[
    {
        "title": "Largest Time for Given Digits",
        "question_content": "Given an array arr of 4 digits, find the latest 24-hour time that can be made using each digit exactly once.\n24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.\nReturn the latest 24-hour time in \"HH:MM\" format. If no valid time can be made, return an empty string.\n&nbsp;\nExample 1:\n\nInput: arr = [1,2,3,4]\nOutput: \"23:41\"\nExplanation: The valid 24-hour times are \"12:34\", \"12:43\", \"13:24\", \"13:42\", \"14:23\", \"14:32\", \"21:34\", \"21:43\", \"23:14\", and \"23:41\". Of these times, \"23:41\" is the latest.\n\nExample 2:\n\nInput: arr = [5,5,5,5]\nOutput: \"\"\nExplanation: There are no valid 24-hour times as \"55:55\" is not valid.\n\n&nbsp;\nConstraints:\n\n\tarr.length == 4\n\t0 <= arr[i] <= 9",
        "solutions": [
            {
                "id": 200693,
                "title": "java-python-3-11-liner-o-64-w-comment-6-ms",
                "content": "`A[i], A[j], A[k], & A[l]` are the `4` elements of `A`, where `i, j, k & l` are the permutation of `0, 1, 2, & 3`, e.g.,\\n`(A[i], A[j], A[k], A[l]) = (A[2], A[0], A[3], A[1])` or `(A[i], A[j], A[k], A[l]) = (A[3], A[1], A[2], A[0])`, etc. \\n\\n`i, j, k & l` can have `4! = 24` different values, but their sum is always same: `6`.\\n\\nTherefore, since `i + j + k + l = 0 + 1 + 2 + 3 = 6`, we have `l = 6 - i - j - k`.\\n\\n```java\\n    public String largestTimeFromDigits(int[] A) {\\n        String ans = \"\";\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = 0; j < 4; ++j) {\\n                for (int k = 0; k < 4; ++k) {\\n                    if (i == j || i == k || j == k) continue; // avoid duplicate among i, j & k.\\n                    String h = \"\" + A[i] + A[j], m = \"\" + A[k] + A[6 - i - j - k], t = h + \":\" + m; // hour, minutes, & time.\\n                    if (h.compareTo(\"24\") < 0 && m.compareTo(\"60\") < 0 && ans.compareTo(t) < 0) ans = t; // hour < 24; minute < 60; update result.\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        ans = \\'\\'\\n        for i, a in enumerate(A):\\n            for j, b in enumerate(A):\\n                for k, c in enumerate(A):\\n                    if i == j or i == k or j == k:\\n                        continue\\n                    hour, minute = str(a) + str(b), str(c) + str(A[6 - i - j - k])\\n                    if hour < \\'24\\' and minute < \\'60\\':\\n                        ans = max(ans, hour + \\':\\' + minute)\\n        return ans\\n```\\nUse Python lib:\\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        for time in itertools.permutations(sorted(A, reverse=True)):\\n            if time[:2] < (2, 4) and time[2] < 6:\\n                return \\'%d%d:%d%d\\' % time\\n        return \\'\\'\\n```\\n**Analysis:**\\n\\nThe inner most  loop at most iterates 4 * 4 * 4 = 64 times.",
                "solutionTags": [],
                "code": "```java\\n    public String largestTimeFromDigits(int[] A) {\\n        String ans = \"\";\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = 0; j < 4; ++j) {\\n                for (int k = 0; k < 4; ++k) {\\n                    if (i == j || i == k || j == k) continue; // avoid duplicate among i, j & k.\\n                    String h = \"\" + A[i] + A[j], m = \"\" + A[k] + A[6 - i - j - k], t = h + \":\" + m; // hour, minutes, & time.\\n                    if (h.compareTo(\"24\") < 0 && m.compareTo(\"60\") < 0 && ans.compareTo(t) < 0) ans = t; // hour < 24; minute < 60; update result.\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        ans = \\'\\'\\n        for i, a in enumerate(A):\\n            for j, b in enumerate(A):\\n                for k, c in enumerate(A):\\n                    if i == j or i == k or j == k:\\n                        continue\\n                    hour, minute = str(a) + str(b), str(c) + str(A[6 - i - j - k])\\n                    if hour < \\'24\\' and minute < \\'60\\':\\n                        ans = max(ans, hour + \\':\\' + minute)\\n        return ans\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        for time in itertools.permutations(sorted(A, reverse=True)):\\n            if time[:2] < (2, 4) and time[2] < 6:\\n                return \\'%d%d:%d%d\\' % time\\n        return \\'\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 200517,
                "title": "python-1-line-check-permutations-o-24",
                "content": "```\\n    def largestTimeFromDigits(self, A):\\n        return max([\"%d%d:%d%d\" % t for t in itertools.permutations(A) if t[:2] < (2, 4) and t[2] < 6] or [\"\"])\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def largestTimeFromDigits(self, A):\\n        return max([\"%d%d:%d%d\" % t for t in itertools.permutations(A) if t[:2] < (2, 4) and t[2] < 6] or [\"\"])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 201564,
                "title": "c-4-lines-0-ms-prev-permutation",
                "content": "There are too many corner cases, so it\\'s easier to just brute-force all 24 combinations and find the maximum over valid ones.\\n\\nThanks to [@AdamTai](https://leetcode.com/adamtai) for pointing out that, since we permutating from smallest to largest, the last valid combination is also the largest one. Therefore, we can sort the input descending, iterate from largest to smallest using ```prev_permutation``` and return the first valid time.\\n```\\nstring largestTimeFromDigits(vector<int>& A) {\\n  sort(begin(A), end(A), greater<int>());\\n  do if ((A[0] < 2 || (A[0] == 2 && A[1] < 4)) && A[2] < 6) \\n      return to_string(A[0]) + to_string(A[1]) + \":\" + to_string(A[2]) + to_string(A[3]);\\n  while (prev_permutation(begin(A), end(A)));\\n  return \"\";\\n}\\n```",
                "solutionTags": [],
                "code": "```prev_permutation```\n```\\nstring largestTimeFromDigits(vector<int>& A) {\\n  sort(begin(A), end(A), greater<int>());\\n  do if ((A[0] < 2 || (A[0] == 2 && A[1] < 4)) && A[2] < 6) \\n      return to_string(A[0]) + to_string(A[1]) + \":\" + to_string(A[2]) + to_string(A[3]);\\n  while (prev_permutation(begin(A), end(A)));\\n  return \"\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822874,
                "title": "python-check-all-permutations-explained",
                "content": "In this problem we are asked to check if some possible permutation of digits creates maximum possible valid time. One way to handle this problem is to just check all possible `4! = 24` permutations: this number is quite small and we can afford it. So, we:\\n\\n1. Create `out = \"\"`, here we will keep our answer.\\n2. Check all permutations of `A`, in python there is special function for it, why not use it: for each permutation check if it is valid time: hour need to be `<=23` and minutes need to be `<=59`, which can be written as `P[2] <= 5`.\\n3. Now, compare new build time with our current maximum and choose best of them. This is all!\\n\\n**Complexity**: time complexity is `O(1)`, but more strictrly it is `O(k!)`, we need to check all permutations in any case, where `k=4` is size of `A`. Space complexity is `O(1)` also, which is more like `O(k)` to keep our answer and compare it with `out`.\\n\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        out = \"\"\\n        for P in permutations(A):\\n            if P[0]*10 + P[1] <= 23 and P[2] <= 5:\\n                out = max(out, str(P[0])+str(P[1]) + \":\" + str(P[2])+str(P[3]))\\n        \\n        return out\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        out = \"\"\\n        for P in permutations(A):\\n            if P[0]*10 + P[1] <= 23 and P[2] <= 5:\\n                out = max(out, str(P[0])+str(P[1]) + \":\" + str(P[2])+str(P[3]))\\n        \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211540,
                "title": "python-simple-obvious-solution",
                "content": "```\\n def largestTimeFromDigits(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: str\\n        \"\"\"\\n        k = sorted(list(itertools.permutations(A)),reverse=True)\\n        \\n        for i in k:            \\n            a,b,c,d = i\\n            su = (a*10+b)\\n            sd = (c*10+d) \\n\\n            if su < 24 and sd <60:\\n                return  f\"{a}{b}:{c}{d}\"\\n                \\n        return \\'\\'\\n```",
                "solutionTags": [],
                "code": "```\\n def largestTimeFromDigits(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: str\\n        \"\"\"\\n        k = sorted(list(itertools.permutations(A)),reverse=True)\\n        \\n        for i in k:            \\n            a,b,c,d = i\\n            su = (a*10+b)\\n            sd = (c*10+d) \\n\\n            if su < 24 and sd <60:\\n                return  f\"{a}{b}:{c}{d}\"\\n                \\n        return \\'\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 823064,
                "title": "java-without-permutations-and-backtracking-beats-100-space-and-runtime",
                "content": "We need to rearrange the array of 4 digits such that it produces largest Time.\\n\\nfor Rearrange the Array I have created function ```rearrange(int maxValue,int index,int[] a)``` details below :\\n \\n Function arguments :\\n  1. maxValue -- maximum value for the given Index\\n  2. index -- for which index we need to rearrange the array\\n  3.  a[] - input array containing 4 digits\\n\\nreturns **TRUE** if we have found the **maximum element for index in a[]** else returns **FALSE**\\n\\nNow, Using above function we have to rearrange the array from left to right. \\n\\nThere are 2 type of cases, as mentioned below :\\n\\n***CASE 1***  - **23:59 , 19:59 , 09:59**\\n\\n\\tif 1st digit is 2 then 2nd digit value can  be 0<=value<=3\\n\\telse if 1st digit is less than 2 then 2nd digit value can be 0<=value<=9\\n\\tfor 3rd digit 0<=value<=5\\n\\tfor 4rth digit 0<=value<=9\\n\\nBelow code summarize the above cases and rearrange the array:\\n```(rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a))```\\n\\n***CASE 2*** : **06:26 , 16:26**\\n\\n**Now Case 1 will fail, when 1st digit can be 0 or 1**\\n\\nso, when Case 1 returns false value, then we can check Case 2 digits condition and rearrange them :\\n\\n\\t1st digit  :  0<=value<=1\\n\\t2nd digit  : 0<=value<=9\\n\\t3rd digit  : 0<=value<=5\\n\\t4rth digit  : 0<=value<=9\\n\\nbelow code summarize the above cases to rearrange:\\n```(rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a))```\\n\\nSo, after adding both ( CASE 1 || CASE 2), we get the below code:\\n\\n```\\nboolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n```\\n\\nAfter rearrangement we just simply convert the array to time format\\n\\nBelow is the final Code\\n\\n```\\nclass Solution {\\n    \\n    private boolean rearrange(int maxValue,int index,int[] a){\\n        int max = -1;\\n\\t\\t\\n\\t\\t// find the maximum number for the given index which should be less than equal\\n\\t\\t// to maxValue\\n        for(int i = index; i<a.length;i++) if(a[i]<=maxValue && (max==-1 || a[max]<a[i])) max = i;\\n\\t\\t// number not found\\n        if(max==-1) return false;\\n    \\n\\t// put the number to its correct index \\n\\t// swap it put at correct position\\n        int temp = a[max];\\n        a[max] = a[index];\\n        a[index] = temp;\\n        return true;\\n    }\\n\\t\\n\\t\\n    \\n    public String largestTimeFromDigits(int[] a) {\\n        boolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n        \\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(!res) return sb.toString();\\n        \\n        return sb.append(String.valueOf(a[0]))\\n          .append(String.valueOf(a[1]))\\n          .append(\\':\\')\\n          .append(String.valueOf(a[2]))\\n          .append(String.valueOf(a[3])).toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "```rearrange(int maxValue,int index,int[] a)```\n```(rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a))```\n```(rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a))```\n```\\nboolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822967,
                "title": "c-just-loop-and-check-validity-on-the-fly-0-ms-beats-100-in-time",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& a) {\\n        string ans = \"\"; int mx = -1, h1 = -1, h2 = -1, m1 = -1, m2 = -1;\\n        \\n        for(int i=0; i<4; ++i) {\\n            if(a[i] > 2) continue;\\n            \\n            for(int j=0; j<4; ++j) {\\n                if(j == i) continue;\\n                if(a[i] == 2 && a[j] > 3) continue;\\n                \\n                for(int k=0; k<4; ++k) {\\n                    if(k == j || k == i) continue;\\n                    if(a[k] > 5) continue;\\n                    \\n                    int l = 6-i-j-k;\\n                    if(l == k || l == j || l == i) continue;\\n\\n                    int val = (a[l] + (a[k] * 10)) + (a[j] + (a[i] * 10)) * 60; // value of time in minutes.\\n\\n                    if(mx < val) {\\n                        mx = val;\\n                        h1 = a[i], h2 = a[j], m1 = a[k], m2 = a[l];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(h1 == -1 || h2 == -1 || m1 == -1 || m2 == -1) return \"\";\\n        \\n        ans = to_string(h1) + to_string(h2) + \":\" + to_string(m1) + to_string(m2);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIf you have any questions, feel free to ask. If you like the solution, please **Upvote!**\\nHave a great day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& a) {\\n        string ans = \"\"; int mx = -1, h1 = -1, h2 = -1, m1 = -1, m2 = -1;\\n        \\n        for(int i=0; i<4; ++i) {\\n            if(a[i] > 2) continue;\\n            \\n            for(int j=0; j<4; ++j) {\\n                if(j == i) continue;\\n                if(a[i] == 2 && a[j] > 3) continue;\\n                \\n                for(int k=0; k<4; ++k) {\\n                    if(k == j || k == i) continue;\\n                    if(a[k] > 5) continue;\\n                    \\n                    int l = 6-i-j-k;\\n                    if(l == k || l == j || l == i) continue;\\n\\n                    int val = (a[l] + (a[k] * 10)) + (a[j] + (a[i] * 10)) * 60; // value of time in minutes.\\n\\n                    if(mx < val) {\\n                        mx = val;\\n                        h1 = a[i], h2 = a[j], m1 = a[k], m2 = a[l];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(h1 == -1 || h2 == -1 || m1 == -1 || m2 == -1) return \"\";\\n        \\n        ans = to_string(h1) + to_string(h2) + \":\" + to_string(m1) + to_string(m2);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202234,
                "title": "java-super-short-solution",
                "content": "```\\n    public String largestTimeFromDigits(int[] A) {\\n        for(int h = 23; h >= 0; h--) {\\n            for(int m = 59; m >= 0; m--) {\\n                \\n                boolean flag = true;\\n                int[] count = new int[10];\\n                \\n                count[h < 10 ? 0 : h / 10]++;\\n                count[h < 10 ? h : h % 10]++;\\n                count[m < 10 ? 0 : m / 10]++;\\n                count[m < 10 ? m : m % 10]++;                \\n\\n                \\n                for(int e : A) {\\n                    if(--count[e] < 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag) return String.format(\"%02d:%02d\", h, m);\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String largestTimeFromDigits(int[] A) {\\n        for(int h = 23; h >= 0; h--) {\\n            for(int m = 59; m >= 0; m--) {\\n                \\n                boolean flag = true;\\n                int[] count = new int[10];\\n                \\n                count[h < 10 ? 0 : h / 10]++;\\n                count[h < 10 ? h : h % 10]++;\\n                count[m < 10 ? 0 : m / 10]++;\\n                count[m < 10 ? m : m % 10]++;                \\n\\n                \\n                for(int e : A) {\\n                    if(--count[e] < 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag) return String.format(\"%02d:%02d\", h, m);\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 309364,
                "title": "100-c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring largestTimeFromDigits(vector<int>& A) {\\n\\t\\t\\tstring ans = \"\";\\n\\t\\t\\tsort(A.begin(),A.end());\\n\\t\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring temp = to_string(A[0])+to_string(A[1])+\":\"\\n\\t\\t\\t\\t\\t\\t+to_string(A[2])+to_string(A[3]);\\n\\t\\t\\t\\t\\tif(temp > ans) ans = temp;\\n\\t\\t\\t\\t}       \\n\\t\\t\\t}while(next_permutation(A.begin(),A.end()));\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring largestTimeFromDigits(vector<int>& A) {\\n\\t\\t\\tstring ans = \"\";\\n\\t\\t\\tsort(A.begin(),A.end());\\n\\t\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring temp = to_string(A[0])+to_string(A[1])+\":\"\\n\\t\\t\\t\\t\\t\\t+to_string(A[2])+to_string(A[3]);\\n\\t\\t\\t\\t\\tif(temp > ans) ans = temp;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 450045,
                "title": "java-greedy-dfs-backtracking-solution-very-easy-to-understand-1ms",
                "content": "Since we want to find the max, we should try the max digit allowed from left to right.\\nFor exmaple, at the first digit, we can try 2, then 1, then 0.\\nat the 2nd digit, if the 1st on is 2, we try 3,2,....,0. Otherwise, try 9,8,7,....,1,0.\\nSince we are following the numerical order, it guarantees that the first permutarion found by the DFS helper is the max.  \\n```\\nclass Solution {\\n    boolean helper(int[] count, int loc, int[] ret) {\\n        if (loc > 3) return true;\\n        int e = 9;\\n        if (loc==0) {\\n            e = 2;\\n        } else if (loc==1) {\\n            if (ret[0]==2) e = 3;\\n        } else if (loc==2) {\\n            e = 5;\\n        }\\n        \\n        for (int i=e; i>=0; i--) {\\n            if (count[i]> 0) {\\n                ret[loc] = i;\\n                count[i]--;\\n                if (helper(count, loc+1, ret)) return true;\\n                count[i]++;\\n                ret[loc] = -1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        int[] ret = new int[4];\\n        Arrays.fill(ret, -1);\\n        int[] count = new int[10];\\n        for (int a: A) count[a]++;\\n        if (helper(count, 0, ret)) {\\n            return \"\"+ret[0]+ret[1]+\":\"+ret[2]+ret[3];\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean helper(int[] count, int loc, int[] ret) {\\n        if (loc > 3) return true;\\n        int e = 9;\\n        if (loc==0) {\\n            e = 2;\\n        } else if (loc==1) {\\n            if (ret[0]==2) e = 3;\\n        } else if (loc==2) {\\n            e = 5;\\n        }\\n        \\n        for (int i=e; i>=0; i--) {\\n            if (count[i]> 0) {\\n                ret[loc] = i;\\n                count[i]--;\\n                if (helper(count, loc+1, ret)) return true;\\n                count[i]++;\\n                ret[loc] = -1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        int[] ret = new int[4];\\n        Arrays.fill(ret, -1);\\n        int[] count = new int[10];\\n        for (int a: A) count[a]++;\\n        if (helper(count, 0, ret)) {\\n            return \"\"+ret[0]+ret[1]+\":\"+ret[2]+ret[3];\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536484,
                "title": "python3-easy-understanding-with-explanation",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n# From 23:59 to 00:00 go over every minute of 24 hours. If A meets this requirement, then totaly 24 * 60 minutes. Since using sort during the ongoing judegment process, so the time complexity is low.\\n        A.sort()\\n        for h in range(23, -1, -1):\\n            for m in range(59, -1, -1):\\n                t = [h//10, h % 10, m // 10, m % 10]\\n                ts = sorted(t)\\n                if ts == A:\\n                    return str(t[0]) + str(t[1]) +\\':\\' + str(t[2]) + str(t[3])\\n        return \\'\\'\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n# From 23:59 to 00:00 go over every minute of 24 hours. If A meets this requirement, then totaly 24 * 60 minutes. Since using sort during the ongoing judegment process, so the time complexity is low.\\n        A.sort()\\n        for h in range(23, -1, -1):\\n            for m in range(59, -1, -1):\\n                t = [h//10, h % 10, m // 10, m % 10]\\n                ts = sorted(t)\\n                if ts == A:\\n                    return str(t[0]) + str(t[1]) +\\':\\' + str(t[2]) + str(t[3])\\n        return \\'\\'\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 823156,
                "title": "python-simple-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=QJeI-gBTp1k)\\nhttps://www.youtube.com/watch?v=QJeI-gBTp1k\\n```\\nfrom itertools import permutations\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        arr = list(permutations(sorted(A, reverse=True)))\\n        \\n        for h1, h2, m1, m2 in arr:\\n            if h1 * 10 + h2 < 24 and m1 * 10 + m2 < 60:\\n                return f\\'{h1}{h2}:{m1}{m2}\\'\\n        return \\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        arr = list(permutations(sorted(A, reverse=True)))\\n        \\n        for h1, h2, m1, m2 in arr:\\n            if h1 * 10 + h2 < 24 and m1 * 10 + m2 < 60:\\n                return f\\'{h1}{h2}:{m1}{m2}\\'\\n        return \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200823,
                "title": "java-iterative-15-lines",
                "content": "```java\\npublic String largestTimeFromDigits(int[] a) {\\n        LinkedList<String> q = new LinkedList<>();\\n        q.add(\"\");\\n        for (int n : a)\\n            for (int size = q.size(); size > 0; size--) {\\n                String s = q.poll();\\n                for (int i = 0; i <= s.length(); i++)\\n                    q.add(s.substring(0, i) + n + s.substring(i));\\n            }\\n        String largest = \"\";\\n        for (String s : q) {\\n            s = s.substring(0, 2) + \":\" + s.substring(2);\\n            if (s.charAt(3) < \\'6\\' && s.compareTo(\"24:00\") < 0 && s.compareTo(largest) > 0)\\n                largest = s;\\n        }\\n        return largest;\\n    }",
                "solutionTags": [],
                "code": "```java\\npublic String largestTimeFromDigits(int[] a) {\\n        LinkedList<String> q = new LinkedList<>();\\n        q.add(\"\");\\n        for (int n : a)\\n            for (int size = q.size(); size > 0; size--) {\\n                String s = q.poll();\\n                for (int i = 0; i <= s.length(); i++)\\n                    q.add(s.substring(0, i) + n + s.substring(i));\\n            }\\n        String largest = \"\";\\n        for (String s : q) {\\n            s = s.substring(0, 2) + \":\" + s.substring(2);\\n            if (s.charAt(3) < \\'6\\' && s.compareTo(\"24:00\") < 0 && s.compareTo(largest) > 0)\\n                largest = s;\\n        }\\n        return largest;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 207126,
                "title": "elegant-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        string res = \"\";\\n        do {\\n            string hours = {(char)(A[0] + \\'0\\'), (char)(A[1] + \\'0\\')}, minutes = {(char)(A[2] + \\'0\\'), (char)(A[3] + \\'0\\')};\\n            res = (stoi(hours) <= 23 && stoi(minutes) <= 59) ? (hours + \":\" + minutes) : res;\\n        } while(next_permutation(A.begin(), A.end()));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        string res = \"\";\\n        do {\\n            string hours = {(char)(A[0] + \\'0\\'), (char)(A[1] + \\'0\\')}, minutes = {(char)(A[2] + \\'0\\'), (char)(A[3] + \\'0\\')};\\n            res = (stoi(hours) <= 23 && stoi(minutes) <= 59) ? (hours + \":\" + minutes) : res;\\n        } while(next_permutation(A.begin(), A.end()));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823706,
                "title": "find-all-permutations-easy-to-understand-solution-with-steps",
                "content": "**Steps :**\\n1) Sort the input array\\n2) Find all the valid permutations and store in a list\\n3) Since the list is sorted, the last element in the list is our required timestamp\\n4) If list is empty then return an empty string\\n\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        \\n        Arrays.sort(A);\\n                \\n        List<String> list = new ArrayList<>();\\n        \\n        findValidPermutations(A, list, new StringBuilder(), new boolean[A.length]);\\n        \\n        if(list.size() == 0)\\n            return \"\";\\n        \\n        String lastString = list.get(list.size() - 1);\\n        \\n        return formatTimeStamp(lastString);\\n        \\n    }\\n    \\n    private void findValidPermutations(int[] A, List<String> list, StringBuilder sb, boolean[] used){\\n        \\n        if(sb.length() == A.length){\\n            if(isValid(sb.toString()))\\n                list.add(sb.toString());\\n            return;\\n        }\\n        \\n        for(int i = 0; i < A.length; i++){\\n            \\n            if(used[i])\\n                continue;\\n            \\n            if(i > 0 && A[i] == A[i-1] && !used[i - 1])\\n                continue;\\n            \\n            used[i] = true;\\n            sb.append(A[i]);\\n            \\n            findValidPermutations(A, list, sb, used);\\n            \\n            sb.deleteCharAt(sb.length() - 1);\\n            used[i] = false;\\n        }\\n    }\\n    \\n    private boolean isValid(String str){\\n        \\n        int hour = Integer.valueOf( str.substring(0,2));\\n        int minute = Integer.valueOf( str.substring(2, 4));\\n \\n        return hour < 24 && minute <= 59;\\n        \\n    }\\n    \\n    private String formatTimeStamp(String str){\\n        \\n        String hour = str.substring(0,2);\\n        String minute = str.substring(2,4);\\n        \\n        return hour + \":\" + minute;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        \\n        Arrays.sort(A);\\n                \\n        List<String> list = new ArrayList<>();\\n        \\n        findValidPermutations(A, list, new StringBuilder(), new boolean[A.length]);\\n        \\n        if(list.size() == 0)\\n            return \"\";\\n        \\n        String lastString = list.get(list.size() - 1);\\n        \\n        return formatTimeStamp(lastString);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 823571,
                "title": "java-detailed-short-code-answer-array-permutation-followed-by-the-validity-check",
                "content": "To do so, we first need to perform the **permutation** of the array number, then pick all the **valid time combination** and find the **max** one. Here is the code:\\n```\\n    public String largestTimeFromDigits(int[] A) {\\n        int ans = -1; // If we cannot find a valid answer, it will keep as -1, then we will return \"\".\\n        // Choose different indices i, j, k, l as a permutation of 0, 1, 2, 3\\n        for (int i = 0; i < 4; ++i)\\n            for (int j = 0; j < 4; ++j) if (j != i)\\n                for (int k = 0; k < 4; ++k) if (k != i && k != j) {\\n                    int l = 6 - i - j - k;\\n                    // For each permutation of A[i], read out the time and\\n                    // record the largest legal time.\\n                    int hours = 10 * A[i] + A[j];\\n                    int mins = 10 * A[k] + A[l];\\n                    if (hours < 24  &&  mins < 60)\\n                        ans = Math.max(ans, hours * 60 + mins);\\n                }\\n        return ans >= 0 ? String.format(\"%02d:%02d\", ans / 60, ans % 60) : \"\";\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public String largestTimeFromDigits(int[] A) {\\n        int ans = -1; // If we cannot find a valid answer, it will keep as -1, then we will return \"\".\\n        // Choose different indices i, j, k, l as a permutation of 0, 1, 2, 3\\n        for (int i = 0; i < 4; ++i)\\n            for (int j = 0; j < 4; ++j) if (j != i)\\n                for (int k = 0; k < 4; ++k) if (k != i && k != j) {\\n                    int l = 6 - i - j - k;\\n                    // For each permutation of A[i], read out the time and\\n                    // record the largest legal time.\\n                    int hours = 10 * A[i] + A[j];\\n                    int mins = 10 * A[k] + A[l];\\n                    if (hours < 24  &&  mins < 60)\\n                        ans = Math.max(ans, hours * 60 + mins);\\n                }\\n        return ans >= 0 ? String.format(\"%02d:%02d\", ans / 60, ans % 60) : \"\";\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823132,
                "title": "c-very-easy-newbie-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans=\"\";\\n        string res=\"\";\\n        for(auto i:A)\\n        {\\n            res+=to_string(i);\\n        }\\n        \\n        sort(res.begin(),res.end());\\n        do\\n        {\\n            string sub1=res.substr(0,2);\\n            string sub2=res.substr(2);\\n            int f=stoi(sub1);\\n            int sec=stoi(sub2);\\n            if(f>=0&&f<=23&&sec>=0&&sec<=59)\\n            {\\n                ans=max(ans,sub1+\":\"+sub2);\\n            }\\n           \\n        }while(next_permutation(res.begin(),res.end()));\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans=\"\";\\n        string res=\"\";\\n        for(auto i:A)\\n        {\\n            res+=to_string(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 822956,
                "title": "c-simple-step-by-step-solution-explained-100-time-55-space",
                "content": "Man, wasn\\'t this the tricky one! But my bad for trying to filter too many edge cases initially, instead of trusting the rest of my logic a bit more.\\n\\nAnyway, let\\'s go with first things first: I declared a couple of class variables: `res` (our result) and `digits`, an array to store the frequency of the digits, so that they could be used by my helper `addMaxEqualLowerThan`, which in turn was created to avoid needless code duplications.\\n\\nThe harder part is to form the largest possible HH part with our digits: if we do that, the rest is relatively simple, as we just need to create the largest possible MM part.\\n\\nTo do so, we need to consider a few more things, but let\\'s move on with the logic: first of all we need to populate `digits` so that it has the frequency of the digit `i` stored in the `i`th cell.\\n\\nOnce we have done that, we can quickly loop through it and check our exit conditions:\\n* having reached `i == 2` and having `sum == 0` means we cannot form any hour;\\n* being at `i == 3` and having `sum == 1` when `digits[2] != 0` again means we cannot form hours (ie: we only have a `2` in that range);\\n* being at `i == 5` and having `sum < 2` means we might be able to form a hour, but then we would like a necessary digit (`<= 5`) for the minutes.\\n\\nIf did not return `res` and are still going on, time to check immediately for the best case: HH starting with `2`, a case we consider onlu if `sum > 2` (and, incidentally, the sole reason for which I did not make `sum` an internal variable of the second loop).\\n\\nWe add `2` (in this specific instance, since we know that `digits[2]`, `addMaxEqualLowerThan(2)` is equivalent to `digits[2]--; res.push_back(\\'2\\');` and then we call our helper again to get any digit `<= 3`; if by then our solution `reas` is still just `\"2\"`, we backtrack, resetting `res` to be empty.\\n\\nIf that was the case, we just invoke our helper to add any digit `<= 1`, followed by any digit `<= 9` (which would be just any digit, period, I guess?).\\n\\nTime to add `\\':\\'` and to easily slide into the MM part: we add any digit `<= 5`, followed by any digit `<= 9`.\\n\\nIf by any chance by now we got a `res` under `5` characters of length, we return an empty string, otherwise we return our successfully computed largest possible time :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\n    // support variables\\n\\tstring res;\\n    int digits[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, sum = 0;\\npublic:\\n    void addMaxEqualLowerThan(int n) {\\n        // updates both res and digits with/for the bigger number <=n\\n\\t\\tfor (int i = n; i >= 0; i--) if (digits[i]) {\\n            res.push_back(i + \\'0\\');\\n            digits[i]--;\\n            break;\\n        }\\n    }\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        // populating digits\\n\\t\\tfor (int i = 0; i < 4; i++) digits[arr[i]]++;\\n        // exit condition: no single digit less than 3, no 2 digits less than 6\\n        for (int i = 0; i < 6; i++) {\\n            sum += digits[i];\\n            if (i == 2 && !sum || i == 3 && digits[2] && sum < 2 || i ==5 && sum < 2) return res;\\n        }\\n        // checking for 2, trickier case\\n        if (digits[2] && sum > 2) {\\n            addMaxEqualLowerThan(2);\\n            addMaxEqualLowerThan(3);\\n            // if not such a number is found, we fold and move to the next\\n            if (res == \"2\") {\\n                digits[2]++;\\n                res = \"\";\\n            }\\n        }\\n        // checking for 1 and 0\\n        if (!res.size()) {\\n            addMaxEqualLowerThan(1);\\n            addMaxEqualLowerThan(9);\\n        }\\n        // and we are done with the hours\\n        res.push_back(\\':\\');\\n        // now with the mins\\n        addMaxEqualLowerThan(5);\\n        addMaxEqualLowerThan(9);\\n        return res.size() == 5 ? res : \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\n    // support variables\\n\\tstring res;\\n    int digits[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, sum = 0;\\npublic:\\n    void addMaxEqualLowerThan(int n) {\\n        // updates both res and digits with/for the bigger number <=n\\n\\t\\tfor (int i = n; i >= 0; i--) if (digits[i]) {\\n            res.push_back(i + \\'0\\');\\n            digits[i]--;\\n            break;\\n        }\\n    }\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        // populating digits\\n\\t\\tfor (int i = 0; i < 4; i++) digits[arr[i]]++;\\n        // exit condition: no single digit less than 3, no 2 digits less than 6\\n        for (int i = 0; i < 6; i++) {\\n            sum += digits[i];\\n            if (i == 2 && !sum || i == 3 && digits[2] && sum < 2 || i ==5 && sum < 2) return res;\\n        }\\n        // checking for 2, trickier case\\n        if (digits[2] && sum > 2) {\\n            addMaxEqualLowerThan(2);\\n            addMaxEqualLowerThan(3);\\n            // if not such a number is found, we fold and move to the next\\n            if (res == \"2\") {\\n                digits[2]++;\\n                res = \"\";\\n            }\\n        }\\n        // checking for 1 and 0\\n        if (!res.size()) {\\n            addMaxEqualLowerThan(1);\\n            addMaxEqualLowerThan(9);\\n        }\\n        // and we are done with the hours\\n        res.push_back(\\':\\');\\n        // now with the mins\\n        addMaxEqualLowerThan(5);\\n        addMaxEqualLowerThan(9);\\n        return res.size() == 5 ? res : \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822907,
                "title": "python-simplest-explained-easy-to-understand-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        # help function to turn number to clock-format:\\n        def to_clock(num):\\n            right = str(num%100)\\n            while len(right) < 2: right = \\'0\\' + right\\n            num //= 100\\n            left = str(num)\\n            while len(left) < 2: left = \\'0\\' + left\\n            return left + \\':\\' + right\\n                \\n        # get all permutations of number list\\n        per = list(itertools.permutations(A))\\n        nums = [int(\\'\\'.join(map(str,per[i]))) for i in range(len(per))]\\n        \\n        # find permutations which can be a valid time\\n        valids = [num for num in nums if num<2359 and num%100<60]\\n        \\n        if len(valids) == 0:\\n            return \"\"\\n        \\n        # use maximum of list\\n        num = max(valids)\\n        return to_clock(num)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        # help function to turn number to clock-format:\\n        def to_clock(num):\\n            right = str(num%100)\\n            while len(right) < 2: right = \\'0\\' + right\\n            num //= 100\\n            left = str(num)\\n            while len(left) < 2: left = \\'0\\' + left\\n            return left + \\':\\' + right\\n                \\n        # get all permutations of number list\\n        per = list(itertools.permutations(A))\\n        nums = [int(\\'\\'.join(map(str,per[i]))) for i in range(len(per))]\\n        \\n        # find permutations which can be a valid time\\n        valids = [num for num in nums if num<2359 and num%100<60]\\n        \\n        if len(valids) == 0:\\n            return \"\"\\n        \\n        # use maximum of list\\n        num = max(valids)\\n        return to_clock(num)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 823747,
                "title": "java-solution-easy-code",
                "content": "* ***Please upvote if helpful!!***\\n\\n```\\nclass Solution {\\n    List<List<Integer>> resultList = new ArrayList<>();\\n    public String largestTimeFromDigits(int[] numArray) {\\n\\n        if (numArray[0] == 0 && numArray[1] == 0 && numArray[2] == 0 && numArray[3] == 0) return \"00:00\";\\n\\n        String result = \"\";\\n        boolean[] visited = new boolean[numArray.length];\\n        findPermutation(numArray, new ArrayList<>(), visited);\\n        int maxNum = Integer.MIN_VALUE;\\n        int firstDigit = -1;\\n        int secondDigit = -1;\\n        int thirdDigit = -1;\\n        int fourthDigit = -1;\\n\\n        int f = 0;\\n        int s = 0;\\n        int t = 0;\\n        int fo = 0;\\n        boolean isVisited = false;\\n        for (List<Integer> list : resultList) {\\n\\n            firstDigit = list.get(0);\\n            secondDigit = list.get(1);\\n            thirdDigit = list.get(2);\\n            fourthDigit = list.get(3);\\n            int num = firstDigit * 1000 + secondDigit * 100 + thirdDigit * 10 + fourthDigit;\\n            if (num <= 2359 && thirdDigit < 6 && num > maxNum) {\\n                isVisited = true;\\n                maxNum = num;\\n                f = list.get(0);\\n                s = list.get(1);\\n                t = list.get(2);\\n                fo = list.get(3);\\n            }\\n\\n        }\\n\\n        if (isVisited)\\n            result = f + \"\" + s + \":\" + t + \"\" + fo;\\n        else\\n            result = \"\";\\n        return result;\\n\\n\\n    }\\n\\n    private void findPermutation(int[] numArray, List<Integer> currList, boolean[] visited) {\\n\\n        if (currList.size() == numArray.length) {\\n            resultList.add(new ArrayList<>(currList));\\n            return;\\n        }\\n\\n        for (int i = 0; i < numArray.length; i++) {\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            currList.add(numArray[i]);\\n            findPermutation(numArray, currList, visited);\\n            currList.remove(currList.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> resultList = new ArrayList<>();\\n    public String largestTimeFromDigits(int[] numArray) {\\n\\n        if (numArray[0] == 0 && numArray[1] == 0 && numArray[2] == 0 && numArray[3] == 0) return \"00:00\";\\n\\n        String result = \"\";\\n        boolean[] visited = new boolean[numArray.length];\\n        findPermutation(numArray, new ArrayList<>(), visited);\\n        int maxNum = Integer.MIN_VALUE;\\n        int firstDigit = -1;\\n        int secondDigit = -1;\\n        int thirdDigit = -1;\\n        int fourthDigit = -1;\\n\\n        int f = 0;\\n        int s = 0;\\n        int t = 0;\\n        int fo = 0;\\n        boolean isVisited = false;\\n        for (List<Integer> list : resultList) {\\n\\n            firstDigit = list.get(0);\\n            secondDigit = list.get(1);\\n            thirdDigit = list.get(2);\\n            fourthDigit = list.get(3);\\n            int num = firstDigit * 1000 + secondDigit * 100 + thirdDigit * 10 + fourthDigit;\\n            if (num <= 2359 && thirdDigit < 6 && num > maxNum) {\\n                isVisited = true;\\n                maxNum = num;\\n                f = list.get(0);\\n                s = list.get(1);\\n                t = list.get(2);\\n                fo = list.get(3);\\n            }\\n\\n        }\\n\\n        if (isVisited)\\n            result = f + \"\" + s + \":\" + t + \"\" + fo;\\n        else\\n            result = \"\";\\n        return result;\\n\\n\\n    }\\n\\n    private void findPermutation(int[] numArray, List<Integer> currList, boolean[] visited) {\\n\\n        if (currList.size() == numArray.length) {\\n            resultList.add(new ArrayList<>(currList));\\n            return;\\n        }\\n\\n        for (int i = 0; i < numArray.length; i++) {\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            currList.add(numArray[i]);\\n            findPermutation(numArray, currList, visited);\\n            currList.remove(currList.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823627,
                "title": "python-3-largest-time-for-given-digits",
                "content": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n\\t\\t # if 0, 1 or 2 is not present in the list then just return blank\\n        if 0 not in A and 1 not in A and 2 not in A:\\n            return \"\"\\n    \\n        max_time= \"-9\"\\n        # generate all the permuations of given digits\\n        for i in set(list(permutations(A))):    \\n\\t\\t    # keep time starting with either 0, 1, or 2. Others are invalid range.\\n            if 0 <= i[0] <= 2:    \\n                temp = str(\\'\\'.join(str(t) for t in i))\\n\\t\\t\\t\\t # check for 23:59 constraint\\n                if int(temp) <= 2359 and int(temp[2:]) < 60:    \\n                    if int(temp) > int(max_time):\\n                        max_time = temp\\n        \\n        \\n        if max_time == \"-9\":\\n            return \"\"\\n        else:\\n            return max_time[:2]+\":\"+max_time[2:]\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n\\t\\t # if 0, 1 or 2 is not present in the list then just return blank\\n        if 0 not in A and 1 not in A and 2 not in A:\\n            return \"\"\\n    \\n        max_time= \"-9\"\\n        # generate all the permuations of given digits\\n        for i in set(list(permutations(A))):    \\n\\t\\t    # keep time starting with either 0, 1, or 2. Others are invalid range.\\n            if 0 <= i[0] <= 2:    \\n                temp = str(\\'\\'.join(str(t) for t in i))\\n\\t\\t\\t\\t # check for 23:59 constraint\\n                if int(temp) <= 2359 and int(temp[2:]) < 60:    \\n                    if int(temp) > int(max_time):\\n                        max_time = temp\\n        \\n        \\n        if max_time == \"-9\":\\n            return \"\"\\n        else:\\n            return max_time[:2]+\":\"+max_time[2:]\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 244890,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public static String largestTimeFromDigits(int[] A) {\\n        StringBuilder res = backtrack(new StringBuilder(), new StringBuilder(), A, new boolean[A.length]);\\n        if(res.length() == 4) {\\n        \\tres.insert(2,\":\");\\n        \\treturn res.toString();\\n        }else {\\n        \\treturn res.toString();\\n        }\\n    }\\n    \\n    private static StringBuilder backtrack(StringBuilder res, StringBuilder temp, int[] A, boolean[] used){\\n        if(temp.length() == 4 && Integer.valueOf(temp.toString()) <= 2359\\n           && Integer.valueOf(temp.substring(2).toString()) < 60){\\n            int tempTime = Integer.valueOf(temp.toString());\\n            return res.length() == 0 ? new StringBuilder(temp) : Integer.valueOf(res.toString()) > tempTime ? res : new StringBuilder(temp);\\n        }else{\\n            for(int i = 0; i < A.length; i++){\\n                if(used[i] || i > 0 && A[i] == A[i-1] && !used[i-1]) continue;\\n                used[i] = true;\\n                temp.append(A[i]);\\n                res = backtrack(res, temp, A, used);\\n                used[i] = false;\\n                temp.deleteCharAt(temp.length() - 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static String largestTimeFromDigits(int[] A) {\\n        StringBuilder res = backtrack(new StringBuilder(), new StringBuilder(), A, new boolean[A.length]);\\n        if(res.length() == 4) {\\n        \\tres.insert(2,\":\");\\n        \\treturn res.toString();\\n        }else {\\n        \\treturn res.toString();\\n        }\\n    }\\n    \\n    private static StringBuilder backtrack(StringBuilder res, StringBuilder temp, int[] A, boolean[] used){\\n        if(temp.length() == 4 && Integer.valueOf(temp.toString()) <= 2359\\n           && Integer.valueOf(temp.substring(2).toString()) < 60){\\n            int tempTime = Integer.valueOf(temp.toString());\\n            return res.length() == 0 ? new StringBuilder(temp) : Integer.valueOf(res.toString()) > tempTime ? res : new StringBuilder(temp);\\n        }else{\\n            for(int i = 0; i < A.length; i++){\\n                if(used[i] || i > 0 && A[i] == A[i-1] && !used[i-1]) continue;\\n                used[i] = true;\\n                temp.append(A[i]);\\n                res = backtrack(res, temp, A, used);\\n                used[i] = false;\\n                temp.deleteCharAt(temp.length() - 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529280,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        do{\\n            int hours = arr[0] * 10 + arr[1];\\n            int minutes = arr[2] * 10 + arr[3];\\n            \\n            if(hours<24 && minutes<60){\\n                string time = \"\";\\n                if(hours<10){\\n                    time+=\"0\";\\n                }\\n                time += to_string(hours);\\n                time += \":\";\\n                \\n                if(minutes<10){\\n                    time += \"0\";\\n                }\\n                \\n                time += to_string(minutes);\\n                return time;\\n            }\\n        }while(prev_permutation(arr.begin(), arr.end()));\\n        \\n        return \"\";\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        curMax = -1\\n        curStr = \"\"\\n        for permutation in set(permutations(arr)):\\n            a, b, c, d = permutation\\n            hours = a*10 + b\\n            minutes = c*10 + d\\n            if hours > 23 or minutes > 59:\\n                pass\\n            elif hours*60 + minutes > curMax:\\n                curMax = hours*60 + minutes\\n                curStr = str(a) + str(b) + \":\" + str(c) + str(d)\\n\\n        return curStr\\n```\\n\\n```Java []\\nclass Solution {\\n    private boolean rearrange(int maxValue,int index,int[] a){\\n        int max = -1;\\n\\t\\t\\n        for(int i = index; i<a.length;i++) if(a[i]<=maxValue && (max==-1 || a[max]<a[i])) max = i;\\n        if(max==-1) return false;\\n\\n        int temp = a[max];\\n        a[max] = a[index];\\n        a[index] = temp;\\n        return true;\\n    }\\n    public String largestTimeFromDigits(int[] a) {\\n        boolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(!res) return sb.toString();\\n        \\n        return sb.append(String.valueOf(a[0]))\\n          .append(String.valueOf(a[1]))\\n          .append(\\':\\')\\n          .append(String.valueOf(a[2]))\\n          .append(String.valueOf(a[3])).toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        do{\\n            int hours = arr[0] * 10 + arr[1];\\n            int minutes = arr[2] * 10 + arr[3];\\n            \\n            if(hours<24 && minutes<60){\\n                string time = \"\";\\n                if(hours<10){\\n                    time+=\"0\";\\n                }\\n                time += to_string(hours);\\n                time += \":\";\\n                \\n                if(minutes<10){\\n                    time += \"0\";\\n                }\\n                \\n                time += to_string(minutes);\\n                return time;\\n            }\\n        }while(prev_permutation(arr.begin(), arr.end()));\\n        \\n        return \"\";\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        curMax = -1\\n        curStr = \"\"\\n        for permutation in set(permutations(arr)):\\n            a, b, c, d = permutation\\n            hours = a*10 + b\\n            minutes = c*10 + d\\n            if hours > 23 or minutes > 59:\\n                pass\\n            elif hours*60 + minutes > curMax:\\n                curMax = hours*60 + minutes\\n                curStr = str(a) + str(b) + \":\" + str(c) + str(d)\\n\\n        return curStr\\n```\n```Java []\\nclass Solution {\\n    private boolean rearrange(int maxValue,int index,int[] a){\\n        int max = -1;\\n\\t\\t\\n        for(int i = index; i<a.length;i++) if(a[i]<=maxValue && (max==-1 || a[max]<a[i])) max = i;\\n        if(max==-1) return false;\\n\\n        int temp = a[max];\\n        a[max] = a[index];\\n        a[index] = temp;\\n        return true;\\n    }\\n    public String largestTimeFromDigits(int[] a) {\\n        boolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(!res) return sb.toString();\\n        \\n        return sb.append(String.valueOf(a[0]))\\n          .append(String.valueOf(a[1]))\\n          .append(\\':\\')\\n          .append(String.valueOf(a[2]))\\n          .append(String.valueOf(a[3])).toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636459,
                "title": "python3-8-lines-permutations-t-m-96-78",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\n        ans = []\\n\\n        for d0, d1, d2, d3 in list(permutations(arr,4)):\\n            hrs, mins = 10*d0+d1, 10*d2+d3\\n\\n            if hrs < 24 and mins < 60:\\n                ans.append((hrs,mins))\\n\\n        if not ans: return \\'\\'        \\n        hrs, mins = max(ans)\\n        return  str(hrs).rjust(2,\\'0\\')+\\':\\'+ str(mins).rjust(2,\\'0\\') \\n```\\n\\n\\n[https://leetcode.com/submissions/detail/810938755/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\n        ans = []\\n\\n        for d0, d1, d2, d3 in list(permutations(arr,4)):\\n            hrs, mins = 10*d0+d1, 10*d2+d3\\n\\n            if hrs < 24 and mins < 60:\\n                ans.append((hrs,mins))\\n\\n        if not ans: return \\'\\'        \\n        hrs, mins = max(ans)\\n        return  str(hrs).rjust(2,\\'0\\')+\\':\\'+ str(mins).rjust(2,\\'0\\') \\n```",
                "codeTag": "Java"
            },
            {
                "id": 824095,
                "title": "94-62-javascript-clean-backtracking-with-short-circuit-optimization",
                "content": "```javascript\\nvar largestTimeFromDigits = function(A) {\\n    let res = \\'\\';\\n    \\n    function permute(arr, str) {\\n        if(str.length === 4) {\\n            if(+str >= +res) res = str;\\n            return;\\n        }\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            if(!str.length && arr[i] > 2) continue;\\n            if(str.length == 1 && str[0] == \\'2\\' && arr[i] > 3) continue;\\n            if(str.length == 2 && arr[i] > 5) continue;\\n            permute([...arr.slice(0, i), ...arr.slice(i+1)], str+arr[i]);\\n        }\\n    }\\n    permute(A, \\'\\');\\n    return res.slice(0, 2) + (res.length ? \\':\\' : \\'\\') + res.slice(2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar largestTimeFromDigits = function(A) {\\n    let res = \\'\\';\\n    \\n    function permute(arr, str) {\\n        if(str.length === 4) {\\n            if(+str >= +res) res = str;\\n            return;\\n        }\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            if(!str.length && arr[i] > 2) continue;\\n            if(str.length == 1 && str[0] == \\'2\\' && arr[i] > 3) continue;\\n            if(str.length == 2 && arr[i] > 5) continue;\\n            permute([...arr.slice(0, i), ...arr.slice(i+1)], str+arr[i]);\\n        }\\n    }\\n    permute(A, \\'\\');\\n    return res.slice(0, 2) + (res.length ? \\':\\' : \\'\\') + res.slice(2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712038,
                "title": "c-4-ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string result = \"\";\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<4;j++){\\n                for(int k=0;k<4;k++){\\n                    if( i == j || j == k || k == i ){\\n                        continue;\\n                    }\\n                    string hours = to_string(A[i]) + to_string(A[j]),\\n                           minutes = to_string(A[k]) + to_string(A[6-i-j-k]),\\n                           time = hours + \":\" + minutes;\\n                    if(hours < \"24\" && minutes < \"60\" && result < time){\\n                        result = time;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string result = \"\";\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<4;j++){\\n                for(int k=0;k<4;k++){\\n                    if( i == j || j == k || k == i ){\\n                        continue;\\n                    }\\n                    string hours = to_string(A[i]) + to_string(A[j]),\\n                           minutes = to_string(A[k]) + to_string(A[6-i-j-k]),\\n                           time = hours + \":\" + minutes;\\n                    if(hours < \"24\" && minutes < \"60\" && result < time){\\n                        result = time;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919164,
                "title": "c-faster-than-100-backtracking-solution",
                "content": "# Code\\n```\\nclass Solution {\\n\\nprivate:\\n\\n    int maxTime = INT_MIN;\\n    string answer = \"\";\\n\\n    void helper(vector<int> &arr, string res, vector<bool> &visited){\\n\\n        if(visited[0] and visited[1] and visited[2] and visited[3]){\\n            if(getTime(res) > maxTime){\\n                maxTime = getTime(res);\\n                answer = res;\\n            }\\n            return;\\n        }\\n\\n        for(int i = 0 ; i < 4 ; i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                res += to_string(arr[i]);\\n                helper(arr, res, visited);\\n                visited[i] = false;\\n                res.pop_back();\\n            }\\n        }\\n    }\\n\\n    int getTime(string res){\\n        int first = res[0] - \\'0\\';\\n        int second = res[1] - \\'0\\';\\n        int third = res[2] - \\'0\\';\\n        int fourth = res[3] - \\'0\\';\\n        int hours = first * 10 + second;\\n        int minutes = third * 10 + fourth;\\n        if(hours > 23 or minutes > 59) return INT_MIN;\\n        return hours * 60 + minutes;\\n    }\\n\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        // Intution\\n        // The solution in here is divided in total into three different steps.\\n        // Finding all the valid strings\\n        vector<bool> visited(4, false);\\n        helper(arr, \"\", visited);\\n        return answer != \"\" ? answer.substr(0, 2) + \":\" + answer.substr(2) : answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n\\n    int maxTime = INT_MIN;\\n    string answer = \"\";\\n\\n    void helper(vector<int> &arr, string res, vector<bool> &visited){\\n\\n        if(visited[0] and visited[1] and visited[2] and visited[3]){\\n            if(getTime(res) > maxTime){\\n                maxTime = getTime(res);\\n                answer = res;\\n            }\\n            return;\\n        }\\n\\n        for(int i = 0 ; i < 4 ; i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                res += to_string(arr[i]);\\n                helper(arr, res, visited);\\n                visited[i] = false;\\n                res.pop_back();\\n            }\\n        }\\n    }\\n\\n    int getTime(string res){\\n        int first = res[0] - \\'0\\';\\n        int second = res[1] - \\'0\\';\\n        int third = res[2] - \\'0\\';\\n        int fourth = res[3] - \\'0\\';\\n        int hours = first * 10 + second;\\n        int minutes = third * 10 + fourth;\\n        if(hours > 23 or minutes > 59) return INT_MIN;\\n        return hours * 60 + minutes;\\n    }\\n\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        // Intution\\n        // The solution in here is divided in total into three different steps.\\n        // Finding all the valid strings\\n        vector<bool> visited(4, false);\\n        helper(arr, \"\", visited);\\n        return answer != \"\" ? answer.substr(0, 2) + \":\" + answer.substr(2) : answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604515,
                "title": "python3-o-1-solution-without-using-in-built-functions",
                "content": "```\\nclass Solution:    \\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        res = \\'\\'\\n        for i, a in enumerate(arr):\\n            for j, b in enumerate(arr):\\n                for k, c in enumerate(arr):\\n                    if i == j or i == k or j == k: #avoid duplicates\\n                        continue\\n                    hour, minute = str(a) + str(b), str(c) + str(arr[6 - i - j - k])\\n                    if hour < \\'24\\' and minute < \\'60\\':\\n                        res = max(res, hour + \\':\\' + minute)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:    \\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        res = \\'\\'\\n        for i, a in enumerate(arr):\\n            for j, b in enumerate(arr):\\n                for k, c in enumerate(arr):\\n                    if i == j or i == k or j == k: #avoid duplicates\\n                        continue\\n                    hour, minute = str(a) + str(b), str(c) + str(arr[6 - i - j - k])\\n                    if hour < \\'24\\' and minute < \\'60\\':\\n                        res = max(res, hour + \\':\\' + minute)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370419,
                "title": "c-easiest-solution-ever",
                "content": "class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        \\n       /* let us consider an array as example like :\\n                            arr=[1 2 3 4]\\n                          index==0 1 2 3\\n           sum of the index =(0+1+2+3)=6\\n           \\n     lets assume index i,j for hour and (i!=j) again assume index k,(6-i-j-k) for the      minute given that (i!=j && j!=k && k!=i) and automatically (6-i-j-k) differs      \\n           let\\'s run nested loops to determine largest time in the given range */\\n           \\n        string result=\"\";\\n        \\n        for(int i=0;i<4;i++){\\n            \\n            for(int j=0;j<4;j++){\\n                \\n                for(int k=0;k<4;k++){\\n                    \\n                    if(i==j||j==k||k==i){\\n                        continue;\\n                    }\\n                    \\n                    else{\\n                        \\n                        string hour=\"\";\\n                        hour=to_string(arr[i])+to_string(arr[j]);\\n                        \\n                        string minute=\"\";\\n                        minute=to_string(arr[k])+to_string(arr[6-i-j-k]);\\n                        \\n                        string s=hour+\":\"+minute;\\n                        \\n                        // Condition checking\\n                        \\n                        if(hour<\"24\" && minute<\"60\" && s>result){\\n                            result=s;\\n                        }\\n                        \\n                        \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n        \\n        /* Time Complexity O(4*4*4) , Space Complexity O(1) */\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        \\n       /* let us consider an array as example like :\\n                            arr=[1 2 3 4]\\n                          index==0 1 2 3\\n           sum of the index =(0+1+2+3)=6\\n           \\n     lets assume index i,j for hour and (i!=j) again assume index k,(6-i-j-k) for the      minute given that (i!=j && j!=k && k!=i) and automatically (6-i-j-k) differs      \\n           let\\'s run nested loops to determine largest time in the given range */\\n           \\n        string result=\"\";\\n        \\n        for(int i=0;i<4;i++){\\n            \\n            for(int j=0;j<4;j++){\\n                \\n                for(int k=0;k<4;k++){\\n                    \\n                    if(i==j||j==k||k==i){\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 854491,
                "title": "c-faster-than-100",
                "content": "```\\n\\tstring largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        do {\\n            if (arr[2] > 5) continue;\\n            if (arr[0] == 2 && arr[1] <= 3 || arr[0] == 1 || arr[0] == 0) {\\n                return to_string(arr[0]) + to_string(arr[1]) + \":\" + to_string(arr[2]) + to_string(arr[3]);\\n            }\\n        } while (prev_permutation(arr.begin(), arr.end()));\\n        return \"\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tstring largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        do {\\n            if (arr[2] > 5) continue;\\n            if (arr[0] == 2 && arr[1] <= 3 || arr[0] == 1 || arr[0] == 0) {\\n                return to_string(arr[0]) + to_string(arr[1]) + \":\" + to_string(arr[2]) + to_string(arr[3]);\\n            }\\n        } while (prev_permutation(arr.begin(), arr.end()));\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 824210,
                "title": "python-3-solution",
                "content": "def largestTimeFromDigits(self, A: List[int]) -> str:\\n        maxVal=\"-1\"\\n        \\n        for i in list(permutations(A)):\\n            if 0<=i[0] <=2:\\n                tempVal= str(\\'\\'.join(str(n) for n in i))\\n                if int(tempVal)<2400 and  int(tempVal[2:])<=59 :\\n                    if tempVal > maxVal:\\n                        maxVal=tempVal\\n        if maxVal==\"-1\":\\n            return \"\"\\n        else:\\n            return maxVal[:2]+ \":\" + maxVal[2:]\\n        ``\\n                        \\n",
                "solutionTags": [],
                "code": "def largestTimeFromDigits(self, A: List[int]) -> str:\\n        maxVal=\"-1\"\\n        \\n        for i in list(permutations(A)):\\n            if 0<=i[0] <=2:\\n                tempVal= str(\\'\\'.join(str(n) for n in i))\\n                if int(tempVal)<2400 and  int(tempVal[2:])<=59 :\\n                    if tempVal > maxVal:\\n                        maxVal=tempVal\\n        if maxVal==\"-1\":\\n            return \"\"\\n        else:\\n            return maxVal[:2]+ \":\" + maxVal[2:]\\n        ``\\n                        \\n",
                "codeTag": "Python3"
            },
            {
                "id": 824060,
                "title": "python-using-custom-lt-gt-and-eq",
                "content": "```\\nclass ttime:\\n    def __init__(self, arr):\\n        arr = list(arr)\\n        self.h = arr[0] * 10 + arr[1]\\n        self.m = arr[2] * 10 + arr[3]\\n    \\n    def valid(self):\\n        return 0 <= self.h < 24 and 0 <= self.m < 60\\n    \\n    def __lt__(self, other):\\n        return self.h < other.h or (self.h == other.h and self.m < other.m)\\n    \\n    def __gt__(self, other):\\n        return self.h > other.h or (self.h == other.h and self.m > other.m)\\n    \\n    def __eq__(self, other):\\n        return self.h == other.h and self.m == other.m\\n    \\n    def get_string(self):\\n        return str(self.h).zfill(2) + \\':\\' + str(self.m).zfill(2) \\n    \\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        def permute(perm_arr, perm):\\n            if not perm_arr and ttime(perm).valid(): self.perm_list.append(ttime(perm))\\n            for i in range(len(perm_arr)):\\n                permute(perm_arr[:i] + perm_arr[i + 1:], perm + [perm_arr[i]])\\n        \\n        self.perm_list = []\\n        permute(A, [])\\n        return max(self.perm_list).get_string() if self.perm_list else \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass ttime:\\n    def __init__(self, arr):\\n        arr = list(arr)\\n        self.h = arr[0] * 10 + arr[1]\\n        self.m = arr[2] * 10 + arr[3]\\n    \\n    def valid(self):\\n        return 0 <= self.h < 24 and 0 <= self.m < 60\\n    \\n    def __lt__(self, other):\\n        return self.h < other.h or (self.h == other.h and self.m < other.m)\\n    \\n    def __gt__(self, other):\\n        return self.h > other.h or (self.h == other.h and self.m > other.m)\\n    \\n    def __eq__(self, other):\\n        return self.h == other.h and self.m == other.m\\n    \\n    def get_string(self):\\n        return str(self.h).zfill(2) + \\':\\' + str(self.m).zfill(2) \\n    \\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        def permute(perm_arr, perm):\\n            if not perm_arr and ttime(perm).valid(): self.perm_list.append(ttime(perm))\\n            for i in range(len(perm_arr)):\\n                permute(perm_arr[:i] + perm_arr[i + 1:], perm + [perm_arr[i]])\\n        \\n        self.perm_list = []\\n        permute(A, [])\\n        return max(self.perm_list).get_string() if self.perm_list else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823752,
                "title": "python-3-today-s-one-liner",
                "content": "Find the max permutation where the first 2 digits are < 24 and the last 2 digits are < 60. Default to empty string if not found.\\n\\n```python\\nclass Solution: largestTimeFromDigits = lambda _,A: max((\\'{}{}:{}{}\\'.format(a,b,c,d) for a,b,c,d in permutations(A) if (a < 2 if a != 2 else b < 4) and c < 6), default=\"\")\\n```\\n\\nWrapped for readability:\\n```python\\nclass Solution: largestTimeFromDigits = lambda _,A: \\\\\\n  max(( \\\\\\n      (\\'{}{}:{}{}\\'.format(a,b,c,d) \\\\\\n      for a,b,c,d in permutations(A) \\\\\\n      if (a < 2 if a != 2 else b < 4) and c < 6 \\\\\\n    ), \\\\\\n    default=\"\")\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution: largestTimeFromDigits = lambda _,A: max((\\'{}{}:{}{}\\'.format(a,b,c,d) for a,b,c,d in permutations(A) if (a < 2 if a != 2 else b < 4) and c < 6), default=\"\")\\n```\n```python\\nclass Solution: largestTimeFromDigits = lambda _,A: \\\\\\n  max(( \\\\\\n      (\\'{}{}:{}{}\\'.format(a,b,c,d) \\\\\\n      for a,b,c,d in permutations(A) \\\\\\n      if (a < 2 if a != 2 else b < 4) and c < 6 \\\\\\n    ), \\\\\\n    default=\"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823371,
                "title": "largest-time-for-given-digits-in-c",
                "content": "Just check all permutations and update hour, minute. If valid result found, format it and return.\\n\\n```\\n\\nbool isValid(int hour, int minute) {\\n  return hour < 24 && minute < 60;\\n}\\n\\nbool isGreater(int hour1, int minute1, int hour2, int minute2) {\\n  return (hour1 > hour2 || (hour1 == hour2 && minute1 > minute2));\\n}\\n\\nvoid checkHourMinite(int tmpHour, int tmpMinute, int* hour, int* minute) {\\n  if (isValid(tmpHour, tmpMinute) && isGreater(tmpHour, tmpMinute, *hour, *minute)) { \\n    *hour = tmpHour;\\n    *minute = tmpMinute; \\n  } \\n}\\n\\nvoid getMaxHourMinutes(int a, int b, int c, int d, int* hour, int* minute) {\\n  checkHourMinite(a * 10 + b, c * 10 + d, hour, minute);\\n  checkHourMinite(a * 10 + b, d * 10 + c, hour, minute);\\n  checkHourMinite(b * 10 + a, c * 10 + d, hour, minute);\\n  checkHourMinite(b * 10 + a, d * 10 + c, hour, minute);\\n\\n  checkHourMinite(c * 10 + d, a * 10 + b, hour, minute);\\n  checkHourMinite(c * 10 + d, b * 10 + a, hour, minute);\\n  checkHourMinite(d * 10 + c, a * 10 + b, hour, minute);\\n  checkHourMinite(d * 10 + c, b * 10 + a, hour, minute); \\n}\\n\\nchar * largestTimeFromDigits(int* A, int ASize){\\n  char* result = malloc(sizeof(char)*6);\\n  result[5] = \\'\\\\0\\';\\n\\n  int ok = 0;\\n\\n  int maxHour = -1;\\n  int maxMinute = -1;\\n  getMaxHourMinutes(A[0], A[1], A[2], A[3], &maxHour, &maxMinute);  \\n  getMaxHourMinutes(A[0], A[2], A[1], A[3], &maxHour, &maxMinute);\\n  getMaxHourMinutes(A[0], A[3], A[1], A[2], &maxHour, &maxMinute); \\n  if (maxHour == -1) {\\n    result[0] = \\'\\\\0\\';\\n  } else {\\n    sprintf(result, \"%02d:%02d\", maxHour, maxMinute);\\n  }\\n\\n  return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nbool isValid(int hour, int minute) {\\n  return hour < 24 && minute < 60;\\n}\\n\\nbool isGreater(int hour1, int minute1, int hour2, int minute2) {\\n  return (hour1 > hour2 || (hour1 == hour2 && minute1 > minute2));\\n}\\n\\nvoid checkHourMinite(int tmpHour, int tmpMinute, int* hour, int* minute) {\\n  if (isValid(tmpHour, tmpMinute) && isGreater(tmpHour, tmpMinute, *hour, *minute)) { \\n    *hour = tmpHour;\\n    *minute = tmpMinute; \\n  } \\n}\\n\\nvoid getMaxHourMinutes(int a, int b, int c, int d, int* hour, int* minute) {\\n  checkHourMinite(a * 10 + b, c * 10 + d, hour, minute);\\n  checkHourMinite(a * 10 + b, d * 10 + c, hour, minute);\\n  checkHourMinite(b * 10 + a, c * 10 + d, hour, minute);\\n  checkHourMinite(b * 10 + a, d * 10 + c, hour, minute);\\n\\n  checkHourMinite(c * 10 + d, a * 10 + b, hour, minute);\\n  checkHourMinite(c * 10 + d, b * 10 + a, hour, minute);\\n  checkHourMinite(d * 10 + c, a * 10 + b, hour, minute);\\n  checkHourMinite(d * 10 + c, b * 10 + a, hour, minute); \\n}\\n\\nchar * largestTimeFromDigits(int* A, int ASize){\\n  char* result = malloc(sizeof(char)*6);\\n  result[5] = \\'\\\\0\\';\\n\\n  int ok = 0;\\n\\n  int maxHour = -1;\\n  int maxMinute = -1;\\n  getMaxHourMinutes(A[0], A[1], A[2], A[3], &maxHour, &maxMinute);  \\n  getMaxHourMinutes(A[0], A[2], A[1], A[3], &maxHour, &maxMinute);\\n  getMaxHourMinutes(A[0], A[3], A[1], A[2], &maxHour, &maxMinute); \\n  if (maxHour == -1) {\\n    result[0] = \\'\\\\0\\';\\n  } else {\\n    sprintf(result, \"%02d:%02d\", maxHour, maxMinute);\\n  }\\n\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823341,
                "title": "java-10lines-easy",
                "content": "```\\npublic String largestTimeFromDigits(int[] A) {\\n        String res = \"\";\\n        for(int i =0; i< 4;i++){\\n            for(int j = 0; j < 4;j++){\\n                for(int k = 0; k < 4; k++){\\n                    if(i == j || j == k || i == k) continue;\\n                    String hour = A[i] + \"\" + A[j];\\n                    String min = A[k] + \"\" + A[6-i-j-k];\\n                    String time = hour + \":\" + min;\\n                    if(hour.compareTo(\"24\") < 0 && min.compareTo(\"60\") < 0)\\n                        res = res.compareTo(time) < 0 ? time : res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestTimeFromDigits(int[] A) {\\n        String res = \"\";\\n        for(int i =0; i< 4;i++){\\n            for(int j = 0; j < 4;j++){\\n                for(int k = 0; k < 4; k++){\\n                    if(i == j || j == k || i == k) continue;\\n                    String hour = A[i] + \"\" + A[j];\\n                    String min = A[k] + \"\" + A[6-i-j-k];\\n                    String time = hour + \":\" + min;\\n                    if(hour.compareTo(\"24\") < 0 && min.compareTo(\"60\") < 0)\\n                        res = res.compareTo(time) < 0 ? time : res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751721,
                "title": "java-backtracking-solution",
                "content": "I tried this in a mock exam. I had one hour and 2 questions. I did the other question in 10 mins. I was trying to solve this one using simple if else logics then after 40 mins realized I could not do it. Then I thought, lets try backtracking solution where you pick one digit and then try putting the rest on other places and see if it works. I was able to solve it within 5-6 mins. \\n```\\nclass Solution {\\n    int[] nums;\\n    String ans = \"\";\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        this.nums = nums;\\n        List<Integer> l = new ArrayList<>();\\n        for(int i: A)l.add(i);\\n        Collections.sort(l, Collections.reverseOrder());\\n        \\n        backtrack(l, \"\", \"\");\\n        return ans;\\n    }\\n    private boolean validHour(String hour){\\n        if(hour.length() == 2 && Integer.valueOf(hour) < 24) return true;\\n        return false;\\n    }\\n    \\n    private boolean validMin(String hour){\\n        if(hour.length() == 2 && Integer.valueOf(hour) < 60) return true;\\n        return false;\\n    }\\n    \\n    public boolean backtrack(List<Integer> l, String hour, String min){\\n        \\n        if(hour.length() == 2 && min.length()==2){\\n            if(validHour(hour) && validMin(min)){\\n                ans = hour + \":\" + min;\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        if(hour.length() < 2){\\n            for(int i=0; i<l.size(); i++){\\n                Integer h = l.remove(i);\\n                \\n                String hr = hour + h;\\n                \\n                if(backtrack(l, hr, min)){\\n                    return true;\\n                }\\n                l.add(i, h);\\n            }            \\n        }\\n        \\n        if(min.length() < 2){\\n            for(int i=0; i<l.size(); i++){\\n                Integer m = l.remove(i);\\n                \\n                String mi = min + m;\\n                \\n                if(backtrack(l, hour, mi)){\\n                    return true;\\n                }\\n                l.add(i, m);\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    String ans = \"\";\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        this.nums = nums;\\n        List<Integer> l = new ArrayList<>();\\n        for(int i: A)l.add(i);\\n        Collections.sort(l, Collections.reverseOrder());\\n        \\n        backtrack(l, \"\", \"\");\\n        return ans;\\n    }\\n    private boolean validHour(String hour){\\n        if(hour.length() == 2 && Integer.valueOf(hour) < 24) return true;\\n        return false;\\n    }\\n    \\n    private boolean validMin(String hour){\\n        if(hour.length() == 2 && Integer.valueOf(hour) < 60) return true;\\n        return false;\\n    }\\n    \\n    public boolean backtrack(List<Integer> l, String hour, String min){\\n        \\n        if(hour.length() == 2 && min.length()==2){\\n            if(validHour(hour) && validMin(min)){\\n                ans = hour + \":\" + min;\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        if(hour.length() < 2){\\n            for(int i=0; i<l.size(); i++){\\n                Integer h = l.remove(i);\\n                \\n                String hr = hour + h;\\n                \\n                if(backtrack(l, hr, min)){\\n                    return true;\\n                }\\n                l.add(i, h);\\n            }            \\n        }\\n        \\n        if(min.length() < 2){\\n            for(int i=0; i<l.size(); i++){\\n                Integer m = l.remove(i);\\n                \\n                String mi = min + m;\\n                \\n                if(backtrack(l, hour, mi)){\\n                    return true;\\n                }\\n                l.add(i, m);\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687711,
                "title": "ruby-2-line-solution",
                "content": "```\\n# @param {Integer[]} a\\n# @return {String}\\ndef largest_time_from_digits(a)\\n  a.permutation.map { |b| \\'%d%d:%d%d\\' % b }.select { |t| valid?(t) }.max || \\'\\'\\nend\\n\\nprivate def valid?(str)\\n  str.match?(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/)\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} a\\n# @return {String}\\ndef largest_time_from_digits(a)\\n  a.permutation.map { |b| \\'%d%d:%d%d\\' % b }.select { |t| valid?(t) }.max || \\'\\'\\nend\\n\\nprivate def valid?(str)\\n  str.match?(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 538181,
                "title": "c-faster-than-95-83-less-than-100-mem-o-1",
                "content": "O(1) because the size of A is set to 4.\\n\\nRuntime: 100 ms\\nMemory Usage: 24.9 MB\\n\\n```\\n    public string LargestTimeFromDigits(int[] A) {\\n        StringBuilder st = new StringBuilder();\\n        HashSet<int> used = new HashSet<int>();\\n        int maxTime = -1;\\n        string result = string.Empty;\\n        \\n        BuildString(st, used, A, 0, 0, ref maxTime, ref result);\\n        return result;\\n    }\\n    \\n    private void BuildString(StringBuilder st, HashSet<int> used, int[] A, int hours, int minutes, ref int maxTime, ref string result)\\n    {\\n        if (used.Count == A.Length)\\n        {\\n            if (st.Length == 4 && hours * 60 + minutes > maxTime) {\\n                maxTime = hours * 60 + minutes;\\n                st.Insert(2,\":\");\\n                result = st.ToString();\\n                st.Remove(2,1);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0; i< A.Length; i++)\\n        {\\n            if (used.Contains(i)) { continue; }\\n            \\n            if (st.Length < 2 && hours * 10 + A[i] < 24)\\n            {\\n                st.Append(A[i]);\\n                used.Add(i);\\n                BuildString(st, used, A, hours * 10 + A[i], minutes, ref maxTime, ref result);  \\n                used.Remove(i);\\n                st.Length--;\\n            }\\n            else if (st.Length >= 2 && minutes * 10 + A[i] < 60)\\n            {\\n                st.Append(A[i]);\\n                used.Add(i);\\n                BuildString(st, used, A, hours, minutes * 10 + A[i], ref maxTime, ref result);  \\n                used.Remove(i);\\n                st.Length--;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "O(1) because the size of A is set to 4.\\n\\nRuntime: 100 ms\\nMemory Usage: 24.9 MB\\n\\n```\\n    public string LargestTimeFromDigits(int[] A) {\\n        StringBuilder st = new StringBuilder();\\n        HashSet<int> used = new HashSet<int>();\\n        int maxTime = -1;\\n        string result = string.Empty;\\n        \\n        BuildString(st, used, A, 0, 0, ref maxTime, ref result);\\n        return result;\\n    }\\n    \\n    private void BuildString(StringBuilder st, HashSet<int> used, int[] A, int hours, int minutes, ref int maxTime, ref string result)\\n    {\\n        if (used.Count == A.Length)\\n        {\\n            if (st.Length == 4 && hours * 60 + minutes > maxTime) {\\n                maxTime = hours * 60 + minutes;\\n                st.Insert(2,\":\");\\n                result = st.ToString();\\n                st.Remove(2,1);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0; i< A.Length; i++)\\n        {\\n            if (used.Contains(i)) { continue; }\\n            \\n            if (st.Length < 2 && hours * 10 + A[i] < 24)\\n            {\\n                st.Append(A[i]);\\n                used.Add(i);\\n                BuildString(st, used, A, hours * 10 + A[i], minutes, ref maxTime, ref result);  \\n                used.Remove(i);\\n                st.Length--;\\n            }\\n            else if (st.Length >= 2 && minutes * 10 + A[i] < 60)\\n            {\\n                st.Append(A[i]);\\n                used.Add(i);\\n                BuildString(st, used, A, hours, minutes * 10 + A[i], ref maxTime, ref result);  \\n                used.Remove(i);\\n                st.Length--;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 513643,
                "title": "javascript-permutation-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n  const times = permutation(A)\\n    .filter(a => ((a[0] === 2 && a[1] < 4) || a[0] < 2) && a[2] < 6) // only keep valid times\\n    .map(a => 60 * (a[0] * 10 + a[1]) + a[2] * 10 + a[3]); // convert to minutes\\n  return times.length ? convert(Math.max(...times)) : \\'\\';\\n};\\n\\n// convert minutes back to time\\nconst convert = time => {\\n  const m = time % 60;\\n  const m2 = m % 10;\\n  const m1 = (m - m2) / 10;\\n  const h = (time - m) / 60;\\n  const h2 = h % 10;\\n  const h1 = (h - h2) / 10;\\n  return `${h1}${h2}:${m1}${m2}`;\\n};\\n\\n// Heap\\'s algorithm to generate permutations\\nconst permutation = arr => {\\n  const generate = (arr, n) => {\\n    if (n == 1) {\\n      result.push(arr.slice());\\n      return;\\n    }\\n    for (var i = 0; i < n; i++) {\\n      generate(arr, n - 1);\\n      if (n % 2 === 0) {\\n        [arr[i], arr[n - 1]] = [arr[n - 1], arr[i]];\\n      } else {\\n        [arr[0], arr[n - 1]] = [arr[n - 1], arr[0]];\\n      }\\n    }\\n  };\\n  const result = [];\\n  generate(arr, arr.length);\\n  return result;\\n};\\n```\\n\\n* 172/172 cases passed (52 ms)\\n* Your runtime beats 96.08 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (35.8 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n  const times = permutation(A)\\n    .filter(a => ((a[0] === 2 && a[1] < 4) || a[0] < 2) && a[2] < 6) // only keep valid times\\n    .map(a => 60 * (a[0] * 10 + a[1]) + a[2] * 10 + a[3]); // convert to minutes\\n  return times.length ? convert(Math.max(...times)) : \\'\\';\\n};\\n\\n// convert minutes back to time\\nconst convert = time => {\\n  const m = time % 60;\\n  const m2 = m % 10;\\n  const m1 = (m - m2) / 10;\\n  const h = (time - m) / 60;\\n  const h2 = h % 10;\\n  const h1 = (h - h2) / 10;\\n  return `${h1}${h2}:${m1}${m2}`;\\n};\\n\\n// Heap\\'s algorithm to generate permutations\\nconst permutation = arr => {\\n  const generate = (arr, n) => {\\n    if (n == 1) {\\n      result.push(arr.slice());\\n      return;\\n    }\\n    for (var i = 0; i < n; i++) {\\n      generate(arr, n - 1);\\n      if (n % 2 === 0) {\\n        [arr[i], arr[n - 1]] = [arr[n - 1], arr[i]];\\n      } else {\\n        [arr[0], arr[n - 1]] = [arr[n - 1], arr[0]];\\n      }\\n    }\\n  };\\n  const result = [];\\n  generate(arr, arr.length);\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 475504,
                "title": "swift-fast-8m-100",
                "content": "```swift\\nclass Solution {\\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        for i in (0...23).reversed() {\\n            let h = i % 10\\n            let dh = i / 10\\n            if A.contains(dh), A.contains(h) {\\n                if let result = pickTime(A, h, dh) {\\n                    return result\\n                }\\n            }\\n        }\\n        return \"\"\\n        \\n    }\\n    \\n    func pickTime(_ from: [Int], _ valid: inout [Int]) -> Int? {\\n        for i in from {\\n            if valid.contains(i) {\\n                if let index = valid.firstIndex(of: i) {\\n                    valid.remove(at: index)\\n                }\\n                return i\\n            }\\n        }\\n        return nil\\n        \\n    }\\n    \\n    func pickTime(_ from: [Int], _ h: Int, _ dh: Int) -> String? {\\n        var numbers = from\\n        if let index = numbers.firstIndex(of: h) {\\n            numbers.remove(at: index)\\n        }\\n        if let index = numbers.firstIndex(of: dh) {\\n            numbers.remove(at: index)\\n        } else {\\n            return nil\\n        }\\n        guard let dm = pickTime([5,4,3,2,1,0], &numbers) else {\\n            return nil\\n        }\\n        let m = numbers.last!\\n        let result = \"\\\\(dh)\\\\(h):\\\\(dm)\\\\(m)\"\\n        \\n        \\n        return result\\n        \\n    }\\n}\\n```\\n\\nalso I have 2 very stupid solutions, just for fun\\n\\n```\\nclass Solution {\\n    \\n    var values: [String: String]\\n    init() {\\n       values = [:]\\n       for i in (0...23).reversed() {\\n           let h = i % 10\\n           let dh = i / 10\\n           for j in (0...59).reversed() {\\n               let m = j % 10\\n               let dm = j / 10\\n               let key = normalize([h,dh,m,dm])\\n               if values[key] == nil {\\n                   values[key] = \"\\\\(dh)\\\\(h):\\\\(dm)\\\\(m)\"\\n               }\\n\\n           }\\n       }\\n   }\\n    \\n    func normalize(_ numbers: [Int]) -> String {\\n        return numbers.sorted().map({ String($0) }).joined()\\n    }\\n    \\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        let key = normalize(A)\\n        return values[key, default: \"\"]\\n    }\\n}\\n```\\n\\nor even more, we could store calculated values\\n\\n```swift\\nclass Solution {\\n   var values: [String: String] = [\"2345\": \"23:54\", \"0007\": \"07:00\", \"0568\": \"08:56\", \"1249\": \"21:49\", \"0335\": \"05:33\", \"0557\": \"07:55\", \"2224\": \"22:42\", \"2239\": \"23:29\", \"0279\": \"09:27\", \"0455\": \"05:54\", \"0138\": \"18:30\", \"0248\": \"20:48\", \"1227\": \"22:17\", \"2346\": \"23:46\", \"2245\": \"22:54\", \"0089\": \"09:08\", \"0245\": \"20:54\", \"0244\": \"20:44\", \"1257\": \"21:57\", \"0236\": \"23:06\", \"1258\": \"21:58\", \"1599\": \"19:59\", \"0112\": \"21:10\", \"0022\": \"22:00\", \"1388\": \"18:38\", \"2257\": \"22:57\", \"0026\": \"20:06\", \"1558\": \"18:55\", \"0469\": \"09:46\", \"0058\": \"08:50\", \"1588\": \"18:58\", \"0119\": \"19:10\", \"1157\": \"17:51\", \"1133\": \"13:31\", \"0066\": \"06:06\", \"0133\": \"13:30\", \"1189\": \"19:18\", \"1278\": \"18:27\", \"1348\": \"18:43\", \"1379\": \"19:37\", \"1156\": \"16:51\", \"0358\": \"08:53\", \"2255\": \"22:55\", \"0255\": \"20:55\", \"0269\": \"09:26\", \"0457\": \"07:54\", \"2249\": \"22:49\", \"0005\": \"05:00\", \"1158\": \"18:51\", \"1555\": \"15:55\", \"0266\": \"06:26\", \"0466\": \"06:46\", \"0578\": \"08:57\", \"1337\": \"17:33\", \"0129\": \"21:09\", \"0146\": \"16:40\", \"0115\": \"15:10\", \"1339\": \"19:33\", \"0448\": \"08:44\", \"1288\": \"18:28\", \"1335\": \"15:33\", \"1117\": \"17:11\", \"0006\": \"06:00\", \"0078\": \"08:07\", \"0456\": \"06:54\", \"0289\": \"09:28\", \"1399\": \"19:39\", \"0479\": \"09:47\", \"0478\": \"08:47\", \"1147\": \"17:41\", \"1137\": \"17:31\", \"1144\": \"14:41\", \"1346\": \"16:43\", \"1477\": \"17:47\", \"0447\": \"07:44\", \"1233\": \"23:31\", \"0156\": \"16:50\", \"1155\": \"15:51\", \"0488\": \"08:48\", \"0449\": \"09:44\", \"1367\": \"17:36\", \"1377\": \"17:37\", \"0225\": \"22:50\", \"1167\": \"17:16\", \"2339\": \"23:39\", \"1267\": \"17:26\", \"1124\": \"21:41\", \"2233\": \"23:32\", \"0346\": \"06:43\", \"2226\": \"22:26\", \"1455\": \"15:54\", \"0158\": \"18:50\", \"1579\": \"19:57\", \"0278\": \"08:27\", \"0056\": \"06:50\", \"0001\": \"10:00\", \"2355\": \"23:55\", \"1115\": \"15:11\", \"1556\": \"16:55\", \"2358\": \"23:58\", \"0446\": \"06:44\", \"0088\": \"08:08\", \"0000\": \"00:00\", \"1179\": \"19:17\", \"0224\": \"22:40\", \"0025\": \"20:50\", \"0099\": \"09:09\", \"1479\": \"19:47\", \"0069\": \"09:06\", \"0136\": \"16:30\", \"1446\": \"16:44\", \"0445\": \"05:44\", \"0334\": \"04:33\", \"1358\": \"18:53\", \"1247\": \"21:47\", \"0038\": \"08:30\", \"1166\": \"16:16\", \"0256\": \"20:56\", \"0336\": \"06:33\", \"1127\": \"21:17\", \"0047\": \"07:40\", \"1223\": \"23:21\", \"0033\": \"03:30\", \"0003\": \"03:00\", \"0179\": \"19:07\", \"0226\": \"22:06\", \"2338\": \"23:38\", \"0019\": \"19:00\", \"0116\": \"16:10\", \"1568\": \"18:56\", \"1116\": \"16:11\", \"0011\": \"11:00\", \"0222\": \"22:20\", \"0126\": \"21:06\", \"0357\": \"07:53\", \"0378\": \"08:37\", \"1178\": \"18:17\", \"0458\": \"08:54\", \"0139\": \"19:30\", \"0468\": \"08:46\", \"0233\": \"23:30\", \"0014\": \"14:00\", \"0229\": \"22:09\", \"1456\": \"16:54\", \"1126\": \"21:16\", \"1125\": \"21:51\", \"0035\": \"05:30\", \"0388\": \"08:38\", \"2258\": \"22:58\", \"1113\": \"13:11\", \"1268\": \"18:26\", \"1457\": \"17:54\", \"0399\": \"09:39\", \"0168\": \"18:06\", \"0015\": \"15:00\", \"0268\": \"08:26\", \"0299\": \"09:29\", \"1145\": \"15:41\", \"1256\": \"21:56\", \"0177\": \"17:07\", \"0178\": \"18:07\", \"0135\": \"15:30\", \"2236\": \"23:26\", \"2344\": \"23:44\", \"1228\": \"22:18\", \"0048\": \"08:40\", \"0444\": \"04:44\", \"1378\": \"18:37\", \"2334\": \"23:43\", \"2348\": \"23:48\", \"0369\": \"09:36\", \"0345\": \"05:43\", \"0227\": \"22:07\", \"1345\": \"15:43\", \"0077\": \"07:07\", \"0149\": \"19:40\", \"0169\": \"19:06\", \"1118\": \"18:11\", \"2222\": \"22:22\", \"0239\": \"23:09\", \"0377\": \"07:37\", \"0333\": \"03:33\", \"0155\": \"15:50\", \"1138\": \"18:31\", \"1148\": \"18:41\", \"0028\": \"20:08\", \"0558\": \"08:55\", \"1299\": \"19:29\", \"0008\": \"08:00\", \"0039\": \"09:30\", \"1458\": \"18:54\", \"0569\": \"09:56\", \"2247\": \"22:47\", \"1199\": \"19:19\", \"1366\": \"16:36\", \"0167\": \"17:06\", \"0122\": \"22:10\", \"0037\": \"07:30\", \"0044\": \"04:40\", \"1355\": \"15:53\", \"0559\": \"09:55\", \"1368\": \"18:36\", \"0045\": \"05:40\", \"1224\": \"22:41\", \"0379\": \"09:37\", \"0577\": \"07:57\", \"0137\": \"17:30\", \"0234\": \"23:40\", \"0339\": \"09:33\", \"0235\": \"23:50\", \"1236\": \"23:16\", \"0499\": \"09:49\", \"0589\": \"09:58\", \"2337\": \"23:37\", \"0055\": \"05:50\", \"2336\": \"23:36\", \"1369\": \"19:36\", \"1134\": \"14:31\", \"1578\": \"18:57\", \"2238\": \"23:28\", \"1139\": \"19:31\", \"0134\": \"14:30\", \"2359\": \"23:59\", \"1246\": \"21:46\", \"1229\": \"22:19\", \"1279\": \"19:27\", \"2237\": \"23:27\", \"0259\": \"20:59\", \"1467\": \"17:46\", \"1468\": \"18:46\", \"0467\": \"07:46\", \"0125\": \"21:50\", \"0013\": \"13:00\", \"0267\": \"07:26\", \"0147\": \"17:40\", \"1239\": \"23:19\", \"0029\": \"20:09\", \"0246\": \"20:46\", \"1169\": \"19:16\", \"0489\": \"09:48\", \"0067\": \"07:06\", \"0017\": \"17:00\", \"1168\": \"18:16\", \"1244\": \"21:44\", \"2349\": \"23:49\", \"1114\": \"14:11\", \"2347\": \"23:47\", \"0027\": \"20:07\", \"0189\": \"19:08\", \"2357\": \"23:57\", \"1567\": \"17:56\", \"1469\": \"19:46\", \"1222\": \"22:21\", \"1259\": \"21:59\", \"2234\": \"23:42\", \"0223\": \"23:20\", \"1122\": \"22:11\", \"0117\": \"17:10\", \"0036\": \"06:30\", \"0366\": \"06:36\", \"1238\": \"23:18\", \"2333\": \"23:33\", \"0012\": \"21:00\", \"1235\": \"23:51\", \"0237\": \"23:07\", \"0566\": \"06:56\", \"0009\": \"09:00\", \"1448\": \"18:44\", \"2223\": \"23:22\", \"1159\": \"19:51\", \"1488\": \"18:48\", \"2248\": \"22:48\", \"0079\": \"09:07\", \"2229\": \"22:29\", \"0257\": \"20:57\", \"0347\": \"07:43\", \"0459\": \"09:54\", \"1559\": \"19:55\", \"0288\": \"08:28\", \"0337\": \"07:33\", \"0368\": \"08:36\", \"0049\": \"09:40\", \"1359\": \"19:53\", \"1489\": \"19:48\", \"0159\": \"19:50\", \"1188\": \"18:18\", \"0118\": \"18:10\", \"0258\": \"20:58\", \"0477\": \"07:47\", \"2335\": \"23:53\", \"0599\": \"09:59\", \"1237\": \"23:17\", \"0247\": \"20:47\", \"0567\": \"07:56\", \"2259\": \"22:59\", \"1499\": \"19:49\", \"0046\": \"06:40\", \"0127\": \"21:07\", \"0349\": \"09:43\", \"1389\": \"19:38\", \"0188\": \"18:08\", \"1336\": \"16:33\", \"1347\": \"17:43\", \"1129\": \"21:19\", \"2246\": \"22:46\", \"2228\": \"22:28\", \"1344\": \"14:43\", \"1146\": \"16:41\", \"0123\": \"23:10\", \"0228\": \"22:08\", \"1449\": \"19:44\", \"2244\": \"22:44\", \"0579\": \"09:57\", \"1135\": \"15:31\", \"1225\": \"22:51\", \"1255\": \"21:55\", \"1349\": \"19:43\", \"0124\": \"21:40\", \"1557\": \"17:55\", \"0128\": \"21:08\", \"0057\": \"07:50\", \"2235\": \"23:52\", \"0157\": \"17:50\", \"0111\": \"11:10\", \"0389\": \"09:38\", \"0144\": \"14:40\", \"0004\": \"04:00\", \"0034\": \"04:30\", \"1357\": \"17:53\", \"1234\": \"23:41\", \"1333\": \"13:33\", \"0249\": \"20:49\", \"1112\": \"21:11\", \"0166\": \"16:06\", \"0338\": \"08:33\", \"2225\": \"22:52\", \"2227\": \"22:27\", \"0555\": \"05:55\", \"0277\": \"07:27\", \"1447\": \"17:44\", \"1269\": \"19:26\", \"1356\": \"16:53\", \"1136\": \"16:31\", \"1119\": \"19:11\", \"0068\": \"08:06\", \"1248\": \"21:48\", \"0113\": \"13:10\", \"0556\": \"06:55\", \"1478\": \"18:47\", \"1277\": \"17:27\", \"0348\": \"08:43\", \"1245\": \"21:54\", \"1266\": \"16:26\", \"0023\": \"23:00\", \"1338\": \"18:33\", \"0199\": \"19:09\", \"1111\": \"11:11\", \"0356\": \"06:53\", \"0002\": \"20:00\", \"0148\": \"18:40\", \"0024\": \"20:40\", \"0367\": \"07:36\", \"2356\": \"23:56\", \"1149\": \"19:41\", \"0359\": \"09:53\", \"1444\": \"14:44\", \"0145\": \"15:40\", \"1226\": \"22:16\", \"1569\": \"19:56\", \"0588\": \"08:58\", \"1566\": \"16:56\", \"1577\": \"17:57\", \"0059\": \"09:50\", \"0016\": \"16:00\", \"0018\": \"18:00\", \"2256\": \"22:56\", \"1459\": \"19:54\", \"1445\": \"15:44\", \"1589\": \"19:58\", \"0238\": \"23:08\", \"0344\": \"04:43\", \"1334\": \"14:33\", \"1289\": \"19:28\", \"1128\": \"21:18\", \"0114\": \"14:10\", \"0355\": \"05:53\", \"1123\": \"23:11\", \"1177\": \"17:17\", \"1466\": \"16:46\"]\\n    \\n    func normalize(_ numbers: [Int]) -> String {\\n        return numbers.sorted().map({ String($0) }).joined()\\n    }\\n    \\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        let key = normalize(A)\\n        return values[key, default: \"\"]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        for i in (0...23).reversed() {\\n            let h = i % 10\\n            let dh = i / 10\\n            if A.contains(dh), A.contains(h) {\\n                if let result = pickTime(A, h, dh) {\\n                    return result\\n                }\\n            }\\n        }\\n        return \"\"\\n        \\n    }\\n    \\n    func pickTime(_ from: [Int], _ valid: inout [Int]) -> Int? {\\n        for i in from {\\n            if valid.contains(i) {\\n                if let index = valid.firstIndex(of: i) {\\n                    valid.remove(at: index)\\n                }\\n                return i\\n            }\\n        }\\n        return nil\\n        \\n    }\\n    \\n    func pickTime(_ from: [Int], _ h: Int, _ dh: Int) -> String? {\\n        var numbers = from\\n        if let index = numbers.firstIndex(of: h) {\\n            numbers.remove(at: index)\\n        }\\n        if let index = numbers.firstIndex(of: dh) {\\n            numbers.remove(at: index)\\n        } else {\\n            return nil\\n        }\\n        guard let dm = pickTime([5,4,3,2,1,0], &numbers) else {\\n            return nil\\n        }\\n        let m = numbers.last!\\n        let result = \"\\\\(dh)\\\\(h):\\\\(dm)\\\\(m)\"\\n        \\n        \\n        return result\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    var values: [String: String]\\n    init() {\\n       values = [:]\\n       for i in (0...23).reversed() {\\n           let h = i % 10\\n           let dh = i / 10\\n           for j in (0...59).reversed() {\\n               let m = j % 10\\n               let dm = j / 10\\n               let key = normalize([h,dh,m,dm])\\n               if values[key] == nil {\\n                   values[key] = \"\\\\(dh)\\\\(h):\\\\(dm)\\\\(m)\"\\n               }\\n\\n           }\\n       }\\n   }\\n    \\n    func normalize(_ numbers: [Int]) -> String {\\n        return numbers.sorted().map({ String($0) }).joined()\\n    }\\n    \\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        let key = normalize(A)\\n        return values[key, default: \"\"]\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n   var values: [String: String] = [\"2345\": \"23:54\", \"0007\": \"07:00\", \"0568\": \"08:56\", \"1249\": \"21:49\", \"0335\": \"05:33\", \"0557\": \"07:55\", \"2224\": \"22:42\", \"2239\": \"23:29\", \"0279\": \"09:27\", \"0455\": \"05:54\", \"0138\": \"18:30\", \"0248\": \"20:48\", \"1227\": \"22:17\", \"2346\": \"23:46\", \"2245\": \"22:54\", \"0089\": \"09:08\", \"0245\": \"20:54\", \"0244\": \"20:44\", \"1257\": \"21:57\", \"0236\": \"23:06\", \"1258\": \"21:58\", \"1599\": \"19:59\", \"0112\": \"21:10\", \"0022\": \"22:00\", \"1388\": \"18:38\", \"2257\": \"22:57\", \"0026\": \"20:06\", \"1558\": \"18:55\", \"0469\": \"09:46\", \"0058\": \"08:50\", \"1588\": \"18:58\", \"0119\": \"19:10\", \"1157\": \"17:51\", \"1133\": \"13:31\", \"0066\": \"06:06\", \"0133\": \"13:30\", \"1189\": \"19:18\", \"1278\": \"18:27\", \"1348\": \"18:43\", \"1379\": \"19:37\", \"1156\": \"16:51\", \"0358\": \"08:53\", \"2255\": \"22:55\", \"0255\": \"20:55\", \"0269\": \"09:26\", \"0457\": \"07:54\", \"2249\": \"22:49\", \"0005\": \"05:00\", \"1158\": \"18:51\", \"1555\": \"15:55\", \"0266\": \"06:26\", \"0466\": \"06:46\", \"0578\": \"08:57\", \"1337\": \"17:33\", \"0129\": \"21:09\", \"0146\": \"16:40\", \"0115\": \"15:10\", \"1339\": \"19:33\", \"0448\": \"08:44\", \"1288\": \"18:28\", \"1335\": \"15:33\", \"1117\": \"17:11\", \"0006\": \"06:00\", \"0078\": \"08:07\", \"0456\": \"06:54\", \"0289\": \"09:28\", \"1399\": \"19:39\", \"0479\": \"09:47\", \"0478\": \"08:47\", \"1147\": \"17:41\", \"1137\": \"17:31\", \"1144\": \"14:41\", \"1346\": \"16:43\", \"1477\": \"17:47\", \"0447\": \"07:44\", \"1233\": \"23:31\", \"0156\": \"16:50\", \"1155\": \"15:51\", \"0488\": \"08:48\", \"0449\": \"09:44\", \"1367\": \"17:36\", \"1377\": \"17:37\", \"0225\": \"22:50\", \"1167\": \"17:16\", \"2339\": \"23:39\", \"1267\": \"17:26\", \"1124\": \"21:41\", \"2233\": \"23:32\", \"0346\": \"06:43\", \"2226\": \"22:26\", \"1455\": \"15:54\", \"0158\": \"18:50\", \"1579\": \"19:57\", \"0278\": \"08:27\", \"0056\": \"06:50\", \"0001\": \"10:00\", \"2355\": \"23:55\", \"1115\": \"15:11\", \"1556\": \"16:55\", \"2358\": \"23:58\", \"0446\": \"06:44\", \"0088\": \"08:08\", \"0000\": \"00:00\", \"1179\": \"19:17\", \"0224\": \"22:40\", \"0025\": \"20:50\", \"0099\": \"09:09\", \"1479\": \"19:47\", \"0069\": \"09:06\", \"0136\": \"16:30\", \"1446\": \"16:44\", \"0445\": \"05:44\", \"0334\": \"04:33\", \"1358\": \"18:53\", \"1247\": \"21:47\", \"0038\": \"08:30\", \"1166\": \"16:16\", \"0256\": \"20:56\", \"0336\": \"06:33\", \"1127\": \"21:17\", \"0047\": \"07:40\", \"1223\": \"23:21\", \"0033\": \"03:30\", \"0003\": \"03:00\", \"0179\": \"19:07\", \"0226\": \"22:06\", \"2338\": \"23:38\", \"0019\": \"19:00\", \"0116\": \"16:10\", \"1568\": \"18:56\", \"1116\": \"16:11\", \"0011\": \"11:00\", \"0222\": \"22:20\", \"0126\": \"21:06\", \"0357\": \"07:53\", \"0378\": \"08:37\", \"1178\": \"18:17\", \"0458\": \"08:54\", \"0139\": \"19:30\", \"0468\": \"08:46\", \"0233\": \"23:30\", \"0014\": \"14:00\", \"0229\": \"22:09\", \"1456\": \"16:54\", \"1126\": \"21:16\", \"1125\": \"21:51\", \"0035\": \"05:30\", \"0388\": \"08:38\", \"2258\": \"22:58\", \"1113\": \"13:11\", \"1268\": \"18:26\", \"1457\": \"17:54\", \"0399\": \"09:39\", \"0168\": \"18:06\", \"0015\": \"15:00\", \"0268\": \"08:26\", \"0299\": \"09:29\", \"1145\": \"15:41\", \"1256\": \"21:56\", \"0177\": \"17:07\", \"0178\": \"18:07\", \"0135\": \"15:30\", \"2236\": \"23:26\", \"2344\": \"23:44\", \"1228\": \"22:18\", \"0048\": \"08:40\", \"0444\": \"04:44\", \"1378\": \"18:37\", \"2334\": \"23:43\", \"2348\": \"23:48\", \"0369\": \"09:36\", \"0345\": \"05:43\", \"0227\": \"22:07\", \"1345\": \"15:43\", \"0077\": \"07:07\", \"0149\": \"19:40\", \"0169\": \"19:06\", \"1118\": \"18:11\", \"2222\": \"22:22\", \"0239\": \"23:09\", \"0377\": \"07:37\", \"0333\": \"03:33\", \"0155\": \"15:50\", \"1138\": \"18:31\", \"1148\": \"18:41\", \"0028\": \"20:08\", \"0558\": \"08:55\", \"1299\": \"19:29\", \"0008\": \"08:00\", \"0039\": \"09:30\", \"1458\": \"18:54\", \"0569\": \"09:56\", \"2247\": \"22:47\", \"1199\": \"19:19\", \"1366\": \"16:36\", \"0167\": \"17:06\", \"0122\": \"22:10\", \"0037\": \"07:30\", \"0044\": \"04:40\", \"1355\": \"15:53\", \"0559\": \"09:55\", \"1368\": \"18:36\", \"0045\": \"05:40\", \"1224\": \"22:41\", \"0379\": \"09:37\", \"0577\": \"07:57\", \"0137\": \"17:30\", \"0234\": \"23:40\", \"0339\": \"09:33\", \"0235\": \"23:50\", \"1236\": \"23:16\", \"0499\": \"09:49\", \"0589\": \"09:58\", \"2337\": \"23:37\", \"0055\": \"05:50\", \"2336\": \"23:36\", \"1369\": \"19:36\", \"1134\": \"14:31\", \"1578\": \"18:57\", \"2238\": \"23:28\", \"1139\": \"19:31\", \"0134\": \"14:30\", \"2359\": \"23:59\", \"1246\": \"21:46\", \"1229\": \"22:19\", \"1279\": \"19:27\", \"2237\": \"23:27\", \"0259\": \"20:59\", \"1467\": \"17:46\", \"1468\": \"18:46\", \"0467\": \"07:46\", \"0125\": \"21:50\", \"0013\": \"13:00\", \"0267\": \"07:26\", \"0147\": \"17:40\", \"1239\": \"23:19\", \"0029\": \"20:09\", \"0246\": \"20:46\", \"1169\": \"19:16\", \"0489\": \"09:48\", \"0067\": \"07:06\", \"0017\": \"17:00\", \"1168\": \"18:16\", \"1244\": \"21:44\", \"2349\": \"23:49\", \"1114\": \"14:11\", \"2347\": \"23:47\", \"0027\": \"20:07\", \"0189\": \"19:08\", \"2357\": \"23:57\", \"1567\": \"17:56\", \"1469\": \"19:46\", \"1222\": \"22:21\", \"1259\": \"21:59\", \"2234\": \"23:42\", \"0223\": \"23:20\", \"1122\": \"22:11\", \"0117\": \"17:10\", \"0036\": \"06:30\", \"0366\": \"06:36\", \"1238\": \"23:18\", \"2333\": \"23:33\", \"0012\": \"21:00\", \"1235\": \"23:51\", \"0237\": \"23:07\", \"0566\": \"06:56\", \"0009\": \"09:00\", \"1448\": \"18:44\", \"2223\": \"23:22\", \"1159\": \"19:51\", \"1488\": \"18:48\", \"2248\": \"22:48\", \"0079\": \"09:07\", \"2229\": \"22:29\", \"0257\": \"20:57\", \"0347\": \"07:43\", \"0459\": \"09:54\", \"1559\": \"19:55\", \"0288\": \"08:28\", \"0337\": \"07:33\", \"0368\": \"08:36\", \"0049\": \"09:40\", \"1359\": \"19:53\", \"1489\": \"19:48\", \"0159\": \"19:50\", \"1188\": \"18:18\", \"0118\": \"18:10\", \"0258\": \"20:58\", \"0477\": \"07:47\", \"2335\": \"23:53\", \"0599\": \"09:59\", \"1237\": \"23:17\", \"0247\": \"20:47\", \"0567\": \"07:56\", \"2259\": \"22:59\", \"1499\": \"19:49\", \"0046\": \"06:40\", \"0127\": \"21:07\", \"0349\": \"09:43\", \"1389\": \"19:38\", \"0188\": \"18:08\", \"1336\": \"16:33\", \"1347\": \"17:43\", \"1129\": \"21:19\", \"2246\": \"22:46\", \"2228\": \"22:28\", \"1344\": \"14:43\", \"1146\": \"16:41\", \"0123\": \"23:10\", \"0228\": \"22:08\", \"1449\": \"19:44\", \"2244\": \"22:44\", \"0579\": \"09:57\", \"1135\": \"15:31\", \"1225\": \"22:51\", \"1255\": \"21:55\", \"1349\": \"19:43\", \"0124\": \"21:40\", \"1557\": \"17:55\", \"0128\": \"21:08\", \"0057\": \"07:50\", \"2235\": \"23:52\", \"0157\": \"17:50\", \"0111\": \"11:10\", \"0389\": \"09:38\", \"0144\": \"14:40\", \"0004\": \"04:00\", \"0034\": \"04:30\", \"1357\": \"17:53\", \"1234\": \"23:41\", \"1333\": \"13:33\", \"0249\": \"20:49\", \"1112\": \"21:11\", \"0166\": \"16:06\", \"0338\": \"08:33\", \"2225\": \"22:52\", \"2227\": \"22:27\", \"0555\": \"05:55\", \"0277\": \"07:27\", \"1447\": \"17:44\", \"1269\": \"19:26\", \"1356\": \"16:53\", \"1136\": \"16:31\", \"1119\": \"19:11\", \"0068\": \"08:06\", \"1248\": \"21:48\", \"0113\": \"13:10\", \"0556\": \"06:55\", \"1478\": \"18:47\", \"1277\": \"17:27\", \"0348\": \"08:43\", \"1245\": \"21:54\", \"1266\": \"16:26\", \"0023\": \"23:00\", \"1338\": \"18:33\", \"0199\": \"19:09\", \"1111\": \"11:11\", \"0356\": \"06:53\", \"0002\": \"20:00\", \"0148\": \"18:40\", \"0024\": \"20:40\", \"0367\": \"07:36\", \"2356\": \"23:56\", \"1149\": \"19:41\", \"0359\": \"09:53\", \"1444\": \"14:44\", \"0145\": \"15:40\", \"1226\": \"22:16\", \"1569\": \"19:56\", \"0588\": \"08:58\", \"1566\": \"16:56\", \"1577\": \"17:57\", \"0059\": \"09:50\", \"0016\": \"16:00\", \"0018\": \"18:00\", \"2256\": \"22:56\", \"1459\": \"19:54\", \"1445\": \"15:44\", \"1589\": \"19:58\", \"0238\": \"23:08\", \"0344\": \"04:43\", \"1334\": \"14:33\", \"1289\": \"19:28\", \"1128\": \"21:18\", \"0114\": \"14:10\", \"0355\": \"05:53\", \"1123\": \"23:11\", \"1177\": \"17:17\", \"1466\": \"16:46\"]\\n    \\n    func normalize(_ numbers: [Int]) -> String {\\n        return numbers.sorted().map({ String($0) }).joined()\\n    }\\n    \\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        let key = normalize(A)\\n        return values[key, default: \"\"]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439679,
                "title": "java-1-ms",
                "content": "```\\n// (0-2)_ (0-3)_ : (0-5)_ (0-9)_\\npublic String largestTimeFromDigits(int[] A) {\\n\\tArrays.sort(A);\\n\\tfor (int i = 3; i >= 0; i--) {\\n\\t\\tif (A[i] <= 2) {\\n\\t\\t\\tfor (int j = 3; j >= 0; j--) {\\n\\t\\t\\t\\tif ((A[i] != 2 || A[j] <= 3) && i != j) {\\n\\t\\t\\t\\t\\tfor (int k = 3; k >= 0; k--) {\\n\\t\\t\\t\\t\\t\\tif (A[k] <= 5 && i != k && j != k) {\\n\\t\\t\\t\\t\\t\\t\\t// 6 comes from 0+1+2+3 which are indexes of array so left index is calculated from 6 - i,j,k\\n\\t\\t\\t\\t\\t\\t\\treturn \"\" + A[i] + A[j] + \":\" + A[k] + A[6 - i - j - k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn \"\";\\n}",
                "solutionTags": [],
                "code": "```\\n// (0-2)_ (0-3)_ : (0-5)_ (0-9)_\\npublic String largestTimeFromDigits(int[] A) {\\n\\tArrays.sort(A);\\n\\tfor (int i = 3; i >= 0; i--) {\\n\\t\\tif (A[i] <= 2) {\\n\\t\\t\\tfor (int j = 3; j >= 0; j--) {\\n\\t\\t\\t\\tif ((A[i] != 2 || A[j] <= 3) && i != j) {\\n\\t\\t\\t\\t\\tfor (int k = 3; k >= 0; k--) {\\n\\t\\t\\t\\t\\t\\tif (A[k] <= 5 && i != k && j != k) {\\n\\t\\t\\t\\t\\t\\t\\t// 6 comes from 0+1+2+3 which are indexes of array so left index is calculated from 6 - i,j,k\\n\\t\\t\\t\\t\\t\\t\\treturn \"\" + A[i] + A[j] + \":\" + A[k] + A[6 - i - j - k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn \"\";\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 406661,
                "title": "python3-6-line-via-permutation",
                "content": "It is tempting to think that this problem falls in the regime of \"greedy algorithm\". But a closer look reveals that one has to enumerate all possibilities and find the largest one due to complicated constraints on digits. \\n\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        hh = mm = -1\\n        for x in set(permutations(A, 4)): \\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60 and 60*h + m > 60*hh + mm: hh, mm = h, m\\n        return f\"{hh:02}:{mm:02}\" if hh >= 0 else \"\"\\n```\\n\\nSome comment: In practice, I\\'d write the comparison part as below. But in Python, tuple comparison is a lot slower comparing to number comparison. So to improve the percentage, the exising style is used. \\n\\n```\\n(h, m) > (hour, minute)\\n```\\n\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        def permutations(i=0): \\n            \"\"\"Return all permutations via generator.\"\"\"\\n            if i == len(A): yield A\\n            for ii in range(i, len(A)): \\n                A[i], A[ii] = A[ii], A[i]\\n                yield from permutations(i+1)\\n                A[i], A[ii] = A[ii], A[i]\\n        \\n        hh = mm = -1\\n        for x in permutations(): \\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60 and 60*hh + mm < 60*h + m: hh, mm = h, m \\n        return f\"{hh:02}:{mm:02}\" if hh >= 0 else \"\"\\n```\\n\\nEdited on 12/16/2020\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        def fn(i): \\n            \"\"\"Return unique permutations of arr.\"\"\"\\n            if i == 4: yield arr\\n            else: \\n                seen = set()\\n                for ii in range(i, 4):\\n                    if arr[ii] not in seen: \\n                        seen.add(arr[ii])\\n                        arr[i], arr[ii] = arr[ii], arr[i]\\n                        yield from fn(i+1)\\n                        arr[i], arr[ii] = arr[ii], arr[i]\\n        \\n        hh = mm = -1\\n        for x in fn(0):\\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60: hh, mm = max((hh, mm), (h, m))\\n        return f\"{hh:02}:{mm:02}\" if hh > -1 else \"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        hh = mm = -1\\n        for x in set(permutations(A, 4)): \\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60 and 60*h + m > 60*hh + mm: hh, mm = h, m\\n        return f\"{hh:02}:{mm:02}\" if hh >= 0 else \"\"\\n```\n```\\n(h, m) > (hour, minute)\\n```\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        def permutations(i=0): \\n            \"\"\"Return all permutations via generator.\"\"\"\\n            if i == len(A): yield A\\n            for ii in range(i, len(A)): \\n                A[i], A[ii] = A[ii], A[i]\\n                yield from permutations(i+1)\\n                A[i], A[ii] = A[ii], A[i]\\n        \\n        hh = mm = -1\\n        for x in permutations(): \\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60 and 60*hh + mm < 60*h + m: hh, mm = h, m \\n        return f\"{hh:02}:{mm:02}\" if hh >= 0 else \"\"\\n```\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        def fn(i): \\n            \"\"\"Return unique permutations of arr.\"\"\"\\n            if i == 4: yield arr\\n            else: \\n                seen = set()\\n                for ii in range(i, 4):\\n                    if arr[ii] not in seen: \\n                        seen.add(arr[ii])\\n                        arr[i], arr[ii] = arr[ii], arr[i]\\n                        yield from fn(i+1)\\n                        arr[i], arr[ii] = arr[ii], arr[i]\\n        \\n        hh = mm = -1\\n        for x in fn(0):\\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60: hh, mm = max((hh, mm), (h, m))\\n        return f\"{hh:02}:{mm:02}\" if hh > -1 else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352795,
                "title": "solution-in-python-3-beats-100",
                "content": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n    \\tT, M = [], 0\\n    \\tfor t in set(permutations(A)):\\n    \\t\\th = t[0]*10 + t[1]\\n    \\t\\tm = 60*h + 10*t[2] + t[3]\\n    \\t\\tif h <= 23 and t[2] in [0,1,2,3,4,5] and m < 1440 and m > M: M, T = m, t\\n    \\treturn f\"{T[0]}{T[1]}:{T[2]}{T[3]}\" if len(T) !=0 else \"00:00\" if A == [0,0,0,0] else \"\"\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCodeID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n    \\tT, M = [], 0\\n    \\tfor t in set(permutations(A)):\\n    \\t\\th = t[0]*10 + t[1]\\n    \\t\\tm = 60*h + 10*t[2] + t[3]\\n    \\t\\tif h <= 23 and t[2] in [0,1,2,3,4,5] and m < 1440 and m > M: M, T = m, t\\n    \\treturn f\"{T[0]}",
                "codeTag": "Java"
            },
            {
                "id": 239233,
                "title": "c-solution",
                "content": "```\\nvoid permutation(int* A, int l , int r, int* count, int** table)\\n{\\n    if(l == r)\\n    {\\n        for(int i = 0; i < 4; i++)\\n        {\\n            table[*count][i] = A[i];\\n        }\\n        *count += 1;\\n        return;\\n    }\\n    else\\n    {\\n        for (int i = l; i <= r; i++)\\n        {\\n            int temp;\\n            temp = A[l];\\n            A[l] = A[i];\\n            A[i] = temp;\\n            permutation(A, l+1, r, count, table);\\n            temp = A[l];\\n            A[l] = A[i];\\n            A[i] = temp;\\n        }\\n    }\\n}\\n\\nchar* largestTimeFromDigits(int* A, int ASize) {\\n    int** table = malloc(sizeof(int*)*24);\\n    int count = 0;\\n    int max = -1;\\n    for(int i = 0; i < 24; i++)\\n    {\\n        table[i] = calloc(4, sizeof(int));\\n    }\\n    char* ans = calloc(6, sizeof(char));\\n    permutation(A, 0, ASize-1, &count, table);\\n    int temp;\\n    \\n    for(int i = 0; i < 24; i++)\\n    {\\n        if(table[i][0] == 2)\\n        {\\n            if(table[i][1] < 4)\\n            {\\n                if(table[i][2] < 6)\\n                {\\n                    temp = table[i][0]*1000 + table[i][1]*100 + table[i][2]*10 + table[i][3];\\n                    if (temp > max) max = temp;\\n                }\\n            }\\n        }\\n        else if(table[i][0] < 2)\\n        {\\n            if(table[i][2] < 6)\\n            {\\n                temp = table[i][0]*1000 + table[i][1]*100 + table[i][2]*10 + table[i][3];\\n                if (temp > max) max = temp;\\n            }\\n        }\\n    }\\n    if(max <0) return ans;\\n    ans[2] = \\':\\';\\n    ans[5] = \\'\\\\0\\';\\n    ans[4] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[3] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[1] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[0] = max % 10 + \\'0\\';\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid permutation(int* A, int l , int r, int* count, int** table)\\n{\\n    if(l == r)\\n    {\\n        for(int i = 0; i < 4; i++)\\n        {\\n            table[*count][i] = A[i];\\n        }\\n        *count += 1;\\n        return;\\n    }\\n    else\\n    {\\n        for (int i = l; i <= r; i++)\\n        {\\n            int temp;\\n            temp = A[l];\\n            A[l] = A[i];\\n            A[i] = temp;\\n            permutation(A, l+1, r, count, table);\\n            temp = A[l];\\n            A[l] = A[i];\\n            A[i] = temp;\\n        }\\n    }\\n}\\n\\nchar* largestTimeFromDigits(int* A, int ASize) {\\n    int** table = malloc(sizeof(int*)*24);\\n    int count = 0;\\n    int max = -1;\\n    for(int i = 0; i < 24; i++)\\n    {\\n        table[i] = calloc(4, sizeof(int));\\n    }\\n    char* ans = calloc(6, sizeof(char));\\n    permutation(A, 0, ASize-1, &count, table);\\n    int temp;\\n    \\n    for(int i = 0; i < 24; i++)\\n    {\\n        if(table[i][0] == 2)\\n        {\\n            if(table[i][1] < 4)\\n            {\\n                if(table[i][2] < 6)\\n                {\\n                    temp = table[i][0]*1000 + table[i][1]*100 + table[i][2]*10 + table[i][3];\\n                    if (temp > max) max = temp;\\n                }\\n            }\\n        }\\n        else if(table[i][0] < 2)\\n        {\\n            if(table[i][2] < 6)\\n            {\\n                temp = table[i][0]*1000 + table[i][1]*100 + table[i][2]*10 + table[i][3];\\n                if (temp > max) max = temp;\\n            }\\n        }\\n    }\\n    if(max <0) return ans;\\n    ans[2] = \\':\\';\\n    ans[5] = \\'\\\\0\\';\\n    ans[4] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[3] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[1] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[0] = max % 10 + \\'0\\';\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200580,
                "title": "c-simple-code-next-permutation",
                "content": "Using the next_permutation in c++, we can simply generate all permutations and just check 1 by 1.\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int ans = -1;\\n        string s;\\n        do {\\n            int h = A[0] * 10 + A[1];\\n            int m = A[2] * 10 + A[3];\\n            if(h >= 24 || m >= 60) continue;\\n            if(h * 60 + m > ans) {\\n                ans = h * 60 + m;\\n                s.clear();\\n                s.push_back(A[0] + 48);\\n                s.push_back(A[1] + 48);\\n                s.push_back(\\':\\');\\n                s.push_back(A[2] + 48);\\n                s.push_back(A[3] + 48);\\n            }\\n        } while(next_permutation(A.begin(), A.end()));\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int ans = -1;\\n        string s;\\n        do {\\n            int h = A[0] * 10 + A[1];\\n            int m = A[2] * 10 + A[3];\\n            if(h >= 24 || m >= 60) continue;\\n            if(h * 60 + m > ans) {\\n                ans = h * 60 + m;\\n                s.clear();\\n                s.push_back(A[0] + 48);\\n                s.push_back(A[1] + 48);\\n                s.push_back(\\':\\');\\n                s.push_back(A[2] + 48);\\n                s.push_back(A[3] + 48);\\n            }\\n        } while(next_permutation(A.begin(), A.end()));\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949801,
                "title": "easy-python-solution-strings-permutations",
                "content": "# Code\\n```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\n        x = permutations(arr)\\n        ans = []\\n        currTime = \"\"\\n        for i in x:\\n            h, m = \"\", \"\"\\n            for j in i[:2]:\\n                h += str(j)\\n            for j in i[2:]:\\n                m += str(j)\\n            \\n            if h >= \"00\" and h <= \"23\" and m >= \"00\" and m <= \"59\":\\n                if currTime == \"\":\\n                    currTime = f\"{h}:{m}\"\\n                else:\\n                    if currTime < f\"{h}:{m}\":\\n                        currTime = f\"{h}:{m}\"\\n        return currTime\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\n        x = permutations(arr)\\n        ans = []\\n        currTime = \"\"\\n        for i in x:\\n            h, m = \"\", \"\"\\n            for j in i[:2]:\\n                h += str(j)\\n            for j in i[2:]:\\n                m += str(j)\\n            \\n            if h >= \"00\" and h <= \"23\" and m >= \"00\" and m <= \"59\":\\n                if currTime == \"\":\\n                    currTime = f\"{h}:{m}\"\\n                else:\\n                    if currTime < f\"{h}:{m}\":\\n                        currTime = f\"{h}:{m}\"\\n        return currTime\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764422,
                "title": "using-if-else-if-and-only-loop-brute-force-solution-in-java",
                "content": "Here is the  basic and most brute force approach solution.  Over here I have made the basic If\\'s that are needed to keep in mind to solve it. \\n\\n\\n# Complexity\\n- Time complexity: The Time complexity is O(nlog). \\n\\n- Space complexity: The space Complexity is O(n);\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        List<Integer> list=new ArrayList<>();\\n        int p1=Integer.MIN_VALUE;\\n        int p2=Integer.MIN_VALUE;\\n        //Adding elements to the list\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            list.add(arr[i]);\\n        }\\n        //for hour need to get the first digit...1 or 2.. or 0\\n        //when list contains 2 zeores....\\n        if(list.contains(0))\\n        {\\n            List<Integer> l1= new ArrayList<>(list);\\n            int count=0;\\n            while(l1.contains(0) && count<2)\\n            {\\n                l1.remove((Integer)0);\\n                count++;\\n            }\\n            if(count==2)\\n            {\\n                Collections.sort(l1);\\n                System.out.println(l1);\\n                String str=\"\";\\n                if(l1.get(1)<=2 && l1.get(0)<=2)\\n                {\\n                    return l1.get(1)+\"\"+l1.get(0)+\":00\";\\n                }\\n                if(l1.get(0)==0 && l1.get(1)==0)\\n                {\\n                    return \"00:00\";\\n                } \\n                if(l1.get(0)==1 && l1.get(1)<=9 && l1.get(1)>2)\\n                {\\n                    return l1.get(0)+\"\"+l1.get(1)+\":\"+\"0\"+\"0\"; \\n                }\\n                if(l1.get(0)==2 && l1.get(1)<=3)\\n                {\\n                    return l1.get(0)+\"\"+l1.get(1)+\":\"+\"0\"+\"0\"; \\n                }\\n\\n                if(l1.get(0)==2 && l1.get(1)<=5 )\\n                {\\n                    return l1.get(0)+\"0:\"+l1.get(1)+\"0\";\\n                }\\n                if(l1.get(0)==2 && l1.get(1)>=5 )\\n                {\\n                    return l1.get(0)+\"0:\"+\"0\"+l1.get(1);\\n                }\\n                if(l1.get(1)<=1 && l1.get(0)<=1)\\n                {\\n                    return l1.get(1)+\"\"+l1.get(0)+\":00\";\\n                }\\n                else if(l1.get(0)>5)\\n                {\\n                    return \"0\"+l1.get(1)+\":0\"+l1.get(0);\\n                }\\n                return \"0\"+l1.get(1)+\":\"+l1.get(0)+\"0\"; \\n            }\\n        }\\n            for(int i=2;i>=0;i--)\\n            {\\n                if(list.contains(i))\\n                {\\n                    p1=i;// 2\\n                    list.remove((Integer)i);\\n                    break;\\n                }\\n            }\\n        int flag=0;\\n        if(p1==2)\\n        {\\n            for(int i=3;i>=0;i--)\\n            {\\n                if(list.contains(i))\\n                {\\n                    p2=i;\\n                    list.remove((Integer)i);\\n                    break;\\n                }\\n            }\\n        }\\n        else if(p1<=1)\\n        {\\n            for(int i=9;i>=0;i--)\\n            {\\n                if(list.contains(i))\\n                {\\n                    p2=i;\\n                    list.remove((Integer)i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(p1==Integer.MIN_VALUE || p2==Integer.MIN_VALUE)\\n        {\\n            return \"\";\\n        }\\n        Collections.sort(list);\\n        String str=\"\";\\n        if(list.get(0)==0)\\n        {\\n            if(list.get(1)<=5)\\n            {\\n                return p1+\"\"+p2+\":\"+list.get(1)+\"\"+list.get(0);\\n            }\\n            else if(list.get(1)>5)\\n            {\\n                return p1+\"\"+p2+\":\"+list.get(0)+\"\"+list.get(1);\\n            }\\n        }\\n        int dd1=list.get(0)+list.get(1)*10;\\n        int dd2=list.get(0)*10+list.get(1);\\n        if(dd1>=dd2 && dd1<=59)\\n        {\\n            str=dd1+\"\";\\n        }\\n        else if(dd2<dd1 && dd2<=59)\\n        {\\n            str=dd2+\"\";\\n        }\\n        else if(dd1>59 && dd2>59)\\n        {\\n            if(list.get(0)>5)\\n            {\\n                if(p2==0)\\n                {\\n                    return p2+\"\"+list.get(1)+\":\"+p1+\"\"+list.get(0);\\n                }\\n                else if(p1==0 && p2<=5)\\n                {\\n                    return p1+\"\"+list.get(1)+\":\"+p2+\"\"+list.get(0);\\n                }\\n                else if(p2==1)\\n                {\\n                    return p2+\"\"+list.get(1)+\":\"+p1+\"\"+list.get(0);\\n                }\\n                return \"\";\\n            }\\n            else if(p2==2 && p1>=0)\\n            {\\n                return \"\";\\n            }\\n            return \"\";\\n        }\\n        str=p1+\"\"+p2+\":\"+str;\\n        return str;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        List<Integer> list=new ArrayList<>();\\n        int p1=Integer.MIN_VALUE;\\n        int p2=Integer.MIN_VALUE;\\n        //Adding elements to the list\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            list.add(arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2358664,
                "title": "c-iterative-solution-backward-time-travel",
                "content": "A clock has 4 digits. For each position, there are some limitations. For example, in the first position of a time, you can put only 0, 1, or 2. The same goes for the other positions too. If you want to do this then the problem will become so complicated. So, here I come up with a brute-force approach. Just start the time from 23:59, then run a simple loop. In each loop the time will go backward by 1 minute, i.e 23:59, then  23:58, 23:57... The loop will end when the time is 00:00. For each time, check if all digits in the current time are present in the given array. We can check it by mapping the given digits. If we find all digits we can return the current time, which is our answer. If we finish our loop without a valid solution then the answer is empty string. Check the code for more clarification. :)  \\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int min = 59;\\n        int hour = 23;\\n        int mp[12] = {0};\\n        for (auto it : arr) {\\n            mp[it]++;\\n        }\\n        while (1) {\\n            string s;\\n            string m, h;\\n            m = to_string(min);\\n            h = to_string(hour);\\n            if (m.size() == 1)m = \\'0\\' + m;\\n            if (h.size() == 1)h = \\'0\\' + h;\\n            int tmp[12];\\n            for (int i = 0; i < 10; i++) {\\n                tmp[i] = mp[i];\\n\\n            }\\n            s = h + \":\" + m;\\n            bool f = true;\\n            for (int i = 0; i < 5 and f; i++) {\\n                if (i == 2)continue;\\n                if (tmp[s[i] - \\'0\\']) {\\n                    tmp[s[i] - \\'0\\']--;\\n                }\\n                else f = false;\\n            }\\n            if (f)return s;\\n            min--;\\n            if (min < 0) {\\n                min = 59;\\n                hour--;\\n            }\\n            if (hour < 0)break;\\n        }\\n        return \"\";\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int min = 59;\\n        int hour = 23;\\n        int mp[12] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2243093,
                "title": "generate-permutation-and-get-the-conditionally-max-one",
                "content": "```\\nvoid perm(vector<vector<int> > &res,int ind,int n , vector<int> &t,vector<int> a)\\n{\\n    if(ind == n)\\n    {\\n        res.push_back(t);\\n        return;\\n    }\\n    \\n    for(int i=ind;i<n;i++)\\n    {\\n        t.push_back(a[i]);\\n        swap(a[i],a[ind]);\\n        \\n        perm(res,ind+1,n,t,a);\\n        swap(a[i],a[ind]);\\n        t.pop_back();\\n    }\\n    \\n    \\n}\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& a) {\\n        \\n       vector<vector<int> > res;\\n       \\n        vector<int > t;\\n        perm(res,0,4,t,a);\\n        int ind = -1;\\n        sort(res.begin(),res.end());\\n        for(int i=0;i<res.size();i++)\\n        {\\n            \\n            \\n            if(res[i][0]<=2 && res[i][1]<=3 || res[i][0]<=1 )\\n            {\\n                if(res[i][2] <6)\\n                    ind = i;\\n            }\\n            else\\n            {\\n                break;                \\n            }\\n        }\\n        \\n        if(ind == -1)\\n            return \"\";\\n        \\n        \\n        t = res[ind];\\n        string ans = to_string(t[0])+to_string(t[1])+\":\"+ to_string(t[2])+to_string(t[3]);\\n        \\n      return ans;  \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvoid perm(vector<vector<int> > &res,int ind,int n , vector<int> &t,vector<int> a)\\n{\\n    if(ind == n)\\n    {\\n        res.push_back(t);\\n        return;\\n    }\\n    \\n    for(int i=ind;i<n;i++)\\n    {\\n        t.push_back(a[i]);\\n        swap(a[i],a[ind]);\\n        \\n        perm(res,ind+1,n,t,a);\\n        swap(a[i],a[ind]);\\n        t.pop_back();\\n    }\\n    \\n    \\n}\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& a) {\\n        \\n       vector<vector<int> > res;\\n       \\n        vector<int > t;\\n        perm(res,0,4,t,a);\\n        int ind = -1;\\n        sort(res.begin(),res.end());\\n        for(int i=0;i<res.size();i++)\\n        {\\n            \\n            \\n            if(res[i][0]<=2 && res[i][1]<=3 || res[i][0]<=1 )\\n            {\\n                if(res[i][2] <6)\\n                    ind = i;\\n            }\\n            else\\n            {\\n                break;                \\n            }\\n        }\\n        \\n        if(ind == -1)\\n            return \"\";\\n        \\n        \\n        t = res[ind];\\n        string ans = to_string(t[0])+to_string(t[1])+\":\"+ to_string(t[2])+to_string(t[3]);\\n        \\n      return ans;  \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093775,
                "title": "c-backtracking-permutation-approach",
                "content": "```\\npublic class Solution {\\n    public string LargestTimeFromDigits(int[] arr)\\n    {\\n        string result = string.Empty;\\n        HashSet<string> times = new HashSet<string>();\\n        \\n        // Find all permutations\\n        Backtrack(arr, 0, arr.Length - 1, ref times);\\n\\n        if (times.Count == 0)\\n            return result;\\n\\n        // Find out the maximum time from permutation\\n        int maxHour = 0;\\n        int maxMinute = 0;\\n        foreach(string time in times) \\n        {\\n            //time format = \"HH:mm\"\\n            int hr = Convert.ToInt32(time.Substring(0, 2));\\n            int minute = Convert.ToInt32(time.Substring(3,2));\\n            \\n            //Only update if hour is greater, or same hour with same or greater minutes\\n            if(hr > maxHour || (hr == maxHour && minute >= maxMinute)) \\n            {\\n                maxHour = hr;\\n                maxMinute = minute;\\n                result = time;\\n            }\\n        }\\n\\n        return result;\\n    }\\n    \\n    public static int[] Swap(ref int[] arr, int i, int j) \\n    {\\n        var temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n        return arr;\\n    }\\n    \\n    // Check if its a valid time and add to the hashset\\n    public static void AddValidTime(string time, ref HashSet<string> times)\\n    {\\n        //The format is -- HH:mm \\n        string hour = $\"{time[0]}{time[1]}\";\\n        string minute = $\"{time[2]}{time[3]}\";\\n        if (Convert.ToInt32(hour) < 24 && Convert.ToInt32(minute) < 60)\\n        {\\n            time = $\"{hour}:{minute}\";\\n            times.Add(time);\\n        }\\n    }\\n\\n    public static void Backtrack(int[] arr, int left, int right, ref HashSet<string> times) \\n    {\\n        // Base case\\n        if(left == right) \\n        {\\n            // Only add to the permutation list if it is a valid time\\n            string permutation = string.Join(string.Empty, arr);\\n            AddValidTime(permutation, ref times);\\n            return;\\n        }\\n        else \\n        {\\n            for (int i = left; i <= right; i++)\\n            {\\n                Swap(ref arr, left, i);\\n                Backtrack(arr, left + 1, right, ref times);\\n                Swap(ref arr, left, i);\\n            }\\n        }\\n\\n        return;\\n\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/daadbec4-5b0a-4d95-ab6a-8407f52bd994_1653985012.9550817.png)\\n\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\npublic class Solution {\\n    public string LargestTimeFromDigits(int[] arr)\\n    {\\n        string result = string.Empty;\\n        HashSet<string> times = new HashSet<string>();\\n        \\n        // Find all permutations\\n        Backtrack(arr, 0, arr.Length - 1, ref times);\\n\\n        if (times.Count == 0)\\n            return result;\\n\\n        // Find out the maximum time from permutation\\n        int maxHour = 0;\\n        int maxMinute = 0;\\n        foreach(string time in times) \\n        {\\n            //time format = \"HH:mm\"\\n            int hr = Convert.ToInt32(time.Substring(0, 2));\\n            int minute = Convert.ToInt32(time.Substring(3,2));\\n            \\n            //Only update if hour is greater, or same hour with same or greater minutes\\n            if(hr > maxHour || (hr == maxHour && minute >= maxMinute)) \\n            {\\n                maxHour = hr;\\n                maxMinute = minute;\\n                result = time;\\n            }\\n        }\\n\\n        return result;\\n    }\\n    \\n    public static int[] Swap(ref int[] arr, int i, int j) \\n    {\\n        var temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n        return arr;\\n    }\\n    \\n    // Check if its a valid time and add to the hashset\\n    public static void AddValidTime(string time, ref HashSet<string> times)\\n    {\\n        //The format is -- HH:mm \\n        string hour = $\"{time[0]}{time[1]}\";\\n        string minute = $\"{time[2]}{time[3]}\";\\n        if (Convert.ToInt32(hour) < 24 && Convert.ToInt32(minute) < 60)\\n        {\\n            time = $\"{hour}:{minute}\";\\n            times.Add(time);\\n        }\\n    }\\n\\n    public static void Backtrack(int[] arr, int left, int right, ref HashSet<string> times) \\n    {\\n        // Base case\\n        if(left == right) \\n        {\\n            // Only add to the permutation list if it is a valid time\\n            string permutation = string.Join(string.Empty, arr);\\n            AddValidTime(permutation, ref times);\\n            return;\\n        }\\n        else \\n        {\\n            for (int i = left; i <= right; i++)\\n            {\\n                Swap(ref arr, left, i);\\n                Backtrack(arr, left + 1, right, ref times);\\n                Swap(ref arr, left, i);\\n            }\\n        }\\n\\n        return;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856698,
                "title": "runtime-1-ms-faster-than-100-00-of-java-online-submissions-for-largest-time-for-given-digits",
                "content": "```public class LargestTimeForGivenDigits {\\n    int[] arr;\\n    int[] count = new int[10];\\n    int countOfNrGreaterThan5 = 0;\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        this.arr = arr;\\n        for (int i : arr) {\\n            count[i] += 1;\\n            if (i > 5) {\\n                countOfNrGreaterThan5++;\\n            }\\n            if (i >= 6 && count[i] > 2) {\\n                return \"\";\\n            }\\n            if (countOfNrGreaterThan5 >= 3) {\\n                return \"\";\\n            }\\n        }\\n\\n\\n        int hr1 = get1stHrIndex();\\n        if (hr1 == -1) {\\n            return \"\";\\n        }\\n        int hr2 = get2ndHrIndex(hr1);\\n        if (hr2 == -1) {\\n            return \"\";\\n        }\\n        int min1 = get1stMinuteIndex();\\n        if (min1 == -1) {\\n            return \"\";\\n        }\\n        int min2 = get2ndMinuteIndex();\\n        if (min2 == -1) {\\n            return \"\";\\n        }\\n        StringBuilder sb = new StringBuilder(5);\\n        return sb.append(hr1).append(hr2).append(\":\").append(min1).append(min2).toString();\\n    }\\n\\n    private int get2ndMinuteIndex() {\\n        return findByLoopingNTo0(9);\\n    }\\n\\n    private int get1stMinuteIndex() {\\n        return findByLoopingNTo0(5);\\n    }\\n\\n    private int get2ndHrIndex(int hr1) {\\n        if (hr1 == 2) {\\n            return findByLoopingNTo0(3);\\n        }\\n        return findByLoopingNTo0(9);\\n    }\\n\\n    private int get1stHrIndex() {\\n\\n        int i = 2;\\n        if (countOfNrGreaterThan5 >= 2) {\\n            i = 1;\\n        }\\n        return findByLoopingNTo0(i);\\n    }\\n\\n    private int findByLoopingNTo0(int n){\\n        for (int i = n; i >= 0; i--) {\\n            if (count[i] > 0) {\\n                count[i] -= 1;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "```public class LargestTimeForGivenDigits {\\n    int[] arr;\\n    int[] count = new int[10];\\n    int countOfNrGreaterThan5 = 0;\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        this.arr = arr;\\n        for (int i : arr) {\\n            count[i] += 1;\\n            if (i > 5) {\\n                countOfNrGreaterThan5++;\\n            }\\n            if (i >= 6 && count[i] > 2) {\\n                return \"\";\\n            }\\n            if (countOfNrGreaterThan5 >= 3) {\\n                return \"\";\\n            }\\n        }\\n\\n\\n        int hr1 = get1stHrIndex();\\n        if (hr1 == -1) {\\n            return \"\";\\n        }\\n        int hr2 = get2ndHrIndex(hr1);\\n        if (hr2 == -1) {\\n            return \"\";\\n        }\\n        int min1 = get1stMinuteIndex();\\n        if (min1 == -1) {\\n            return \"\";\\n        }\\n        int min2 = get2ndMinuteIndex();\\n        if (min2 == -1) {\\n            return \"\";\\n        }\\n        StringBuilder sb = new StringBuilder(5);\\n        return sb.append(hr1).append(hr2).append(\":\").append(min1).append(min2).toString();\\n    }\\n\\n    private int get2ndMinuteIndex() {\\n        return findByLoopingNTo0(9);\\n    }\\n\\n    private int get1stMinuteIndex() {\\n        return findByLoopingNTo0(5);\\n    }\\n\\n    private int get2ndHrIndex(int hr1) {\\n        if (hr1 == 2) {\\n            return findByLoopingNTo0(3);\\n        }\\n        return findByLoopingNTo0(9);\\n    }\\n\\n    private int get1stHrIndex() {\\n\\n        int i = 2;\\n        if (countOfNrGreaterThan5 >= 2) {\\n            i = 1;\\n        }\\n        return findByLoopingNTo0(i);\\n    }\\n\\n    private int findByLoopingNTo0(int n){\\n        for (int i = n; i >= 0; i--) {\\n            if (count[i] > 0) {\\n                count[i] -= 1;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1784653,
                "title": "faster-than-100-in-python",
                "content": "\\t\\tmax_time = -1\\n        max_time_str = \"\"\\n        for n1 in [0,1,2,3]:\\n            for n2 in [0,1,2,3]:\\n                if n2 == n1:\\n                    continue\\n                d1 = arr[n1]*10 + arr[n2]\\n                if d1>23:\\n                    continue\\n                for n3 in [0,1,2,3]:\\n                    if n3 == n1 or n3 == n2:\\n                        continue\\n                    for n4 in [0,1,2,3]:\\n                        if n4 == n1 or n4 == n2 or n4 == n3:\\n                            continue\\n                        d2 = arr[n3]*10 + arr[n4]\\n                        if d2>59:\\n                            continue\\n                        this_time = d1*100+d2\\n                        if this_time > max_time:\\n                            max_time = this_time\\n                            max_time_str = str(arr[n1])+str(arr[n2])+\":\"+str(arr[n3])+str(arr[n4])\\n        return max_time_str\\n```",
                "solutionTags": [],
                "code": "\\t\\tmax_time = -1\\n        max_time_str = \"\"\\n        for n1 in [0,1,2,3]:\\n            for n2 in [0,1,2,3]:\\n                if n2 == n1:\\n                    continue\\n                d1 = arr[n1]*10 + arr[n2]\\n                if d1>23:\\n                    continue\\n                for n3 in [0,1,2,3]:\\n                    if n3 == n1 or n3 == n2:\\n                        continue\\n                    for n4 in [0,1,2,3]:\\n                        if n4 == n1 or n4 == n2 or n4 == n3:\\n                            continue\\n                        d2 = arr[n3]*10 + arr[n4]\\n                        if d2>59:\\n                            continue\\n                        this_time = d1*100+d2\\n                        if this_time > max_time:\\n                            max_time = this_time\\n                            max_time_str = str(arr[n1])+str(arr[n2])+\":\"+str(arr[n3])+str(arr[n4])\\n        return max_time_str\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1707920,
                "title": "python-regex-and-itertools-permutations",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\t\\t# create regex for valid times\\n        time_re = re.compile(\\'[01][0-9]:[0-5][0-9]|2[0-3]:[0-5][0-9]\\')\\n        ans = \\'\\'\\n        for a,b,c,d in itertools.permutations(arr):\\n\\t\\t\\t# concat each number into a time string\\n            each_time = str(a) + str(b) + \\':\\' + str(c) + str(d)\\n\\t\\t\\t# compare each valid time string to the max so far.\\n            if time_re.match(each_time):\\n                ans = max(ans, each_time)\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\t\\t# create regex for valid times\\n        time_re = re.compile(\\'[01][0-9]:[0-5][0-9]|2[0-3]:[0-5][0-9]\\')\\n        ans = \\'\\'\\n        for a,b,c,d in itertools.permutations(arr):\\n\\t\\t\\t# concat each number into a time string\\n            each_time = str(a) + str(b) + \\':\\' + str(c) + str(d)\\n\\t\\t\\t# compare each valid time string to the max so far.\\n            if time_re.match(each_time):\\n                ans = max(ans, each_time)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704853,
                "title": "simple-commented-c",
                "content": "```\\n/*\\n    -Approach:\\n    -format of time is :\"HH:MM\" \\n    -in order to form largest possible time we have to form largest value of HH & MM which is valid hour & minutes\\n    -we will try different permutations of elements given array to form largest time\\n    \\n    - we will try different permutations of indexes of array\\n    - 3 different indexes of time can be formed by using 3 different loops\\n    - 4th index of time is (6-(sum of previous 3 indexes)) \\n    -Note: Sum of all the indexes is 6 (because we 4 elements)\\n*/\\n```\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    string largestTimeFromDigits(vector<int>& arr) {\\n        \\n        string ans=\"\";\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<4;j++){\\n                for(int k=0;k<4;k++){\\n                    \\n                    //we can use each digit exactly once\\n                    if(i==j || j==k || k==i)\\n                        continue;\\n                    \\n                    //possible values of hh & mm\\n                    string hh=to_string(arr[i])+to_string(arr[j]);\\n                    string mm=to_string(arr[k]) + to_string(arr[6-i-j-k]);\\n                    string _time= hh + \":\" + mm;\\n                   \\n                    //comparasion in strings are done characeter by character\\n                    if( hh < \"24\" && mm < \"60\" && _time > ans)\\n                        ans=_time;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    -Approach:\\n    -format of time is :\"HH:MM\" \\n    -in order to form largest possible time we have to form largest value of HH & MM which is valid hour & minutes\\n    -we will try different permutations of elements given array to form largest time\\n    \\n    - we will try different permutations of indexes of array\\n    - 3 different indexes of time can be formed by using 3 different loops\\n    - 4th index of time is (6-(sum of previous 3 indexes)) \\n    -Note: Sum of all the indexes is 6 (because we 4 elements)\\n*/\\n```\n```\\n\\nclass Solution {\\npublic:\\n    \\n    string largestTimeFromDigits(vector<int>& arr) {\\n        \\n        string ans=\"\";\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<4;j++){\\n                for(int k=0;k<4;k++){\\n                    \\n                    //we can use each digit exactly once\\n                    if(i==j || j==k || k==i)\\n                        continue;\\n                    \\n                    //possible values of hh & mm\\n                    string hh=to_string(arr[i])+to_string(arr[j]);\\n                    string mm=to_string(arr[k]) + to_string(arr[6-i-j-k]);\\n                    string _time= hh + \":\" + mm;\\n                   \\n                    //comparasion in strings are done characeter by character\\n                    if( hh < \"24\" && mm < \"60\" && _time > ans)\\n                        ans=_time;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634912,
                "title": "949-python3-in-case-the-interviewer-asks-u-to-write-the-permutation-using-backtracking",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        def backtrack(curr):\\n            if len(curr) == n:\\n                return [list(curr)]\\n            res = []\\n            for i in range(n):\\n                if i not in curr:\\n                    res.extend(backtrack(curr + [i]))\\n            return res\\n\\n        n, res = len(arr), -1\\n\\n        for i1, i2, i3, i4 in backtrack([]):\\n            h, m = arr[i1] * 10 + arr[i2], arr[i3] * 10 + arr[i4]\\n            if h < 24 and m < 60:\\n                res = max(res, h * 60 + m)\\n\\n        return \"{:02d}:{:02d}\".format(res // 60, res % 60) if res != -1 else \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        def backtrack(curr):\\n            if len(curr) == n:\\n                return [list(curr)]\\n            res = []\\n            for i in range(n):\\n                if i not in curr:\\n                    res.extend(backtrack(curr + [i]))\\n            return res\\n\\n        n, res = len(arr), -1\\n\\n        for i1, i2, i3, i4 in backtrack([]):\\n            h, m = arr[i1] * 10 + arr[i2], arr[i3] * 10 + arr[i4]\\n            if h < 24 and m < 60:\\n                res = max(res, h * 60 + m)\\n\\n        return \"{:02d}:{:02d}\".format(res // 60, res % 60) if res != -1 else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584831,
                "title": "fastest-python3-solution-in-just-1-line-of-actual-code",
                "content": "```python\\nfrom itertools import permutations\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        return max(map(lambda t: \"{}{}:{}{}\".format(*t) if 10*t[0]+t[1] < 24 and 10*t[2]+t[3] < 60 else \"\", permutations(arr)))\\n\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom itertools import permutations\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        return max(map(lambda t: \"{}{}:{}{}\".format(*t) if 10*t[0]+t[1] < 24 and 10*t[2]+t[3] < 60 else \"\", permutations(arr)))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455545,
                "title": "c-solution",
                "content": "```class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string result;\\n        for(int i=0;i<=3;++i){\\n           for(int j=0;j<=3;++j){\\n                for(int k=0;k<=3;++k){\\n                    if(i==j or j==k or k==i)\\n                        continue;\\n                    string hh = to_string(arr[i]) + to_string(arr[j]);\\n                    string mm = to_string(arr[k]) + to_string(arr[6-i-j-k]);\\n                    \\n                    string temp = hh + \":\" + mm;\\n                    \\n                    if(hh < \"24\" and mm < \"60\" and temp > result){\\n                        result = temp;\\n                    }\\n                }\\n            } \\n        }\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string result;\\n        for(int i=0;i<=3;++i){\\n           for(int j=0;j<=3;++j){\\n                for(int k=0;k<=3;++k){\\n                    if(i==j or j==k or k==i)\\n                        continue;\\n                    string hh = to_string(arr[i]) + to_string(arr[j]);\\n                    string mm = to_string(arr[k]) + to_string(arr[6-i-j-k]);\\n                    \\n                    string temp = hh + \":\" + mm;\\n                    \\n                    if(hh < \"24\" and mm < \"60\" and temp > result){\\n                        result = temp;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1405149,
                "title": "python-1-liner-92",
                "content": "\\n```\\ndef largestTimeFromDigits(self, arr: List[int]) -> str:\\n        return max((f\"{a}{b}:{c}{d}\" for a,b,c,d in permutations(arr) \\n                   if f\"{a}{b}\" < \"24\" and f\"{c}{d}\" < \"60\"), default = \"\")\\n ```",
                "solutionTags": [],
                "code": "```\\ndef largestTimeFromDigits(self, arr: List[int]) -> str:\\n        return max((f\"{a}{b}:{c}{d}\" for a,b,c,d in permutations(arr) \\n                   if f\"{a}{b}\" < \"24\" and f\"{c}{d}\" < \"60\"), default = \"\")\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 1377045,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string str;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 3; i >= 0; str += char(arr[i--] + \\'0\\'));\\n        do {\\n            if (str.substr(0, 2) < \"24\" && str.substr(2) < \"60\")\\n                return str.substr(0, 2) + \":\" + str.substr(2);\\n        } while (prev_permutation(str.begin(), str.end()));\\n        return \"\" ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string str;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 3; i >= 0; str += char(arr[i--] + \\'0\\'));\\n        do {\\n            if (str.substr(0, 2) < \"24\" && str.substr(2) < \"60\")\\n                return str.substr(0, 2) + \":\" + str.substr(2);\\n        } while (prev_permutation(str.begin(), str.end()));\\n        return \"\" ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912416,
                "title": "java-0-ms",
                "content": "There are two valid options:\\n- 0..1; any; 0..5; any;\\n- 2; 0..3; 0..5; any;\\n\\nSo for the first case we need to have at least one digit to be in range of 0..1 and at least two digits in range of 0..5. It\\'s because 0..5 range includes 0..1.\\n\\nThe second case is slightly more complicated. \\'2\\' is a must. For range 0..3 we need to have at least two digits because \\'2\\' falls into this rang. Then we need to have one more for range 0..5 and again, because it includes 0..3 and \\'2\\' it should be 3+.\\n\\nPresent input as an array of ten elements each containing number of digits from input. For example for input [2, 9, 9, 1] it will be\\n[ 0, 1, 1, 0, 0, 0, 0, 0, 0, 2 ]\\n[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\\n\\ncalculate baskets:\\n[0..1] - 1\\n[0..3] - 2\\n[0..5] - 2\\n\\nAs we see the condition for [2; 0..3; 0..5; any] is not fullfilled. While we have \\'2\\' and 0..3 range, we lack digit in 0..5 range. However [0..1; any; 0..5; any] can be successfully combined.\\n\\nNow all we need to do - is to get max value from the range.\\n\\n```\\n    public static String largestTimeFromDigits(int[] input) {\\n        int[] numbers = new int[10];\\n        Arrays.fill(numbers, 0);\\n\\n        for (int n : input) {\\n            numbers[n]++;\\n        }\\n\\n        int zeroToOneBasket = numbers[0] + numbers[1];\\n        int zeroToThreeBasket = zeroToOneBasket + numbers[2] + numbers[3];\\n        int zeroToFiveBasket = zeroToThreeBasket + numbers[4] + numbers[5];\\n\\n        StringBuilder stringBuilder = new StringBuilder();\\n        if (numbers[2] > 0 && zeroToThreeBasket > 1 && zeroToFiveBasket > 2) {\\n            return stringBuilder\\n                    .append(removeMaxNLimitedBy(numbers, 2))\\n                    .append(removeMaxNLimitedBy(numbers, 3))\\n                    .append(\":\")\\n                    .append(removeMaxNLimitedBy(numbers, 5))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .toString();\\n        }\\n\\n        if (zeroToOneBasket > 0 && zeroToFiveBasket > 1) {\\n            return stringBuilder\\n                    .append(removeMaxNLimitedBy(numbers, 1))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .append(\":\")\\n                    .append(removeMaxNLimitedBy(numbers, 5))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .toString();\\n        }\\n\\n        return \"\";\\n    }\\n\\n    private static int removeMaxNLimitedBy(int[] numbers, int limitedBy) {\\n        for (int i = limitedBy; i >= 0; i--) {\\n            if (numbers[i] > 0) {\\n                numbers[i]--;\\n                return i;\\n            }\\n        }\\n\\n        throw new IllegalStateException();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public static String largestTimeFromDigits(int[] input) {\\n        int[] numbers = new int[10];\\n        Arrays.fill(numbers, 0);\\n\\n        for (int n : input) {\\n            numbers[n]++;\\n        }\\n\\n        int zeroToOneBasket = numbers[0] + numbers[1];\\n        int zeroToThreeBasket = zeroToOneBasket + numbers[2] + numbers[3];\\n        int zeroToFiveBasket = zeroToThreeBasket + numbers[4] + numbers[5];\\n\\n        StringBuilder stringBuilder = new StringBuilder();\\n        if (numbers[2] > 0 && zeroToThreeBasket > 1 && zeroToFiveBasket > 2) {\\n            return stringBuilder\\n                    .append(removeMaxNLimitedBy(numbers, 2))\\n                    .append(removeMaxNLimitedBy(numbers, 3))\\n                    .append(\":\")\\n                    .append(removeMaxNLimitedBy(numbers, 5))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .toString();\\n        }\\n\\n        if (zeroToOneBasket > 0 && zeroToFiveBasket > 1) {\\n            return stringBuilder\\n                    .append(removeMaxNLimitedBy(numbers, 1))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .append(\":\")\\n                    .append(removeMaxNLimitedBy(numbers, 5))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .toString();\\n        }\\n\\n        return \"\";\\n    }\\n\\n    private static int removeMaxNLimitedBy(int[] numbers, int limitedBy) {\\n        for (int i = limitedBy; i >= 0; i--) {\\n            if (numbers[i] > 0) {\\n                numbers[i]--;\\n                return i;\\n            }\\n        }\\n\\n        throw new IllegalStateException();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 910662,
                "title": "dfs-in-java-easy-to-understand-beats-80",
                "content": "the idea is to calculate all the valid times using backtracking,\\nand eliminate the recursion when we create a time that is not valid.\\n\\nwhen we have all the valid solutions, all we have to do is to sort the valid times by the default compare of String object, and then take the last one.\\n\\n\"\"\"\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        List<String> validTimes = dfs(arr);\\n        if(validTimes.size()==0) return \"\";\\n        Collections.sort(validTimes);\\n        String latestValidTime = validTimes.get(validTimes.size()-1);\\n        return latestValidTime.substring(0,2) + \":\" + latestValidTime.substring(2,4);\\n    }\\n    \\n    private List<String> dfs(int[] arr){\\n        List<String> validTimes = new ArrayList();\\n        Set<Integer> visitedIndexes = new HashSet();\\n        dfsHelper(validTimes, arr, \"\", visitedIndexes);\\n        return validTimes;\\n    }\\n    \\n    private void dfsHelper(List<String> validTimes, int[] arr, String builder, Set<Integer> visitedIndexes){\\n        if(visitedIndexes.size() ==4){\\n            validTimes.add(builder);\\n            return;\\n        }\\n        for(int i=0; i<4; i++){\\n            if(builder.length()==0 && arr[i] > 2) continue; //first digit is greater than 2\\n            if(builder.equals(\"2\") && arr[i] > 3) continue; //first 2 digits are greater than 24\\n            if(builder.length()==2 && arr[i] > 5) continue; // 3rd digit is greater than 5\\n            if(visitedIndexes.contains(i)) continue;\\n            visitedIndexes.add(i);\\n            dfsHelper(validTimes, arr, builder + String.valueOf(arr[i]), visitedIndexes);\\n            visitedIndexes.remove(i);\\n        }\\n    }\\n\"\"\"",
                "solutionTags": [],
                "code": "the idea is to calculate all the valid times using backtracking,\\nand eliminate the recursion when we create a time that is not valid.\\n\\nwhen we have all the valid solutions, all we have to do is to sort the valid times by the default compare of String object, and then take the last one.\\n\\n\"\"\"\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        List<String> validTimes = dfs(arr);\\n        if(validTimes.size()==0) return \"\";\\n        Collections.sort(validTimes);\\n        String latestValidTime = validTimes.get(validTimes.size()-1);\\n        return latestValidTime.substring(0,2) + \":\" + latestValidTime.substring(2,4);\\n    }\\n    \\n    private List<String> dfs(int[] arr){\\n        List<String> validTimes = new ArrayList();\\n        Set<Integer> visitedIndexes = new HashSet();\\n        dfsHelper(validTimes, arr, \"\", visitedIndexes);\\n        return validTimes;\\n    }\\n    \\n    private void dfsHelper(List<String> validTimes, int[] arr, String builder, Set<Integer> visitedIndexes){\\n        if(visitedIndexes.size() ==4){\\n            validTimes.add(builder);\\n            return;\\n        }\\n        for(int i=0; i<4; i++){\\n            if(builder.length()==0 && arr[i] > 2) continue; //first digit is greater than 2\\n            if(builder.equals(\"2\") && arr[i] > 3) continue; //first 2 digits are greater than 24\\n            if(builder.length()==2 && arr[i] > 5) continue; // 3rd digit is greater than 5\\n            if(visitedIndexes.contains(i)) continue;\\n            visitedIndexes.add(i);\\n            dfsHelper(validTimes, arr, builder + String.valueOf(arr[i]), visitedIndexes);\\n            visitedIndexes.remove(i);\\n        }\\n    }\\n\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 845666,
                "title": "easy-and-understandable-c-solution",
                "content": "```\\nvoid permutate(vector<int> &arr, int i, int n, vector<vector<int> > &valid){\\n    if(i>=n){\\n\\t\\t// checking if this permutation is valid or not. if it is a valid time we push it to the valid array.\\n        if( (arr[0]<2 and arr[2]<6) or (arr[0]==2 and arr[1]<4 and arr[2]<6) ){\\n            valid.push_back(arr);\\n        }\\n    } else{\\n        for(int j=i; j<n; j++){\\n            swap(arr[i], arr[j]);\\n            permutate(arr, i+1, n, valid);\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        vector<vector<int> > valid;\\n        permutate(arr, 0, 4, valid);\\n        \\n\\t\\t// if no valid permuations are found , return empty string.\\n        if(valid.size()==0) return \"\";\\n        \\n\\t\\t// Find the greatest time, convert it into string and return it.\\n        vector<int> ans = *max_element(valid.begin(), valid.end());\\n        string str = to_string(ans[0])+to_string(ans[1])+\":\"+to_string(ans[2])+to_string(ans[3]);\\n        return str;\\n    }\\n};\\n\\n```\\n\\nIf u like the solution then please upvote!",
                "solutionTags": [],
                "code": "```\\nvoid permutate(vector<int> &arr, int i, int n, vector<vector<int> > &valid){\\n    if(i>=n){\\n\\t\\t// checking if this permutation is valid or not. if it is a valid time we push it to the valid array.\\n        if( (arr[0]<2 and arr[2]<6) or (arr[0]==2 and arr[1]<4 and arr[2]<6) ){\\n            valid.push_back(arr);\\n        }\\n    } else{\\n        for(int j=i; j<n; j++){\\n            swap(arr[i], arr[j]);\\n            permutate(arr, i+1, n, valid);\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        vector<vector<int> > valid;\\n        permutate(arr, 0, 4, valid);\\n        \\n\\t\\t// if no valid permuations are found , return empty string.\\n        if(valid.size()==0) return \"\";\\n        \\n\\t\\t// Find the greatest time, convert it into string and return it.\\n        vector<int> ans = *max_element(valid.begin(), valid.end());\\n        string str = to_string(ans[0])+to_string(ans[1])+\":\"+to_string(ans[2])+to_string(ans[3]);\\n        return str;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827631,
                "title": "c-cpp-beats-100-of-solution-0-ms-simple-brute-force",
                "content": "Simple Brute force solution beats 100% of submissions. \\nThink of some corner cases, what digits can be possible on first and second place. \\nWe need maximum time, so start from max digits. \\n\\nPlease find the solution below . If this is useful to you , please help to upvote.\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string str;\\n        vector<int> count(10,0);\\n        for(int i=0;i<A.size();i++)\\n            count[A[i]]++;\\n        int i;\\n        \\n        for(i=2;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        if(str.length()==0)\\n            return str;\\n        if(str[0]==\\'2\\'){\\n            for(i=3;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            if(str.length()==1){\\n                if(count[1]>0){\\n                    str.pop_back();\\n                    str.push_back(\\'1\\');\\n                    count[2]++;\\n                    count[1]--;\\n                }   \\n                else if(count[0]>0){\\n                    str.pop_back();\\n                    str.push_back(\\'0\\');\\n                    count[2]++;\\n                    count[0]--;\\n                }\\n                else\\n                    return \"\";\\n            }\\n        }\\n        if(str[0]!=\\'2\\'){\\n            for(i=9;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n        }\\n        str+=\":\";\\n        \\n        for(i=5;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        if(str.length()==3){\\n            count[str[1]-\\'0\\']++;\\n            count[str[0]-\\'0\\']++;\\n            str=\"\";\\n            if(count[1]>0){\\n                str.push_back(\\'1\\');\\n                count[1]--;\\n            }   \\n            else if(count[0]>0){\\n                str.push_back(\\'0\\');\\n                count[0]--;\\n            }\\n            else\\n                return str;\\n            for(i=9;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            str+=\":\";\\n            for(i=5;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            if(str.length()==3)\\n                return \"\";\\n        }\\n            \\n        for(i=9;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string str;\\n        vector<int> count(10,0);\\n        for(int i=0;i<A.size();i++)\\n            count[A[i]]++;\\n        int i;\\n        \\n        for(i=2;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        if(str.length()==0)\\n            return str;\\n        if(str[0]==\\'2\\'){\\n            for(i=3;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            if(str.length()==1){\\n                if(count[1]>0){\\n                    str.pop_back();\\n                    str.push_back(\\'1\\');\\n                    count[2]++;\\n                    count[1]--;\\n                }   \\n                else if(count[0]>0){\\n                    str.pop_back();\\n                    str.push_back(\\'0\\');\\n                    count[2]++;\\n                    count[0]--;\\n                }\\n                else\\n                    return \"\";\\n            }\\n        }\\n        if(str[0]!=\\'2\\'){\\n            for(i=9;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n        }\\n        str+=\":\";\\n        \\n        for(i=5;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        if(str.length()==3){\\n            count[str[1]-\\'0\\']++;\\n            count[str[0]-\\'0\\']++;\\n            str=\"\";\\n            if(count[1]>0){\\n                str.push_back(\\'1\\');\\n                count[1]--;\\n            }   \\n            else if(count[0]>0){\\n                str.push_back(\\'0\\');\\n                count[0]--;\\n            }\\n            else\\n                return str;\\n            for(i=9;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            str+=\":\";\\n            for(i=5;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            if(str.length()==3)\\n                return \"\";\\n        }\\n            \\n        for(i=9;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827133,
                "title": "fixed-my-code-fails-test-on-submit-but-passes-same-test-on-run-code-what-gives",
                "content": "Anyone experience this weirdness on this or another problem.\\n\\nMy code fails a test on `Submit`, but passes that same test on `Run Code`.\\n\\nThe test is test `52` if tests are 1-indexed (I get `51/172 / 172 test cases passed.` and then this test fails). The test input is `[0,0,1,0]`, expected result `\"10:00\"`.\\n\\nWhen my code is run against this test on `Submit`, the result is incorrectly `\"00:00\"`; however, when my code is run against this test on `Run Code` using `Custom Testcase`, the result is correct (`\"10:00\"`). Was wondering if anyone has experienced this kind of discrepancy before and what might be the causes for same deterministic code running on the same input to produce different results depending on where it\\'s running. Seems odd.\\n\\nHere\\'s my code:\\n\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, nums: List[int]) -> str:\\n        res = self.findA(nums, 2, [3,5,9]) or self.findWA(nums, [1,9,5,9])\\n        return self.toTimeStr(res) if res else \"\"\\n    \\n    def findA(self, nums, a, conds, pre=[]):\\n        # nums = nums.copy()\\n        # pre = pre.copy()\\n        if a not in nums:\\n            return None\\n            \\n        nums.remove(a)\\n        pre.append(a)\\n        \\n        if not conds:\\n            return pre\\n        \\n        for b in range(conds[0], -1, -1):\\n            res = self.findA(nums, b, conds[1:], pre)\\n            if res:\\n                return res\\n        nums.append(a)\\n        pre.remove(a)\\n        return None\\n    \\n    def findWA(self, nums, conds, pre=[]):\\n        if not conds:\\n            return pre\\n        \\n        for b in range(conds[0], -1, -1):\\n            res = self.findA(nums, b, conds[1:], pre)\\n            if res:\\n                return res\\n        return None\\n    \\n    def toTimeStr(self, nums):\\n        hour = nums[0]*10 + nums[1]\\n        minute = nums[2]*10 + nums[3]\\n        return f\"{hour:02d}:{minute:02d}\"\\n        # return \"%d%d:%d%d\" % tuple(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, nums: List[int]) -> str:\\n        res = self.findA(nums, 2, [3,5,9]) or self.findWA(nums, [1,9,5,9])\\n        return self.toTimeStr(res) if res else \"\"\\n    \\n    def findA(self, nums, a, conds, pre=[]):\\n        # nums = nums.copy()\\n        # pre = pre.copy()\\n        if a not in nums:\\n            return None\\n            \\n        nums.remove(a)\\n        pre.append(a)\\n        \\n        if not conds:\\n            return pre\\n        \\n        for b in range(conds[0], -1, -1):\\n            res = self.findA(nums, b, conds[1:], pre)\\n            if res:\\n                return res\\n        nums.append(a)\\n        pre.remove(a)\\n        return None\\n    \\n    def findWA(self, nums, conds, pre=[]):\\n        if not conds:\\n            return pre\\n        \\n        for b in range(conds[0], -1, -1):\\n            res = self.findA(nums, b, conds[1:], pre)\\n            if res:\\n                return res\\n        return None\\n    \\n    def toTimeStr(self, nums):\\n        hour = nums[0]*10 + nums[1]\\n        minute = nums[2]*10 + nums[3]\\n        return f\"{hour:02d}:{minute:02d}\"\\n        # return \"%d%d:%d%d\" % tuple(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825315,
                "title": "clean-and-production-quality-python3",
                "content": "Create valid permuations \\nwe can use `itertools` but if the interviewer says not to use it. it might take longer. The advantage in creating your own is that you wont make invalid permutations. \\n\\nMake a Dateobj so you can compare it cleanly. \\n\\n```\\n# standard permutation algorithm with dups\\ndef getValidPermutations(nums):\\n    output = []\\n    used = [False] * len(nums)\\n    def permute(curr, nums, used, output):\\n        if len(curr) > 0 and curr[0] > 2:\\n            return\\n        if len(curr) > 2 and curr[0] == 2 and curr[1] > 3:\\n            return\\n        if len(curr) > 3 and curr[2] > 5:\\n            return\\n        if len(curr) == len(nums):\\n            output.append(list(curr))\\n            return\\n        i = 0\\n        while i < len(nums):\\n            if used[i]:\\n                i += 1\\n                continue\\n            curr.append(nums[i])\\n            used[i] = True\\n            permute(curr, nums, used, output)\\n            used[i] = False\\n            curr.pop()\\n            \\n            while i < len(nums) - 1 and nums[i] == nums[i+1]:\\n                i+= 1            \\n            i += 1\\n            \\n    curr = []\\n    permute(curr, nums, used, output)\\n    return output    \\n\\n# Date object that takes in the hour and minute\\nclass DateObj:\\n    \\n    def __init__(self, hour = 0, minute = 0):\\n        self.hour = hour\\n        self.minute = minute\\n\\n    def __eq__(self, other):\\n        return self.hour == other.hour and self.minute == other.minute\\n    \\n    def __gt__(self, other):\\n        if self.hour > other.hour:\\n            return True\\n        if self.hour == other.hour and self.minute > other.minute:\\n            return True\\n        return False\\n    \\n    def convert(self, num):\\n        output = \"\"\\n        if num == 0:\\n            output = \"00\"\\n        elif 0 < num < 10:\\n            output = \"0\" + str(num % 10)\\n        else:\\n            output = str(num)\\n        return output\\n    \\n    def format(self):\\n        output = \"\"\\n        output += self.convert(self.hour)\\n        output += \":\" + self.convert(self.minute)\\n        return output\\n \\n# the actual solution\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        A = sorted(A)\\n        valid_times = getValidPermutations(A)\\n        if not valid_times:\\n            return \"\"\\n        max_time = DateObj()\\n        for times in valid_times:\\n            hour = times[0] * 10 + times[1]\\n            minute = times[2] * 10 + times[3]\\n            \\n            time = DateObj(hour, minute)\\n            max_time = max(max_time, time)\\n        \\n        return max_time.format()\\n```",
                "solutionTags": [],
                "code": "```\\n# standard permutation algorithm with dups\\ndef getValidPermutations(nums):\\n    output = []\\n    used = [False] * len(nums)\\n    def permute(curr, nums, used, output):\\n        if len(curr) > 0 and curr[0] > 2:\\n            return\\n        if len(curr) > 2 and curr[0] == 2 and curr[1] > 3:\\n            return\\n        if len(curr) > 3 and curr[2] > 5:\\n            return\\n        if len(curr) == len(nums):\\n            output.append(list(curr))\\n            return\\n        i = 0\\n        while i < len(nums):\\n            if used[i]:\\n                i += 1\\n                continue\\n            curr.append(nums[i])\\n            used[i] = True\\n            permute(curr, nums, used, output)\\n            used[i] = False\\n            curr.pop()\\n            \\n            while i < len(nums) - 1 and nums[i] == nums[i+1]:\\n                i+= 1            \\n            i += 1\\n            \\n    curr = []\\n    permute(curr, nums, used, output)\\n    return output    \\n\\n# Date object that takes in the hour and minute\\nclass DateObj:\\n    \\n    def __init__(self, hour = 0, minute = 0):\\n        self.hour = hour\\n        self.minute = minute\\n\\n    def __eq__(self, other):\\n        return self.hour == other.hour and self.minute == other.minute\\n    \\n    def __gt__(self, other):\\n        if self.hour > other.hour:\\n            return True\\n        if self.hour == other.hour and self.minute > other.minute:\\n            return True\\n        return False\\n    \\n    def convert(self, num):\\n        output = \"\"\\n        if num == 0:\\n            output = \"00\"\\n        elif 0 < num < 10:\\n            output = \"0\" + str(num % 10)\\n        else:\\n            output = str(num)\\n        return output\\n    \\n    def format(self):\\n        output = \"\"\\n        output += self.convert(self.hour)\\n        output += \":\" + self.convert(self.minute)\\n        return output\\n \\n# the actual solution\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        A = sorted(A)\\n        valid_times = getValidPermutations(A)\\n        if not valid_times:\\n            return \"\"\\n        max_time = DateObj()\\n        for times in valid_times:\\n            hour = times[0] * 10 + times[1]\\n            minute = times[2] * 10 + times[3]\\n            \\n            time = DateObj(hour, minute)\\n            max_time = max(max_time, time)\\n        \\n        return max_time.format()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824499,
                "title": "simple-brute-force-in-constant-time-most-easy-solution-try-max-to-min",
                "content": "Too much **frustate** from edge cases after that Tried Indirect Idea\\n\\n**Now try from Max time to Min time, Brute Force\\n23:59 to 00:00** \\n\\nIf we able to find then return it else empty string\\n\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        map<int,int> mp1,mp2;\\n        for(auto x:A) mp1[x]++;   //store digits in map\\n        mp2=mp1;  //2nd map to retrive count\\n        int hr=23,m=59;  //start from here to 00:00\\n        while(hr>=0)\\n        {\\n            \\n            /*\\n            Lets time 23:58\\n            h0->2 , h1->3\\n            m0->5 , m1->8\\n            \\n            */\\n            int h0=hr/10,h1=hr%10; \\n            int m0=m/10,m1=m%10;\\n            int p=0;  //check for validation\\n            \\n            if(mp1[h0]>0) mp1[h0]--; else p=1;\\n            if(mp1[h1]>0) mp1[h1]--; else p=1;\\n            if(mp1[m0]>0) mp1[m0]--; else p=1;\\n            if(mp1[m1]>0) mp1[m1]--; else p=1;\\n            \\n            if(p==0) //if we found our combination in map then rturn its string format \\n            {\\n                string s=\"\";\\n                s=to_string(h0)+to_string(h1)+\\':\\'+to_string(m0)+to_string(m1);\\n                return s;\\n            }\\n            mp1=mp2;  //retrive original count\\n            //Please note 10:60 is not valid , it\\'s actually 11:00\\n            if(m==0)  //if minute ->0 , menas we have to decrease hr by 1 and set min to 59\\n            {\\n                hr-=1;m=59;\\n            }\\n            else\\n            {\\n                m--;  //drecease till zero\\n            }\\n            \\n        }\\n        return \"\"; //oh...no time found , invalid input\\n    }\\n};\\n```\\n\\n***Time Complexity : O(24 * 60) ~ O(1)\\nSpace complexity: O(1)***\\n\\n**Feel free to comment if any improvement needed**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        map<int,int> mp1,mp2;\\n        for(auto x:A) mp1[x]++;   //store digits in map\\n        mp2=mp1;  //2nd map to retrive count\\n        int hr=23,m=59;  //start from here to 00:00\\n        while(hr>=0)\\n        {\\n            \\n            /*\\n            Lets time 23:58\\n            h0->2 , h1->3\\n            m0->5 , m1->8\\n            \\n            */\\n            int h0=hr/10,h1=hr%10; \\n            int m0=m/10,m1=m%10;\\n            int p=0;  //check for validation\\n            \\n            if(mp1[h0]>0) mp1[h0]--; else p=1;\\n            if(mp1[h1]>0) mp1[h1]--; else p=1;\\n            if(mp1[m0]>0) mp1[m0]--; else p=1;\\n            if(mp1[m1]>0) mp1[m1]--; else p=1;\\n            \\n            if(p==0) //if we found our combination in map then rturn its string format \\n            {\\n                string s=\"\";\\n                s=to_string(h0)+to_string(h1)+\\':\\'+to_string(m0)+to_string(m1);\\n                return s;\\n            }\\n            mp1=mp2;  //retrive original count\\n            //Please note 10:60 is not valid , it\\'s actually 11:00\\n            if(m==0)  //if minute ->0 , menas we have to decrease hr by 1 and set min to 59\\n            {\\n                hr-=1;m=59;\\n            }\\n            else\\n            {\\n                m--;  //drecease till zero\\n            }\\n            \\n        }\\n        return \"\"; //oh...no time found , invalid input\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824368,
                "title": "greedy-dfs-c-0ms-best100",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans=\"\";\\n    bool gdfs(string a,vector<int> &A){\\n        int sz=a.size(),es[]={2,3,0,5,9},end;         // es[] acts to provide upper inclusive limit for value in particular pos\\n        if(sz==2)return gdfs(a+\\':\\',A);                // add \\':\\' in between\\n        if(sz==5){ans=a;return true;}                 // choose the first best ans, return true to stop all recusions\\n        if(a[0]<\\'2\\')es[1]=9;                          // another important ;P condition.\\n        end=es[sz];\\n        for(int i=end;i>-1;i--)                      // iterate in a greedy fashion\\n            for(auto &j:A){     \\n                if(i==j){                                       \\n                    j=-1;                                       \\n                    if(gdfs(a+char(\\'0\\'+i),A))return true;\\n                    j=i;\\n                }\\n            }\\n        return false;\\n    }\\n    string largestTimeFromDigits(vector<int>& A) {\\n        gdfs(\"\",A);\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string ans=\"\";\\n    bool gdfs(string a,vector<int> &A){\\n        int sz=a.size(),es[]={2,3,0,5,9}",
                "codeTag": "Java"
            },
            {
                "id": 824312,
                "title": "c-92-time-solution-backtracking-o-1",
                "content": "#### The idea is constrained backtracking\\nWe have the following rules:\\nHH -> have to be less than 24\\nMM -> Have to be less than 60\\n\\nCreate all possible permutations, and then save the largest one that is valid.\\nWe need to sort first to simply create ascending permutaions, but because the array is length of 4, the sort is also O(1).\\n\\n\\n#### Time complexity breakthrough:\\nSince we have only 4 items in A, we will create 4! permutations.\\nThis results in O(1)\\n\\nIf we had N length array, the complexity would be O(N!)\\n\\n#### Space complexity:\\nSame as time here.\\nDeepest recursion stack is 4.\\n\\n\\n```\\npublic class Solution {\\n    public string LargestTimeFromDigits(int[] A)\\n    {\\n        Array.Sort(A);\\n        int[] res = new int[4];\\n        int[] final_res = new int[4];\\n        bool hasFinished = false;\\n\\n        void GeneratePermutations(int i)\\n        {\\n            if (i == 4)\\n            {\\n                res.CopyTo(final_res, 0);\\n                hasFinished = true;\\n                return;\\n            }\\n\\n\\n            foreach (var (num, index) in A.Select((num, index) => (num, index)))\\n            {\\n                if (num == -1)\\n                    continue;\\n\\n                if (i == 1)\\n                {\\n                    if (res[0] * 10 + num < 24)\\n                    {\\n                        // Permute\\n                        A[index] = -1;\\n                        res[i] = num;\\n\\n                        GeneratePermutations(i + 1);\\n\\n                        // Backtrack\\n                        res[i] = -1;\\n                        A[index] = num;\\n                    }\\n                }\\n                else if (i == 3)\\n                {\\n                    if(res[2] * 10 + num < 60)\\n                    {\\n                        // permute\\n                        A[index] = -1;\\n                        res[i] = num;\\n\\n                        GeneratePermutations(i + 1);\\n\\n                        // backtrack\\n                        res[i] = -1;\\n                        A[index] = num;\\n                    }\\n                }\\n                else\\n                {\\n                    // permute\\n                    A[index] = -1;\\n                    res[i] = num;\\n\\n                    GeneratePermutations(i + 1);\\n\\n                    // backtrack\\n                    res[i] = -1;\\n                    A[index] = num;\\n                }\\n\\n            }\\n        }\\n\\n        GeneratePermutations(0);\\n\\n        if (!hasFinished)\\n        {\\n            return \"\";\\n        }\\n\\n        return string.Format(\"{0}{1}:{2}{3}\", final_res[0], final_res[1], final_res[2], final_res[3]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string LargestTimeFromDigits(int[] A)\\n    {\\n        Array.Sort(A);\\n        int[] res = new int[4];\\n        int[] final_res = new int[4];\\n        bool hasFinished = false;\\n\\n        void GeneratePermutations(int i)\\n        {\\n            if (i == 4)\\n            {\\n                res.CopyTo(final_res, 0);\\n                hasFinished = true;\\n                return;\\n            }\\n\\n\\n            foreach (var (num, index) in A.Select((num, index) => (num, index)))\\n            {\\n                if (num == -1)\\n                    continue;\\n\\n                if (i == 1)\\n                {\\n                    if (res[0] * 10 + num < 24)\\n                    {\\n                        // Permute\\n                        A[index] = -1;\\n                        res[i] = num;\\n\\n                        GeneratePermutations(i + 1);\\n\\n                        // Backtrack\\n                        res[i] = -1;\\n                        A[index] = num;\\n                    }\\n                }\\n                else if (i == 3)\\n                {\\n                    if(res[2] * 10 + num < 60)\\n                    {\\n                        // permute\\n                        A[index] = -1;\\n                        res[i] = num;\\n\\n                        GeneratePermutations(i + 1);\\n\\n                        // backtrack\\n                        res[i] = -1;\\n                        A[index] = num;\\n                    }\\n                }\\n                else\\n                {\\n                    // permute\\n                    A[index] = -1;\\n                    res[i] = num;\\n\\n                    GeneratePermutations(i + 1);\\n\\n                    // backtrack\\n                    res[i] = -1;\\n                    A[index] = num;\\n                }\\n\\n            }\\n        }\\n\\n        GeneratePermutations(0);\\n\\n        if (!hasFinished)\\n        {\\n            return \"\";\\n        }\\n\\n        return string.Format(\"{0}{1}:{2}{3}\", final_res[0], final_res[1], final_res[2], final_res[3]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824240,
                "title": "largest-time-for-given-digits-c-using-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        \\n        pair<int, int> ans{-1, -1};\\n        \\n        do\\n        {\\n            int hours, minutes;\\n            \\n            hours = A[0]*10 + A[1];\\n            minutes = A[2]*10 + A[3];\\n            if(hours < 24 && minutes < 60)\\n                ans = max(ans, make_pair(hours, minutes));\\n        } while(next_permutation(A.begin(), A.end()));\\n        \\n        if(ans == make_pair(-1, -1))\\n            return \"\";\\n        \\n        string hours, minutes;\\n        // if(hour is less than 10)\\n        if(ans.first/10 == 0)\\n            hours += \\'0\\';\\n        hours += to_string(ans.first);\\n                // if(min is less than 10)\\n        if(ans.second/10 == 0)\\n            minutes += \\'0\\';\\n        minutes += to_string(ans.second);\\n        return hours + \\':\\' + minutes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        \\n        pair<int, int> ans{-1, -1};\\n        \\n        do\\n        {\\n            int hours, minutes;\\n            \\n            hours = A[0]*10 + A[1];\\n            minutes = A[2]*10 + A[3];\\n            if(hours < 24 && minutes < 60)\\n                ans = max(ans, make_pair(hours, minutes));\\n        } while(next_permutation(A.begin(), A.end()));\\n        \\n        if(ans == make_pair(-1, -1))\\n            return \"\";\\n        \\n        string hours, minutes;\\n        // if(hour is less than 10)\\n        if(ans.first/10 == 0)\\n            hours += \\'0\\';\\n        hours += to_string(ans.first);\\n                // if(min is less than 10)\\n        if(ans.second/10 == 0)\\n            minutes += \\'0\\';\\n        minutes += to_string(ans.second);\\n        return hours + \\':\\' + minutes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824204,
                "title": "java-count-digits-and-find-max-based-on-condition-simple-to-understand-21ms-40mb",
                "content": "\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int[] nums = new int[10];\\n        int hasLessThan5 = 0;\\n        for(int a : A){\\n            nums[a]++;\\n            if(a < 6){\\n                hasLessThan5++;\\n            }\\n        }\\n        \\n        if(hasLessThan5 < 2){\\n            // will not fall under [0-2]X:[0-5]X\\n            return \"\";\\n        }\\n        \\n        String time = \"\";\\n        if(nums[2] > 0){\\n            nums[2]--;\\n            // reduce count of 2 and find max of 0-3\\n            int number = getMaxNumber(3, nums) ;\\n            if(number > -1){\\n                time = \"2\" + number + \":\";\\n//                System.out.println(time);\\n                int mins = getMaxNumber(5, nums) ;\\n                if(mins > -1){\\n//                    System.out.println(mins);\\n                    int munit = getMaxNumber(9, nums) ;\\n                    if(munit > -1){\\n//                        System.out.println(munit + \"munit hr\");\\n                        return time + mins + munit;\\n                    }\\n                    nums[mins]++;\\n                    // reset minute number\\n                }\\n                \\n                nums[number]++;\\n//                System.out.println(\"reset h \" + number + \" m \" + mins);\\n                time = \"\";\\n                // reset hour number\\n            }\\n            \\n            nums[2]++;\\n            // not valid hour with 2X or combination . Reset count of 2\\n        }\\n        \\n        if(nums[1] > 0 || nums[0] > 0){\\n            int hour = getMaxNumber(1, nums) ;\\n//            System.out.println(hour);\\n            if(hour > -1){\\n                int hunit = getMaxNumber(9, nums) ;\\n//                System.out.println(hunit);\\n                if(hunit > -1){\\n                    time = hour +\"\" + hunit + \":\";\\n                    System.out.println(time);\\n                    int mins = getMaxNumber(5, nums) ;\\n//                    System.out.println(mins);\\n                    if(mins > -1){\\n                        int munit = getMaxNumber(9, nums) ;\\n//                        System.out.println(munit + \"munit\");\\n                        if(munit > -1){\\n                            return time + mins + munit;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n    \\n    public int getMaxNumber(int upperLimit, int[] nums){\\n        for(int i = upperLimit; i >= 0; i--){\\n            if(nums[i] > 0){\\n                nums[i]--; // kept here since common for all\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int[] nums = new int[10];\\n        int hasLessThan5 = 0;\\n        for(int a : A){\\n            nums[a]++;\\n            if(a < 6){\\n                hasLessThan5++;\\n            }\\n        }\\n        \\n        if(hasLessThan5 < 2){\\n            // will not fall under [0-2]X:[0-5]X\\n            return \"\";\\n        }\\n        \\n        String time = \"\";\\n        if(nums[2] > 0){\\n            nums[2]--;\\n            // reduce count of 2 and find max of 0-3\\n            int number = getMaxNumber(3, nums) ;\\n            if(number > -1){\\n                time = \"2\" + number + \":\";\\n//                System.out.println(time);\\n                int mins = getMaxNumber(5, nums) ;\\n                if(mins > -1){\\n//                    System.out.println(mins);\\n                    int munit = getMaxNumber(9, nums) ;\\n                    if(munit > -1){\\n//                        System.out.println(munit + \"munit hr\");\\n                        return time + mins + munit;\\n                    }\\n                    nums[mins]++;\\n                    // reset minute number\\n                }\\n                \\n                nums[number]++;\\n//                System.out.println(\"reset h \" + number + \" m \" + mins);\\n                time = \"\";\\n                // reset hour number\\n            }\\n            \\n            nums[2]++;\\n            // not valid hour with 2X or combination . Reset count of 2\\n        }\\n        \\n        if(nums[1] > 0 || nums[0] > 0){\\n            int hour = getMaxNumber(1, nums) ;\\n//            System.out.println(hour);\\n            if(hour > -1){\\n                int hunit = getMaxNumber(9, nums) ;\\n//                System.out.println(hunit);\\n                if(hunit > -1){\\n                    time = hour +\"\" + hunit + \":\";\\n                    System.out.println(time);\\n                    int mins = getMaxNumber(5, nums) ;\\n//                    System.out.println(mins);\\n                    if(mins > -1){\\n                        int munit = getMaxNumber(9, nums) ;\\n//                        System.out.println(munit + \"munit\");\\n                        if(munit > -1){\\n                            return time + mins + munit;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n    \\n    public int getMaxNumber(int upperLimit, int[] nums){\\n        for(int i = upperLimit; i >= 0; i--){\\n            if(nums[i] > 0){\\n                nums[i]--; // kept here since common for all\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824133,
                "title": "python3-simple-python3-solution-5-lines",
                "content": "The size of the possible search space is `4!=24`; thus, a simple brute force solution will be enough.\\n\\nHere I used `permutation` for simplicity.\\n\\nThe time complexity of this question is `O(C)`.\\n\\n```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        ans = \"\"\\n        for p in permutations(A):\\n            if p[0] * 10 + p[1] <= 23 and p[2] <= 5:\\n                cand = \"{0}{1}:{2}{3}\".format(*p)\\n                ans = max(ans, cand)\\n        return ans\\n```\\n\\nThank you.",
                "solutionTags": [],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        ans = \"\"\\n        for p in permutations(A):\\n            if p[0] * 10 + p[1] <= 23 and p[2] <= 5:\\n                cand = \"{0}{1}:{2}{3}\".format(*p)\\n                ans = max(ans, cand)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824023,
                "title": "c-short-std-sort-std-prev-permutation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) const\\n    {\\n        sort(begin(A), end(A), greater());\\n\\n        do {\\n            if (A[0] * 10 + A[1] <= 23 && A[2] <= 5) {\\n                ostringstream oss;\\n                oss << A[0] << A[1] << \\':\\' << A[2] << A[3];\\n                return oss.str();\\n            }\\n        } while (prev_permutation(begin(A), end(A)));\\n\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) const\\n    {\\n        sort(begin(A), end(A), greater());\\n\\n        do {\\n            if (A[0] * 10 + A[1] <= 23 && A[2] <= 5) {\\n                ostringstream oss;\\n                oss << A[0] << A[1] << \\':\\' << A[2] << A[3];\\n                return oss.str();\\n            }\\n        } while (prev_permutation(begin(A), end(A)));\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823732,
                "title": "javascript-dfs-backtrack-explained-99-speed",
                "content": "Compute all permutations but do not store them all at once. A DFS backtrack generates permutations dynamically and when the base condition of all digits having been used is satisfied, the resulting time is checked for validity and for whether it surpasses the maximum observed. Return the maximum found through the DFS with appropriate formatting.\\n\\n```\\nconst largestTimeFromDigits = A => {\\n    \\n    const visited = new Array(4).fill(false);   //Tracking digits used in permutation construction by index in A\\n    let max = -1, ans = [];                     //Variables for tracking maximum observed time\\n    \\n    //Given some array of numbers time representing a permutation of A that is either fully constructed or in the process of being constructed\\n    const DFSBacktrack = (time = []) => {\\n        if (time.length === 4 && isValidTime(time)){  //If the time represented by the sequence is complete and valid\\n            const timeNum = parseInt(time.join(\\'\\'));  //Get the time in number format and compare to maximum observed\\n            if (max < timeNum){ \\n                max = timeNum;                        //If a new maximum was found, record it as a number and in result array\\n                ans = [...time];\\n            }\\n            return;\\n        }    \\n        \\n        for (let i = 0; i < A.length; i++){           //If array not full, continue building the current permutation via DFS backtrack\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            time.push(A[i]);\\n            DFSBacktrack(time);\\n            visited[i] = false;\\n            time.pop();\\n        }\\n        return;\\n    };\\n    \\n    //Checks if some array of numbers time of length >= 3 representing a permuation of A qualifies as a valid time\\n    const isValidTime = time => (time[0] === 2 && time[1] < 4 && time[2] <= 5) || (time[0] <= 1 && time[2] <= 5);\\n    \\n    //Run the DFS to get the maximum time, add the semicolon and return\\n    DFSBacktrack();\\n    if (!ans.length) return \"\";\\n    ans.splice(2,0,\":\");\\n    return ans.join(\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst largestTimeFromDigits = A => {\\n    \\n    const visited = new Array(4).fill(false);   //Tracking digits used in permutation construction by index in A\\n    let max = -1, ans = [];                     //Variables for tracking maximum observed time\\n    \\n    //Given some array of numbers time representing a permutation of A that is either fully constructed or in the process of being constructed\\n    const DFSBacktrack = (time = []) => {\\n        if (time.length === 4 && isValidTime(time)){  //If the time represented by the sequence is complete and valid\\n            const timeNum = parseInt(time.join(\\'\\'));  //Get the time in number format and compare to maximum observed\\n            if (max < timeNum){ \\n                max = timeNum;                        //If a new maximum was found, record it as a number and in result array\\n                ans = [...time];\\n            }\\n            return;\\n        }    \\n        \\n        for (let i = 0; i < A.length; i++){           //If array not full, continue building the current permutation via DFS backtrack\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            time.push(A[i]);\\n            DFSBacktrack(time);\\n            visited[i] = false;\\n            time.pop();\\n        }\\n        return;\\n    };\\n    \\n    //Checks if some array of numbers time of length >= 3 representing a permuation of A qualifies as a valid time\\n    const isValidTime = time => (time[0] === 2 && time[1] < 4 && time[2] <= 5) || (time[0] <= 1 && time[2] <= 5);\\n    \\n    //Run the DFS to get the maximum time, add the semicolon and return\\n    DFSBacktrack();\\n    if (!ans.length) return \"\";\\n    ans.splice(2,0,\":\");\\n    return ans.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823637,
                "title": "c-brute-force-with-linq-7-lines",
                "content": "```\\n    var digits=String.Concat(A.Select(x=>x+\"\").OrderBy(x=>x));\\n    var hora=DateTime.Parse(\"11:59 PM\"); \\n    while (hora >= DateTime.Parse(\"00:00 AM\")) \\n    {\\n        var newdig=String.Concat($\"{hora:HHmm}\".OrderBy(x=>x));\\n        if (newdig==digits) return $\"{hora:HH:mm}\"; \\n        hora=hora.AddMinutes(-1);\\n    }\\n    return \"\";\\n```",
                "solutionTags": [],
                "code": "```\\n    var digits=String.Concat(A.Select(x=>x+\"\").OrderBy(x=>x));\\n    var hora=DateTime.Parse(\"11:59 PM\"); \\n    while (hora >= DateTime.Parse(\"00:00 AM\")) \\n    {\\n        var newdig=String.Concat($\"{hora:HHmm}\".OrderBy(x=>x));\\n        if (newdig==digits) return $\"{hora:HH:mm}\"; \\n        hora=hora.AddMinutes(-1);\\n    }\\n    return \"\";\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823509,
                "title": "java-faster-than-90-simple-logic-map-based",
                "content": "```\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    public String largestTimeFromDigits(int[] A) {\\n       \\n        mapReset(A);\\n        StringBuilder time = new StringBuilder();\\n        // Finding largest time in hr\\n        String hour = hourMinute(23);\\n        // If hour is not possible, return empty string\\n        if(hour.isEmpty())\\n            return \"\";\\n        int hr = Integer.parseInt(hour);\\n        // Finding largest time in minute from remaining elements\\n        time.append(hour).append(\":\").append(hourMinute(59));\\n        // Case if hours are valid and minutes are not valid eg : [2,0,6,6] -> hr = 20 and min = 66, not valid, but hr = 06 and min = 26 is valid\\n        if(map.size()>0){\\n            mapReset(A);\\n            time = new StringBuilder();\\n            // Finding new hr lower than preivous one and minute from remaining elements again\\n            time.append(hourMinute(hr-1)).append(\":\").append(hourMinute(59));\\n        }\\n        // Valid time cannot be made\\n        if(map.size()>0)\\n            return \"\";\\n        return time.toString();\\n    }\\n    \\n    public void mapReset(int[] A){\\n        map = new HashMap<>();\\n        for(int a :A)\\n            map.put(a, map.getOrDefault(a,0)+1);\\n    }\\n    \\n    public String hourMinute(int start){\\n        StringBuilder time = new StringBuilder();\\n        for(int i=start;i>=0; i--){\\n            int r = i%10;\\n            int q = i/10;\\n            if(map.containsKey(r) && map.containsKey(q)){\\n                if(r==q && map.get(r)<2)\\n                    continue;\\n                map.put(r, map.get(r)-1);\\n                if(map.get(r)==0)\\n                    map.remove(r);\\n                map.put(q, map.get(q)-1);\\n                if(map.get(q)==0)\\n                    map.remove(q);\\n                time.append(q).append(r);\\n                break;\\n            }\\n        }\\n        return time.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    public String largestTimeFromDigits(int[] A) {\\n       \\n        mapReset(A);\\n        StringBuilder time = new StringBuilder();\\n        // Finding largest time in hr\\n        String hour = hourMinute(23);\\n        // If hour is not possible, return empty string\\n        if(hour.isEmpty())\\n            return \"\";\\n        int hr = Integer.parseInt(hour);\\n        // Finding largest time in minute from remaining elements\\n        time.append(hour).append(\":\").append(hourMinute(59));\\n        // Case if hours are valid and minutes are not valid eg : [2,0,6,6] -> hr = 20 and min = 66, not valid, but hr = 06 and min = 26 is valid\\n        if(map.size()>0){\\n            mapReset(A);\\n            time = new StringBuilder();\\n            // Finding new hr lower than preivous one and minute from remaining elements again\\n            time.append(hourMinute(hr-1)).append(\":\").append(hourMinute(59));\\n        }\\n        // Valid time cannot be made\\n        if(map.size()>0)\\n            return \"\";\\n        return time.toString();\\n    }\\n    \\n    public void mapReset(int[] A){\\n        map = new HashMap<>();\\n        for(int a :A)\\n            map.put(a, map.getOrDefault(a,0)+1);\\n    }\\n    \\n    public String hourMinute(int start){\\n        StringBuilder time = new StringBuilder();\\n        for(int i=start;i>=0; i--){\\n            int r = i%10;\\n            int q = i/10;\\n            if(map.containsKey(r) && map.containsKey(q)){\\n                if(r==q && map.get(r)<2)\\n                    continue;\\n                map.put(r, map.get(r)-1);\\n                if(map.get(r)==0)\\n                    map.remove(r);\\n                map.put(q, map.get(q)-1);\\n                if(map.get(q)==0)\\n                    map.remove(q);\\n                time.append(q).append(r);\\n                break;\\n            }\\n        }\\n        return time.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823457,
                "title": "c-4ms-permutation-clean-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans = \"\";\\n        sort(A.begin(),A.end());\\n        do{\\n            if((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5)\\n                ans = to_string(A[0])+to_string(A[1])+\":\"+to_string(A[2])+to_string(A[3]);\\n        }while(next_permutation(A.begin(),A.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans = \"\";\\n        sort(A.begin(),A.end());\\n        do{\\n            if((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5)\\n                ans = to_string(A[0])+to_string(A[1])+\":\"+to_string(A[2])+to_string(A[3]);\\n        }while(next_permutation(A.begin(),A.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823424,
                "title": "javascript-brute-force-short-but-slow",
                "content": "```\\nvar largestTimeFromDigits = function(A) {\\n    \\n    const cmp = A.sort().join(\"\");\\n    for(let i=23; i>=0; i--){\\n        for(let j=59; j>=0; j--){\\n            if(cmp==[Math.floor(i/10),i%10,Math.floor(j/10),j%10].sort().join(\"\"))\\n                return \\'\\'+Math.floor(i/10)+i%10+\\':\\'+Math.floor(j/10)+j%10;\\n        }\\n    }\\n   \\n    return \"\";\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestTimeFromDigits = function(A) {\\n    \\n    const cmp = A.sort().join(\"\");\\n    for(let i=23; i>=0; i--){\\n        for(let j=59; j>=0; j--){\\n            if(cmp==[Math.floor(i/10),i%10,Math.floor(j/10),j%10].sort().join(\"\"))\\n                return \\'\\'+Math.floor(i/10)+i%10+\\':\\'+Math.floor(j/10)+j%10;\\n        }\\n    }\\n   \\n    return \"\";\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823276,
                "title": "java-simple-for-loops",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        String ans = \"\";\\n        Arrays.sort(A);\\n        int max = -1;\\n        for(int i=0;i<4;i++)\\n        {\\n          for(int j=0;j<4;j++)\\n            {\\n                for(int k=0;k<4;k++)\\n                {\\n                 \\n                    for(int l=0;l<4;l++)\\n                    {\\n                        if(i!=j && i!=k &&i!=l && j!=k &&j!=l && k!=l)\\n                        {\\n                            String hr = A[i]+\"\"+A[j];\\n                            String min = A[k]+\"\"+A[l];\\n                            \\n                            if(Integer.parseInt(hr) < 24 && Integer.parseInt(min) < 60 && Integer.parseInt(hr+min+\"\") > max)\\n                            {\\n                                ans=hr+\":\"+min;\\n                                max = Integer.parseInt(hr+min);\\n                               \\n                            }\\n                                \\n                        }\\n                    }\\n                }\\n              \\n            }   \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        String ans = \"\";\\n        Arrays.sort(A);\\n        int max = -1;\\n        for(int i=0;i<4;i++)\\n        {\\n          for(int j=0;j<4;j++)\\n            {\\n                for(int k=0;k<4;k++)\\n                {\\n                 \\n                    for(int l=0;l<4;l++)\\n                    {\\n                        if(i!=j && i!=k &&i!=l && j!=k &&j!=l && k!=l)\\n                        {\\n                            String hr = A[i]+\"\"+A[j];\\n                            String min = A[k]+\"\"+A[l];\\n                            \\n                            if(Integer.parseInt(hr) < 24 && Integer.parseInt(min) < 60 && Integer.parseInt(hr+min+\"\") > max)\\n                            {\\n                                ans=hr+\":\"+min;\\n                                max = Integer.parseInt(hr+min);\\n                               \\n                            }\\n                                \\n                        }\\n                    }\\n                }\\n              \\n            }   \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823260,
                "title": "javascript-backtrack-with-comments",
                "content": "```\\n/*\\nhh:mm\\n^ 0,1,2 <-- \\n ^ 0-9, 2: 0-4\\n   ^ 0-5\\n    ^ 0-9 <- most flexible any digit can go here\\n    \\nif there\\'s a 2, put in first spot, dictates 0-4 in 2nd spot.  0-5 in 3rd spot.  if either 2nd or 3rd spot have nothing, 2 can\\'t go in 1st spot. then choose 1 in first spot and 0-5 in 3rd spot, biggest number in 2nd slot and\\nlooks like a backtracking pattern\\n\\nwith duplicates, use a bool visited array to recognize which element has been used\\n\\nA is only 4 elements, there are at most 4*3*2*1 permutations. brute force enumerate them all and check for largest one that fits conditions\\nwith an sb, we can .join and *1 to get a 4 digit number to compare to a max\\nwhen returning the string we can splice in \":\" and join\\n\\nO(1) time and space since permutations is always constant\\n*/\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n    let visited = new Array(4).fill(false)\\n    let max = -1\\n    let result = []\\n    backtrack([])\\n    return result.join(\\'\\')\\n    \\n    function backtrack(sb){\\n        if (sb.length === 4 && isValid(sb)){\\n            let time = sb.join(\\'\\')*1\\n            if (max < time){\\n                max = time\\n                result = sb.slice();\\n                result.splice(2,0,\":\")\\n            }\\n            return;\\n        }\\n        \\n        for (let i = 0; i < A.length; i++){\\n            if (visited[i]) continue\\n            visited[i] = true\\n            sb.push(A[i])\\n            backtrack(sb)\\n            visited[i] = false\\n            sb.pop()\\n        }\\n    }\\n    function isValid(sb){\\n        if (sb[0] === 2 && sb[1] < 4 && sb[2] <= 5) return true;\\n        if (sb[0] <= 1 && sb[2] <= 5) return true;\\n        return false\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nhh:mm\\n^ 0,1,2 <-- \\n ^ 0-9, 2: 0-4\\n   ^ 0-5\\n    ^ 0-9 <- most flexible any digit can go here\\n    \\nif there\\'s a 2, put in first spot, dictates 0-4 in 2nd spot.  0-5 in 3rd spot.  if either 2nd or 3rd spot have nothing, 2 can\\'t go in 1st spot. then choose 1 in first spot and 0-5 in 3rd spot, biggest number in 2nd slot and\\nlooks like a backtracking pattern\\n\\nwith duplicates, use a bool visited array to recognize which element has been used\\n\\nA is only 4 elements, there are at most 4*3*2*1 permutations. brute force enumerate them all and check for largest one that fits conditions\\nwith an sb, we can .join and *1 to get a 4 digit number to compare to a max\\nwhen returning the string we can splice in \":\" and join\\n\\nO(1) time and space since permutations is always constant\\n*/\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n    let visited = new Array(4).fill(false)\\n    let max = -1\\n    let result = []\\n    backtrack([])\\n    return result.join(\\'\\')\\n    \\n    function backtrack(sb){\\n        if (sb.length === 4 && isValid(sb)){\\n            let time = sb.join(\\'\\')*1\\n            if (max < time){\\n                max = time\\n                result = sb.slice();\\n                result.splice(2,0,\":\")\\n            }\\n            return;\\n        }\\n        \\n        for (let i = 0; i < A.length; i++){\\n            if (visited[i]) continue\\n            visited[i] = true\\n            sb.push(A[i])\\n            backtrack(sb)\\n            visited[i] = false\\n            sb.pop()\\n        }\\n    }\\n    function isValid(sb){\\n        if (sb[0] === 2 && sb[1] < 4 && sb[2] <= 5) return true;\\n        if (sb[0] <= 1 && sb[2] <= 5) return true;\\n        return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823242,
                "title": "c-find-permutations-and-only-check-and-compare",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        if(s[0] == \\'2\\' && s[1] >= \\'4\\')\\n            return false;\\n        if(s[0] > \\'2\\')\\n            return false;\\n        \\n        if(s[2] >= \\'6\\')\\n            return false;\\n        \\n    return true;\\n    }\\n    bool cmp(string s1 , string s2)\\n    {\\n        for(int i = 0;i<4;i++)\\n        {\\n            if(s1[i] > s2[i])\\n                return true;\\n            else if(s1[i] == s2[i]){}\\n            else if(s1[i] < s2[i])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    string largestTimeFromDigits(vector<int>& A) {\\n       \\n        string temp = \"\";\\n        for(int i : A)\\n            temp += to_string(i);\\n        \\n        sort(temp.begin() , temp.end());\\n        \\n        int a = stoi(temp);\\n        if(a == 0)\\n            return \"00:00\";\\n        \\n        int count = 0;\\n     \\n        \\n        \\n        // take the cases of zero\\n       \\n        string res = \"\";\\n        string val = \"0000\";\\n        \\n        cout<<temp<<\" \";\\n        do{\\n            string x = temp;\\n            if(check(x) && cmp(x,val))\\n            {\\n                cout<<x<<\" \";\\n                res = x;\\n                val = x;\\n            }\\n        }while(next_permutation(temp.begin() , temp.end()));\\n        \\n        if(res.length() == 0)\\n            return \"\";\\n        string ans = res.substr(0,2) + \\':\\' + res.substr(2,2);\\n        \\n        return ans;\\n       \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        if(s[0] == \\'2\\' && s[1] >= \\'4\\')\\n            return false;\\n        if(s[0] > \\'2\\')\\n            return false;\\n        \\n        if(s[2] >= \\'6\\')\\n            return false;\\n        \\n    return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 823171,
                "title": "c-regex-pattern-matching-with-backtracking",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string res=\"\";\\n    void check(map<int,int>mp,string str,regex &pattern)\\n    {\\n        if(str.length()==2)\\n            str+=\":\";\\n        \\n        if(str.length()==5)\\n        {\\n            if(regex_match(str,pattern))\\n                res=max(res,str); //valid time\\n            \\n            return;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second!=0)\\n            {\\n                int val=it->first;\\n                mp[val]--;\\n                check(mp,str+to_string(val),pattern);\\n                mp[val]++;\\n            }\\n        }\\n    }\\n    string largestTimeFromDigits(vector<int>& A) {\\n        regex pattern(\"([0-1][0-9]:[0-5][0-9])|([2][0-3]:[0-5][0-9])\");\\n        map<int,int>mp;\\n        for(int i=0;i<A.size();i++)\\n            mp[A[i]]++;\\n\\t\\t\\t\\n        string str=\"\";\\n        check(mp,str,pattern);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string res=\"\";\\n    void check(map<int,int>mp,string str,regex &pattern)\\n    {\\n        if(str.length()==2)\\n            str+=\":\";\\n        \\n        if(str.length()==5)\\n        {\\n            if(regex_match(str,pattern))\\n                res=max(res,str); //valid time\\n            \\n            return;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second!=0)\\n            {\\n                int val=it->first;\\n                mp[val]--;\\n                check(mp,str+to_string(val),pattern);\\n                mp[val]++;\\n            }\\n        }\\n    }\\n    string largestTimeFromDigits(vector<int>& A) {\\n        regex pattern(\"([0-1][0-9]:[0-5][0-9])|([2][0-3]:[0-5][0-9])\");\\n        map<int,int>mp;\\n        for(int i=0;i<A.size();i++)\\n            mp[A[i]]++;\\n\\t\\t\\t\\n        string str=\"\";\\n        check(mp,str,pattern);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823166,
                "title": "java-easy-to-understand-solution-1ms-faster",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        Map<Integer, Integer> timeMap = new HashMap<Integer, Integer>();\\n\\t\\tStringBuilder timeFormat = new StringBuilder();\\n\\t\\tboolean flag = false;\\n\\t\\tint len = A.length;\\n\\t\\tif (len > 4)\\n\\t\\t\\treturn \"\";\\n\\t\\tfor (int i : A)\\n\\t\\t\\ttimeMap.put(i, timeMap.getOrDefault(i, 0) + 1);\\n\\t\\tint s = 0, res = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (A[i] > 5)\\n\\t\\t\\t\\tres++; // Count the Number of entries which are greater than 5.\\n\\t\\t}\\n\\t\\t// If I have more than 2 entries which are greater than 5 I cannot form a max\\n\\t\\t// time starting with 2 else I can start a max time with 2.\\n\\t\\t// Hence \\'s\\' is either 1 or 2.\\n\\t\\ts = (res >= 2) ? 1 : 2;\\n\\t\\tfor (int i = s; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the first digit of the Hour with \\'s\\'\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\"; // Reset the flag if the condition failed\\n\\t\\tflag = false;\\n\\t\\t// If the first digit of the hour starts with 2, then I\\'m allowed only till 3\\n\\t\\t// for my second digit. Hence starting with 3.\\n\\t\\tif (timeFormat.charAt(0) == \\'2\\') {\\n\\t\\t\\tfor (int i = 3; i >= 0; i--) {\\n\\t\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\ttimeFormat.append(i); // Append the second digit of the Hour\\n\\t\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else { // If the first digit of the hour starts with 1 or 0, then I\\'m allowed only till\\n\\t\\t\\t\\t\\t// 9 for my second digit. Hence starting with 9.\\n\\t\\t\\tfor (int i = 9; i >= 0; i--) {\\n\\t\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\ttimeFormat.append(i);\\n\\t\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\ttimeFormat.append(\":\"); // Append the colon to separate Hours and Minutes\\n\\t\\tflag = false;\\n\\t\\t// The max number allowed to start my first digit of the minute is 5. Hence,\\n\\t\\t// starting with 5.\\n\\t\\tfor (int i = 5; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the first digit of the Minutes\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\tflag = false;\\n\\t\\t// The max number allowed to start my second digit of the minute is 9.\\n\\t\\t// Hence, starting with 9.\\n\\t\\tfor (int i = 9; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the second digit of the Minutes\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\treturn timeFormat.toString(); // Final time\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        Map<Integer, Integer> timeMap = new HashMap<Integer, Integer>();\\n\\t\\tStringBuilder timeFormat = new StringBuilder();\\n\\t\\tboolean flag = false;\\n\\t\\tint len = A.length;\\n\\t\\tif (len > 4)\\n\\t\\t\\treturn \"\";\\n\\t\\tfor (int i : A)\\n\\t\\t\\ttimeMap.put(i, timeMap.getOrDefault(i, 0) + 1);\\n\\t\\tint s = 0, res = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (A[i] > 5)\\n\\t\\t\\t\\tres++; // Count the Number of entries which are greater than 5.\\n\\t\\t}\\n\\t\\t// If I have more than 2 entries which are greater than 5 I cannot form a max\\n\\t\\t// time starting with 2 else I can start a max time with 2.\\n\\t\\t// Hence \\'s\\' is either 1 or 2.\\n\\t\\ts = (res >= 2) ? 1 : 2;\\n\\t\\tfor (int i = s; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the first digit of the Hour with \\'s\\'\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\"; // Reset the flag if the condition failed\\n\\t\\tflag = false;\\n\\t\\t// If the first digit of the hour starts with 2, then I\\'m allowed only till 3\\n\\t\\t// for my second digit. Hence starting with 3.\\n\\t\\tif (timeFormat.charAt(0) == \\'2\\') {\\n\\t\\t\\tfor (int i = 3; i >= 0; i--) {\\n\\t\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\ttimeFormat.append(i); // Append the second digit of the Hour\\n\\t\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else { // If the first digit of the hour starts with 1 or 0, then I\\'m allowed only till\\n\\t\\t\\t\\t\\t// 9 for my second digit. Hence starting with 9.\\n\\t\\t\\tfor (int i = 9; i >= 0; i--) {\\n\\t\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\ttimeFormat.append(i);\\n\\t\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\ttimeFormat.append(\":\"); // Append the colon to separate Hours and Minutes\\n\\t\\tflag = false;\\n\\t\\t// The max number allowed to start my first digit of the minute is 5. Hence,\\n\\t\\t// starting with 5.\\n\\t\\tfor (int i = 5; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the first digit of the Minutes\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\tflag = false;\\n\\t\\t// The max number allowed to start my second digit of the minute is 9.\\n\\t\\t// Hence, starting with 9.\\n\\t\\tfor (int i = 9; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the second digit of the Minutes\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\treturn timeFormat.toString(); // Final time\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823144,
                "title": "java-solution-using-treemap-faster-than-90-submissions",
                "content": "\\n``` \\npublic String largestTimeFromDigits(int[] arr) {\\n        String ans=\"\";\\n        TreeMap <Integer,Integer> treeMap=new TreeMap<>();\\n        for(int i:arr){\\n            treeMap.merge(i, 1, Integer::sum);\\n        }\\n\\n        int hourOneKey=2;\\n            Integer hourOne=treeMap.floorKey(hourOneKey);\\n        while(hourOne!=null && hourOne>=0){\\n            ans += hourOne;\\n            treeMap.compute(hourOne, (key, value) -> (value - 1));\\n            if (treeMap.get(hourOne) == 0) treeMap.remove(hourOne);\\n            Integer hourTwoKey = (hourOne == 2) ? 3 : 9;\\n            Integer hourTwo = treeMap.floorKey(hourTwoKey);\\n            if (hourTwo != null) {\\n                ans += hourTwo;\\n                treeMap.compute(hourTwo, (key, val) -> (val - 1));\\n                if (treeMap.get(hourTwo) == 0) treeMap.remove(hourTwo);\\n                ans += \\':\\';\\n                Integer minOne = treeMap.floorKey(5);\\n                if (minOne != null) {\\n                    ans += minOne;\\n                    treeMap.compute(minOne, (key, val) -> (val - 1));\\n                    if (treeMap.get(minOne) == 0) treeMap.remove(minOne);\\n                    ans += treeMap.firstKey();\\n                }\\n            }\\n            if (ans.length() == 5) return ans;\\n        ans=\"\";\\n        treeMap.clear();\\n            for(int i:arr){\\n                treeMap.merge(i, 1, Integer::sum);\\n            }\\n            hourOne=treeMap.floorKey(hourOne-1);\\n        }\\n\\n        return new String(\"\");\\n    }\\n",
                "solutionTags": [],
                "code": "\\n``` \\npublic String largestTimeFromDigits(int[] arr) {\\n        String ans=\"\";\\n        TreeMap <Integer,Integer> treeMap=new TreeMap<>();\\n        for(int i:arr){\\n            treeMap.merge(i, 1, Integer::sum);\\n        }\\n\\n        int hourOneKey=2;\\n            Integer hourOne=treeMap.floorKey(hourOneKey);\\n        while(hourOne!=null && hourOne>=0){\\n            ans += hourOne;\\n            treeMap.compute(hourOne, (key, value) -> (value - 1));\\n            if (treeMap.get(hourOne) == 0) treeMap.remove(hourOne);\\n            Integer hourTwoKey = (hourOne == 2) ? 3 : 9;\\n            Integer hourTwo = treeMap.floorKey(hourTwoKey);\\n            if (hourTwo != null) {\\n                ans += hourTwo;\\n                treeMap.compute(hourTwo, (key, val) -> (val - 1));\\n                if (treeMap.get(hourTwo) == 0) treeMap.remove(hourTwo);\\n                ans += \\':\\';\\n                Integer minOne = treeMap.floorKey(5);\\n                if (minOne != null) {\\n                    ans += minOne;\\n                    treeMap.compute(minOne, (key, val) -> (val - 1));\\n                    if (treeMap.get(minOne) == 0) treeMap.remove(minOne);\\n                    ans += treeMap.firstKey();\\n                }\\n            }\\n            if (ans.length() == 5) return ans;\\n        ans=\"\";\\n        treeMap.clear();\\n            for(int i:arr){\\n                treeMap.merge(i, 1, Integer::sum);\\n            }\\n            hourOne=treeMap.floorKey(hourOne-1);\\n        }\\n\\n        return new String(\"\");\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 823137,
                "title": "python3",
                "content": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        best_minutes = -1\\n        for i in permutations(A):\\n            hours = i[0] * 10 + i[1]\\n            if hours >= 24:\\n                continue\\n            minutes = i[2] * 10 + i[3]\\n            if minutes >= 60:\\n                continue\\n            total_minutes = hours * 60 + minutes\\n            if total_minutes > best_minutes:\\n                best_minutes = total_minutes\\n                best = i\\n        if best_minutes == -1:\\n            return \\'\\'\\n        best = [str(i) for i in best]\\n        return \\'\\'.join(best[:2]) + \\':\\' + \\'\\'.join(best[2:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        best_minutes = -1\\n        for i in permutations(A):\\n            hours = i[0] * 10 + i[1]\\n            if hours >= 24:\\n                continue\\n            minutes = i[2] * 10 + i[3]\\n            if minutes >= 60:\\n                continue\\n            total_minutes = hours * 60 + minutes\\n            if total_minutes > best_minutes:\\n                best_minutes = total_minutes\\n                best = i\\n        if best_minutes == -1:\\n            return \\'\\'\\n        best = [str(i) for i in best]\\n        return \\'\\'.join(best[:2]) + \\':\\' + \\'\\'.join(best[2:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823120,
                "title": "python-calculate-all-possibility",
                "content": "Number of permutation = 4 ! = 24 so it it O(1)\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        def to_minute(arr):\\n            hour = 10 * arr[0] + arr[1]\\n            minute = 10 * arr[2] + arr[3]\\n            if hour < 24 and minute < 60: # valid time\\n                return hour * 60 + minute\\n            else:\\n                return -1\\n            \\n        def backtracking(i):\\n            if i == len(A): # finished one permutation\\n                self.res = max(self.res, to_minute(A))\\n            else:\\n                for j in range(i, len(A)):\\n                    A[i], A[j] = A[j], A[i]\\n                    backtracking(i + 1)\\n                    A[i], A[j] = A[j], A[i]\\n        \\n        def to_time(minute):\\n            if minute == -1: return \"\"\\n            hour_s = minute // 60\\n            min_s = minute % 60\\n            return \\'%02d:%02d\\' % (hour_s, min_s)\\n        \\n        self.res = -1\\n        backtracking(0)\\n        return to_time(self.res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        def to_minute(arr):\\n            hour = 10 * arr[0] + arr[1]\\n            minute = 10 * arr[2] + arr[3]\\n            if hour < 24 and minute < 60: # valid time\\n                return hour * 60 + minute\\n            else:\\n                return -1\\n            \\n        def backtracking(i):\\n            if i == len(A): # finished one permutation\\n                self.res = max(self.res, to_minute(A))\\n            else:\\n                for j in range(i, len(A)):\\n                    A[i], A[j] = A[j], A[i]\\n                    backtracking(i + 1)\\n                    A[i], A[j] = A[j], A[i]\\n        \\n        def to_time(minute):\\n            if minute == -1: return \"\"\\n            hour_s = minute // 60\\n            min_s = minute % 60\\n            return \\'%02d:%02d\\' % (hour_s, min_s)\\n        \\n        self.res = -1\\n        backtracking(0)\\n        return to_time(self.res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823100,
                "title": "simple-iterative-solution-with-video-explaination",
                "content": "https://www.youtube.com/watch?v=Y-uGoJqDtBM\\nIterative solution in constant time as the size of input array is fixed ie 4.\\n\\nTime Complexity is O(1)\\n\\n````\\nclass Solution {\\n    \\n                    // 0 1 2 3\\n                     //  max val (i +j + k) +l = 6\\n                    // l = 6 -i - j - k\\n    public String largestTimeFromDigits(int[] A) {\\n        int maxTime = -1;\\n        int maxHours = -1;\\n        int maxMin = -1;\\n        \\n        for(int i=0;i<A.length;i++){\\n            for(int j=0;j<A.length;j++){\\n                for(int k=0;k<A.length;k++){\\n                    if(i==j || j==k || k==i){\\n                        continue;\\n                    }\\n                    \\n                    int hoursTens = A[i];\\n                    int hoursUnits = A[j];\\n\\n                    int minsTens = A[k];\\n                    int minsUnit = A[6-i-j-k];\\n                    \\n                    \\n                    int hour = hoursTens*10 + hoursUnits;\\n                    \\n                    int min = minsTens * 10+ minsUnit;\\n                    \\n                    int totalTime  = hour*60 + min;\\n                    if(hour<24 && min< 60 && (totalTime)> maxTime){ //if we have a better time within hour and min constraint\\n                        maxTime = totalTime;\\n                        maxHours = hour;\\n                        maxMin = min;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(maxHours == -1 || maxMin == -1){\\n            return \"\";\\n        } else {\\n            // 9:45 => 09:45 , 7:8 = > 07:08\\n            return padding(maxHours) + \":\" + padding(maxMin); \\n        }\\n        \\n    }\\n    private String padding(int no){\\n        String str = \"\"+no;\\n        if(str.length()==1){\\n            str = \"0\" + str;\\n        }\\n        return str;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n                    // 0 1 2 3\\n                     //  max val (i +j + k) +l = 6\\n                    // l = 6 -i - j - k\\n    public String largestTimeFromDigits(int[] A) {\\n        int maxTime = -1;\\n        int maxHours = -1;\\n        int maxMin = -1;\\n        \\n        for(int i=0;i<A.length;i++){\\n            for(int j=0;j<A.length;j++){\\n                for(int k=0;k<A.length;k++){\\n                    if(i==j || j==k || k==i){\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 823055,
                "title": "largest-time-for-given-digits-using-greedy-stl-library",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans = \"\";\\n        sort(A.begin(),A.end());\\n        do{\\n            if((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5 && A[3]<=9){\\n                string temp = to_string(A[0]) + to_string(A[1]) + \\':\\' + to_string(A[2]) + to_string(A[3]);\\n                \\n                if(temp > ans)\\n                    ans = temp;\\n            }\\n            \\n        }\\n        while(next_permutation(A.begin(),A.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans = \"\";\\n        sort(A.begin(),A.end());\\n        do{\\n            if((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5 && A[3]<=9){\\n                string temp = to_string(A[0]) + to_string(A[1]) + \\':\\' + to_string(A[2]) + to_string(A[3]);\\n                \\n                if(temp > ans)\\n                    ans = temp;\\n            }\\n            \\n        }\\n        while(next_permutation(A.begin(),A.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822981,
                "title": "python-o-4-by-permutation-w-hint",
                "content": "![image](https://assets.leetcode.com/users/images/68fdc533-7cca-4b33-ac11-9413cb8a4fdc_1598950579.2524464.png)\\n\\n[image source](https://picclick.com/Car-Clock-12-Volt-Led-Digital-Dash-Panel-264092407158.html)\\n\\n---\\n\\n**Hint**:\\n\\na.\\nConsider input is 4 digits, and permutations cost is **O( 4! ) = 24**, which is **small enough**.\\n\\nTherefore we enumerate all permutation, validate its time range, and update maximum clock time.\\n\\n---\\n\\nb. \\nOuput format is **HH:MM**, remember to apply **zero padding on the front** if needed.\\n\\nFor example:\\n1:23 is wrong, which doesn\\'t match the output format.\\n**0**1:23 is correct.\\n\\n---\\n\\n```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        hour, minute = -1, -1\\n        \\n        for h1, h2, m1, m2 in permutations(A):\\n            \\n            cur_hour, cur_min = 10*h1 + h2, 10*m1 + m2\\n\\n            if cur_hour >= 24 or cur_min >= 60:\\n                \\n                # skip invaid clock time\\n                continue\\n                \\n                \\n            if cur_hour * 60 + cur_min > hour*60 + minute:\\n                # update and record maximum clock time\\n                hour, minute = cur_hour, cur_min\\n                    \\n                    \\n        if (hour, minute) == (-1, -1):\\n            return \"\"\\n        \\n        else:\\n            # convert to clock string with zero-padding on the front\\n            clock_string = [f\\'{hour:02}\\', f\\'{minute:02}\\']\\n            return \\':\\'.join( clock_string )\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about permutations](https://docs.python.org/3/library/itertools.html#itertools.permutations)\\n\\n[2] [Python official docs about f-string](https://www.python.org/dev/peps/pep-0498/#how-to-denote-f-strings)\\n\\n[3] [Wiki: 24-hour clock time](https://en.wikipedia.org/wiki/24-hour_clock)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Probability and Statistics"
                ],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        hour, minute = -1, -1\\n        \\n        for h1, h2, m1, m2 in permutations(A):\\n            \\n            cur_hour, cur_min = 10*h1 + h2, 10*m1 + m2\\n\\n            if cur_hour >= 24 or cur_min >= 60:\\n                \\n                # skip invaid clock time\\n                continue\\n                \\n                \\n            if cur_hour * 60 + cur_min > hour*60 + minute:\\n                # update and record maximum clock time\\n                hour, minute = cur_hour, cur_min\\n                    \\n                    \\n        if (hour, minute) == (-1, -1):\\n            return \"\"\\n        \\n        else:\\n            # convert to clock string with zero-padding on the front\\n            clock_string = [f\\'{hour:02}\\', f\\'{minute:02}\\']\\n            return \\':\\'.join( clock_string )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822934,
                "title": "cool-creative-python-solution",
                "content": "the idea is to try to create all permutations of times and return the max\\n\\n```\\nclass Solution:\\n    \\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        permutations = set(itertools.permutations(A))\\n        max_time = datetime.time(0, 0)\\n        flag = False\\n        my_time = \"\"\\n\\t\\t\\n        for permutation in permutations:\\n            hour = permutation[0] * 10 + permutation[1]\\n            minutes = permutation[2] * 10 + permutation[3]\\n            try:\\n                my_time = datetime.time(hour, minutes)\\n                \\n                if max_time <= my_time:\\n                    max_time = my_time\\n                    flag = True\\n                    \\n            except ValueError:\\n                pass\\n        \\n        return f\\'{max_time}\\'[:-3] if flag else \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        permutations = set(itertools.permutations(A))\\n        max_time = datetime.time(0, 0)\\n        flag = False\\n        my_time = \"\"\\n\\t\\t\\n        for permutation in permutations:\\n            hour = permutation[0] * 10 + permutation[1]\\n            minutes = permutation[2] * 10 + permutation[3]\\n            try:\\n                my_time = datetime.time(hour, minutes)\\n                \\n                if max_time <= my_time:\\n                    max_time = my_time\\n                    flag = True\\n                    \\n            except ValueError:\\n                pass\\n        \\n        return f\\'{max_time}\\'[:-3] if flag else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751205,
                "title": "c",
                "content": "### [\\u53C2\\u8003](https://www.cnblogs.com/grandyang/p/13123589.html)\\n```C++\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        \\n        string result;\\n        \\n        sort(A.begin(), A.end());\\n        \\n        do{\\n            string hour = {char(A[0] + \\'0\\'), char(A[1] + \\'0\\')}, minute = {char(A[2] + \\'0\\'), char(A[3] + \\'0\\')};\\n            \\n            result = (hour <= \"23\" && minute <= \"59\") ? (hour + \":\" + minute) : result;\\n            \\n        } while (next_permutation(A.begin(), A.end()));\\n            \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        \\n        string result;\\n        \\n        sort(A.begin(), A.end());\\n        \\n        do{\\n            string hour = {char(A[0] + \\'0\\'), char(A[1] + \\'0\\')}, minute = {char(A[2] + \\'0\\'), char(A[3] + \\'0\\')};\\n            \\n            result = (hour <= \"23\" && minute <= \"59\") ? (hour + \":\" + minute) : result;\\n            \\n        } while (next_permutation(A.begin(), A.end()));\\n            \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732927,
                "title": "python3-straightforward-solution-with-explanation",
                "content": "class Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        # first get all possible permutations\\n        # then rule out those invalid numbers\\n        # return the max\\n        n = len(A)\\n        possible_times = []\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    for l in range(n):\\n                        if i != j and i != k and i != l and j != k and j != l and k != l:\\n                            possible_times.append(str(A[i])+str(A[j])+str(A[k])+str(A[l]))\\n        valid_times = []\\n        for i in range(len(possible_times)):\\n            if int(possible_times[i][0]) == 2:\\n                if int(possible_times[i][1]) <= 3:\\n                    if int(possible_times[i][2]) <= 5:\\n                        valid_times.append(int(possible_times[i]))\\n            elif int(possible_times[i][0]) <= 1:\\n                if int(possible_times[i][2]) <= 5:\\n                        valid_times.append(int(possible_times[i]))\\n        if len(valid_times) == 0:\\n            return(\"\")\\n        else:\\n            max_valid_time_str = str(max(valid_times))\\n            if len(max_valid_time_str) == 4:\\n                return(max_valid_time_str[0]+max_valid_time_str[1]+\\':\\'+max_valid_time_str[2]+max_valid_time_str[3])\\n            elif len(max_valid_time_str) == 3:\\n                return(\\'0\\'+max_valid_time_str[0]+\\':\\'+max_valid_time_str[1]+max_valid_time_str[2])\\n            elif len(max_valid_time_str) == 2:\\n                return(\\'0\\'+\\'0\\'+\\':\\'+max_valid_time_str[0]+max_valid_time_str[1])\\n            else:\\n                return(\\'0\\'+\\'0\\'+\\':\\'+\\'0\\'+max_valid_time_str[0])",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        # first get all possible permutations\\n        # then rule out those invalid numbers\\n        # return the max\\n        n = len(A)\\n        possible_times = []\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    for l in range(n):\\n                        if i != j and i != k and i != l and j != k and j != l and k != l:\\n                            possible_times.append(str(A[i])+str(A[j])+str(A[k])+str(A[l]))\\n        valid_times = []\\n        for i in range(len(possible_times)):\\n            if int(possible_times[i][0]) == 2:\\n                if int(possible_times[i][1]) <= 3:\\n                    if int(possible_times[i][2]) <= 5:\\n                        valid_times.append(int(possible_times[i]))\\n            elif int(possible_times[i][0]) <= 1:\\n                if int(possible_times[i][2]) <= 5:\\n                        valid_times.append(int(possible_times[i]))\\n        if len(valid_times) == 0:\\n            return(\"\")\\n        else:\\n            max_valid_time_str = str(max(valid_times))\\n            if len(max_valid_time_str) == 4:\\n                return(max_valid_time_str[0]+max_valid_time_str[1]+\\':\\'+max_valid_time_str[2]+max_valid_time_str[3])\\n            elif len(max_valid_time_str) == 3:\\n                return(\\'0\\'+max_valid_time_str[0]+\\':\\'+max_valid_time_str[1]+max_valid_time_str[2])\\n            elif len(max_valid_time_str) == 2:\\n                return(\\'0\\'+\\'0\\'+\\':\\'+max_valid_time_str[0]+max_valid_time_str[1])\\n            else:\\n                return(\\'0\\'+\\'0\\'+\\':\\'+\\'0\\'+max_valid_time_str[0])",
                "codeTag": "Java"
            },
            {
                "id": 677961,
                "title": "rust-nested-iterators-for-the-lulz",
                "content": "```\\n    pub fn largest_time_from_digits(a: Vec<i32>) -> String {\\n        \\n        let iter = (0_usize..4_usize).into_iter();\\n        let max = iter.clone()\\n            .filter(|&i| a[i] < 3)\\n            .map(|i| iter.clone()\\n                        .filter(|&j| j != i && (a[i] != 2 || a[j] < 4) )\\n                        .map(|j| iter.clone()\\n                                     .filter(|&k| k != j && k != i && a[k] < 6)\\n                                     .map(|k| iter.clone()\\n                                                 .filter(|&l| l != k && l != j && l != i)\\n                                                 .map(|l| a[i] *600 + a[j]*60 + a[k] * 10 + a[l])\\n                                                 .max()\\n                                                 \\n                                                 \\n                                        ).max()\\n                                        \\n                        ).max()\\n                        \\n                )\\n            .max();\\n        match max {\\n            Some(Some(Some(Some(x)))) => format!(\"{:0>2}:{:0>2}\", x /60, x%60),\\n        _ => \"\".to_string()\\n        }       \\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n    pub fn largest_time_from_digits(a: Vec<i32>) -> String {\\n        \\n        let iter = (0_usize..4_usize).into_iter();\\n        let max = iter.clone()\\n            .filter(|&i| a[i] < 3)\\n            .map(|i| iter.clone()\\n                        .filter(|&j| j != i && (a[i] != 2 || a[j] < 4) )\\n                        .map(|j| iter.clone()\\n                                     .filter(|&k| k != j && k != i && a[k] < 6)\\n                                     .map(|k| iter.clone()\\n                                                 .filter(|&l| l != k && l != j && l != i)\\n                                                 .map(|l| a[i] *600 + a[j]*60 + a[k] * 10 + a[l])\\n                                                 .max()\\n                                                 \\n                                                 \\n                                        ).max()\\n                                        \\n                        ).max()\\n                        \\n                )\\n            .max();\\n        match max {\\n            Some(Some(Some(Some(x)))) => format!(\"{:0>2}:{:0>2}\", x /60, x%60),\\n        _ => \"\".to_string()\\n        }       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 671731,
                "title": "concise-and-simple-js-solution",
                "content": "```\\nvar largestTimeFromDigits = function(A) {\\n    const convert = (h, m) => (parseInt(h) * 60) + parseInt(m)\\n    \\n    const isValid = (h, m) => parseInt(h) <= 23 && parseInt(m) <= 59\\n    \\n    let permutations = []\\n    \\n    let max = 0\\n     \\n    const check = (permutation) => {\\n        let h = permutation[0]+\\'\\'+permutation[1]\\n        let m = permutation[2]+\\'\\'+permutation[3]\\n        \\n        if (isValid(h, m)) {\\n            if (!max || convert(max[0], max[1]) < convert(h, m)) max = [h, m]\\n        }\\n    }\\n    \\n    const permute = (array, index) => {\\n        if (index == array.length) check([...array])\\n        for (let i = index; i < array.length; i++) {\\n            [array[index], array[i]] = [array[i], array[index]]\\n            permute(array, index+1);\\n            [array[index], array[i]] = [array[i], array[index]]\\n        }\\n    }\\n    \\n    permute(A, 0)\\n   \\n    return max ? max[0]+\\':\\'+max[1] : \\'\\'\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar largestTimeFromDigits = function(A) {\\n    const convert = (h, m) => (parseInt(h) * 60) + parseInt(m)\\n    \\n    const isValid = (h, m) => parseInt(h) <= 23 && parseInt(m) <= 59\\n    \\n    let permutations = []\\n    \\n    let max = 0\\n     \\n    const check = (permutation) => {\\n        let h = permutation[0]+\\'\\'+permutation[1]\\n        let m = permutation[2]+\\'\\'+permutation[3]\\n        \\n        if (isValid(h, m)) {\\n            if (!max || convert(max[0], max[1]) < convert(h, m)) max = [h, m]\\n        }\\n    }\\n    \\n    const permute = (array, index) => {\\n        if (index == array.length) check([...array])\\n        for (let i = index; i < array.length; i++) {\\n            [array[index], array[i]] = [array[i], array[index]]\\n            permute(array, index+1);\\n            [array[index], array[i]] = [array[i], array[index]]\\n        }\\n    }\\n    \\n    permute(A, 0)\\n   \\n    return max ? max[0]+\\':\\'+max[1] : \\'\\'\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 568343,
                "title": "java-solution-beats-97-5-time-100-space",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] nums) {\\n        String res = \"\";\\n        for (int a = 0; a < 4; a++) {\\n            if (nums[a] > 2) continue;\\n            for (int b = 0; b < 4; b++) {\\n                if (b == a || (nums[a] == 2 && nums[b] > 3)) continue;\\n                for (int c = 0; c < 4; c++) {\\n                    if (c == a || c == b || nums[c] > 5) continue;\\n                    int d = 6 - a - b - c;\\n                    StringBuilder sb = new StringBuilder();\\n                    sb.append(nums[a]).append(nums[b]).append(\":\").append(nums[c]).append(nums[d]);\\n\\n                    String tmp = sb.toString();\\n                    if (res.compareTo(tmp) < 0) res = tmp;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] nums) {\\n        String res = \"\";\\n        for (int a = 0; a < 4; a++) {\\n            if (nums[a] > 2) continue;\\n            for (int b = 0; b < 4; b++) {\\n                if (b == a || (nums[a] == 2 && nums[b] > 3)) continue;\\n                for (int c = 0; c < 4; c++) {\\n                    if (c == a || c == b || nums[c] > 5) continue;\\n                    int d = 6 - a - b - c;\\n                    StringBuilder sb = new StringBuilder();\\n                    sb.append(nums[a]).append(nums[b]).append(\":\").append(nums[c]).append(nums[d]);\\n\\n                    String tmp = sb.toString();\\n                    if (res.compareTo(tmp) < 0) res = tmp;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545697,
                "title": "c-permutation-and-validation",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string res = \"\";\\n        vector<string> vec;\\n        vector<bool> visited(4, false);\\n        permutation(A, vec, visited, \"\");\\n        sort(vec.rbegin(), vec.rend());\\n        for(auto a : vec) {\\n            if(isvalid(a)) {\\n                res = a;\\n                break;\\n            }\\n        }\\n        // string :: insert(iterator, char)\\n        if(res != \"\") res.insert(res.begin() + 2, \\':\\');\\n        return res;\\n    }\\n    void permutation(vector<int>& A, vector<string>& res, vector<bool>& visited, string path) {\\n        if(path.size() == A.size()) {\\n            res.push_back(path);\\n            return;\\n        }\\n        for(int i = 0; i < A.size(); i++) {\\n            if(!visited[i]) {\\n                visited[i] = true;\\n                permutation(A, res, visited, path + to_string(A[i]));\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n    bool isvalid(string s) {\\n        if(s[0] > \\'2\\') return false;\\n        if(s[0] == \\'2\\' && s[1] >= \\'4\\') return false;\\n        if(s[2] > \\'5\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string res = \"\";\\n        vector<string> vec;\\n        vector<bool> visited(4, false);\\n        permutation(A, vec, visited, \"\");\\n        sort(vec.rbegin(), vec.rend());\\n        for(auto a : vec) {\\n            if(isvalid(a)) {\\n                res = a;\\n                break;\\n            }\\n        }\\n        // string :: insert(iterator, char)\\n        if(res != \"\") res.insert(res.begin() + 2, \\':\\');\\n        return res;\\n    }\\n    void permutation(vector<int>& A, vector<string>& res, vector<bool>& visited, string path) {\\n        if(path.size() == A.size()) {\\n            res.push_back(path);\\n            return;\\n        }\\n        for(int i = 0; i < A.size(); i++) {\\n            if(!visited[i]) {\\n                visited[i] = true;\\n                permutation(A, res, visited, path + to_string(A[i]));\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n    bool isvalid(string s) {\\n        if(s[0] > \\'2\\') return false;\\n        if(s[0] == \\'2\\' && s[1] >= \\'4\\') return false;\\n        if(s[2] > \\'5\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523682,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int ans = -1;        \\n        for(int i = 0; i < 4; i++) {     \\n            for(int j = 0; j < 4; j++) {\\n                    for(int k = 0; k < 4; k++) {\\n                        for(int l = 0; l < 4; l++) {\\n                            if( i != j && j != k && k != l && i != k && i != l && j != l ) {\\n                                   int hours = 10 * A[i] + A[j];\\n                                   int mins = 10 * A[k] + A[l];\\n                                   if (hours < 24 && mins < 60)\\n                                    ans = Math.max(ans, hours * 60 + mins);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n    \\n\\n        return ans >= 0 ? String.format(\"%02d:%02d\", ans / 60, ans % 60) : \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int ans = -1;        \\n        for(int i = 0; i < 4; i++) {     \\n            for(int j = 0; j < 4; j++) {\\n                    for(int k = 0; k < 4; k++) {\\n                        for(int l = 0; l < 4; l++) {\\n                            if( i != j && j != k && k != l && i != k && i != l && j != l ) {\\n                                   int hours = 10 * A[i] + A[j];\\n                                   int mins = 10 * A[k] + A[l];\\n                                   if (hours < 24 && mins < 60)\\n                                    ans = Math.max(ans, hours * 60 + mins);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n    \\n\\n        return ans >= 0 ? String.format(\"%02d:%02d\", ans / 60, ans % 60) : \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495040,
                "title": "java-code-arrayutils-help",
                "content": "Below java code uses ArrayUtils class for removing elements ,** is there any other way to calculate minutes after we get hours in this code ?**\\n\\n```\\n    public String largestTimeFromDigits(int[] A) {\\n        String ret = \"\";\\n\\t\\tString hrPrev = \"\";\\n\\t\\tString min = \"\";\\n\\t\\t// store positions of hours\\n\\t\\tint[] hrInt = new int[2];\\n\\t\\tint[] positions = { 0, 1, 2, 3 };\\n\\n\\t\\t// Calculate the hours first\\n\\t\\tfor (int i = 0; i < 4; ++i) {\\n\\t\\t\\tfor (int j = 0; j < 4; ++j) {\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tString hr = \"\" + A[i] + A[j];\\n\\t\\t\\t\\tif (hr.compareTo(\"24\") < 0 && hrPrev.compareTo(hr) < 0) {\\n\\t\\t\\t\\t\\thrPrev = hr;\\n\\t\\t\\t\\t\\thrInt[0] = i;\\n\\t\\t\\t\\t\\thrInt[1] = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// remove hours positions from positions array\\n\\t\\tpositions = org.apache.commons.lang.ArrayUtils.removeElement(positions, hrInt[0]);\\n\\t\\tpositions = org.apache.commons.lang.ArrayUtils.removeElement(positions, hrInt[1]);\\n\\n\\t\\t// calculate the minutes now\\n\\n\\t\\tint minutes1 = A[positions[0]] * 10 + A[positions[1]];\\n\\t\\tint minutes2 = A[positions[1]] * 10 + A[positions[0]];\\n\\n\\t\\tint minutes = (minutes1 > minutes2) ? minutes1 : minutes2;\\n\\n\\t\\tif (minutes < 60) {\\n\\t\\t\\tmin = \"\" + minutes;\\n\\t\\t}\\n\\n\\t\\tif (hrPrev == \"\" || min == \"\") {\\n\\t\\t\\treturn ret;\\n\\t\\t} else {\\n\\t\\t\\tret = hrPrev + \":\" + min;\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n    }\\n",
                "solutionTags": [],
                "code": "Below java code uses ArrayUtils class for removing elements ,** is there any other way to calculate minutes after we get hours in this code ?**\\n\\n```\\n    public String largestTimeFromDigits(int[] A) {\\n        String ret = \"\";\\n\\t\\tString hrPrev = \"\";\\n\\t\\tString min = \"\";\\n\\t\\t// store positions of hours\\n\\t\\tint[] hrInt = new int[2];\\n\\t\\tint[] positions = { 0, 1, 2, 3 };\\n\\n\\t\\t// Calculate the hours first\\n\\t\\tfor (int i = 0; i < 4; ++i) {\\n\\t\\t\\tfor (int j = 0; j < 4; ++j) {\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tString hr = \"\" + A[i] + A[j];\\n\\t\\t\\t\\tif (hr.compareTo(\"24\") < 0 && hrPrev.compareTo(hr) < 0) {\\n\\t\\t\\t\\t\\thrPrev = hr;\\n\\t\\t\\t\\t\\thrInt[0] = i;\\n\\t\\t\\t\\t\\thrInt[1] = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// remove hours positions from positions array\\n\\t\\tpositions = org.apache.commons.lang.ArrayUtils.removeElement(positions, hrInt[0]);\\n\\t\\tpositions = org.apache.commons.lang.ArrayUtils.removeElement(positions, hrInt[1]);\\n\\n\\t\\t// calculate the minutes now\\n\\n\\t\\tint minutes1 = A[positions[0]] * 10 + A[positions[1]];\\n\\t\\tint minutes2 = A[positions[1]] * 10 + A[positions[0]];\\n\\n\\t\\tint minutes = (minutes1 > minutes2) ? minutes1 : minutes2;\\n\\n\\t\\tif (minutes < 60) {\\n\\t\\t\\tmin = \"\" + minutes;\\n\\t\\t}\\n\\n\\t\\tif (hrPrev == \"\" || min == \"\") {\\n\\t\\t\\treturn ret;\\n\\t\\t} else {\\n\\t\\t\\tret = hrPrev + \":\" + min;\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n    }\\n",
                "codeTag": "Java"
            },
            {
                "id": 454440,
                "title": "949-largest-time-for-given-digits-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Brute Force - Permutation**\\n| O(T): O(nn) | O(S): O(nn) | Rt: 28ms | \\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        possible = itertools.permutations(A, 4)\\n        isvalid = lambda x: x[0]*10 + x[1] < 24 and x[2]*10 + x[3] < 60\\n        validTime = [i for i in possible if isvalid(i)]\\n        if not validTime: return \\'\\'\\n        rst = max(validTime, key = lambda x: (x[0]*10 + x[1], x[2]*10 + x[3]))\\n        return f\"{rst[0]}{rst[1]}:{rst[2]}{rst[3]}\"\\n```\\nAlternative: one-liner.  | Rt: 28ms |\\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        return max([f\"{i[0]}{i[1]}:{i[2]}{i[3]}\" for i in itertools.permutations(A, 4) if i[:2] < (2, 4) and i[2] < 6] or [\\'\\'])\\n```\\nReferrence: https://leetcode.com/problems/largest-time-for-given-digits/discuss/200517/Python-1-line-Check-Permutations-O(24)\\n\\n\\n**II). Sort and Permutation**\\n| O(T): O(n^2lgn) | O(S): O(nn) | Rt: 20ms | \\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        for i in itertools.permutations(sorted(A, reverse=True), 4):\\n            if i[0]*10 + i[1] < 24 and i[2]*10 + i[3] < 60: \\n                return f\"{i[0]}{i[1]}:{i[2]}{i[3]}\"\\n        return \\'\\'\\n```\\nAlternative: lengthy one-liner.  | Rt: 28ms |\\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        return next((f\"{i[0]}{i[1]}:{i[2]}{i[3]}\" for i in itertools.permutations(sorted(A, reverse=True), 4) if i[0]*10 + i[1] < 24 and i[2]*10 + i[3] < 60), \\'\\') \\n```\\nComment: pay attention to the default value of next. \\n\\n\\n**III). Brute Force**\\n| O(T): O(n^3) | O(S): O(1) | Rt: 28ms | \\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        rst = \\'\\'\\n        for i in range(4):\\n            for j in range(4):\\n                for k in range(4):\\n                    if (i == j or i == k or j == k): continue\\n                    #0, 1, 2, 3, all add up, get 6    \\n                    l = 6 - i -j - k\\n                    cur = f\"{A[i]}{A[j]}:{A[k]}{A[l]}\"\\n                    if cur[:2] > \\'23\\' or cur[3] > \\'5\\': continue\\n                    rst = max(rst, cur)\\n        return rst\\n```\\nReferrence: https://leetcode.com/problems/largest-time-for-given-digits/discuss/200693/Java-11-liner-O(64)-w-comment-6-ms.\\n",
                "solutionTags": [],
                "code": "```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        possible = itertools.permutations(A, 4)\\n        isvalid = lambda x: x[0]*10 + x[1] < 24 and x[2]*10 + x[3] < 60\\n        validTime = [i for i in possible if isvalid(i)]\\n        if not validTime: return \\'\\'\\n        rst = max(validTime, key = lambda x: (x[0]*10 + x[1], x[2]*10 + x[3]))\\n        return f\"{rst[0]}{rst[1]}:{rst[2]}{rst[3]}\"\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        return max([f\"{i[0]}{i[1]}:{i[2]}{i[3]}\" for i in itertools.permutations(A, 4) if i[:2] < (2, 4) and i[2] < 6] or [\\'\\'])\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        for i in itertools.permutations(sorted(A, reverse=True), 4):\\n            if i[0]*10 + i[1] < 24 and i[2]*10 + i[3] < 60: \\n                return f\"{i[0]}{i[1]}:{i[2]}{i[3]}\"\\n        return \\'\\'\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        return next((f\"{i[0]}{i[1]}:{i[2]}{i[3]}\" for i in itertools.permutations(sorted(A, reverse=True), 4) if i[0]*10 + i[1] < 24 and i[2]*10 + i[3] < 60), \\'\\') \\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        rst = \\'\\'\\n        for i in range(4):\\n            for j in range(4):\\n                for k in range(4):\\n                    if (i == j or i == k or j == k): continue\\n                    #0, 1, 2, 3, all add up, get 6    \\n                    l = 6 - i -j - k\\n                    cur = f\"{A[i]}{A[j]}:{A[k]}{A[l]}\"\\n                    if cur[:2] > \\'23\\' or cur[3] > \\'5\\': continue\\n                    rst = max(rst, cur)\\n        return rst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 364813,
                "title": "java-dfs-1ms",
                "content": "\\tint res = -1;\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        boolean[] visited = new boolean[A.length];\\n        dfs(A, visited, 0);\\n        int tmp = res;\\n        StringBuilder sb = new StringBuilder();\\n        while(tmp > 0) {\\n        \\tif(sb.length() == 2)\\n        \\t\\tsb.insert(0, \\':\\');\\n        \\tsb.insert(0, tmp%10);\\n        \\ttmp/=10;\\n        }\\n        while(sb.length() < 5) {\\n        \\tif(sb.length() == 2)\\n        \\t\\tsb.insert(0, \\':\\');\\n        \\tsb.insert(0, \\'0\\');\\n        }\\n        return res >= 0 ? sb.toString() : \"\";\\n    }\\n    \\n    void dfs(int[] A, boolean[] visited, int tmp){\\n        if(isAllVisited(visited) && (tmp >= 2400 || tmp%100 >= 60)) \\n            return;\\n        if(isAllVisited(visited))\\n        \\tres = Math.max(tmp, res);\\n        for(int i=0;i<A.length;i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                dfs(A, visited, tmp*10 + A[i]);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n    \\n    boolean isAllVisited(boolean[] visited){\\n        for(boolean v : visited)\\n            if(!v)\\n                return false;\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "\\tint res = -1;\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        boolean[] visited = new boolean[A.length];\\n        dfs(A, visited, 0);\\n        int tmp = res;\\n        StringBuilder sb = new StringBuilder();\\n        while(tmp > 0) {\\n        \\tif(sb.length() == 2)\\n        \\t\\tsb.insert(0, \\':\\');\\n        \\tsb.insert(0, tmp%10);\\n        \\ttmp/=10;\\n        }\\n        while(sb.length() < 5) {\\n        \\tif(sb.length() == 2)\\n        \\t\\tsb.insert(0, \\':\\');\\n        \\tsb.insert(0, \\'0\\');\\n        }\\n        return res >= 0 ? sb.toString() : \"\";\\n    }\\n    \\n    void dfs(int[] A, boolean[] visited, int tmp){\\n        if(isAllVisited(visited) && (tmp >= 2400 || tmp%100 >= 60)) \\n            return;\\n        if(isAllVisited(visited))\\n        \\tres = Math.max(tmp, res);\\n        for(int i=0;i<A.length;i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                dfs(A, visited, tmp*10 + A[i]);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n    \\n    boolean isAllVisited(boolean[] visited){\\n        for(boolean v : visited)\\n            if(!v)\\n                return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 356682,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nStarting from highest possible timestamp `23:59`, we will go round the clock decrementing the time and stopping when we are able to find all the digits from the current timestamp. \\n\\nEasy way to check that is extract digits and sort them (`curr` in the code) and sort and compare with sorted input `a`. \\n\\n```\\npublic String largestTimeFromDigits(int[] a) {\\n        Arrays.sort(a);\\n        for(int h=23; h >= 0; h--){\\n            for(int m=59; m >= 0; m--){\\n                String s = helper(a, h, m);\\n                if(s != null)\\n                    return s;\\n            }\\n        }\\n        return \"\";\\n    }\\n    private String helper(int[] a, int h, int m){\\n        StringBuilder sb = new StringBuilder();\\n        int[] curr = new int[4];\\n        int d = m % 10;\\n        sb.append(d);\\n        curr[3] = d;\\n        m /= 10;\\n        sb.append(m);\\n        curr[2] = m;\\n        sb.append(\":\");\\n        d = h % 10;\\n        sb.append(d);\\n        curr[1] = d;\\n        h /= 10;\\n        sb.append(h);\\n        curr[0] = h;\\n        Arrays.sort(curr);\\n        for(int i=0; i < a.length; i++)\\n            if(a[i] != curr[i])\\n                return null;\\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestTimeFromDigits(int[] a) {\\n        Arrays.sort(a);\\n        for(int h=23; h >= 0; h--){\\n            for(int m=59; m >= 0; m--){\\n                String s = helper(a, h, m);\\n                if(s != null)\\n                    return s;\\n            }\\n        }\\n        return \"\";\\n    }\\n    private String helper(int[] a, int h, int m){\\n        StringBuilder sb = new StringBuilder();\\n        int[] curr = new int[4];\\n        int d = m % 10;\\n        sb.append(d);\\n        curr[3] = d;\\n        m /= 10;\\n        sb.append(m);\\n        curr[2] = m;\\n        sb.append(\":\");\\n        d = h % 10;\\n        sb.append(d);\\n        curr[1] = d;\\n        h /= 10;\\n        sb.append(h);\\n        curr[0] = h;\\n        Arrays.sort(curr);\\n        for(int i=0; i < a.length; i++)\\n            if(a[i] != curr[i])\\n                return null;\\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 336615,
                "title": "easy-to-understand-javascript-solution-with-comments-52ms-94-100",
                "content": "Going down from 23 hours to 0 hours. If hours are found - check if minutes are valid.\\n\\n```\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n    let result = \\'\\';\\n    \\n    for (let hours = 23; hours >= 0; hours--) {\\n        const h = Math.floor(hours / 10);\\n        const l = hours % 10;\\n        const hI = A.indexOf(h);\\n        \\n        // check if both hour\\'s digits are in A\\n        if (hI >= 0 && A.indexOf(l, h === l ? hI + 1 : 0) >= 0) {\\n            const arr = [...A]; //copy array\\n            \\n            // remove hour\\'s digits\\n            arr.splice(hI, 1);\\n            arr.splice(arr.indexOf(l), 1);\\n            \\n            // 2 candidates for minues\\n            const mins1 = arr[0] * 10 + arr[1];\\n            const mins2 = arr[1] * 10 + arr[0];\\n            \\n            // check if candidates are valid\\n            const candidates = [];\\n            if (mins1 >= 0 && mins1 <= 59) {\\n                candidates.push(mins1);\\n            }\\n            if (mins2 >=0 && mins2 <= 59) {\\n                candidates.push(mins2);\\n            }\\n            \\n            // no valid candidates, continue loop\\n            if (candidates.length === 0) {\\n                continue;\\n            }\\n            \\n            candidates.sort();\\n            // take the biggest valid candidate\\n            const mins = candidates[candidates.length - 1];\\n            \\n            const hStr = hours < 10 ? `0${hours}` : `${hours}`;\\n            const mStr = mins < 10 ? `0${mins}` : `${mins}`;\\n            return `${hStr}:${mStr}`;\\n        }\\n    }\\n    \\n    return \\'\\';\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n    let result = \\'\\';\\n    \\n    for (let hours = 23; hours >= 0; hours--) {\\n        const h = Math.floor(hours / 10);\\n        const l = hours % 10;\\n        const hI = A.indexOf(h);\\n        \\n        // check if both hour\\'s digits are in A\\n        if (hI >= 0 && A.indexOf(l, h === l ? hI + 1 : 0) >= 0) {\\n            const arr = [...A]; //copy array\\n            \\n            // remove hour\\'s digits\\n            arr.splice(hI, 1);\\n            arr.splice(arr.indexOf(l), 1);\\n            \\n            // 2 candidates for minues\\n            const mins1 = arr[0] * 10 + arr[1];\\n            const mins2 = arr[1] * 10 + arr[0];\\n            \\n            // check if candidates are valid\\n            const candidates = [];\\n            if (mins1 >= 0 && mins1 <= 59) {\\n                candidates.push(mins1);\\n            }\\n            if (mins2 >=0 && mins2 <= 59) {\\n                candidates.push(mins2);\\n            }\\n            \\n            // no valid candidates, continue loop\\n            if (candidates.length === 0) {\\n                continue;\\n            }\\n            \\n            candidates.sort();\\n            // take the biggest valid candidate\\n            const mins = candidates[candidates.length - 1];\\n            \\n            const hStr = hours < 10 ? `0${hours}` : `${hours}`;\\n            const mStr = mins < 10 ? `0${mins}` : `${mins}`;\\n            return `${hStr}:${mStr}`;\\n        }\\n    }\\n    \\n    return \\'\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 318695,
                "title": "go-with-no-permutations-in-20lines",
                "content": "```\\nfunc largestTimeFromDigits(A []int) string {\\n\\tsort.Ints(A)\\n\\tfor i := 3; i >= 0; i-- {\\n\\t\\tfor j := 3; j >= 0; j-- {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tfor k := 3; k >= 0; k-- {\\n\\t\\t\\t\\tif k == i || k == j {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\th, m := 10*A[i]+A[j], 10*A[k]+A[6-i-j-k]\\n\\t\\t\\t\\tif h < 24 && m < 60 {\\n\\t\\t\\t\\t\\treturn fmt.Sprintf(\"%02d:%02d\", h, m)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn \"\"\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc largestTimeFromDigits(A []int) string {\\n\\tsort.Ints(A)\\n\\tfor i := 3; i >= 0; i-- {\\n\\t\\tfor j := 3; j >= 0; j-- {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tfor k := 3; k >= 0; k-- {\\n\\t\\t\\t\\tif k == i || k == j {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\th, m := 10*A[i]+A[j], 10*A[k]+A[6-i-j-k]\\n\\t\\t\\t\\tif h < 24 && m < 60 {\\n\\t\\t\\t\\t\\treturn fmt.Sprintf(\"%02d:%02d\", h, m)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn \"\"\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 273984,
                "title": "c-17-lines-code-i-think-no-one-write-c-shorter-then-me",
                "content": "```\\nclass Solution {\\nprivate:\\n    inline bool valid(int hour, int minute) {\\n        return (hour < 24 && hour >= 0 && minute < 60 && minute >= 0);\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        char ans[6] = \"\", buffer[6];\\n        sort(A.begin(), A.end());\\n        do {\\n            sprintf(buffer, \"%d%d:%d%d\", A[0], A[1], A[2], A[3]);\\n            if (valid(A[0]*10+A[1], A[2]*10+A[3]) && strcmp(ans, buffer) < 0)  // actually, it\\'s needn\\'t to compare ans with buffer\\n                strcpy(ans, buffer);\\n        } while (next_permutation(A.begin(), A.end()));\\n        return string(ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    inline bool valid(int hour, int minute) {\\n        return (hour < 24 && hour >= 0 && minute < 60 && minute >= 0);\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        char ans[6] = \"\", buffer[6];\\n        sort(A.begin(), A.end());\\n        do {\\n            sprintf(buffer, \"%d%d:%d%d\", A[0], A[1], A[2], A[3]);\\n            if (valid(A[0]*10+A[1], A[2]*10+A[3]) && strcmp(ans, buffer) < 0)  // actually, it\\'s needn\\'t to compare ans with buffer\\n                strcpy(ans, buffer);\\n        } while (next_permutation(A.begin(), A.end()));\\n        return string(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246742,
                "title": "java-5ms-beats-100-sort-brute-force-stopping-on-1st-valid-time",
                "content": "Sort the array, use the brute force solution but start from largest to smallest number, so the first valid time found is the largest possible time\\n\\n```\\nclass Solution {\\n\\n    public String largestTimeFromDigits(int[] A) {       \\n        Arrays.sort(A);       \\n               \\n        String r = \"\";\\n        \\n        for(int i=3;i>=0;i--) {\\n            for(int j=3;j>=0;j--) {\\n                if(j==i) continue;\\n                for(int k=3;k>=0;k--){\\n                    if(k==j || k==i)  continue;\\n                    for(int s=3;s>=0;s--){\\n                        if(s==k||s==j||s==i) continue;\\n                        String t = time(A[i],A[j],A[k],A[s]);\\n                        if(!t.equals(\"\")) {\\n                            return t;\\n                        }                        \\n                    }\\n                }\\n            }\\n        }\\n\\n        return r;       \\n    }\\n    \\n    private String time(int a, int b, int c, int d) { \\n        if(a>2||c>5)  return \"\";\\n        if(a==2&&b>3) return \"\";\\n        \\n        StringBuilder r = new StringBuilder();\\n        \\n        r.append(a);\\n        r.append(b);\\n        r.append(\":\");\\n        r.append(c);\\n        r.append(d);\\n        \\n        return r.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public String largestTimeFromDigits(int[] A) {       \\n        Arrays.sort(A);       \\n               \\n        String r = \"\";\\n        \\n        for(int i=3;i>=0;i--) {\\n            for(int j=3;j>=0;j--) {\\n                if(j==i) continue;\\n                for(int k=3;k>=0;k--){\\n                    if(k==j || k==i)  continue;\\n                    for(int s=3;s>=0;s--){\\n                        if(s==k||s==j||s==i) continue;\\n                        String t = time(A[i],A[j],A[k],A[s]);\\n                        if(!t.equals(\"\")) {\\n                            return t;\\n                        }                        \\n                    }\\n                }\\n            }\\n        }\\n\\n        return r;       \\n    }\\n    \\n    private String time(int a, int b, int c, int d) { \\n        if(a>2||c>5)  return \"\";\\n        if(a==2&&b>3) return \"\";\\n        \\n        StringBuilder r = new StringBuilder();\\n        \\n        r.append(a);\\n        r.append(b);\\n        r.append(\":\");\\n        r.append(c);\\n        r.append(d);\\n        \\n        return r.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246468,
                "title": "use-c-next-permutation",
                "content": "C++ offers next_permutation in STL.\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<int> pos={0,1,2,3};\\n        string s=\"\";\\n        for (int i=0;i<24;++i){\\n            int hour=A[pos[0]]*10+A[pos[1]];\\n            int min=A[pos[2]]*10+A[pos[3]];\\n            if (hour>=0&&hour<=23&&min>=0&&min<=59){\\n                s=to_string(A[pos[0]])+to_string(A[pos[1]]);\\n                s+=\":\";\\n                s+=to_string(A[pos[2]])+to_string(A[pos[3]]);\\n            }\\n            next_permutation(pos.begin(),pos.end());\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<int> pos={0,1,2,3};\\n        string s=\"\";\\n        for (int i=0;i<24;++i){\\n            int hour=A[pos[0]]*10+A[pos[1]];\\n            int min=A[pos[2]]*10+A[pos[3]];\\n            if (hour>=0&&hour<=23&&min>=0&&min<=59){\\n                s=to_string(A[pos[0]])+to_string(A[pos[1]]);\\n                s+=\":\";\\n                s+=to_string(A[pos[2]])+to_string(A[pos[3]]);\\n            }\\n            next_permutation(pos.begin(),pos.end());\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240461,
                "title": "python3-100-with-easy-filter",
                "content": "\\n\\'\\'\\'\\nclass Solution:\\n    def largestTimeFromDigits(self, A: \\'List[int]\\') -> \\'str\\':\\n        A.sort()\\n        if A[0]>2 or A[1]>5:#\\u52A0\\u5165\\u7C97\\u7565\\u7B5B\\u9009\\n            return(\"\")\\n        ans=\"\"\\n        from itertools import permutations\\n        mh=-1\\n        mm=-1\\n        flag=0\\n        for s in permutations(A):\\n            h = s[0]*10+s[1]\\n            m = s[2]*10+s[3]\\n            if (mh<h<24 and m<60) or (h==mh and mm<m<60):\\n                flag=1\\n                mh=h\\n                mm=m\\n        if flag:\\n      \\n            return(\"%02d:%02d\"%(mh,mm))\\n        else:\\n            return(\"\")\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\nclass Solution:\\n    def largestTimeFromDigits(self, A: \\'List[int]\\') -> \\'str\\':\\n        A.sort()\\n        if A[0]>2 or A[1]>5:#\\u52A0\\u5165\\u7C97\\u7565\\u7B5B\\u9009\\n            return(\"\")\\n        ans=\"\"\\n        from itertools import permutations\\n        mh=-1\\n        mm=-1\\n        flag=0\\n        for s in permutations(A):\\n            h = s[0]*10+s[1]\\n            m = s[2]*10+s[3]\\n            if (mh<h<24 and m<60) or (h==mh and mm<m<60):\\n                flag=1\\n                mh=h\\n                mm=m\\n        if flag:\\n      \\n            return(\"%02d:%02d\"%(mh,mm))\\n        else:\\n            return(\"\")\\n\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 235821,
                "title": "c-very-short-prev-permutation-beats-100",
                "content": "Since we generate permutations in decreasing order, we know that first valid found is biggest, so we can stop our search.\\n```Cpp\\nstring largestTimeFromDigits(vector<int>& A) {\\n    sort(A.rbegin(),A.rend());\\n    char res[6];\\n    res[0]=\\'\\\\0\\';\\n    do {\\n        int h = A[0]*10+A[1];\\n        int m = A[2]*10+A[3];\\n        if(h<24 && m<60) {\\n            sprintf(res,\"%02d:%02d\",h,m);\\n            break; \\n        }\\n    } while(prev_permutation(A.begin(),A.end()));\\n    return string(res);\\n}\\n```",
                "solutionTags": [],
                "code": "```Cpp\\nstring largestTimeFromDigits(vector<int>& A) {\\n    sort(A.rbegin(),A.rend());\\n    char res[6];\\n    res[0]=\\'\\\\0\\';\\n    do {\\n        int h = A[0]*10+A[1];\\n        int m = A[2]*10+A[3];\\n        if(h<24 && m<60) {\\n            sprintf(res,\"%02d:%02d\",h,m);\\n            break; \\n        }\\n    } while(prev_permutation(A.begin(),A.end()));\\n    return string(res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201871,
                "title": "c-javascript-solution-implemented-next-permutation",
                "content": "C++\\n\\n```\\nbool isValid(vector<int> & A){\\n\\tif(((A[0]==0 && A[1]<=9) || (A[0]==1 && A[1]<=9) || (A[0]==2 && A[1]<=3)) && A[2]<=5 && A[3]<=9){\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n           \\n}\\n    \\nbool next_permut(vector<int> &A ){\\n\\tint i=A.size()-2;\\n\\n\\twhile(i>=0 && A[i]>=A[i+1]){\\n\\t\\ti--;\\n\\t}\\n\\tif(i<0){\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint j=A.size()-1;\\n\\twhile(A[j]<=A[i]){\\n\\t\\tj--;\\n\\t}\\n\\tA[i]^=A[j];\\n\\tA[j]^=A[i];\\n\\tA[i]^=A[j];\\n\\n\\tj=A.size()-1;\\n\\ti++;\\n\\twhile(i<j){\\n\\t\\tA[i]^=A[j];\\n\\t\\tA[j]^=A[i];\\n\\t\\tA[i]^=A[j];\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}\\n\\treturn true;\\n}\\nstring largestTimeFromDigits(vector<int>& A) {\\n\\tsort(A.begin(),A.end());\\n\\tvector<int> out;\\n\\tdo{\\n\\t\\tif(isValid(A)){\\n\\t\\t\\tout=A;\\n\\t\\t}\\n\\t}while(next_permut(A));\\n\\n\\tif(out.size()==0){\\n\\t\\treturn \"\";\\n\\t}\\n\\t return to_string(out[0])+to_string(out[1])+\":\"+to_string(out[2])+to_string(out[3]);\\n}\\n```\\n\\nJavascript\\n```\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nlet isValid=function( A){\\n    if(((A[0]===0 && A[1]<=9) || (A[0]===1 && A[1]<=9) || (A[0]===2 && A[1]<=3)) && A[2]<=5 && A[3]<=9){\\n        return true;\\n    }\\n    return false;\\n};\\n    \\nlet next_permut= function(A ){\\n    let i=A.length-2;\\n\\n    while(i>=0 && A[i]>=A[i+1]){\\n        i--;\\n    }\\n    if(i<0){\\n        return false;\\n    }\\n\\n    let j=A.length-1;\\n    while(A[j]<=A[i]){\\n        j--;\\n    }\\n    A[i]^=A[j];\\n    A[j]^=A[i];\\n    A[i]^=A[j];\\n\\n    j=A.length-1;\\n    i++;\\n    while(i<j){\\n        A[i]^=A[j];\\n        A[j]^=A[i];\\n        A[i]^=A[j];\\n        i++;\\n        j--;\\n    }\\n    return true;\\n};\\n    \\nvar largestTimeFromDigits = function(A) {\\n   A.sort((a,b)=>parseInt(a)-parseInt(b));\\n   let out=[];\\n    do{\\n        if(isValid(A)){\\n            out=A.slice();\\n        }\\n    }while(next_permut(A));\\n\\n    if(out.length==0){\\n        return \"\";\\n    }\\n    return out[0].toString()+out[1].toString()+\":\"+out[2].toString()+out[3].toString();\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nbool isValid(vector<int> & A){\\n\\tif(((A[0]==0 && A[1]<=9) || (A[0]==1 && A[1]<=9) || (A[0]==2 && A[1]<=3)) && A[2]<=5 && A[3]<=9){\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n           \\n}\\n    \\nbool next_permut(vector<int> &A ){\\n\\tint i=A.size()-2;\\n\\n\\twhile(i>=0 && A[i]>=A[i+1]){\\n\\t\\ti--;\\n\\t}\\n\\tif(i<0){\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint j=A.size()-1;\\n\\twhile(A[j]<=A[i]){\\n\\t\\tj--;\\n\\t}\\n\\tA[i]^=A[j];\\n\\tA[j]^=A[i];\\n\\tA[i]^=A[j];\\n\\n\\tj=A.size()-1;\\n\\ti++;\\n\\twhile(i<j){\\n\\t\\tA[i]^=A[j];\\n\\t\\tA[j]^=A[i];\\n\\t\\tA[i]^=A[j];\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}\\n\\treturn true;\\n}\\nstring largestTimeFromDigits(vector<int>& A) {\\n\\tsort(A.begin(),A.end());\\n\\tvector<int> out;\\n\\tdo{\\n\\t\\tif(isValid(A)){\\n\\t\\t\\tout=A;\\n\\t\\t}\\n\\t}while(next_permut(A));\\n\\n\\tif(out.size()==0){\\n\\t\\treturn \"\";\\n\\t}\\n\\t return to_string(out[0])+to_string(out[1])+\":\"+to_string(out[2])+to_string(out[3]);\\n}\\n```\n```\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nlet isValid=function( A){\\n    if(((A[0]===0 && A[1]<=9) || (A[0]===1 && A[1]<=9) || (A[0]===2 && A[1]<=3)) && A[2]<=5 && A[3]<=9){\\n        return true;\\n    }\\n    return false;\\n};\\n    \\nlet next_permut= function(A ){\\n    let i=A.length-2;\\n\\n    while(i>=0 && A[i]>=A[i+1]){\\n        i--;\\n    }\\n    if(i<0){\\n        return false;\\n    }\\n\\n    let j=A.length-1;\\n    while(A[j]<=A[i]){\\n        j--;\\n    }\\n    A[i]^=A[j];\\n    A[j]^=A[i];\\n    A[i]^=A[j];\\n\\n    j=A.length-1;\\n    i++;\\n    while(i<j){\\n        A[i]^=A[j];\\n        A[j]^=A[i];\\n        A[i]^=A[j];\\n        i++;\\n        j--;\\n    }\\n    return true;\\n};\\n    \\nvar largestTimeFromDigits = function(A) {\\n   A.sort((a,b)=>parseInt(a)-parseInt(b));\\n   let out=[];\\n    do{\\n        if(isValid(A)){\\n            out=A.slice();\\n        }\\n    }while(next_permut(A));\\n\\n    if(out.length==0){\\n        return \"\";\\n    }\\n    return out[0].toString()+out[1].toString()+\":\"+out[2].toString()+out[3].toString();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201327,
                "title": "brute-force-python-20ms-beats-100",
                "content": "```\\nimport itertools\\n\\nclass Solution(object):\\n    def largestTimeFromDigits(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: str\\n        \"\"\"\\n        \\n        perms = itertools.permutations(A)\\n        argbest = []\\n        best = -1\\n        for p in perms:\\n            h = p[0]*10+p[1]\\n            if h > 23:\\n                continue\\n            m = p[2]*10+p[3]\\n            if m > 59:\\n                continue\\n            cur = h * 100 + m\\n            if cur > best:\\n                best = cur\\n                argbest = p\\n        if best < 0:\\n            return \\'\\'\\n        return str(argbest[0]) + str(argbest[1]) + \\':\\' + str(argbest[2]) + str(argbest[3])\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nimport itertools\\n\\nclass Solution(object):\\n    def largestTimeFromDigits(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: str\\n        \"\"\"\\n        \\n        perms = itertools.permutations(A)\\n        argbest = []\\n        best = -1\\n        for p in perms:\\n            h = p[0]*10+p[1]\\n            if h > 23:\\n                continue\\n            m = p[2]*10+p[3]\\n            if m > 59:\\n                continue\\n            cur = h * 100 + m\\n            if cur > best:\\n                best = cur\\n                argbest = p\\n        if best < 0:\\n            return \\'\\'\\n        return str(argbest[0]) + str(argbest[1]) + \\':\\' + str(argbest[2]) + str(argbest[3])\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 201313,
                "title": "golang-recursive-and-iterative-solutions-suggestions-welcome",
                "content": "Recursive solution was easier to figure out first and runs all test cases in 4ms\\n\\n```\\nfunc largestTimeFromDigits(A []int) string {\\n    times := getTimePermutations(A)\\n    hr, min := -1, -1\\n    \\n    for i:=0;i<len(times);i++ {\\n        curHr, curMin := getTime(times[i])\\n        \\n        if curHr <=23 && curMin <= 59 && (curHr > hr || curHr == hr && curMin > min) {\\n            hr = curHr\\n            min = curMin\\n        }\\n    }\\n    \\n    ans := \"\"\\n    if hr == -1 {\\n        return ans\\n    }\\n    \\n    if hr < 10 {\\n        ans = \"0\"\\n    }\\n    ans += strconv.Itoa(hr) + \":\"\\n    \\n    if min < 10 {\\n        ans += \"0\"\\n    }\\n    ans += strconv.Itoa(min)\\n    return ans\\n}\\n\\nfunc getTimePermutations(A []int) [][]int {\\n    if len(A) == 1 {\\n        return [][]int{[]int{A[0]}}\\n    }\\n    \\n    ret := [][]int{}\\n    \\n    for i:=0;i<len(A);i++ {\\n        pickVal := A[i]\\n        remainder := []int{}\\n        remainder = append(remainder, A[:i]...)\\n        remainder = append(remainder, A[i+1:]...)\\n        \\n        permutations := getTimePermutations(remainder)\\n        \\n        for _,p := range permutations {\\n            newTime := []int{pickVal}\\n            newTime = append(newTime, p...)\\n            ret = append(ret, newTime)\\n        }\\n    }\\n    \\n    return ret\\n}\\n\\nfunc getTime(time []int) (hr, min int) {\\n    hr = time[0]*10 + time[1]\\n    min = time[2]*10 + time[3]\\n    return\\n}\\n```\\n\\nIterative solution runs all test cases in 0ms\\n```\\nfunc largestTimeFromDigits(A []int) string {\\n    maxHr, maxMin := -1, -1\\n    \\n    for i:=0;i<len(A);i++ {\\n        for j:=0;j<len(A);j++ {\\n            if j==i {\\n                continue\\n            }\\n            for k:=0;k<len(A);k++ {\\n                if k==j || k==i {\\n                    continue\\n                }\\n                \\n                l := 6-i-j-k // sum of indexes for an array of size 4: 0+1+2+3 = 6\\n                \\n                hr := A[i]*10 + A[j]\\n                min := A[k]*10 + A[l]\\n                \\n                if hr<=23 && min<=59 && (hr>maxHr || hr==maxHr && min>maxMin) {\\n                    maxHr = hr\\n                    maxMin = min\\n                }\\n            }\\n        }\\n    }\\n    \\n    if maxHr == -1 {\\n        return \"\"\\n    }\\n    \\n    ans := \"\"\\n    \\n    if maxHr<10 {\\n        ans = \"0\"\\n    }\\n    ans += strconv.Itoa(maxHr) + \":\"\\n    \\n    if maxMin<10 {\\n        ans += \"0\"\\n    }\\n    ans += strconv.Itoa(maxMin)\\n    \\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc largestTimeFromDigits(A []int) string {\\n    times := getTimePermutations(A)\\n    hr, min := -1, -1\\n    \\n    for i:=0;i<len(times);i++ {\\n        curHr, curMin := getTime(times[i])\\n        \\n        if curHr <=23 && curMin <= 59 && (curHr > hr || curHr == hr && curMin > min) {\\n            hr = curHr\\n            min = curMin\\n        }\\n    }\\n    \\n    ans := \"\"\\n    if hr == -1 {\\n        return ans\\n    }\\n    \\n    if hr < 10 {\\n        ans = \"0\"\\n    }\\n    ans += strconv.Itoa(hr) + \":\"\\n    \\n    if min < 10 {\\n        ans += \"0\"\\n    }\\n    ans += strconv.Itoa(min)\\n    return ans\\n}\\n\\nfunc getTimePermutations(A []int) [][]int {\\n    if len(A) == 1 {\\n        return [][]int{[]int{A[0]}}\\n    }\\n    \\n    ret := [][]int{}\\n    \\n    for i:=0;i<len(A);i++ {\\n        pickVal := A[i]\\n        remainder := []int{}\\n        remainder = append(remainder, A[:i]...)\\n        remainder = append(remainder, A[i+1:]...)\\n        \\n        permutations := getTimePermutations(remainder)\\n        \\n        for _,p := range permutations {\\n            newTime := []int{pickVal}\\n            newTime = append(newTime, p...)\\n            ret = append(ret, newTime)\\n        }\\n    }\\n    \\n    return ret\\n}\\n\\nfunc getTime(time []int) (hr, min int) {\\n    hr = time[0]*10 + time[1]\\n    min = time[2]*10 + time[3]\\n    return\\n}\\n```\n```\\nfunc largestTimeFromDigits(A []int) string {\\n    maxHr, maxMin := -1, -1\\n    \\n    for i:=0;i<len(A);i++ {\\n        for j:=0;j<len(A);j++ {\\n            if j==i {\\n                continue\\n            }\\n            for k:=0;k<len(A);k++ {\\n                if k==j || k==i {\\n                    continue\\n                }\\n                \\n                l := 6-i-j-k // sum of indexes for an array of size 4: 0+1+2+3 = 6\\n                \\n                hr := A[i]*10 + A[j]\\n                min := A[k]*10 + A[l]\\n                \\n                if hr<=23 && min<=59 && (hr>maxHr || hr==maxHr && min>maxMin) {\\n                    maxHr = hr\\n                    maxMin = min\\n                }\\n            }\\n        }\\n    }\\n    \\n    if maxHr == -1 {\\n        return \"\"\\n    }\\n    \\n    ans := \"\"\\n    \\n    if maxHr<10 {\\n        ans = \"0\"\\n    }\\n    ans += strconv.Itoa(maxHr) + \":\"\\n    \\n    if maxMin<10 {\\n        ans += \"0\"\\n    }\\n    ans += strconv.Itoa(maxMin)\\n    \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200984,
                "title": "java-super-easy-o-24-9ms-solution-beats-100",
                "content": "```\\n    int res=-1;\\n    public String largestTimeFromDigits(int[] A) {\\n        BT(A, new boolean[]{false,false,false,false}, new StringBuilder());\\n        if(res==-1) return \"\";\\n        String a=Integer.toString(res/60), b=Integer.toString(res%60);\\n        if(a.length()==1) a=\"0\"+a;\\n        if(b.length()==1) b=\"0\"+b;\\n        return a+\":\"+b;\\n    }\\n    \\n    public void BT(int[] A, boolean[] used, StringBuilder sb) {\\n        if(sb.length()==4) {\\n            int a=Integer.parseInt(sb.substring(0, 2).toString());\\n            int b=Integer.parseInt(sb.substring(2).toString());\\n            if(a>23||b>59) return;\\n            res=Math.max(res, a*60+b);\\n            return;\\n        }\\n        for(int i=0;i<4;i++) {\\n            if(!used[i]) {\\n                used[i]=true;\\n                BT(A, used, new StringBuilder(sb).append(A[i]));\\n                used[i]=false;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\n    int res=-1;\\n    public String largestTimeFromDigits(int[] A) {\\n        BT(A, new boolean[]{false,false,false,false}, new StringBuilder());\\n        if(res==-1) return \"\";\\n        String a=Integer.toString(res/60), b=Integer.toString(res%60);\\n        if(a.length()==1) a=\"0\"+a;\\n        if(b.length()==1) b=\"0\"+b;\\n        return a+\":\"+b;\\n    }\\n    \\n    public void BT(int[] A, boolean[] used, StringBuilder sb) {\\n        if(sb.length()==4) {\\n            int a=Integer.parseInt(sb.substring(0, 2).toString());\\n            int b=Integer.parseInt(sb.substring(2).toString());\\n            if(a>23||b>59) return;\\n            res=Math.max(res, a*60+b);\\n            return;\\n        }\\n        for(int i=0;i<4;i++) {\\n            if(!used[i]) {\\n                used[i]=true;\\n                BT(A, used, new StringBuilder(sb).append(A[i]));\\n                used[i]=false;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 200653,
                "title": "backtrack-permutation",
                "content": "```\\nclass Solution {\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        if (A == null || A.length == 0){\\n            return \"\";\\n        }\\n        boolean[] visited = new boolean[4];\\n        List<List<Integer>> resList = new ArrayList<>();\\n        permutation(resList, A, new ArrayList<Integer>(), visited);\\n        int max = Integer.MIN_VALUE;\\n        int index = -1;\\n        for (int i = 0; i < resList.size(); i++){\\n            List<Integer> list = resList.get(i);\\n            int num = convert(list);\\n            if (num > max){\\n                max = num;\\n                index = i;\\n            }\\n        }\\n        if (index == -1 || max == Integer.MIN_VALUE){\\n            return \"\";\\n        }\\n        List<Integer> res = resList.get(index);\\n        return res.get(0) + String.valueOf(res.get(1)) + \":\" + String.valueOf(res.get(2)) + res.get(3);\\n    }\\n    private void permutation(List<List<Integer>> res, int[] A, List<Integer> item, boolean[] visited){\\n        if (item.size() == A.length){\\n            res.add(new ArrayList<>(item));\\n            return;\\n        }\\n        for (int i = 0; i < A.length; i++){\\n            if (!visited[i]){\\n                visited[i] = true;\\n                item.add(A[i]);\\n                permutation(res, A, item, visited);\\n                visited[i] = false;\\n                item.remove(item.size() - 1);\\n            }\\n        }\\n    }\\n    private int convert(List<Integer> list){\\n        if (list.get(0) * 10 + list.get(1) < 24 && list.get(2) * 10 + list.get(3) < 60){\\n            return list.get(0) * 1000 + list.get(1) * 100 + list.get(2) * 10 + list.get(3);\\n        }\\n        return Integer.MIN_VALUE;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        if (A == null || A.length == 0){\\n            return \"\";\\n        }\\n        boolean[] visited = new boolean[4];\\n        List<List<Integer>> resList = new ArrayList<>();\\n        permutation(resList, A, new ArrayList<Integer>(), visited);\\n        int max = Integer.MIN_VALUE;\\n        int index = -1;\\n        for (int i = 0; i < resList.size(); i++){\\n            List<Integer> list = resList.get(i);\\n            int num = convert(list);\\n            if (num > max){\\n                max = num;\\n                index = i;\\n            }\\n        }\\n        if (index == -1 || max == Integer.MIN_VALUE){\\n            return \"\";\\n        }\\n        List<Integer> res = resList.get(index);\\n        return res.get(0) + String.valueOf(res.get(1)) + \":\" + String.valueOf(res.get(2)) + res.get(3);\\n    }\\n    private void permutation(List<List<Integer>> res, int[] A, List<Integer> item, boolean[] visited){\\n        if (item.size() == A.length){\\n            res.add(new ArrayList<>(item));\\n            return;\\n        }\\n        for (int i = 0; i < A.length; i++){\\n            if (!visited[i]){\\n                visited[i] = true;\\n                item.add(A[i]);\\n                permutation(res, A, item, visited);\\n                visited[i] = false;\\n                item.remove(item.size() - 1);\\n            }\\n        }\\n    }\\n    private int convert(List<Integer> list){\\n        if (list.get(0) * 10 + list.get(1) < 24 && list.get(2) * 10 + list.get(3) < 60){\\n            return list.get(0) * 1000 + list.get(1) * 100 + list.get(2) * 10 + list.get(3);\\n        }\\n        return Integer.MIN_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200649,
                "title": "java-o-24-60",
                "content": "```\\npublic String largestTimeFromDigits(int[] A) {\\n        int[] count = new int[10];\\n        for(int a : A) count[a]++;\\n        for(int i = 23; i >= 0; i--) {\\n            int a = i / 10, b = i % 10;\\n            count[a]--;\\n            count[b]--;\\n            if (count[a] >= 0 && count[b] >= 0) {\\n                for(int j = 59; j >= 0; j--) {\\n                    int p = j / 10, q = j % 10;\\n                    count[p]--;\\n                    count[q]--;\\n                    if (count[p] >= 0 && count[q] >= 0)\\n                        return a + \"\" + b + \":\" + p + \"\" + q;\\n                    count[p]++;\\n                    count[q]++;\\n                }\\n            }\\n            count[a]++;\\n            count[b]++;\\n        }\\n        return \"\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestTimeFromDigits(int[] A) {\\n        int[] count = new int[10];\\n        for(int a : A) count[a]++;\\n        for(int i = 23; i >= 0; i--) {\\n            int a = i / 10, b = i % 10;\\n            count[a]--;\\n            count[b]--;\\n            if (count[a] >= 0 && count[b] >= 0) {\\n                for(int j = 59; j >= 0; j--) {\\n                    int p = j / 10, q = j % 10;\\n                    count[p]--;\\n                    count[q]--;\\n                    if (count[p] >= 0 && count[q] >= 0)\\n                        return a + \"\" + b + \":\" + p + \"\" + q;\\n                    count[p]++;\\n                    count[q]++;\\n                }\\n            }\\n            count[a]++;\\n            count[b]++;\\n        }\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200560,
                "title": "java-permutation-solution",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        String time = \"\";\\n        String str = \"\";\\n        for (int a : A) {\\n            str += a; \\n        }\\n        \\n        List<String> list = new ArrayList<>();\\n        \\n        permutation(\"\", str, list);     \\n        \\n        for (String s : list) {\\n            s = s.substring(0, 2) + \":\" + s.substring(2);\\n            if (s.charAt(3) < \\'6\\') {\\n                if (s.charAt(0) <= \\'2\\' && s.compareTo(\"24:00\") < 0) {\\n                    time = time.compareTo(s) > 0 ? time : s;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n    \\n    \\n    private static void permutation(String prefix, String str, List<String> list) {\\n        int n = str.length();\\n        if (n == 0) list.add(prefix);\\n        else {\\n            for (int i = 0; i < n; i++)\\n            permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n), list);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        String time = \"\";\\n        String str = \"\";\\n        for (int a : A) {\\n            str += a; \\n        }\\n        \\n        List<String> list = new ArrayList<>();\\n        \\n        permutation(\"\", str, list);     \\n        \\n        for (String s : list) {\\n            s = s.substring(0, 2) + \":\" + s.substring(2);\\n            if (s.charAt(3) < \\'6\\') {\\n                if (s.charAt(0) <= \\'2\\' && s.compareTo(\"24:00\") < 0) {\\n                    time = time.compareTo(s) > 0 ? time : s;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n    \\n    \\n    private static void permutation(String prefix, String str, List<String> list) {\\n        int n = str.length();\\n        if (n == 0) list.add(prefix);\\n        else {\\n            for (int i = 0; i < n; i++)\\n            permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n), list);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200556,
                "title": "java-no-permutation-no-brute-force-warning-messy-code-ahead-6ms-10ms",
                "content": "Code messy AF.   [6ms-10ms]\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int[] freq = new int[10];\\n        for (int i=0; i<A.length; i++) freq[A[i]]++;\\n        StringBuilder sb = new StringBuilder();\\n        int[] invalidhr = new int[24];\\n        \\n        boolean nextRound = true;\\n        while (nextRound) {\\n            sb = new StringBuilder();\\n            nextRound = false;\\n            int hr = 0;\\n            int[] table = Arrays.copyOf(freq, freq.length);\\n             for (int i=23; i>=0; i--) {\\n                int a = i/10 % 10;\\n                int b = i % 10;\\n                if ( ((a == b && table[a]>1) || (a!=b && table[a]>0 && table[b]>0)) && invalidhr[i]!=1) {  \\n                        sb.append(\"\" + a + \"\" + b);\\n                        table[a]--;\\n                        table[b]--;\\n                        hr = i;\\n                        break;\\n                }\\n            }\\n            if (sb.length()<2) return \"\";\\n            sb.append(\":\");\\n\\n            for (int i=59; i>=0; i--) {\\n                int a = i/10 % 10;\\n                int b = i % 10;\\n                if ( ((a == b && table[a]>1) || (a!=b && table[a]>0 && table[b]>0)) ) {  \\n                        sb.append(\"\" + a + \"\" + b);\\n                        table[a]--;\\n                        table[b]--;\\n                        break;\\n                }\\n            }\\n\\n            if (sb.length()<5) { \\n                nextRound = true;\\n                invalidhr[hr] = 1;\\n                // we need to find the next one.\\n            }\\n            if (!nextRound) break;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int[] freq = new int[10];\\n        for (int i=0; i<A.length; i++) freq[A[i]]++;\\n        StringBuilder sb = new StringBuilder();\\n        int[] invalidhr = new int[24];\\n        \\n        boolean nextRound = true;\\n        while (nextRound) {\\n            sb = new StringBuilder();\\n            nextRound = false;\\n            int hr = 0;\\n            int[] table = Arrays.copyOf(freq, freq.length);\\n             for (int i=23; i>=0; i--) {\\n                int a = i/10 % 10;\\n                int b = i % 10;\\n                if ( ((a == b && table[a]>1) || (a!=b && table[a]>0 && table[b]>0)) && invalidhr[i]!=1) {  \\n                        sb.append(\"\" + a + \"\" + b);\\n                        table[a]--;\\n                        table[b]--;\\n                        hr = i;\\n                        break;\\n                }\\n            }\\n            if (sb.length()<2) return \"\";\\n            sb.append(\":\");\\n\\n            for (int i=59; i>=0; i--) {\\n                int a = i/10 % 10;\\n                int b = i % 10;\\n                if ( ((a == b && table[a]>1) || (a!=b && table[a]>0 && table[b]>0)) ) {  \\n                        sb.append(\"\" + a + \"\" + b);\\n                        table[a]--;\\n                        table[b]--;\\n                        break;\\n                }\\n            }\\n\\n            if (sb.length()<5) { \\n                nextRound = true;\\n                invalidhr[hr] = 1;\\n                // we need to find the next one.\\n            }\\n            if (!nextRound) break;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200530,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    String time;\\n    int[] max = {2, 3, 5, 9};\\n    public String largestTimeFromDigits(int[] A) {\\n        \\n        int[] cur = new int[4];\\n        Arrays.fill(cur, -1);\\n        \\n        findLargest(A, new boolean[4], cur, 0);\\n        return time == null ? \"\" : time;\\n    }\\n    \\n    private void findLargest(int[] A, boolean[] used, int[] cur, int pos) {\\n        if (pos == 4) {\\n            String s = \"\" + cur[0] + cur[1] + \":\" + cur[2] + cur[3];\\n            if (time == null || time.compareTo(s) < 0) {\\n                time = s;\\n            }\\n            return;\\n        }\\n        if (pos == 1) {\\n            if (cur[0] == 1 || cur[0] == 0){\\n                max[1] = 9;\\n            } else if (cur[0] == 2) {\\n                max[1] = 3;\\n            }\\n        }\\n        for (int j = 0; j < 4; j++) {\\n            if (used[j] || A[j] > max[pos]) continue;\\n            cur[pos] = A[j];\\n            used[j]  = true;\\n            findLargest(A, used, cur, pos + 1);\\n            cur[pos] = -1;\\n            used[j] = false;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    String time;\\n    int[] max = {2, 3, 5, 9}",
                "codeTag": "Java"
            },
            {
                "id": 200495,
                "title": "python-straightforward-permutation",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        h = m = -float(\"inf\")\\n        for n1, n2, n3, n4 in itertools.permutations(A):\\n            hh, mm = n1 * 10 + n2, n3 * 10 + n4\\n            if 0 <= hh <= 23 and 0 <= mm <= 59 and (hh > h or hh == h and mm > m):\\n                h, m = hh, mm\\n        sh = str(h) if h > 9 else \"0\" + str(h)\\n        sm = str(m) if m > 9 else \"0\" + str(m)\\n        return 0 <= h <= 23 and 0 <= m <= 59 and sh + \":\" + sm or \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        h = m = -float(\"inf\")\\n        for n1, n2, n3, n4 in itertools.permutations(A):\\n            hh, mm = n1 * 10 + n2, n3 * 10 + n4\\n            if 0 <= hh <= 23 and 0 <= mm <= 59 and (hh > h or hh == h and mm > m):\\n                h, m = hh, mm\\n        sh = str(h) if h > 9 else \"0\" + str(h)\\n        sm = str(m) if m > 9 else \"0\" + str(m)\\n        return 0 <= h <= 23 and 0 <= m <= 59 and sh + \":\" + sm or \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099326,
                "title": "brute-forcce",
                "content": "```class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        vector<string> time;\\n        // string seconds=\"####\";\\n        for(int i=0;i<4;i++){\\n            string seconds=\"####\";\\n            string h1=to_string(arr[i]);\\n            seconds[i]=\\'$\\';\\n            for(int j=i+1;j<4;j++){\\n                string h2=to_string(arr[j]);\\n                seconds[j]=\\'$\\';\\n                \\n                string hr1=h1+h2;\\n                string hr2=h2+h1;\\n                \\n                string s1=\"-1\";\\n                string s2=\"-1\";\\n                for(int k=0;k<4;k++){\\n                    if(seconds[k]==\\'#\\'){\\n                        if(s1==\"-1\") s1=to_string(arr[k]);\\n                        else s2=to_string(arr[k]);\\n                    }\\n                }\\n                string sec1=s1+s2;\\n                string sec2=s2+s1;\\n                if(stoi(sec1)<60){\\n                    if(stoi(hr1)<24){\\n                        time.push_back(hr1+sec1);\\n                    }\\n                    if(stoi(hr2)<24){\\n                        time.push_back(hr2+sec1);\\n                    }\\n                }\\n                if(stoi(sec2)<60){\\n                    if(stoi(hr1)<24){\\n                        time.push_back(hr1+sec2);\\n                    }\\n                    if(stoi(hr2)<24){\\n                        time.push_back(hr2+sec2);\\n                    }\\n                }\\n                seconds[j]=\\'#\\';\\n                    \\n            }\\n        }\\n        sort(time.begin(),time.end());\\n        // for(auto x:time) cout<<x<<\" \";\\n        string res;\\n        if(time.size()>0)\\n        {\\n            string ans=time.back();\\n            cout<<ans;\\n            int cnt=0;\\n            for(auto c:ans){\\n                res+=c;\\n                cnt++;\\n                if(cnt==2) res+=\\':\\';\\n            }\\n        }\\n        return res;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        vector<string> time;\\n        // string seconds=\"####\";\\n        for(int i=0;i<4;i++){\\n            string seconds=\"####\";\\n            string h1=to_string(arr[i]);\\n            seconds[i]=\\'$\\';\\n            for(int j=i+1;j<4;j++){\\n                string h2=to_string(arr[j]);\\n                seconds[j]=\\'$\\';\\n                \\n                string hr1=h1+h2;\\n                string hr2=h2+h1;\\n                \\n                string s1=\"-1\";\\n                string s2=\"-1\";\\n                for(int k=0;k<4;k++){\\n                    if(seconds[k]==\\'#\\'){\\n                        if(s1==\"-1\") s1=to_string(arr[k]);\\n                        else s2=to_string(arr[k]);\\n                    }\\n                }\\n                string sec1=s1+s2;\\n                string sec2=s2+s1;\\n                if(stoi(sec1)<60){\\n                    if(stoi(hr1)<24){\\n                        time.push_back(hr1+sec1);\\n                    }\\n                    if(stoi(hr2)<24){\\n                        time.push_back(hr2+sec1);\\n                    }\\n                }\\n                if(stoi(sec2)<60){\\n                    if(stoi(hr1)<24){\\n                        time.push_back(hr1+sec2);\\n                    }\\n                    if(stoi(hr2)<24){\\n                        time.push_back(hr2+sec2);\\n                    }\\n                }\\n                seconds[j]=\\'#\\';\\n                    \\n            }\\n        }\\n        sort(time.begin(),time.end());\\n        // for(auto x:time) cout<<x<<\" \";\\n        string res;\\n        if(time.size()>0)\\n        {\\n            string ans=time.back();\\n            cout<<ans;\\n            int cnt=0;\\n            for(auto c:ans){\\n                res+=c;\\n                cnt++;\\n                if(cnt==2) res+=\\':\\';\\n            }\\n        }\\n        return res;\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 4062057,
                "title": "43ms-handles-difficult-edge-case-o-n-log-n-time",
                "content": "This question is definitely do-able in 30 minutes or less if you have not encountered it before just really try your best to beat out the edge case early. I was able to solve this problem in 29 minutes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n# @param {Integer[]} arr\\n# @return {String}\\ndef largest_time_from_digits(arr)\\n    # Used to detect edge case where we have a 2 val and 2 vals larger\\n    # than 5 in array.\\n    digits_over_5 = 0\\n    arr.sort!{|a, b| b<=>a}\\n    nums_hash = {}\\n    arr.each do |n|\\n        if !nums_hash[n]\\n            nums_hash[n] = 0\\n        end\\n\\n        nums_hash[n] = nums_hash[n] + 1\\n        if n > 5\\n            digits_over_5 = digits_over_5 + 1\\n        end\\n    end\\n\\n    # If we have 2 val and 2 vals larger\\n    # than 5 in array the first digit cannot be a 2 \\n    # or else we invalidate the time.\\n    answer = \"\"\\n    if digits_over_5 > 1 and nums_hash[2]\\n        if nums_hash[1]\\n            answer = \"1\"\\n            nums_hash[1] = nums_hash[1] - 1\\n            if nums_hash[1] == 0\\n                nums_hash.delete 1\\n            end\\n        elsif nums_hash[0]\\n            answer = \"0\"\\n            nums_hash[0] = nums_hash[0] - 1\\n            if nums_hash[0] == 0\\n                nums_hash.delete 0\\n            end\\n        else\\n            return \"\"\\n        end\\n\\n        limiting_factors = [10, 6]\\n\\n    # In the situation where we do hit our edge case of 2 val + 2x vals larger than 5\\n    # we use our simple limiting factors array to put together our string.\\n    else\\n        limiting_factors = [3, \"x\", 6]\\n    end\\n\\n    \\n    limiting_factors.each do |limiting_factor|\\n        if limiting_factor == \"x\"\\n            if answer[0]\\n                if answer[0] == \"2\"\\n                    limiting_factor = 4\\n                else\\n                    limiting_factor = 10\\n                end\\n            else\\n                return \"\"\\n            end\\n        end\\n\\n        nums_hash.keys.each do |n|\\n            if n < limiting_factor\\n                answer = answer + n.to_s\\n                nums_hash[n] = nums_hash[n] - 1\\n                if nums_hash[n] == 0\\n                    nums_hash.delete n\\n                end\\n                break\\n            end\\n        end\\n    end\\n\\n    if answer.size < 3\\n        return \"\"\\n    else\\n        return answer[0] + answer[1] + \":\" + answer[2] + nums_hash.keys[0].to_s\\n    end\\nend\\n\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} arr\\n# @return {String}\\ndef largest_time_from_digits(arr)\\n    # Used to detect edge case where we have a 2 val and 2 vals larger\\n    # than 5 in array.\\n    digits_over_5 = 0\\n    arr.sort!{|a, b| b<=>a}\\n    nums_hash = {}\\n    arr.each do |n|\\n        if !nums_hash[n]\\n            nums_hash[n] = 0\\n        end\\n\\n        nums_hash[n] = nums_hash[n] + 1\\n        if n > 5\\n            digits_over_5 = digits_over_5 + 1\\n        end\\n    end\\n\\n    # If we have 2 val and 2 vals larger\\n    # than 5 in array the first digit cannot be a 2 \\n    # or else we invalidate the time.\\n    answer = \"\"\\n    if digits_over_5 > 1 and nums_hash[2]\\n        if nums_hash[1]\\n            answer = \"1\"\\n            nums_hash[1] = nums_hash[1] - 1\\n            if nums_hash[1] == 0\\n                nums_hash.delete 1\\n            end\\n        elsif nums_hash[0]\\n            answer = \"0\"\\n            nums_hash[0] = nums_hash[0] - 1\\n            if nums_hash[0] == 0\\n                nums_hash.delete 0\\n            end\\n        else\\n            return \"\"\\n        end\\n\\n        limiting_factors = [10, 6]\\n\\n    # In the situation where we do hit our edge case of 2 val + 2x vals larger than 5\\n    # we use our simple limiting factors array to put together our string.\\n    else\\n        limiting_factors = [3, \"x\", 6]\\n    end\\n\\n    \\n    limiting_factors.each do |limiting_factor|\\n        if limiting_factor == \"x\"\\n            if answer[0]\\n                if answer[0] == \"2\"\\n                    limiting_factor = 4\\n                else\\n                    limiting_factor = 10\\n                end\\n            else\\n                return \"\"\\n            end\\n        end\\n\\n        nums_hash.keys.each do |n|\\n            if n < limiting_factor\\n                answer = answer + n.to_s\\n                nums_hash[n] = nums_hash[n] - 1\\n                if nums_hash[n] == 0\\n                    nums_hash.delete n\\n                end\\n                break\\n            end\\n        end\\n    end\\n\\n    if answer.size < 3\\n        return \"\"\\n    else\\n        return answer[0] + answer[1] + \":\" + answer[2] + nums_hash.keys[0].to_s\\n    end\\nend\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3978551,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n private:\\n  using time_t = tuple<int, int, int, int>;\\n  static constexpr int n = 4;\\n  static constexpr int base = 10;\\n  static constexpr int min_hour = 0;\\n  static constexpr int max_hour = 23;\\n  static constexpr int min_minute = 0;\\n  static constexpr int max_minute = 59;\\n  static constexpr int minutes_per_hour = 60;\\n  static constexpr int invalid_component = -1;\\n  static constexpr char separator = \\':\\';\\n  static constexpr char zero = \\'0\\';\\n  \\n public:\\n  string largestTimeFromDigits(vector<int> &arr) {\\n    time_t largest_time{invalid_component, invalid_component, invalid_component, invalid_component};\\n    sort(arr.begin(), arr.end());\\n    do {\\n      time_t time{arr[0], arr[1], arr[2], arr[3]};\\n      if (!is_valid(time)) {\\n        continue;\\n      }\\n      \\n      if (is_empty(largest_time) || is_greater(time, largest_time)) {\\n        largest_time = move(time);\\n      }\\n    } while (next_permutation(arr.begin(), arr.end()));\\n    return is_empty(largest_time) ? string{} : to_string(largest_time);\\n  }\\n  \\n private:\\n  bool is_empty(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    return h1 == invalid_component && h2 == invalid_component && m1 == invalid_component && m2 == invalid_component;\\n  }\\n  \\n  pair<int, int> get_hour_and_minute(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    const int h = h1 * base + h2;\\n    const int m = m1 * base + m2;\\n    return make_pair(h, m);\\n  }\\n  \\n  bool is_valid(const time_t &time) {\\n    const auto [h, m] = get_hour_and_minute(time);\\n    return min_hour <= h && h <= max_hour && min_minute <= m && m <= max_minute;\\n  }\\n  \\n  int to_minute(const time_t &time) {\\n    const auto [h, m] = get_hour_and_minute(time);\\n    return h * minutes_per_hour + m;\\n  }\\n  \\n  bool is_greater(const time_t &lhs, const time_t &rhs) {\\n    return to_minute(lhs) > to_minute(rhs);\\n  }\\n  \\n  string to_string(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    string ret;\\n    ret.append(1, zero + h1).append(1, zero + h2).append(1, separator).append(1, zero + m1).append(1, zero + m2);\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n private:\\n  using time_t = tuple<int, int, int, int>;\\n  static constexpr int n = 4;\\n  static constexpr int base = 10;\\n  static constexpr int min_hour = 0;\\n  static constexpr int max_hour = 23;\\n  static constexpr int min_minute = 0;\\n  static constexpr int max_minute = 59;\\n  static constexpr int minutes_per_hour = 60;\\n  static constexpr int invalid_component = -1;\\n  static constexpr char separator = \\':\\';\\n  static constexpr char zero = \\'0\\';\\n  \\n public:\\n  string largestTimeFromDigits(vector<int> &arr) {\\n    time_t largest_time{invalid_component, invalid_component, invalid_component, invalid_component};\\n    sort(arr.begin(), arr.end());\\n    do {\\n      time_t time{arr[0], arr[1], arr[2], arr[3]};\\n      if (!is_valid(time)) {\\n        continue;\\n      }\\n      \\n      if (is_empty(largest_time) || is_greater(time, largest_time)) {\\n        largest_time = move(time);\\n      }\\n    } while (next_permutation(arr.begin(), arr.end()));\\n    return is_empty(largest_time) ? string{} : to_string(largest_time);\\n  }\\n  \\n private:\\n  bool is_empty(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    return h1 == invalid_component && h2 == invalid_component && m1 == invalid_component && m2 == invalid_component;\\n  }\\n  \\n  pair<int, int> get_hour_and_minute(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    const int h = h1 * base + h2;\\n    const int m = m1 * base + m2;\\n    return make_pair(h, m);\\n  }\\n  \\n  bool is_valid(const time_t &time) {\\n    const auto [h, m] = get_hour_and_minute(time);\\n    return min_hour <= h && h <= max_hour && min_minute <= m && m <= max_minute;\\n  }\\n  \\n  int to_minute(const time_t &time) {\\n    const auto [h, m] = get_hour_and_minute(time);\\n    return h * minutes_per_hour + m;\\n  }\\n  \\n  bool is_greater(const time_t &lhs, const time_t &rhs) {\\n    return to_minute(lhs) > to_minute(rhs);\\n  }\\n  \\n  string to_string(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    string ret;\\n    ret.append(1, zero + h1).append(1, zero + h2).append(1, separator).append(1, zero + m1).append(1, zero + m2);\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973855,
                "title": "solution-with-itertools-permutations-method",
                "content": "# Complexity\\n- Time complexity: `O(1)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSee coments for explanation ^\\n\\n# Code\\n```\\n# Clarification:\\n\\n# Test cases:\\n\\n# Notes:\\n# earliest 00:00 and latest 23:59\\n# hh < 24 and mm < 60\\n\\n# Plan:\\n# sort the input array in reverse order, because we want to give the greatest valid number from left to right.\\n# Get permutations with reversed sorted array and check if it\\'s valid. The permutations will go from greatest to smallest, and so if valid, it will return the greatest valid hour.\\n# Otherwise, if invalid, returns empty string.\\n\\n# Time: O(1)\\n# Our string consists of four digits and we are given 4 digits in the input arr. For the first place we have N options, for the second we have N - 1, and so on, which is equivalent to N!.\\n# However, since we know that our input array will always be 4:\\n# Permutations = 4!\\n# Sorting = 4 log (4)\\n# Both of this result in O(1)\\n\\n# Space: O(1)\\n# because list with permutations will contain 4! = O(1) space.\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        lst = list(permutations(sorted(arr, reverse = True)))\\n\\n        for h1, h2, m1, m2 in lst:\\n            if h1 * 10 + h2 < 24 and m1 * 10 + m2 < 60:\\n                return f\"{h1}{h2}:{m1}{m2}\"\\n        \\n        return \"\"\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Clarification:\\n\\n# Test cases:\\n\\n# Notes:\\n# earliest 00:00 and latest 23:59\\n# hh < 24 and mm < 60\\n\\n# Plan:\\n# sort the input array in reverse order, because we want to give the greatest valid number from left to right.\\n# Get permutations with reversed sorted array and check if it\\'s valid. The permutations will go from greatest to smallest, and so if valid, it will return the greatest valid hour.\\n# Otherwise, if invalid, returns empty string.\\n\\n# Time: O(1)\\n# Our string consists of four digits and we are given 4 digits in the input arr. For the first place we have N options, for the second we have N - 1, and so on, which is equivalent to N!.\\n# However, since we know that our input array will always be 4:\\n# Permutations = 4!\\n# Sorting = 4 log (4)\\n# Both of this result in O(1)\\n\\n# Space: O(1)\\n# because list with permutations will contain 4! = O(1) space.\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        lst = list(permutations(sorted(arr, reverse = True)))\\n\\n        for h1, h2, m1, m2 in lst:\\n            if h1 * 10 + h2 < 24 and m1 * 10 + m2 < 60:\\n                return f\"{h1}{h2}:{m1}{m2}\"\\n        \\n        return \"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973305,
                "title": "javascript-recursion",
                "content": "# Code\\n```\\nvar largestTimeFromDigits = function(arr) {\\n    let max = -1;\\n\\n    const go = (str, a) => {\\n        if (str.length === 2 && +str > 23) return; // hours need to be 23 or lower\\n        if (+str > 2359) return; // too big\\n        if (str.length === 4) {\\n            // minutes portion needs to be below 60 \\n            if (+str.substr(2) < 60) max = Math.max(max, +str);\\n            return;\\n        }\\n        for (let i = 0; i < a.length; i++) {\\n            go(str + a[i].toString(), a.slice(0, i).concat(a.slice(i + 1)))\\n        }\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        // time can only start with 0, 1, or 2\\n        if (arr[i] < 3) go(arr[i].toString(), arr.slice(0, i).concat(arr.slice(i + 1)));\\n    }\\n    \\n    // format as hours:minutes, pad with zeroes if needed\\n    let fmt = (num) => {\\n        let str = (\\'0000\\' + num).slice(-4);\\n        return str.substr(0, 2) + \\':\\' + str.substr(2);\\n    }\\n\\n    return max === -1 ? \\'\\' : fmt(max);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestTimeFromDigits = function(arr) {\\n    let max = -1;\\n\\n    const go = (str, a) => {\\n        if (str.length === 2 && +str > 23) return; // hours need to be 23 or lower\\n        if (+str > 2359) return; // too big\\n        if (str.length === 4) {\\n            // minutes portion needs to be below 60 \\n            if (+str.substr(2) < 60) max = Math.max(max, +str);\\n            return;\\n        }\\n        for (let i = 0; i < a.length; i++) {\\n            go(str + a[i].toString(), a.slice(0, i).concat(a.slice(i + 1)))\\n        }\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        // time can only start with 0, 1, or 2\\n        if (arr[i] < 3) go(arr[i].toString(), arr.slice(0, i).concat(arr.slice(i + 1)));\\n    }\\n    \\n    // format as hours:minutes, pad with zeroes if needed\\n    let fmt = (num) => {\\n        let str = (\\'0000\\' + num).slice(-4);\\n        return str.substr(0, 2) + \\':\\' + str.substr(2);\\n    }\\n\\n    return max === -1 ? \\'\\' : fmt(max);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3965020,
                "title": "python3-solution-using-itertools-permutations",
                "content": "# Code\\n```\\nfrom itertools import permutations \\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        time=[]\\n        for i in permutations(arr):\\n            if str(i[0])+str(i[1])<\"24\" and str(i[2])+str(i[3])<\"60\":\\n                time.append(str(i[0])+str(i[1])+\":\"+str(i[2])+str(i[3]))\\n                \\n        return max(time) if time else \"\"\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations \\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        time=[]\\n        for i in permutations(arr):\\n            if str(i[0])+str(i[1])<\"24\" and str(i[2])+str(i[3])<\"60\":\\n                time.append(str(i[0])+str(i[1])+\":\"+str(i[2])+str(i[3]))\\n                \\n        return max(time) if time else \"\"\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953733,
                "title": "c-permutations",
                "content": "```\\nclass Solution {\\n    bool isValidTime(const vector<int> &perm) {\\n        const int t = perm[0] * 1000 + perm[1] * 100 + perm[2] * 10 + perm[3];\\n        const int hh = t / 100;\\n        if(hh < 0 || hh > 23)\\n            return false;\\n        const int mm = t % 100;\\n        return mm >= 0 && mm <= 59;\\n    }\\n    string makeTime(const vector<int> &perm) {\\n        string ret(5, \\' \\');\\n        ret[0] = perm[0] + \\'0\\';\\n        ret[1] = perm[1] + \\'0\\';\\n        ret[2] = \\':\\';\\n        ret[3] = perm[2] + \\'0\\';\\n        ret[4] = perm[3] + \\'0\\';\\n        return ret;\\n    }\\n    void check_perm_rec(vector<int>& arr, int i, int N, string &t) {\\n        if(i == N) {\\n            if(isValidTime(arr)) {\\n                t = max(t, makeTime(arr));\\n            }\\n            return;\\n        }\\n        for(int j = i; j < N; ++j) {\\n            swap(arr[i], arr[j]);\\n            check_perm_rec(arr, i + 1, N, t);\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n    void check(vector<int> &arr, string &t) {\\n        check_perm_rec(arr, 0, arr.size(), t);\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string t;\\n        check(arr, t);\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isValidTime(const vector<int> &perm) {\\n        const int t = perm[0] * 1000 + perm[1] * 100 + perm[2] * 10 + perm[3];\\n        const int hh = t / 100;\\n        if(hh < 0 || hh > 23)\\n            return false;\\n        const int mm = t % 100;\\n        return mm >= 0 && mm <= 59;\\n    }\\n    string makeTime(const vector<int> &perm) {\\n        string ret(5, \\' \\');\\n        ret[0] = perm[0] + \\'0\\';\\n        ret[1] = perm[1] + \\'0\\';\\n        ret[2] = \\':\\';\\n        ret[3] = perm[2] + \\'0\\';\\n        ret[4] = perm[3] + \\'0\\';\\n        return ret;\\n    }\\n    void check_perm_rec(vector<int>& arr, int i, int N, string &t) {\\n        if(i == N) {\\n            if(isValidTime(arr)) {\\n                t = max(t, makeTime(arr));\\n            }\\n            return;\\n        }\\n        for(int j = i; j < N; ++j) {\\n            swap(arr[i], arr[j]);\\n            check_perm_rec(arr, i + 1, N, t);\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n    void check(vector<int> &arr, string &t) {\\n        check_perm_rec(arr, 0, arr.size(), t);\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string t;\\n        check(arr, t);\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941043,
                "title": "simple-c-solution-using-backtracking-and-permutation-beats-100-of-user-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinding all the permutation of the string that can make a valid time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDiskard the time that is not in the range of the 24 hr and 60min.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid permute(vector<int>&a, int l, int r,int &ans)\\n{\\n    if (l == r)\\n        {\\n            int hr=10*a[0]+a[1];\\n            int min=10*a[2]+a[3];\\n            if(hr<24 and min<60)\\n            {\\n                ans=max(ans,hr*60+min);\\n            }\\n        }\\n        for (int i = l; i <= r; i++) {\\n            swap(a[l], a[i]);\\n            permute(a, l + 1, r,ans);\\n            swap(a[l], a[i]);\\n        }\\n    }\\n\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=-1;\\n        permute(arr,0,n-1,ans);\\n        if(ans<0)return \"\";\\n        int hr=ans/60,min=ans%60;\\n        return to_string(hr/10)+to_string(hr%10)+\":\"+to_string(min/10)+to_string(min%10);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid permute(vector<int>&a, int l, int r,int &ans)\\n{\\n    if (l == r)\\n        {\\n            int hr=10*a[0]+a[1];\\n            int min=10*a[2]+a[3];\\n            if(hr<24 and min<60)\\n            {\\n                ans=max(ans,hr*60+min);\\n            }\\n        }\\n        for (int i = l; i <= r; i++) {\\n            swap(a[l], a[i]);\\n            permute(a, l + 1, r,ans);\\n            swap(a[l], a[i]);\\n        }\\n    }\\n\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=-1;\\n        permute(arr,0,n-1,ans);\\n        if(ans<0)return \"\";\\n        int hr=ans/60,min=ans%60;\\n        return to_string(hr/10)+to_string(hr%10)+\":\"+to_string(min/10)+to_string(min%10);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936462,
                "title": "typescript-there-2-possibility-2-0-3-0-5-0-9-and-0-1-0-9-0-5-0-9-no-permutations",
                "content": "# Intuition\\nThere 2 possible \"independent\" formats that we need to check\\n[2][0-3]:[0-5][0-9] and [0-1][0-9]:[0-5][0-9]. We need to check both because one of them might not work while another provides solution. And we can not be sure that one of them is bigger because we impose [0-3] second hour digit limit even in cases when first hour is in range [0-1]. There were 2 options either for 1 format create dependency so if we have first hour digit [0-1] don\\'t impose [0-3] limit on 2nd hour digit or just calculate 2 formats independently and compare them. I chose 2nd option as I think it\\'s easier to understand. \\n*Side node: permutations feel for me as a brute force solution. I don\\'t understand why we need to try all possible options when it\\'s not necessary.*\\n# Approach\\n1. Calculate 2 variants for 2 possible formats [2][0-3]:[0-5][0-9] and [0-1][0-9]:[0-5][0-9] choosing maximum digit for each position\\n2. If both formats work choose winner by comparing them in minutes, if only one works choose it.\\n3. Format the winner.\\n\\n# Complexity\\n- Time complexity:\\nFor each digit we select max from the rest it\\'s $$O(n)$$ so in total  $$O(n^2)$$, ignoring the fact that we do it 2 times. Comparing digits is also $$O(n)$$. Considering $$n == 4$$ of cause in practive it\\'s $$O(1)$$\\n\\n- Space complexity:\\n`leftDigits` gives us $$O(n)$$\\n\\n# Code\\n```\\nfunction largestTimeFromDigits(arr: number[]): string {\\n    function getTimeDigits(limits: number[]): number[] | undefined {\\n        let leftDigits = Array.from(arr)\\n        let resultDigits = []\\n        // select max digit for each position according limit variant\\n        for (let currentDigitLimit of limits) {\\n            let currentDigitCandidates = leftDigits.filter(x =>\\n                x <= currentDigitLimit && x >= 0\\n            )\\n            if (currentDigitCandidates.length === 0) {\\n                return undefined\\n            }\\n\\n            let currentDigit = Math.max(...currentDigitCandidates)\\n            resultDigits.push(currentDigit)\\n            let currentDigitIndex = leftDigits.indexOf(currentDigit)\\n            // exlude used digit to not use it twice\\n            leftDigits = leftDigits.filter((_, ind) => ind !== currentDigitIndex)\\n        }\\n        return resultDigits\\n    }\\n\\n    // 2 independent possible digits limits, if we try them both and compare we will get the winner\\n    let limitsVariantA = [2, 3, 5, 9]\\n    let limitsVariantB = [1, 9, 5, 9]\\n\\n    let variantA = getTimeDigits(limitsVariantA)\\n    let variantB = getTimeDigits(limitsVariantB)\\n\\n    let toMinutes = (digits: number[]) =>\\n        (digits[0] * 10 + digits[1]) * 60 + // hourse to minutes\\n        (digits[2] * 10 + digits[3])    // plus minutes\\n\\n    let winner = variantA || variantB; // any valid variant by default\\n\\n    if (variantA && variantB) {\\n        // if we have both valid variants we need to compare them\\n        winner = toMinutes(variantA) > toMinutes(variantB) ? variantA : variantB\\n    }\\n\\n    let format = (digits: number[] | undefined) =>\\n        digits ? `${digits[0]}${digits[1]}:${digits[2]}${digits[3]}` : \"\"\\n\\n    return format(winner)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction largestTimeFromDigits(arr: number[]): string {\\n    function getTimeDigits(limits: number[]): number[] | undefined {\\n        let leftDigits = Array.from(arr)\\n        let resultDigits = []\\n        // select max digit for each position according limit variant\\n        for (let currentDigitLimit of limits) {\\n            let currentDigitCandidates = leftDigits.filter(x =>\\n                x <= currentDigitLimit && x >= 0\\n            )\\n            if (currentDigitCandidates.length === 0) {\\n                return undefined\\n            }\\n\\n            let currentDigit = Math.max(...currentDigitCandidates)\\n            resultDigits.push(currentDigit)\\n            let currentDigitIndex = leftDigits.indexOf(currentDigit)\\n            // exlude used digit to not use it twice\\n            leftDigits = leftDigits.filter((_, ind) => ind !== currentDigitIndex)\\n        }\\n        return resultDigits\\n    }\\n\\n    // 2 independent possible digits limits, if we try them both and compare we will get the winner\\n    let limitsVariantA = [2, 3, 5, 9]\\n    let limitsVariantB = [1, 9, 5, 9]\\n\\n    let variantA = getTimeDigits(limitsVariantA)\\n    let variantB = getTimeDigits(limitsVariantB)\\n\\n    let toMinutes = (digits: number[]) =>\\n        (digits[0] * 10 + digits[1]) * 60 + // hourse to minutes\\n        (digits[2] * 10 + digits[3])    // plus minutes\\n\\n    let winner = variantA || variantB; // any valid variant by default\\n\\n    if (variantA && variantB) {\\n        // if we have both valid variants we need to compare them\\n        winner = toMinutes(variantA) > toMinutes(variantB) ? variantA : variantB\\n    }\\n\\n    let format = (digits: number[] | undefined) =>\\n        digits ? `${digits[0]}${digits[1]}:${digits[2]}${digits[3]}` : \"\"\\n\\n    return format(winner)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3918553,
                "title": "c-solution-beats-100-in-runtime-and-90-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n\\n\\n        int hf = -1;\\n        int hs = -1;\\n        int mf = -1;\\n        int ms = -1;\\n\\n        int taken =-1;\\n        int taken2 = -1;\\n        int taken3 = -1;\\n\\n        int sixs = 0;\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(arr[x] >= 6)\\n                sixs++;\\n        }\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(sixs>1 && arr[x]==2)\\n                continue;\\n            if(arr[x]<=2)\\n            {\\n                if(hf<=arr[x])\\n                {\\n                    hf = arr[x];\\n                    taken = x;\\n                \\n                }\\n            }\\n           \\n        }\\n        \\n\\n        for(int x=0; x<arr.size();x++)\\n        {\\n           \\n            \\n            if(taken==x)\\n                continue;\\n            \\n             if(hf<2)\\n            {\\n                if(hs<=arr[x])\\n                {\\n                    hs = arr[x];\\n                    taken2 = x;\\n                }\\n            }\\n            else if(hf==2 && arr[x]<=3)\\n            {\\n                if(hs<=arr[x]){\\n                    hs = arr[x];\\n                    taken2 = x;\\n                }\\n            }\\n            \\n        }\\n\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(x==taken || x==taken2) continue;\\n\\n            if(arr[x]<6){\\n                \\n                if(mf<=arr[x]){\\n                mf = arr[x];\\n                taken3 = x;\\n                }\\n            }\\n            \\n        }\\n        \\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(taken!=x && taken2!=x && taken3!=x)\\n                ms = arr[x];\\n        }\\n     \\n        if(hf==-1 || hs ==-1 || mf ==-1 || ms == -1) return \"\";\\n        return  to_string(hf) + to_string(hs) + \\n        \\':\\' + to_string(mf) + to_string(ms);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n\\n\\n        int hf = -1;\\n        int hs = -1;\\n        int mf = -1;\\n        int ms = -1;\\n\\n        int taken =-1;\\n        int taken2 = -1;\\n        int taken3 = -1;\\n\\n        int sixs = 0;\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(arr[x] >= 6)\\n                sixs++;\\n        }\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(sixs>1 && arr[x]==2)\\n                continue;\\n            if(arr[x]<=2)\\n            {\\n                if(hf<=arr[x])\\n                {\\n                    hf = arr[x];\\n                    taken = x;\\n                \\n                }\\n            }\\n           \\n        }\\n        \\n\\n        for(int x=0; x<arr.size();x++)\\n        {\\n           \\n            \\n            if(taken==x)\\n                continue;\\n            \\n             if(hf<2)\\n            {\\n                if(hs<=arr[x])\\n                {\\n                    hs = arr[x];\\n                    taken2 = x;\\n                }\\n            }\\n            else if(hf==2 && arr[x]<=3)\\n            {\\n                if(hs<=arr[x]){\\n                    hs = arr[x];\\n                    taken2 = x;\\n                }\\n            }\\n            \\n        }\\n\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(x==taken || x==taken2) continue;\\n\\n            if(arr[x]<6){\\n                \\n                if(mf<=arr[x]){\\n                mf = arr[x];\\n                taken3 = x;\\n                }\\n            }\\n            \\n        }\\n        \\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(taken!=x && taken2!=x && taken3!=x)\\n                ms = arr[x];\\n        }\\n     \\n        if(hf==-1 || hs ==-1 || mf ==-1 || ms == -1) return \"\";\\n        return  to_string(hf) + to_string(hs) + \\n        \\':\\' + to_string(mf) + to_string(ms);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861090,
                "title": "simple-verbose-python-solution",
                "content": "\\n# Complexity\\n- Time complexity: since len(arr) is a constant the time compexity of this slution is O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        \\n        hours = []\\n        # find all posible valid hour permutations in sorted order\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                hour = arr[i] * 10 + arr[j]\\n                if hour < 24:\\n                    hours.append((hour, i, j))\\n                hour = arr[j] * 10 + arr[i] \\n                if hour < 24:\\n                    hours.append((hour, j, i))\\n        hours = sorted(hours, reverse=True)\\n\\n        # find all possible valid minute permutations that go  with the \\n        # specific hour\\n        for hour, i, j in hours:\\n            \\n            for k in range(len(arr)):\\n                for l in range(k + 1, len(arr)):\\n                    if k != i and k != j and l != i and l != j:\\n                        minute1, minute2 = None, None\\n                        min = arr[k] * 10 + arr[l]\\n                        if min < 60:\\n                            minute1 = min\\n                        \\n                        min = arr[l] * 10 + arr[k]\\n                        if min < 60:\\n                            minute2 = min\\n                            \\n                        if  minute1 == None and minute2 == None:\\n                            continue\\n                        \\n                        if minute1 == None:\\n                            max_min = minute2\\n                        \\n                        elif minute2 == None:\\n                            max_min = minute1\\n                        else:\\n                            max_min = max(minute1, minute2)\\n \\n                        hour_str = f\"{hour}\" if hour > 9 else f\"0{hour}\"\\n                        min_str = f\"{max_min}\" if max_min > 9 else f\"0{max_min}\"\\n                        \\n                        return f\"{hour_str}:{min_str}\"\\n        return \"\"\\n                        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        \\n        hours = []\\n        # find all posible valid hour permutations in sorted order\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                hour = arr[i] * 10 + arr[j]\\n                if hour < 24:\\n                    hours.append((hour, i, j))\\n                hour = arr[j] * 10 + arr[i] \\n                if hour < 24:\\n                    hours.append((hour, j, i))\\n        hours = sorted(hours, reverse=True)\\n\\n        # find all possible valid minute permutations that go  with the \\n        # specific hour\\n        for hour, i, j in hours:\\n            \\n            for k in range(len(arr)):\\n                for l in range(k + 1, len(arr)):\\n                    if k != i and k != j and l != i and l != j:\\n                        minute1, minute2 = None, None\\n                        min = arr[k] * 10 + arr[l]\\n                        if min < 60:\\n                            minute1 = min\\n                        \\n                        min = arr[l] * 10 + arr[k]\\n                        if min < 60:\\n                            minute2 = min\\n                            \\n                        if  minute1 == None and minute2 == None:\\n                            continue\\n                        \\n                        if minute1 == None:\\n                            max_min = minute2\\n                        \\n                        elif minute2 == None:\\n                            max_min = minute1\\n                        else:\\n                            max_min = max(minute1, minute2)\\n \\n                        hour_str = f\"{hour}\" if hour > 9 else f\"0{hour}\"\\n                        min_str = f\"{max_min}\" if max_min > 9 else f\"0{max_min}\"\\n                        \\n                        return f\"{hour_str}:{min_str}\"\\n        return \"\"\\n                        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834863,
                "title": "steps-explained-succinct-java-solution-easy-to-understand",
                "content": "# Intuition\\nThere are two points to consider:\\n1. We already have the digits that make up the largest timestamp\\n2. We know the range of these numbers. That is the timestamp can range from 00:00 until 23:59. So the input must be a combination of these numbers\\n\\n# Approach\\n1. This is a brute force approach in which we try to get all possible combinations are match it against the input\\n2. We work our way in descending manner to get the largest match first.\\n3. We apply two for loops one for hour which begins at 23 and decrements by 1 and another inner for loop for minutes that begins at 59 and decrements by 1.\\n4. At each iteration we try to get the digits that make up that timestamp.\\n5. We do this by using division and modulus operations\\n6. Once obtained we sort this timestamp and compare against the input which is also sorted.\\n7. Return if match is found, else return \"\".\\n\\nThis is my first time posting a solution and I had a lot of help from the solutions already discussed. If you have any suggestions, corrections or inputs, they are welcome.\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        int h1=-1, h2=-1, m1=-1, m2=-1;\\n        Arrays.sort(arr);\\n        for(int h=23; h>=0; h--){\\n            for(int m=59; m>=0; m--){\\n                h1=h/10;\\n                h2=h%10;\\n                m1=m/10;\\n                m2=m%10;\\n\\n                int[] t = {h1,h2,m1,m2};\\n                Arrays.sort(t);\\n                if(Arrays.equals(arr, t)){\\n                    return h1+\"\"+h2+\":\"+m1+\"\"+m2;\\n                }\\n\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        int h1=-1, h2=-1, m1=-1, m2=-1;\\n        Arrays.sort(arr);\\n        for(int h=23; h>=0; h--){\\n            for(int m=59; m>=0; m--){\\n                h1=h/10;\\n                h2=h%10;\\n                m1=m/10;\\n                m2=m%10;\\n\\n                int[] t = {h1,h2,m1,m2};\\n                Arrays.sort(t);\\n                if(Arrays.equals(arr, t)){\\n                    return h1+\"\"+h2+\":\"+m1+\"\"+m2;\\n                }\\n\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820492,
                "title": "most-intuitive-approach",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        time = []\\n\\n        for dig in (2, 1, 0) if sum(1 for dig in arr if dig > 5) < 2 else (1, 0):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n\\n        if len(time) < 1:\\n            return \\'\\'\\n        \\n        for dig in (3, 2, 1, 0) if time[0] == 2 else range(9, -1, -1):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n\\n        if len(time) < 2:\\n            return \\'\\'\\n        \\n        for dig in range(5, -1, -1):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n        \\n        if len(time) < 3:\\n            return \\'\\'\\n        \\n        time.append(arr[0])\\n\\n        return f\\'{time[0]}{time[1]}:{time[2]}{time[3]}\\'\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        time = []\\n\\n        for dig in (2, 1, 0) if sum(1 for dig in arr if dig > 5) < 2 else (1, 0):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n\\n        if len(time) < 1:\\n            return \\'\\'\\n        \\n        for dig in (3, 2, 1, 0) if time[0] == 2 else range(9, -1, -1):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n\\n        if len(time) < 2:\\n            return \\'\\'\\n        \\n        for dig in range(5, -1, -1):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n        \\n        if len(time) < 3:\\n            return \\'\\'\\n        \\n        time.append(arr[0])\\n\\n        return f\\'{time[0]}{time[1]}:{time[2]}{time[3]}\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764677,
                "title": "recursion-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int cur, int c){\\n        if(c == 4){\\n            if(cur <= 2359 && cur % 100 < 60) {return cur;}\\n            return -1;\\n        }\\n        int ans = -1;\\n        for(int &i: nums){\\n            if(i <= 9){\\n                int tmp = i;\\n                i = 10;\\n                ans = max(ans, solve(nums, cur*10 + tmp, c + 1));\\n                i = tmp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string largestTimeFromDigits(vector<int>& nums) {\\n        int num = solve(nums, 0, 0);\\n        if(num == -1) return \"\";\\n        if(num == 0) return \"00:00\";\\n        cout << num << endl;\\n        string str = to_string(num);\\n        while(str.size() < 4) str = \"0\" + str;\\n        return str.substr(0, 2) + \":\" + str.substr(2, 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int cur, int c){\\n        if(c == 4){\\n            if(cur <= 2359 && cur % 100 < 60) {return cur;}\\n            return -1;\\n        }\\n        int ans = -1;\\n        for(int &i: nums){\\n            if(i <= 9){\\n                int tmp = i;\\n                i = 10;\\n                ans = max(ans, solve(nums, cur*10 + tmp, c + 1));\\n                i = tmp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string largestTimeFromDigits(vector<int>& nums) {\\n        int num = solve(nums, 0, 0);\\n        if(num == -1) return \"\";\\n        if(num == 0) return \"00:00\";\\n        cout << num << endl;\\n        string str = to_string(num);\\n        while(str.size() < 4) str = \"0\" + str;\\n        return str.substr(0, 2) + \":\" + str.substr(2, 2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3759784,
                "title": "c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvoid backtrack(int* hash, char *buf, int len, char *latest)\\n{\\n    if (len == 5) {\\n        if (latest[0] == 0) {\\n            strcpy(latest, buf);\\n        }\\n        else {\\n            if (latest[0] > buf[0]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[1] > buf[1]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[3] > buf[3]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[4] > buf[4]) { \\n                strcpy(latest, buf);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n    if (len == 2) {\\n        buf[len] = \\':\\';\\n        backtrack(hash, buf, len + 1, latest);\\n    }\\n    else {\\n        for (int i = 0; i < 10; i++) {\\n\\n            if (hash[i]) {\\n\\n                if (len == 0) {\\n                    if (i >= 0 && i <= 2) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n                else if (len == 1) {\\n                    if (buf[len - 1] == \\'2\\') {\\n                        if (i >= 0 && i <= 3) {\\n                            buf[len] = i + \\'0\\';\\n                            hash[i]--;\\n                            backtrack(hash, buf, len + 1, latest);\\n                            hash[i]++;\\n                        }\\n                    }\\n                    else {\\n                        if (i >= 0 && i <= 9) {\\n                            buf[len] = i + \\'0\\';\\n                            hash[i]--;\\n                            backtrack(hash, buf, len + 1, latest);\\n                            hash[i]++;\\n                        }\\n                    }\\n\\n                }\\n                else if (len == 3) {\\n                    if (i >= 0 && i <= 5) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n                else if (len == 4) {\\n                    if (i >= 0 && i <= 9) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nchar * largestTimeFromDigits(int* arr, int arrSize){\\n    int hash[10] = {0};\\n    char buf[6] = {0};\\n    char *latest = (char *)calloc(1, sizeof(char) * 6);\\n    \\n    for (int i = 0; i < arrSize; i++) {\\n        hash[arr[i]]++;\\n    }\\n    \\n    backtrack(hash, buf, 0, latest);\\n    \\n    return latest;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Backtracking",
                    "Enumeration"
                ],
                "code": "```\\nvoid backtrack(int* hash, char *buf, int len, char *latest)\\n{\\n    if (len == 5) {\\n        if (latest[0] == 0) {\\n            strcpy(latest, buf);\\n        }\\n        else {\\n            if (latest[0] > buf[0]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[1] > buf[1]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[3] > buf[3]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[4] > buf[4]) { \\n                strcpy(latest, buf);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n    if (len == 2) {\\n        buf[len] = \\':\\';\\n        backtrack(hash, buf, len + 1, latest);\\n    }\\n    else {\\n        for (int i = 0; i < 10; i++) {\\n\\n            if (hash[i]) {\\n\\n                if (len == 0) {\\n                    if (i >= 0 && i <= 2) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n                else if (len == 1) {\\n                    if (buf[len - 1] == \\'2\\') {\\n                        if (i >= 0 && i <= 3) {\\n                            buf[len] = i + \\'0\\';\\n                            hash[i]--;\\n                            backtrack(hash, buf, len + 1, latest);\\n                            hash[i]++;\\n                        }\\n                    }\\n                    else {\\n                        if (i >= 0 && i <= 9) {\\n                            buf[len] = i + \\'0\\';\\n                            hash[i]--;\\n                            backtrack(hash, buf, len + 1, latest);\\n                            hash[i]++;\\n                        }\\n                    }\\n\\n                }\\n                else if (len == 3) {\\n                    if (i >= 0 && i <= 5) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n                else if (len == 4) {\\n                    if (i >= 0 && i <= 9) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nchar * largestTimeFromDigits(int* arr, int arrSize){\\n    int hash[10] = {0};\\n    char buf[6] = {0};\\n    char *latest = (char *)calloc(1, sizeof(char) * 6);\\n    \\n    for (int i = 0; i < arrSize; i++) {\\n        hash[arr[i]]++;\\n    }\\n    \\n    backtrack(hash, buf, 0, latest);\\n    \\n    return latest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746902,
                "title": "java-forming-permutations-via-backtracking",
                "content": "```\\nclass Solution {\\n    \\n    HashSet<String> seen = new HashSet<>();\\n    \\n    public String largestTimeFromDigits(int[] arr) {\\n        \\n        calculate(arr, 0);\\n        if(seen.isEmpty())\\n            return \"\";\\n        List<String> list = new ArrayList<>();\\n        list.addAll(seen);\\n        Collections.sort(list);\\n        // System.out.println(list);\\n        \\n        int index = list.size()-1;\\n        String s = list.get(index);\\n        s = s.substring(0,2) + \":\" +  s.substring(2,4);\\n        return s;\\n    }\\n    \\n    public void calculate(int[] arr, int index) {\\n        \\n        if(index==arr.length) {\\n            if(isValid(arr)) {\\n                StringBuilder sb = new StringBuilder();\\n                for(int i=0;i<arr.length;i++) {\\n                    sb.append(arr[i]);\\n                }\\n                seen.add(sb.toString());\\n                // System.out.println(sb.toString());\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            swap(arr, index, i);\\n            calculate(arr, index+1);\\n            swap(arr, index, i);\\n        }  \\n    }\\n    \\n    public void swap(int[] arr, int i , int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n    \\n    public boolean isValid(int[] arr) {\\n        if(arr[0]>2) return false;\\n        if(arr[0]>=2 && arr[1]>=4) return false;\\n        if(arr[2]>=6) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\n    HashSet<String> seen = new HashSet<>();\\n    \\n    public String largestTimeFromDigits(int[] arr) {\\n        \\n        calculate(arr, 0);\\n        if(seen.isEmpty())\\n            return \"\";\\n        List<String> list = new ArrayList<>();\\n        list.addAll(seen);\\n        Collections.sort(list);\\n        // System.out.println(list);\\n        \\n        int index = list.size()-1;\\n        String s = list.get(index);\\n        s = s.substring(0,2) + \":\" +  s.substring(2,4);\\n        return s;\\n    }\\n    \\n    public void calculate(int[] arr, int index) {\\n        \\n        if(index==arr.length) {\\n            if(isValid(arr)) {\\n                StringBuilder sb = new StringBuilder();\\n                for(int i=0;i<arr.length;i++) {\\n                    sb.append(arr[i]);\\n                }\\n                seen.add(sb.toString());\\n                // System.out.println(sb.toString());\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            swap(arr, index, i);\\n            calculate(arr, index+1);\\n            swap(arr, index, i);\\n        }  \\n    }\\n    \\n    public void swap(int[] arr, int i , int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n    \\n    public boolean isValid(int[] arr) {\\n        if(arr[0]>2) return false;\\n        if(arr[0]>=2 && arr[1]>=4) return false;\\n        if(arr[2]>=6) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687655,
                "title": "todays-ram",
                "content": "class Solution {\\n    public:\\n        \\n        string s=\"0000\";\\n        bool is=false;\\n        \\n        void solve(int i,vector<int> &arr,string now)\\n        {\\n            if(i==4)\\n            {\\n                if(now.substr(0,2)<=\"23\" && now.substr(2,2)<=\"59\" && (s==\"0000\" || s<now))\\n                {\\n                    is=true;\\n                    s=now;\\n                    return;\\n                }\\n                return;    \\n            }\\n            \\n            for(int j=0;j<4;j++)\\n            {\\n                if(now[j]==\\' \\')\\n                {\\n                    now[j]=(\\'0\\'+arr[i]);\\n                    solve(i+1,arr,now);\\n                    now[j]=\\' \\';\\n                }\\n            }\\n        }\\n            \\n        string largestTimeFromDigits(vector<int>& arr) \\n        {\\n            string now=\"    \"; \\n            solve(0,arr,now);\\n            if(is==false)\\n                return \"\";\\n            string res=s.substr(0,2);\\n            res+=\":\";\\n            res+=s.substr(2);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        \\n        string s=\"0000\";\\n        bool is=false;\\n        \\n        void solve(int i,vector<int> &arr,string now)\\n        {\\n            if(i==4)\\n            {\\n                if(now.substr(0,2)<=\"23\" && now.substr(2,2)<=\"59\" && (s==\"0000\" || s<now))\\n                {\\n                    is=true;\\n                    s=now;\\n                    return;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3638784,
                "title": "simple-permutate-the-string-for-valid-times",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate all time permutations and discard non-valid solutions.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort array and convert it to a string.\\nTwo upper limits exist: 24:00 and for minutes 6;  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ ==> while will always take 4! iterations.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end()); // needed for permutations\\n \\n        string permutateTime = to_string(arr[0]) + to_string(arr[1]) + to_string(arr[2]) + to_string(arr[3]);\\n        \\n        string endTime = \"2400\";\\n        constexpr char minuteOverflow = \\'6\\'; \\n        \\n        string result = \"\";\\n        do{\\n            if( permutateTime < endTime and permutateTime[2] < minuteOverflow){\\n                result = max(permutateTime, result);\\n            }\\n        }while(next_permutation(permutateTime.begin(), permutateTime.end()));\\n \\n        return result.empty() ? \"\" : result.substr(0,2) + \":\" + result.substr(2,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end()); // needed for permutations\\n \\n        string permutateTime = to_string(arr[0]) + to_string(arr[1]) + to_string(arr[2]) + to_string(arr[3]);\\n        \\n        string endTime = \"2400\";\\n        constexpr char minuteOverflow = \\'6\\'; \\n        \\n        string result = \"\";\\n        do{\\n            if( permutateTime < endTime and permutateTime[2] < minuteOverflow){\\n                result = max(permutateTime, result);\\n            }\\n        }while(next_permutation(permutateTime.begin(), permutateTime.end()));\\n \\n        return result.empty() ? \"\" : result.substr(0,2) + \":\" + result.substr(2,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632821,
                "title": "try-all-and-check-for-the-latest",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) \\n    {\\n       //the length of the string is 5\\n        //hh:mm\\n        \\n        //00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 (24)\\n        //00 -> 59 (60)\\n        //24 * 60 = 1440\\n\\n        string str = \"??:??\";\\n        //we need to fill the string str\\n\\n        int idx = 0;\\n        string ans=\"\";\\n        int n = str.length();\\n        fun(arr,str,idx,ans,n);\\n        return ans;\\n    }\\n    bool isValid(string str)\\n    {\\n        int hrs = 0;\\n        hrs = (hrs*10) + (str[0] - \\'0\\');\\n        hrs = (hrs*10) + (str[1] - \\'0\\');\\n\\n        if(hrs < 0 or hrs >= 24) return false;\\n\\n        int mins = 0;\\n        mins = (mins*10) + (str[3] - \\'0\\');\\n        mins = (mins*10) + (str[4] - \\'0\\');\\n\\n        if(mins < 0 or mins >= 60) return false;\\n\\n        return true;\\n    }\\n    bool isLatest(string &str , string &ans)\\n    {\\n        if(ans.length() == 0)\\n        return true;\\n\\n        int currhrs = 0;\\n        int prvhrs = 0;\\n\\n        currhrs = (currhrs*10) + (str[0] - \\'0\\');\\n        currhrs = (currhrs*10) + (str[1] - \\'0\\');\\n  \\n     \\n        prvhrs = (prvhrs*10) + (ans[0] - \\'0\\');\\n        prvhrs = (prvhrs*10) + (ans[1] - \\'0\\');\\n\\n        //if(currhrs == 0 and prvhrs == 1) cout<<\"hello\"<<endl;\\n        if(currhrs > prvhrs) return true;\\n        else if(currhrs < prvhrs) return false;\\n\\n        int currmins = 0;\\n        int prvmins = 0;\\n\\n        currmins = (currmins*10) + (str[3] - \\'0\\');\\n        currmins = (currmins*10) + (str[4] - \\'0\\');\\n\\n        prvmins = (prvmins*10) + (ans[3] - \\'0\\');\\n        prvmins = (prvmins*10) + (ans[4] - \\'0\\');\\n\\n        if(currmins > prvmins) return true;\\n\\n       // cout<<str<<\" \"<<ans<<endl;\\n        return false;\\n        \\n    }\\n    void fun(vector<int>&arr,string &str,int idx,string &ans,int &n)\\n    {\\n        if(idx >= n)\\n        {\\n            if(isValid(str) == true and isLatest(str,ans) == true)\\n            {\\n                ans = str;\\n            }\\n            //cout<<\"ans = \"<<ans<<endl;\\n            return;\\n        }\\n        if(str[idx] == \\'?\\')\\n        {\\n             for(int i=0;i<arr.size();i++)\\n             {\\n                 int val = arr[i];\\n                 if(arr[i] != -1)\\n                 {\\n                   arr[i] = -1;\\n                   str[idx] = char(val +\\' 0\\');\\n                   fun(arr,str,idx+1,ans,n);\\n                   str[idx] = \\'?\\';\\n                   arr[i] = val;\\n                }\\n             }\\n        }\\n        else if(str[idx] != \\'?\\')   //:\\n        {\\n            fun(arr,str,idx+1,ans,n);\\n        }\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) \\n    {\\n       //the length of the string is 5\\n        //hh:mm\\n        \\n        //00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 (24)\\n        //00 -> 59 (60)\\n        //24 * 60 = 1440\\n\\n        string str = \"??:??\";\\n        //we need to fill the string str\\n\\n        int idx = 0;\\n        string ans=\"\";\\n        int n = str.length();\\n        fun(arr,str,idx,ans,n);\\n        return ans;\\n    }\\n    bool isValid(string str)\\n    {\\n        int hrs = 0;\\n        hrs = (hrs*10) + (str[0] - \\'0\\');\\n        hrs = (hrs*10) + (str[1] - \\'0\\');\\n\\n        if(hrs < 0 or hrs >= 24) return false;\\n\\n        int mins = 0;\\n        mins = (mins*10) + (str[3] - \\'0\\');\\n        mins = (mins*10) + (str[4] - \\'0\\');\\n\\n        if(mins < 0 or mins >= 60) return false;\\n\\n        return true;\\n    }\\n    bool isLatest(string &str , string &ans)\\n    {\\n        if(ans.length() == 0)\\n        return true;\\n\\n        int currhrs = 0;\\n        int prvhrs = 0;\\n\\n        currhrs = (currhrs*10) + (str[0] - \\'0\\');\\n        currhrs = (currhrs*10) + (str[1] - \\'0\\');\\n  \\n     \\n        prvhrs = (prvhrs*10) + (ans[0] - \\'0\\');\\n        prvhrs = (prvhrs*10) + (ans[1] - \\'0\\');\\n\\n        //if(currhrs == 0 and prvhrs == 1) cout<<\"hello\"<<endl;\\n        if(currhrs > prvhrs) return true;\\n        else if(currhrs < prvhrs) return false;\\n\\n        int currmins = 0;\\n        int prvmins = 0;\\n\\n        currmins = (currmins*10) + (str[3] - \\'0\\');\\n        currmins = (currmins*10) + (str[4] - \\'0\\');\\n\\n        prvmins = (prvmins*10) + (ans[3] - \\'0\\');\\n        prvmins = (prvmins*10) + (ans[4] - \\'0\\');\\n\\n        if(currmins > prvmins) return true;\\n\\n       // cout<<str<<\" \"<<ans<<endl;\\n        return false;\\n        \\n    }\\n    void fun(vector<int>&arr,string &str,int idx,string &ans,int &n)\\n    {\\n        if(idx >= n)\\n        {\\n            if(isValid(str) == true and isLatest(str,ans) == true)\\n            {\\n                ans = str;\\n            }\\n            //cout<<\"ans = \"<<ans<<endl;\\n            return;\\n        }\\n        if(str[idx] == \\'?\\')\\n        {\\n             for(int i=0;i<arr.size();i++)\\n             {\\n                 int val = arr[i];\\n                 if(arr[i] != -1)\\n                 {\\n                   arr[i] = -1;\\n                   str[idx] = char(val +\\' 0\\');\\n                   fun(arr,str,idx+1,ans,n);\\n                   str[idx] = \\'?\\';\\n                   arr[i] = val;\\n                }\\n             }\\n        }\\n        else if(str[idx] != \\'?\\')   //:\\n        {\\n            fun(arr,str,idx+1,ans,n);\\n        }\\n    } \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3576635,
                "title": "python-brute-force-approach-using-basic-data-structure",
                "content": "# Intuition\\nSolving with basic data structure\\n\\n# Approach\\nCreate a hash table to keep all possible combinations and then find all possible or valid time and keep them in list and then find the latest time from the list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n   def largestTimeFromDigits(self, arr):\\n     \\n        nums = {}\\n        for i in range(4):\\n            for j in range(4):\\n                if i != j:\\n                    num = arr[i]*10 + arr[j]\\n                    nums[tuple([i,j])] = num\\n\\n        possible_ans = []\\n        for indx_hh in nums:\\n            if nums[indx_hh] < 24:\\n                for indx_mm in nums:\\n                    # ensure one digit used only once\\n                    if len(set(indx_mm + indx_hh)) < 4:\\n                        continue\\n                    if nums[indx_mm] < 60:\\n                        possible_ans.append([nums[indx_hh], nums[indx_mm]])\\n        if possible_ans:\\n            possible_ans.sort()\\n            hh, mm  = possible_ans[-1:][0]\\n            # print (final)\\n            # hh, mm  = final[0], final[1]\\n            return f\"{hh:02d}:{mm:02d}\"\\n   \\n        return \"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n   def largestTimeFromDigits(self, arr):\\n     \\n        nums = {}\\n        for i in range(4):\\n            for j in range(4):\\n                if i != j:\\n                    num = arr[i]*10 + arr[j]\\n                    nums[tuple([i,j])] = num\\n\\n        possible_ans = []\\n        for indx_hh in nums:\\n            if nums[indx_hh] < 24:\\n                for indx_mm in nums:\\n                    # ensure one digit used only once\\n                    if len(set(indx_mm + indx_hh)) < 4:\\n                        continue\\n                    if nums[indx_mm] < 60:\\n                        possible_ans.append([nums[indx_hh], nums[indx_mm]])\\n        if possible_ans:\\n            possible_ans.sort()\\n            hh, mm  = possible_ans[-1:][0]\\n            # print (final)\\n            # hh, mm  = final[0], final[1]\\n            return f\"{hh:02d}:{mm:02d}\"\\n   \\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556991,
                "title": "python3-permutations",
                "content": "\\n```\\nclass Solution:\\n    def checkTime(self, t):\\n        if t[0] > 2:\\n            return False\\n        if t[0] == 2 and t[1] > 3:\\n            return False\\n        if t[2] > 5:\\n            return False\\n        \\n        return True\\n            \\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        ret = (-1,-1,-1,-1)\\n        for t in itertools.permutations(arr):\\n            if self.checkTime(t) and (t > ret):\\n                ret = t\\n        \\n        return \"\" if ret == (-1,-1,-1,-1) else \"{}{}:{}{}\".format(ret[0],ret[1],ret[2],ret[3])\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkTime(self, t):\\n        if t[0] > 2:\\n            return False\\n        if t[0] == 2 and t[1] > 3:\\n            return False\\n        if t[2] > 5:\\n            return False\\n        \\n        return True\\n            \\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        ret = (-1,-1,-1,-1)\\n        for t in itertools.permutations(arr):\\n            if self.checkTime(t) and (t > ret):\\n                ret = t\\n        \\n        return \"\" if ret == (-1,-1,-1,-1) else \"{}{}:{}{}\".format(ret[0],ret[1],ret[2],ret[3])\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542995,
                "title": "js-solution-using-recursion-to-generate-all-possible-permutations",
                "content": "```\\nvar largestTimeFromDigits = function(arr) {\\n    \\n    //variables to store max hour and max minute\\n    let maxh;\\n    let maxm;\\n  \\n    //finds max hour and min by checking all possible permuations\\n    function perms(digits, selec){\\n        \\n        //stop condition if no more digits to choose from\\n        if(digits.length === 0){\\n            \\n            //stringify hour and minute separately\\n            let h = [selec[0], selec[1]].join(\"\")\\n            let m = [selec[2], selec[3]].join(\"\")\\n            \\n            //check if hour and minute are valid and within range\\n            if(h <= 23 && m <= 59){\\n                \\n                //store hour and minute if first valid combination\\n                if(!maxh){\\n                    maxh = h\\n                    maxm = m\\n                }\\n                //check if hour is greater than current max hour\\n                else if(h > maxh){\\n                    maxh = h;\\n                    maxm = m\\n                }\\n                //if hour is same as current max hour, check if minute is greater than current max minute\\n                else if(h === maxh && m > maxm){\\n                    maxh = h;\\n                    maxm = m\\n                }\\n            }\\n            \\n            return;\\n        }\\n        \\n        for(let i=0;i<digits.length;i++){\\n            \\n            //choose digit\\n            selec.push(digits[i])\\n            \\n            //filter digit out of array \\n            let rest = digits.filter((digit,index) => index !== i);\\n            \\n            //generate permutations with rest of digits\\n            perms(rest,selec)\\n            \\n            //pop off last selected digit\\n            selec.pop()\\n        }\\n    }\\n    \\n    //generate permuations and find max hour and min\\n    perms(arr, [])\\n    \\n    // check if max hour was ever set, and if so return max 24 hour time, else return empty string\\n    return maxh ? `${maxh}:${maxm}`: \"\"\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar largestTimeFromDigits = function(arr) {\\n    \\n    //variables to store max hour and max minute\\n    let maxh;\\n    let maxm;\\n  \\n    //finds max hour and min by checking all possible permuations\\n    function perms(digits, selec){\\n        \\n        //stop condition if no more digits to choose from\\n        if(digits.length === 0){\\n            \\n            //stringify hour and minute separately\\n            let h = [selec[0], selec[1]].join(\"\")\\n            let m = [selec[2], selec[3]].join(\"\")\\n            \\n            //check if hour and minute are valid and within range\\n            if(h <= 23 && m <= 59){\\n                \\n                //store hour and minute if first valid combination\\n                if(!maxh){\\n                    maxh = h\\n                    maxm = m\\n                }\\n                //check if hour is greater than current max hour\\n                else if(h > maxh){\\n                    maxh = h;\\n                    maxm = m\\n                }\\n                //if hour is same as current max hour, check if minute is greater than current max minute\\n                else if(h === maxh && m > maxm){\\n                    maxh = h;\\n                    maxm = m\\n                }\\n            }\\n            \\n            return;\\n        }\\n        \\n        for(let i=0;i<digits.length;i++){\\n            \\n            //choose digit\\n            selec.push(digits[i])\\n            \\n            //filter digit out of array \\n            let rest = digits.filter((digit,index) => index !== i);\\n            \\n            //generate permutations with rest of digits\\n            perms(rest,selec)\\n            \\n            //pop off last selected digit\\n            selec.pop()\\n        }\\n    }\\n    \\n    //generate permuations and find max hour and min\\n    perms(arr, [])\\n    \\n    // check if max hour was ever set, and if so return max 24 hour time, else return empty string\\n    return maxh ? `${maxh}:${maxm}`: \"\"\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526827,
                "title": "simple-java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        Arrays.sort(arr); \\n        String result = \"\";\\n\\n        for (int h = 23; h >= 0; h--) {\\n            for (int m = 59; m >= 0; m--) {\\n                int[] digits = { h / 10, h % 10, m / 10, m % 10 };\\n                Arrays.sort(digits); \\n\\n                if (Arrays.equals(arr, digits)) {\\n                    result = String.format(\"%02d:%02d\", h, m);\\n                    return result;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    } \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        Arrays.sort(arr); \\n        String result = \"\";\\n\\n        for (int h = 23; h >= 0; h--) {\\n            for (int m = 59; m >= 0; m--) {\\n                int[] digits = { h / 10, h % 10, m / 10, m % 10 };\\n                Arrays.sort(digits); \\n\\n                if (Arrays.equals(arr, digits)) {\\n                    result = String.format(\"%02d:%02d\", h, m);\\n                    return result;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    } \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497997,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        result = -1\\n        n = len(arr)\\n        def compare():\\n            nonlocal result\\n            hours = arr[0] * 10 + arr[1]\\n            minutes = arr[2] * 10 + arr[3]\\n            if hours < 24 and minutes < 60:\\n                result = max(result, hours * 60 + minutes)\\n\\n        def backtrack(i):\\n            if i == n:\\n                compare()\\n            for j in range(i, n):\\n                arr[i], arr[j] = arr[j], arr[i]\\n                backtrack(i + 1)\\n                arr[i], arr[j] = arr[j], arr[i]\\n\\n        backtrack(0)\\n        if result == -1:\\n            return \"\"\\n        else:\\n            hours = result // 60\\n            minutes = result % 60\\n            return \"{:02d}:{:02d}\".format(hours, minutes)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        result = -1\\n        n = len(arr)\\n        def compare():\\n            nonlocal result\\n            hours = arr[0] * 10 + arr[1]\\n            minutes = arr[2] * 10 + arr[3]\\n            if hours < 24 and minutes < 60:\\n                result = max(result, hours * 60 + minutes)\\n\\n        def backtrack(i):\\n            if i == n:\\n                compare()\\n            for j in range(i, n):\\n                arr[i], arr[j] = arr[j], arr[i]\\n                backtrack(i + 1)\\n                arr[i], arr[j] = arr[j], arr[i]\\n\\n        backtrack(0)\\n        if result == -1:\\n            return \"\"\\n        else:\\n            hours = result // 60\\n            minutes = result % 60\\n            return \"{:02d}:{:02d}\".format(hours, minutes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434292,
                "title": "c-simple-solution-easy-to-understand-solution-with-steps",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(24 * 60 * 4!),\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        string time;\\n        do {\\n            int hours = arr[0] * 10 + arr[1]; // compute the hours from the first two digits\\n            int minutes = arr[2] * 10 + arr[3]; // compute the minutes from the last two digits\\n            if(hours < 24 && minutes <60){ // check if the time is valid\\n                time = (hours < 10) ? \"0\" : \"\";\\n                time += to_string(hours); \\n                time += \":\";\\n                time += (minutes < 10) ? \"0\" : \"\";\\n                time += to_string(minutes); \\n            }\\n        } while(next_permutation(arr.begin(),arr.end())); // generate all possible permutations of the array\\n        return time;  // return the latest valid time\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        string time;\\n        do {\\n            int hours = arr[0] * 10 + arr[1]; // compute the hours from the first two digits\\n            int minutes = arr[2] * 10 + arr[3]; // compute the minutes from the last two digits\\n            if(hours < 24 && minutes <60){ // check if the time is valid\\n                time = (hours < 10) ? \"0\" : \"\";\\n                time += to_string(hours); \\n                time += \":\";\\n                time += (minutes < 10) ? \"0\" : \"\";\\n                time += to_string(minutes); \\n            }\\n        } while(next_permutation(arr.begin(),arr.end())); // generate all possible permutations of the array\\n        return time;  // return the latest valid time\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417786,
                "title": "python-simple-looping",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        res = [0] * 5\\n        c = Counter(arr)\\n        great5 = 0\\n        for key in c:\\n            if key > 5:\\n                great5 += c[key]\\n                \\n        #set the size of the ranges for each position\\n        cycl = {0:3, 1:4, 2:0,3:6,4:10}\\n        \\n        #O(1)\\n        for i in range(5):\\n            #spacer\\n            if i == 2:\\n                continue\\n            assigned = False\\n            \\n            #edge case\\n            #we were allowed to take 2 so fill the second slot in with the largest number we have remaining\\n            if i == 1 and int(res[0]) < 2:\\n                #4 at most\\n                mx = max(c)\\n                res[i] = str(mx)\\n                c[mx] -=1\\n                if c[mx] == 0:\\n                    del c[mx]\\n                continue\\n                \\n            #try all number ranges for the given postion and take the largest\\n            for j in range(cycl[i] -1,-1,-1):\\n                #edge case\\n                #if there are more than 2 numbers greater than 5 in the list than we cant take 2 as the first number since we will need it in the second position\\n                if i == 0 and j == 2 and great5 >= 2:\\n                    continue\\n                \\n                #if we have this number remaining use it and remove it from our dict\\n                if j in c:\\n                    assigned = True\\n                    res[i] = str(j)\\n                    c[j] -=1\\n                    if c[j] == 0:\\n                        del c[j]\\n                    break\\n            \\n            #we could not assign this position\\n            if not assigned:\\n                return \"\"\\n        \\n        res[2] = \":\"\\n        return \\'\\'.join(res)\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        res = [0] * 5\\n        c = Counter(arr)\\n        great5 = 0\\n        for key in c:\\n            if key > 5:\\n                great5 += c[key]\\n                \\n        #set the size of the ranges for each position\\n        cycl = {0:3, 1:4, 2:0,3:6,4:10}",
                "codeTag": "Java"
            },
            {
                "id": 3377329,
                "title": "c-easy-to-understand-solution-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int n=arr.size();\\n        string hr=\"\",min=\"\";\\n        vector<string> times;\\n        for (int i=0;i<4;i++) {\\n            for (int j=0;j<4;j++) {\\n                if (j!=i) {\\n                    hr += to_string(arr[i]);\\n                    hr += to_string(arr[j]);\\n                    for (int k=0;k<4;k++) {\\n                        if (k!=i && k!=j) {\\n                            min += to_string(arr[k]);\\n                            for (int l=0;l<4;l++) {\\n                                if (l!=i && l!=j && l!=k) {\\n                                    min += to_string(arr[l]);\\n                                    times.push_back(hr+\":\"+min);\\n                                }\\n                            }\\n                        }\\n                        min=\"\";\\n                    }\\n                }\\n                hr=\"\";\\n            }\\n        }\\n        // sort in descending order\\n        sort(times.begin(),times.end(),[](const string& a,const string& b) {\\n            if (stoi(a.substr(0,2)) > stoi(b.substr(0,2))) {\\n                return true;\\n            }else if (stoi(a.substr(0,2)) < stoi(b.substr(0,2))) {\\n                return false;\\n            }else {\\n                if (stoi(a.substr(3,2)) > stoi(b.substr(3,2))) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        });\\n        for (int i=0;i<24;i++) {\\n            if (stoi(times[i].substr(0,2)) <= 23 && stoi(times[i].substr(3,2)) <= 59) {\\n                return times[i];\\n            } \\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int n=arr.size();\\n        string hr=\"\",min=\"\";\\n        vector<string> times;\\n        for (int i=0;i<4;i++) {\\n            for (int j=0;j<4;j++) {\\n                if (j!=i) {\\n                    hr += to_string(arr[i]);\\n                    hr += to_string(arr[j]);\\n                    for (int k=0;k<4;k++) {\\n                        if (k!=i && k!=j) {\\n                            min += to_string(arr[k]);\\n                            for (int l=0;l<4;l++) {\\n                                if (l!=i && l!=j && l!=k) {\\n                                    min += to_string(arr[l]);\\n                                    times.push_back(hr+\":\"+min);\\n                                }\\n                            }\\n                        }\\n                        min=\"\";\\n                    }\\n                }\\n                hr=\"\";\\n            }\\n        }\\n        // sort in descending order\\n        sort(times.begin(),times.end(),[](const string& a,const string& b) {\\n            if (stoi(a.substr(0,2)) > stoi(b.substr(0,2))) {\\n                return true;\\n            }else if (stoi(a.substr(0,2)) < stoi(b.substr(0,2))) {\\n                return false;\\n            }else {\\n                if (stoi(a.substr(3,2)) > stoi(b.substr(3,2))) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        });\\n        for (int i=0;i<24;i++) {\\n            if (stoi(times[i].substr(0,2)) <= 23 && stoi(times[i].substr(3,2)) <= 59) {\\n                return times[i];\\n            } \\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372155,
                "title": "python-backtracking-no-library-functions",
                "content": "# Intuition\\nThis seemed like a backtracking problem because we want to greedily assign the largest digits first and then gradually try lower options if that doesn\\'t lead to a solution.\\n\\n# Approach\\nWe keep a stack for the current solution in `sol` and we explore at most 4 levels (one for each digit spot). Custom logic for the maximum digit of each level.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where $$n$$ is the length of the sought solution (in this case, $$4$$)\\n\\n- Space complexity: $$O(n)$$, where $$n$$ is the length of the sought solution (in this case, $$4$$)\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        arr,sol=Counter(arr),[]\\n        def backtrack(l: int):\\n            if l==0: maxdigit=2\\n            elif l==1: maxdigit=3 if sol[0]==2 else 9\\n            elif l==2: maxdigit=5\\n            elif l==3: maxdigit=9\\n            else: return f\"{sol[0]}{sol[1]}:{sol[2]}{sol[3]}\"\\n            for o in list(range(maxdigit,-1,-1)):\\n                if o in arr and arr[o]>0:\\n                    arr[o]-=1\\n                    sol.append(o)\\n                    res=backtrack(l+1)\\n                    if res!=\"\": return res\\n                    arr[o]+=1\\n                    sol.pop()\\n            return \"\"\\n        return backtrack(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        arr,sol=Counter(arr),[]\\n        def backtrack(l: int):\\n            if l==0: maxdigit=2\\n            elif l==1: maxdigit=3 if sol[0]==2 else 9\\n            elif l==2: maxdigit=5\\n            elif l==3: maxdigit=9\\n            else: return f\"{sol[0]}{sol[1]}:{sol[2]}{sol[3]}\"\\n            for o in list(range(maxdigit,-1,-1)):\\n                if o in arr and arr[o]>0:\\n                    arr[o]-=1\\n                    sol.append(o)\\n                    res=backtrack(l+1)\\n                    if res!=\"\": return res\\n                    arr[o]+=1\\n                    sol.pop()\\n            return \"\"\\n        return backtrack(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367607,
                "title": "java-solution-permutation",
                "content": "# Code\\n```\\nclass Solution {\\n    int time = 0;\\n    int maxTime = Integer.MIN_VALUE;\\n    String result  = \"\";\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        int n = arr.length;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < n; i++){\\n            sb.append(String.valueOf(arr[i]));\\n        }\\n        \\n        getPermutations(\"\",sb.toString());\\n        \\n        return result == \"\"\\n                ? \"\" \\n                : result.substring(0,2) + \":\" + result.substring(2);\\n    }\\n\\n    public void getPermutations(String prefix, String str){\\n        int n = str.length();\\n        if(n == 0 && prefix.charAt(0) - \\'0\\' < 3 && prefix.charAt(2) - \\'0\\' < 6 \\n                && !(prefix.charAt(0)- \\'0\\' == 2 && prefix.charAt(1) - \\'0\\' > 3)){\\n                    \\n            time = (Integer.valueOf(prefix.substring(0,2))*60) + Integer.valueOf(prefix.substring(2));\\n            if(time > maxTime){\\n                maxTime = time;\\n                result = prefix;\\n            }\\n        }else{\\n            for(int i = 0; i < n; i++){\\n                getPermutations(prefix+str.charAt(i), str.substring(0,i)+str.substring(i+1));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int time = 0;\\n    int maxTime = Integer.MIN_VALUE;\\n    String result  = \"\";\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        int n = arr.length;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < n; i++){\\n            sb.append(String.valueOf(arr[i]));\\n        }\\n        \\n        getPermutations(\"\",sb.toString());\\n        \\n        return result == \"\"\\n                ? \"\" \\n                : result.substring(0,2) + \":\" + result.substring(2);\\n    }\\n\\n    public void getPermutations(String prefix, String str){\\n        int n = str.length();\\n        if(n == 0 && prefix.charAt(0) - \\'0\\' < 3 && prefix.charAt(2) - \\'0\\' < 6 \\n                && !(prefix.charAt(0)- \\'0\\' == 2 && prefix.charAt(1) - \\'0\\' > 3)){\\n                    \\n            time = (Integer.valueOf(prefix.substring(0,2))*60) + Integer.valueOf(prefix.substring(2));\\n            if(time > maxTime){\\n                maxTime = time;\\n                result = prefix;\\n            }\\n        }else{\\n            for(int i = 0; i < n; i++){\\n                getPermutations(prefix+str.charAt(i), str.substring(0,i)+str.substring(i+1));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348920,
                "title": "recursion-permutation-of-string-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public void helper(String s,TreeSet<String>set,String t){\\n        if(t.length()==4){\\n            set.add(t);\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            String r = s.substring(0,i)+s.substring(i+1);\\n            helper(r,set,t+c);\\n        }\\n    }\\n    public String largestTimeFromDigits(int[] arr) {\\n        Arrays.sort(arr);\\n        String s=\"\";\\n        for(int i=0;i<4;i++) s+=Integer.toString(arr[i]);\\n        TreeSet<String> set = new TreeSet<>();\\n        helper(s,set,\"\");\\n        TreeSet<String> seter = new TreeSet<>();\\n        for(String x:set){\\n            if(x.substring(0,2).compareTo(\"24\")<0 && x.substring(2).compareTo(\"60\")<0)\\n            seter.add(x);\\n        }\\n        if(seter.size()==0) return \"\";\\n        String r = seter.last().substring(0,2)+\":\"+seter.last().substring(2);\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public void helper(String s,TreeSet<String>set,String t){\\n        if(t.length()==4){\\n            set.add(t);\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            String r = s.substring(0,i)+s.substring(i+1);\\n            helper(r,set,t+c);\\n        }\\n    }\\n    public String largestTimeFromDigits(int[] arr) {\\n        Arrays.sort(arr);\\n        String s=\"\";\\n        for(int i=0;i<4;i++) s+=Integer.toString(arr[i]);\\n        TreeSet<String> set = new TreeSet<>();\\n        helper(s,set,\"\");\\n        TreeSet<String> seter = new TreeSet<>();\\n        for(String x:set){\\n            if(x.substring(0,2).compareTo(\"24\")<0 && x.substring(2).compareTo(\"60\")<0)\\n            seter.add(x);\\n        }\\n        if(seter.size()==0) return \"\";\\n        String r = seter.last().substring(0,2)+\":\"+seter.last().substring(2);\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346672,
                "title": "simple-typescript-javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(arr) {\\n    var result;\\n    for(var i =0; i<4; i++){\\n        for (var j=0; j<4 ; j++){\\n            for (var k =0; k<4; k++){\\n                if(i==j || j==k || k==i)\\n                    continue;\\n                var hh = arr[i].toString()+arr[j].toString();\\n                var mm = arr[k].toString()+arr[6-i-j-k].toString();\\n                var _time = hh+\":\"+mm;\\n                if(hh<\"24\" && mm<\"60\" && (_time>result || result==undefined))\\n                    result = _time;\\n            }\\n        }\\n    }\\n    if(result == undefined)\\n        return \"\";\\n    else\\n        return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(arr) {\\n    var result;\\n    for(var i =0; i<4; i++){\\n        for (var j=0; j<4 ; j++){\\n            for (var k =0; k<4; k++){\\n                if(i==j || j==k || k==i)\\n                    continue;\\n                var hh = arr[i].toString()+arr[j].toString();\\n                var mm = arr[k].toString()+arr[6-i-j-k].toString();\\n                var _time = hh+\":\"+mm;\\n                if(hh<\"24\" && mm<\"60\" && (_time>result || result==undefined))\\n                    result = _time;\\n            }\\n        }\\n    }\\n    if(result == undefined)\\n        return \"\";\\n    else\\n        return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3338937,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int time = -1 ;\\n    const int upperBound = 24 * 60 ;\\n    void dfs(vector<bool>&used, vector<int>&arr, int cur, vector<int>&tmp){\\n        if(cur == 4){\\n            int hour = tmp[0]*10 + tmp[1] ;\\n            int minute = tmp[2]*10 + tmp[3] ;\\n            if(minute >= 60)\\n                return ;\\n            int curTime = hour * 60 + minute ;\\n            if(curTime < upperBound) \\n                time = max(time, curTime) ;              \\n            return ;\\n        }\\n        for(int i = 0; i < 4; i++){\\n            if(used[i])\\n                continue ;\\n            used[i] = true ;\\n            tmp[cur] = arr[i] ;\\n            dfs(used, arr, cur+1, tmp) ;\\n            used[i] = false ;\\n        }\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end()) ;\\n        if(arr[0] > 2 || (arr[0] == 2 && arr[1] > 3))\\n            return \"\" ;\\n\\n        vector<bool>used(4) ;\\n        vector<int>tmp(4) ;\\n        dfs(used, arr, 0, tmp) ;\\n        if(time == -1)\\n            return \"\" ;\\n        string ret ;\\n        int hour = time/60 ;\\n        int minute = time %60 ;\\n\\n        if(hour < 10)\\n            ret += \"0\" + to_string(hour) ;\\n        else\\n            ret += to_string(hour) ;\\n        ret += \":\" ;\\n        \\n        if(minute < 10)\\n            ret += \"0\" + to_string(minute) ;\\n        else\\n            ret += to_string(minute) ;\\n\\n        return ret ;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int time = -1 ;\\n    const int upperBound = 24 * 60 ;\\n    void dfs(vector<bool>&used, vector<int>&arr, int cur, vector<int>&tmp){\\n        if(cur == 4){\\n            int hour = tmp[0]*10 + tmp[1] ;\\n            int minute = tmp[2]*10 + tmp[3] ;\\n            if(minute >= 60)\\n                return ;\\n            int curTime = hour * 60 + minute ;\\n            if(curTime < upperBound) \\n                time = max(time, curTime) ;              \\n            return ;\\n        }\\n        for(int i = 0; i < 4; i++){\\n            if(used[i])\\n                continue ;\\n            used[i] = true ;\\n            tmp[cur] = arr[i] ;\\n            dfs(used, arr, cur+1, tmp) ;\\n            used[i] = false ;\\n        }\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end()) ;\\n        if(arr[0] > 2 || (arr[0] == 2 && arr[1] > 3))\\n            return \"\" ;\\n\\n        vector<bool>used(4) ;\\n        vector<int>tmp(4) ;\\n        dfs(used, arr, 0, tmp) ;\\n        if(time == -1)\\n            return \"\" ;\\n        string ret ;\\n        int hour = time/60 ;\\n        int minute = time %60 ;\\n\\n        if(hour < 10)\\n            ret += \"0\" + to_string(hour) ;\\n        else\\n            ret += to_string(hour) ;\\n        ret += \":\" ;\\n        \\n        if(minute < 10)\\n            ret += \"0\" + to_string(minute) ;\\n        else\\n            ret += to_string(minute) ;\\n\\n        return ret ;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325015,
                "title": "java-easy-to-understand-permutations",
                "content": "```\\nclass Solution {\\n    private void generatePermutations(int ind, int[] arr, ArrayList<int[]> al) {\\n        if(ind == 4){\\n            al.add(arr.clone());\\n            return;\\n        }\\n        for(int i = ind;i < 4;i++) {\\n            swap(arr, ind, i);\\n            generatePermutations(ind + 1, arr, al);\\n            swap(arr, ind, i);\\n        }\\n    }\\n    private void swap( int[] arr, int i, int j) {\\n            int temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] =  temp;\\n    }\\n    public String largestTimeFromDigits(int[] arr) {\\n        ArrayList<int[]> al = new ArrayList<>();\\n        generatePermutations(0, arr, al);\\n        StringBuilder sb = new StringBuilder();\\n        int max = 0;\\n        for(int[] a : al) {\\n           int hh = a[0] * 10 + a[1];\\n           int mm = a[2] * 10 + a[3];\\n      \\n           if(hh >= 0 && hh <= 23) {\\n               if(mm >= 0 && mm <= 59){\\n                   if(hh * 100 + mm >= max){\\n                        max = hh * 100 + mm;\\n                        sb = new StringBuilder();\\n                  \\n                        if(hh <= 9 && mm <= 9){\\n                            sb.append(\"0\").append(Integer.toString(hh)).append(\":\").append(\"0\").append(Integer.toString(mm));\\n                        }\\n                        else if(hh <= 9)\\n                            sb.append(\"0\").append(Integer.toString(hh)).append(\":\").append(Integer.toString(mm));\\n                        else if(mm <= 9)\\n                            sb.append(Integer.toString(hh)).append(\":\").append(\"0\").append(Integer.toString(mm));\\n                        else \\n                            sb.append(Integer.toString(hh)).append(\":\").append(Integer.toString(mm));\\n                       \\n                     }\\n                }\\n            }\\n       \\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private void generatePermutations(int ind, int[] arr, ArrayList<int[]> al) {\\n        if(ind == 4){\\n            al.add(arr.clone());\\n            return;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1795252,
                "content": [
                    {
                        "username": "DanQingReader",
                        "content": "stupid question"
                    },
                    {
                        "username": "decostar",
                        "content": "No Brother :(\\n"
                    },
                    {
                        "username": "akhaled01",
                        "content": "isnt the largest possible time for array (1, 2, 3, 4) 23:43?"
                    },
                    {
                        "username": "njculpin",
                        "content": "no, \"can be made using each digit exactly once\""
                    },
                    {
                        "username": "charlie-_-",
                        "content": "No, it\\'s 23:41. You can only use each digit once. "
                    }
                ]
            },
            {
                "id": 1989416,
                "content": [
                    {
                        "username": "DanQingReader",
                        "content": "stupid question"
                    },
                    {
                        "username": "decostar",
                        "content": "No Brother :(\\n"
                    },
                    {
                        "username": "akhaled01",
                        "content": "isnt the largest possible time for array (1, 2, 3, 4) 23:43?"
                    },
                    {
                        "username": "njculpin",
                        "content": "no, \"can be made using each digit exactly once\""
                    },
                    {
                        "username": "charlie-_-",
                        "content": "No, it\\'s 23:41. You can only use each digit once. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if There is a Valid Path in a Grid",
        "question_content": "<p>You are given an <code>m x n</code> <code>grid</code>. Each cell of <code>grid</code> represents a street. The street of <code>grid[i][j]</code> can be:</p>\n\n<ul>\n\t<li><code>1</code> which means a street connecting the left cell and the right cell.</li>\n\t<li><code>2</code> which means a street connecting the upper cell and the lower cell.</li>\n\t<li><code>3</code> which means a street connecting the left cell and the lower cell.</li>\n\t<li><code>4</code> which means a street connecting the right cell and the lower cell.</li>\n\t<li><code>5</code> which means a street connecting the left cell and the upper cell.</li>\n\t<li><code>6</code> which means a street connecting the right cell and the upper cell.</li>\n</ul>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/03/05/main.png\" style=\"width: 450px; height: 708px;\" />\n<p>You will initially start at the street of the upper-left cell <code>(0, 0)</code>. A valid path in the grid is a path that starts from the upper left cell <code>(0, 0)</code> and ends at the bottom-right cell <code>(m - 1, n - 1)</code>. <strong>The path should only follow the streets</strong>.</p>\n\n<p><strong>Notice</strong> that you are <strong>not allowed</strong> to change any street.</p>\n\n<p>Return <code>true</code><em> if there is a valid path in the grid or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/03/05/e1.png\" style=\"width: 455px; height: 311px;\" />\n<pre>\n<strong>Input:</strong> grid = [[2,4,3],[6,5,2]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/03/05/e2.png\" style=\"width: 455px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,2,1],[1,2,1]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,1,2]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 6</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 547371,
                "title": "java-clean-bfs",
                "content": "credit to @uwi, some modification\\n```\\nclass Solution {\\n    int[][][] dirs = {\\n                {{0, -1}, {0, 1}},\\n                {{-1, 0}, {1, 0}},\\n                {{0, -1}, {1, 0}},\\n                {{0, 1}, {1, 0}},\\n                {{0, -1}, {-1, 0}},\\n                {{0, 1}, {-1, 0}}\\n    };\\n    //the idea is you need to check port direction match, you can go to next cell and check whether you can come back.\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int x = cur[0], y = cur[1];\\n            int num = grid[x][y] - 1;\\n            for (int[] dir : dirs[num]) {\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || visited[nx][ny]) continue;\\n                //go to the next cell and come back to orign to see if port directions are same\\n                for (int[] backDir : dirs[grid[nx][ny] - 1])\\n                    if (nx + backDir[0] == x && ny + backDir[1] == y) {\\n                        visited[nx][ny] = true;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n            }\\n        }\\n        return visited[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][][] dirs = {\\n                {{0, -1}, {0, 1}},\\n                {{-1, 0}, {1, 0}},\\n                {{0, -1}, {1, 0}},\\n                {{0, 1}, {1, 0}},\\n                {{0, -1}, {-1, 0}},\\n                {{0, 1}, {-1, 0}}\\n    };\\n    //the idea is you need to check port direction match, you can go to next cell and check whether you can come back.\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int x = cur[0], y = cur[1];\\n            int num = grid[x][y] - 1;\\n            for (int[] dir : dirs[num]) {\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || visited[nx][ny]) continue;\\n                //go to the next cell and come back to orign to see if port directions are same\\n                for (int[] backDir : dirs[grid[nx][ny] - 1])\\n                    if (nx + backDir[0] == x && ny + backDir[1] == y) {\\n                        visited[nx][ny] = true;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n            }\\n        }\\n        return visited[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547229,
                "title": "python-union-find",
                "content": "# Explanation\\nAssume we have input A[2][2]. (Thanks @Gad2017 for this diagram)\\n<img src=\"https://assets.leetcode.com/users/lee215/image_1584946037.png\" alt=\"diagram\" width=\"600\"/>\\n\\nThe center of `A[0][0]` has coordinates `[0, 0]`\\nThe center of `A[i][j]` has coordinates `[2i, 2j]`\\nThe top edge of `A[i][j]` has coordinates `[2i-1, 2j]`\\nThe left edge of `A[i][j]` has coordinates `[2i, 2j-1]`\\nThe bottom edge of `A[i][j]` has coordinates `[2i+1, 2j]`\\nThe right edge of `A[i][j]` has coordinates `[2i, 2j+1]`\\n\\nThen we apply **Union Find**:\\nif `A[i][j]` in [2, 5, 6]: connect center and top\\nif `A[i][j]` in [1, 3, 5]: connect center and left\\nif `A[i][j]` in [2, 3, 4]: connect center and bottom\\nif `A[i][j]` in [1, 4, 6]: connect center and right\\n<br>\\n\\n\\n# Complexity\\nTime `O(MN) * O(UF)`\\nSpace `O(MN)`\\n<br>\\n\\n**Python:**\\n```py\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        uf = {(i, j): (i, j) for i in xrange(-1, m * 2) for j in xrange(-1, n * 2)}\\n\\n        def find(x):\\n            if uf[x] != x:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n\\n        def merge(i, j, di, dj):\\n            uf[find((i, j))] = find((i + di, j + dj))\\n\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if A[i][j] in [2, 5, 6]: merge(i * 2, j * 2, -1, 0)\\n                if A[i][j] in [1, 3, 5]: merge(i * 2, j * 2, 0, -1)\\n                if A[i][j] in [2, 3, 4]: merge(i * 2, j * 2, 1, 0)\\n                if A[i][j] in [1, 4, 6]: merge(i * 2, j * 2, 0, 1)\\n        return find((0, 0)) == find((m * 2 - 2, n * 2 - 2))\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        uf = {(i, j): (i, j) for i in xrange(-1, m * 2) for j in xrange(-1, n * 2)}\\n\\n        def find(x):\\n            if uf[x] != x:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n\\n        def merge(i, j, di, dj):\\n            uf[find((i, j))] = find((i + di, j + dj))\\n\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                if A[i][j] in [2, 5, 6]: merge(i * 2, j * 2, -1, 0)\\n                if A[i][j] in [1, 3, 5]: merge(i * 2, j * 2, 0, -1)\\n                if A[i][j] in [2, 3, 4]: merge(i * 2, j * 2, 1, 0)\\n                if A[i][j] in [1, 4, 6]: merge(i * 2, j * 2, 0, 1)\\n        return find((0, 0)) == find((m * 2 - 2, n * 2 - 2))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 547225,
                "title": "c-with-picture-track-direction-upscaled-grid",
                "content": "#### Approach 1: Track Direction\\nYou do not need to search for a path. You just follow the existing path until you can, and check if you reach your destination. The only variable here is your initial direction: e.g. if you start at a turn, you can go either down or right. \\n\\nLet\\'s define 4 directions: right (0), left (1), down (2) and up (3). Each road type can continue from some direction, and can change it to another direction. For example, for road type 3, you can continue from left, and it changes your direction to down. Or, you can continue from up and change to left. We track these rules in `turns`.\\n\\nThanks [arenard](https://leetcode.com/arenard/) for spotting the \"infinite loop\" problem in the initial implementation!\\n\\n```cpp\\nvector<pair<int, int>> dirs{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nunordered_map<int, int> turns[7]{{}, \\n    {{0, 0}, {1, 1}}, {{2, 2}, {3, 3}}, {{0, 2}, {3, 1}}, \\n    {{3, 0}, {1, 2}}, {{0, 3}, {2, 1}}, {{2, 0}, {1, 3}}};\\nbool trace(vector<vector<int>> &g, int dir) {\\n    int i = 0, j = 0, m = g.size(), n = g[0].size();\\n    while(min(i, j) >= 0 && i < m && j < n) {\\n        auto road = g[i][j];\\n        if (turns[road].count(dir) == 0)\\n            return false;\\n        if (i == m - 1 && j == n - 1)\\n            return true;\\n        dir = turns[road][dir];\\n        i += dirs[dir].first, j += dirs[dir].second;\\n        if (i == 0 && j == 0)\\n            return false;\\n    }\\n    return false;        \\n}\\nbool hasValidPath(vector<vector<int>>& g) {\\n    return trace(g, 0) || trace(g, 1) || trace(g, 2) || trace(g, 3);\\n}\\n```\\n#### Approach 2: DFS on Upscaled Grid\\nThis is inspired by a similar solution for [959. Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes/discuss/205674/C%2B%2B-with-picture-DFS-on-upscaled-grid).\\n\\nWe can upscale the input grid to [n * 3][n * 3] grid and draw \"roads\" there. Then, we use DFS to trace the way from start to finish. Picture below says it all. Thanks [gaurav_ec](https://leetcode.com/gaurav_ec/) for pushing the idea!\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1585020742.png)\\n\\n```cpp\\nbool dfs(vector<vector<bool>> &g, int i, int j) {\\n    if (min(i, j) < 0 || i >= g.size() || j >= g[i].size() || !g[i][j])\\n        return false;\\n    if (i == g.size() - 2 && j == g[i].size() - 2)\\n        return true;\\n    g[i][j] = false;\\n    return dfs(g, i - 1, j) || dfs(g, i + 1, j) || dfs(g, i, j + 1) || dfs(g, i, j - 1);\\n}\\nbool hasValidPath(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<bool>> g(m * 3, vector<bool>(n * 3));\\n    for (auto i = 0; i < m; ++i)\\n        for (auto j = 0; j < n; ++j) {\\n            auto r = grid[i][j];\\n            g[i * 3 + 1][j * 3 + 1] = true;\\n            g[i * 3 + 1][j * 3 + 0] = r == 1 || r == 3 || r == 5;\\n            g[i * 3 + 1][j * 3 + 2] = r == 1 || r == 4 || r == 6;\\n            g[i * 3 + 0][j * 3 + 1] = r == 2 || r == 5 || r == 6;\\n            g[i * 3 + 2][j * 3 + 1] = r == 2 || r == 3 || r == 4;\\n        }\\n    return dfs(g, 1, 1);    \\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<pair<int, int>> dirs{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nunordered_map<int, int> turns[7]{{}, \\n    {{0, 0}, {1, 1}}, {{2, 2}, {3, 3}}, {{0, 2}, {3, 1}}, \\n    {{3, 0}, {1, 2}}, {{0, 3}, {2, 1}}, {{2, 0}, {1, 3}}};\\nbool trace(vector<vector<int>> &g, int dir) {\\n    int i = 0, j = 0, m = g.size(), n = g[0].size();\\n    while(min(i, j) >= 0 && i < m && j < n) {\\n        auto road = g[i][j];\\n        if (turns[road].count(dir) == 0)\\n            return false;\\n        if (i == m - 1 && j == n - 1)\\n            return true;\\n        dir = turns[road][dir];\\n        i += dirs[dir].first, j += dirs[dir].second;\\n        if (i == 0 && j == 0)\\n            return false;\\n    }\\n    return false;        \\n}\\nbool hasValidPath(vector<vector<int>>& g) {\\n    return trace(g, 0) || trace(g, 1) || trace(g, 2) || trace(g, 3);\\n}\\n```\n```cpp\\nbool dfs(vector<vector<bool>> &g, int i, int j) {\\n    if (min(i, j) < 0 || i >= g.size() || j >= g[i].size() || !g[i][j])\\n        return false;\\n    if (i == g.size() - 2 && j == g[i].size() - 2)\\n        return true;\\n    g[i][j] = false;\\n    return dfs(g, i - 1, j) || dfs(g, i + 1, j) || dfs(g, i, j + 1) || dfs(g, i, j - 1);\\n}\\nbool hasValidPath(vector<vector<int>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<bool>> g(m * 3, vector<bool>(n * 3));\\n    for (auto i = 0; i < m; ++i)\\n        for (auto j = 0; j < n; ++j) {\\n            auto r = grid[i][j];\\n            g[i * 3 + 1][j * 3 + 1] = true;\\n            g[i * 3 + 1][j * 3 + 0] = r == 1 || r == 3 || r == 5;\\n            g[i * 3 + 1][j * 3 + 2] = r == 1 || r == 4 || r == 6;\\n            g[i * 3 + 0][j * 3 + 1] = r == 2 || r == 5 || r == 6;\\n            g[i * 3 + 2][j * 3 + 1] = r == 2 || r == 3 || r == 4;\\n        }\\n    return dfs(g, 1, 1);    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 547263,
                "title": "python-easy-dfs",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        if not grid:\\n            return true\\n        directions = {1: [(0,-1),(0,1)],\\n                      2: [(-1,0),(1,0)],\\n                      3: [(0,-1),(1,0)],\\n                      4: [(0,1),(1,0)],\\n                      5: [(0,-1),(-1,0)],\\n                      6: [(0,1),(-1,0)]}\\n        visited = set()\\n        goal = (len(grid)-1, len(grid[0]) - 1)\\n        def dfs(i, j):\\n            visited.add((i,j))\\n            if (i,j) == goal:\\n                return True\\n            for d in directions[grid[i][j]]:\\n                ni, nj = i+d[0], j+d[1]\\n                if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (ni, nj) not in visited and (-d[0], -d[1]) in directions[grid[ni][nj]]:\\n                    if dfs(ni, nj):\\n                        return True\\n            return False\\n        return dfs(0,0)\\n```\\nWhy ```(-d[0], -d[1]) in directions[grid[ni][nj]]```:?\\n\\nWhen traversing from one cell to the next. the next cell must have a direction that is the opposite of the direction we are moving in for the cells to be connected. For example, if we are moving one unit to the right, then from the next cell it must be possible to go one unit to the left, otherwise it\\'s not actually connected.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        if not grid:\\n            return true\\n        directions = {1: [(0,-1),(0,1)],\\n                      2: [(-1,0),(1,0)],\\n                      3: [(0,-1),(1,0)],\\n                      4: [(0,1),(1,0)],\\n                      5: [(0,-1),(-1,0)],\\n                      6: [(0,1),(-1,0)]}\\n        visited = set()\\n        goal = (len(grid)-1, len(grid[0]) - 1)\\n        def dfs(i, j):\\n            visited.add((i,j))\\n            if (i,j) == goal:\\n                return True\\n            for d in directions[grid[i][j]]:\\n                ni, nj = i+d[0], j+d[1]\\n                if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and (ni, nj) not in visited and (-d[0], -d[1]) in directions[grid[ni][nj]]:\\n                    if dfs(ni, nj):\\n                        return True\\n            return False\\n        return dfs(0,0)\\n```\n```(-d[0], -d[1]) in directions[grid[ni][nj]]```",
                "codeTag": "Java"
            },
            {
                "id": 553574,
                "title": "java-dfs-solution-clean-code",
                "content": "```java\\npublic class Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        return dfs(grid, m, n, 0, 0, visited);\\n    }\\n    int[][][] DIR = new int[][][]{\\n            {{0, -1}, {0, 1}},\\n            {{-1, 0}, {1, 0}},\\n            {{0, -1}, {1, 0}},\\n            {{0, 1}, {1, 0}},\\n            {{0, -1}, {-1, 0}},\\n            {{-1, 0}, {0, 1}}\\n    };\\n    boolean dfs(int[][] grid, int m, int n, int r, int c, boolean[][] visited) {\\n        if (r == m - 1 && c == n - 1) return true; // Reach bottom-right cell -> Valid path\\n        visited[r][c] = true;\\n        for (int[] nextDir : DIR[grid[r][c] - 1]) {\\n            int nr = r + nextDir[0], nc = c + nextDir[1];\\n            if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) continue;\\n            for (int[] backDir : DIR[grid[nr][nc] - 1]) { // Check next cell can go back to current cell\\n                if (nr + backDir[0] == r && nc + backDir[1] == c) {\\n                    if (dfs(grid, m, n, nr, nc, visited)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nComplexity\\n- Time & Space: `O(m*n)`, where `m` is the number of rows, `n` is the number of columns of `grid`",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        return dfs(grid, m, n, 0, 0, visited);\\n    }\\n    int[][][] DIR = new int[][][]{\\n            {{0, -1}, {0, 1}},\\n            {{-1, 0}, {1, 0}},\\n            {{0, -1}, {1, 0}},\\n            {{0, 1}, {1, 0}},\\n            {{0, -1}, {-1, 0}},\\n            {{-1, 0}, {0, 1}}\\n    };\\n    boolean dfs(int[][] grid, int m, int n, int r, int c, boolean[][] visited) {\\n        if (r == m - 1 && c == n - 1) return true; // Reach bottom-right cell -> Valid path\\n        visited[r][c] = true;\\n        for (int[] nextDir : DIR[grid[r][c] - 1]) {\\n            int nr = r + nextDir[0], nc = c + nextDir[1];\\n            if (nr < 0 || nr >= m || nc < 0 || nc >= n || visited[nr][nc]) continue;\\n            for (int[] backDir : DIR[grid[nr][nc] - 1]) { // Check next cell can go back to current cell\\n                if (nr + backDir[0] == r && nc + backDir[1] == c) {\\n                    if (dfs(grid, m, n, nr, nc, visited)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573840,
                "title": "c-dfs-100-space-and-faster-than-76",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is_valid(int x,int y,vector<vector<int> > &grid)\\n    {\\n        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size())\\n            return 0;\\n        return 1;\\n    }\\n    void dfs(int x,int y,vector<vector<bool> > &visited,vector<vector<int> > &grid){\\n        if(visited[x][y])\\n            return;\\n        visited[x][y] = 1;\\n        int up,down,left,right;\\n        up=down=left=right=0;\\n        if(grid[x][y] == 1)\\n            left=right=1;\\n        else if(grid[x][y] == 2)\\n            up=down=1;\\n        else if(grid[x][y] == 3)\\n            left=down=1;\\n        else if(grid[x][y] == 4)\\n            down=right=1;\\n        else if(grid[x][y] == 5)\\n            up = left = 1;\\n        else\\n            right=up=1;\\n        if(up)\\n        {\\n            int new_x=x-1,new_y=y;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==2 || grid[new_x][new_y]==3 || grid[new_x][new_y]==4))\\n               dfs(new_x,new_y,visited,grid);\\n        }\\n        if(down)\\n        {\\n            int new_x=x+1,new_y=y;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==2 || grid[new_x][new_y]==5 || grid[new_x][new_y]==6))\\n               dfs(new_x,new_y,visited,grid);\\n        }\\n        if(left)\\n       {\\n            int new_x=x,new_y=y-1;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==1 || grid[new_x][new_y]==4 || grid[new_x][new_y]==6))\\n               dfs(new_x,new_y,visited,grid);\\n       }\\n        if(right)\\n       {\\n            int new_x=x,new_y=y+1;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==1 || grid[new_x][new_y]==3 || grid[new_x][new_y]==5))\\n                dfs(new_x,new_y,visited,grid);\\n       }\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(!n)\\n            return 1;\\n        int m = grid[0].size();\\n        vector <vector<bool> > visited(n,vector<bool>(m,0));\\n        dfs(0,0,visited,grid);\\n        return visited[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_valid(int x,int y,vector<vector<int> > &grid)\\n    {\\n        if(x<0 || y<0 || x>=grid.size() || y>=grid[0].size())\\n            return 0;\\n        return 1;\\n    }\\n    void dfs(int x,int y,vector<vector<bool> > &visited,vector<vector<int> > &grid){\\n        if(visited[x][y])\\n            return;\\n        visited[x][y] = 1;\\n        int up,down,left,right;\\n        up=down=left=right=0;\\n        if(grid[x][y] == 1)\\n            left=right=1;\\n        else if(grid[x][y] == 2)\\n            up=down=1;\\n        else if(grid[x][y] == 3)\\n            left=down=1;\\n        else if(grid[x][y] == 4)\\n            down=right=1;\\n        else if(grid[x][y] == 5)\\n            up = left = 1;\\n        else\\n            right=up=1;\\n        if(up)\\n        {\\n            int new_x=x-1,new_y=y;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==2 || grid[new_x][new_y]==3 || grid[new_x][new_y]==4))\\n               dfs(new_x,new_y,visited,grid);\\n        }\\n        if(down)\\n        {\\n            int new_x=x+1,new_y=y;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==2 || grid[new_x][new_y]==5 || grid[new_x][new_y]==6))\\n               dfs(new_x,new_y,visited,grid);\\n        }\\n        if(left)\\n       {\\n            int new_x=x,new_y=y-1;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==1 || grid[new_x][new_y]==4 || grid[new_x][new_y]==6))\\n               dfs(new_x,new_y,visited,grid);\\n       }\\n        if(right)\\n       {\\n            int new_x=x,new_y=y+1;\\n            if(is_valid(new_x,new_y,grid) && (grid[new_x][new_y]==1 || grid[new_x][new_y]==3 || grid[new_x][new_y]==5))\\n                dfs(new_x,new_y,visited,grid);\\n       }\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(!n)\\n            return 1;\\n        int m = grid[0].size();\\n        vector <vector<bool> > visited(n,vector<bool>(m,0));\\n        dfs(0,0,visited,grid);\\n        return visited[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679168,
                "title": "java-just-stupid-enum-cases-not-clean-but-straightforward",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int m=grid.length, n=grid[0].length;\\n        int[][] visited=new int[m][n];\\n        return dfs(grid, 0, 0, m, n, visited);\\n    }\\n    public boolean dfs(int[][] grid, int i, int j, int m, int n, int[][] visited){\\n        if(i==m-1 && j==n-1) return true;\\n        if(i<0 || i>=m || j<0 || j>=n || visited[i][j]==1) return false;\\n        visited[i][j]=1;\\n        if(grid[i][j]==1){\\n            if( (j>0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6) && dfs(grid, i, j-1, m, n, visited)) || \\n\\t\\t\\t    (j<n-1 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5 ) && dfs(grid, i, j+1, m, n, visited) )) return true;\\n        }else if(grid[i][j]==2){\\n            if( (i<m-1 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6) && dfs(grid, i+1, j, m, n, visited)) || \\n                (i>0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4) && dfs(grid, i-1, j, m, n, visited))) return true;\\n        }else if(grid[i][j]==3){\\n            if( (j>0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6) && dfs(grid, i, j-1, m, n, visited)) || \\n\\t\\t\\t    (i<m-1 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6) && dfs(grid, i+1, j, m, n, visited))) return true;\\n        }else if(grid[i][j]==4){\\n            if( ((i<m-1 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)) && dfs(grid, i+1, j, m, n, visited)) || \\n\\t\\t\\t    (j<n-1 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5) && dfs(grid, i, j+1, m, n, visited))) return true;\\n        }else if(grid[i][j]==5){\\n            if( (j>0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6) && dfs(grid, i, j-1, m, n, visited)) || \\n\\t\\t\\t    (i>0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4) && dfs(grid, i-1, j, m, n, visited))) return true;\\n        }else{\\n            if( (i>0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4) && dfs(grid, i-1, j, m, n, visited)) || \\n\\t\\t\\t    (j<n-1 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5) && dfs(grid, i, j+1, m, n, visited))) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int m=grid.length, n=grid[0].length;\\n        int[][] visited=new int[m][n];\\n        return dfs(grid, 0, 0, m, n, visited);\\n    }\\n    public boolean dfs(int[][] grid, int i, int j, int m, int n, int[][] visited){\\n        if(i==m-1 && j==n-1) return true;\\n        if(i<0 || i>=m || j<0 || j>=n || visited[i][j]==1) return false;\\n        visited[i][j]=1;\\n        if(grid[i][j]==1){\\n            if( (j>0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6) && dfs(grid, i, j-1, m, n, visited)) || \\n\\t\\t\\t    (j<n-1 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5 ) && dfs(grid, i, j+1, m, n, visited) )) return true;\\n        }else if(grid[i][j]==2){\\n            if( (i<m-1 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6) && dfs(grid, i+1, j, m, n, visited)) || \\n                (i>0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4) && dfs(grid, i-1, j, m, n, visited))) return true;\\n        }else if(grid[i][j]==3){\\n            if( (j>0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6) && dfs(grid, i, j-1, m, n, visited)) || \\n\\t\\t\\t    (i<m-1 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6) && dfs(grid, i+1, j, m, n, visited))) return true;\\n        }else if(grid[i][j]==4){\\n            if( ((i<m-1 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)) && dfs(grid, i+1, j, m, n, visited)) || \\n\\t\\t\\t    (j<n-1 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5) && dfs(grid, i, j+1, m, n, visited))) return true;\\n        }else if(grid[i][j]==5){\\n            if( (j>0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6) && dfs(grid, i, j-1, m, n, visited)) || \\n\\t\\t\\t    (i>0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4) && dfs(grid, i-1, j, m, n, visited))) return true;\\n        }else{\\n            if( (i>0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4) && dfs(grid, i-1, j, m, n, visited)) || \\n\\t\\t\\t    (j<n-1 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5) && dfs(grid, i, j+1, m, n, visited))) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249569,
                "title": "python-bfs-very-simple",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        \\n        DIRECTIONS = {\\n            1: [(0, -1), (0, 1)],\\n            2: [(-1, 0), (1, 0)],\\n            3: [(0, -1), (1, 0)],\\n            4: [(0, 1), (1, 0)],\\n            5: [(0, -1), (-1, 0)],\\n            6: [(0, 1), (-1, 0)]\\n        }\\n        \\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        def isValidMove(r,c): \\n            return r < ROWS and r >= 0 and c < COLS and c >= 0 and (r,c) not in visited\\n        \\n        \\n        q = deque([(0,0)])\\n        visited = set()\\n        while q:\\n            r,c = q.pop()\\n            \\n            if r == ROWS - 1 and c == COLS - 1:\\n                return True\\n\\n            visited.add((r,c))\\n            s = grid[r][c]\\n\\n            for dr, dc in DIRECTIONS[s]:\\n                nr, nc = r+dr, c+dc\\n                if isValidMove(nr,nc):\\n                    ns = grid[nr][nc]\\n                    if (-dr,-dc) in DIRECTIONS[ns]:\\n                        q.append((nr, nc))\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        \\n        DIRECTIONS = {\\n            1: [(0, -1), (0, 1)],\\n            2: [(-1, 0), (1, 0)],\\n            3: [(0, -1), (1, 0)],\\n            4: [(0, 1), (1, 0)],\\n            5: [(0, -1), (-1, 0)],\\n            6: [(0, 1), (-1, 0)]\\n        }\\n        \\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        def isValidMove(r,c): \\n            return r < ROWS and r >= 0 and c < COLS and c >= 0 and (r,c) not in visited\\n        \\n        \\n        q = deque([(0,0)])\\n        visited = set()\\n        while q:\\n            r,c = q.pop()\\n            \\n            if r == ROWS - 1 and c == COLS - 1:\\n                return True\\n\\n            visited.add((r,c))\\n            s = grid[r][c]\\n\\n            for dr, dc in DIRECTIONS[s]:\\n                nr, nc = r+dr, c+dc\\n                if isValidMove(nr,nc):\\n                    ns = grid[nr][nc]\\n                    if (-dr,-dc) in DIRECTIONS[ns]:\\n                        q.append((nr, nc))\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547633,
                "title": "python-super-easy-idea-just-walk-the-maze-based-on-the-rule",
                "content": "0 means going right, 1 means upwards, 2 means downwards, 3 means going left. \\n\\nAt cell with type 1, you can either enter it with right direction and leave it keeping the same direction, or enter it with left and leave for the left cell. So the rule for cell \\'1\\' is `{0: 0, 3: 3}`, and we can do the same transition rule for the other types.\\n\\nThen we can start walking in the maze. The initial position is (0, 0), and the initial direction can have two cases. If we walk outside of the maze, walk to a visited position or reach a pixel which does not permit the current direction, we exit the loop and return `False`.\\n\\nRuntime: 1460 ms, faster than 87.50% of Python3 online submissions for Check if There is a Valid Path in a Grid.\\nMemory Usage: 27.6 MB, less than 100.00% of Python3 online submissions for Check if There is a Valid Path in a Grid.\\n\\n```\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # dict for transition rule\\n        rules = {\\n            1: {0: 0, 3: 3},\\n            2: {1: 1, 2: 2},\\n            3: {0: 2, 1: 3},\\n            4: {1: 0, 3: 2},\\n            5: {0: 1, 2: 3},\\n            6: {2: 0, 3: 1},\\n        }\\n        \\n        # dict for update rule\\n        moves = {\\n            0: (0, 1),\\n            1: (-1, 0),\\n            2: (1, 0),\\n            3: (0, -1),\\n        }\\n        \\n        x, y = (0, 0)\\n        k = grid[0][0]\\n        d = list(rules[k].keys())\\n        d1, d2 = d[0], d[1]\\n        \\n        def walkMaze(x, y, d):\\n            visited = set([(x, y)])\\n            while True:\\n                if x < 0 or x >= m or y < 0 or y >= n:\\n                    return False\\n                \\n                k = grid[x][y]\\n                if d not in rules[k]:\\n                    return False\\n                \\n                if (x, y) == (m - 1, n - 1):\\n                    return True\\n                \\n                d = rules[k][d]\\n                x, y = (x + moves[d][0], y + moves[d][1])\\n                if (x, y) in visited: # there is a loop\\n                    return False\\n                visited.add((x, y))\\n        \\n        return walkMaze(x, y, d1) or walkMaze(x, y, d2)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # dict for transition rule\\n        rules = {\\n            1: {0: 0, 3: 3},\\n            2: {1: 1, 2: 2},\\n            3: {0: 2, 1: 3},\\n            4: {1: 0, 3: 2},\\n            5: {0: 1, 2: 3},\\n            6: {2: 0, 3: 1},\\n        }\\n        \\n        # dict for update rule\\n        moves = {\\n            0: (0, 1),\\n            1: (-1, 0),\\n            2: (1, 0),\\n            3: (0, -1),\\n        }\\n        \\n        x, y = (0, 0)\\n        k = grid[0][0]\\n        d = list(rules[k].keys())\\n        d1, d2 = d[0], d[1]\\n        \\n        def walkMaze(x, y, d):\\n            visited = set([(x, y)])\\n            while True:\\n                if x < 0 or x >= m or y < 0 or y >= n:\\n                    return False\\n                \\n                k = grid[x][y]\\n                if d not in rules[k]:\\n                    return False\\n                \\n                if (x, y) == (m - 1, n - 1):\\n                    return True\\n                \\n                d = rules[k][d]\\n                x, y = (x + moves[d][0], y + moves[d][1])\\n                if (x, y) in visited: # there is a loop\\n                    return False\\n                visited.add((x, y))\\n        \\n        return walkMaze(x, y, d1) or walkMaze(x, y, d2)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 617817,
                "title": "c-dfs-solution",
                "content": "```\\nCredits to :-https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/discuss/573840/C%2B%2B-DFS-100-Space-and-Faster-than-76\\n\\nWe will be solving w be solving this using dfs.\\n\\nOur idea of solving will be to start from top left corner and work ourselves to the bottom right corner.\\n\\nWe keep a visited boolean array that tells about each cell wether it is visited or not.\\nAll we want to do in this question is to check if the bottommost right cell is visited or not.\\n\\nclass Solution {\\npublic:\\n    bool isvalid(int x,int y,vector<vector<int>> &grid)                //This is a boolean function to check we are within the matrix.\\n    {\\n        if(x<0||y<0||x>=grid.size()||y>=grid[0].size())return false;\\n        return true;\\n    }\\n    void dfs(int x,int y,vector<vector<bool>> &vis,vector<vector<int>> &grid)\\n    {\\n        if(vis[x][y])return;                //We dont want to backtrack our visited steps\\n        vis[x][y]=true;\\n        int up,down,left,right;\\n        up=down=left=right=0;                //These are intuitiv just look at the diagram \\n        if(grid[x][y]==1)\\n            left=right=1;\\n        else if(grid[x][y]==2)\\n            up=down=1;\\n        else if(grid[x][y]==3)\\n            left=down=1;\\n        else if(grid[x][y]==4)\\n            down=right=1;\\n        else if(grid[x][y]==5)\\n            left=up=1;\\n        else\\n            up=right=1;\\n        if(up)\\n        {\\n            int new_x=x-1,new_y=y;            //Think this in terms of the matrix and not the routes.I can go up a cell means i can go up a row which mean i-1\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==2||grid[new_x][new_y]==3||grid[new_x][new_y]==4))  //The way to get the second part of the if case is to check from my current cell what all routes will allow me to go up\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n        if(down)\\n        {\\n            int new_x=x+1,new_y=y;\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==2||grid[new_x][new_y]==5||grid[new_x][new_y]==6))\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n        if(right)\\n        {\\n            int new_x=x,new_y=y+1;\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==1||grid[new_x][new_y]==5||grid[new_x][new_y]==3))\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n        if(left)\\n        {\\n            int new_x=x,new_y=y-1;\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==1||grid[new_x][new_y]==4||grid[new_x][new_y]==6))\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(n==0)return false;\\n        int m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));           //Boolean array with the size of grid checking if a cell is visited or not\\n        dfs(0,0,vis,grid);                                           //We start our dfs function from top left corner and work ourselves to the bottom right corner.\\n        return vis[n-1][m-1];                                       //All we care about is if the last cell is visited or not.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nCredits to :-https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/discuss/573840/C%2B%2B-DFS-100-Space-and-Faster-than-76\\n\\nWe will be solving w be solving this using dfs.\\n\\nOur idea of solving will be to start from top left corner and work ourselves to the bottom right corner.\\n\\nWe keep a visited boolean array that tells about each cell wether it is visited or not.\\nAll we want to do in this question is to check if the bottommost right cell is visited or not.\\n\\nclass Solution {\\npublic:\\n    bool isvalid(int x,int y,vector<vector<int>> &grid)                //This is a boolean function to check we are within the matrix.\\n    {\\n        if(x<0||y<0||x>=grid.size()||y>=grid[0].size())return false;\\n        return true;\\n    }\\n    void dfs(int x,int y,vector<vector<bool>> &vis,vector<vector<int>> &grid)\\n    {\\n        if(vis[x][y])return;                //We dont want to backtrack our visited steps\\n        vis[x][y]=true;\\n        int up,down,left,right;\\n        up=down=left=right=0;                //These are intuitiv just look at the diagram \\n        if(grid[x][y]==1)\\n            left=right=1;\\n        else if(grid[x][y]==2)\\n            up=down=1;\\n        else if(grid[x][y]==3)\\n            left=down=1;\\n        else if(grid[x][y]==4)\\n            down=right=1;\\n        else if(grid[x][y]==5)\\n            left=up=1;\\n        else\\n            up=right=1;\\n        if(up)\\n        {\\n            int new_x=x-1,new_y=y;            //Think this in terms of the matrix and not the routes.I can go up a cell means i can go up a row which mean i-1\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==2||grid[new_x][new_y]==3||grid[new_x][new_y]==4))  //The way to get the second part of the if case is to check from my current cell what all routes will allow me to go up\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n        if(down)\\n        {\\n            int new_x=x+1,new_y=y;\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==2||grid[new_x][new_y]==5||grid[new_x][new_y]==6))\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n        if(right)\\n        {\\n            int new_x=x,new_y=y+1;\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==1||grid[new_x][new_y]==5||grid[new_x][new_y]==3))\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n        if(left)\\n        {\\n            int new_x=x,new_y=y-1;\\n            if(isvalid(new_x,new_y,grid) && (grid[new_x][new_y]==1||grid[new_x][new_y]==4||grid[new_x][new_y]==6))\\n                dfs(new_x,new_y,vis,grid);\\n        }\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(n==0)return false;\\n        int m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));           //Boolean array with the size of grid checking if a cell is visited or not\\n        dfs(0,0,vis,grid);                                           //We start our dfs function from top left corner and work ourselves to the bottom right corner.\\n        return vis[n-1][m-1];                                       //All we care about is if the last cell is visited or not.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775048,
                "title": "play-the-game-dfs-solution-the-most-readable-solution-you-re-going-to-find",
                "content": "I was bored so I wanted to make something out of an annoying problem.\\n\\nAt each cell in the board i,j, we test to see two things, we can move in each direction, and for each direction that we can move in, if the piece there can accept us from moving in that direction. \\n\\nNow this is more like playing a game, rather than a coding exercise.\\n\\nThe hash table moveTo notes who can move up right down left, and acceptFrom denotes the pieces which can accept someone incoming from up right down and left.\\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[int]]) -> bool:\\n        if not A:\\n            return True\\n        m, n = len(A), len(A[0])\\n        visited = [[False]*n for _ in range(m)]\\n        moveTo = {\\n            \"up\": {2,5,6},\\n            \"right\": {1,4,6},\\n            \"down\": {2,3,4},\\n            \"left\" : {1,3,5}\\n        }\\n        acceptFrom = {\\n            \"up\": {2,3,4},\\n            \"right\": {1,3,5},\\n            \"down\": {2,5,6},\\n            \"left\": {1,4,6}\\n        }\\n        def inBound(i,j):\\n            return 0 <= i and i <= m-1 and 0 <= j and j <= n-1\\n        def dfs(i,j):\\n            if visited[i][j]:   return False\\n            if i == m-1 and j == n-1:   return True\\n            visited[i][j] = True\\n            curr = A[i][j]\\n            up = A[i-1][j] if inBound(i-1,j) else False\\n            right = A[i][j+1] if inBound(i,j+1) else False\\n            down = A[i+1][j] if inBound(i+1,j) else False\\n            left = A[i][j-1] if inBound(i,j-1) else False\\n            possible = False\\n            if not possible and curr in moveTo[\"up\"] and up and up in acceptFrom[\"up\"]:\\n                possible = dfs(i-1, j)\\n            if not possible and curr in moveTo[\"right\"] and right and right in acceptFrom[\"right\"]:\\n                possible = dfs(i, j+1)\\n            if not possible and curr in moveTo[\"down\"] and down and down in acceptFrom[\"down\"]:\\n                possible = dfs(i+1,j)\\n            if not possible and curr in moveTo[\"left\"] and left and left in acceptFrom[\"left\"]:\\n                possible = dfs(i,j-1)\\n            return possible\\n        return dfs(0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[int]]) -> bool:\\n        if not A:\\n            return True\\n        m, n = len(A), len(A[0])\\n        visited = [[False]*n for _ in range(m)]\\n        moveTo = {\\n            \"up\": {2,5,6},\\n            \"right\": {1,4,6},\\n            \"down\": {2,3,4},\\n            \"left\" : {1,3,5}\\n        }\\n        acceptFrom = {\\n            \"up\": {2,3,4},\\n            \"right\": {1,3,5},\\n            \"down\": {2,5,6},\\n            \"left\": {1,4,6}\\n        }\\n        def inBound(i,j):\\n            return 0 <= i and i <= m-1 and 0 <= j and j <= n-1\\n        def dfs(i,j):\\n            if visited[i][j]:   return False\\n            if i == m-1 and j == n-1:   return True\\n            visited[i][j] = True\\n            curr = A[i][j]\\n            up = A[i-1][j] if inBound(i-1,j) else False\\n            right = A[i][j+1] if inBound(i,j+1) else False\\n            down = A[i+1][j] if inBound(i+1,j) else False\\n            left = A[i][j-1] if inBound(i,j-1) else False\\n            possible = False\\n            if not possible and curr in moveTo[\"up\"] and up and up in acceptFrom[\"up\"]:\\n                possible = dfs(i-1, j)\\n            if not possible and curr in moveTo[\"right\"] and right and right in acceptFrom[\"right\"]:\\n                possible = dfs(i, j+1)\\n            if not possible and curr in moveTo[\"down\"] and down and down in acceptFrom[\"down\"]:\\n                possible = dfs(i+1,j)\\n            if not possible and curr in moveTo[\"left\"] and left and left in acceptFrom[\"left\"]:\\n                possible = dfs(i,j-1)\\n            return possible\\n        return dfs(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551075,
                "title": "java-concise-dfs-solution",
                "content": "If I can receive from right, I can give to left as well. If I receive from up, I give it to down as well.\\n```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int rows = grid.length , cols = grid[0].length;\\n        boolean[][] vis = new boolean[rows][cols];\\n        Map<Integer,Set<Character>> map = new HashMap<>();\\n        map.put(1,new HashSet<>(Arrays.asList(\\'L\\',\\'R\\')));\\n        map.put(2,new HashSet<>(Arrays.asList(\\'U\\',\\'D\\')));\\n        map.put(3,new HashSet<>(Arrays.asList(\\'R\\',\\'U\\')));\\n        map.put(4,new HashSet<>(Arrays.asList(\\'L\\',\\'U\\')));\\n        map.put(5,new HashSet<>(Arrays.asList(\\'R\\',\\'D\\')));\\n        map.put(6,new HashSet<>(Arrays.asList(\\'L\\',\\'D\\')));\\n        return dfs(grid,0,0,rows,cols,map,\\'~\\',vis);\\n    }\\n    \\n    private boolean dfs(int[][] grid,int x,int y,int rows,int cols,Map<Integer,Set<Character>> map,char dir,boolean[][] vis){\\n        if(x == rows || x < 0 || y == cols || y < 0 || vis[x][y] || dir != \\'~\\' && !map.get(grid[x][y]).contains(dir)) return false;\\n        if(x == rows-1 && y == cols-1) return true;\\n        vis[x][y] = true;\\n        if(map.get(grid[x][y]).contains(\\'L\\') && dfs(grid,x,y+1,rows,cols,map,\\'R\\',vis)) return true;\\n        if(map.get(grid[x][y]).contains(\\'R\\') && dfs(grid,x,y-1,rows,cols,map,\\'L\\',vis)) return true;\\n        if(map.get(grid[x][y]).contains(\\'U\\') && dfs(grid,x+1,y,rows,cols,map,\\'D\\',vis)) return true;\\n        if(map.get(grid[x][y]).contains(\\'D\\') && dfs(grid,x-1,y,rows,cols,map,\\'U\\',vis)) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int rows = grid.length , cols = grid[0].length;\\n        boolean[][] vis = new boolean[rows][cols];\\n        Map<Integer,Set<Character>> map = new HashMap<>();\\n        map.put(1,new HashSet<>(Arrays.asList(\\'L\\',\\'R\\')));\\n        map.put(2,new HashSet<>(Arrays.asList(\\'U\\',\\'D\\')));\\n        map.put(3,new HashSet<>(Arrays.asList(\\'R\\',\\'U\\')));\\n        map.put(4,new HashSet<>(Arrays.asList(\\'L\\',\\'U\\')));\\n        map.put(5,new HashSet<>(Arrays.asList(\\'R\\',\\'D\\')));\\n        map.put(6,new HashSet<>(Arrays.asList(\\'L\\',\\'D\\')));\\n        return dfs(grid,0,0,rows,cols,map,\\'~\\',vis);\\n    }\\n    \\n    private boolean dfs(int[][] grid,int x,int y,int rows,int cols,Map<Integer,Set<Character>> map,char dir,boolean[][] vis){\\n        if(x == rows || x < 0 || y == cols || y < 0 || vis[x][y] || dir != \\'~\\' && !map.get(grid[x][y]).contains(dir)) return false;\\n        if(x == rows-1 && y == cols-1) return true;\\n        vis[x][y] = true;\\n        if(map.get(grid[x][y]).contains(\\'L\\') && dfs(grid,x,y+1,rows,cols,map,\\'R\\',vis)) return true;\\n        if(map.get(grid[x][y]).contains(\\'R\\') && dfs(grid,x,y-1,rows,cols,map,\\'L\\',vis)) return true;\\n        if(map.get(grid[x][y]).contains(\\'U\\') && dfs(grid,x+1,y,rows,cols,map,\\'D\\',vis)) return true;\\n        if(map.get(grid[x][y]).contains(\\'D\\') && dfs(grid,x-1,y,rows,cols,map,\\'U\\',vis)) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310590,
                "title": "c-easiest-bfs-solution-with-constant-space",
                "content": "# Intuition\\nWe can move from one cell to the other 4 possible cells only if they are not visited already and there exist the path in between them .\\n\\n# Approach\\nWe will be using Breadth First Search Approach \\nFor that we need to remember that from a current type of path, on what types of path can we move to if we go in left direction , right , up or down each .\\n\\nFor that we use 3D Vector mp where mp[i][j][k] denotes , that from path i if we go in direction j , then can we reach on path k or not?\\n\\nwhere 1 <= i , k <= 7; \\n       0 <= j <= 3;\\nj = 0 denotes -> Left Direction \\nj = 1 denotes -> Right Direction \\nj = 2 denotes -> UpWards \\nj = 3 denotes -> Downwards \\n\\nFor ex , mp[4][1][3] is true as we can move from path 4 to path 3 bygoing right direction\\n\\nSimilarly mp[1][3][2] is false because we can move from path 1 to path 2 by going downwards.\\n\\nWe start from cell (0,0) by pushing it into q and to mark it visited we multiply its value with -1 so that we can remember the path type and also mark it visted at the same time .\\n\\n// If somehow you find this solution helpful an Upvote will ve appreciated .\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int m , n;\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        grid[0][0] = -grid[0][0];\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        vector<vector<vector<int>>> mp(7, vector<vector<int>> (4 , vector<int>(7, 0)));\\n\\n        // 1 , 0\\n        mp[1][0][1] = 1;\\n        mp[1][0][4] = 1;\\n        mp[1][0][6] = 1;\\n\\n        // 1 , 1\\n        mp[1][1][1] = 1;\\n        mp[1][1][3] = 1;\\n        mp[1][1][5] = 1;\\n\\n        // 2 , 2\\n        mp[2][2][2] = 1;\\n        mp[2][2][3] = 1;\\n        mp[2][2][4] = 1;\\n\\n        // 2 , 3\\n        mp[2][3][2] = 1;\\n        mp[2][3][5] = 1;\\n        mp[2][3][6] = 1;\\n\\n        //3 0\\n        mp[3][0][1] = 1;\\n        mp[3][0][4] = 1;\\n        mp[3][0][6] = 1;\\n\\n        //3 3\\n        mp[3][3][2] = 1;\\n        mp[3][3][5] = 1;\\n        mp[3][3][6] = 1;\\n        \\n        // 4 1\\n        mp[4][1][1] = 1;\\n        mp[4][1][3] = 1;\\n        mp[4][1][5] = 1;\\n        \\n\\n        // 4 3\\n        mp[4][3][2] = 1;\\n        mp[4][3][5] = 1;\\n        mp[4][3][6] = 1;\\n\\n        // 5 0\\n        mp[5][0][1] = 1;\\n        mp[5][0][4] = 1;\\n        mp[5][0][6] = 1;\\n\\n        // 5 2\\n        mp[5][2][2] = 1;\\n        mp[5][2][2] = 1;\\n        mp[5][2][4] = 1;\\n\\n        // 6 1\\n        mp[6][1][1] = 1;\\n        mp[6][1][3] = 1;\\n        mp[6][1][5] = 1;\\n\\n        // 6 2\\n        mp[6][2][2] = 1;\\n        mp[6][2][3] = 1;\\n        mp[6][2][4] = 1;\\n\\n\\n        while(!q.empty())\\n        {\\n               int x = q.front().first;\\n               int y = q.front().second;\\n               int pos = -grid[x][y];\\n               q.pop();\\n\\n               if(x == m-1 && y == n-1)\\n               return true;\\n               \\n               // 0  -> Left       \\n               if(y-1>=0)\\n               {\\n                   if(grid[x][y-1] > 0 && mp[pos][0][grid[x][y-1]])\\n                   {\\n                       q.push({x,y-1});\\n                       grid[x][y-1] = -grid[x][y-1];\\n                   }               \\n                }   \\n\\n               // 1  -> Right\\n               if(y+1 < n)\\n               {\\n                   if(grid[x][y+1] > 0 && mp[pos][1][grid[x][y+1]])\\n                   {\\n                       q.push({x,y+1});\\n                       grid[x][y+1] = -grid[x][y+1];\\n                   }               \\n                }   \\n\\n               // 2   -> Up\\n               if(x-1>=0)\\n               {\\n                   if(grid[x-1][y] > 0 && mp[pos][2][grid[x-1][y]])\\n                   {\\n                       q.push({x-1,y});\\n                       grid[x-1][y] = -grid[x-1][y];\\n                   }\\n               }   \\n\\n               // 3   ->  Down     \\n               if(x+1<m)\\n               {\\n                   if(grid[x+1][y] > 0 && mp[pos][3][grid[x+1][y]])\\n                   {\\n                       q.push({x+1,y});\\n                       grid[x+1][y] = -grid[x+1][y];\\n                   }               \\n                }   \\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int m , n;\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        grid[0][0] = -grid[0][0];\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        vector<vector<vector<int>>> mp(7, vector<vector<int>> (4 , vector<int>(7, 0)));\\n\\n        // 1 , 0\\n        mp[1][0][1] = 1;\\n        mp[1][0][4] = 1;\\n        mp[1][0][6] = 1;\\n\\n        // 1 , 1\\n        mp[1][1][1] = 1;\\n        mp[1][1][3] = 1;\\n        mp[1][1][5] = 1;\\n\\n        // 2 , 2\\n        mp[2][2][2] = 1;\\n        mp[2][2][3] = 1;\\n        mp[2][2][4] = 1;\\n\\n        // 2 , 3\\n        mp[2][3][2] = 1;\\n        mp[2][3][5] = 1;\\n        mp[2][3][6] = 1;\\n\\n        //3 0\\n        mp[3][0][1] = 1;\\n        mp[3][0][4] = 1;\\n        mp[3][0][6] = 1;\\n\\n        //3 3\\n        mp[3][3][2] = 1;\\n        mp[3][3][5] = 1;\\n        mp[3][3][6] = 1;\\n        \\n        // 4 1\\n        mp[4][1][1] = 1;\\n        mp[4][1][3] = 1;\\n        mp[4][1][5] = 1;\\n        \\n\\n        // 4 3\\n        mp[4][3][2] = 1;\\n        mp[4][3][5] = 1;\\n        mp[4][3][6] = 1;\\n\\n        // 5 0\\n        mp[5][0][1] = 1;\\n        mp[5][0][4] = 1;\\n        mp[5][0][6] = 1;\\n\\n        // 5 2\\n        mp[5][2][2] = 1;\\n        mp[5][2][2] = 1;\\n        mp[5][2][4] = 1;\\n\\n        // 6 1\\n        mp[6][1][1] = 1;\\n        mp[6][1][3] = 1;\\n        mp[6][1][5] = 1;\\n\\n        // 6 2\\n        mp[6][2][2] = 1;\\n        mp[6][2][3] = 1;\\n        mp[6][2][4] = 1;\\n\\n\\n        while(!q.empty())\\n        {\\n               int x = q.front().first;\\n               int y = q.front().second;\\n               int pos = -grid[x][y];\\n               q.pop();\\n\\n               if(x == m-1 && y == n-1)\\n               return true;\\n               \\n               // 0  -> Left       \\n               if(y-1>=0)\\n               {\\n                   if(grid[x][y-1] > 0 && mp[pos][0][grid[x][y-1]])\\n                   {\\n                       q.push({x,y-1});\\n                       grid[x][y-1] = -grid[x][y-1];\\n                   }               \\n                }   \\n\\n               // 1  -> Right\\n               if(y+1 < n)\\n               {\\n                   if(grid[x][y+1] > 0 && mp[pos][1][grid[x][y+1]])\\n                   {\\n                       q.push({x,y+1});\\n                       grid[x][y+1] = -grid[x][y+1];\\n                   }               \\n                }   \\n\\n               // 2   -> Up\\n               if(x-1>=0)\\n               {\\n                   if(grid[x-1][y] > 0 && mp[pos][2][grid[x-1][y]])\\n                   {\\n                       q.push({x-1,y});\\n                       grid[x-1][y] = -grid[x-1][y];\\n                   }\\n               }   \\n\\n               // 3   ->  Down     \\n               if(x+1<m)\\n               {\\n                   if(grid[x+1][y] > 0 && mp[pos][3][grid[x+1][y]])\\n                   {\\n                       q.push({x+1,y});\\n                       grid[x+1][y] = -grid[x+1][y];\\n                   }               \\n                }   \\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531370,
                "title": "c-dfs",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    map<int,set<pair<int,int>>> dxy; // directions in which we can move from particular cell value\\n    \\n    bool solve(vector<vector<int>>& grid, int i, int j, vector<vector<bool>> &visited){\\n        int n=grid.size(), m=grid[0].size();\\n        if(i==n-1 && j==m-1) return true;\\n        visited[i][j]=true;\\n        \\n        set<pair<int,int>> st=dxy[grid[i][j]];\\n        set<pair<int,int>> :: iterator it;\\n        for(it=st.begin();it!=st.end();it++){\\n            int d1=it->first, d2=it->second;\\n            int x=i+d1, y=j+d2; // next cell position\\n            if(x>=0 && y>=0 && x<n && y<m && visited[x][y]==false){\\n                int next=grid[x][y];\\n\\t\\t\\t\\t// we also need to check that it possible to reach back to cuurent cell from next cell for valid move\\n                if(dxy[next].find({-d1,-d2})!=dxy[next].end() && solve(grid,x,y,visited)) return true; \\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n\\t\\t\\n        dxy[1].insert({{0,-1},{0,1}});\\n        dxy[2].insert({{-1,0},{1,0}});\\n        dxy[3].insert({{0,-1},{1,0}});\\n        dxy[4].insert({{0,1},{1,0}});\\n        dxy[5].insert({{-1,0},{0,-1}});\\n        dxy[6].insert({{-1,0},{0,1}});\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        return solve(grid,0,0,visited);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    map<int,set<pair<int,int>>> dxy; // directions in which we can move from particular cell value\\n    \\n    bool solve(vector<vector<int>>& grid, int i, int j, vector<vector<bool>> &visited){\\n        int n=grid.size(), m=grid[0].size();\\n        if(i==n-1 && j==m-1) return true;\\n        visited[i][j]=true;\\n        \\n        set<pair<int,int>> st=dxy[grid[i][j]];\\n        set<pair<int,int>> :: iterator it;\\n        for(it=st.begin();it!=st.end();it++){\\n            int d1=it->first, d2=it->second;\\n            int x=i+d1, y=j+d2; // next cell position\\n            if(x>=0 && y>=0 && x<n && y<m && visited[x][y]==false){\\n                int next=grid[x][y];\\n\\t\\t\\t\\t// we also need to check that it possible to reach back to cuurent cell from next cell for valid move\\n                if(dxy[next].find({-d1,-d2})!=dxy[next].end() && solve(grid,x,y,visited)) return true; \\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n\\t\\t\\n        dxy[1].insert({{0,-1},{0,1}});\\n        dxy[2].insert({{-1,0},{1,0}});\\n        dxy[3].insert({{0,-1},{1,0}});\\n        dxy[4].insert({{0,1},{1,0}});\\n        dxy[5].insert({{-1,0},{0,-1}});\\n        dxy[6].insert({{-1,0},{0,1}});\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        return solve(grid,0,0,visited);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602788,
                "title": "easy-to-understand-dsu-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799828,
                "title": "dfs-c-very-naive-solution-nice-problem-w-nice-solution",
                "content": "Please Upvote :)\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Travel each cell if it can be entered and unvisited.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Basic dfs \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n * m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(2 * ( n * m ))\\n# Code\\n```\\nclass Solution {\\n    int n,m;\\n    bool vis[305][305];\\n    vector<vector<int>>g;\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        g = grid;\\n        memset(vis, false, sizeof(vis));\\n        dfs(0,0);\\n        return vis[n-1][m-1];\\n    }\\n\\n    void dfs(int ux, int uy){\\n        vis[ux][uy]=true;\\n        int vx,vy;\\n\\n        if(g[ux][uy] == 1 || g[ux][uy]==4 || g[ux][uy]==6) {vx=ux, vy=uy+1; if(valid(vx, vy) && L_enter(vx,vy)) dfs(vx, vy);}\\n        if(g[ux][uy] == 1 || g[ux][uy]==3 || g[ux][uy]==5) {vx=ux, vy=uy-1; if(valid(vx, vy) && R_enter(vx,vy)) dfs(vx, vy);}\\n        if(g[ux][uy] == 2 || g[ux][uy]==3 || g[ux][uy]==4) {vx=ux+1, vy=uy; if(valid(vx, vy) && D_enter(vx,vy)) dfs(vx, vy);}\\n        if(g[ux][uy] == 2 || g[ux][uy]==5 || g[ux][uy]==6) {vx=ux-1, vy=uy; if(valid(vx, vy) && U_enter(vx,vy)) dfs(vx, vy);} \\n\\n    }\\n    bool valid(int x , int y){\\n        if(x>=0 && y>=0 && x<n && y<m && !vis[x][y] ) return true;\\n        return false;\\n    }\\n    bool L_enter(int x, int y){\\n        if(g[x][y]%2) return true;\\n        return false;\\n    }\\n    bool R_enter(int x, int y){\\n        if(g[x][y]==1 || g[x][y]==4 || g[x][y]==6) return true;\\n        return false;\\n    }\\n    bool D_enter(int x, int y)\\n    {\\n        if(g[x][y]==2 || g[x][y]==5 || g[x][y]==6) return true;\\n        return false;\\n    }\\n     bool U_enter(int x, int y)\\n    {\\n        if(g[x][y]==2 || g[x][y]==3 || g[x][y]==4) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int n,m;\\n    bool vis[305][305];\\n    vector<vector<int>>g;\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        g = grid;\\n        memset(vis, false, sizeof(vis));\\n        dfs(0,0);\\n        return vis[n-1][m-1];\\n    }\\n\\n    void dfs(int ux, int uy){\\n        vis[ux][uy]=true;\\n        int vx,vy;\\n\\n        if(g[ux][uy] == 1 || g[ux][uy]==4 || g[ux][uy]==6) {vx=ux, vy=uy+1; if(valid(vx, vy) && L_enter(vx,vy)) dfs(vx, vy);}\\n        if(g[ux][uy] == 1 || g[ux][uy]==3 || g[ux][uy]==5) {vx=ux, vy=uy-1; if(valid(vx, vy) && R_enter(vx,vy)) dfs(vx, vy);}\\n        if(g[ux][uy] == 2 || g[ux][uy]==3 || g[ux][uy]==4) {vx=ux+1, vy=uy; if(valid(vx, vy) && D_enter(vx,vy)) dfs(vx, vy);}\\n        if(g[ux][uy] == 2 || g[ux][uy]==5 || g[ux][uy]==6) {vx=ux-1, vy=uy; if(valid(vx, vy) && U_enter(vx,vy)) dfs(vx, vy);} \\n\\n    }\\n    bool valid(int x , int y){\\n        if(x>=0 && y>=0 && x<n && y<m && !vis[x][y] ) return true;\\n        return false;\\n    }\\n    bool L_enter(int x, int y){\\n        if(g[x][y]%2) return true;\\n        return false;\\n    }\\n    bool R_enter(int x, int y){\\n        if(g[x][y]==1 || g[x][y]==4 || g[x][y]==6) return true;\\n        return false;\\n    }\\n    bool D_enter(int x, int y)\\n    {\\n        if(g[x][y]==2 || g[x][y]==5 || g[x][y]==6) return true;\\n        return false;\\n    }\\n     bool U_enter(int x, int y)\\n    {\\n        if(g[x][y]==2 || g[x][y]==3 || g[x][y]==4) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993874,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(vector<vector<int>>& grid, int i ,int j, int m, int n)\\n    {\\n        if(i == m-1 && j == n-1) return true;\\n        \\n        if(grid[i][j] == 0) return false;\\n        \\n        if(grid[i][j] == 1)\\n        {\\n            grid[i][j] = 0;\\n            return ((j > 0 && (grid[i][j-1] == 4 || grid[i][j-1] == 6 || grid[i][j-1] == 1) && dfs(grid,i,j-1,m,n)) ||\\n                    j < n-1 && (grid[i][j+1] == 3 || grid[i][j+1] == 5 || grid[i][j+1] == 1) && dfs(grid,i,j+1,m,n));\\n        }\\n        else if(grid[i][j] == 2)\\n        {\\n            grid[i][j] = 0;\\n            return ((i > 0 && (grid[i-1][j] == 3 || grid[i-1][j] == 4 || grid[i-1][j] == 2) && dfs(grid,i-1,j,m,n)) ||\\n                    i < m-1 && (grid[i+1][j] == 5 || grid[i+1][j] == 6 || grid[i+1][j] == 2) && dfs(grid,i+1,j,m,n));\\n        }\\n        else if(grid[i][j] == 3)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j > 0 && (grid[i][j-1] == 4 || grid[i][j-1] == 6 || grid[i][j-1] == 1) && dfs(grid,i,j-1,m,n)) ||\\n                    i < m-1 && (grid[i+1][j] == 5 || grid[i+1][j] == 6 ||grid[i+1][j] == 2) && dfs(grid,i+1,j,m,n));\\n        }\\n        else if(grid[i][j] == 4)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j < n-1 && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) && dfs(grid,i,j+1,m,n)) ||\\n                    i < m-1 && (grid[i+1][j] == 5 || grid[i+1][j] == 6 || grid[i+1][j] == 2) && dfs(grid,i+1,j,m,n));\\n        }\\n        else if(grid[i][j] == 5)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j > 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) && dfs(grid,i,j-1,m,n)) ||\\n                    i > 0 && (grid[i-1][j] == 3 || grid[i-1][j] == 4 || grid[i-1][j] == 2) && dfs(grid,i-1,j,m,n));\\n        \\n        }\\n        else if(grid[i][j] == 6)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j < n-1 && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) && dfs(grid,i,j+1,m,n)) ||\\n                    i > 0 && (grid[i-1][j] == 4 || grid[i-1][j] == 3 || grid[i-1][j] == 2) && dfs(grid,i-1,j,m,n));\\n        \\n        }\\n        else\\n        {\\n            grid[i][j] = 0;    \\n            return false;\\n         }    \\n    }    \\n    \\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        \\n        return dfs(grid,0,0,grid.size(), grid[0].size());\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(vector<vector<int>>& grid, int i ,int j, int m, int n)\\n    {\\n        if(i == m-1 && j == n-1) return true;\\n        \\n        if(grid[i][j] == 0) return false;\\n        \\n        if(grid[i][j] == 1)\\n        {\\n            grid[i][j] = 0;\\n            return ((j > 0 && (grid[i][j-1] == 4 || grid[i][j-1] == 6 || grid[i][j-1] == 1) && dfs(grid,i,j-1,m,n)) ||\\n                    j < n-1 && (grid[i][j+1] == 3 || grid[i][j+1] == 5 || grid[i][j+1] == 1) && dfs(grid,i,j+1,m,n));\\n        }\\n        else if(grid[i][j] == 2)\\n        {\\n            grid[i][j] = 0;\\n            return ((i > 0 && (grid[i-1][j] == 3 || grid[i-1][j] == 4 || grid[i-1][j] == 2) && dfs(grid,i-1,j,m,n)) ||\\n                    i < m-1 && (grid[i+1][j] == 5 || grid[i+1][j] == 6 || grid[i+1][j] == 2) && dfs(grid,i+1,j,m,n));\\n        }\\n        else if(grid[i][j] == 3)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j > 0 && (grid[i][j-1] == 4 || grid[i][j-1] == 6 || grid[i][j-1] == 1) && dfs(grid,i,j-1,m,n)) ||\\n                    i < m-1 && (grid[i+1][j] == 5 || grid[i+1][j] == 6 ||grid[i+1][j] == 2) && dfs(grid,i+1,j,m,n));\\n        }\\n        else if(grid[i][j] == 4)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j < n-1 && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) && dfs(grid,i,j+1,m,n)) ||\\n                    i < m-1 && (grid[i+1][j] == 5 || grid[i+1][j] == 6 || grid[i+1][j] == 2) && dfs(grid,i+1,j,m,n));\\n        }\\n        else if(grid[i][j] == 5)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j > 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) && dfs(grid,i,j-1,m,n)) ||\\n                    i > 0 && (grid[i-1][j] == 3 || grid[i-1][j] == 4 || grid[i-1][j] == 2) && dfs(grid,i-1,j,m,n));\\n        \\n        }\\n        else if(grid[i][j] == 6)\\n        {\\n            \\n            grid[i][j] = 0;\\n            return ((j < n-1 && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) && dfs(grid,i,j+1,m,n)) ||\\n                    i > 0 && (grid[i-1][j] == 4 || grid[i-1][j] == 3 || grid[i-1][j] == 2) && dfs(grid,i-1,j,m,n));\\n        \\n        }\\n        else\\n        {\\n            grid[i][j] = 0;    \\n            return false;\\n         }    \\n    }    \\n    \\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        \\n        return dfs(grid,0,0,grid.size(), grid[0].size());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408547,
                "title": "standard-java-solution",
                "content": "### Theory\\nThis is a standard DFS problem. Build out your directions matrix or mappings, then initiate a DFS from the first square. Whats unique to this problem is that you have to make sure the roads connect back to the previous cell. I actually completley forgot about this use case ;)\\n\\n### Solution\\n```\\n    private static Map<Integer, Integer[][]> map;\\n    static {\\n        Map<Integer, Integer[][]> aMap = new HashMap();\\n        aMap.put(1, new Integer[][] {{0,-1}, {0, 1}});\\n        aMap.put(2, new Integer[][] {{1, 0}, {-1,0}});\\n        aMap.put(3, new Integer[][] {{0,-1}, {1, 0}});\\n        aMap.put(4, new Integer[][] {{0, 1}, {1, 0}});\\n        aMap.put(5, new Integer[][] {{0,-1}, {-1,0}});\\n        aMap.put(6, new Integer[][] {{0, 1}, {-1,0}});\\n        map = Collections.unmodifiableMap(aMap);\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        return dfs(0, 0, grid, new boolean[grid.length][grid[0].length]);\\n    }\\n    \\n    private boolean dfs(int x, int y, int[][] grid, boolean[][] visited) {\\n        if (x == grid.length - 1 && y == grid[0].length - 1) return true;\\n        visited[x][y] = true;\\n        \\n        for (Integer[] next : map.get(grid[x][y])) {\\n            int newX = x + next[0], newY = y + next[1];\\n            if (!outOfBounds(newX, newY, grid) && !visited[newX][newY]) {\\n                // need to check if I can get back to current cell from newX,newY\\n                for (Integer[] rev : map.get(grid[newX][newY])) {\\n                    if (newX + rev[0] == x && newY + rev[1] == y) {\\n                        if (dfs(newX, newY, grid, visited)) return true;\\n                    }\\n                }\\n            }            \\n        }\\n        return false;\\n    }\\n    \\n    private boolean outOfBounds(int x, int y, int[][] grid) {\\n        return x < 0 || y < 0 || x >= grid.length || y >= grid[0].length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private static Map<Integer, Integer[][]> map;\\n    static {\\n        Map<Integer, Integer[][]> aMap = new HashMap();\\n        aMap.put(1, new Integer[][] {{0,-1}, {0, 1}});\\n        aMap.put(2, new Integer[][] {{1, 0}, {-1,0}});\\n        aMap.put(3, new Integer[][] {{0,-1}, {1, 0}});\\n        aMap.put(4, new Integer[][] {{0, 1}, {1, 0}});\\n        aMap.put(5, new Integer[][] {{0,-1}, {-1,0}});\\n        aMap.put(6, new Integer[][] {{0, 1}, {-1,0}});\\n        map = Collections.unmodifiableMap(aMap);\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        return dfs(0, 0, grid, new boolean[grid.length][grid[0].length]);\\n    }\\n    \\n    private boolean dfs(int x, int y, int[][] grid, boolean[][] visited) {\\n        if (x == grid.length - 1 && y == grid[0].length - 1) return true;\\n        visited[x][y] = true;\\n        \\n        for (Integer[] next : map.get(grid[x][y])) {\\n            int newX = x + next[0], newY = y + next[1];\\n            if (!outOfBounds(newX, newY, grid) && !visited[newX][newY]) {\\n                // need to check if I can get back to current cell from newX,newY\\n                for (Integer[] rev : map.get(grid[newX][newY])) {\\n                    if (newX + rev[0] == x && newY + rev[1] == y) {\\n                        if (dfs(newX, newY, grid, visited)) return true;\\n                    }\\n                }\\n            }            \\n        }\\n        return false;\\n    }\\n    \\n    private boolean outOfBounds(int x, int y, int[][] grid) {\\n        return x < 0 || y < 0 || x >= grid.length || y >= grid[0].length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359262,
                "title": "c-easy-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        //store the directions in which you can move for every street\\n        vector<vector<pair<int,int>>> dir(7);\\n        \\n        dir[1]={{0,-1},{0,1}};\\n        dir[2]={{1,0},{-1,0}};\\n        dir[3]={{0,-1},{1,0}};\\n        dir[4]={{0,1},{1,0}};\\n        dir[5]={{-1,0},{0,-1}};\\n        dir[6]={{-1,0},{0,1}};\\n        \\n        //start at the cell 0 and move into the streets in which there is a path (use the dir arr to get the moves for a street)\\n        \\n        return dfs(0,0,grid,dir,m,n);\\n        \\n    }\\n    bool dfs(int i,int j,vector<vector<int>>& grid,vector<vector<pair<int,int>>>& dir,int& m,int& n)\\n    {\\n        if(i==m-1 && j==n-1)\\n            return true;\\n        \\n        int val=grid[i][j];\\n        //change grid[i][j] to 0  to avoid visiting again\\n        \\n        //example if array is [[4,3],[6,5]] \\n        //we stuck in a loop\\n        grid[i][j]=0;\\n        \\n        //explore all the paths\\n        int x;\\n        int y;\\n        for(int k=0;k<2;k++)\\n        {\\n            x=i+dir[val][k].first;\\n            y=j+dir[val][k].second;\\n            if(x<0 || y<0  || x>=m || y>=n || grid[x][y]==0)\\n                continue;\\n            \\n            int nxt=grid[x][y];\\n            int x1=x+dir[nxt][0].first;\\n            int x2=x+dir[nxt][1].first;\\n            int y1=y+dir[nxt][0].second;\\n            int y2=y+dir[nxt][1].second;\\n            \\n            //if there is a path connecting [i,j] and the [x,y] \\n            //you can check if one of  the directions of [x,y] cell is the [i,j]\\n            \\n            if((x1==i && y1==j) || (x2==i && y2==j) )\\n                if(dfs(x,y,grid,dir,m,n))\\n                   return true;\\n        }\\n        grid[i][j]=val;\\n        return false;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        //store the directions in which you can move for every street\\n        vector<vector<pair<int,int>>> dir(7);\\n        \\n        dir[1]={{0,-1},{0,1}};\\n        dir[2]={{1,0},{-1,0}};\\n        dir[3]={{0,-1},{1,0}};\\n        dir[4]={{0,1},{1,0}};\\n        dir[5]={{-1,0},{0,-1}};\\n        dir[6]={{-1,0},{0,1}};\\n        \\n        //start at the cell 0 and move into the streets in which there is a path (use the dir arr to get the moves for a street)\\n        \\n        return dfs(0,0,grid,dir,m,n);\\n        \\n    }\\n    bool dfs(int i,int j,vector<vector<int>>& grid,vector<vector<pair<int,int>>>& dir,int& m,int& n)\\n    {\\n        if(i==m-1 && j==n-1)\\n            return true;\\n        \\n        int val=grid[i][j];\\n        //change grid[i][j] to 0  to avoid visiting again\\n        \\n        //example if array is [[4,3],[6,5]] \\n        //we stuck in a loop\\n        grid[i][j]=0;\\n        \\n        //explore all the paths\\n        int x;\\n        int y;\\n        for(int k=0;k<2;k++)\\n        {\\n            x=i+dir[val][k].first;\\n            y=j+dir[val][k].second;\\n            if(x<0 || y<0  || x>=m || y>=n || grid[x][y]==0)\\n                continue;\\n            \\n            int nxt=grid[x][y];\\n            int x1=x+dir[nxt][0].first;\\n            int x2=x+dir[nxt][1].first;\\n            int y1=y+dir[nxt][0].second;\\n            int y2=y+dir[nxt][1].second;\\n            \\n            //if there is a path connecting [i,j] and the [x,y] \\n            //you can check if one of  the directions of [x,y] cell is the [i,j]\\n            \\n            if((x1==i && y1==j) || (x2==i && y2==j) )\\n                if(dfs(x,y,grid,dir,m,n))\\n                   return true;\\n        }\\n        grid[i][j]=val;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603032,
                "title": "c-bfs-much-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n\\tbool isVal (int ni, int nj) {\\n\\t\\treturn !(ni < 0 or ni >= n or nj < 0 or nj >= m);\\n\\t}\\n\\n\\tbool hasValidPath(vector<vector<int>> &grid) {\\n\\t\\tn = grid.size(), m = grid[0].size();\\n\\t\\tvis.insert({0, 0}), q.push({0, 0});\\n\\t\\tsetDirAndPath();\\n\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tauto nd = q.front(); q.pop();\\t\\t\\t\\n\\t\\t\\tint i = nd.first, j = nd.second;\\n\\t\\t\\t\\n\\t\\t\\tif (i == n - 1 and j == m - 1) \\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t\\t\\tfor (auto d : dir[grid[i][j]]) {\\n\\t\\t\\t\\tint ni = i + d.first, nj = j + d.second;\\n\\t\\t\\t\\tif (isVal(ni,nj) and path[d].count(grid[ni][nj]) and !vis.count({ni, nj})) {\\n\\t\\t\\t\\t\\tvis.insert({ni, nj});\\n\\t\\t\\t\\t\\tq.push({ni, nj});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\t\\n\\nprivate:\\n\\tint n, m;\\n\\tunordered_map<int, vector<pair<int, int>>> dir;\\n\\tmap<pair<int, int>, set<int>> path;\\n\\tset<pair<int, int>> vis;\\n\\tqueue<pair<int, int>> q;\\n\\n\\tvoid setDirAndPath() {\\n\\t\\tdir[1] = {{0, -1}, {0, 1}}, dir[2] = {{ -1, 0}, {1, 0}}, dir[3] = {{0, -1}, {1, 0}};\\n\\t\\tdir[4] = {{0, 1}, {1, 0}}, dir[5] = {{0, -1}, { -1, 0}}, dir[6] = {{0, 1}, { -1, 0}};\\n\\n\\t\\tpath[{-1, 0}].insert({2, 3, 4}), path[{1, 0}].insert({2, 5, 6});\\n\\t\\tpath[{0, 1}].insert({1, 3, 5}), path[{0, -1}].insert({1, 4, 6});\\n\\t}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\tbool isVal (int ni, int nj) {\\n\\t\\treturn !(ni < 0 or ni >= n or nj < 0 or nj >= m);\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3541190,
                "title": "python-solution-with-dfs-and-untion-find",
                "content": "\\n**Title: Valid Path in a Grid - Union-Find Solution\\n**\\nDescription:\\n\\nThe problem asks us to determine whether there exists a valid path in a given grid, where each cell represents a street with specific connections. We are not allowed to change any streets, and the valid path should start from the upper-left cell and end at the bottom-right cell.\\n\\nThis solution utilizes the Union-Find algorithm to efficiently determine the validity of the path. The approach begins by initializing a parent dictionary using a defaultdict and assigning each cell as its own parent. Additionally, a rank matrix is created to keep track of the rank of each cell.\\n\\nNext, the valid connections for right and down directions are defined using dictionaries. These dictionaries map each street type to the set of valid connections it has with neighboring cells. For example, street 1 can connect with streets 1, 3, and 5 to the right.\\n\\nThen, a nested loop iterates through each cell in the grid. For each cell, the algorithm checks the valid connections in the right and down directions. If a valid connection is found, the algorithm performs the union operation using the Union-Find data structure. This operation merges the sets containing the cells to connect them.\\n\\nFinally, the algorithm checks if the upper-left cell (0, 0) and the bottom-right cell (m-1, n-1) are in the same connected component. This is done by calling the find function on both cells and comparing their roots. If they belong to the same component, it indicates the existence of a valid path from the start to the end.\\n\\nThe solution efficiently handles the grid\\'s connectivity using the Union-Find algorithm, allowing for quick determination of a valid path. By exploring the valid connections and performing unions between cells, the algorithm accurately determines if a valid path exists in the given grid.\\n\\nThe overall time complexity of this solution is O(m * n * \\u03B1(m * n)), where m and n are the dimensions of the grid, and \\u03B1 denotes the inverse Ackermann function. This time complexity arises from the union-find operations performed on the cells in the grid.\\n\\nOverall, this solution provides an efficient approach to solve the problem by leveraging the Union-Find algorithm and considering the valid connections between the cells in the grid.\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        parent=defaultdict(int)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                parent[(i,j)]=(i,j)\\n        \\n        rank=[[0 for j in range(len(grid[0]))] for i in range(len(grid))]\\n        directions=[(1,0),(0,1)]\\n        def inbound(row,col):\\n            return 0<=row<=len(grid)-1 and 0<=col<=len(grid[0])-1\\n        def find(x):\\n            root=x\\n            while root!=parent[root]:\\n                root=parent[root]\\n            \\n            while x!=root:\\n                temp=parent[x]\\n                parent[x]=root\\n                x=temp\\n            return root\\n            \\n        def union(pair1,pair2):\\n            parentX=find(pair1)\\n            parentY=find(pair2)\\n            if parentX==parentY:return\\n            if rank[parentX[0]][parentX[1]]==rank[parentY[0]][parentY[1]]:\\n                rank[parentX[0]][parentX[1]]+=1\\n            if rank[parentX[0]][parentX[1]]>rank[parentY[0]][parentY[1]]:\\n                parent[parentY]=parentX\\n            else:\\n                parent[parentX]=parentY\\n        right = {1: {1, 3, 5}, 2: {}, 3: {}, 4: {1, 3, 5}, 5: {}, 6: {1, 3, 5}}\\n        down = {1: {}, 2: {2, 5, 6}, 3: {2, 5, 6}, 4: {2, 5, 6}, 5: {}, 6: {}}\\n        for row in range(len(grid)):\\n            for col in range(len(grid[i])):\\n                for change_row,change_col in directions:\\n                    new_row=row+change_row\\n                    new_col=col+change_col\\n                    if inbound(new_row,new_col)and  grid[new_row][new_col] in right[grid[row][col]] and new_col-col==1:\\n                        \\n                        union((row,col),(new_row,new_col))\\n                    if inbound(new_row,new_col)and  grid[new_row][new_col] in down[grid[row][col]] and new_row-row==1:\\n                        union((row,col),(new_row,new_col))\\n        return find((0,0))==find((len(grid)-1,len(grid[-1])-1))\\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        parent=defaultdict(int)\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                parent[(i,j)]=(i,j)\\n        \\n        rank=[[0 for j in range(len(grid[0]))] for i in range(len(grid))]\\n        directions=[(1,0),(0,1)]\\n        def inbound(row,col):\\n            return 0<=row<=len(grid)-1 and 0<=col<=len(grid[0])-1\\n        def find(x):\\n            root=x\\n            while root!=parent[root]:\\n                root=parent[root]\\n            \\n            while x!=root:\\n                temp=parent[x]\\n                parent[x]=root\\n                x=temp\\n            return root\\n            \\n        def union(pair1,pair2):\\n            parentX=find(pair1)\\n            parentY=find(pair2)\\n            if parentX==parentY:return\\n            if rank[parentX[0]][parentX[1]]==rank[parentY[0]][parentY[1]]:\\n                rank[parentX[0]][parentX[1]]+=1\\n            if rank[parentX[0]][parentX[1]]>rank[parentY[0]][parentY[1]]:\\n                parent[parentY]=parentX\\n            else:\\n                parent[parentX]=parentY\\n        right = {1: {1, 3, 5}, 2: {}, 3: {}, 4: {1, 3, 5}, 5: {}, 6: {1, 3, 5}}\\n        down = {1: {}, 2: {2, 5, 6}, 3: {2, 5, 6}, 4: {2, 5, 6}, 5: {}, 6: {}}\\n        for row in range(len(grid)):\\n            for col in range(len(grid[i])):\\n                for change_row,change_col in directions:\\n                    new_row=row+change_row\\n                    new_col=col+change_col\\n                    if inbound(new_row,new_col)and  grid[new_row][new_col] in right[grid[row][col]] and new_col-col==1:\\n                        \\n                        union((row,col),(new_row,new_col))\\n                    if inbound(new_row,new_col)and  grid[new_row][new_col] in down[grid[row][col]] and new_row-row==1:\\n                        union((row,col),(new_row,new_col))\\n        return find((0,0))==find((len(grid)-1,len(grid[-1])-1))\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036363,
                "title": "c-solution-union-find-method",
                "content": "```\\nclass Solution {\\npublic:\\n    int parent[100000];\\n    int find(int x) {\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    bool union_(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if(x == y) return true;\\n        parent[y] = x;\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& g) {\\n        \\n        int n = g.size();\\n        int m = g[0].size();\\n        \\n        for(int i = 0; i < 100000; i++)\\n            parent[i] = i;\\n        \\n        int dx[] = {-1, 0, 1, 0};\\n        int dy[] = {0, 1, 0, -1};\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                \\n                int x = i, y = j;\\n                for(int k = 0; k < 4; k++) {\\n                    int nx =  x + dx[k];\\n                    int ny = y + dy[k];\\n                    \\n                    \\n                    if(nx < 0 or nx >= n or ny < 0 or ny >= m)\\n                        continue;\\n                    int way = g[nx][ny];\\n                    int curr = g[x][y];\\n                    \\n                    // top\\n                    if(k == 0) {\\n                        if(curr == 5 or curr == 6 or curr == 2) {\\n                            if(way == 2 or way == 3 or way == 4)\\n                                union_(x * m + y, nx * m + ny);\\n                        }  \\n                    }\\n                    // right\\n                     if(k == 1) {\\n                         if(curr == 1 or curr == 4 or curr == 5) {\\n                            if(way == 3 or way == 5 or way == 1)\\n                                union_(x * m + y, nx * m + ny);\\n                        }\\n                     }\\n                    // down\\n                    if(k == 2) {\\n                        if(curr == 3 or curr == 4 or curr == 2) {\\n                            if(way == 2 or way == 5 or way == 6)\\n                                union_(x * m + y, nx * m + ny);\\n                        }\\n                    }\\n                    // left\\n                    if(k == 3) {\\n                        if(curr == 3 or curr == 5 or curr == 1) {\\n                            if(way == 4 or way == 6 or way == 1)\\n                                union_(x * m + y, nx * m + ny);\\n                        }\\n                    } \\n                }   \\n                // if (0, 0) and (n - 1, m - 1) are connected too return true\\n                if(find(0) == find(n * m - 1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int parent[100000];\\n    int find(int x) {\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    bool union_(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if(x == y) return true;\\n        parent[y] = x;\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& g) {\\n        \\n        int n = g.size();\\n        int m = g[0].size();\\n        \\n        for(int i = 0; i < 100000; i++)\\n            parent[i] = i;\\n        \\n        int dx[] = {-1, 0, 1, 0};\\n        int dy[] = {0, 1, 0, -1};\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                \\n                int x = i, y = j;\\n                for(int k = 0; k < 4; k++) {\\n                    int nx =  x + dx[k];\\n                    int ny = y + dy[k];\\n                    \\n                    \\n                    if(nx < 0 or nx >= n or ny < 0 or ny >= m)\\n                        continue;\\n                    int way = g[nx][ny];\\n                    int curr = g[x][y];\\n                    \\n                    // top\\n                    if(k == 0) {\\n                        if(curr == 5 or curr == 6 or curr == 2) {\\n                            if(way == 2 or way == 3 or way == 4)\\n                                union_(x * m + y, nx * m + ny);\\n                        }  \\n                    }\\n                    // right\\n                     if(k == 1) {\\n                         if(curr == 1 or curr == 4 or curr == 5) {\\n                            if(way == 3 or way == 5 or way == 1)\\n                                union_(x * m + y, nx * m + ny);\\n                        }\\n                     }\\n                    // down\\n                    if(k == 2) {\\n                        if(curr == 3 or curr == 4 or curr == 2) {\\n                            if(way == 2 or way == 5 or way == 6)\\n                                union_(x * m + y, nx * m + ny);\\n                        }\\n                    }\\n                    // left\\n                    if(k == 3) {\\n                        if(curr == 3 or curr == 5 or curr == 1) {\\n                            if(way == 4 or way == 6 or way == 1)\\n                                union_(x * m + y, nx * m + ny);\\n                        }\\n                    } \\n                }   \\n                // if (0, 0) and (n - 1, m - 1) are connected too return true\\n                if(find(0) == find(n * m - 1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484358,
                "title": "c-bfs-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool bfs(vector<vector<int>>& g,int r,int c,vector<vector<bool>>&vi){\\n        vector<vector<pair<int,int>>>dirr(7);\\n        dirr[1] = {{0,-1},{0,1}};\\n        dirr[2] = {{-1,0},{1,0}};\\n        dirr[3] = {{0,-1},{1,0}};\\n        dirr[4] = {{0,1},{1,0}};\\n        dirr[5] = {{0,-1},{-1,0}};\\n        dirr[6] = {{0,1},{-1,0}};\\n        queue<pair<int,int>>q;\\n        q.push({r,c});\\n        vi[r][c]=true;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                \\n                if(x==g.size()-1 && y==g[0].size()-1) return true;\\n                \\n                int type=g[x][y];\\n                for (int k = 0; k < 2; k++) {\\n                    int u = x + dirr[type][k].first, v = y + dirr[type][k].second;\\n                    if (u >= 0 && u < g.size() && v >= 0 && v < g[0].size() && vi[u][v] == false) {\\n                        vi[u][v] = true;\\n                        int z=g[u][v];\\n                        int x1=u+dirr[z][0].first;\\n                        int y1=v+dirr[z][0].second;\\n                        int x2=u+dirr[z][1].first;\\n                        int y2=v+dirr[z][1].second;\\n                    \\n                        if((x==x1 && y==y1) || (x==x2 && y==y2))\\n                            q.push({u,v});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>>vis(n,vector<bool>(m,false));\\n        bool valid = bfs(grid,0,0,vis);\\n        return valid;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool bfs(vector<vector<int>>& g,int r,int c,vector<vector<bool>>&vi){\\n        vector<vector<pair<int,int>>>dirr(7);\\n        dirr[1] = {{0,-1},{0,1}};\\n        dirr[2] = {{-1,0},{1,0}};\\n        dirr[3] = {{0,-1},{1,0}};\\n        dirr[4] = {{0,1},{1,0}};\\n        dirr[5] = {{0,-1},{-1,0}};\\n        dirr[6] = {{0,1},{-1,0}};\\n        queue<pair<int,int>>q;\\n        q.push({r,c});\\n        vi[r][c]=true;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                \\n                if(x==g.size()-1 && y==g[0].size()-1) return true;\\n                \\n                int type=g[x][y];\\n                for (int k = 0; k < 2; k++) {\\n                    int u = x + dirr[type][k].first, v = y + dirr[type][k].second;\\n                    if (u >= 0 && u < g.size() && v >= 0 && v < g[0].size() && vi[u][v] == false) {\\n                        vi[u][v] = true;\\n                        int z=g[u][v];\\n                        int x1=u+dirr[z][0].first;\\n                        int y1=v+dirr[z][0].second;\\n                        int x2=u+dirr[z][1].first;\\n                        int y2=v+dirr[z][1].second;\\n                    \\n                        if((x==x1 && y==y1) || (x==x2 && y==y2))\\n                            q.push({u,v});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<bool>>vis(n,vector<bool>(m,false));\\n        bool valid = bfs(grid,0,0,vis);\\n        return valid;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446538,
                "title": "python-clean-dfs-easy-to-read-understand",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        visited = set()\\n        rows, cols = len(grid), len(grid[0])\\n        right = (0, 1, {1, 3, 5})\\n        left = (0, -1, {1, 4, 6})\\n        down = (1, 0, {2, 5, 6})\\n        up = (-1, 0, {2, 3, 4})\\n        \\n        directions = {\\n            1: [right, left],\\n            2: [up, down],\\n            3: [left, down],\\n            4: [right, down],\\n            5: [left, up],\\n            6: [right, up]\\n         }\\n        \\n        def traverse(i, j):\\n            if i == rows - 1 and j == cols - 1:\\n                return True\\n            visited.add((i, j))\\n            \\n            for d in directions[grid[i][j]]:\\n                i_next, j_next, valid_next_streets = i + d[0], j + d[1], d[2]\\n                valid_position = 0 <= i_next < rows and 0 <= j_next < cols\\n                if valid_position and grid[i_next][j_next] in valid_next_streets and (i_next, j_next) not in visited:\\n                    if traverse(i_next, j_next):\\n                        return True\\n            return False\\n        \\n        return traverse(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        visited = set()\\n        rows, cols = len(grid), len(grid[0])\\n        right = (0, 1, {1, 3, 5})\\n        left = (0, -1, {1, 4, 6})\\n        down = (1, 0, {2, 5, 6})\\n        up = (-1, 0, {2, 3, 4})\\n        \\n        directions = {\\n            1: [right, left],\\n            2: [up, down],\\n            3: [left, down],\\n            4: [right, down],\\n            5: [left, up],\\n            6: [right, up]\\n         }\\n        \\n        def traverse(i, j):\\n            if i == rows - 1 and j == cols - 1:\\n                return True\\n            visited.add((i, j))\\n            \\n            for d in directions[grid[i][j]]:\\n                i_next, j_next, valid_next_streets = i + d[0], j + d[1], d[2]\\n                valid_position = 0 <= i_next < rows and 0 <= j_next < cols\\n                if valid_position and grid[i_next][j_next] in valid_next_streets and (i_next, j_next) not in visited:\\n                    if traverse(i_next, j_next):\\n                        return True\\n            return False\\n        \\n        return traverse(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051452,
                "title": "python-bfs-with-link-idea-w-comment",
                "content": "```py\\n\\'\\'\\'\\nw: graph\\nh: link the cell one by one, for each type of street, there are two ends\\n    we need to consider what type of streets can be connected for each end\\n    use idx to present each end of street\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        connected = {1: {0: [1, 3, 5], 1: {1, 4, 6}}, 2: {0: [2, 3, 4], 1: [2, 5, 6]}, \\n                     3: {0: [1, 4, 6], 1: {2, 5, 6}}, 4: {0: [1, 3, 5], 1: [2, 5, 6]},\\n                     5: {0: [1, 6, 4], 1: [2, 4, 3]}, 6: {0: [2, 4, 3], 1: [3, 1, 5]}}\\n        \\n        directions = {1: [(0, 1), (0, -1)], 2: [(-1, 0), (1, 0)], 3: [(0, -1), (1, 0)],\\n                      4: [(0, 1), (1, 0)], 5: [(0, -1), (-1, 0)], 6: [(-1, 0), (0, 1)]}\\n        \\n        \\n        seen = set()\\n        deque = collections.deque([(0,0)])\\n        \\n        while deque:\\n            #print(deque)\\n            x, y = deque.popleft()\\n            seen.add((x, y))\\n            \\n            if x == m-1 and y == n-1:\\n                return True\\n            \\n            street = grid[x][y]\\n            for idx, (dx, dy) in enumerate(directions[street]):\\n                nx = x+dx\\n                ny = y+dy\\n                if 0<=nx<=m-1 and 0<=ny<=n-1 and (nx, ny) not in seen and grid[nx][ny] in connected[street][idx]:\\n                    deque.append((nx, ny))\\n                    seen.add((nx, ny))\\n        \\n        \\n        return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: graph\\nh: link the cell one by one, for each type of street, there are two ends\\n    we need to consider what type of streets can be connected for each end\\n    use idx to present each end of street\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        connected = {1: {0: [1, 3, 5], 1: {1, 4, 6}}, 2: {0: [2, 3, 4], 1: [2, 5, 6]}, \\n                     3: {0: [1, 4, 6], 1: {2, 5, 6}}, 4: {0: [1, 3, 5], 1: [2, 5, 6]},\\n                     5: {0: [1, 6, 4], 1: [2, 4, 3]}, 6: {0: [2, 4, 3], 1: [3, 1, 5]}}\\n        \\n        directions = {1: [(0, 1), (0, -1)], 2: [(-1, 0), (1, 0)], 3: [(0, -1), (1, 0)],\\n                      4: [(0, 1), (1, 0)], 5: [(0, -1), (-1, 0)], 6: [(-1, 0), (0, 1)]}\\n        \\n        \\n        seen = set()\\n        deque = collections.deque([(0,0)])\\n        \\n        while deque:\\n            #print(deque)\\n            x, y = deque.popleft()\\n            seen.add((x, y))\\n            \\n            if x == m-1 and y == n-1:\\n                return True\\n            \\n            street = grid[x][y]\\n            for idx, (dx, dy) in enumerate(directions[street]):\\n                nx = x+dx\\n                ny = y+dy\\n                if 0<=nx<=m-1 and 0<=ny<=n-1 and (nx, ny) not in seen and grid[nx][ny] in connected[street][idx]:\\n                    deque.append((nx, ny))\\n                    seen.add((nx, ny))\\n        \\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014516,
                "title": "c-dfs-simple-solution-better-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int> >& grid,vector<vector<bool> >& visited,\\n             int i,int j,int m,int n,char prev){\\n\\n        if(i>=m || i<0 || j>=n ||j<0 || visited[i][j]==true)\\n            return ;\\n        \\n        if(i==m-1 && j==n-1){\\n            if(prev==\\'U\\' && (grid[i][j]==2 || grid[i][j]==6 || grid[i][j]==5))\\n                visited[i][j]=true;\\n            else if(grid[i][j]==1 || grid[i][j]==3 || grid[i][j]==5)\\n                visited[i][j]=true;\\n            return;\\n        }\\n        \\n        visited[i][j]=true;\\n        if(prev==\\'U\\'){\\n            if(grid[i][j]==2)\\n                dfs(grid,visited,i+1,j,m,n,\\'U\\');\\n            else if(grid[i][j]==5)\\n                dfs(grid,visited,i,j-1,m,n,\\'R\\');\\n            else if(grid[i][j]==6)\\n                dfs(grid,visited,i,j+1,m,n,\\'L\\');\\n        }\\n        else if(prev==\\'L\\'){\\n            if(grid[i][j]==1)\\n                dfs(grid,visited,i,j+1,m,n,\\'L\\');\\n            else if(grid[i][j]==3)\\n                dfs(grid,visited,i+1,j,m,n,\\'U\\');\\n            else if(grid[i][j]==5)\\n                dfs(grid,visited,i-1,j,m,n,\\'B\\');\\n        }\\n        else if(prev==\\'B\\'){\\n            if(grid[i][j]==2)\\n                dfs(grid,visited,i-1,j,m,n,\\'B\\');\\n            else if(grid[i][j]==3)\\n                dfs(grid,visited,i,j-1,m,n,\\'R\\');\\n            else if(grid[i][j]==4)\\n                dfs(grid,visited,i,j+1,m,n,\\'L\\');\\n        }\\n        else if(prev==\\'R\\'){\\n            if(grid[i][j]==1)\\n                dfs(grid,visited,i,j-1,m,n,\\'R\\');\\n            else if(grid[i][j]==4)\\n                dfs(grid,visited,i+1,j,m,n,\\'U\\');\\n            else if(grid[i][j]==6)\\n                dfs(grid,visited,i-1,j,m,n,\\'B\\');\\n        }\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(m==1 && n==1)\\n            return true;\\n        vector<vector<bool> > visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n        if(grid[0][0]==2)\\n            dfs(grid,visited,1,0,m,n,\\'U\\');    \\n        else if(grid[0][0]==1)\\n            dfs(grid,visited,0,1,m,n,\\'L\\');\\n        else if(grid[0][0]==3)\\n            dfs(grid,visited,1,0,m,n,\\'U\\');\\n        else if(grid[0][0]==4){\\n            dfs(grid,visited,1,0,m,n,\\'U\\');\\n            dfs(grid,visited,0,1,m,n,\\'L\\');\\n        }\\n        else if(grid[0][0]==6)\\n            dfs(grid,visited,0,1,m,n,\\'L\\');\\n        return visited[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int> >& grid,vector<vector<bool> >& visited,\\n             int i,int j,int m,int n,char prev){\\n\\n        if(i>=m || i<0 || j>=n ||j<0 || visited[i][j]==true)\\n            return ;\\n        \\n        if(i==m-1 && j==n-1){\\n            if(prev==\\'U\\' && (grid[i][j]==2 || grid[i][j]==6 || grid[i][j]==5))\\n                visited[i][j]=true;\\n            else if(grid[i][j]==1 || grid[i][j]==3 || grid[i][j]==5)\\n                visited[i][j]=true;\\n            return;\\n        }\\n        \\n        visited[i][j]=true;\\n        if(prev==\\'U\\'){\\n            if(grid[i][j]==2)\\n                dfs(grid,visited,i+1,j,m,n,\\'U\\');\\n            else if(grid[i][j]==5)\\n                dfs(grid,visited,i,j-1,m,n,\\'R\\');\\n            else if(grid[i][j]==6)\\n                dfs(grid,visited,i,j+1,m,n,\\'L\\');\\n        }\\n        else if(prev==\\'L\\'){\\n            if(grid[i][j]==1)\\n                dfs(grid,visited,i,j+1,m,n,\\'L\\');\\n            else if(grid[i][j]==3)\\n                dfs(grid,visited,i+1,j,m,n,\\'U\\');\\n            else if(grid[i][j]==5)\\n                dfs(grid,visited,i-1,j,m,n,\\'B\\');\\n        }\\n        else if(prev==\\'B\\'){\\n            if(grid[i][j]==2)\\n                dfs(grid,visited,i-1,j,m,n,\\'B\\');\\n            else if(grid[i][j]==3)\\n                dfs(grid,visited,i,j-1,m,n,\\'R\\');\\n            else if(grid[i][j]==4)\\n                dfs(grid,visited,i,j+1,m,n,\\'L\\');\\n        }\\n        else if(prev==\\'R\\'){\\n            if(grid[i][j]==1)\\n                dfs(grid,visited,i,j-1,m,n,\\'R\\');\\n            else if(grid[i][j]==4)\\n                dfs(grid,visited,i+1,j,m,n,\\'U\\');\\n            else if(grid[i][j]==6)\\n                dfs(grid,visited,i-1,j,m,n,\\'B\\');\\n        }\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(m==1 && n==1)\\n            return true;\\n        vector<vector<bool> > visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n        if(grid[0][0]==2)\\n            dfs(grid,visited,1,0,m,n,\\'U\\');    \\n        else if(grid[0][0]==1)\\n            dfs(grid,visited,0,1,m,n,\\'L\\');\\n        else if(grid[0][0]==3)\\n            dfs(grid,visited,1,0,m,n,\\'U\\');\\n        else if(grid[0][0]==4){\\n            dfs(grid,visited,1,0,m,n,\\'U\\');\\n            dfs(grid,visited,0,1,m,n,\\'L\\');\\n        }\\n        else if(grid[0][0]==6)\\n            dfs(grid,visited,0,1,m,n,\\'L\\');\\n        return visited[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907971,
                "title": "c-bfs-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<pair<int, int>>> direction = {\\n\\t\\t{{0,-1}, {0,1}}, {{-1,0}, {1,0}}, // left-right, up-down\\n\\t\\t{{0,-1}, {1,0}}, {{0,1}, {1,0}}, // left-down, right-down\\n\\t\\t{{0,-1}, {-1,0}}, {{0,1}, {-1,0}} // left-up, right-up\\n\\t};\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n    \\tint m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({0,0}); //start point\\n\\t\\tvisited[0][0] = true;\\n        bool reachDestination = false;\\n        while(q.size() && !reachDestination){\\n        \\tint size = q.size();\\n        \\tfor(int i=0; i<size; i++){\\n        \\t\\tint curX = q.front().first;\\n        \\t\\tint curY = q.front().second;\\n        \\t\\tq.pop();\\n        \\t\\tif(curX == m-1 && curY==n-1){\\n        \\t\\t\\treachDestination = true;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\tfor(auto p: direction[grid[curX][curY]-1]){ // try visit neighbors\\n        \\t\\t\\tint x = curX+p.first;\\n        \\t\\t\\tint y = curY+p.second;\\n        \\t\\t\\tif(x<0 || y<0 || x>=m || y>= n || visited[x][y]){\\n        \\t\\t\\t\\tcontinue;\\n        \\t\\t\\t}else{ // check if neighbor connects to self\\n        \\t\\t\\t\\tfor(auto p2: direction[grid[x][y]-1]){\\n        \\t\\t\\t\\t\\tif(curX == x+p2.first && curY == y+p2.second){\\n        \\t\\t\\t\\t\\t\\tq.push({x, y});\\n\\t\\t\\t\\t\\t\\t\\t\\tvisited[x][y] = true;\\n        \\t\\t\\t\\t\\t}\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return reachDestination;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<pair<int, int>>> direction = {\\n\\t\\t{{0,-1}, {0,1}}, {{-1,0}, {1,0}}, // left-right, up-down\\n\\t\\t{{0,-1}, {1,0}}, {{0,1}, {1,0}}, // left-down, right-down\\n\\t\\t{{0,-1}, {-1,0}}, {{0,1}, {-1,0}} // left-up, right-up\\n\\t};\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n    \\tint m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({0,0}); //start point\\n\\t\\tvisited[0][0] = true;\\n        bool reachDestination = false;\\n        while(q.size() && !reachDestination){\\n        \\tint size = q.size();\\n        \\tfor(int i=0; i<size; i++){\\n        \\t\\tint curX = q.front().first;\\n        \\t\\tint curY = q.front().second;\\n        \\t\\tq.pop();\\n        \\t\\tif(curX == m-1 && curY==n-1){\\n        \\t\\t\\treachDestination = true;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\tfor(auto p: direction[grid[curX][curY]-1]){ // try visit neighbors\\n        \\t\\t\\tint x = curX+p.first;\\n        \\t\\t\\tint y = curY+p.second;\\n        \\t\\t\\tif(x<0 || y<0 || x>=m || y>= n || visited[x][y]){\\n        \\t\\t\\t\\tcontinue;\\n        \\t\\t\\t}else{ // check if neighbor connects to self\\n        \\t\\t\\t\\tfor(auto p2: direction[grid[x][y]-1]){\\n        \\t\\t\\t\\t\\tif(curX == x+p2.first && curY == y+p2.second){\\n        \\t\\t\\t\\t\\t\\tq.push({x, y});\\n\\t\\t\\t\\t\\t\\t\\t\\tvisited[x][y] = true;\\n        \\t\\t\\t\\t\\t}\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return reachDestination;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894395,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dir = {\\n        {1, 0}, {0, 1}, {-1, 0}, {0, -1}\\n    };\\n    vector<vector<int>>way = {\\n        {}, {1, 3}, {2, 0}, {3, 0}, {1, 0}, {3, 2}, {2, 1}\\n    };\\n    vector<vector<bool>>vis;\\n    int m, n;\\n    bool dfs(int i, int j, vector<vector<int>>& grid){\\n        if(i == m - 1 && j == n - 1) return true;\\n        vis[i][j] = true;\\n        for(int c : way[grid[i][j]]){\\n            int x = i + dir[c][0];\\n            int y = j + dir[c][1];\\n            if(x >= 0 && x < m && y >= 0 && y < n && !vis[x][y]){\\n                for(int d : way[grid[x][y]]){\\n                    if(x + dir[d][0] == i && y + dir[d][1] == j && dfs(x, y, grid)){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        vis.resize(m, vector<bool>(n, false));\\n        return dfs(0, 0, grid);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>>dir = {\\n        {1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 868006,
                "title": "simple-python-union-find-solution-considering-pairwise-connectivity",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.leaders = [i for i in range(n)]\\n        self.ranks = [1 for i in range(n)]\\n    \\n    def find(self, x):\\n        if self.leaders[x] != x:\\n            self.leaders[x] = self.find(self.leaders[x])\\n        return self.leaders[x]\\n\\n    def union(self, x, y):\\n        p = self.find(x)\\n        q = self.find(y)\\n        if p == q: \\n            return False\\n        if self.ranks[p] < self.ranks[q]:\\n            self.leaders[p] = q\\n        elif self.ranks[p] > self.ranks[q]:\\n            self.leaders[q] = p\\n        else:        \\n            self.leaders[q] = p\\n            self.ranks[p] += 1\\n        return True\\n    \\nclass Solution:\\n    def hasValidPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        right = {1: {1, 3, 5}, 2: {}, 3: {}, 4: {1, 3, 5}, 5: {}, 6: {1, 3, 5}}\\n        down = {1: {}, 2: {2, 5, 6}, 3: {2, 5, 6}, 4: {2, 5, 6}, 5: {}, 6: {}}\\n        uf = UnionFind(m * n)\\n        for x in range(m):\\n            for y in range(n):\\n                if y + 1 <= n - 1 and grid[x][y + 1] in right[grid[x][y]]:\\n                    uf.union(x * n + y, x * n + y + 1)\\n                if x + 1 <= m - 1 and grid[x + 1][y] in down[grid[x][y]]:\\n                    uf.union(x * n + y, (x + 1) * n + y)\\n        return uf.find(0) == uf.find(m * n - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.leaders = [i for i in range(n)]\\n        self.ranks = [1 for i in range(n)]\\n    \\n    def find(self, x):\\n        if self.leaders[x] != x:\\n            self.leaders[x] = self.find(self.leaders[x])\\n        return self.leaders[x]\\n\\n    def union(self, x, y):\\n        p = self.find(x)\\n        q = self.find(y)\\n        if p == q: \\n            return False\\n        if self.ranks[p] < self.ranks[q]:\\n            self.leaders[p] = q\\n        elif self.ranks[p] > self.ranks[q]:\\n            self.leaders[q] = p\\n        else:        \\n            self.leaders[q] = p\\n            self.ranks[p] += 1\\n        return True\\n    \\nclass Solution:\\n    def hasValidPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        right = {1: {1, 3, 5}, 2: {}, 3: {}, 4: {1, 3, 5}, 5: {}, 6: {1, 3, 5}}\\n        down = {1: {}, 2: {2, 5, 6}, 3: {2, 5, 6}, 4: {2, 5, 6}, 5: {}, 6: {}}\\n        uf = UnionFind(m * n)\\n        for x in range(m):\\n            for y in range(n):\\n                if y + 1 <= n - 1 and grid[x][y + 1] in right[grid[x][y]]:\\n                    uf.union(x * n + y, x * n + y + 1)\\n                if x + 1 <= m - 1 and grid[x + 1][y] in down[grid[x][y]]:\\n                    uf.union(x * n + y, (x + 1) * n + y)\\n        return uf.find(0) == uf.find(m * n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844887,
                "title": "faster-100-javascript-while-simple-data-structure",
                "content": "```\\nfunction hasValidPath(grid) {\\n    if (grid[0][0] === 5) return false;\\n    if (grid[grid.length-1][grid[0].length-1] === 4) return false;\\n\\n    const info = types[grid[0][0]];\\n\\n    const [input1, input2] = Object.keys(info);\\n    \\n\\t// try to go through both inputs\\n    return (\\n        isPathValid(input1, grid) ||\\n        isPathValid(input2, grid)\\n    );\\n};\\n\\nfunction isPathValid(input, grid) {\\n    const n = grid.length - 1;\\n    const m = grid[0].length - 1;\\n\\n    let i = 0;\\n    let j = 0;\\n\\n    while ((i >= 0 && i <= n) && (j >= 0 && j <= m)) {\\n\\n        const curr = grid[i][j];\\n        const currInfo = types[curr];\\n\\n        if (!currInfo[input]) {\\n            return false;\\n        }\\n\\n        if (i === n && j === m) {\\n            return true;\\n        }\\n        \\n        const currOutput = currInfo[input];\\n        input = inputFromOutput[currOutput]\\n        if (currOutput === \\'up\\') {\\n            i--;\\n        }\\n        else if (currOutput === \\'right\\') {\\n            j++;\\n        }\\n        else if (currOutput === \\'down\\') {\\n            i++;\\n        }\\n        else if (currOutput === \\'left\\') {\\n            j--;\\n        }\\n\\n        // find a loop\\n        if (i === 0 && j === 0) return false;\\n    }\\n    // overflow boandaries but didn\\'t reach a destenation\\n    return false;\\n}\\n\\nconst inputFromOutput = {\\n    left: \\'right\\',\\n    right: \\'left\\',\\n    up: \\'down\\',\\n    down: \\'up\\'\\n}\\n\\n// store types as input : output\\nconst types = {\\n    1: { left: \\'right\\', right: \\'left\\' },\\n    2: { up: \\'down\\', down: \\'up\\' },\\n    3: { left: \\'down\\', down: \\'left\\' },\\n    4: { down: \\'right\\', right: \\'down\\' },\\n    5: { up: \\'left\\', left: \\'up\\' },\\n    6: { right: \\'up\\', up: \\'right\\' }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction hasValidPath(grid) {\\n    if (grid[0][0] === 5) return false;\\n    if (grid[grid.length-1][grid[0].length-1] === 4) return false;\\n\\n    const info = types[grid[0][0]];\\n\\n    const [input1, input2] = Object.keys(info);\\n    \\n\\t// try to go through both inputs\\n    return (\\n        isPathValid(input1, grid) ||\\n        isPathValid(input2, grid)\\n    );\\n};\\n\\nfunction isPathValid(input, grid) {\\n    const n = grid.length - 1;\\n    const m = grid[0].length - 1;\\n\\n    let i = 0;\\n    let j = 0;\\n\\n    while ((i >= 0 && i <= n) && (j >= 0 && j <= m)) {\\n\\n        const curr = grid[i][j];\\n        const currInfo = types[curr];\\n\\n        if (!currInfo[input]) {\\n            return false;\\n        }\\n\\n        if (i === n && j === m) {\\n            return true;\\n        }\\n        \\n        const currOutput = currInfo[input];\\n        input = inputFromOutput[currOutput]\\n        if (currOutput === \\'up\\') {\\n            i--;\\n        }\\n        else if (currOutput === \\'right\\') {\\n            j++;\\n        }\\n        else if (currOutput === \\'down\\') {\\n            i++;\\n        }\\n        else if (currOutput === \\'left\\') {\\n            j--;\\n        }\\n\\n        // find a loop\\n        if (i === 0 && j === 0) return false;\\n    }\\n    // overflow boandaries but didn\\'t reach a destenation\\n    return false;\\n}\\n\\nconst inputFromOutput = {\\n    left: \\'right\\',\\n    right: \\'left\\',\\n    up: \\'down\\',\\n    down: \\'up\\'\\n}\\n\\n// store types as input : output\\nconst types = {\\n    1: { left: \\'right\\', right: \\'left\\' },\\n    2: { up: \\'down\\', down: \\'up\\' },\\n    3: { left: \\'down\\', down: \\'left\\' },\\n    4: { down: \\'right\\', right: \\'down\\' },\\n    5: { up: \\'left\\', left: \\'up\\' },\\n    6: { right: \\'up\\', up: \\'right\\' }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 719337,
                "title": "easy-c-solution-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int N = grid[0].size();\\n        vector<vector<int>> vis(grid.size(),vector<int>(N,0));\\n        if(grid.size()==0) return false;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n                                \\n        map<int,pair<char,char>> path;\\n        map<char,pair<int,int>> next;\\n        map<char,vector<int>> check;\\n        \\n        path.insert({1,{\\'L\\',\\'R\\'}});\\n        path.insert({2,{\\'U\\',\\'D\\'}});\\n        path.insert({3,{\\'L\\',\\'D\\'}});\\n        path.insert({4,{\\'R\\',\\'D\\'}});\\n        path.insert({5,{\\'L\\',\\'U\\'}});\\n        path.insert({6,{\\'R\\',\\'U\\'}});\\n        \\n        check.insert({\\'L\\',{1,4,6}});\\n        check.insert({\\'R\\',{1,3,5}});\\n        check.insert({\\'U\\',{2,3,4}});\\n        check.insert({\\'D\\',{2,5,6}});\\n        \\n        next.insert({\\'L\\',{0,-1}});\\n        next.insert({\\'R\\',{0,1}});\\n        next.insert({\\'U\\',{-1,0}});\\n        next.insert({\\'D\\',{1,0}});\\n                                \\n        while(!q.empty()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            vis[r][c]=1;\\n            if(r==(grid.size()-1) && c==(grid[0].size()-1) ) return true;\\n            q.pop();\\n            int data = grid[r][c];\\n            int rr1 = r+next[path[data].first].first;\\n            int cc1 = c+next[path[data].first].second;\\n            if(rr1>=0 && cc1 >=0 && rr1<grid.size() && cc1 <grid[0].size() && vis[rr1][cc1]==0){\\n                int data1 = grid[rr1][cc1];\\n                for(int i=0;i<3;i++){\\n                    if(check[path[data].first][i]==data1){\\n                        q.push({rr1,cc1});\\n                    }\\n                }\\n            }\\n            rr1 = r+next[path[data].second].first;\\n            cc1 = c+next[path[data].second].second;\\n            if(rr1>=0 && cc1 >=0 && rr1<grid.size() && cc1 <grid[0].size() && vis[rr1][cc1]==0){\\n                int data1 = grid[rr1][cc1];\\n                for(int i=0;i<3;i++){\\n                    if(check[path[data].second][i]==data1){\\n                        q.push({rr1,cc1});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int N = grid[0].size();\\n        vector<vector<int>> vis(grid.size(),vector<int>(N,0));\\n        if(grid.size()==0) return false;\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n                                \\n        map<int,pair<char,char>> path;\\n        map<char,pair<int,int>> next;\\n        map<char,vector<int>> check;\\n        \\n        path.insert({1,{\\'L\\',\\'R\\'}});\\n        path.insert({2,{\\'U\\',\\'D\\'}});\\n        path.insert({3,{\\'L\\',\\'D\\'}});\\n        path.insert({4,{\\'R\\',\\'D\\'}});\\n        path.insert({5,{\\'L\\',\\'U\\'}});\\n        path.insert({6,{\\'R\\',\\'U\\'}});\\n        \\n        check.insert({\\'L\\',{1,4,6}});\\n        check.insert({\\'R\\',{1,3,5}});\\n        check.insert({\\'U\\',{2,3,4}});\\n        check.insert({\\'D\\',{2,5,6}});\\n        \\n        next.insert({\\'L\\',{0,-1}});\\n        next.insert({\\'R\\',{0,1}});\\n        next.insert({\\'U\\',{-1,0}});\\n        next.insert({\\'D\\',{1,0}});\\n                                \\n        while(!q.empty()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            vis[r][c]=1;\\n            if(r==(grid.size()-1) && c==(grid[0].size()-1) ) return true;\\n            q.pop();\\n            int data = grid[r][c];\\n            int rr1 = r+next[path[data].first].first;\\n            int cc1 = c+next[path[data].first].second;\\n            if(rr1>=0 && cc1 >=0 && rr1<grid.size() && cc1 <grid[0].size() && vis[rr1][cc1]==0){\\n                int data1 = grid[rr1][cc1];\\n                for(int i=0;i<3;i++){\\n                    if(check[path[data].first][i]==data1){\\n                        q.push({rr1,cc1});\\n                    }\\n                }\\n            }\\n            rr1 = r+next[path[data].second].first;\\n            cc1 = c+next[path[data].second].second;\\n            if(rr1>=0 && cc1 >=0 && rr1<grid.size() && cc1 <grid[0].size() && vis[rr1][cc1]==0){\\n                int data1 = grid[rr1][cc1];\\n                for(int i=0;i<3;i++){\\n                    if(check[path[data].second][i]==data1){\\n                        q.push({rr1,cc1});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635713,
                "title": "python3-dfs-solution-check-if-there-is-a-valid-path-in-a-grid",
                "content": "This is just a variation of a conventional dfs problem. I did the following modifications:\\n*  `directions` contains the delta of coordinates when moving up, right, down, left (in clockwise order).\\n*  `streetDirections` maps street type to the directions (index of the directions list) that we can go from that type of street.\\n*  Mark street visited by negating the street type. At the end, if last street type is negative, then there is a valid path.\\n*  The `dfs` function takes an extra argument which is the outgoing direction. Inside `dfs`, this direction is turned into the opposite direction and check whether the current type can accept traffic from that direction. For example, if parent type is 2 and it goes down (direction 2), we need to check if the current type can accept traffic from up (direction 0, i.e. (2+2) % 4). \\n*  Start at 0, 0 with direction both 0 and 3. If the start street can\\'t accept from any of these directions, it would return immediately.\\n```\\nclass Solution:\\n    directions = [[-1, 0], [0, 1], [1, 0], [0, -1]]\\n    streetDirections = {\\n       1: [1, 3],\\n       2: [0, 2],\\n       3: [2, 3],\\n       4: [1, 2],\\n       5: [0, 3],\\n       6: [0, 1]\\n    }\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        def dfs(i: int, j: int, oppositeDirection: int) -> None:\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] < 0:\\n                return\\n            v = grid[i][j]\\n            sd = Solution.streetDirections[v]\\n            direction = (oppositeDirection + 2) % 4\\n            if direction not in sd:\\n                return\\n            grid[i][j] = -v\\n            for d in sd:\\n                delta = Solution.directions[d]\\n                dfs(i+delta[0], j+delta[1], d)\\n        dfs(0, 0, 0)\\n        dfs(0, 0, 3)\\n        return grid[m-1][n-1] < 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    directions = [[-1, 0], [0, 1], [1, 0], [0, -1]]\\n    streetDirections = {\\n       1: [1, 3],\\n       2: [0, 2],\\n       3: [2, 3],\\n       4: [1, 2],\\n       5: [0, 3],\\n       6: [0, 1]\\n    }\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        def dfs(i: int, j: int, oppositeDirection: int) -> None:\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] < 0:\\n                return\\n            v = grid[i][j]\\n            sd = Solution.streetDirections[v]\\n            direction = (oppositeDirection + 2) % 4\\n            if direction not in sd:\\n                return\\n            grid[i][j] = -v\\n            for d in sd:\\n                delta = Solution.directions[d]\\n                dfs(i+delta[0], j+delta[1], d)\\n        dfs(0, 0, 0)\\n        dfs(0, 0, 3)\\n        return grid[m-1][n-1] < 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561344,
                "title": "clean-very-easy-to-understand-java-dfs",
                "content": "```\\nclass Solution {\\n    Valid roads[];\\n    boolean visited[][];\\n\\n    class Valid{\\n        List<Integer> left, right, top, down;\\n\\n        public Valid(){\\n            left = right = top = down = new ArrayList<>();\\n        }        \\n    }\\n    \\n    public boolean isValid(int i, int j, int m, int n){\\n        if(i < 0 || j < 0 || i > m-1 || j > n-1 || visited[i][j]) return false;\\n        return true; \\n    }\\n    \\n    public boolean dfs(int[][] grid, int i, int j){\\n        int m = grid.length, n = grid[0].length, curr = grid[i][j];\\n        if(i == grid.length-1 && j == grid[0].length-1) return true;\\n        visited[i][j] = true; \\n                    \\n        if (isValid(i-1, j, m, n) && roads[curr].top.contains(grid[i-1][j]) && dfs(grid, i-1, j)) return true;\\n        if (isValid(i+1, j, m, n) && roads[curr].down.contains(grid[i+1][j]) && dfs(grid, i+1, j)) return true;\\n        if (isValid(i, j-1, m, n) && roads[curr].left.contains(grid[i][j-1]) && dfs(grid, i, j-1)) return true;\\n        if (isValid(i, j+1, m, n) && roads[curr].right.contains(grid[i][j+1]) && dfs(grid, i, j+1)) return true;\\n                \\n        return false;\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        visited = new boolean[grid.length][grid[0].length];\\n        roads = new Valid[7];\\n \\n        for(int i = 1; i <= 6; i++) roads[i] = new Valid(); \\n            \\n        roads[1].left = roads[3].left = roads[5].left =  Arrays.asList(1, 4, 6);\\n        roads[1].right = roads[4].right = roads[6].right =  Arrays.asList(1, 3, 5);\\n        roads[2].top = roads[5].top = roads[6].top =  Arrays.asList(2, 3, 4);\\n        roads[2].down = roads[3].down = roads[4].down =  Arrays.asList(2, 5, 6);\\n        \\n        return dfs(grid, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Valid roads[];\\n    boolean visited[][];\\n\\n    class Valid{\\n        List<Integer> left, right, top, down;\\n\\n        public Valid(){\\n            left = right = top = down = new ArrayList<>();\\n        }        \\n    }\\n    \\n    public boolean isValid(int i, int j, int m, int n){\\n        if(i < 0 || j < 0 || i > m-1 || j > n-1 || visited[i][j]) return false;\\n        return true; \\n    }\\n    \\n    public boolean dfs(int[][] grid, int i, int j){\\n        int m = grid.length, n = grid[0].length, curr = grid[i][j];\\n        if(i == grid.length-1 && j == grid[0].length-1) return true;\\n        visited[i][j] = true; \\n                    \\n        if (isValid(i-1, j, m, n) && roads[curr].top.contains(grid[i-1][j]) && dfs(grid, i-1, j)) return true;\\n        if (isValid(i+1, j, m, n) && roads[curr].down.contains(grid[i+1][j]) && dfs(grid, i+1, j)) return true;\\n        if (isValid(i, j-1, m, n) && roads[curr].left.contains(grid[i][j-1]) && dfs(grid, i, j-1)) return true;\\n        if (isValid(i, j+1, m, n) && roads[curr].right.contains(grid[i][j+1]) && dfs(grid, i, j+1)) return true;\\n                \\n        return false;\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        visited = new boolean[grid.length][grid[0].length];\\n        roads = new Valid[7];\\n \\n        for(int i = 1; i <= 6; i++) roads[i] = new Valid(); \\n            \\n        roads[1].left = roads[3].left = roads[5].left =  Arrays.asList(1, 4, 6);\\n        roads[1].right = roads[4].right = roads[6].right =  Arrays.asList(1, 3, 5);\\n        roads[2].top = roads[5].top = roads[6].top =  Arrays.asList(2, 3, 4);\\n        roads[2].down = roads[3].down = roads[4].down =  Arrays.asList(2, 5, 6);\\n        \\n        return dfs(grid, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559775,
                "title": "java-dfs-explanation-easy-solution-using-directions-enum",
                "content": "Enums could be a great replacement to direction arrays as they are easy to use and understand.\\n\\nHere I have used the direction enum to depict left/right/up/down directions.\\n\\nIt\\'s a simple dfs solution where when you are at a current cell you do the following:\\n* make sure it\\'s within grid\\'s boundary\\n* make sure it\\'s an unvisited cell\\n* make sure whatever direction was used to enter into this cell, is actually allowed.\\n* make sure it\\'s not the destination (it it is then return true as you were able to reach cell)\\n* then, out of all the possible 4 directions proceed with all the  directions towards which you can proceed from current cell (i.e. not knowing whether the other cell will accept or not. just make sure current cell allows outgoing from current cell. incoming will be checked in the starting of function of the other cell).\\n* if none returns true, then not possible and return false.\\n\\nMain thing to note here is the doesConnect() function. It takes the type of the cell and a direction (can be outgoing direction or the incoming direction). Doesn\\'t matter.\\n\\n```\\nclass Solution {\\n    // 9 depicts visited cell\\n    public boolean hasValidPath(int[][] grid) {\\n        return travel(grid,0,0,direction.START);\\n    }\\n    private boolean travel(int[][] grid, int i, int j, direction dir){\\n        if(dir!=direction.START){\\n            // boundary and visited check\\n            if(i<0 || j<0 || i>= grid.length || j>= grid[0].length || grid[i][j] == 9) return false;\\n            // acceptance check (whether this cell allows entry from the given direction)\\n            if(!doesConnect(grid[i][j],dir)) return false;\\n        }\\n        // destination check\\n        if(i==grid.length-1 && j==grid[0].length-1) return true;\\n        // visit\\n        int type = grid[i][j];\\n        grid[i][j] = 9;\\n        \\n        // all directions out of 4, where this can send next\\n        if((doesConnect(type,direction.UP) && travel(grid,i-1,j,direction.DOWN)) ||\\n           (doesConnect(type,direction.DOWN) && travel(grid,i+1,j,direction.UP)) ||\\n           (doesConnect(type,direction.LEFT) && travel(grid,i,j-1,direction.RIGHT)) ||\\n           (doesConnect(type,direction.RIGHT) && travel(grid,i,j+1,direction.LEFT))\\n            ) return true;\\n        // unvisit\\n        grid[i][j] = type;\\n        return false;\\n    }\\n    private boolean doesConnect(int type, direction dir){\\n        if(dir==direction.UP){\\n            return type == 2 || type == 5 || type == 6;\\n        } else if(dir==direction.DOWN){\\n            return type == 2 || type == 3 || type == 4;\\n        } else if(dir==direction.LEFT){\\n            return type == 1 || type == 3 || type == 5;\\n        } else if(dir==direction.RIGHT){\\n            return type == 1 || type == 4 || type == 6;\\n        }\\n        return false;\\n    }\\n}\\n\\nenum direction {\\n    LEFT,RIGHT,UP,DOWN,START;\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    // 9 depicts visited cell\\n    public boolean hasValidPath(int[][] grid) {\\n        return travel(grid,0,0,direction.START);\\n    }\\n    private boolean travel(int[][] grid, int i, int j, direction dir){\\n        if(dir!=direction.START){\\n            // boundary and visited check\\n            if(i<0 || j<0 || i>= grid.length || j>= grid[0].length || grid[i][j] == 9) return false;\\n            // acceptance check (whether this cell allows entry from the given direction)\\n            if(!doesConnect(grid[i][j],dir)) return false;\\n        }\\n        // destination check\\n        if(i==grid.length-1 && j==grid[0].length-1) return true;\\n        // visit\\n        int type = grid[i][j];\\n        grid[i][j] = 9;\\n        \\n        // all directions out of 4, where this can send next\\n        if((doesConnect(type,direction.UP) && travel(grid,i-1,j,direction.DOWN)) ||\\n           (doesConnect(type,direction.DOWN) && travel(grid,i+1,j,direction.UP)) ||\\n           (doesConnect(type,direction.LEFT) && travel(grid,i,j-1,direction.RIGHT)) ||\\n           (doesConnect(type,direction.RIGHT) && travel(grid,i,j+1,direction.LEFT))\\n            ) return true;\\n        // unvisit\\n        grid[i][j] = type;\\n        return false;\\n    }\\n    private boolean doesConnect(int type, direction dir){\\n        if(dir==direction.UP){\\n            return type == 2 || type == 5 || type == 6;\\n        } else if(dir==direction.DOWN){\\n            return type == 2 || type == 3 || type == 4;\\n        } else if(dir==direction.LEFT){\\n            return type == 1 || type == 3 || type == 5;\\n        } else if(dir==direction.RIGHT){\\n            return type == 1 || type == 4 || type == 6;\\n        }\\n        return false;\\n    }\\n}\\n\\nenum direction {\\n    LEFT,RIGHT,UP,DOWN,START;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550049,
                "title": "c-dfs",
                "content": "I encoded each type of road as a 4-tuple with corresponding directions {North, East, South, West}. If road **a** connects **b** and we\\'re moving in some direction {0, 1, 2, 3} then their opposite components must be equal to 1. By opposite I mean for example North and South, Weast and East. \\n\\nI used a simple dfs-approach. Starting from the top-left cell check each unvisited neighbour road if it is connected to the current cell.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> visited;\\n    vector<vector<int>> roads = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, 1}, {0, 1, 1, 0}, {1, 0, 0, 1}, {1, 1, 0, 0}};\\n    vector<pair<int, int>> dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n    \\n    bool connected(int a, int b, int k){\\n        return roads[a][k] && roads[b][(k + 2) % 4];\\n    }\\n    \\n    bool dfs(vector<vector<int>>& grid, int i, int j){\\n        if(i == grid.size() - 1 && j == grid.front().size() - 1)\\n            return true;\\n        \\n        if(!visited[i][j]){\\n            visited[i][j] = true;\\n            \\n            for(int k = 0; k < dirs.size() ++k){\\n                int di = i + dirs[k].first;\\n                int dj = j + dirs[k].second;\\n                \\n                if(di >= 0 && di < grid.size() && dj >= 0 && dj < grid.front().size() && connected(grid[i][j] - 1, grid[di][dj] - 1, k) && dfs(grid, di, dj))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        visited.resize(grid.size(), vector<bool>(grid.front().size()));\\n        return dfs(grid, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> visited;\\n    vector<vector<int>> roads = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, 1}, {0, 1, 1, 0}, {1, 0, 0, 1}, {1, 1, 0, 0}};\\n    vector<pair<int, int>> dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n    \\n    bool connected(int a, int b, int k){\\n        return roads[a][k] && roads[b][(k + 2) % 4];\\n    }\\n    \\n    bool dfs(vector<vector<int>>& grid, int i, int j){\\n        if(i == grid.size() - 1 && j == grid.front().size() - 1)\\n            return true;\\n        \\n        if(!visited[i][j]){\\n            visited[i][j] = true;\\n            \\n            for(int k = 0; k < dirs.size() ++k){\\n                int di = i + dirs[k].first;\\n                int dj = j + dirs[k].second;\\n                \\n                if(di >= 0 && di < grid.size() && dj >= 0 && dj < grid.front().size() && connected(grid[i][j] - 1, grid[di][dj] - 1, k) && dfs(grid, di, dj))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        visited.resize(grid.size(), vector<bool>(grid.front().size()));\\n        return dfs(grid, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549804,
                "title": "java-graph-cutting-union-find",
                "content": "Follow the [idea](https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/discuss/547229/Python-Union-Find) and give a java veriosn:\\n\\n```java\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int t = 2*n + 1;\\n        UF uf = new UF((2*m + 1)*(2*n + 1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 || grid[i][j] == 3 || grid[i][j] == 5) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i + 1, 2*j, t));\\n                }\\n                if (grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i + 1, 2*j + 2, t));\\n                }\\n                if (grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i + 2, 2*j + 1, t));\\n                }\\n                if (grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i, 2*j + 1, t));\\n                }\\n            }\\n        }\\n        return uf.isConnected(g(1, 1, t), g(2*m - 1, 2*n - 1, t));\\n    }\\n    \\n    public int g(int r, int c, int n) {\\n        return r*n + c;\\n    }\\n    \\n    class UF {\\n        private int[] parents;\\n        \\n        public UF(int n) {\\n            parents = new int[n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                parents[i] = i;\\n            }\\n        }\\n        \\n        public int find(int node) {\\n            while (node != parents[node]) {\\n                parents[node] = parents[parents[node]];\\n                node = parents[node];\\n            }\\n            return node;\\n        }\\n        \\n        public void union(int node1, int node2) {\\n            int root1 = find(node1);\\n            int root2 = find(node2);\\n            if (root1 != root2) {\\n                parents[root1] = root2;\\n            }\\n        }\\n        \\n        public boolean isConnected(int node1, int node2) {\\n            return find(node1) == find(node2);\\n        }\\n    }\\n}\\n```\\n\\n**explanation**\\n\\na classic 2D-array Union-Find tranform to 1D is :\\n```\\n    public int g(int r, int c, int n) {\\n        return r*n + c;\\n    }\\n```\\n\\nSimilar basic 2D Union-Find problem : [200. Number of Islands](https://leetcode.com/problems/number-of-islands/)\\n\\nAnd I called this type of problems **Graph Cutting Union Find**\\n\\nSimilar graph cutting uf problem : [959. Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes/)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int t = 2*n + 1;\\n        UF uf = new UF((2*m + 1)*(2*n + 1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 || grid[i][j] == 3 || grid[i][j] == 5) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i + 1, 2*j, t));\\n                }\\n                if (grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i + 1, 2*j + 2, t));\\n                }\\n                if (grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i + 2, 2*j + 1, t));\\n                }\\n                if (grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6) {\\n                    uf.union(g(2*i + 1, 2*j + 1, t), g(2*i, 2*j + 1, t));\\n                }\\n            }\\n        }\\n        return uf.isConnected(g(1, 1, t), g(2*m - 1, 2*n - 1, t));\\n    }\\n    \\n    public int g(int r, int c, int n) {\\n        return r*n + c;\\n    }\\n    \\n    class UF {\\n        private int[] parents;\\n        \\n        public UF(int n) {\\n            parents = new int[n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                parents[i] = i;\\n            }\\n        }\\n        \\n        public int find(int node) {\\n            while (node != parents[node]) {\\n                parents[node] = parents[parents[node]];\\n                node = parents[node];\\n            }\\n            return node;\\n        }\\n        \\n        public void union(int node1, int node2) {\\n            int root1 = find(node1);\\n            int root2 = find(node2);\\n            if (root1 != root2) {\\n                parents[root1] = root2;\\n            }\\n        }\\n        \\n        public boolean isConnected(int node1, int node2) {\\n            return find(node1) == find(node2);\\n        }\\n    }\\n}\\n```\n```\\n    public int g(int r, int c, int n) {\\n        return r*n + c;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547945,
                "title": "java-dfs-map",
                "content": "In DFS, add a map to define what are all compatible configurations for 1 to 6 along 4 directions.\\nR -> To the right\\nL -> To the left\\nU -> Upwards\\nD -> Downwards.\\n0 - is only for starting left top cell.\\nNormal DFS + checking what was the prior cell before coming to current cell using \"dir\". Checking if current grid value is compatible with previous \"dir\".\\nEnd condition is met once we reach the destination.\\nRun time 83 ms\\tSpace 258.4 MB\\n```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        Map<String, List<Integer>> map = new HashMap<>();\\n        createMap(map);\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        return dfs(grid, visited, 0, 0, map, \"0\");\\n    }\\n    \\n    boolean dfs(int[][] grid, boolean[][] visited, int x, int y, Map<String, List<Integer>> map, String dir) {\\n        int rows = grid.length - 1;\\n        int cols = grid[0].length - 1;\\n        if(x < 0 || x > rows || y < 0 || y > cols || visited[x][y]) {\\n            return false;\\n        }\\n        if(!map.containsKey(dir)) {\\n            return false;\\n        }\\n        if(!map.get(dir).contains(grid[x][y])) {\\n            return false;\\n        }\\n        if(x == rows && y == cols) {\\n            return true;\\n        }\\n        visited[x][y] = true;\\n        boolean result = dfs(grid, visited, x + 1, y, map, grid[x][y] + \"D\")\\n            || dfs(grid, visited, x, y + 1, map, grid[x][y] + \"R\")\\n            || dfs(grid, visited, x - 1, y , map, grid[x][y] + \"U\")\\n            || dfs(grid, visited, x, y - 1, map, grid[x][y] + \"L\");\\n        visited[x][y] = false;\\n        return result;\\n    }\\n    \\n      void createMap(Map<String, List<Integer>> map) {\\n        List<Integer> oneThreeFive = Arrays.asList(1,3,5);\\n        List<Integer> twoThreeFour = Arrays.asList(2,3,4);\\n        List<Integer> oneFourSix = Arrays.asList(1,4,6);\\n        List<Integer> twoFiveSix = Arrays.asList(2,5,6);\\n        map.put(\"0\", Arrays.asList(1,2,3,4,5,6));\\n        map.put(\"1R\", oneThreeFive);\\n        map.put(\"1L\", oneFourSix);\\n        map.put(\"2D\", twoFiveSix);\\n        map.put(\"2U\", twoThreeFour);\\n        map.put(\"3L\", oneFourSix);\\n        map.put(\"3D\", twoFiveSix);\\n        map.put(\"4R\", oneThreeFive);\\n        map.put(\"4D\", twoFiveSix);\\n        map.put(\"5L\", oneFourSix);\\n        map.put(\"5U\", twoThreeFour);\\n        map.put(\"6R\", oneThreeFive);\\n        map.put(\"6U\", twoThreeFour);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        Map<String, List<Integer>> map = new HashMap<>();\\n        createMap(map);\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        return dfs(grid, visited, 0, 0, map, \"0\");\\n    }\\n    \\n    boolean dfs(int[][] grid, boolean[][] visited, int x, int y, Map<String, List<Integer>> map, String dir) {\\n        int rows = grid.length - 1;\\n        int cols = grid[0].length - 1;\\n        if(x < 0 || x > rows || y < 0 || y > cols || visited[x][y]) {\\n            return false;\\n        }\\n        if(!map.containsKey(dir)) {\\n            return false;\\n        }\\n        if(!map.get(dir).contains(grid[x][y])) {\\n            return false;\\n        }\\n        if(x == rows && y == cols) {\\n            return true;\\n        }\\n        visited[x][y] = true;\\n        boolean result = dfs(grid, visited, x + 1, y, map, grid[x][y] + \"D\")\\n            || dfs(grid, visited, x, y + 1, map, grid[x][y] + \"R\")\\n            || dfs(grid, visited, x - 1, y , map, grid[x][y] + \"U\")\\n            || dfs(grid, visited, x, y - 1, map, grid[x][y] + \"L\");\\n        visited[x][y] = false;\\n        return result;\\n    }\\n    \\n      void createMap(Map<String, List<Integer>> map) {\\n        List<Integer> oneThreeFive = Arrays.asList(1,3,5);\\n        List<Integer> twoThreeFour = Arrays.asList(2,3,4);\\n        List<Integer> oneFourSix = Arrays.asList(1,4,6);\\n        List<Integer> twoFiveSix = Arrays.asList(2,5,6);\\n        map.put(\"0\", Arrays.asList(1,2,3,4,5,6));\\n        map.put(\"1R\", oneThreeFive);\\n        map.put(\"1L\", oneFourSix);\\n        map.put(\"2D\", twoFiveSix);\\n        map.put(\"2U\", twoThreeFour);\\n        map.put(\"3L\", oneFourSix);\\n        map.put(\"3D\", twoFiveSix);\\n        map.put(\"4R\", oneThreeFive);\\n        map.put(\"4D\", twoFiveSix);\\n        map.put(\"5L\", oneFourSix);\\n        map.put(\"5U\", twoThreeFour);\\n        map.put(\"6R\", oneThreeFive);\\n        map.put(\"6U\", twoThreeFour);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547411,
                "title": "python3-bfs-using-states",
                "content": "`Street 1` can only move left `(0, -1)` or right `(0, 1)` and the only streets that can be connected when going left is `Street 1, 4, 6` and when doing right is `Street 1, 3, 5`.\\n`Street 2` can only move down `(1, 0)` or up `(-1, 0)` and the only streets that can be connected when going down is `Street 2, 5, 6` and when going up is `Street 2, 3, 4`.\\n`Street 3,4,5,6` with the same concept.\\n\\nThe rest is just BFS until we get to `(m-1, n-1)` if possible.\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        L, R = {(0, -1): {1, 4, 6}}, {(0, 1): {1, 3, 5}} \\n        U, D = {(-1, 0): {2, 3, 4}}, {(1, 0): {2, 5, 6}}         \\n        states = {\\n            1: {**L, **R},\\n            2: {**U, **D},\\n            3: {**L, **D},\\n            4: {**R, **D},\\n            5: {**L, **U},\\n            6: {**R, **U}\\n        }\\n        \\n        q = collections.deque([(0, 0)])\\n        visited = set()\\n        m, n = len(grid), len(grid[0])\\n        \\n        while q:\\n            x, y = q.popleft()\\n            if (x, y) == (m-1, n-1):\\n                return True\\n            street = grid[x][y]\\n            for dx, dy in states[street]:\\n                i, j = x + dx, y + dy\\n                if 0 <= i < m and  0 <= j < n and (i, j) not in visited and grid[i][j] in states[street][dx,dy]:\\n                    q.append((i, j))\\n                    visited.add((i, j))\\n        return False  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        L, R = {(0, -1): {1, 4, 6}}, {(0, 1): {1, 3, 5}} \\n        U, D = {(-1, 0): {2, 3, 4}}, {(1, 0): {2, 5, 6}}         \\n        states = {\\n            1: {**L, **R},\\n            2: {**U, **D},\\n            3: {**L, **D},\\n            4: {**R, **D},\\n            5: {**L, **U},\\n            6: {**R, **U}\\n        }\\n        \\n        q = collections.deque([(0, 0)])\\n        visited = set()\\n        m, n = len(grid), len(grid[0])\\n        \\n        while q:\\n            x, y = q.popleft()\\n            if (x, y) == (m-1, n-1):\\n                return True\\n            street = grid[x][y]\\n            for dx, dy in states[street]:\\n                i, j = x + dx, y + dy\\n                if 0 <= i < m and  0 <= j < n and (i, j) not in visited and grid[i][j] in states[street][dx,dy]:\\n                    q.append((i, j))\\n                    visited.add((i, j))\\n        return False  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089053,
                "title": "ugly-but-running-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<bool>>vis;\\n    bool hasValidPath(vector<vector<int>>& grid) \\n    {\\n        n = grid.size();\\n        m = grid[0].size();\\n        int row = 0;\\n        int col = 0;\\n        vis.resize(grid.size(),vector<bool>(grid[0].size(),false));\\n        return fun(grid,row,col,n,m);    \\n    }\\n    bool fun(vector<vector<int>>&grid,int row,int col,int &n,int &m)\\n    {\\n         cout<<\"row = \"<<row<<\" \"<<\"col = \"<<col<<endl;\\n         if(row == (n-1) and col == (m-1))\\n         {\\n             cout<<\"hello\"<<endl;\\n             return true;   //condition has fullfilled\\n         }\\n\\n         if(row < 0 or row >= n or col < 0 or col >= m)\\n         {\\n              return false;  //out of bound condition\\n         }\\n        \\n         int nextrow  = -1;\\n         int nextcol = -1;\\n\\n         int num = grid[row][col];\\n         if(num == 1)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n             \\n             vis[row][col] = true;\\n\\n             if(isValid(row,col-1) == true and vis[row][col-1] == false and (grid[row][col-1] == 4 or grid[row][col-1] == 6 or grid[row][col-1] == 1))  //4 6 \\n             a = fun(grid,row,col-1,n,m);   //moving left side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row,col+1) == true and vis[row][col+1] == false and (grid[row][col+1] == 3 or grid[row][col+1] == 5  or grid[row][col+1] == 1)) // 3 5\\n             b = fun(grid,row,col+1,n,m);   //moving the right side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 2)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n\\n             vis[row][col] = true;\\n\\n             if(isValid(row-1,col) == true and vis[row-1][col] == false and (grid[row-1][col] == 3 or grid[row-1][col] == 4 or grid[row-1][col] == 2)) // 3 4\\n             a = fun(grid,row-1,col,n,m);   //moving the upper side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row+1,col) == true and vis[row+1][col] == false and (grid[row+1][col] == 5 or grid[row+1][col] == 6 or grid[row+1][col] == 2))  //5 6\\n             b = fun(grid,row+1,col,n,m);   //moving the lower side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 3)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n            \\n             vis[row][col] = true;\\n\\n             if(isValid(row,col-1) == true and vis[row][col-1] == false and (grid[row][col-1]==1 or grid[row][col-1] == 4 or grid[row][col-1] == 6 or grid[row][col-1] == 3))  //1 4 6\\n             a = fun(grid,row,col-1,n,m);   //moving left side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row+1,col) == true and vis[row+1][col] == false and (grid[row+1][col] == 2 or grid[row+1][col] == 5 or grid[row+1][col] == 6))  //2 5 6\\n             b = fun(grid,row+1,col,n,m);   //moving the lower side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 4)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n             \\n\\n             vis[row][col] = true;\\n\\n             if(isValid(row,col+1) == true and vis[row][col+1] == false and (grid[row][col+1] == 1 or grid[row][col+1] == 3 or grid[row][col+1] == 5 or grid[row][col+1] == 4))  //1 3 5\\n             a = fun(grid,row,col+1,n,m);   //moving right side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row+1,col) == true and vis[row+1][col] == false and (grid[row+1][col] == 2 or grid[row+1][col] == 5 or grid[row+1][col] == 6)) // 2 5 6\\n             b = fun(grid,row+1,col,n,m);   //moving the lower side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n         \\n         if(num == 5)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n \\n             vis[row][col] = true;\\n\\n             if(isValid(row,col-1) == true and vis[row][col-1] == false and (grid[row][col-1] == 1 or grid[row][col-1] == 4 or grid[row][col-1] == 6)) // 1 4 6\\n             a = fun(grid,row,col-1,n,m);   //moving left side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row-1,col) == true and vis[row-1][col] == false and (grid[row-1][col]==2 or grid[row-1][col] == 3 or grid[row-1][col] == 4)) // 2 3 4\\n             b = fun(grid,row-1,col,n,m);    //moving the upper cell\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 6)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n\\n              vis[row][col] = true;\\n\\n              if(isValid(row,col+1) == true and vis[row][col+1] == false and (grid[row][col+1] == 1 or grid[row][col+1] == 3 or grid[row][col+1] == 5)) //1 3 5\\n              a = fun(grid,row,col+1,n,m);   //moving right side\\n\\n              if(a == true) return true;\\n\\n              if(isValid(row-1,col) == true and vis[row-1][col] == false and (grid[row-1][col] == 2 or grid[row-1][col] == 3 or grid[row-1][col] == 4)) //2 3 4\\n              b = fun(grid,row-1,col,n,m);   //moving the upper cell\\n\\n              vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n         \\n         return false;\\n    }\\n    bool isValid(int row,int col)\\n    {\\n        if(row < 0 or row >= n or col < 0 or col >= m)\\n        return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<bool>>vis;\\n    bool hasValidPath(vector<vector<int>>& grid) \\n    {\\n        n = grid.size();\\n        m = grid[0].size();\\n        int row = 0;\\n        int col = 0;\\n        vis.resize(grid.size(),vector<bool>(grid[0].size(),false));\\n        return fun(grid,row,col,n,m);    \\n    }\\n    bool fun(vector<vector<int>>&grid,int row,int col,int &n,int &m)\\n    {\\n         cout<<\"row = \"<<row<<\" \"<<\"col = \"<<col<<endl;\\n         if(row == (n-1) and col == (m-1))\\n         {\\n             cout<<\"hello\"<<endl;\\n             return true;   //condition has fullfilled\\n         }\\n\\n         if(row < 0 or row >= n or col < 0 or col >= m)\\n         {\\n              return false;  //out of bound condition\\n         }\\n        \\n         int nextrow  = -1;\\n         int nextcol = -1;\\n\\n         int num = grid[row][col];\\n         if(num == 1)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n             \\n             vis[row][col] = true;\\n\\n             if(isValid(row,col-1) == true and vis[row][col-1] == false and (grid[row][col-1] == 4 or grid[row][col-1] == 6 or grid[row][col-1] == 1))  //4 6 \\n             a = fun(grid,row,col-1,n,m);   //moving left side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row,col+1) == true and vis[row][col+1] == false and (grid[row][col+1] == 3 or grid[row][col+1] == 5  or grid[row][col+1] == 1)) // 3 5\\n             b = fun(grid,row,col+1,n,m);   //moving the right side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 2)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n\\n             vis[row][col] = true;\\n\\n             if(isValid(row-1,col) == true and vis[row-1][col] == false and (grid[row-1][col] == 3 or grid[row-1][col] == 4 or grid[row-1][col] == 2)) // 3 4\\n             a = fun(grid,row-1,col,n,m);   //moving the upper side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row+1,col) == true and vis[row+1][col] == false and (grid[row+1][col] == 5 or grid[row+1][col] == 6 or grid[row+1][col] == 2))  //5 6\\n             b = fun(grid,row+1,col,n,m);   //moving the lower side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 3)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n            \\n             vis[row][col] = true;\\n\\n             if(isValid(row,col-1) == true and vis[row][col-1] == false and (grid[row][col-1]==1 or grid[row][col-1] == 4 or grid[row][col-1] == 6 or grid[row][col-1] == 3))  //1 4 6\\n             a = fun(grid,row,col-1,n,m);   //moving left side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row+1,col) == true and vis[row+1][col] == false and (grid[row+1][col] == 2 or grid[row+1][col] == 5 or grid[row+1][col] == 6))  //2 5 6\\n             b = fun(grid,row+1,col,n,m);   //moving the lower side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 4)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n             \\n\\n             vis[row][col] = true;\\n\\n             if(isValid(row,col+1) == true and vis[row][col+1] == false and (grid[row][col+1] == 1 or grid[row][col+1] == 3 or grid[row][col+1] == 5 or grid[row][col+1] == 4))  //1 3 5\\n             a = fun(grid,row,col+1,n,m);   //moving right side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row+1,col) == true and vis[row+1][col] == false and (grid[row+1][col] == 2 or grid[row+1][col] == 5 or grid[row+1][col] == 6)) // 2 5 6\\n             b = fun(grid,row+1,col,n,m);   //moving the lower side\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n         \\n         if(num == 5)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n \\n             vis[row][col] = true;\\n\\n             if(isValid(row,col-1) == true and vis[row][col-1] == false and (grid[row][col-1] == 1 or grid[row][col-1] == 4 or grid[row][col-1] == 6)) // 1 4 6\\n             a = fun(grid,row,col-1,n,m);   //moving left side\\n\\n             if(a == true) return true;\\n\\n             if(isValid(row-1,col) == true and vis[row-1][col] == false and (grid[row-1][col]==2 or grid[row-1][col] == 3 or grid[row-1][col] == 4)) // 2 3 4\\n             b = fun(grid,row-1,col,n,m);    //moving the upper cell\\n\\n             vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n\\n         if(num == 6)    //can move in the left or in the right\\n         {\\n             bool a = false;\\n             bool b = false;\\n\\n              vis[row][col] = true;\\n\\n              if(isValid(row,col+1) == true and vis[row][col+1] == false and (grid[row][col+1] == 1 or grid[row][col+1] == 3 or grid[row][col+1] == 5)) //1 3 5\\n              a = fun(grid,row,col+1,n,m);   //moving right side\\n\\n              if(a == true) return true;\\n\\n              if(isValid(row-1,col) == true and vis[row-1][col] == false and (grid[row-1][col] == 2 or grid[row-1][col] == 3 or grid[row-1][col] == 4)) //2 3 4\\n              b = fun(grid,row-1,col,n,m);   //moving the upper cell\\n\\n              vis[row][col] = false;\\n\\n             if(a == true or b == true)\\n             return true;\\n         }\\n         \\n         return false;\\n    }\\n    bool isValid(int row,int col)\\n    {\\n        if(row < 0 or row >= n or col < 0 or col >= m)\\n        return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3355051,
                "title": "c-dfs-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\no(n*m)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i < 0 || j < 0 || i >= n || j >= m) return false;\\n        if(i == n-1 && j == m-1) return true; \\n        vis[i][j] = true;\\n\\n        bool reached = false;\\n        if(grid[i][j] == 1) {\\n            if(j+1 < m && !vis[i][j+1] && grid[i][j+1] != 2) {\\n                reached = solve(i,j+1,grid,vis);\\n            }\\n            if(j-1 >= 0 && !vis[i][j-1] && grid[i][j-1] != 2) {\\n                reached = reached | solve(i,j-1,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 2) {\\n            if(i-1 >= 0 && !vis[i-1][j] && grid[i-1][j] != 1) {\\n                reached = solve(i-1,j,grid,vis);\\n            }\\n            if(i+1 < n && !vis[i+1][j] && grid[i+1][j] != 1) {\\n                reached = reached | solve(i+1,j,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 3) {\\n            if(i+1 < n && !vis[i+1][j] && (grid[i+1][j] == 2 || grid[i+1][j] == 6 || grid[i+1][j] == 5)) {\\n                reached = solve(i+1,j,grid,vis);\\n            }\\n            if(j-1 >= 0 && !vis[i][j-1] && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6)) {\\n                reached = reached | solve(i,j-1,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 4) {\\n            if(j+1 < m && !vis[i][j+1] && (grid[i][j+1] == 5 || grid[i][j+1] == 1 || grid[i][j+1] == 3)) {\\n                reached = solve(i,j+1,grid,vis);\\n            }\\n            if(i+1 < n && !vis[i+1][j] && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6)) {\\n                reached = reached | solve(i+1,j,grid,vis);\\n            }\\n        } \\n        else if(grid[i][j] == 5) {\\n            if(i-1 >= 0 && !vis[i-1][j] && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)) {\\n                reached = solve(i-1,j,grid,vis);\\n            }\\n            if(j-1 >= 0 && !vis[i][j-1] && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 5)) {\\n                reached = reached | solve(i,j-1,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 6) {\\n            if(i-1 >= 0 && !vis[i-1][j] && (grid[i-1][j] == 4 || grid[i-1][j] == 3 || grid[i-1][j] == 2)) {\\n                reached = solve(i-1,j,grid,vis);\\n            }\\n            if(j+1 < m && !vis[i][j+1] && (grid[i][j+1] == 5 || grid[i][j+1] == 3 || grid[i][j+1] == 1)) {\\n                reached = reached | solve(i,j+1,grid,vis);\\n            }\\n        }\\n\\n        return reached;\\n    }\\n\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();       \\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        return solve(0,0,grid,vis);\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i < 0 || j < 0 || i >= n || j >= m) return false;\\n        if(i == n-1 && j == m-1) return true; \\n        vis[i][j] = true;\\n\\n        bool reached = false;\\n        if(grid[i][j] == 1) {\\n            if(j+1 < m && !vis[i][j+1] && grid[i][j+1] != 2) {\\n                reached = solve(i,j+1,grid,vis);\\n            }\\n            if(j-1 >= 0 && !vis[i][j-1] && grid[i][j-1] != 2) {\\n                reached = reached | solve(i,j-1,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 2) {\\n            if(i-1 >= 0 && !vis[i-1][j] && grid[i-1][j] != 1) {\\n                reached = solve(i-1,j,grid,vis);\\n            }\\n            if(i+1 < n && !vis[i+1][j] && grid[i+1][j] != 1) {\\n                reached = reached | solve(i+1,j,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 3) {\\n            if(i+1 < n && !vis[i+1][j] && (grid[i+1][j] == 2 || grid[i+1][j] == 6 || grid[i+1][j] == 5)) {\\n                reached = solve(i+1,j,grid,vis);\\n            }\\n            if(j-1 >= 0 && !vis[i][j-1] && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6)) {\\n                reached = reached | solve(i,j-1,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 4) {\\n            if(j+1 < m && !vis[i][j+1] && (grid[i][j+1] == 5 || grid[i][j+1] == 1 || grid[i][j+1] == 3)) {\\n                reached = solve(i,j+1,grid,vis);\\n            }\\n            if(i+1 < n && !vis[i+1][j] && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6)) {\\n                reached = reached | solve(i+1,j,grid,vis);\\n            }\\n        } \\n        else if(grid[i][j] == 5) {\\n            if(i-1 >= 0 && !vis[i-1][j] && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)) {\\n                reached = solve(i-1,j,grid,vis);\\n            }\\n            if(j-1 >= 0 && !vis[i][j-1] && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 5)) {\\n                reached = reached | solve(i,j-1,grid,vis);\\n            }\\n        }\\n        else if(grid[i][j] == 6) {\\n            if(i-1 >= 0 && !vis[i-1][j] && (grid[i-1][j] == 4 || grid[i-1][j] == 3 || grid[i-1][j] == 2)) {\\n                reached = solve(i-1,j,grid,vis);\\n            }\\n            if(j+1 < m && !vis[i][j+1] && (grid[i][j+1] == 5 || grid[i][j+1] == 3 || grid[i][j+1] == 1)) {\\n                reached = reached | solve(i,j+1,grid,vis);\\n            }\\n        }\\n\\n        return reached;\\n    }\\n\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();       \\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        return solve(0,0,grid,vis);\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966529,
                "title": "c-bfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n\\n- Space complexity:O(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        //if(grid[grid.size()-1][grid[0].size()-1]!=6 && grid[grid.size()-1][grid[0].size()-1]!=1){return false;}\\n        int p1=0, p2=0;\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector<vector<int>>v1(grid.size(), vector<int>(grid[0].size(), 1));\\n        queue<pair<int, int>>q;\\n        v[0][0]=1;\\n        q.push({0, 0});\\n        while(!q.empty()){\\n            int x=q.front().first, y=q.front().second;\\n            p1=x; p2=y;\\n            //cout<<x<<\" \"<<y<<endl;\\n            q.pop();\\n            //if(v==v1){break;}\\n            if(x==grid.size()-1 && y==grid[0].size()-1){return true;}\\n            if(grid[x][y]==1){\\n                if(y<grid[0].size()-1 && !v[x][y+1] && (grid[x][y+1]==3 || grid[x][y+1]==5 || grid[x][y+1]==1)){\\n                    v[x][y+1]=1;\\n                    q.push({x, y+1});\\n                }\\n                if(y>0 && !v[x][y-1] && (grid[x][y-1]==4 || grid[x][y-1]==6 || grid[x][y-1]==1)){\\n                    v[x][y-1]=1;\\n                    q.push({x, y-1});\\n                }\\n            }\\n            //if(grid[x][y]==2){\\n            else if(grid[x][y]==2){\\n                if(x<grid.size()-1 && !v[x+1][y] && (grid[x+1][y]==5 || grid[x+1][y]==6 || grid[x+1][y]==2)){\\n                    v[x+1][y]=1;\\n                    q.push({x+1, y});\\n                }\\n                if(x>0 && !v[x-1][y] && (grid[x-1][y]==4 || grid[x-1][y]==3 || grid[x-1][y]==2)){\\n                    q.push({x-1, y});\\n                    v[x-1][y]=1;\\n                }\\n            }\\n            else if(grid[x][y]==3){\\n                if(x<grid.size()-1 && !v[x+1][y] && (grid[x+1][y]==5 || grid[x+1][y]==6 || grid[x+1][y]==2)){\\n                    v[x+1][y]=1;\\n                    q.push({x+1, y});\\n                }\\n                if(y>0 && !v[x][y-1] && (grid[x][y-1]==4 || grid[x][y-1]==6 || grid[x][y-1]==1)){\\n                    q.push({x, y-1});\\n                    v[x][y-1]=1;\\n                }\\n            }\\n            else if(grid[x][y]==4){\\n                if(x<grid.size()-1 && !v[x+1][y] && (grid[x+1][y]==5 || grid[x+1][y]==6 || grid[x+1][y]==2)){\\n                    v[x+1][y]=1;\\n                    q.push({x+1, y});\\n                }\\n                if(y<grid[0].size()-1 && !v[x][y+1] && (grid[x][y+1]==1 || grid[x][y+1]==3) || grid[x][y+1]==5){\\n                    q.push({x, y+1});\\n                    v[x][y+1]=1;\\n                }\\n            }\\n            else if(grid[x][y]==5){\\n                if(x>0 && !v[x-1][y] && (grid[x-1][y]==2 || grid[x-1][y]==3 || grid[x-1][y]==4)){\\n                    v[x-1][y]=1;\\n                    q.push({x-1, y});\\n                }\\n                if(y>0 && !v[x][y-1] && (grid[x][y-1]==1 || grid[x][y-1]==4 || grid[x][y-1]==3)){\\n                    q.push({x, y-1});\\n                    v[x][y-1]=1;\\n                }\\n            }\\n            else if(grid[x][y]==6){\\n                if(x>0 && !v[x-1][y] && (grid[x-1][y]==1 || grid[x-1][y]==3 || grid[x-1][y]==5)){\\n                    v[x-1][y]=1;\\n                    q.push({x-1, y});\\n                }\\n                if(y<grid[0].size()-1 && !v[x][y+1] && (grid[x][y+1]==1 || grid[x][y+1]==3 || grid[x][y+1]==5)){\\n                    q.push({x, y+1});\\n                    v[x][y+1]=1;\\n                }\\n            }\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                cout<<v[i][j]<<\" \";\\n            }cout<<endl;\\n        }\\n        if(p1!=grid.size()-1 && p2!=grid[0].size()-1){return false;}\\n        if(v[grid.size()-1][grid[0].size()-1]==0){return false;}\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        //if(grid[grid.size()-1][grid[0].size()-1]!=6 && grid[grid.size()-1][grid[0].size()-1]!=1){return false;}\\n        int p1=0, p2=0;\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        vector<vector<int>>v1(grid.size(), vector<int>(grid[0].size(), 1));\\n        queue<pair<int, int>>q;\\n        v[0][0]=1;\\n        q.push({0, 0});\\n        while(!q.empty()){\\n            int x=q.front().first, y=q.front().second;\\n            p1=x; p2=y;\\n            //cout<<x<<\" \"<<y<<endl;\\n            q.pop();\\n            //if(v==v1){break;}\\n            if(x==grid.size()-1 && y==grid[0].size()-1){return true;}\\n            if(grid[x][y]==1){\\n                if(y<grid[0].size()-1 && !v[x][y+1] && (grid[x][y+1]==3 || grid[x][y+1]==5 || grid[x][y+1]==1)){\\n                    v[x][y+1]=1;\\n                    q.push({x, y+1});\\n                }\\n                if(y>0 && !v[x][y-1] && (grid[x][y-1]==4 || grid[x][y-1]==6 || grid[x][y-1]==1)){\\n                    v[x][y-1]=1;\\n                    q.push({x, y-1});\\n                }\\n            }\\n            //if(grid[x][y]==2){\\n            else if(grid[x][y]==2){\\n                if(x<grid.size()-1 && !v[x+1][y] && (grid[x+1][y]==5 || grid[x+1][y]==6 || grid[x+1][y]==2)){\\n                    v[x+1][y]=1;\\n                    q.push({x+1, y});\\n                }\\n                if(x>0 && !v[x-1][y] && (grid[x-1][y]==4 || grid[x-1][y]==3 || grid[x-1][y]==2)){\\n                    q.push({x-1, y});\\n                    v[x-1][y]=1;\\n                }\\n            }\\n            else if(grid[x][y]==3){\\n                if(x<grid.size()-1 && !v[x+1][y] && (grid[x+1][y]==5 || grid[x+1][y]==6 || grid[x+1][y]==2)){\\n                    v[x+1][y]=1;\\n                    q.push({x+1, y});\\n                }\\n                if(y>0 && !v[x][y-1] && (grid[x][y-1]==4 || grid[x][y-1]==6 || grid[x][y-1]==1)){\\n                    q.push({x, y-1});\\n                    v[x][y-1]=1;\\n                }\\n            }\\n            else if(grid[x][y]==4){\\n                if(x<grid.size()-1 && !v[x+1][y] && (grid[x+1][y]==5 || grid[x+1][y]==6 || grid[x+1][y]==2)){\\n                    v[x+1][y]=1;\\n                    q.push({x+1, y});\\n                }\\n                if(y<grid[0].size()-1 && !v[x][y+1] && (grid[x][y+1]==1 || grid[x][y+1]==3) || grid[x][y+1]==5){\\n                    q.push({x, y+1});\\n                    v[x][y+1]=1;\\n                }\\n            }\\n            else if(grid[x][y]==5){\\n                if(x>0 && !v[x-1][y] && (grid[x-1][y]==2 || grid[x-1][y]==3 || grid[x-1][y]==4)){\\n                    v[x-1][y]=1;\\n                    q.push({x-1, y});\\n                }\\n                if(y>0 && !v[x][y-1] && (grid[x][y-1]==1 || grid[x][y-1]==4 || grid[x][y-1]==3)){\\n                    q.push({x, y-1});\\n                    v[x][y-1]=1;\\n                }\\n            }\\n            else if(grid[x][y]==6){\\n                if(x>0 && !v[x-1][y] && (grid[x-1][y]==1 || grid[x-1][y]==3 || grid[x-1][y]==5)){\\n                    v[x-1][y]=1;\\n                    q.push({x-1, y});\\n                }\\n                if(y<grid[0].size()-1 && !v[x][y+1] && (grid[x][y+1]==1 || grid[x][y+1]==3 || grid[x][y+1]==5)){\\n                    q.push({x, y+1});\\n                    v[x][y+1]=1;\\n                }\\n            }\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                cout<<v[i][j]<<\" \";\\n            }cout<<endl;\\n        }\\n        if(p1!=grid.size()-1 && p2!=grid[0].size()-1){return false;}\\n        if(v[grid.size()-1][grid[0].size()-1]==0){return false;}\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2876272,
                "title": "100-faster-i-don-t-think-anyone-has-done-this-yet",
                "content": "# Intuition\\nJust do as the question says.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$ *since each cell is visited at most once*\\n\\n- Space complexity:\\n$$O(N)$$ *for queue*\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m,n = len(grid),len(grid[0])\\n        paths = {\\n            1: [\"L\",\"R\"],\\n            2: [\"U\",\"D\"],\\n            3: [\"L\",\"D\"],\\n            4: [\"R\",\"D\"],\\n            5: [\"L\",\"U\"],\\n            6: [\"R\",\"U\"]\\n        }\\n        directions = {\\n            \"R\": (0,1),\\n            \"L\": (0,-1),\\n            \"D\": (1,0),\\n            \"U\": (-1,0)\\n        }\\n        opposites = {\\n            \"R\": \"L\",\\n            \"L\": \"R\",\\n            \"U\": \"D\",\\n            \"D\": \"U\"\\n        }\\n\\n        visited = set()\\n        queue = deque()\\n        queue.append(((0,0),None))\\n\\n        while queue:\\n            cur,prev = queue.popleft()\\n            x,y = cur\\n            \\n            if x<0 or x>=m or y<0 or y>=n: continue\\n            \\n            street = grid[x][y]\\n            if prev and prev not in paths[street]: continue\\n            if x == m-1 and y == n-1: return True\\n\\n            for path in paths[street]:\\n                if path == prev: continue\\n                dx,dy = directions[path]\\n                newx,newy = x+dx,y+dy\\n                if (newx,newy) not in visited:\\n                    visited.add((newx,newy))\\n                    queue.append(((newx,newy),opposites[path]))\\n\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m,n = len(grid),len(grid[0])\\n        paths = {\\n            1: [\"L\",\"R\"],\\n            2: [\"U\",\"D\"],\\n            3: [\"L\",\"D\"],\\n            4: [\"R\",\"D\"],\\n            5: [\"L\",\"U\"],\\n            6: [\"R\",\"U\"]\\n        }\\n        directions = {\\n            \"R\": (0,1),\\n            \"L\": (0,-1),\\n            \"D\": (1,0),\\n            \"U\": (-1,0)\\n        }\\n        opposites = {\\n            \"R\": \"L\",\\n            \"L\": \"R\",\\n            \"U\": \"D\",\\n            \"D\": \"U\"\\n        }\\n\\n        visited = set()\\n        queue = deque()\\n        queue.append(((0,0),None))\\n\\n        while queue:\\n            cur,prev = queue.popleft()\\n            x,y = cur\\n            \\n            if x<0 or x>=m or y<0 or y>=n: continue\\n            \\n            street = grid[x][y]\\n            if prev and prev not in paths[street]: continue\\n            if x == m-1 and y == n-1: return True\\n\\n            for path in paths[street]:\\n                if path == prev: continue\\n                dx,dy = directions[path]\\n                newx,newy = x+dx,y+dy\\n                if (newx,newy) not in visited:\\n                    visited.add((newx,newy))\\n                    queue.append(((newx,newy),opposites[path]))\\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665841,
                "title": "basic-bfs-python-easy-understanding",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        drn = {\\n            1: [(0, -1), (0, 1)] ,\\n            2: [(-1, 0), (1, 0)] ,\\n            3: [(0, -1), (1, 0)] ,\\n            4: [(0, 1), (1, 0)] ,\\n            5: [(0, -1), (-1, 0)] ,\\n            6: [(0, 1), (-1, 0)] ,\\n        }\\n        \\n        n, m = len(grid), len(grid[0])\\n        visited = {(0, 0)}\\n        is_valid = lambda i, j:  0 <= i < n and 0 <= j < m and (new_i, new_j) not in visited\\n        \\n        queue = deque([(0, 0)])\\n        while queue:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if i == n-1 and j == m-1:\\n                    return True\\n                for i_drn, j_drn in drn[grid[i][j]]:\\n                    new_i, new_j = i+i_drn, j+j_drn\\n                    if is_valid(new_i, new_j) and (-i_drn, -j_drn) in drn[grid[new_i][new_j]]:  # Important BW\\n                        \\n                        visited.add((new_i, new_j))\\n                        queue.append((new_i, new_j))\\n        return False\\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        drn = {\\n            1: [(0, -1), (0, 1)] ,\\n            2: [(-1, 0), (1, 0)] ,\\n            3: [(0, -1), (1, 0)] ,\\n            4: [(0, 1), (1, 0)] ,\\n            5: [(0, -1), (-1, 0)] ,\\n            6: [(0, 1), (-1, 0)] ,\\n        }\\n        \\n        n, m = len(grid), len(grid[0])\\n        visited = {(0, 0)}\\n        is_valid = lambda i, j:  0 <= i < n and 0 <= j < m and (new_i, new_j) not in visited\\n        \\n        queue = deque([(0, 0)])\\n        while queue:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if i == n-1 and j == m-1:\\n                    return True\\n                for i_drn, j_drn in drn[grid[i][j]]:\\n                    new_i, new_j = i+i_drn, j+j_drn\\n                    if is_valid(new_i, new_j) and (-i_drn, -j_drn) in drn[grid[new_i][new_j]]:  # Important BW\\n                        \\n                        visited.add((new_i, new_j))\\n                        queue.append((new_i, new_j))\\n        return False\\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501296,
                "title": "java-best-solution-ever-dfs",
                "content": "```\\nclass Solution {\\n    \\n    // can we go up\\n    boolean isUp(int val)\\n    {\\n        return val == 2 || val == 5 || val == 6;\\n    }\\n    //can we go left\\n    boolean isLeft(int val)\\n    {\\n        return val == 1 || val == 3 || val == 5;\\n    }\\n    //can we go down\\n    boolean isDown(int val)\\n    {\\n        return val == 2 || val == 3 || val == 4;\\n    }\\n    //can we go right\\n    boolean isRight(int val)\\n    {\\n        return val == 1 || val == 4 || val == 6;\\n    }\\n    \\n    boolean isPath(int[][] grid, int x, int y, \\n                   int m, int n, char sign)\\n    {\\n        if(!(x<m && x>=0 && y<n && y>=0 && grid[x][y] != -1))\\n            return  false;\\n        \\n        if(!(x==0 && y==0))\\n        {\\n              if(sign == \\'U\\' && !isDown(grid[x][y]))\\n                  return false;\\n              else if(sign == \\'L\\' && !isRight(grid[x][y]))\\n                  return false;\\n              else if(sign == \\'D\\' && !isUp(grid[x][y]))\\n                  return false;\\n              else if(sign == \\'R\\' && !isLeft(grid[x][y]))\\n                  return false;\\n        }\\n        \\n        //check if destination cell reached\\n        if(x==m-1 && y==n-1)\\n            return true;\\n        \\n        \\n        int val = grid[x][y];\\n        grid[x][y] = -1;\\n      \\n        if(isUp(val) && isPath(grid, x-1, y, m, n, \\'U\\'))\\n            return true;\\n        if(isLeft(val) && isPath(grid, x, y-1, m, n, \\'L\\'))\\n            return true;\\n        if(isDown(val) && isPath(grid, x+1, y, m, n, \\'D\\'))\\n            return true;\\n        if(isRight(val) && isPath(grid, x, y+1, m, n, \\'R\\'))\\n            return true;\\n        \\n        grid[x][y] = val;\\n        \\n        return false;\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n           \\n        return isPath(grid, 0, 0, m, n, \\'0\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // can we go up\\n    boolean isUp(int val)\\n    {\\n        return val == 2 || val == 5 || val == 6;\\n    }\\n    //can we go left\\n    boolean isLeft(int val)\\n    {\\n        return val == 1 || val == 3 || val == 5;\\n    }\\n    //can we go down\\n    boolean isDown(int val)\\n    {\\n        return val == 2 || val == 3 || val == 4;\\n    }\\n    //can we go right\\n    boolean isRight(int val)\\n    {\\n        return val == 1 || val == 4 || val == 6;\\n    }\\n    \\n    boolean isPath(int[][] grid, int x, int y, \\n                   int m, int n, char sign)\\n    {\\n        if(!(x<m && x>=0 && y<n && y>=0 && grid[x][y] != -1))\\n            return  false;\\n        \\n        if(!(x==0 && y==0))\\n        {\\n              if(sign == \\'U\\' && !isDown(grid[x][y]))\\n                  return false;\\n              else if(sign == \\'L\\' && !isRight(grid[x][y]))\\n                  return false;\\n              else if(sign == \\'D\\' && !isUp(grid[x][y]))\\n                  return false;\\n              else if(sign == \\'R\\' && !isLeft(grid[x][y]))\\n                  return false;\\n        }\\n        \\n        //check if destination cell reached\\n        if(x==m-1 && y==n-1)\\n            return true;\\n        \\n        \\n        int val = grid[x][y];\\n        grid[x][y] = -1;\\n      \\n        if(isUp(val) && isPath(grid, x-1, y, m, n, \\'U\\'))\\n            return true;\\n        if(isLeft(val) && isPath(grid, x, y-1, m, n, \\'L\\'))\\n            return true;\\n        if(isDown(val) && isPath(grid, x+1, y, m, n, \\'D\\'))\\n            return true;\\n        if(isRight(val) && isPath(grid, x, y+1, m, n, \\'R\\'))\\n            return true;\\n        \\n        grid[x][y] = val;\\n        \\n        return false;\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n           \\n        return isPath(grid, 0, 0, m, n, \\'0\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469650,
                "title": "c-dfs",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> x{1,-1,0,0};\\n    vector<int> y{0,0,1,-1};\\n    bool isvalid(int x,int y,int m,int n)\\n    {\\n        if(x>=0 && x<m && y>=0 && y<n)\\n            return true;\\n        return false;\\n    }\\n    bool solve(vector<vector<int>>& grid,int i,int j,int m,int n,vector<vector<int>> &vis,unordered_map<int,vector<vector<int>>> &mp)\\n    {\\n        if(i==m-1 && j==n-1)\\n            return true;\\n        vis[i][j]=1;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x1=i+x[k];\\n            int y1=j+y[k];\\n            if(isvalid(x1,y1,m,n) && vis[x1][y1]==0)\\n            {\\n                int temp=grid[i][j];\\n                cout<<k;\\n                for(int l=0;l<mp[temp][k].size();l++)\\n                {\\n                    if(mp[temp][k][l]==grid[x1][y1])\\n                    {\\n                        if(solve(grid,x1,y1,m,n,vis,mp))\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) \\n    {\\n        unordered_map<int,vector<vector<int>>> mp{{1,{{},{},{1,3,5},{1,4,6}}},\\n                                                  {2,{{2,5,6},{2,3,4},{},{}}},\\n                                                  {3,{{2,5,6},{},{},{1,4,6}}},\\n                                                  {4,{{2,5,6},{},{1,3,5},{}}},\\n                                                  {5,{{},{2,3,4},{},{1,4,6}}},\\n                                                  {6,{{},{2,3,4},{1,3,5},{}}}};\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        return solve(grid,0,0,m,n,vis,mp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> x{1,-1,0,0};\\n    vector<int> y{0,0,1,-1};\\n    bool isvalid(int x,int y,int m,int n)\\n    {\\n        if(x>=0 && x<m && y>=0 && y<n)\\n            return true;\\n        return false;\\n    }\\n    bool solve(vector<vector<int>>& grid,int i,int j,int m,int n,vector<vector<int>> &vis,unordered_map<int,vector<vector<int>>> &mp)\\n    {\\n        if(i==m-1 && j==n-1)\\n            return true;\\n        vis[i][j]=1;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x1=i+x[k];\\n            int y1=j+y[k];\\n            if(isvalid(x1,y1,m,n) && vis[x1][y1]==0)\\n            {\\n                int temp=grid[i][j];\\n                cout<<k;\\n                for(int l=0;l<mp[temp][k].size();l++)\\n                {\\n                    if(mp[temp][k][l]==grid[x1][y1])\\n                    {\\n                        if(solve(grid,x1,y1,m,n,vis,mp))\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) \\n    {\\n        unordered_map<int,vector<vector<int>>> mp{{1,{{},{},{1,3,5},{1,4,6}}},\\n                                                  {2,{{2,5,6},{2,3,4},{},{}}},\\n                                                  {3,{{2,5,6},{},{},{1,4,6}}},\\n                                                  {4,{{2,5,6},{},{1,3,5},{}}},\\n                                                  {5,{{},{2,3,4},{},{1,4,6}}},\\n                                                  {6,{{},{2,3,4},{1,3,5},{}}}};\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        return solve(grid,0,0,m,n,vis,mp);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2455333,
                "title": "python-dfs-2-different-methods",
                "content": "#CODE1:\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        \\n        def traverse(row,col,prev):\\n            if row==ROWS-1 and col==COLS-1:\\n                if prev in validPrev[grid[row][col]]:\\n                    return True\\n                else:\\n                    return False\\n                \\n            if row<0 or row>=ROWS or col<0 or col>=COLS or (row,col) in visited:\\n                return False\\n            \\n            visited.add((row,col))\\n            \\n            if grid[row][col]==1 and prev in validPrev[1]:\\n                return traverse(row,col+1,(0,1)) or traverse(row,col-1,(0,-1))\\n            \\n            elif grid[row][col]==2 and prev in validPrev[2]:\\n                return traverse(row+1,col,(1,0)) or traverse(row-1,col,(-1,0))\\n            \\n            elif grid[row][col]==3 and prev in validPrev[3]:\\n                return traverse(row+1,col,(1,0)) or traverse(row,col-1,(0,-1))\\n            \\n            elif grid[row][col]==4 and prev in validPrev[4]:\\n                return traverse(row,col+1,(0,1)) or traverse(row+1,col,(1,0))\\n            \\n            elif grid[row][col]==5 and prev in validPrev[5]:\\n                return traverse(row-1,col,(-1,0)) or traverse(row,col-1,(0,-1))\\n            \\n            elif grid[row][col]==6 and prev in validPrev[6]:\\n                return traverse(row,col+1,(0,1)) or traverse(row-1,col,(-1,0))\\n            \\n            else:\\n                return False\\n                \\n        ROWS=len(grid)\\n        COLS=len(grid[0])\\n        visited=set()\\n        validPrev={}\\n        #(0,0 for start) rest for incoming directions\\n        validPrev[1]={(0,0),(0,-1),(0,1)}\\n        validPrev[2]={(0,0),(-1,0),(1,0)}\\n        validPrev[3]={(0,0),(0,1),(-1,0)}\\n        validPrev[4]={(0,0),(0,-1),(-1,0)}\\n        validPrev[5]={(0,0),(0,1),(1,0)}\\n        validPrev[6]={(0,0),(0,-1),(1,0)}\\n        \\n        res=traverse(0,0,(0,0))\\n        return res\\n\\n#CODE2: More detailed conditions\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        \\n        def traverse(row,col,prev):\\n            if row==ROWS-1 and col==COLS-1:\\n                if prev in validPrev[grid[row][col]]:\\n                    return True\\n                else:\\n                    return False\\n            \\n            if row<0 or row>=ROWS or col<0 or col>=COLS or (row,col) in visited:\\n                return False\\n            visited.add((row,col))\\n            if grid[row][col]==1 and prev in validPrev[1]:\\n                \\n                if prev==0:\\n                    prev=1\\n                    return traverse(row,col+1,prev)\\n                \\n                if prev==1:\\n                    prev=grid[row][col]\\n                    return traverse(row,col+1,prev) or traverse(row,col-1,prev)\\n                elif prev in {5,3}:\\n                    prev=grid[row][col]\\n                    return traverse(row,col-1,prev)\\n                else:\\n                    prev=1\\n                    return traverse(row,col+1,prev)\\n                \\n            elif grid[row][col]==2 and prev in validPrev[2]:\\n                \\n                if prev==0:\\n                    prev=2\\n                    return traverse(row+1,col,prev)\\n                \\n                if prev==4 or prev==3:\\n                    prev=grid[row][col]\\n                    return traverse(row+1,col,prev)\\n                elif prev==5 or prev==6:\\n                    prev=grid[row][col]\\n                    return traverse(row-1,col,prev)\\n                else:\\n                    prev=grid[row][col]\\n                    return traverse(row+1,col,prev) or traverse(row-1,col,prev)\\n                \\n            elif grid[row][col]==3 and prev in validPrev[3]:\\n                \\n                if prev==0:\\n                    prev=3\\n                    return traverse(row+1,col,prev)\\n                \\n                if prev==1 or prev==6 or prev==4:\\n                    prev=grid[row][col]\\n                    return traverse(row+1,col,prev)\\n                else:\\n                    prev=grid[row][col]\\n                    return traverse(row,col-1,prev)\\n            \\n            elif grid[row][col]==4 and prev in validPrev[4]:\\n                if prev==0:\\n                    prev=4\\n                    return traverse(row+1,col,prev) or traverse(row,col+1,prev)\\n                \\n                if prev in {1,3}:\\n                    prev=grid[row][col]\\n                    return traverse(row+1,col,prev)\\n                else:\\n                    prev=4\\n                    return traverse(row,col+1,prev)\\n            \\n            elif grid[row][col]==5 and prev in validPrev[5]:\\n                \\n                if prev==0:\\n                    return False\\n                \\n                if prev in {2,4,3}:\\n                    prev=grid[row][col]\\n                    return traverse(row,col-1,prev)\\n                else:\\n                    prev=5\\n                    return traverse(row-1,col,prev)\\n                \\n            elif grid[row][col]==6 and prev in validPrev[6]:\\n                \\n                if prev==0:\\n                    prev=6\\n                    return traverse(row,col+1,prev)\\n                \\n                if prev in {2,3,4}:\\n                    prev=grid[row][col]\\n                    return traverse(row,col+1,prev)\\n                else:\\n                    prev=6\\n                    return traverse(row-1,col,prev)\\n            else:\\n                return False\\n                \\n        ROWS=len(grid)\\n        COLS=len(grid[0])\\n        visited=set()\\n        validPrev={}\\n\\t\\t#Acceptable Previous Values\\n        validPrev[1]={0,1,3,4,5,6}\\n        validPrev[2]={0,2,3,4,5,6}\\n        validPrev[3]={0,1,2,4,5,6}\\n        validPrev[4]={0,1,2,3,5,6}\\n        validPrev[5]={0,1,2,3,4,6}\\n        validPrev[6]={0,1,2,3,4,5}\\n        \\n        return traverse(0,0,0)\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        \\n        def traverse(row,col,prev):\\n            if row==ROWS-1 and col==COLS-1:\\n                if prev in validPrev[grid[row][col]]:\\n                    return True\\n                else:\\n                    return False\\n                \\n            if row<0 or row>=ROWS or col<0 or col>=COLS or (row,col) in visited:\\n                return False\\n            \\n            visited.add((row,col))\\n            \\n            if grid[row][col]==1 and prev in validPrev[1]:\\n                return traverse(row,col+1,(0,1)) or traverse(row,col-1,(0,-1))\\n            \\n            elif grid[row][col]==2 and prev in validPrev[2]:\\n                return traverse(row+1,col,(1,0)) or traverse(row-1,col,(-1,0))\\n            \\n            elif grid[row][col]==3 and prev in validPrev[3]:\\n                return traverse(row+1,col,(1,0)) or traverse(row,col-1,(0,-1))\\n            \\n            elif grid[row][col]==4 and prev in validPrev[4]:\\n                return traverse(row,col+1,(0,1)) or traverse(row+1,col,(1,0))\\n            \\n            elif grid[row][col]==5 and prev in validPrev[5]:\\n                return traverse(row-1,col,(-1,0)) or traverse(row,col-1,(0,-1))\\n            \\n            elif grid[row][col]==6 and prev in validPrev[6]:\\n                return traverse(row,col+1,(0,1)) or traverse(row-1,col,(-1,0))\\n            \\n            else:\\n                return False\\n                \\n        ROWS=len(grid)\\n        COLS=len(grid[0])\\n        visited=set()\\n        validPrev={}",
                "codeTag": "Java"
            },
            {
                "id": 2415633,
                "title": "python3-solution-85-faster-and-98-less-memory",
                "content": "This is my first time posting so please excuse me if I\\'ve made any errors.\\n\\nI considered the DFS solution, however with larger maps, the amount of storage becomes quite large. I also notice that the majority of solutions store a \\'visited\\' parameter, which in my view adds more storage than neccessary. \\n\\nMy approach instead just stores an m and n location that moves with the map, code below.\\n\\n```class Solution: \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        # Define the different paths in a dictionary.\\n        pathDict = {1:[1,3], 2:[2,4], 3:[1,4], 4:[3,4], 5:[1,2], 6:[2,3]}\\n        \\n        # Calculate the starting position\\n        M, N = len(grid), len(grid[0])\\n        if M == N == 1:\\n            return(True)\\n        \\n        # Loop through the starting values in the grid.\\n        for startValue in pathDict[grid[0][0]]:\\n            m = n = p = 0\\n            while True:\\n                if startValue == 1:\\n                    n -= 1\\n                    p = 3\\n                elif startValue == 2:\\n                    m -= 1\\n                    p = 4\\n                elif startValue == 3:\\n                    n += 1\\n                    p = 1\\n                elif startValue == 4:\\n                    m += 1\\n                    p = 2\\n                \\n                # Check whether we are outside of the map or append the map.\\n                if m < 0 or n < 0 or m == M or n==N:\\n                        break\\n                elif p in pathDict[grid[m][n]]:\\n                    startValue = (set(pathDict[grid[m][n]]) - set([p])).pop()\\n                else:\\n                    break\\n\\n                # Stopping condition.\\n                if (m,n) == (0,0):\\n                    return(False)\\n                elif m == M-1 and n == N-1:\\n                    return(True)\\n                \\n        return(False)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution: \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        # Define the different paths in a dictionary.\\n        pathDict = {1:[1,3], 2:[2,4], 3:[1,4], 4:[3,4], 5:[1,2], 6:[2,3]}",
                "codeTag": "Java"
            },
            {
                "id": 2382575,
                "title": "javascript",
                "content": "```\\nvar hasValidPath = function (grid) {\\n  let m = grid.length;\\n  let n = grid[0].length;\\n  if (grid[0][0] === 5 || grid[m - 1][n - 1] === 4) return false;\\n\\n  let street = {\\n    1: [\"l\", \"r\"],\\n    2: [\"u\", \"d\"],\\n    3: [\"d\", \"l\"],\\n    4: [\"d\", \"r\"],\\n    5: [\"u\", \"l\"],\\n    6: [\"u\", \"r\"],\\n  };\\n\\n  let dirs = {\\n    l: [0, -1, \"r\"],\\n    r: [0, 1, \"l\"],\\n    u: [-1, 0, \"d\"],\\n    d: [1, 0, \"u\"],\\n  };\\n\\n  let visited = {};\\n  let queue = [];\\n  queue.push([0, 0]);\\n\\n  while (queue.length > 0) {\\n    let [i, j] = queue.shift();\\n    if (i === m - 1 && j === n - 1) return true;\\n    for (let k = 0; k < street[grid[i][j]].length; k++) {\\n      let dir = street[grid[i][j]][k];\\n      let [di, dj, dir_from] = dirs[dir];\\n      let i1 = i + di;\\n      let j1 = j + dj;\\n\\n      if (i1 < 0 || j1 < 0 || i1 >= m || j1 >= n) continue;\\n      if (street[grid[i1][j1]].includes(dir_from)) {\\n        let key = `${i1},${j1}`;\\n        if (visited[key] !== undefined) continue;\\n        visited[key] = true;\\n        queue.push([i1, j1]);\\n      }\\n    }\\n  }\\n  return false;\\n};",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nvar hasValidPath = function (grid) {\\n  let m = grid.length;\\n  let n = grid[0].length;\\n  if (grid[0][0] === 5 || grid[m - 1][n - 1] === 4) return false;\\n\\n  let street = {\\n    1: [\"l\", \"r\"],\\n    2: [\"u\", \"d\"],\\n    3: [\"d\", \"l\"],\\n    4: [\"d\", \"r\"],\\n    5: [\"u\", \"l\"],\\n    6: [\"u\", \"r\"],\\n  };\\n\\n  let dirs = {\\n    l: [0, -1, \"r\"],\\n    r: [0, 1, \"l\"],\\n    u: [-1, 0, \"d\"],\\n    d: [1, 0, \"u\"],\\n  };\\n\\n  let visited = {};\\n  let queue = [];\\n  queue.push([0, 0]);\\n\\n  while (queue.length > 0) {\\n    let [i, j] = queue.shift();\\n    if (i === m - 1 && j === n - 1) return true;\\n    for (let k = 0; k < street[grid[i][j]].length; k++) {\\n      let dir = street[grid[i][j]][k];\\n      let [di, dj, dir_from] = dirs[dir];\\n      let i1 = i + di;\\n      let j1 = j + dj;\\n\\n      if (i1 < 0 || j1 < 0 || i1 >= m || j1 >= n) continue;\\n      if (street[grid[i1][j1]].includes(dir_from)) {\\n        let key = `${i1},${j1}`;\\n        if (visited[key] !== undefined) continue;\\n        visited[key] = true;\\n        queue.push([i1, j1]);\\n      }\\n    }\\n  }\\n  return false;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2300502,
                "title": "simple-dfs-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool helper(vector<vector<int>>& grid,int i,int j,int m,int n,vector<vector<bool>>& visited){\\n        if(i<0 || j<0 || i>=m || j>=n || visited[i][j]==true)\\n            return false;\\n        if(i==m-1 && j==n-1)\\n            return true;\\n        visited[i][j]=true;\\n        bool a=false,b=false,c=false,d=false,e=false,f=false,g=false,h=false,o=false,p=false,k=false,l=false;\\n        if(grid[i][j]==1){\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6))\\n                a=helper(grid,i,j-1,m,n,visited);\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5))\\n                b=helper(grid,i,j+1,m,n,visited);\\n        }\\n        if(grid[i][j]==2){\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4))\\n                c=helper(grid,i-1,j,m,n,visited);\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6))\\n                d=helper(grid,i+1,j,m,n,visited);\\n        }\\n        if(grid[i][j]==3){\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6))\\n                e=helper(grid,i,j-1,m,n,visited);\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6))\\n                f=helper(grid,i+1,j,m,n,visited);\\n        }\\n        if(grid[i][j]==4){\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5))\\n                g=helper(grid,i,j+1,m,n,visited);\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6))\\n                h=helper(grid,i+1,j,m,n,visited);\\n        }\\n        if(grid[i][j]==5){\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4))\\n                o=helper(grid,i-1,j,m,n,visited);\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6))\\n                p=helper(grid,i,j-1,m,n,visited);\\n        }\\n        if(grid[i][j]==6){\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4))\\n                k=helper(grid,i-1,j,m,n,visited);\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5))\\n                l=helper(grid,i,j+1,m,n,visited);\\n        }\\n        return (a || b || c || d || e || f || g || h || o || p || k || l);\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        return helper(grid,0,0,m,n,visited);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool helper(vector<vector<int>>& grid,int i,int j,int m,int n,vector<vector<bool>>& visited){\\n        if(i<0 || j<0 || i>=m || j>=n || visited[i][j]==true)\\n            return false;\\n        if(i==m-1 && j==n-1)\\n            return true;\\n        visited[i][j]=true;\\n        bool a=false,b=false,c=false,d=false,e=false,f=false,g=false,h=false,o=false,p=false,k=false,l=false;\\n        if(grid[i][j]==1){\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6))\\n                a=helper(grid,i,j-1,m,n,visited);\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5))\\n                b=helper(grid,i,j+1,m,n,visited);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2290772,
                "title": "simple-c-bfs-most-intuitive-commented-full-explanation",
                "content": "Everything in code will be same as **Standard BFS**, only thing is checking of back directions will be necessary before visiting to the next cell, basically checking the connectivity of next cell with current cell.  \\n\\n----\\nFor understanding the **back direction concepts** must dry run this small test case.\\n\\n----\\n**Input :** **`[[1,1,2]]`**,  **`r = 1,  c = 3`**\\n**Output :** **`false`** \\n\\n----\\n![image](https://assets.leetcode.com/users/images/d4310f8b-d5ec-4597-bdf7-e34fd2637698_1657984436.0421526.png)![image](https://assets.leetcode.com/users/images/3b2f8241-2fd8-4e84-ad14-5d6c335326cd_1657984445.5361862.png)![image](https://assets.leetcode.com/users/images/347c159e-a1f2-41c8-b19c-e2c9ef57623f_1657984460.7235923.png)\\n\\n----\\nAs you can see, you will not be able to reach **last cell.**\\nBut you can see in middle cell there is horizontal street which allows to move in last cell.  So, there is not any connecting street from **`2nd`** cell to **`3rd`** cell. that\\'s why we will not be able to reach last cell.\\n\\n**`current cell`** : Where we are right now. \\n**`next cell`** :  Which are connected with current cell via street.\\nThis connectivity will be checked with the help of back directions from the **`next cell`** to the **`current cell`**. \\nHere in this test case,  we will check back directions from every cell.\\n\\nBut twist comes at middle cell :\\n* We have 2 direction from **`middle cell`**, one is already visited **`left cell`** and not visited one is **`right cell`**.  \\n* So, we will be visiting to right cell, and wait here.\\n* First of all check **`back direction`** or **`connectivity`**  from this **`right cell`** towards **`middle cell`**.\\n* If there is a connectivity possible between **`right`** and **`middle`** cell then we will definitely add that **`right cell`** into the queue with respect to **`current`** cell for **`future visit`**.\\n\\n----\\n```\\nclass Solution {\\npublic:\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(m==1 and n==1) return true;\\n        // 2D - direction vector for all streets\\n        // 0th based indexing 0 to 11\\n        \\n        // Let grid value g[i][j] = 4, means we need to follow \"street-4\" direction\\n        // First index of street-4 direction = 2*(4-1) = 6\\n        // Second index of street-4 direction = 2*(4-1)+1 = 7\\n        // dir[6] = {0, 1}\\n        // dir[7] = {1, 0}\\n        vector<vector<int>>dir = {        // Indices   \\n            {0,-1}, {0, 1}, // street 1  -->  0  1\\n            {-1,0}, {1, 0}, // street 2  -->  2  3\\n            {0,-1}, {1, 0}, // street 3  -->  4  5\\n            {0, 1}, {1, 0}, // street 4  -->  6  7\\n            {0,-1}, {-1,0}, // street 5  -->  8  9 \\n            {0, 1}, {-1,0}  // street 6  -->  10  11\\n        };\\n\\n        vector<vector<bool>>vis(m, vector<bool>(n, false));\\n        queue<pair<int,int>>q;\\n        \\n        q.push({0, 0});\\n        vis[0][0] = true;\\n        \\n        while (!q.empty()) \\n        {\\n            auto cur = q.front(); q.pop();\\n\\n            int r = cur.first;\\n            int c = cur.second;\\n            int val = grid[r][c] - 1; // grid values 1 to 6\\n            \\n            if(r==m-1 and c==n-1) return true;\\n            \\n            // 2 directions from every cell\\n            for(int k=0;k<2;k++) // k = 0, k = 1\\n            {\\n                int idx = 2*val+k;   // get index\\n                int nr = r + dir[idx][0];\\n                int nc = c + dir[idx][1];\\n                if (nr < 0 or nr >= m or nc < 0 or nc >= n or vis[nr][nc]==true) continue;\\n                \\n                //  for checking the back direction matches with current cell i.e forming path to next cell\\n                for(int x=0;x<2;x++)\\n                {\\n                    int i = 2*(grid[nr][nc]-1)+x;   // get index\\n                    if(r == nr+dir[i][0] and c == nc+dir[i][1]){\\n                        vis[nr][nc] = true;\\n                        q.push({nr, nc});\\n                    }       \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n*Thanks for Upvoting !*\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(m==1 and n==1) return true;\\n        // 2D - direction vector for all streets\\n        // 0th based indexing 0 to 11\\n        \\n        // Let grid value g[i][j] = 4, means we need to follow \"street-4\" direction\\n        // First index of street-4 direction = 2*(4-1) = 6\\n        // Second index of street-4 direction = 2*(4-1)+1 = 7\\n        // dir[6] = {0, 1}\\n        // dir[7] = {1, 0}\\n        vector<vector<int>>dir = {        // Indices   \\n            {0,-1}, {0, 1}, // street 1  -->  0  1\\n            {-1,0}, {1, 0}, // street 2  -->  2  3\\n            {0,-1}, {1, 0}, // street 3  -->  4  5\\n            {0, 1}, {1, 0}, // street 4  -->  6  7\\n            {0,-1}, {-1,0}, // street 5  -->  8  9 \\n            {0, 1}, {-1,0}  // street 6  -->  10  11\\n        };\\n\\n        vector<vector<bool>>vis(m, vector<bool>(n, false));\\n        queue<pair<int,int>>q;\\n        \\n        q.push({0, 0});\\n        vis[0][0] = true;\\n        \\n        while (!q.empty()) \\n        {\\n            auto cur = q.front(); q.pop();\\n\\n            int r = cur.first;\\n            int c = cur.second;\\n            int val = grid[r][c] - 1; // grid values 1 to 6\\n            \\n            if(r==m-1 and c==n-1) return true;\\n            \\n            // 2 directions from every cell\\n            for(int k=0;k<2;k++) // k = 0, k = 1\\n            {\\n                int idx = 2*val+k;   // get index\\n                int nr = r + dir[idx][0];\\n                int nc = c + dir[idx][1];\\n                if (nr < 0 or nr >= m or nc < 0 or nc >= n or vis[nr][nc]==true) continue;\\n                \\n                //  for checking the back direction matches with current cell i.e forming path to next cell\\n                for(int x=0;x<2;x++)\\n                {\\n                    int i = 2*(grid[nr][nc]-1)+x;   // get index\\n                    if(r == nr+dir[i][0] and c == nc+dir[i][1]){\\n                        vis[nr][nc] = true;\\n                        q.push({nr, nc});\\n                    }       \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068073,
                "title": "python-bfs-easy-solution-beats-90",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        move = {\\n            \"N\": (-1, 0),\\n            \"S\": (1, 0),\\n            \"E\": (0, 1),\\n            \"W\": (0, -1),\\n        }\\n        contra = {\\n            \\'N\\': \\'S\\',\\n            \\'E\\': \\'W\\',\\n            \\'S\\': \\'N\\',\\n            \\'W\\': \\'E\\',\\n        }\\n        ops = {\\n            1: [\\'W\\', \\'E\\'],\\n            2: [\\'N\\', \\'S\\'],\\n            3: [\\'W\\', \\'S\\'],\\n            4: [\\'E\\', \\'S\\'],\\n            5: [\\'N\\', \\'W\\'],\\n            6: [\\'N\\', \\'E\\'],\\n        }\\n        \\n        def isValid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n\\n        queue = deque([(0,0)])\\n        visited = {(0,0): True}\\n        while queue:\\n            i, j = queue.popleft()\\n            if i == m-1 and j == n-1:\\n                return True\\n            d1, d2 = ops[grid[i][j]]\\n            i1, j1 = move[d1]\\n            i2, j2 = move[d2]\\n            ni1, nj1 = i+i1, j+j1\\n            ni2, nj2 = i+i2, j+j2\\n            if isValid(ni1, nj1) and (ni1, nj1) not in visited:\\n                if contra[d1] in ops[grid[ni1][nj1]]:\\n                    queue.append((ni1, nj1))\\n                    visited[(ni1, nj1)] = True\\n            if isValid(ni2, nj2) and (ni2, nj2) not in visited:\\n                if contra[d2] in ops[grid[ni2][nj2]]:\\n                    queue.append((ni2, nj2))\\n                    visited[(ni2, nj2)] = True\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        move = {\\n            \"N\": (-1, 0),\\n            \"S\": (1, 0),\\n            \"E\": (0, 1),\\n            \"W\": (0, -1),\\n        }\\n        contra = {\\n            \\'N\\': \\'S\\',\\n            \\'E\\': \\'W\\',\\n            \\'S\\': \\'N\\',\\n            \\'W\\': \\'E\\',\\n        }\\n        ops = {\\n            1: [\\'W\\', \\'E\\'],\\n            2: [\\'N\\', \\'S\\'],\\n            3: [\\'W\\', \\'S\\'],\\n            4: [\\'E\\', \\'S\\'],\\n            5: [\\'N\\', \\'W\\'],\\n            6: [\\'N\\', \\'E\\'],\\n        }\\n        \\n        def isValid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n\\n        queue = deque([(0,0)])\\n        visited = {(0,0): True}\\n        while queue:\\n            i, j = queue.popleft()\\n            if i == m-1 and j == n-1:\\n                return True\\n            d1, d2 = ops[grid[i][j]]\\n            i1, j1 = move[d1]\\n            i2, j2 = move[d2]\\n            ni1, nj1 = i+i1, j+j1\\n            ni2, nj2 = i+i2, j+j2\\n            if isValid(ni1, nj1) and (ni1, nj1) not in visited:\\n                if contra[d1] in ops[grid[ni1][nj1]]:\\n                    queue.append((ni1, nj1))\\n                    visited[(ni1, nj1)] = True\\n            if isValid(ni2, nj2) and (ni2, nj2) not in visited:\\n                if contra[d2] in ops[grid[ni2][nj2]]:\\n                    queue.append((ni2, nj2))\\n                    visited[(ni2, nj2)] = True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999368,
                "title": "java-union-find-with-comments",
                "content": "```\\nclass Solution {\\n    class UF {\\n        int[] root;\\n        int[] size;\\n        \\n        public UF(int n){\\n            this.root = new int[n];\\n            this.size = new int[n];\\n            \\n            for(int i = 0; i < n; i++){\\n                this.root[i] = i;\\n                this.size[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x){\\n            while(x != root[x]){\\n                root[x] = root[root[x]];\\n                x = root[x];\\n            }\\n            return x;\\n        }\\n        \\n        public void union(int x, int y){\\n            int rx = find(x);\\n            int ry = find(y);\\n            \\n            if(rx == ry) return;\\n            \\n            if(size[rx] > size[ry]){\\n                root[ry] = rx;\\n                size[rx] += size[ry];\\n            }else{\\n                root[rx] = ry;\\n                size[ry] += size[rx];\\n            }\\n        }\\n        \\n        public boolean isConnected(int x, int y){\\n            return find(x) == find(y);\\n        }\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        UF uf = new UF(n * m);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int left = i * m + j - 1;\\n                int right = i * m + j + 1;\\n                int up = (i - 1) * m + j;\\n                int down = (i + 1) * m + j;\\n                int u = i * m + j;\\n                if(grid[i][j] == 1){\\n                    // union left and right \\n                    // if left has right interface\\n                    // (grid[i][j + 1] == 1 || grid[i][j + 1] == 4 || grid[i][j + 1] == 6)\\n                    if(j >= 1 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        uf.union(u, left);\\n                    }\\n                    // if right has left interface\\n                    if(j < m - 1 && grid[i][j + 1] % 2 == 1){\\n                        uf.union(u, right);\\n                    }\\n                }else if(grid[i][j] == 2){\\n                    // up and down\\n                    // up has down\\n                    if(i >= 1 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        uf.union(u, up);\\n                    }\\n                    // down has up\\n                    if(i < n - 1 && (grid[i + 1][j] == 2 || grid[i + 1][j] == 5 || grid[i + 1][j] == 6)){\\n                        uf.union(u, down);\\n                    }\\n                }else if(grid[i][j] == 3){\\n                    // left and down\\n                    // left has right\\n                    if(j >= 1 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        uf.union(u, left);\\n                    }\\n                    // down has up\\n                    if(i < n - 1 && (grid[i + 1][j] == 2 || grid[i + 1][j] == 5 || grid[i + 1][j] == 6)){\\n                        uf.union(u, down);\\n                    }\\n                }else if(grid[i][j] == 4){\\n                    // right and down\\n                    // right has left\\n                    if(j < m - 1 && grid[i][j + 1] % 2 == 1){\\n                        uf.union(u, right);\\n                    }\\n                    // down has up\\n                    if(i < n - 1 &&  (grid[i + 1][j] == 2 || grid[i + 1][j] == 5 || grid[i + 1][j] == 6)){\\n                        uf.union(u, down);\\n                    }\\n                }else if(grid[i][j] == 5){\\n                    // up and left\\n                    // up has down\\n                    if(i >= 1 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        uf.union(u, up);\\n                    }\\n                    \\n                    // left has righ\\n                    if(j >= 1 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        uf.union(u, left);\\n                    }\\n                }else if(grid[i][j] == 6){\\n                    // up and right\\n                    // up has down\\n                    if(i >= 1 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        uf.union(u, up);\\n                    }\\n                    // right has left\\n                    if(j < m - 1 &&  grid[i][j + 1] % 2 == 1){\\n                        uf.union(u, right);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return uf.isConnected(0, n * m - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    class UF {\\n        int[] root;\\n        int[] size;\\n        \\n        public UF(int n){\\n            this.root = new int[n];\\n            this.size = new int[n];\\n            \\n            for(int i = 0; i < n; i++){\\n                this.root[i] = i;\\n                this.size[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x){\\n            while(x != root[x]){\\n                root[x] = root[root[x]];\\n                x = root[x];\\n            }\\n            return x;\\n        }\\n        \\n        public void union(int x, int y){\\n            int rx = find(x);\\n            int ry = find(y);\\n            \\n            if(rx == ry) return;\\n            \\n            if(size[rx] > size[ry]){\\n                root[ry] = rx;\\n                size[rx] += size[ry];\\n            }else{\\n                root[rx] = ry;\\n                size[ry] += size[rx];\\n            }\\n        }\\n        \\n        public boolean isConnected(int x, int y){\\n            return find(x) == find(y);\\n        }\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        UF uf = new UF(n * m);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int left = i * m + j - 1;\\n                int right = i * m + j + 1;\\n                int up = (i - 1) * m + j;\\n                int down = (i + 1) * m + j;\\n                int u = i * m + j;\\n                if(grid[i][j] == 1){\\n                    // union left and right \\n                    // if left has right interface\\n                    // (grid[i][j + 1] == 1 || grid[i][j + 1] == 4 || grid[i][j + 1] == 6)\\n                    if(j >= 1 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        uf.union(u, left);\\n                    }\\n                    // if right has left interface\\n                    if(j < m - 1 && grid[i][j + 1] % 2 == 1){\\n                        uf.union(u, right);\\n                    }\\n                }else if(grid[i][j] == 2){\\n                    // up and down\\n                    // up has down\\n                    if(i >= 1 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        uf.union(u, up);\\n                    }\\n                    // down has up\\n                    if(i < n - 1 && (grid[i + 1][j] == 2 || grid[i + 1][j] == 5 || grid[i + 1][j] == 6)){\\n                        uf.union(u, down);\\n                    }\\n                }else if(grid[i][j] == 3){\\n                    // left and down\\n                    // left has right\\n                    if(j >= 1 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        uf.union(u, left);\\n                    }\\n                    // down has up\\n                    if(i < n - 1 && (grid[i + 1][j] == 2 || grid[i + 1][j] == 5 || grid[i + 1][j] == 6)){\\n                        uf.union(u, down);\\n                    }\\n                }else if(grid[i][j] == 4){\\n                    // right and down\\n                    // right has left\\n                    if(j < m - 1 && grid[i][j + 1] % 2 == 1){\\n                        uf.union(u, right);\\n                    }\\n                    // down has up\\n                    if(i < n - 1 &&  (grid[i + 1][j] == 2 || grid[i + 1][j] == 5 || grid[i + 1][j] == 6)){\\n                        uf.union(u, down);\\n                    }\\n                }else if(grid[i][j] == 5){\\n                    // up and left\\n                    // up has down\\n                    if(i >= 1 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        uf.union(u, up);\\n                    }\\n                    \\n                    // left has righ\\n                    if(j >= 1 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        uf.union(u, left);\\n                    }\\n                }else if(grid[i][j] == 6){\\n                    // up and right\\n                    // up has down\\n                    if(i >= 1 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        uf.union(u, up);\\n                    }\\n                    // right has left\\n                    if(j < m - 1 &&  grid[i][j + 1] % 2 == 1){\\n                        uf.union(u, right);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return uf.isConnected(0, n * m - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958551,
                "title": "java-3-solutions-uf-or-bfs-or-simulation",
                "content": "Hi, here I am providing 3 different solutions on how one can go about solving a problem like this. \\nI think this problem is quite interesting! I drew some inspirations from other posts wrote the following 3 solutions: \\n\\n- In terms of length: BFS < Union Find < Simulation (smaller is better)\\n\\n- In terms of performance: Simulation (100% Speed) < BFS < Union Find (Path Compression + Union by Rank) #smaller is better\\n\\nHere comes BFS solution first:\\nIdea is that we can get to a point by going to that point and check if we can come back.\\n```Java\\n    public boolean hasValidPath(int[][] grid) {\\n        int[][][] dirs = {\\n            {{0, 1}, {0, -1}}, // 1\\n            {{1, 0}, {-1, 0}}, // 2\\n            {{0, -1}, {1, 0}}, // 3\\n            {{0, 1}, {1, 0}},  // 4\\n            {{-1, 0}, {0, -1}},// 5\\n            {{-1, 0}, {0, 1}}  // 6\\n        };\\n        int n = grid[0].length, m = grid.length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{0, 0});\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        while(!queue.isEmpty()){\\n            int x = queue.peek()[0];\\n            int y = queue.poll()[1];\\n            for (int[] d : dirs[grid[x][y] - 1]){\\n                int nx = x + d[0];\\n                int ny = y + d[1];\\n                if (nx < 0 || ny < 0 || nx == m || ny == n || visited[nx][ny])\\n                    continue;\\n                for (int[] dd : dirs[grid[nx][ny] - 1]){\\n                    if (nx + dd[0] == x && ny + dd[1] == y){\\n                        visited[nx][ny] = true; // If we can come back, then we can add this to the queue.\\n                        queue.offer(new int[]{nx, ny});\\n                    }\\n                }\\n            }\\n        }\\n        return visited[m - 1][n - 1];\\n    }\\n```\\n\\nHere is the Union Find solution:\\nIdea is that we can upscale the grid by 2, meaning the grid becomes a matrix with (2 * row + 1, 2 * col + 1) size. \\nAnd a road cell has 9 dots: top-left, top-center, top-right, center-left, center-center, center-right, bottom-left, bottom-center, bottom-right.\\nAnd we union the pieces based on the type of road it is. \\nIn the end, we check if we can get from (1, 1) to (2 * row - 1, 2 * col - 1).\\n```Java\\n    int n, m;\\n    public boolean hasValidPath(int[][] grid) {\\n        n = grid[0].length; m = grid.length;\\n        UF uf = new UF((2 * n + 1) * (2 * m + 1));\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                int v = grid[i][j];\\n                if (v == 2 || v == 5 || v == 6){ // Connect CENTER to TOP\\n                    uf.union(id(i, j, 0, 0), id(i, j, -1, 0));\\n                }\\n                if (v == 1 || v == 4 || v == 6){ // Connect CENTER to RIGHT\\n                    uf.union(id(i, j, 0, 0), id(i, j, 0, 1));\\n                }\\n                if (v == 2 || v == 3 || v == 4){ // Connect CENTER to BOTTOM\\n                    uf.union(id(i, j, 0, 0), id(i, j, 1, 0));\\n                }\\n                if (v == 1 || v == 3 || v == 5){ // Connect CENTER to LEFT\\n                    uf.union(id(i, j, 0, 0), id(i, j, 0, -1));\\n                }\\n            }\\n        }\\n        return uf.find(id(0, 0, 0, 0)) == uf.find(id(m - 1, n - 1, 0, 0));\\n    }\\n\\n    private int id(int i, int j, int di, int dj){\\n        return (di + 2 * i + 1) * (2 * n + 1) + (dj + 2 * j + 1);\\n    }\\n\\n    private class UF {\\n        int[] parent;\\n        int[] rank;\\n\\n        UF (int n){\\n            parent = IntStream.range(0, n).toArray();\\n            rank = new int[n];\\n        }\\n\\n        int find(int x){\\n            return x == parent[x]? x : (parent[x] = find(parent[x]));\\n        }\\n\\n        void union(int x, int y){\\n            x = find(x);\\n            y = find(y);\\n            if (x == y)\\n                return;\\n            if (rank[x] > rank[y]){\\n                parent[y] = x;\\n            }else{\\n                parent[x] = y;\\n                if (rank[x] == rank[y]){\\n                    rank[y]++;\\n                }\\n            }\\n        }\\n    }\\n```\\n\\nHere comes the fastest but the lengthiest solution: Simulation. \\nIt runs **1200%** (12 times) faster than the previous Union Find solution and scored a 100% Speed, but it is kind of annoying to write it out especially during an interview.\\n\\nIdea is that since the road has a one-to-one relationship, we go in from one side and go out from the other side, we can track of its direction and simulate the whole thing.\\n```Java\\n public boolean hasValidPath(int[][] grid) {\\n        int x = 0, y = 0, n = grid[0].length, m = grid.length, v = grid[0][0];\\n        int UP = 0, DOWN = 1, RIGHT = 2, LEFT = 3;\\n        List<Integer> st = new ArrayList<>();\\n        boolean[][] valid = new boolean[7][4]; // Mark valid directions.\\n        valid[1][RIGHT] = valid[1][LEFT] = valid[2][UP] = valid[2][DOWN] = valid[3][RIGHT] = valid[3][UP] = true;\\n        valid[4][UP] = valid[4][LEFT] = valid[5][RIGHT] = valid[5][DOWN] = valid[6][LEFT] = valid[6][DOWN] = true;\\n        if (v == 1 || v == 3){ // Determine start direction. Note that 4 can start with two and 5 starts with none.\\n            st.add(RIGHT);\\n        }\\n        if (v == 2 || v == 6){\\n            st.add(DOWN);\\n        }\\n        if (v == 4){\\n            st.add(LEFT);\\n            st.add(UP);\\n        }\\n        if (n == 1 && m == 1) // Start at 5 can still be true but only if grid is 1 by 1.\\n            return true;\\n\\n        for (int d : st){ // For each direction, we try to explore the grid\\n            while(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] > 0 && valid[grid[x][y]][d]){ // This cond has to be valid\\n                if (x == m - 1 && y == n - 1)\\n                    return true; // Found the end.\\n                v = grid[x][y];\\n                if (x > 0 && y > 0){ // don\\'t mark (0, 0) as visited because 4 can start twice.\\n                    grid[x][y] = 0;\\n                }\\n                switch(v){ // HardCode the simulation part in.\\n                    case 1 -> y = d == RIGHT? ++y : --y;\\n                    case 2 -> x = d == DOWN? ++x : --x;\\n                    case 3 -> {\\n                        if (d == RIGHT){\\n                            ++x;\\n                            d = DOWN;\\n                        }else{\\n                            --y;\\n                            d = LEFT;\\n                        }\\n                    }\\n                    case 4 -> {\\n                        if (d == LEFT){\\n                            ++x;\\n                            d = DOWN;\\n                        }else{\\n                            ++y;\\n                            d = RIGHT;\\n                        }\\n                    }\\n                    case 5 -> {\\n                        if (d == RIGHT){\\n                            --x;\\n                            d = UP;\\n                        }else{\\n                            --y;\\n                            d = LEFT;\\n                        }\\n                    }\\n                    case 6 -> {\\n                        if (d == LEFT){\\n                            --x;\\n                            d = UP;\\n                        }else{\\n                            ++y;\\n                            d = RIGHT;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false; // Not found.\\n    }\\n```\\n\\nI think this question is quite cool.\\nPlease upvote if it helps you! Thank you.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\n    public boolean hasValidPath(int[][] grid) {\\n        int[][][] dirs = {\\n            {{0, 1}, {0, -1}}, // 1\\n            {{1, 0}, {-1, 0}}, // 2\\n            {{0, -1}, {1, 0}}, // 3\\n            {{0, 1}, {1, 0}},  // 4\\n            {{-1, 0}, {0, -1}},// 5\\n            {{-1, 0}, {0, 1}}  // 6\\n        };\\n        int n = grid[0].length, m = grid.length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{0, 0});\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        while(!queue.isEmpty()){\\n            int x = queue.peek()[0];\\n            int y = queue.poll()[1];\\n            for (int[] d : dirs[grid[x][y] - 1]){\\n                int nx = x + d[0];\\n                int ny = y + d[1];\\n                if (nx < 0 || ny < 0 || nx == m || ny == n || visited[nx][ny])\\n                    continue;\\n                for (int[] dd : dirs[grid[nx][ny] - 1]){\\n                    if (nx + dd[0] == x && ny + dd[1] == y){\\n                        visited[nx][ny] = true; // If we can come back, then we can add this to the queue.\\n                        queue.offer(new int[]{nx, ny});\\n                    }\\n                }\\n            }\\n        }\\n        return visited[m - 1][n - 1];\\n    }\\n```\n```Java\\n    int n, m;\\n    public boolean hasValidPath(int[][] grid) {\\n        n = grid[0].length; m = grid.length;\\n        UF uf = new UF((2 * n + 1) * (2 * m + 1));\\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                int v = grid[i][j];\\n                if (v == 2 || v == 5 || v == 6){ // Connect CENTER to TOP\\n                    uf.union(id(i, j, 0, 0), id(i, j, -1, 0));\\n                }\\n                if (v == 1 || v == 4 || v == 6){ // Connect CENTER to RIGHT\\n                    uf.union(id(i, j, 0, 0), id(i, j, 0, 1));\\n                }\\n                if (v == 2 || v == 3 || v == 4){ // Connect CENTER to BOTTOM\\n                    uf.union(id(i, j, 0, 0), id(i, j, 1, 0));\\n                }\\n                if (v == 1 || v == 3 || v == 5){ // Connect CENTER to LEFT\\n                    uf.union(id(i, j, 0, 0), id(i, j, 0, -1));\\n                }\\n            }\\n        }\\n        return uf.find(id(0, 0, 0, 0)) == uf.find(id(m - 1, n - 1, 0, 0));\\n    }\\n\\n    private int id(int i, int j, int di, int dj){\\n        return (di + 2 * i + 1) * (2 * n + 1) + (dj + 2 * j + 1);\\n    }\\n\\n    private class UF {\\n        int[] parent;\\n        int[] rank;\\n\\n        UF (int n){\\n            parent = IntStream.range(0, n).toArray();\\n            rank = new int[n];\\n        }\\n\\n        int find(int x){\\n            return x == parent[x]? x : (parent[x] = find(parent[x]));\\n        }\\n\\n        void union(int x, int y){\\n            x = find(x);\\n            y = find(y);\\n            if (x == y)\\n                return;\\n            if (rank[x] > rank[y]){\\n                parent[y] = x;\\n            }else{\\n                parent[x] = y;\\n                if (rank[x] == rank[y]){\\n                    rank[y]++;\\n                }\\n            }\\n        }\\n    }\\n```\n```Java\\n public boolean hasValidPath(int[][] grid) {\\n        int x = 0, y = 0, n = grid[0].length, m = grid.length, v = grid[0][0];\\n        int UP = 0, DOWN = 1, RIGHT = 2, LEFT = 3;\\n        List<Integer> st = new ArrayList<>();\\n        boolean[][] valid = new boolean[7][4]; // Mark valid directions.\\n        valid[1][RIGHT] = valid[1][LEFT] = valid[2][UP] = valid[2][DOWN] = valid[3][RIGHT] = valid[3][UP] = true;\\n        valid[4][UP] = valid[4][LEFT] = valid[5][RIGHT] = valid[5][DOWN] = valid[6][LEFT] = valid[6][DOWN] = true;\\n        if (v == 1 || v == 3){ // Determine start direction. Note that 4 can start with two and 5 starts with none.\\n            st.add(RIGHT);\\n        }\\n        if (v == 2 || v == 6){\\n            st.add(DOWN);\\n        }\\n        if (v == 4){\\n            st.add(LEFT);\\n            st.add(UP);\\n        }\\n        if (n == 1 && m == 1) // Start at 5 can still be true but only if grid is 1 by 1.\\n            return true;\\n\\n        for (int d : st){ // For each direction, we try to explore the grid\\n            while(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] > 0 && valid[grid[x][y]][d]){ // This cond has to be valid\\n                if (x == m - 1 && y == n - 1)\\n                    return true; // Found the end.\\n                v = grid[x][y];\\n                if (x > 0 && y > 0){ // don\\'t mark (0, 0) as visited because 4 can start twice.\\n                    grid[x][y] = 0;\\n                }\\n                switch(v){ // HardCode the simulation part in.\\n                    case 1 -> y = d == RIGHT? ++y : --y;\\n                    case 2 -> x = d == DOWN? ++x : --x;\\n                    case 3 -> {\\n                        if (d == RIGHT){\\n                            ++x;\\n                            d = DOWN;\\n                        }else{\\n                            --y;\\n                            d = LEFT;\\n                        }\\n                    }\\n                    case 4 -> {\\n                        if (d == LEFT){\\n                            ++x;\\n                            d = DOWN;\\n                        }else{\\n                            ++y;\\n                            d = RIGHT;\\n                        }\\n                    }\\n                    case 5 -> {\\n                        if (d == RIGHT){\\n                            --x;\\n                            d = UP;\\n                        }else{\\n                            --y;\\n                            d = LEFT;\\n                        }\\n                    }\\n                    case 6 -> {\\n                        if (d == LEFT){\\n                            --x;\\n                            d = UP;\\n                        }else{\\n                            ++y;\\n                            d = RIGHT;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false; // Not found.\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886432,
                "title": "python-simple-dfs",
                "content": "\\n    def hasValidPath(self, A):\\n        dict1 = {1:[\"l\",\"r\"], 2:[\"u\",\"d\"], 3:[\"l\",\"d\"], 4:[\"r\",\"d\"], 5:[\"u\",\"l\"], 6:[\"u\",\"r\"]}\\n        \\n        seen = set()\\n        \\n        n, m = len(A), len(A[0])\\n        \\n        ans = [(0,0)]\\n        \\n        while ans:\\n            i, j = ans.pop()\\n\\t\\t\\t\\n            if (i, j) not in seen:\\n                d1, d2 = dict1[A[i][j]]\\n                \\n                for d in [d1, d2]:\\n                    if d == \"u\" and 0<=i-1<n and (i-1,j) not in seen and \"d\" in dict1[A[i-1][j]]:\\n                        ans.append((i-1,j))\\n                    elif d == \"d\" and 0<=i+1<n and (i+1,j) not in seen and \"u\" in dict1[A[i+1][j]]:\\n                        ans.append((i+1,j))\\n                    elif d == \"l\" and 0<=j-1<m and (i,j-1) not in seen and \"r\" in dict1[A[i][j-1]]:\\n                        ans.append((i,j-1))\\n                    elif d == \"r\" and 0<=j+1<m and (i,j+1) not in seen and \"l\" in dict1[A[i][j+1]]:\\n                        ans.append((i,j+1))\\n                        \\n                seen.add((i,j))\\n                \\n                if i+1 == n and j+1 == m:\\n                    return True\\n                \\n        return False",
                "solutionTags": [],
                "code": "\\n    def hasValidPath(self, A):\\n        dict1 = {1:[\"l\",\"r\"], 2:[\"u\",\"d\"], 3:[\"l\",\"d\"], 4:[\"r\",\"d\"], 5:[\"u\",\"l\"], 6:[\"u\",\"r\"]}\\n        \\n        seen = set()\\n        \\n        n, m = len(A), len(A[0])\\n        \\n        ans = [(0,0)]\\n        \\n        while ans:\\n            i, j = ans.pop()\\n\\t\\t\\t\\n            if (i, j) not in seen:\\n                d1, d2 = dict1[A[i][j]]\\n                \\n                for d in [d1, d2]:\\n                    if d == \"u\" and 0<=i-1<n and (i-1,j) not in seen and \"d\" in dict1[A[i-1][j]]:\\n                        ans.append((i-1,j))\\n                    elif d == \"d\" and 0<=i+1<n and (i+1,j) not in seen and \"u\" in dict1[A[i+1][j]]:\\n                        ans.append((i+1,j))\\n                    elif d == \"l\" and 0<=j-1<m and (i,j-1) not in seen and \"r\" in dict1[A[i][j-1]]:\\n                        ans.append((i,j-1))\\n                    elif d == \"r\" and 0<=j+1<m and (i,j+1) not in seen and \"l\" in dict1[A[i][j+1]]:\\n                        ans.append((i,j+1))\\n                        \\n                seen.add((i,j))\\n                \\n                if i+1 == n and j+1 == m:\\n                    return True\\n                \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 1731654,
                "title": "cpp-classical-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> vis;  //visited array \\n    int m,n;\\n    \\n    bool fun(int i,int j,vector<vector<int>>& grid)\\n    {\\n        if(i == -1 or j == -1 or i == m or j == n or vis[i][j] == true) return false;\\n        if(i == m-1 and j == n-1){\\n            return true;\\n        }\\n        //Simple classical dfs\\n        \\n        vis[i][j] = true;\\n        \\n        if(grid[i][j] == 1){\\n            \\n            if(j+1 != n and (grid[i][j+1] == 1 or grid[i][j+1] == 3 or grid[i][j+1] == 5 ) and vis[i][j+1] == false){\\n                if(fun(i,j+1,grid) == true) return true;    \\n            }\\n            if(j-1 != -1 and (grid[i][j-1] == 1 or grid[i][j-1] == 4 or grid[i][j-1] == 6)  and vis[i][j-1] == false){\\n                if(fun(i,j-1,grid) == true) return true;    \\n            }\\n            \\n        }else if(grid[i][j] == 2){\\n            if(i+1 != m and (grid[i+1][j] == 5 or grid[i+1][j] == 6 or grid[i+1][j] == 2)  and vis[i+1][j] == false){\\n                if(fun(i+1,j,grid) == true) return true;    \\n            }\\n             if(i-1 != -1 and (grid[i-1][j] == 2 or grid[i-1][j] == 3 or grid[i-1][j] == 4)  and vis[i-1][j] == false){\\n                if(fun(i-1,j,grid) == true) return true;    \\n            }\\n        }else if(grid[i][j] == 3){\\n            if(j-1 != -1 and (grid[i][j-1] == 1 or grid[i][j-1] == 4 or grid[i][j-1] == 6)  and vis[i][j-1] == false){\\n                if(fun(i,j-1,grid) == true) return true;    \\n            }\\n             if(i+1 != m and (grid[i+1][j] == 5 or grid[i+1][j] == 6 or grid[i+1][j] == 2)  and vis[i+1][j] == false){\\n                if(fun(i+1,j,grid) == true) return true;    \\n            }\\n        }else if(grid[i][j] == 4){\\n            if(j+1 != n and (grid[i][j+1] == 1 or grid[i][j+1] == 3 or grid[i][j+1] == 5)  and vis[i][j+1] == false){\\n                if(fun(i,j+1,grid) == true) return true;    \\n            }\\n            if(i+1 != m and (grid[i+1][j] == 5 or grid[i+1][j] == 6 or grid[i+1][j] == 2)  and vis[i+1][j] == false){\\n                if(fun(i+1,j,grid) == true) return true;    \\n            }\\n        }else if(grid[i][j] == 5){\\n              if(i-1 != -1 and (grid[i-1][j] == 2 or grid[i-1][j] == 3 or grid[i-1][j] == 4)  and vis[i-1][j] == false){\\n                if(fun(i-1,j,grid) == true) return true;    \\n            }\\n            if(j-1 != -1 and (grid[i][j-1] == 1 or grid[i][j-1] == 4 or grid[i][j-1] == 6)  and vis[i][j-1] == false){\\n                if(fun(i,j-1,grid) == true) return true;    \\n            }\\n        }else if(grid[i][j] == 6){\\n             if(i-1 != -1 and (grid[i-1][j] == 2 or grid[i-1][j] == 3 or grid[i-1][j] == 4)  and vis[i-1][j] == false){\\n                if(fun(i-1,j,grid) == true) return true;    \\n            }\\n             if(j+1 != n and (grid[i][j+1] == 1 or grid[i][j+1] == 3 or grid[i][j+1] == 5)  and vis[i][j+1] == false){\\n                if(fun(i,j+1,grid) == true) return true;    \\n            }\\n        }\\n        return false;\\n        \\n        \\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        vis = vector<vector<bool>> (m,vector<bool> (n));\\n        \\n        return fun(0,0,grid);\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<vector<bool>> vis;  //visited array \\n    int m,n;\\n    \\n    bool fun(int i,int j,vector<vector<int>>& grid)\\n    {\\n        if(i == -1 or j == -1 or i == m or j == n or vis[i][j] == true) return false;\\n        if(i == m-1 and j == n-1){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1486702,
                "title": "python3-readable-solution-with-comments",
                "content": "```\\nclass Solution:\\n    # define direction identifiers\\n    left, right, up, down = 0, 1, 2, 3\\n    \\n    # define possible directions to move from a given street\\n    moves = {\\n        1: {left, right},\\n        2: {up,   down},\\n        3: {left, down},\\n        4: {down, right},\\n        5: {left, up},\\n        6: {up,   right}\\n    }\\n    \\n    # defind offsets x, y offsets for each direction\\n    offsets = {\\n        left:  ( 0, -1, right), # y offset, x offset, move to return to previous position\\n        right: ( 0,  1, left),\\n        up:    (-1,  0, down),\\n        down:  ( 1,  0, up)\\n    }\\n        \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        if len(grid) == 1 and len(grid[0]) == 1:\\n            return True\\n        \\n        # on the start we can possibly move only to right and down\\n        # so there are only two possible paths which can lead as to the final position\\n        for direction in [Solution.right, Solution.down]:\\n            cur_x, cur_y = 0, 0\\n            while 1:\\n                y_offset, x_offset, reverse_move = Solution.offsets[direction]\\n                cur_x += x_offset\\n                cur_y += y_offset\\n                \\n                # break if current road leads us to out of grid\\n                if not (0 <= cur_x < len(grid[0]) and 0 <= cur_y < len(grid)):\\n                    break\\n                # break if current road leads us to incompatible road\\n                if not reverse_move in Solution.moves[grid[cur_y][cur_x]]:\\n                    break\\n                \\n                # we are in the infinite loop\\n                if (cur_x, cur_y) == (0, 0):\\n                    break\\n                \\n                # define next direction\\n                direction = [i for i in Solution.moves[grid[cur_y][cur_x]] if i != reverse_move][0]\\n                if (cur_x, cur_y) == (len(grid[0]) - 1, len(grid) - 1):\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # define direction identifiers\\n    left, right, up, down = 0, 1, 2, 3\\n    \\n    # define possible directions to move from a given street\\n    moves = {\\n        1: {left, right},\\n        2: {up,   down},\\n        3: {left, down},\\n        4: {down, right},\\n        5: {left, up},\\n        6: {up,   right}\\n    }\\n    \\n    # defind offsets x, y offsets for each direction\\n    offsets = {\\n        left:  ( 0, -1, right), # y offset, x offset, move to return to previous position\\n        right: ( 0,  1, left),\\n        up:    (-1,  0, down),\\n        down:  ( 1,  0, up)\\n    }\\n        \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        if len(grid) == 1 and len(grid[0]) == 1:\\n            return True\\n        \\n        # on the start we can possibly move only to right and down\\n        # so there are only two possible paths which can lead as to the final position\\n        for direction in [Solution.right, Solution.down]:\\n            cur_x, cur_y = 0, 0\\n            while 1:\\n                y_offset, x_offset, reverse_move = Solution.offsets[direction]\\n                cur_x += x_offset\\n                cur_y += y_offset\\n                \\n                # break if current road leads us to out of grid\\n                if not (0 <= cur_x < len(grid[0]) and 0 <= cur_y < len(grid)):\\n                    break\\n                # break if current road leads us to incompatible road\\n                if not reverse_move in Solution.moves[grid[cur_y][cur_x]]:\\n                    break\\n                \\n                # we are in the infinite loop\\n                if (cur_x, cur_y) == (0, 0):\\n                    break\\n                \\n                # define next direction\\n                direction = [i for i in Solution.moves[grid[cur_y][cur_x]] if i != reverse_move][0]\\n                if (cur_x, cur_y) == (len(grid[0]) - 1, len(grid) - 1):\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336417,
                "title": "python-solution-using-dfs",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        def connection(i,j,val):#to know which cells the current cell connects refer the diagram in question\\n            if val==1:\\n                return [[i,j-1],[i,j+1]]\\n            elif val==2:\\n                return [[i-1,j],[i+1,j]]\\n            elif val==3:\\n                return [[i,j-1],[i+1,j]]\\n            elif val==4:\\n                return [[i,j+1],[i+1,j]]\\n            elif val==5:\\n                return [[i,j-1],[i-1,j]]\\n            elif val==6:\\n                return [[i,j+1],[i-1,j]]\\n        def isValidPos(i,j):#to check if current position is valid or not\\n            nonlocal rows,cols,visited\\n            if i<0 or j<0 or i>=rows or j>=cols or visited[i][j]==True:\\n                return False\\n            return True\\n        def func(i,j,visited):\\n            nonlocal grid,rows,cols,flag\\n            if i==rows-1 and j==cols-1:#reached the bottom-right cell of the matrix\\n                flag=True\\n                return\\n            visited[i][j]=True#mark the cell as visited so it does\\'t come into account in further recursive calls\\n            curr=[i,j]\\n            con=connection(i,j,grid[i][j])#list of cells that current cell connects\\n\\n            \\'\\'\\'\\n            check whether adjacent cells can be connected through the current cell and \\n            also the adjacent cell connects to current cell so that we have a path from current\\n            cell to that adjacent cell\\n\\n            [[1,2],[2,1]]-checkout this testcase to know why we have to check for adjacent cell\\n            connections\\n            \\'\\'\\'\\n            if isValidPos(i+1,j) and [i+1,j] in con and curr in connection(i+1,j,grid[i+1][j]):\\n                func(i+1,j,visited)\\n            if isValidPos(i-1,j) and [i-1,j] in con and curr in connection(i-1,j,grid[i-1][j]):\\n                func(i-1,j,visited)\\n            if isValidPos(i,j-1) and [i,j-1] in con and curr in connection(i,j-1,grid[i][j-1]):\\n                func(i,j-1,visited)\\n            if isValidPos(i,j+1) and [i,j+1] in con and curr in connection(i,j+1,grid[i][j+1]):\\n                func(i,j+1,visited)\\n            visited[i][j]=False #backtrack\\n        flag=False\\n        rows=len(grid)\\n        cols=len(grid[0])\\n        visited=[[False for j in range(cols)] for i in range(rows)]\\n        func(0,0,visited)\\n        return flag #able to reach or not\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        def connection(i,j,val):#to know which cells the current cell connects refer the diagram in question\\n            if val==1:\\n                return [[i,j-1],[i,j+1]]\\n            elif val==2:\\n                return [[i-1,j],[i+1,j]]\\n            elif val==3:\\n                return [[i,j-1],[i+1,j]]\\n            elif val==4:\\n                return [[i,j+1],[i+1,j]]\\n            elif val==5:\\n                return [[i,j-1],[i-1,j]]\\n            elif val==6:\\n                return [[i,j+1],[i-1,j]]\\n        def isValidPos(i,j):#to check if current position is valid or not\\n            nonlocal rows,cols,visited\\n            if i<0 or j<0 or i>=rows or j>=cols or visited[i][j]==True:\\n                return False\\n            return True\\n        def func(i,j,visited):\\n            nonlocal grid,rows,cols,flag\\n            if i==rows-1 and j==cols-1:#reached the bottom-right cell of the matrix\\n                flag=True\\n                return\\n            visited[i][j]=True#mark the cell as visited so it does\\'t come into account in further recursive calls\\n            curr=[i,j]\\n            con=connection(i,j,grid[i][j])#list of cells that current cell connects\\n\\n            \\'\\'\\'\\n            check whether adjacent cells can be connected through the current cell and \\n            also the adjacent cell connects to current cell so that we have a path from current\\n            cell to that adjacent cell\\n\\n            [[1,2],[2,1]]-checkout this testcase to know why we have to check for adjacent cell\\n            connections\\n            \\'\\'\\'\\n            if isValidPos(i+1,j) and [i+1,j] in con and curr in connection(i+1,j,grid[i+1][j]):\\n                func(i+1,j,visited)\\n            if isValidPos(i-1,j) and [i-1,j] in con and curr in connection(i-1,j,grid[i-1][j]):\\n                func(i-1,j,visited)\\n            if isValidPos(i,j-1) and [i,j-1] in con and curr in connection(i,j-1,grid[i][j-1]):\\n                func(i,j-1,visited)\\n            if isValidPos(i,j+1) and [i,j+1] in con and curr in connection(i,j+1,grid[i][j+1]):\\n                func(i,j+1,visited)\\n            visited[i][j]=False #backtrack\\n        flag=False\\n        rows=len(grid)\\n        cols=len(grid[0])\\n        visited=[[False for j in range(cols)] for i in range(rows)]\\n        func(0,0,visited)\\n        return flag #able to reach or not\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279886,
                "title": "c-bfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool hasValidPath(vector<vector<int>>& grid) {\\n\\t\\t\\tint m=grid.size();\\n\\t\\t\\tint n=grid[0].size();\\n\\n\\t\\t\\tvector<vector<bool>>visited(m,vector<bool>(n,false));\\n\\n\\t\\t\\tqueue<pair<int,int>>q;\\n\\t\\t\\tq.push({0,0});\\n\\n\\t\\t\\tvector<int>dir{-1,0,1,0,-1};\\n\\t\\t\\tvisited[0][0]=true;\\n\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint len=q.size();\\n\\t\\t\\t\\twhile(len--){\\n\\t\\t\\t\\t\\tpair<int,int>cur=q.front();q.pop();\\n\\t\\t\\t\\t\\tint street=grid[cur.first][cur.second];\\n\\t\\t\\t\\t\\tfor(int i=0;i<4;++i){\\n\\t\\t\\t\\t\\t\\tint nextx=cur.first+dir[i];\\n\\t\\t\\t\\t\\t\\tint nexty=cur.second+dir[i+1];\\n\\t\\t\\t\\t\\t\\tif(nextx<0 || nexty<0 || nextx>=m || nexty>=n || visited[nextx][nexty] || !validRoad(grid[nextx][nexty],street,i))continue;                    \\n\\t\\t\\t\\t\\t\\tif(nextx==m-1 && nexty==n-1)return true;\\n\\t\\t\\t\\t\\t\\tvisited[nextx][nexty]=true;\\n\\t\\t\\t\\t\\t\\tq.push({nextx,nexty});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn visited[m-1][n-1];\\n\\t\\t}\\n\\tprivate:\\n\\t\\tbool validRoad(int next,int cur, int dir){\\n\\t\\t\\tswitch(cur){\\n\\t\\t\\t\\tcase 1:\\n\\t\\t\\t\\t\\tif(dir==1 && (next==3 || next==1 || next==5))return true;\\n\\t\\t\\t\\t\\tif(dir==3 && (next==4 || next==1 || next==6))return true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 2:\\n\\t\\t\\t\\t\\tif(dir==0 && (next==4 || next==3 || next==2))return true;\\n\\t\\t\\t\\t\\tif(dir==2 && (next==5 || next==6 || next==2))return true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 3:\\n\\t\\t\\t\\t\\tif(dir==2 && (next==5 || next==6 || next==2))return true;\\n\\t\\t\\t\\t\\tif(dir==3 && (next==4 || next==1 || next==6))return true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 4:\\n\\t\\t\\t\\t\\tif(dir==1 && (next==3 || next==1 || next==5))return true;\\n\\t\\t\\t\\t\\tif(dir==2 && (next==5 || next==6 || next==2))return true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 5:\\n\\t\\t\\t\\t\\tif(dir==0 && (next==4 || next==3 || next==2))return true;\\n\\t\\t\\t\\t\\tif(dir==3 && (next==4 || next==1 || next==6))return true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 6:\\n\\t\\t\\t\\t\\tif(dir==1 && (next==3 || next==1 || next==5))return true;\\n\\t\\t\\t\\t\\tif(dir==0 && (next==4 || next==3 || next==2))return true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool hasValidPath(vector<vector<int>>& grid) {\\n\\t\\t\\tint m=grid.size();\\n\\t\\t\\tint n=grid[0].size();\\n\\n\\t\\t\\tvector<vector<bool>>visited(m,vector<bool>(n,false));\\n\\n\\t\\t\\tqueue<pair<int,int>>q;\\n\\t\\t\\tq.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1260644,
                "title": "c-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<int> >&grid,int x,int y,vector<vector<int> >&dp)\\n    {\\n        dp[x][y]=1;\\n        if(grid[x][y]==2)\\n        {\\n            if(x>0)\\n            {\\n                if(dp[x-1][y]==0&&(grid[x-1][y]==3||grid[x-1][y]==4||grid[x-1][y]==2))\\n                {\\n                    DFS(grid,x-1,y,dp);\\n                }\\n            }\\n            if(x+1<grid.size())\\n            {\\n               if(dp[x+1][y]==0&&(grid[x+1][y]==5||grid[x+1][y]==6||grid[x+1][y]==2))\\n                {\\n                    DFS(grid,x+1,y,dp);\\n                } \\n            }\\n        }\\n        else if(grid[x][y]==1)\\n        {\\n         if(y>0)\\n         {\\n             if(dp[x][y-1]==0&&(grid[x][y-1]==4||grid[x][y-1]==6||grid[x][y-1]==1))\\n             {\\n                 DFS(grid,x,y-1,dp);\\n             }\\n         }\\n         if(y+1<grid[x].size())\\n         {\\n             if(dp[x][y+1]==0&&(grid[x][y+1]==3||grid[x][y+1]==5||grid[x][y+1]==1))\\n             {\\n                 DFS(grid,x,y+1,dp);\\n             }\\n         }\\n        }\\n        else if(grid[x][y]==3)\\n        {\\n            if(y>0)\\n            {\\n                if(dp[x][y-1]==0&&(grid[x][y-1]==6||grid[x][y-1]==4||grid[x][y-1]==1))\\n                {\\n                    DFS(grid,x,y-1,dp);\\n                }\\n            }\\n            if(x+1<grid.size())\\n            {\\n                if(dp[x+1][y]==0&&(grid[x+1][y]==2||grid[x+1][y]==5||grid[x+1][y]==6))\\n                {\\n                    DFS(grid,x+1,y,dp);\\n                }\\n            }\\n        }\\n        else if(grid[x][y]==4)\\n        {\\n            if(x+1<grid.size())\\n            {\\n                \\n                if(dp[x+1][y]==0&&(grid[x+1][y]==2||grid[x+1][y]==5||grid[x+1][y]==6))\\n                {\\n                    DFS(grid,x+1,y,dp);\\n                }\\n                \\n            }\\n            if(y+1<grid[x].size())\\n            {\\n                \\n                if(dp[x][y+1]==0&&(grid[x][y+1]==1||grid[x][y+1]==5||grid[x][y+1]==3))\\n                {\\n                    DFS(grid,x,y+1,dp);\\n                }\\n                \\n            }\\n        }\\n        else if(grid[x][y]==5)\\n        {\\n            \\n            if(x>0)\\n            {\\n                if(dp[x-1][y]==0&&(grid[x-1][y]==2||grid[x-1][y]==4||grid[x-1][y]==3))\\n                {\\n                    DFS(grid,x-1,y,dp);\\n                }\\n            }\\n            if(y>0)\\n            {\\n                if(dp[x][y-1]==0&&(grid[x][y-1]==1||grid[x][y-1]==4||grid[x][y-1]==6))\\n                {\\n                    DFS(grid,x,y-1,dp);\\n                }\\n            }\\n            \\n        }\\n        else if(grid[x][y]==6)\\n        {\\n            \\n          if(x>0)\\n          {\\n              if(dp[x-1][y]==0&&(grid[x-1][y]==2||grid[x-1][y]==3||grid[x-1][y]==4))\\n              {\\n                  DFS(grid,x-1,y,dp);\\n              }\\n          }\\n            if(y+1<grid[x].size())\\n             {\\n             if(dp[x][y+1]==0&&(grid[x][y+1]==1||grid[x][y+1]==3||grid[x][y+1]==5))\\n               {\\n               DFS(grid,x,y+1,dp);\\n               }\\n            }\\n        }\\n     \\n        \\n        return ;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid)\\n    {\\n         \\n         vector<vector<int> >dp(301,vector<int>(301,0));\\n         DFS(grid,0,0,dp);\\n        return dp[grid.size()-1][grid[0].size()-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<int> >&grid,int x,int y,vector<vector<int> >&dp)\\n    {\\n        dp[x][y]=1;\\n        if(grid[x][y]==2)\\n        {\\n            if(x>0)\\n            {\\n                if(dp[x-1][y]==0&&(grid[x-1][y]==3||grid[x-1][y]==4||grid[x-1][y]==2))\\n                {\\n                    DFS(grid,x-1,y,dp);\\n                }\\n            }\\n            if(x+1<grid.size())\\n            {\\n               if(dp[x+1][y]==0&&(grid[x+1][y]==5||grid[x+1][y]==6||grid[x+1][y]==2))\\n                {\\n                    DFS(grid,x+1,y,dp);\\n                } \\n            }\\n        }\\n        else if(grid[x][y]==1)\\n        {\\n         if(y>0)\\n         {\\n             if(dp[x][y-1]==0&&(grid[x][y-1]==4||grid[x][y-1]==6||grid[x][y-1]==1))\\n             {\\n                 DFS(grid,x,y-1,dp);\\n             }\\n         }\\n         if(y+1<grid[x].size())\\n         {\\n             if(dp[x][y+1]==0&&(grid[x][y+1]==3||grid[x][y+1]==5||grid[x][y+1]==1))\\n             {\\n                 DFS(grid,x,y+1,dp);\\n             }\\n         }\\n        }\\n        else if(grid[x][y]==3)\\n        {\\n            if(y>0)\\n            {\\n                if(dp[x][y-1]==0&&(grid[x][y-1]==6||grid[x][y-1]==4||grid[x][y-1]==1))\\n                {\\n                    DFS(grid,x,y-1,dp);\\n                }\\n            }\\n            if(x+1<grid.size())\\n            {\\n                if(dp[x+1][y]==0&&(grid[x+1][y]==2||grid[x+1][y]==5||grid[x+1][y]==6))\\n                {\\n                    DFS(grid,x+1,y,dp);\\n                }\\n            }\\n        }\\n        else if(grid[x][y]==4)\\n        {\\n            if(x+1<grid.size())\\n            {\\n                \\n                if(dp[x+1][y]==0&&(grid[x+1][y]==2||grid[x+1][y]==5||grid[x+1][y]==6))\\n                {\\n                    DFS(grid,x+1,y,dp);\\n                }\\n                \\n            }\\n            if(y+1<grid[x].size())\\n            {\\n                \\n                if(dp[x][y+1]==0&&(grid[x][y+1]==1||grid[x][y+1]==5||grid[x][y+1]==3))\\n                {\\n                    DFS(grid,x,y+1,dp);\\n                }\\n                \\n            }\\n        }\\n        else if(grid[x][y]==5)\\n        {\\n            \\n            if(x>0)\\n            {\\n                if(dp[x-1][y]==0&&(grid[x-1][y]==2||grid[x-1][y]==4||grid[x-1][y]==3))\\n                {\\n                    DFS(grid,x-1,y,dp);\\n                }\\n            }\\n            if(y>0)\\n            {\\n                if(dp[x][y-1]==0&&(grid[x][y-1]==1||grid[x][y-1]==4||grid[x][y-1]==6))\\n                {\\n                    DFS(grid,x,y-1,dp);\\n                }\\n            }\\n            \\n        }\\n        else if(grid[x][y]==6)\\n        {\\n            \\n          if(x>0)\\n          {\\n              if(dp[x-1][y]==0&&(grid[x-1][y]==2||grid[x-1][y]==3||grid[x-1][y]==4))\\n              {\\n                  DFS(grid,x-1,y,dp);\\n              }\\n          }\\n            if(y+1<grid[x].size())\\n             {\\n             if(dp[x][y+1]==0&&(grid[x][y+1]==1||grid[x][y+1]==3||grid[x][y+1]==5))\\n               {\\n               DFS(grid,x,y+1,dp);\\n               }\\n            }\\n        }\\n     \\n        \\n        return ;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid)\\n    {\\n         \\n         vector<vector<int> >dp(301,vector<int>(301,0));\\n         DFS(grid,0,0,dp);\\n        return dp[grid.size()-1][grid[0].size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144767,
                "title": "python-3-concise-bfs-coordinate-mapping",
                "content": "```\\ndef hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n, dq, seen = len(grid), len(grid[0]), collections.deque(), set()\\n        if m == n == 1:\\n            return True\\n\\n        dirs = {1: ((0, 1), (0, -1)), 2: ((1, 0), (-1, 0)), 3: ((0, -1), (1, 0)), \\\\\\n                4: ((1, 0), (0, 1)), 5: ((0, -1), (-1, 0)), 6: ((-1, 0), (0, 1))}\\n        \\n        dq.append((0, 0, grid[0][0]))\\n        seen.add((0, 0))\\n        \\n        while dq:\\n            cx, cy, num = dq.popleft()\\n            for dx, dy in dirs[num]:\\n                if 0 <= cx + dx < m and 0 <= cy + dy < n and (cx + dx, cy + dy) not in seen:\\n                    if (-dx, -dy) in dirs[grid[cx + dx][cy + dy]]: \\n                        if cx + dx == m - 1 and cy + dy == n - 1:\\n                            return True\\n                        seen.add((cx + dx, cy + dy))\\n                        dq.append((cx + dx, cy + dy, grid[cx + dx][cy + dy]))\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n, dq, seen = len(grid), len(grid[0]), collections.deque(), set()\\n        if m == n == 1:\\n            return True\\n\\n        dirs = {1: ((0, 1), (0, -1)), 2: ((1, 0), (-1, 0)), 3: ((0, -1), (1, 0)), \\\\\\n                4: ((1, 0), (0, 1)), 5: ((0, -1), (-1, 0)), 6: ((-1, 0), (0, 1))}\\n        \\n        dq.append((0, 0, grid[0][0]))\\n        seen.add((0, 0))\\n        \\n        while dq:\\n            cx, cy, num = dq.popleft()\\n            for dx, dy in dirs[num]:\\n                if 0 <= cx + dx < m and 0 <= cy + dy < n and (cx + dx, cy + dy) not in seen:\\n                    if (-dx, -dy) in dirs[grid[cx + dx][cy + dy]]: \\n                        if cx + dx == m - 1 and cy + dy == n - 1:\\n                            return True\\n                        seen.add((cx + dx, cy + dy))\\n                        dq.append((cx + dx, cy + dy, grid[cx + dx][cy + dy]))\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1118089,
                "title": "union-find-quick-union",
                "content": "I know it is slow. I just want to prove UF also works.\\n\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    int[][][] parent; //    int[row][col][2]\\n    public boolean hasValidPath(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0] == null) return false;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        parent = new int[row][col][2];\\n\\n        // init parent matrix\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                parent[i][j][0] = i;\\n                parent[i][j][1] = j;\\n            }\\n        }\\n\\n        boolean[][] upDown = new boolean[7][7];\\n        boolean[][] leftRight = new boolean[7][7];\\n\\n        upDown[2][2] = upDown[2][5] = upDown[2][6] = true;\\n        upDown[3][2] = upDown[3][5] = upDown[3][6] = true;\\n        upDown[4][2] = upDown[4][5] = upDown[4][6] = true;\\n\\n        leftRight[1][1] = leftRight[1][3] = leftRight[1][5] = true;\\n        leftRight[4][1] = leftRight[4][3] = leftRight[4][5] = true;\\n        leftRight[6][1] = leftRight[6][3] = leftRight[6][5] = true;\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                // connect current node and down node if possible\\n                if(i < row - 1) {\\n                    if(upDown[grid[i][j]][grid[i + 1][j]]){\\n                        union(i, j , i+1, j);\\n                    }\\n                }\\n                // connect current node and right node if possible\\n                if(j < col - 1){\\n                    if(leftRight[grid[i][j]][grid[i][j+1]]){\\n                        union(i, j , i, j+1);\\n                    }\\n                }\\n            }\\n        }\\n        return find(0, 0, row-1, col-1);\\n    }\\n\\n    private int[] root(int x, int y) {\\n        int[] t;\\n        while (x != parent[x][y][0] || y != parent[x][y][1])  {\\n           t = parent[x][y];\\n           x = t[0];\\n           y = t[1];\\n        }\\n        return new int[]{x, y};\\n    }\\n\\n    public boolean find(int ax, int ay, int bx, int by) {\\n        int[] a1 = root(ax, ay);\\n        int[] b1 = root(bx, by);\\n        return a1[0] == b1[0] && a1[1] == b1[1];\\n    }\\n\\n    // Quick Union (faster for this problem)\\n    public void union(int ax, int ay, int bx, int by) {\\n        System.out.println(\"Union(\" +ax  +\", \"+ ay +\"), and (\"+ bx  +\", \"+  by + \")\");\\n        int[] i = root(ax, ay);\\n        int[] j = root(bx, by);\\n        parent[i[0]][i[1]][0] = j[0];\\n        parent[i[0]][i[1]][1] = j[1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    int[][][] parent; //    int[row][col][2]\\n    public boolean hasValidPath(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0] == null) return false;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        parent = new int[row][col][2];\\n\\n        // init parent matrix\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                parent[i][j][0] = i;\\n                parent[i][j][1] = j;\\n            }\\n        }\\n\\n        boolean[][] upDown = new boolean[7][7];\\n        boolean[][] leftRight = new boolean[7][7];\\n\\n        upDown[2][2] = upDown[2][5] = upDown[2][6] = true;\\n        upDown[3][2] = upDown[3][5] = upDown[3][6] = true;\\n        upDown[4][2] = upDown[4][5] = upDown[4][6] = true;\\n\\n        leftRight[1][1] = leftRight[1][3] = leftRight[1][5] = true;\\n        leftRight[4][1] = leftRight[4][3] = leftRight[4][5] = true;\\n        leftRight[6][1] = leftRight[6][3] = leftRight[6][5] = true;\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                // connect current node and down node if possible\\n                if(i < row - 1) {\\n                    if(upDown[grid[i][j]][grid[i + 1][j]]){\\n                        union(i, j , i+1, j);\\n                    }\\n                }\\n                // connect current node and right node if possible\\n                if(j < col - 1){\\n                    if(leftRight[grid[i][j]][grid[i][j+1]]){\\n                        union(i, j , i, j+1);\\n                    }\\n                }\\n            }\\n        }\\n        return find(0, 0, row-1, col-1);\\n    }\\n\\n    private int[] root(int x, int y) {\\n        int[] t;\\n        while (x != parent[x][y][0] || y != parent[x][y][1])  {\\n           t = parent[x][y];\\n           x = t[0];\\n           y = t[1];\\n        }\\n        return new int[]{x, y};\\n    }\\n\\n    public boolean find(int ax, int ay, int bx, int by) {\\n        int[] a1 = root(ax, ay);\\n        int[] b1 = root(bx, by);\\n        return a1[0] == b1[0] && a1[1] == b1[1];\\n    }\\n\\n    // Quick Union (faster for this problem)\\n    public void union(int ax, int ay, int bx, int by) {\\n        System.out.println(\"Union(\" +ax  +\", \"+ ay +\"), and (\"+ bx  +\", \"+  by + \")\");\\n        int[] i = root(ax, ay);\\n        int[] j = root(bx, by);\\n        parent[i[0]][i[1]][0] = j[0];\\n        parent[i[0]][i[1]][1] = j[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1105244,
                "title": "python3-dfs-with-backtracking-clean-code",
                "content": "The question is a bit tricky, considering the special case:\\n[[4,1,3], [6,1,2]], where basically you have two choices starting from position (0,0). \\n\\nIf we would know the starting direction, we wouldn\\'t even need backtracking - a single while loop should work.\\n\\nSince there are no other choices, we need to try both possibilities - that is the real reason to keep DFS + backtracking.\\n\\n```python\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        table = {1: [(0,1),(0,-1)],\\n                2: [(1,0),(-1,0)],\\n                3: [(1,0), (0,-1)],\\n                4: [(1,0), (0,1)],\\n                5: [(-1,0), (0,-1)],\\n                6: [(-1,0), (0,1)]}\\n        \\n        i = j = 0\\n        m, n = len(grid), len(grid[0])\\n\\n        def dfs(i, j):\\n            if i==m-1 and j==n-1:\\n                return True\\n            found = False\\n            for (dx,dy) in table[grid[i][j]]:\\n                x, y = i + dx, j + dy\\n                if 0<=x<m and 0<=y<n and \\\\\\n                    grid[x][y] != 0 and (-dx, -dy) in table[grid[x][y]]:\\n                        grid[i][j], t = 0, grid[i][j]\\n                        found = found or dfs(x, y)\\n                        grid[i][j] = t\\n            return found\\n\\n        return dfs(0, 0)\\n ```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        table = {1: [(0,1),(0,-1)],\\n                2: [(1,0),(-1,0)],\\n                3: [(1,0), (0,-1)],\\n                4: [(1,0), (0,1)],\\n                5: [(-1,0), (0,-1)],\\n                6: [(-1,0), (0,1)]}\\n        \\n        i = j = 0\\n        m, n = len(grid), len(grid[0])\\n\\n        def dfs(i, j):\\n            if i==m-1 and j==n-1:\\n                return True\\n            found = False\\n            for (dx,dy) in table[grid[i][j]]:\\n                x, y = i + dx, j + dy\\n                if 0<=x<m and 0<=y<n and \\\\\\n                    grid[x][y] != 0 and (-dx, -dy) in table[grid[x][y]]:\\n                        grid[i][j], t = 0, grid[i][j]\\n                        found = found or dfs(x, y)\\n                        grid[i][j] = t\\n            return found\\n\\n        return dfs(0, 0)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 948271,
                "title": "java-both-bfs-and-dfs-solutions-with-easy-explanation",
                "content": "Create an hashmap of paths\\n0,-1 left cell\\n0,1 right cell\\n-1,0 upper cell\\n1,0 lowe cell\\n\\nentries in hash map \\n1 -> { {0,-1},{0,1} } \\nindicates path 1 from left cell and right cell\\nand so on..\\n\\nthe idea is to start from 0,0 cell and go to next cells from the combination\\nif we are at 2,2 and the value is 1 we can either go left (2,1) or right (2,3)\\n\\nwe also have to check that the next cell that we will go to is also a valid cell (with in the grid) and is not visited before\\nwe can keep a visited boolean 2d array to keep check of visited cell\\n\\nwe also have to check the back link i.e the node we are going to next also links back to current back only then the next the next node is worth exploring.\\nin the exampe grid = [[1,2,1],[1,2,1]] we can go from grid[0][0] to grid[0][1] but from grid[0,1] we cannot get back to grid[0][0] thus this is not a complete path.\\n\\nif we find a path that can lead to grid[m-1][n-1] then we return true\\nwe can use either **bfs** or **dfs** to explore the grid. both will have same time complexity O(mn)\\n    \\n\\n\\n\\n```\\nclass Solution {\\n    \\n    HashMap<Integer, int[][]> dirs;\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        dirs = new HashMap<>();\\n        dirs.put(1, new int[][]{ {0,-1},{0,1} });\\n        dirs.put(2, new int[][]{ {-1,0},{1,0} });\\n        dirs.put(3, new int[][]{ {0,-1},{1,0} });\\n        dirs.put(4, new int[][]{ {0,1},{1,0} });\\n        dirs.put(5, new int[][]{ {0,-1},{-1,0} });\\n        dirs.put(6, new int[][]{ {0,1},{-1,0} });\\n\\n        boolean[][] visited = new boolean[rows][cols];\\n        \\n        // return bfs(grid, 0, 0, rows-1, cols-1,  visited);\\n        return dfs(grid, 0, 0, rows-1, cols-1,  visited);\\n    }\\n    \\n    \\n    public boolean bfs(int[][] grid, int startR, int startC, int rows, int cols, boolean[][] visited){\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{startR,startC});\\n\\n        while(!q.isEmpty()){\\n            int[] curr = q.poll();\\n            int currR = curr[0];\\n            int currC = curr[1];\\n            \\n            visited[currR][currC] = true;\\n            \\n            int path = grid[currR][currC];\\n            \\n            for(int[] dir : dirs.get(path)){\\n                \\n                int nextR = currR+dir[0];\\n                int nextC = currC+dir[1];\\n\\n                if(nextR<0 || nextR > rows || nextC<0 || nextC > cols || visited[nextR][nextC])\\n                    continue;          \\n                \\n                int nextPath = grid[nextR][nextC];\\n                for(int[] backDir : dirs.get(nextPath)){\\n                    int backR = nextR + backDir[0];\\n                    int backC = nextC + backDir[1];\\n                    if(backR == currR && backC == currC){\\n                        q.add(new int[]{nextR, nextC});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        //bfs checks in the end whether we have visited the final position \\n        return visited[rows][cols];\\n    }\\n    \\n    \\n    \\n    public boolean dfs(int[][] grid, int r, int c, int rows, int cols, boolean[][] visited){\\n        //when we have reached end return true;\\n        if(r == rows && c == cols)\\n            return true;\\n        \\n        int path = grid[r][c];\\n        \\n        for(int[] dir : dirs.get(path)){\\n            int nextR = r+dir[0];\\n            int nextC = c+dir[1];\\n            \\n            if(nextR<0 || nextR > rows || nextC<0 || nextC > cols || visited[nextR][nextC])\\n                continue;\\n            \\n            int nextPath = grid[nextR][nextC];\\n            for(int[] backDir : dirs.get(nextPath)){\\n                int backR = nextR + backDir[0];\\n                int backC = nextC + backDir[1];\\n                if(backR == r && backC == c){\\n                    visited[nextR][nextC] = true;\\n                    //return true if there is a path to end from next cell\\n                    if(dfs(grid, nextR, nextC, rows, cols, visited))\\n                        return true;\\n                }\\n            }\\n            \\n        }\\n        // return false if we haven\\'t reached end\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    HashMap<Integer, int[][]> dirs;\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        dirs = new HashMap<>();\\n        dirs.put(1, new int[][]{ {0,-1},{0,1} });\\n        dirs.put(2, new int[][]{ {-1,0},{1,0} });\\n        dirs.put(3, new int[][]{ {0,-1},{1,0} });\\n        dirs.put(4, new int[][]{ {0,1},{1,0} });\\n        dirs.put(5, new int[][]{ {0,-1},{-1,0} });\\n        dirs.put(6, new int[][]{ {0,1},{-1,0} });\\n\\n        boolean[][] visited = new boolean[rows][cols];\\n        \\n        // return bfs(grid, 0, 0, rows-1, cols-1,  visited);\\n        return dfs(grid, 0, 0, rows-1, cols-1,  visited);\\n    }\\n    \\n    \\n    public boolean bfs(int[][] grid, int startR, int startC, int rows, int cols, boolean[][] visited){\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{startR,startC});\\n\\n        while(!q.isEmpty()){\\n            int[] curr = q.poll();\\n            int currR = curr[0];\\n            int currC = curr[1];\\n            \\n            visited[currR][currC] = true;\\n            \\n            int path = grid[currR][currC];\\n            \\n            for(int[] dir : dirs.get(path)){\\n                \\n                int nextR = currR+dir[0];\\n                int nextC = currC+dir[1];\\n\\n                if(nextR<0 || nextR > rows || nextC<0 || nextC > cols || visited[nextR][nextC])\\n                    continue;          \\n                \\n                int nextPath = grid[nextR][nextC];\\n                for(int[] backDir : dirs.get(nextPath)){\\n                    int backR = nextR + backDir[0];\\n                    int backC = nextC + backDir[1];\\n                    if(backR == currR && backC == currC){\\n                        q.add(new int[]{nextR, nextC});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        //bfs checks in the end whether we have visited the final position \\n        return visited[rows][cols];\\n    }\\n    \\n    \\n    \\n    public boolean dfs(int[][] grid, int r, int c, int rows, int cols, boolean[][] visited){\\n        //when we have reached end return true;\\n        if(r == rows && c == cols)\\n            return true;\\n        \\n        int path = grid[r][c];\\n        \\n        for(int[] dir : dirs.get(path)){\\n            int nextR = r+dir[0];\\n            int nextC = c+dir[1];\\n            \\n            if(nextR<0 || nextR > rows || nextC<0 || nextC > cols || visited[nextR][nextC])\\n                continue;\\n            \\n            int nextPath = grid[nextR][nextC];\\n            for(int[] backDir : dirs.get(nextPath)){\\n                int backR = nextR + backDir[0];\\n                int backC = nextC + backDir[1];\\n                if(backR == r && backC == c){\\n                    visited[nextR][nextC] = true;\\n                    //return true if there is a path to end from next cell\\n                    if(dfs(grid, nextR, nextC, rows, cols, visited))\\n                        return true;\\n                }\\n            }\\n            \\n        }\\n        // return false if we haven\\'t reached end\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859394,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    int [][][] DIR = new int[][][] {\\n        {{0, -1}, {0, 1}},\\n        {{-1, 0}, {1, 0}},\\n        {{0, -1}, {1, 0}},\\n        {{0, 1}, {1, 0}},\\n        {{0, -1}, {-1, 0}},\\n        {{0, 1}, {-1, 0}}\\n    };\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean [][] visited = new boolean[m][n];\\n        return dfs(grid, m, n, 0, 0, visited);\\n    }\\n    public boolean dfs(int [][] grid, int m, int n, int row, int col, boolean [][] visited) {\\n        if (row == m-1 && col == n-1)\\n            return true;\\n        visited[row][col] = true;\\n        for (int [] nextDirection: DIR[grid[row][col]-1]) { // the next possible move\\n            int nextRow = row + nextDirection[0];\\n            int nextCol = col + nextDirection[1];\\n            if (nextRow<0 || nextCol<0 || nextRow>=m || nextCol>=n || visited[nextRow][nextCol])\\n                continue;\\n            for (int [] backDirection: DIR[grid[nextRow][nextCol]-1]) {  // now check whether we can go back from current position\\n                int backRow = nextRow + backDirection[0];\\n                int backCol = nextCol + backDirection[1];\\n                if (backRow == row && backCol == col)\\n                    if (dfs(grid, m, n, nextRow, nextCol, visited))\\n                        return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int [][][] DIR = new int[][][] {\\n        {{0, -1}, {0, 1}},\\n        {{-1, 0}, {1, 0}},\\n        {{0, -1}, {1, 0}},\\n        {{0, 1}, {1, 0}},\\n        {{0, -1}, {-1, 0}},\\n        {{0, 1}, {-1, 0}}\\n    };\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean [][] visited = new boolean[m][n];\\n        return dfs(grid, m, n, 0, 0, visited);\\n    }\\n    public boolean dfs(int [][] grid, int m, int n, int row, int col, boolean [][] visited) {\\n        if (row == m-1 && col == n-1)\\n            return true;\\n        visited[row][col] = true;\\n        for (int [] nextDirection: DIR[grid[row][col]-1]) { // the next possible move\\n            int nextRow = row + nextDirection[0];\\n            int nextCol = col + nextDirection[1];\\n            if (nextRow<0 || nextCol<0 || nextRow>=m || nextCol>=n || visited[nextRow][nextCol])\\n                continue;\\n            for (int [] backDirection: DIR[grid[nextRow][nextCol]-1]) {  // now check whether we can go back from current position\\n                int backRow = nextRow + backDirection[0];\\n                int backCol = nextCol + backDirection[1];\\n                if (backRow == row && backCol == col)\\n                    if (dfs(grid, m, n, nextRow, nextCol, visited))\\n                        return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824184,
                "title": "simple-bfs-works",
                "content": "```\\nclass Solution {\\n    \\n    int[] x = {-1,1,0,0};//up,down,left,right\\n    int[] y = {0,0,-1,1};\\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        boolean[][] v = new boolean[grid.length][grid[0].length];\\n        Queue<State> q = new LinkedList<>();\\n        \\n        q.offer(new State(0,0));\\n        v[0][0] = true;\\n        \\n        while(!q.isEmpty()) {\\n            State s = q.poll();\\n            if(s.r == grid.length-1 && s.c == grid[0].length-1)  return true;\\n          \\n            for(int d=0;d<4;d++) {\\n                if(canMove(v,grid,s.r,s.c,d)) {\\n                    int r = s.r+x[d];\\n                    int c = s.c+y[d];\\n                    q.offer(new State(r,c));\\n                    v[r][c] = true;\\n                }\\n            }\\n                                            \\n        }\\n        return false;\\n    }\\n\\n\\n    boolean canMove(boolean[][] v,int[][] grid,int ri,int ci,int d) {\\n        int r=ri+x[d],c=ci+y[d];\\n        if(r<0||r>=v.length||c<0||c>=v[0].length||v[r][c]) return false;\\n        \\n        int type = grid[ri][ci];\\n        int nextType = grid[r][c];\\n        if(type ==1) {\\n            if (d==3) //right\\n               if(nextType ==1 || nextType==3 || nextType==5 ) return true;\\n           if (d==2) //left\\n               if(nextType ==1 || nextType==4 || nextType==6 ) return true;\\n        } \\n        if (type ==2) {\\n            if (d==1) //down\\n                 if(nextType ==2 || nextType==5 || nextType==6 ) return true;\\n            if (d==0) //up\\n                 if(nextType ==2 || nextType==3 || nextType==4 ) return true;\\n        }\\n        if (type ==3) {\\n            if (d==2) //left\\n                 if(nextType ==1 || nextType==4 || nextType==6 ) return true;\\n            if (d==1) //down\\n                 if(nextType ==2 || nextType==5 || nextType==6 ) return true;\\n        }\\n        if (type ==4) {\\n            if (d==3) //r\\n                 if(nextType ==1 || nextType==3 || nextType==5 ) return true;\\n            if (d==1) //d\\n                 if(nextType ==2 || nextType==5 || nextType==6 ) return true;\\n        }\\n        if (type ==5) {\\n            if (d==0) //u\\n                 if(nextType ==2 || nextType==3 || nextType==4 ) return true;\\n            if (d==2) //l\\n                 if(nextType ==1 || nextType==4 || nextType==6 ) return true;\\n        }\\n        if (type ==6) {\\n            if (d==0) //u\\n                 if(nextType ==2 || nextType==3 || nextType==4 ) return true;\\n            if (d==3) //r\\n                 if(nextType ==1 || nextType==3 || nextType==5 ) return true;\\n        }\\n        return false;\\n    }\\n    \\n    class State {\\n        int r,c;\\n        public State(int r, int c) {\\n            this.r=r;this.c=c;\\n        }\\n    }\\n        \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[] x = {-1,1,0,0};//up,down,left,right\\n    int[] y = {0,0,-1,1};\\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        boolean[][] v = new boolean[grid.length][grid[0].length];\\n        Queue<State> q = new LinkedList<>();\\n        \\n        q.offer(new State(0,0));\\n        v[0][0] = true;\\n        \\n        while(!q.isEmpty()) {\\n            State s = q.poll();\\n            if(s.r == grid.length-1 && s.c == grid[0].length-1)  return true;\\n          \\n            for(int d=0;d<4;d++) {\\n                if(canMove(v,grid,s.r,s.c,d)) {\\n                    int r = s.r+x[d];\\n                    int c = s.c+y[d];\\n                    q.offer(new State(r,c));\\n                    v[r][c] = true;\\n                }\\n            }\\n                                            \\n        }\\n        return false;\\n    }\\n\\n\\n    boolean canMove(boolean[][] v,int[][] grid,int ri,int ci,int d) {\\n        int r=ri+x[d],c=ci+y[d];\\n        if(r<0||r>=v.length||c<0||c>=v[0].length||v[r][c]) return false;\\n        \\n        int type = grid[ri][ci];\\n        int nextType = grid[r][c];\\n        if(type ==1) {\\n            if (d==3) //right\\n               if(nextType ==1 || nextType==3 || nextType==5 ) return true;\\n           if (d==2) //left\\n               if(nextType ==1 || nextType==4 || nextType==6 ) return true;\\n        } \\n        if (type ==2) {\\n            if (d==1) //down\\n                 if(nextType ==2 || nextType==5 || nextType==6 ) return true;\\n            if (d==0) //up\\n                 if(nextType ==2 || nextType==3 || nextType==4 ) return true;\\n        }\\n        if (type ==3) {\\n            if (d==2) //left\\n                 if(nextType ==1 || nextType==4 || nextType==6 ) return true;\\n            if (d==1) //down\\n                 if(nextType ==2 || nextType==5 || nextType==6 ) return true;\\n        }\\n        if (type ==4) {\\n            if (d==3) //r\\n                 if(nextType ==1 || nextType==3 || nextType==5 ) return true;\\n            if (d==1) //d\\n                 if(nextType ==2 || nextType==5 || nextType==6 ) return true;\\n        }\\n        if (type ==5) {\\n            if (d==0) //u\\n                 if(nextType ==2 || nextType==3 || nextType==4 ) return true;\\n            if (d==2) //l\\n                 if(nextType ==1 || nextType==4 || nextType==6 ) return true;\\n        }\\n        if (type ==6) {\\n            if (d==0) //u\\n                 if(nextType ==2 || nextType==3 || nextType==4 ) return true;\\n            if (d==3) //r\\n                 if(nextType ==1 || nextType==3 || nextType==5 ) return true;\\n        }\\n        return false;\\n    }\\n    \\n    class State {\\n        int r,c;\\n        public State(int r, int c) {\\n            this.r=r;this.c=c;\\n        }\\n    }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724748,
                "title": "java-100-runtime-80-memory-usage-bitwise-operations",
                "content": "Runtime: 3 ms\\nMemory: 53.7 MB\\n\\n```\\nclass Solution {\\n    \\n    private static final byte TOP      = 0b0001;\\n    private static final byte RIGHT    = 0b0010;\\n    private static final byte BOTTOM   = 0b0100;\\n    private static final byte LEFT     = 0b1000;\\n    private static final byte[] STREETS = new byte[]{\\n        0, // Unused\\n        LEFT | RIGHT,   // Street 1\\n        TOP | BOTTOM,   // Street 2\\n        BOTTOM | LEFT,  // Street 3\\n        BOTTOM | RIGHT, // Street 4\\n        TOP | LEFT,     // Street 5\\n        TOP | RIGHT,    // Street 6\\n    };\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        \\n\\t\\t// Invalid input\\n        if(grid.length == 0 || grid[0].length == 0){\\n            return false;\\n        }\\n        \\n\\t\\t// Get the first street, remove entry points from the top and left as we do not want to traverse in those directions\\n        int outDirection = STREETS[grid[0][0]] & ~TOP & ~LEFT;\\n\\n        // Attempt to navigate down first, then right second\\n        return navigate(grid, outDirection & BOTTOM) || navigate(grid, outDirection & RIGHT);\\n    }\\n    \\n    public boolean navigate(int[][] grid, int outDirection) {\\n\\n        int width = grid[0].length;\\n        int height = grid.length;\\n        int rowIdx = 0;\\n        int cellIdx = 0;\\n\\n        while(true){\\n\\n            // We got to the bottom right tile, success\\n            if(rowIdx == height-1 && cellIdx == width-1){\\n                return true;\\n            }\\n\\n            int inDirection;\\n\\n            // Determine the direction to navigate out of the current street as well as the how to navigate into the next street\\n            if(outDirection == TOP){\\n                rowIdx--;\\n                inDirection=BOTTOM;\\n            }else if(outDirection == RIGHT){\\n                cellIdx++;\\n                inDirection=LEFT;\\n            }else if(outDirection == BOTTOM){\\n                rowIdx++;\\n                inDirection=TOP;\\n            }else if(outDirection == LEFT){\\n                cellIdx--;\\n                inDirection=RIGHT;\\n            }else{\\n                // Only possible for first tile if it connects top to left\\n                return false;\\n            }\\n\\n            // Prevent out of bounds exceptions\\n            if(rowIdx < 0 || rowIdx >= height || cellIdx < 0 || cellIdx >= width){\\n                return false;\\n            }\\n    \\n\\t        // Prevent circular loops\\n            if(rowIdx == 0 && cellIdx == 0){\\n                return false;\\n            }\\n\\n            // Navigate to the next street\\n            int nextStreet = STREETS[grid[rowIdx][cellIdx]];\\n            \\n            // Determine the out direction for next street by removing the in direction\\n            outDirection = nextStreet & ~inDirection;\\n            \\n            // When we removed the in direction it did not modify the next street, which means it doesn\\'t have an in direciton that matches, abort\\n            if(nextStreet == outDirection){\\n               return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private static final byte TOP      = 0b0001;\\n    private static final byte RIGHT    = 0b0010;\\n    private static final byte BOTTOM   = 0b0100;\\n    private static final byte LEFT     = 0b1000;\\n    private static final byte[] STREETS = new byte[]{\\n        0, // Unused\\n        LEFT | RIGHT,   // Street 1\\n        TOP | BOTTOM,   // Street 2\\n        BOTTOM | LEFT,  // Street 3\\n        BOTTOM | RIGHT, // Street 4\\n        TOP | LEFT,     // Street 5\\n        TOP | RIGHT,    // Street 6\\n    };\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        \\n\\t\\t// Invalid input\\n        if(grid.length == 0 || grid[0].length == 0){\\n            return false;\\n        }\\n        \\n\\t\\t// Get the first street, remove entry points from the top and left as we do not want to traverse in those directions\\n        int outDirection = STREETS[grid[0][0]] & ~TOP & ~LEFT;\\n\\n        // Attempt to navigate down first, then right second\\n        return navigate(grid, outDirection & BOTTOM) || navigate(grid, outDirection & RIGHT);\\n    }\\n    \\n    public boolean navigate(int[][] grid, int outDirection) {\\n\\n        int width = grid[0].length;\\n        int height = grid.length;\\n        int rowIdx = 0;\\n        int cellIdx = 0;\\n\\n        while(true){\\n\\n            // We got to the bottom right tile, success\\n            if(rowIdx == height-1 && cellIdx == width-1){\\n                return true;\\n            }\\n\\n            int inDirection;\\n\\n            // Determine the direction to navigate out of the current street as well as the how to navigate into the next street\\n            if(outDirection == TOP){\\n                rowIdx--;\\n                inDirection=BOTTOM;\\n            }else if(outDirection == RIGHT){\\n                cellIdx++;\\n                inDirection=LEFT;\\n            }else if(outDirection == BOTTOM){\\n                rowIdx++;\\n                inDirection=TOP;\\n            }else if(outDirection == LEFT){\\n                cellIdx--;\\n                inDirection=RIGHT;\\n            }else{\\n                // Only possible for first tile if it connects top to left\\n                return false;\\n            }\\n\\n            // Prevent out of bounds exceptions\\n            if(rowIdx < 0 || rowIdx >= height || cellIdx < 0 || cellIdx >= width){\\n                return false;\\n            }\\n    \\n\\t        // Prevent circular loops\\n            if(rowIdx == 0 && cellIdx == 0){\\n                return false;\\n            }\\n\\n            // Navigate to the next street\\n            int nextStreet = STREETS[grid[rowIdx][cellIdx]];\\n            \\n            // Determine the out direction for next street by removing the in direction\\n            outDirection = nextStreet & ~inDirection;\\n            \\n            // When we removed the in direction it did not modify the next street, which means it doesn\\'t have an in direciton that matches, abort\\n            if(nextStreet == outDirection){\\n               return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584410,
                "title": "python-clean-bfs-solution",
                "content": "I use a map to map the #path to the valid directions, and add valid nodes to the queue, the two nodes must be able to reach each other in order to be connected\\n```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        queue = [(0, 0)]\\n        height, width = len(grid), len(grid[0])\\n        map = {1: [(0, -1), (0, 1)], 2: [(1, 0), (-1, 0)], 3: [(0, -1), (1, 0)], 4: [(0, 1), (1, 0)], 5: [(-1, 0), (0, -1)], 6: [(-1, 0), (0, 1)] }\\n        \\n        while queue:\\n            i, j = queue.pop(0)\\n            path = grid[i][j]\\n            if path == 0:\\n                continue\\n            if i == height - 1 and j == width - 1:\\n                return True\\n\\n            for di, dj in map[path]:\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < height and 0 <= nj < width and grid[ni][nj]:\\n                    nextpath = grid[ni][nj]\\n                    if (-di, -dj) in map[nextpath]:\\n                        queue.append((ni, nj))\\n                \\n            grid[i][j] = 0\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        queue = [(0, 0)]\\n        height, width = len(grid), len(grid[0])\\n        map = {1: [(0, -1), (0, 1)], 2: [(1, 0), (-1, 0)], 3: [(0, -1), (1, 0)], 4: [(0, 1), (1, 0)], 5: [(-1, 0), (0, -1)], 6: [(-1, 0), (0, 1)] }\\n        \\n        while queue:\\n            i, j = queue.pop(0)\\n            path = grid[i][j]\\n            if path == 0:\\n                continue\\n            if i == height - 1 and j == width - 1:\\n                return True\\n\\n            for di, dj in map[path]:\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < height and 0 <= nj < width and grid[ni][nj]:\\n                    nextpath = grid[ni][nj]\\n                    if (-di, -dj) in map[nextpath]:\\n                        queue.append((ni, nj))\\n                \\n            grid[i][j] = 0\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577528,
                "title": "c",
                "content": "```\\n\\t\\tpublic bool HasValidPath(int[][] grid) {\\n            int[][][] move = new int[7][][];\\n            for (int i = 0; i < 7; i++) move[i] = new int[4][];\\n            move[1][0] = new int[] { 0, 1, 0 };\\n            move[1][2] = new int[] { 0, -1, 2 };\\n            move[2][1] = new int[] { 1, 0, 1 };\\n            move[2][3] = new int[] { -1, 0, 3 };\\n            move[3][0] = new int[] { 1, 0, 1 };\\n            move[3][3] = new int[] { 0, -1, 2 };\\n            move[4][2] = new int[] { 1, 0, 1 };\\n            move[4][3] = new int[] { 0, 1, 0 };\\n            move[5][0] = new int[] { -1, 0, 3 };\\n            move[5][1] = new int[] { 0, -1, 2 };\\n            move[6][1] = new int[] { 0, 1, 0 };\\n            move[6][2] = new int[] { -1, 0, 3 };\\n\\n            int[][] start = new int[][] {\\n                new int[] {  },\\n                new int[] { 0 },\\n                new int[] { 1 },\\n                new int[] { 0 },\\n                new int[] { 2, 3 },\\n                new int[] { 0 },\\n                new int[] { 1 }\\n            };\\n            \\n            int n = grid.Length, m = grid[0].Length;\\n            foreach(int dir in start[grid[0][0]]) {\\n                int x = 0, y = 0;\\n                int d = dir;\\n                bool[][] seen = new bool[n][];\\n                for (int i = 0; i < n; i++) seen[i] = new bool[m];\\n                while (true) {\\n                    if (seen[x][y]) break;\\n                    seen[x][y] = true;\\n                    if (move[grid[x][y]][d] == null) break;\\n                    if (x == n - 1 && y == m - 1) return true;\\n                    var mv = move[grid[x][y]][d];\\n                    x += mv[0];\\n                    y += mv[1];\\n                    d = mv[2];\\n                    if (x < 0 || x >= n || y < 0 || y >= m) break;\\n                }\\n            }\\n            return false;\\n        }\\n```\\nWe have four directions:\\n0 - from left\\n1 - from up\\n2 - from right\\n3 - from down\\nand change in coordinates which depends from direction we came and grid cell type.\\nMove saves the data for each possible direction and cell type, e.g.\\n```move[4][2] = new int[] { 1, 0, 1 };``` means that if we came from direction 2 to cell with type 4 x coordinates will increase to 1 and direction will change to 1.\\nThe array start contains inistial directions for each cell type, note that we have two possible directions for cells with type 4. Additional directions for types 3, 5 and 6 can be ommited.",
                "solutionTags": [],
                "code": "```\\n\\t\\tpublic bool HasValidPath(int[][] grid) {\\n            int[][][] move = new int[7][][];\\n            for (int i = 0; i < 7; i++) move[i] = new int[4][];\\n            move[1][0] = new int[] { 0, 1, 0 };\\n            move[1][2] = new int[] { 0, -1, 2 };\\n            move[2][1] = new int[] { 1, 0, 1 };\\n            move[2][3] = new int[] { -1, 0, 3 };\\n            move[3][0] = new int[] { 1, 0, 1 };\\n            move[3][3] = new int[] { 0, -1, 2 };\\n            move[4][2] = new int[] { 1, 0, 1 };\\n            move[4][3] = new int[] { 0, 1, 0 };\\n            move[5][0] = new int[] { -1, 0, 3 };\\n            move[5][1] = new int[] { 0, -1, 2 };\\n            move[6][1] = new int[] { 0, 1, 0 };\\n            move[6][2] = new int[] { -1, 0, 3 };\\n\\n            int[][] start = new int[][] {\\n                new int[] {  },\\n                new int[] { 0 },\\n                new int[] { 1 },\\n                new int[] { 0 },\\n                new int[] { 2, 3 },\\n                new int[] { 0 },\\n                new int[] { 1 }\\n            };\\n            \\n            int n = grid.Length, m = grid[0].Length;\\n            foreach(int dir in start[grid[0][0]]) {\\n                int x = 0, y = 0;\\n                int d = dir;\\n                bool[][] seen = new bool[n][];\\n                for (int i = 0; i < n; i++) seen[i] = new bool[m];\\n                while (true) {\\n                    if (seen[x][y]) break;\\n                    seen[x][y] = true;\\n                    if (move[grid[x][y]][d] == null) break;\\n                    if (x == n - 1 && y == m - 1) return true;\\n                    var mv = move[grid[x][y]][d];\\n                    x += mv[0];\\n                    y += mv[1];\\n                    d = mv[2];\\n                    if (x < 0 || x >= n || y < 0 || y >= m) break;\\n                }\\n            }\\n            return false;\\n        }\\n```\n```move[4][2] = new int[] { 1, 0, 1 };```",
                "codeTag": "Unknown"
            },
            {
                "id": 573445,
                "title": "clear-python-solution-with-comments-backtracking",
                "content": "This is a typical backtracking problem. However, the relationships are a bit complex, so the code might turn out to have some repeating parts. \\nTo write a dry code, we can use some maps to handle the relationships.\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        if len(grid) == 0:\\n            return False\\n        \\n        # Map of direction to the possible street blocks  \\n        self.dirToS = {   \\n            \\'r\\': [1,3,5],\\n            \\'u\\': [2,3,4],\\n            \\'l\\': [1,4,6],\\n            \\'d\\': [2,5,6]\\n        }\\n        # Map of street block to the directions it leads to \\n        self.sToDir = {\\n            1 : [\\'r\\', \\'l\\'],\\n            2 : [\\'u\\', \\'d\\'],\\n            3 : [\\'l\\', \\'d\\'],\\n            4 : [\\'r\\', \\'d\\'],\\n            5 : [\\'l\\', \\'u\\'],\\n            6 : [\\'r\\', \\'u\\']  \\n        }\\n        # Map of direction to the coordinate shifts\\n        self.dirToXy = {\\n            \\'r\\': ( 0,  1),\\n            \\'u\\': (-1,  0),\\n            \\'l\\': ( 0, -1),\\n            \\'d\\': ( 1,  0)\\n        }\\n        \\n        visited = set([])   #must use set (TLE if using list)\\n        return self.helper(grid, 0, 0, visited)\\n    \\n    def helper(self, grid, i, j, visited):\\n        m, n = len(grid), len(grid[0])\\n        \\n        if (i, j) == (m-1, n-1): #arrived at the destination \\n            return True\\n        \\n        cur = grid[i][j]\\n        nextDirs = self.sToDir[cur] \\n\\t\\t\\n        for nextDir in nextDirs:  #nextDir: \\'r\\', \\'u\\', \\'l\\', \\'d\\'\\n            ni = i + self.dirToXy[nextDir][0] #next i\\n            nj = j + self.dirToXy[nextDir][1] #next j \\n            \\n            if ni < 0 or ni >= m or nj < 0 or nj >= n: #out of the boundary \\n                continue\\n            if grid[ni][nj] not in self.dirToS[nextDir]: #street blocks not matching \\n                continue\\n            if (ni, nj) in visited: #visited \\n                continue\\n                \\n            visited.add((ni, nj))\\n            if self.helper(grid, ni, nj, visited): \\n                return True\\n            visited.remove((ni, nj)) #backtracking \\n            \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        if len(grid) == 0:\\n            return False\\n        \\n        # Map of direction to the possible street blocks  \\n        self.dirToS = {   \\n            \\'r\\': [1,3,5],\\n            \\'u\\': [2,3,4],\\n            \\'l\\': [1,4,6],\\n            \\'d\\': [2,5,6]\\n        }\\n        # Map of street block to the directions it leads to \\n        self.sToDir = {\\n            1 : [\\'r\\', \\'l\\'],\\n            2 : [\\'u\\', \\'d\\'],\\n            3 : [\\'l\\', \\'d\\'],\\n            4 : [\\'r\\', \\'d\\'],\\n            5 : [\\'l\\', \\'u\\'],\\n            6 : [\\'r\\', \\'u\\']  \\n        }\\n        # Map of direction to the coordinate shifts\\n        self.dirToXy = {\\n            \\'r\\': ( 0,  1),\\n            \\'u\\': (-1,  0),\\n            \\'l\\': ( 0, -1),\\n            \\'d\\': ( 1,  0)\\n        }\\n        \\n        visited = set([])   #must use set (TLE if using list)\\n        return self.helper(grid, 0, 0, visited)\\n    \\n    def helper(self, grid, i, j, visited):\\n        m, n = len(grid), len(grid[0])\\n        \\n        if (i, j) == (m-1, n-1): #arrived at the destination \\n            return True\\n        \\n        cur = grid[i][j]\\n        nextDirs = self.sToDir[cur] \\n\\t\\t\\n        for nextDir in nextDirs:  #nextDir: \\'r\\', \\'u\\', \\'l\\', \\'d\\'\\n            ni = i + self.dirToXy[nextDir][0] #next i\\n            nj = j + self.dirToXy[nextDir][1] #next j \\n            \\n            if ni < 0 or ni >= m or nj < 0 or nj >= n: #out of the boundary \\n                continue\\n            if grid[ni][nj] not in self.dirToS[nextDir]: #street blocks not matching \\n                continue\\n            if (ni, nj) in visited: #visited \\n                continue\\n                \\n            visited.add((ni, nj))\\n            if self.helper(grid, ni, nj, visited): \\n                return True\\n            visited.remove((ni, nj)) #backtracking \\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557424,
                "title": "72ms-long-but-very-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/ducmanh/image_1585626349.png)\\n\\n```\\nclass Solution {\\n    int r, c;\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n    \\n        r = grid.size();\\n        c = grid[0].size();\\n        return go(0, 0, grid);\\n    }\\n    bool ok(int y, int x) {\\n        if (y >= r || x >= c || y < 0 || x < 0) {\\n            return 0;\\n        }        \\n        return 1;\\n    }\\n    bool go(int y, int x, vector<vector<int>>& grid) {\\n        if (y == r-1 && x == c-1) {\\n            return 1;\\n        }\\n        if (grid[y][x] == 0) {\\n            return 0;\\n        }\\n        int tmp = grid[y][x];\\n        grid[y][x] = 0;\\n        if (tmp == 1) {\\n            if ((ok(y, x+1) && (grid[y][x+1] == 1 || grid[y][x+1] == 3 || grid[y][x+1] == 5)) && go(y, x+1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y, x-1) && (grid[y][x-1] == 1 || grid[y][x-1] == 4 || grid[y][x-1] == 6)) && go(y, x-1, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 2) {\\n            if ((ok(y+1, x) && (grid[y+1][x] == 2 || grid[y+1][x] == 5 || grid[y+1][x] == 6)) && go(y+1, x, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y-1, x) && (grid[y-1][x] == 2 || grid[y-1][x] == 3 || grid[y-1][x] == 4)) && go(y-1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 3) {\\n            if ((ok(y, x-1) && (grid[y][x-1] == 1 || grid[y][x-1] == 4 || grid[y][x-1] == 6)) && go(y, x-1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y+1, x) && (grid[y+1][x] == 2 || grid[y+1][x] == 5 || grid[y+1][x] == 6)) && go(y+1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 4) {\\n            if ((ok(y+1, x) && (grid[y+1][x] == 2 || grid[y+1][x] == 5 || grid[y+1][x] == 6)) && go(y+1, x, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y, x+1) && (grid[y][x+1] == 1 || grid[y][x+1] == 3 || grid[y][x+1] == 5)) && go(y, x+1, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 5) {\\n            if ((ok(y, x-1) && (grid[y][x-1] == 1 || grid[y][x-1] == 4 || grid[y][x-1] == 6)) && go(y, x-1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y-1, x) && (grid[y-1][x] == 2 || grid[y-1][x] == 3 || grid[y-1][x] == 4)) && go(y-1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        else {\\n            if ((ok(y, x+1) && (grid[y][x+1] == 1 || grid[y][x+1] == 3 || grid[y][x+1] == 5)) && go(y, x+1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y-1, x) && (grid[y-1][x] == 2 || grid[y-1][x] == 3 || grid[y-1][x] == 4)) && go(y-1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int r, c;\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n    \\n        r = grid.size();\\n        c = grid[0].size();\\n        return go(0, 0, grid);\\n    }\\n    bool ok(int y, int x) {\\n        if (y >= r || x >= c || y < 0 || x < 0) {\\n            return 0;\\n        }        \\n        return 1;\\n    }\\n    bool go(int y, int x, vector<vector<int>>& grid) {\\n        if (y == r-1 && x == c-1) {\\n            return 1;\\n        }\\n        if (grid[y][x] == 0) {\\n            return 0;\\n        }\\n        int tmp = grid[y][x];\\n        grid[y][x] = 0;\\n        if (tmp == 1) {\\n            if ((ok(y, x+1) && (grid[y][x+1] == 1 || grid[y][x+1] == 3 || grid[y][x+1] == 5)) && go(y, x+1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y, x-1) && (grid[y][x-1] == 1 || grid[y][x-1] == 4 || grid[y][x-1] == 6)) && go(y, x-1, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 2) {\\n            if ((ok(y+1, x) && (grid[y+1][x] == 2 || grid[y+1][x] == 5 || grid[y+1][x] == 6)) && go(y+1, x, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y-1, x) && (grid[y-1][x] == 2 || grid[y-1][x] == 3 || grid[y-1][x] == 4)) && go(y-1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 3) {\\n            if ((ok(y, x-1) && (grid[y][x-1] == 1 || grid[y][x-1] == 4 || grid[y][x-1] == 6)) && go(y, x-1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y+1, x) && (grid[y+1][x] == 2 || grid[y+1][x] == 5 || grid[y+1][x] == 6)) && go(y+1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 4) {\\n            if ((ok(y+1, x) && (grid[y+1][x] == 2 || grid[y+1][x] == 5 || grid[y+1][x] == 6)) && go(y+1, x, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y, x+1) && (grid[y][x+1] == 1 || grid[y][x+1] == 3 || grid[y][x+1] == 5)) && go(y, x+1, grid)) {\\n                return 1;\\n            }\\n        }\\n        else if (tmp == 5) {\\n            if ((ok(y, x-1) && (grid[y][x-1] == 1 || grid[y][x-1] == 4 || grid[y][x-1] == 6)) && go(y, x-1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y-1, x) && (grid[y-1][x] == 2 || grid[y-1][x] == 3 || grid[y-1][x] == 4)) && go(y-1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        else {\\n            if ((ok(y, x+1) && (grid[y][x+1] == 1 || grid[y][x+1] == 3 || grid[y][x+1] == 5)) && go(y, x+1, grid)) {\\n                return 1;\\n            }\\n            if ((ok(y-1, x) && (grid[y-1][x] == 2 || grid[y-1][x] == 3 || grid[y-1][x] == 4)) && go(y-1, x, grid)) {\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 548459,
                "title": "java-intuitive-single-pass-no-dfs-bfs-with-comments",
                "content": "```\\nclass Solution {\\n    int[][][] dirs = {\\n                {},\\n                {{0, -1}, {0, 1}},\\n                {{-1, 0}, {1, 0}},\\n                {{0, -1}, {1, 0}},\\n                {{0, 1}, {1, 0}},\\n                {{0, -1}, {-1, 0}},\\n                {{-1, 0}, {0, 1}}\\n    };\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int i = 0, j = 0; \\n        if (grid[i][j] == 5)\\n            return false;\\n        int[] output = dirs[grid[i][j]][1];\\n        int m = grid.length, n = grid[0].length;\\n        while (!(i == m - 1 && j == n - 1)) { \\n            int[] input = new int[2];\\n            i += output[0];\\n            j += output[1];\\n            input[0] = output[0] * -1; //negative output becomes new input\\n            input[1] = output[1] * -1;\\n            if (isValidInput(i, j, input, grid) == false) return false;\\n            output = findOutput(input, grid[i][j]);\\n        }\\n        return true;\\n    }\\n\\n    private int[] findOutput(int[] input, int street) { //output is the opposite side of the street\\'s input\\n        if (dirs[street][0][0] == input[0] && dirs[street][0][1] == input[1]) return dirs[street][1];\\n        return dirs[street][0];\\n    }\\n\\n    private boolean isValidInput(int i, int j, int[] input, int[][] grid) { //checks if out of bounds and if ends of street pieces meet\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) return false;\\n        int[][] twoends = dirs[grid[i][j]];\\n        for (int[] end : twoends) {\\n            if (end[0] == input[0] && end[1] == input[1]) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][][] dirs = {\\n                {},\\n                {{0, -1}, {0, 1}},\\n                {{-1, 0}, {1, 0}},\\n                {{0, -1}, {1, 0}},\\n                {{0, 1}, {1, 0}},\\n                {{0, -1}, {-1, 0}},\\n                {{-1, 0}, {0, 1}}\\n    };\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int i = 0, j = 0; \\n        if (grid[i][j] == 5)\\n            return false;\\n        int[] output = dirs[grid[i][j]][1];\\n        int m = grid.length, n = grid[0].length;\\n        while (!(i == m - 1 && j == n - 1)) { \\n            int[] input = new int[2];\\n            i += output[0];\\n            j += output[1];\\n            input[0] = output[0] * -1; //negative output becomes new input\\n            input[1] = output[1] * -1;\\n            if (isValidInput(i, j, input, grid) == false) return false;\\n            output = findOutput(input, grid[i][j]);\\n        }\\n        return true;\\n    }\\n\\n    private int[] findOutput(int[] input, int street) { //output is the opposite side of the street\\'s input\\n        if (dirs[street][0][0] == input[0] && dirs[street][0][1] == input[1]) return dirs[street][1];\\n        return dirs[street][0];\\n    }\\n\\n    private boolean isValidInput(int i, int j, int[] input, int[][] grid) { //checks if out of bounds and if ends of street pieces meet\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) return false;\\n        int[][] twoends = dirs[grid[i][j]];\\n        for (int[] end : twoends) {\\n            if (end[0] == input[0] && end[1] == input[1]) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548457,
                "title": "dew-it-super-concise-java-super-unreadable-code",
                "content": "**THE BASIC IDEA**\\n* We may enter a cell from any of the four walls - top, right, bottom, left (encoded as 1, 2, 3 and 4 in the code)\\n* If the street in that cell allows, the end result of passing through the cell is a new direction to enter one of the adjacent cells\\n* Since cells always have only one entry point and one exit point, there is (almost) no question of hit and trial - if you are at a cell and you entered a certain way, the next step is deterministic\\n* We say \"almost\" in the above point because the very first cell (0,0) could have a street of type \\'4\\' - in which case, we need to try out both paths - rightward and downward\\n\\nThe idea is pretty simple. However if you can understand this code, you deserve a medal.\\n\\n**THE CODE**\\n```\\nclass Solution {\\n    int m, n;\\n    int[][] grid,\\n        dir = new int[][] { {0,0},{1,0},{0,-1},{-1,0},{0,1} },\\n        startMatrix = new int[][] { {0,0,0},{4,0,1},{1,1,0},{1,1,0},{4,0,1},{-1,0,0},{4,0,1} },\\n        decisionMatrix = new int[][] { {-1,-1,-1,-1,-1},{-1,-1,2,-1,4},{-1,1,-1,3,-1},{-1,-1,-1,2,1},{-1,-1,1,4,-1},{-1,2,-1,-1,3},{-1,4,3,-1,-1} };\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        this.grid = grid;\\n        m = grid.length;\\n        n = grid[0].length;\\n        if(m*n == 1) return true;\\n        int start = grid[0][0], next = startMatrix[start][0], i = startMatrix[start][1], j = startMatrix[start][2];\\n        if(dewIt(next, i, j)) return true;\\n        return (start == 4 && dewIt(1, 1, 0));\\n    }\\n    \\n    private boolean dewIt(int enter, int i, int j) {\\n        boolean[] seen = new boolean[n*m];\\n        while(enter != -1) {\\n            int k = i*n+j;\\n            if(!(i > -1 && j > -1 && i < m && j < n) || seen[k]) break;\\n            else seen[k] = true;\\n            enter =  decisionMatrix[grid[i][j]][enter];\\n            if(enter == -1) break;\\n            else if(i == m-1 && j == n-1) return true;\\n            i += dir[enter][0];\\n            j += dir[enter][1];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    int[][] grid,\\n        dir = new int[][] { {0,0},{1,0},{0,-1},{-1,0},{0,1} },\\n        startMatrix = new int[][] { {0,0,0},{4,0,1},{1,1,0},{1,1,0},{4,0,1},{-1,0,0},{4,0,1} },\\n        decisionMatrix = new int[][] { {-1,-1,-1,-1,-1},{-1,-1,2,-1,4},{-1,1,-1,3,-1},{-1,-1,-1,2,1},{-1,-1,1,4,-1},{-1,2,-1,-1,3},{-1,4,3,-1,-1} };\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        this.grid = grid;\\n        m = grid.length;\\n        n = grid[0].length;\\n        if(m*n == 1) return true;\\n        int start = grid[0][0], next = startMatrix[start][0], i = startMatrix[start][1], j = startMatrix[start][2];\\n        if(dewIt(next, i, j)) return true;\\n        return (start == 4 && dewIt(1, 1, 0));\\n    }\\n    \\n    private boolean dewIt(int enter, int i, int j) {\\n        boolean[] seen = new boolean[n*m];\\n        while(enter != -1) {\\n            int k = i*n+j;\\n            if(!(i > -1 && j > -1 && i < m && j < n) || seen[k]) break;\\n            else seen[k] = true;\\n            enter =  decisionMatrix[grid[i][j]][enter];\\n            if(enter == -1) break;\\n            else if(i == m-1 && j == n-1) return true;\\n            i += dir[enter][0];\\n            j += dir[enter][1];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548414,
                "title": "c-no-bfs-dfs-required-single-pass-100",
                "content": "Proof\\n-\\n![image](https://assets.leetcode.com/users/laprade/image_1584921704.png)\\n\\nReasoning\\n-\\nWe don\\'t actually need to handle branching paths. There\\'s always only one direction the road can lead from our current location. The only exception is if we start on Road Type 4, in which case we can go Right or Down, so we use a boolean to retry exactly one time in that case.\\n\\nThe algorithm is straightforward. Given our current direction and the type of tile in front of us, we know what our new direction will be.\\n\\nAlgorithm\\n-\\n```\\npublic class Solution {\\n    private static readonly int[] starters = {-1, 1, 3, 3, 1, -1, 1};\\n    private static readonly int[,] transformer = {{-1,-1,-1,-1},{0,1,-1,-1},{-1,-1,2,3},{-1,3,0,-1},{3,-1,1,-1},{-1,2,-1,0},{2,-1,-1,1}};\\n    public bool HasValidPath(int[][] grid, bool secondTry = false) {\\n        var row = 0;\\n        var col = 0;\\n        var rowTarget = grid.Length - 1;\\n        var colTarget = grid[0].Length - 1;\\n        var streetType = grid[row][col];\\n        var finalTry = streetType != 4 || secondTry;\\n        var direction = secondTry ? 3 : starters[streetType];\\n        while (direction != -1) {\\n            if (row == rowTarget && col == colTarget) return true;\\n            bool done = true;\\n            switch (direction) {\\n                case 0: // Left\\n                    done = col-- == 0;\\n                    break;\\n                case 1: // Right\\n                    done = col++ == colTarget;\\n                    break;\\n                case 2: // Up\\n                    done = row-- == 0;\\n                    break;\\n                case 3: // Down\\n                    done = row++ == rowTarget;\\n                    break;\\n            }\\n            if (done) break;\\n            streetType = grid[row][col];\\n            direction = transformer[streetType,direction];\\n        }\\n        return finalTry ? false : HasValidPath(grid, true);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private static readonly int[] starters = {-1, 1, 3, 3, 1, -1, 1};\\n    private static readonly int[,] transformer = {{-1,-1,-1,-1},{0,1,-1,-1},{-1,-1,2,3},{-1,3,0,-1},{3,-1,1,-1},{-1,2,-1,0},{2,-1,-1,1}};\\n    public bool HasValidPath(int[][] grid, bool secondTry = false) {\\n        var row = 0;\\n        var col = 0;\\n        var rowTarget = grid.Length - 1;\\n        var colTarget = grid[0].Length - 1;\\n        var streetType = grid[row][col];\\n        var finalTry = streetType != 4 || secondTry;\\n        var direction = secondTry ? 3 : starters[streetType];\\n        while (direction != -1) {\\n            if (row == rowTarget && col == colTarget) return true;\\n            bool done = true;\\n            switch (direction) {\\n                case 0: // Left\\n                    done = col-- == 0;\\n                    break;\\n                case 1: // Right\\n                    done = col++ == colTarget;\\n                    break;\\n                case 2: // Up\\n                    done = row-- == 0;\\n                    break;\\n                case 3: // Down\\n                    done = row++ == rowTarget;\\n                    break;\\n            }\\n            if (done) break;\\n            streetType = grid[row][col];\\n            direction = transformer[streetType,direction];\\n        }\\n        return finalTry ? false : HasValidPath(grid, true);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547961,
                "title": "9ms-time-100-memory",
                "content": "```\\nclass Solution {\\n    static int d[][]; // to traverse 4 directions\\n    static int dir[][]; // to know if there is valid route to any of 4 directions from current cell\\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        d = new int[][]{{0,-1},{-1,0},{0,1},{1,0}}; \\n        dir =   new int[][]{\\n                    {1,0,1,0},\\n                    {0,1,0,1},\\n                    {1,0,0,1},\\n                    {0,0,1,1},\\n                    {1,1,0,0},\\n                    {0,1,1,0}\\n                };\\n        return helper(grid,0,0);\\n    }\\n    public boolean helper(int grid[][],int x,int y){\\n        if(x==grid.length-1 && y==grid[0].length-1)\\n            return true;\\n        \\n        int curr = grid[x][y];\\n        grid[x][y] = -1; // to avoid loops\\n        for(int i=0;i<4;i++){\\n            int dx = x + d[i][0]; // new row co-ordinate\\n            int dy = y + d[i][1]; // new col co-ordinate\\n            if(dx>=0 && dx<grid.length && dy>=0 && dy<grid[0].length && grid[dx][dy]!=-1){\\n\\t\\t\\t\\t// if there is a route from curr cell to next cell\\n                if(dir[curr-1][i] == dir[grid[dx][dy]-1][(i+2)%4] && dir[curr-1][i] == 1){\\n                    if(helper(grid,dx,dy))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nany further optimizations are helpful, Thanks!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int d[][]; // to traverse 4 directions\\n    static int dir[][]; // to know if there is valid route to any of 4 directions from current cell\\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        d = new int[][]{{0,-1},{-1,0},{0,1},{1,0}}; \\n        dir =   new int[][]{\\n                    {1,0,1,0},\\n                    {0,1,0,1},\\n                    {1,0,0,1},\\n                    {0,0,1,1},\\n                    {1,1,0,0},\\n                    {0,1,1,0}\\n                };\\n        return helper(grid,0,0);\\n    }\\n    public boolean helper(int grid[][],int x,int y){\\n        if(x==grid.length-1 && y==grid[0].length-1)\\n            return true;\\n        \\n        int curr = grid[x][y];\\n        grid[x][y] = -1; // to avoid loops\\n        for(int i=0;i<4;i++){\\n            int dx = x + d[i][0]; // new row co-ordinate\\n            int dy = y + d[i][1]; // new col co-ordinate\\n            if(dx>=0 && dx<grid.length && dy>=0 && dy<grid[0].length && grid[dx][dy]!=-1){\\n\\t\\t\\t\\t// if there is a route from curr cell to next cell\\n                if(dir[curr-1][i] == dir[grid[dx][dy]-1][(i+2)%4] && dir[curr-1][i] == 1){\\n                    if(helper(grid,dx,dy))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547822,
                "title": "python-3-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef hasValidPath(self, grid: List[List[int]]) -> bool:\\n\\t\\t\\tr = len(grid)\\n\\t\\t\\tc = len(grid[0])\\n\\t\\t\\tmap = {(1, 0):[(2, 3, 4), (2, 5, 6)], (-1, 0):[(2, 5, 6), (2, 3, 4)], (0, 1):[(1, 4, 6), (1, 3, 5)], (0, -1):[(1, 3, 5), (1, 4, 6)]}\\n\\t\\t\\tstack = [(0, 0)]\\n\\t\\t\\tseen = set()\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tx, y = stack.pop()\\n\\t\\t\\t\\tif x == r - 1 and y == c - 1:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tfor k, v in map.items():\\n\\t\\t\\t\\t\\ta = x + k[0]\\n\\t\\t\\t\\t\\tb = y + k[1]\\n\\t\\t\\t\\t\\tif 0 <= a < r and 0 <= b < c and grid[x][y] in v[0] and grid[a][b] in v[1] and (a, b) not in seen:\\n\\t\\t\\t\\t\\t\\tstack.append((a, b))\\n\\t\\t\\t\\t\\t\\tseen.add((a, b))\\n\\t\\t\\treturn False",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef hasValidPath(self, grid: List[List[int]]) -> bool:\\n\\t\\t\\tr = len(grid)\\n\\t\\t\\tc = len(grid[0])\\n\\t\\t\\tmap = {(1, 0):[(2, 3, 4), (2, 5, 6)], (-1, 0):[(2, 5, 6), (2, 3, 4)], (0, 1):[(1, 4, 6), (1, 3, 5)], (0, -1):[(1, 3, 5), (1, 4, 6)]}",
                "codeTag": "Java"
            },
            {
                "id": 547602,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    int[][] grid;\\n    public boolean hasValidPath(int[][] grid) {\\n        Set<String> visited = new HashSet<String>();\\n        this.grid = grid;\\n        if(grid.length == 0) return true;\\n        Queue<int[]> q = new LinkedList<int[]>();\\n        q.add(new int[] {0, 0});\\n        while(!q.isEmpty()) {\\n            int[] curr = q.remove();\\n            int i = curr[0];\\n            int j = curr[1];\\n            if(i == grid.length  - 1 && j == grid[0].length - 1) return true;\\n            \\n            String key = i + \",\" + j;\\n            \\n            if(visited.contains(key)) continue;\\n            visited.add(key);\\n            \\n            int currSt = grid[i][j];\\n            // up\\n            if(i - 1 >= 0 && !visited.contains((i - 1) + \",\" + j) && up(i, j)) q.add(new int[]{i - 1, j});\\n            // down\\n            if(i + 1 < grid.length && !visited.contains((i + 1) + \",\" + j) && down(i, j)) q.add(new int[]{i + 1, j});\\n            // left\\n            if(j - 1 >= 0 && !visited.contains(i + \",\" + (j - 1)) && left(i, j)) q.add(new int[]{i, j - 1});\\n            //right\\n            if(j + 1 < grid[0].length && !visited.contains(i + \",\" + (j + 1)) && right(i, j)) q.add(new int[]{i, j + 1});\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean up(int i, int j) {\\n        int upW = grid[i - 1][j] ;\\n        if(grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6) return upW == 2 || upW == 3 || upW == 4;\\n        return false;\\n    }\\n    \\n    public boolean down(int i, int j) {\\n        int upW = grid[i + 1][j] ;\\n        if(grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4) return upW == 2 || upW == 5 || upW == 6;\\n        return false;\\n    }\\n    \\n    public boolean right(int i, int j) {\\n        int upW = grid[i][j + 1] ;\\n        if(grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6) return upW == 1 || upW == 3 || upW == 5;\\n        return false;\\n    }\\n    \\n    public boolean left(int i, int j) {\\n        int upW = grid[i][j - 1] ;\\n        if(grid[i][j] == 1 || grid[i][j] == 3 || grid[i][j] == 5) return upW == 1 || upW == 4 || upW == 6;    \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] grid;\\n    public boolean hasValidPath(int[][] grid) {\\n        Set<String> visited = new HashSet<String>();\\n        this.grid = grid;\\n        if(grid.length == 0) return true;\\n        Queue<int[]> q = new LinkedList<int[]>();\\n        q.add(new int[] {0, 0});\\n        while(!q.isEmpty()) {\\n            int[] curr = q.remove();\\n            int i = curr[0];\\n            int j = curr[1];\\n            if(i == grid.length  - 1 && j == grid[0].length - 1) return true;\\n            \\n            String key = i + \",\" + j;\\n            \\n            if(visited.contains(key)) continue;\\n            visited.add(key);\\n            \\n            int currSt = grid[i][j];\\n            // up\\n            if(i - 1 >= 0 && !visited.contains((i - 1) + \",\" + j) && up(i, j)) q.add(new int[]{i - 1, j});\\n            // down\\n            if(i + 1 < grid.length && !visited.contains((i + 1) + \",\" + j) && down(i, j)) q.add(new int[]{i + 1, j});\\n            // left\\n            if(j - 1 >= 0 && !visited.contains(i + \",\" + (j - 1)) && left(i, j)) q.add(new int[]{i, j - 1});\\n            //right\\n            if(j + 1 < grid[0].length && !visited.contains(i + \",\" + (j + 1)) && right(i, j)) q.add(new int[]{i, j + 1});\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean up(int i, int j) {\\n        int upW = grid[i - 1][j] ;\\n        if(grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6) return upW == 2 || upW == 3 || upW == 4;\\n        return false;\\n    }\\n    \\n    public boolean down(int i, int j) {\\n        int upW = grid[i + 1][j] ;\\n        if(grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4) return upW == 2 || upW == 5 || upW == 6;\\n        return false;\\n    }\\n    \\n    public boolean right(int i, int j) {\\n        int upW = grid[i][j + 1] ;\\n        if(grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6) return upW == 1 || upW == 3 || upW == 5;\\n        return false;\\n    }\\n    \\n    public boolean left(int i, int j) {\\n        int upW = grid[i][j - 1] ;\\n        if(grid[i][j] == 1 || grid[i][j] == 3 || grid[i][j] == 5) return upW == 1 || upW == 4 || upW == 6;    \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547537,
                "title": "java-split-grid-into-4-parts-and-use-union-find-explanation-with-graph",
                "content": "- step1. each grid has four edges, so we can split each grid into 4 parts by connecting the 2 diagonols, give 4 parts unique id\\n- step2. build connections inside a grid. eg. Street 1 connects left and right edge, so union left part and right part\\n- step3. build connections between grids. \\n    eg. in grid1 the street can reach down edge, grid2 is just below grid1, and the street in it can reach up edge. So we can connect grid1\\'s down part and grid2\\'s up part\\n- Similar question: [959. Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes/) \\n![image](https://assets.leetcode.com/users/zyhanghang/image_1584861023.png)\\n\\n```\\nclass Solution {\\n    class UnionFind {\\n        int[] id;\\n        public UnionFind(int N) {\\n            id = new int[N];\\n            for (int i = 0; i < N; i++) {\\n                id[i] = i;\\n            }\\n        }\\n        public void union(int x, int y) {\\n            int rx = find(x), ry = find(y);\\n            if (rx != ry) {\\n                id[rx] = ry;\\n            }\\n        }\\n        public int find(int x) {\\n            if (id[x] != x) {\\n                id[x] = find(id[x]);\\n            }\\n            return id[x];\\n        }\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        UnionFind uf = new UnionFind(4*m*n);\\n        \\n        //the street which has correspongding direction\\n        Set<Integer> up = new HashSet<>();\\n        up.add(2); up.add(5); up.add(6);\\n        Set<Integer> down = new HashSet<>();\\n        down.add(2); down.add(3); down.add(4);\\n        Set<Integer> left = new HashSet<>();\\n        left.add(1); left.add(3); left.add(5);\\n        Set<Integer> right = new HashSet<>();\\n        right.add(1); right.add(4); right.add(6);\\n        \\n        //build external connection, connect grid with grid if possible \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int idx = i * n + j;\\n                //connect cur grid with downward grid if possible\\n                if (down.contains(grid[i][j])) {\\n                    if (i + 1 < m && up.contains(grid[i+1][j])) {\\n                        int d = (i + 1) * n + j;\\n                        uf.union(idx*4+3, d*4+1);\\n                    }\\n                }\\n                //connect cur grid with rightward grid if possible\\n                if (right.contains(grid[i][j])) {\\n                    if (j + 1 < n && left.contains(grid[i][j+1])) {\\n                        int r = i * n + (j + 1);\\n                        uf.union(idx*4+2, r*4);\\n                    } \\n                }\\n                //connect cur grid with upward grid if possible\\n                if (up.contains(grid[i][j])) {\\n                    if (i - 1 >= 0 && down.contains(grid[i-1][j])) {\\n                        int u = (i-1) * n + j;\\n                        uf.union(idx*4+1, u*4+3);\\n                    } \\n                }\\n                //connect cur grid with leftward grid if possible\\n                if (left.contains(grid[i][j])) {\\n                    if (j - 1 >= 0 && right.contains(grid[i][j-1])) {\\n                        int l = i * n + (j - 1);\\n                        uf.union(idx*4, l*4+2);\\n                    } \\n                }\\n            }\\n        }\\n        \\n        //build internal connection\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int dir = grid[i][j];\\n                int idx = i * n + j;\\n                int b = 4 * idx;\\n                if (dir == 1) {\\n                    uf.union(b, b+2);                   \\n                } else if (dir == 2) {\\n                    uf.union(b+1, b+3);\\n                } else if (dir == 3) {\\n                    uf.union(b, b+3);\\n                } else if (dir == 4) {\\n                    uf.union(b+2, b+3);\\n                } else if (dir == 5) {\\n                    uf.union(b, b+1);\\n                } else {\\n                    uf.union(b+1, b+2);   \\n                }\\n            }\\n        }\\n        \\n        //check if (0, 0) and (m-1, n-1) is connected\\n        int src = 0, des = m*n-1;\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < 4; i++) {\\n            set.add(uf.find(4*src+i));\\n        }\\n        for (int i = 0; i < 4; i++) {\\n            if (set.contains(4*des+i)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class UnionFind {\\n        int[] id;\\n        public UnionFind(int N) {\\n            id = new int[N];\\n            for (int i = 0; i < N; i++) {\\n                id[i] = i;\\n            }\\n        }\\n        public void union(int x, int y) {\\n            int rx = find(x), ry = find(y);\\n            if (rx != ry) {\\n                id[rx] = ry;\\n            }\\n        }\\n        public int find(int x) {\\n            if (id[x] != x) {\\n                id[x] = find(id[x]);\\n            }\\n            return id[x];\\n        }\\n    }\\n    \\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        UnionFind uf = new UnionFind(4*m*n);\\n        \\n        //the street which has correspongding direction\\n        Set<Integer> up = new HashSet<>();\\n        up.add(2); up.add(5); up.add(6);\\n        Set<Integer> down = new HashSet<>();\\n        down.add(2); down.add(3); down.add(4);\\n        Set<Integer> left = new HashSet<>();\\n        left.add(1); left.add(3); left.add(5);\\n        Set<Integer> right = new HashSet<>();\\n        right.add(1); right.add(4); right.add(6);\\n        \\n        //build external connection, connect grid with grid if possible \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int idx = i * n + j;\\n                //connect cur grid with downward grid if possible\\n                if (down.contains(grid[i][j])) {\\n                    if (i + 1 < m && up.contains(grid[i+1][j])) {\\n                        int d = (i + 1) * n + j;\\n                        uf.union(idx*4+3, d*4+1);\\n                    }\\n                }\\n                //connect cur grid with rightward grid if possible\\n                if (right.contains(grid[i][j])) {\\n                    if (j + 1 < n && left.contains(grid[i][j+1])) {\\n                        int r = i * n + (j + 1);\\n                        uf.union(idx*4+2, r*4);\\n                    } \\n                }\\n                //connect cur grid with upward grid if possible\\n                if (up.contains(grid[i][j])) {\\n                    if (i - 1 >= 0 && down.contains(grid[i-1][j])) {\\n                        int u = (i-1) * n + j;\\n                        uf.union(idx*4+1, u*4+3);\\n                    } \\n                }\\n                //connect cur grid with leftward grid if possible\\n                if (left.contains(grid[i][j])) {\\n                    if (j - 1 >= 0 && right.contains(grid[i][j-1])) {\\n                        int l = i * n + (j - 1);\\n                        uf.union(idx*4, l*4+2);\\n                    } \\n                }\\n            }\\n        }\\n        \\n        //build internal connection\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int dir = grid[i][j];\\n                int idx = i * n + j;\\n                int b = 4 * idx;\\n                if (dir == 1) {\\n                    uf.union(b, b+2);                   \\n                } else if (dir == 2) {\\n                    uf.union(b+1, b+3);\\n                } else if (dir == 3) {\\n                    uf.union(b, b+3);\\n                } else if (dir == 4) {\\n                    uf.union(b+2, b+3);\\n                } else if (dir == 5) {\\n                    uf.union(b, b+1);\\n                } else {\\n                    uf.union(b+1, b+2);   \\n                }\\n            }\\n        }\\n        \\n        //check if (0, 0) and (m-1, n-1) is connected\\n        int src = 0, des = m*n-1;\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < 4; i++) {\\n            set.add(uf.find(4*src+i));\\n        }\\n        for (int i = 0; i < 4; i++) {\\n            if (set.contains(4*des+i)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547532,
                "title": "bfs-in-java",
                "content": "We use BFS approach to solve the problem. The key is how to define the connectivity. We use an array \"conn\" to represent possible streets in each four direction. So every time, we need to check moving direction based on pair array, and then check if there is a conect between current node and next node. \\n\\n```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return false;\\n        \\n        Deque<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0});\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; ++i) {\\n                int[] cell = queue.poll();\\n                if (cell[0] == m - 1 && cell[1] == n - 1) return true;\\n                for (int[] pair : pairs) {\\n                    int x = pair[0] + cell[0];\\n                    int y = pair[1] + cell[1];\\n                    \\n                    if ( x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;\\n                    \\n                    if ((pair[0] == -1 && isInArray(conn[0], grid[cell[0]][cell[1]]) && isInArray(conn[3],grid[x][y])) ||\\n                        (pair[0] == 1 && isInArray(conn[3], grid[cell[0]][cell[1]]) && isInArray(conn[0],grid[x][y])) ||\\n                        (pair[1] == -1 && isInArray(conn[1], grid[cell[0]][cell[1]]) && isInArray(conn[2],grid[x][y])) ||\\n                        (pair[1] == 1 && isInArray(conn[2], grid[cell[0]][cell[1]]) && isInArray(conn[1],grid[x][y]))) {\\n\\n                        visited[x][y] = true;\\n                        queue.offer(new int[]{x, y});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    private boolean isInArray(int[] arr, int num) {\\n        boolean res = false;\\n        for (int element : arr) {\\n            if (element == num) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int[][] pairs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    int[][] conn = new int[][]{{2,5,6}, {1,3,5}, {1,4,6}, {2,3,4}};\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return false;\\n        \\n        Deque<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0});\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; ++i) {\\n                int[] cell = queue.poll();\\n                if (cell[0] == m - 1 && cell[1] == n - 1) return true;\\n                for (int[] pair : pairs) {\\n                    int x = pair[0] + cell[0];\\n                    int y = pair[1] + cell[1];\\n                    \\n                    if ( x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) continue;\\n                    \\n                    if ((pair[0] == -1 && isInArray(conn[0], grid[cell[0]][cell[1]]) && isInArray(conn[3],grid[x][y])) ||\\n                        (pair[0] == 1 && isInArray(conn[3], grid[cell[0]][cell[1]]) && isInArray(conn[0],grid[x][y])) ||\\n                        (pair[1] == -1 && isInArray(conn[1], grid[cell[0]][cell[1]]) && isInArray(conn[2],grid[x][y])) ||\\n                        (pair[1] == 1 && isInArray(conn[2], grid[cell[0]][cell[1]]) && isInArray(conn[1],grid[x][y]))) {\\n\\n                        visited[x][y] = true;\\n                        queue.offer(new int[]{x, y});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    private boolean isInArray(int[] arr, int num) {\\n        boolean res = false;\\n        for (int element : arr) {\\n            if (element == num) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int[][] pairs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    int[][] conn = new int[][]{{2,5,6}, {1,3,5}, {1,4,6}, {2,3,4}};\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547401,
                "title": "java-union-find-enumeration",
                "content": "The idea of the following solution is quit straight forward: Just enumerate all cases that 2 paths can be considered as connected. \\n\\nSince this is a Union-Find solution, we can always choose ```one direction``` to make decision, that is, ```we do not need check a path from both side```. For example, if we have ```int[][] grid = [[1, 3]]```, then by the definition from this problem, we can only check path 1\\'s right to see whether we can meet a path 1 or path 3 and path 5. If we can meet one of three paths, then unite them with same root. \\n\\nFinally, we just check whether the top left cell and bottom right cell have same root value, that is what```find(0, m * n - 1)```representing for. \\n```\\n\\nclass Solution {\\n    int[] id;\\n    int[] sz;\\n    public boolean hasValidPath(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0){\\n            return false;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        id = new int[m * n];\\n        sz = new int[m * n];\\n        for (int i = 0; i < m * n; i++){\\n            id[i] = i;\\n        }\\n\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1 || grid[i][j] == 6){\\n                    if (j != n - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)){\\n                        unite(i * n + j, i * n + j + 1);\\n                    }\\n                } else if (grid[i][j] == 2 || grid[i][j] == 3){\\n                    if (i != m - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)){\\n                        unite(i * n + j, (i + 1) * n + j);\\n                    }\\n                } else if (grid[i][j] == 4){\\n                    if (j != n - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)){\\n                        unite(i * n + j, i * n + j + 1);\\n                    }\\n                    if (i != m - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)){\\n                        unite(i * n + j, (i + 1) * n + j);\\n                    }\\n                } else {\\n                    if (j != 0 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        unite(i * n + j, i * n + j - 1);\\n                    }\\n                    if (i != 0 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        unite(i * n + j, (i - 1) * n + j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return find(0, m * n - 1);\\n    }\\n    \\n    public boolean find(int p, int q) {\\n        return root(p) == root(q);\\n    }\\n\\n    public int root(int i) {\\n        while (i != id[i]) {\\n            id[i] = id[id[i]];\\n            i = id[i];\\n        }\\n        return i;\\n    }\\n\\n    public void unite(int p, int q) {\\t\\n        int i = root(p);\\n        int j = root(q);\\n        if (sz[i] < sz[j]) {\\n            id[i] = j;\\n            sz[j] += sz[i];\\n        } else {\\n            id[j] = i;\\n            sz[i] += sz[j];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```one direction```\n```we do not need check a path from both side```\n```int[][] grid = [[1, 3]]```\n```find(0, m * n - 1)```\n```\\n\\nclass Solution {\\n    int[] id;\\n    int[] sz;\\n    public boolean hasValidPath(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0){\\n            return false;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        id = new int[m * n];\\n        sz = new int[m * n];\\n        for (int i = 0; i < m * n; i++){\\n            id[i] = i;\\n        }\\n\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1 || grid[i][j] == 6){\\n                    if (j != n - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)){\\n                        unite(i * n + j, i * n + j + 1);\\n                    }\\n                } else if (grid[i][j] == 2 || grid[i][j] == 3){\\n                    if (i != m - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)){\\n                        unite(i * n + j, (i + 1) * n + j);\\n                    }\\n                } else if (grid[i][j] == 4){\\n                    if (j != n - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)){\\n                        unite(i * n + j, i * n + j + 1);\\n                    }\\n                    if (i != m - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)){\\n                        unite(i * n + j, (i + 1) * n + j);\\n                    }\\n                } else {\\n                    if (j != 0 && (grid[i][j - 1] == 1 || grid[i][j - 1] == 4 || grid[i][j - 1] == 6)){\\n                        unite(i * n + j, i * n + j - 1);\\n                    }\\n                    if (i != 0 && (grid[i - 1][j] == 2 || grid[i - 1][j] == 3 || grid[i - 1][j] == 4)){\\n                        unite(i * n + j, (i - 1) * n + j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return find(0, m * n - 1);\\n    }\\n    \\n    public boolean find(int p, int q) {\\n        return root(p) == root(q);\\n    }\\n\\n    public int root(int i) {\\n        while (i != id[i]) {\\n            id[i] = id[id[i]];\\n            i = id[i];\\n        }\\n        return i;\\n    }\\n\\n    public void unite(int p, int q) {\\t\\n        int i = root(p);\\n        int j = root(q);\\n        if (sz[i] < sz[j]) {\\n            id[i] = j;\\n            sz[j] += sz[i];\\n        } else {\\n            id[j] = i;\\n            sz[i] += sz[j];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547326,
                "title": "java-simple-interactive-dfs",
                "content": "Since it is a one way dfs no splits, it is possible apply DFS iteratively other than by recursion.\\n```\\nclass Solution {\\n    int[][][] dir = new int[][][]{{{0,1},{0,-1}},\\n                            {{1,0},{-1,0}},\\n                            {{1,0}, {0,-1}},\\n                            {{0,1},{1,0}},\\n                            {{-1,0},{0,-1}},\\n                            {{0,1},{-1, 0}}};\\n    public boolean hasValidPath(int[][] g) {\\n        int m = g.length, n = g[0].length;\\n        if (m <= 1 && n <= 1) return true;\\n        if (g[0][0] == 5) return false;\\n        if (g[0][0] == 4) return dfs(0, 0, 0, m, n, g) || dfs(0, 0, 1, m, n, g);\\n        return dfs(0, 0, 0, m, n, g);\\n    }\\n    \\n    private boolean dfs(int i, int j, int prev, int m, int n, int[][] g) {\\n        while (true) {\\n            if (i == m -1 && j == n - 1) return true;\\n            int in = g[i][j] - 1, next = prev == 1 ? 0 : 1;\\n            i += dir[in][prev][0];\\n            j += dir[in][prev][1];\\n            if (i < 0 || i >= m || j< 0 || j >= n) return false;\\n            int nextIn = g[i][j] - 1;\\n            if (dir[in][prev][0] + dir[nextIn][prev][0] == 0 && dir[in][prev][1] + dir[nextIn][prev][1] == 0) {\\n                prev = next;\\n                continue;// try one outlet\\n            }   \\n            if (dir[in][prev][0] + dir[nextIn][next][0] == 0 && dir[in][prev][1] + dir[nextIn][next][1] == 0) {\\n                continue; // try another outlet\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```\\nI use recursion in context and got TLE.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][][] dir = new int[][][]{{{0,1},{0,-1}},\\n                            {{1,0},{-1,0}},\\n                            {{1,0}, {0,-1}},\\n                            {{0,1},{1,0}},\\n                            {{-1,0},{0,-1}},\\n                            {{0,1},{-1, 0}}};\\n    public boolean hasValidPath(int[][] g) {\\n        int m = g.length, n = g[0].length;\\n        if (m <= 1 && n <= 1) return true;\\n        if (g[0][0] == 5) return false;\\n        if (g[0][0] == 4) return dfs(0, 0, 0, m, n, g) || dfs(0, 0, 1, m, n, g);\\n        return dfs(0, 0, 0, m, n, g);\\n    }\\n    \\n    private boolean dfs(int i, int j, int prev, int m, int n, int[][] g) {\\n        while (true) {\\n            if (i == m -1 && j == n - 1) return true;\\n            int in = g[i][j] - 1, next = prev == 1 ? 0 : 1;\\n            i += dir[in][prev][0];\\n            j += dir[in][prev][1];\\n            if (i < 0 || i >= m || j< 0 || j >= n) return false;\\n            int nextIn = g[i][j] - 1;\\n            if (dir[in][prev][0] + dir[nextIn][prev][0] == 0 && dir[in][prev][1] + dir[nextIn][prev][1] == 0) {\\n                prev = next;\\n                continue;// try one outlet\\n            }   \\n            if (dir[in][prev][0] + dir[nextIn][next][0] == 0 && dir[in][prev][1] + dir[nextIn][next][1] == 0) {\\n                continue; // try another outlet\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547262,
                "title": "python-bfs",
                "content": "```\\nclass Solution(object):\\n    def hasValidPath(self, grid):\\n        self.moves = {1:[(0,1), (0,-1)], \\n                      2:[(1,0),(-1,0)], \\n                      3:[(1,0),(0,-1)], \\n                      4:[(0,1),(1,0)],\\n                      5:[(-1,0),(0,-1)],\\n                      6:[(-1,0),(0,1)]}\\n        \\n        queue = collections.deque([(0,0)])\\n        seen = set() \\n        while queue:\\n            curr_row, curr_col = queue.popleft() \\n            curr_direction = grid[curr_row][curr_col] \\n            if curr_row == len(grid) - 1 and curr_col == len(grid[-1]) - 1:\\n                return True\\n            \\n            for move in self.moves[curr_direction]:\\n                new_row, new_col = curr_row + move[0], curr_col + move[1]\\n                if self.is_inbounds(grid, new_row, new_col, seen) and self.does_accept(grid, move, new_row, new_col):\\n                    seen.add((new_row, new_col))\\n                    queue.append((new_row, new_col)) \\n        return False \\n    \\n    def does_accept(self, grid, move, row, col):\\n        opposite_move = (move[0] *-1, move[1] * -1) \\n        curr_direction = grid[row][col]\\n        return opposite_move in self.moves[curr_direction] \\n    \\n    \\n    def is_inbounds(self, board, row, col, seen):\\n        return 0 <= row < len(board) and 0 <= col < len(board[row]) and (row, col) not in seen\\n    \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def hasValidPath(self, grid):\\n        self.moves = {1:[(0,1), (0,-1)], \\n                      2:[(1,0),(-1,0)], \\n                      3:[(1,0),(0,-1)], \\n                      4:[(0,1),(1,0)],\\n                      5:[(-1,0),(0,-1)],\\n                      6:[(-1,0),(0,1)]}\\n        \\n        queue = collections.deque([(0,0)])\\n        seen = set() \\n        while queue:\\n            curr_row, curr_col = queue.popleft() \\n            curr_direction = grid[curr_row][curr_col] \\n            if curr_row == len(grid) - 1 and curr_col == len(grid[-1]) - 1:\\n                return True\\n            \\n            for move in self.moves[curr_direction]:\\n                new_row, new_col = curr_row + move[0], curr_col + move[1]\\n                if self.is_inbounds(grid, new_row, new_col, seen) and self.does_accept(grid, move, new_row, new_col):\\n                    seen.add((new_row, new_col))\\n                    queue.append((new_row, new_col)) \\n        return False \\n    \\n    def does_accept(self, grid, move, row, col):\\n        opposite_move = (move[0] *-1, move[1] * -1) \\n        curr_direction = grid[row][col]\\n        return opposite_move in self.moves[curr_direction] \\n    \\n    \\n    def is_inbounds(self, board, row, col, seen):\\n        return 0 <= row < len(board) and 0 <= col < len(board[row]) and (row, col) not in seen\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547226,
                "title": "python3-graph-traversal",
                "content": "Algorithm: \\nConvert `grid` into a graph and traverse the graph. \\n\\nImplementation: \\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0]) #dimension\\n        \\n        graph = dict()\\n        for i in range(m):\\n            for j in range(n):\\n                if   grid[i][j] == 1: graph[i, j] = [(i, j-1), (i, j+1)]\\n                elif grid[i][j] == 2: graph[i, j] = [(i-1, j), (i+1, j)]\\n                elif grid[i][j] == 3: graph[i, j] = [(i, j-1), (i+1, j)]\\n                elif grid[i][j] == 4: graph[i, j] = [(i+1, j), (i, j+1)]\\n                elif grid[i][j] == 5: graph[i, j] = [(i-1, j), (i, j-1)]\\n                else:                 graph[i, j] = [(i-1, j), (i, j+1)] \\n        \\n        #traverse graph\\n        stack = [(0, 0)]\\n        seen = set()\\n        while stack:\\n            i, j = stack.pop()\\n            if i == m-1 and j == n-1: return True \\n            seen.add((i, j)) #mark as visited \\n            for ii, jj in graph[i, j]: \\n                if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen and (i, j) in graph[ii, jj]: \\n                    stack.append((ii, jj))\\n        return False \\n```\\nAnalysis\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0]) #dimension\\n        \\n        graph = dict()\\n        for i in range(m):\\n            for j in range(n):\\n                if   grid[i][j] == 1: graph[i, j] = [(i, j-1), (i, j+1)]\\n                elif grid[i][j] == 2: graph[i, j] = [(i-1, j), (i+1, j)]\\n                elif grid[i][j] == 3: graph[i, j] = [(i, j-1), (i+1, j)]\\n                elif grid[i][j] == 4: graph[i, j] = [(i+1, j), (i, j+1)]\\n                elif grid[i][j] == 5: graph[i, j] = [(i-1, j), (i, j-1)]\\n                else:                 graph[i, j] = [(i-1, j), (i, j+1)] \\n        \\n        #traverse graph\\n        stack = [(0, 0)]\\n        seen = set()\\n        while stack:\\n            i, j = stack.pop()\\n            if i == m-1 and j == n-1: return True \\n            seen.add((i, j)) #mark as visited \\n            for ii, jj in graph[i, j]: \\n                if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in seen and (i, j) in graph[ii, jj]: \\n                    stack.append((ii, jj))\\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 547221,
                "title": "python-dfs-easy-to-understand-clean-code",
                "content": "```\\nclass Solution(object):\\n    \\n    def valid(self, i, j, valid_next, grid):\\n        if i < 0 or j < 0 or i > len(grid) -1 or j > len(grid[0]) - 1:\\n            return False\\n        if grid[i][j] == \\'X\\' or grid[i][j] not in valid_next:\\n            return False\\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\\n            return True\\n        cur = grid[i][j]\\n        grid[i][j] = \\'X\\'\\n        for d in self.street_dir[cur]:\\n            x, y = self.dirs[d][0], self.dirs[d][1]\\n            if self.valid(i + x, j + y, self.valid_next[d], grid):\\n                return True\\n        return False\\n\\n    def hasValidPath(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return False\\n        self.valid_next = {\\n            \\'r\\': [1, 3, 5],\\n            \\'l\\': [1, 4, 6],\\n            \\'d\\': [2, 5, 6],\\n            \\'u\\': [2, 3, 4]\\n        }\\n        self.street_dir = {\\n            1: [\\'l\\', \\'r\\'],\\n            2: [\\'u\\', \\'d\\'],\\n            3: [\\'l\\', \\'d\\'],\\n            4: [\\'r\\', \\'d\\'],\\n            5: [\\'l\\', \\'u\\'],\\n            6: [\\'u\\', \\'r\\']\\n        }\\n        self.dirs = {\\n            \\'r\\': [0, 1],\\n            \\'l\\': [0, -1],\\n            \\'u\\': [-1, 0],\\n            \\'d\\': [1, 0]\\n        }\\n        \\n        return self.valid(0, 0, [1, 2, 3, 4, 6], grid)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def valid(self, i, j, valid_next, grid):\\n        if i < 0 or j < 0 or i > len(grid) -1 or j > len(grid[0]) - 1:\\n            return False\\n        if grid[i][j] == \\'X\\' or grid[i][j] not in valid_next:\\n            return False\\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\\n            return True\\n        cur = grid[i][j]\\n        grid[i][j] = \\'X\\'\\n        for d in self.street_dir[cur]:\\n            x, y = self.dirs[d][0], self.dirs[d][1]\\n            if self.valid(i + x, j + y, self.valid_next[d], grid):\\n                return True\\n        return False\\n\\n    def hasValidPath(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if not grid or not grid[0]:\\n            return False\\n        self.valid_next = {\\n            \\'r\\': [1, 3, 5],\\n            \\'l\\': [1, 4, 6],\\n            \\'d\\': [2, 5, 6],\\n            \\'u\\': [2, 3, 4]\\n        }\\n        self.street_dir = {\\n            1: [\\'l\\', \\'r\\'],\\n            2: [\\'u\\', \\'d\\'],\\n            3: [\\'l\\', \\'d\\'],\\n            4: [\\'r\\', \\'d\\'],\\n            5: [\\'l\\', \\'u\\'],\\n            6: [\\'u\\', \\'r\\']\\n        }\\n        self.dirs = {\\n            \\'r\\': [0, 1],\\n            \\'l\\': [0, -1],\\n            \\'u\\': [-1, 0],\\n            \\'d\\': [1, 0]\\n        }\\n        \\n        return self.valid(0, 0, [1, 2, 3, 4, 6], grid)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089074,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<bool>>vis;\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        vis.resize(m,vector<bool>(n,false));\\n        return fun(grid,0,0,-1);\\n    }\\n    bool fun(vector<vector<int>>&grid,int i,int j,int dir)\\n    {\\n        if(i<0 or j<0 or i>=m or j>=n)\\n        {\\n            return false;\\n        }\\n        if(i==m-1 and j==n-1)\\n        {\\n            return true;\\n        }\\n        if(vis[i][j]==true)\\n        {\\n            return false;\\n        }\\n        int val=grid[i][j];\\n        vis[i][j]=true;\\n        // 1->up 2->down 3->right 4->left\\n        if(val==1)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i,j-1,4) or fun(grid,i,j+1,3);\\n            }\\n            else if(dir==4) \\n            {\\n                if(isvalid(i,j-1))\\n                {\\n                    int v=grid[i][j-1];\\n                    if(v==2 or v==3 or v==5)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i,j-1,4);\\n                }\\n            }\\n            else if(dir==3)\\n            {\\n                if(isvalid(i,j+1))\\n                {\\n                    int v=grid[i][j+1];\\n                    if(v==2 or v==4 or v==6)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i,j+1,3);\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==2)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i-1,j,1) or fun(grid,i+1,j,2);\\n            }\\n            else if(dir==1)\\n            {\\n                if(isvalid(i-1,j))\\n                {\\n                    int v=grid[i-1][j];\\n                    if(v==1 or v==5 or v==6)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i-1,j,1);\\n                }\\n            }\\n            else if(dir==2)\\n            {\\n                if(isvalid(i+1,j))\\n                {\\n                    int v=grid[i+1][j];\\n                    if(v==1 or v==3 or v==4)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i+1,j,2);\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==3)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i+1,j,2) or fun(grid,i,j-1,4);\\n            }\\n            else if(dir==1)\\n            {\\n                // up ->left\\n                return fun(grid,i,j-1,4);\\n            }\\n            else if(dir==3)\\n            {\\n                // right->down\\n                return fun(grid,i+1,j,2);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==4)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i+1,j,2) or fun(grid,i,j+1,3);\\n            }\\n            else if(dir==1)\\n            {\\n                return fun(grid,i,j+1,3);\\n            }\\n            else if(dir==4)\\n            {\\n                return fun(grid,i+1,j,2);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==5)\\n        {\\n            if(dir==2)\\n            {\\n                return fun(grid,i,j-1,4);\\n            }\\n            else if(dir==3)\\n            {\\n                return fun(grid,i-1,j,1);\\n            }\\n            else \\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==6)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i,j+1,3);\\n            }\\n            else if(dir==2)\\n            {\\n                return fun(grid,i,j+1,3);\\n            }\\n            else if(dir==4)\\n            {\\n                return fun(grid,i-1,j,1);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isvalid(int i,int j)\\n    {\\n        if(i<0 or j<0 or i>=m or j>=n)\\n        {\\n            return false;\\n        }\\n        if(vis[i][j]==true)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<bool>>vis;\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        vis.resize(m,vector<bool>(n,false));\\n        return fun(grid,0,0,-1);\\n    }\\n    bool fun(vector<vector<int>>&grid,int i,int j,int dir)\\n    {\\n        if(i<0 or j<0 or i>=m or j>=n)\\n        {\\n            return false;\\n        }\\n        if(i==m-1 and j==n-1)\\n        {\\n            return true;\\n        }\\n        if(vis[i][j]==true)\\n        {\\n            return false;\\n        }\\n        int val=grid[i][j];\\n        vis[i][j]=true;\\n        // 1->up 2->down 3->right 4->left\\n        if(val==1)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i,j-1,4) or fun(grid,i,j+1,3);\\n            }\\n            else if(dir==4) \\n            {\\n                if(isvalid(i,j-1))\\n                {\\n                    int v=grid[i][j-1];\\n                    if(v==2 or v==3 or v==5)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i,j-1,4);\\n                }\\n            }\\n            else if(dir==3)\\n            {\\n                if(isvalid(i,j+1))\\n                {\\n                    int v=grid[i][j+1];\\n                    if(v==2 or v==4 or v==6)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i,j+1,3);\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==2)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i-1,j,1) or fun(grid,i+1,j,2);\\n            }\\n            else if(dir==1)\\n            {\\n                if(isvalid(i-1,j))\\n                {\\n                    int v=grid[i-1][j];\\n                    if(v==1 or v==5 or v==6)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i-1,j,1);\\n                }\\n            }\\n            else if(dir==2)\\n            {\\n                if(isvalid(i+1,j))\\n                {\\n                    int v=grid[i+1][j];\\n                    if(v==1 or v==3 or v==4)\\n                    {\\n                        return false;\\n                    }\\n                    return fun(grid,i+1,j,2);\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==3)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i+1,j,2) or fun(grid,i,j-1,4);\\n            }\\n            else if(dir==1)\\n            {\\n                // up ->left\\n                return fun(grid,i,j-1,4);\\n            }\\n            else if(dir==3)\\n            {\\n                // right->down\\n                return fun(grid,i+1,j,2);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==4)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i+1,j,2) or fun(grid,i,j+1,3);\\n            }\\n            else if(dir==1)\\n            {\\n                return fun(grid,i,j+1,3);\\n            }\\n            else if(dir==4)\\n            {\\n                return fun(grid,i+1,j,2);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==5)\\n        {\\n            if(dir==2)\\n            {\\n                return fun(grid,i,j-1,4);\\n            }\\n            else if(dir==3)\\n            {\\n                return fun(grid,i-1,j,1);\\n            }\\n            else \\n            {\\n                return false;\\n            }\\n        }\\n        else if(val==6)\\n        {\\n            if(dir==-1)\\n            {\\n                return fun(grid,i,j+1,3);\\n            }\\n            else if(dir==2)\\n            {\\n                return fun(grid,i,j+1,3);\\n            }\\n            else if(dir==4)\\n            {\\n                return fun(grid,i-1,j,1);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isvalid(int i,int j)\\n    {\\n        if(i<0 or j<0 or i>=m or j>=n)\\n        {\\n            return false;\\n        }\\n        if(vis[i][j]==true)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084600,
                "title": "easy-python-dfs",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def dfs(self,grid,i,j):\\n        z=grid[i][j]\\n        grid[i][j]=-1\\n        \\n        \\n         \\n        if z==1:\\n            q=i\\n            w=j+1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,3,5]:\\n                self.dfs(grid,q,w)\\n            q=i\\n            w=j-1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,4,6]:\\n                self.dfs(grid,q,w)\\n        if z==2:\\n            \\n            q=i-1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,3,4]:\\n                self.dfs(grid,q,w)\\n            q=i+1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,5,6]:\\n                self.dfs(grid,q,w)\\n        if z==3:\\n            \\n            q=i\\n            w=j-1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,4,6]:\\n                self.dfs(grid,q,w)\\n            q=i+1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,5,6]:\\n                self.dfs(grid,q,w)\\n        if z==4:\\n            \\n            q=i\\n            w=j+1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,3,5]:\\n                self.dfs(grid,q,w)\\n            q=i+1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,5,6]:\\n                self.dfs(grid,q,w)\\n        if z==5:\\n            \\n            q=i-1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,3,4]:\\n                self.dfs(grid,q,w)\\n            q=i\\n            w=j-1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,4,6]:\\n                self.dfs(grid,q,w)\\n        if z==6:\\n            \\n            q=i-1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,4,3]:\\n                self.dfs(grid,q,w)\\n            q=i\\n            w=j+1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,5,3]:\\n                self.dfs(grid,q,w)\\n\\n\\n            \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        self.dfs(grid,0,0)\\n        if grid[-1][-1]==-1:\\n            return True\\n        return False\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self,grid,i,j):\\n        z=grid[i][j]\\n        grid[i][j]=-1\\n        \\n        \\n         \\n        if z==1:\\n            q=i\\n            w=j+1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,3,5]:\\n                self.dfs(grid,q,w)\\n            q=i\\n            w=j-1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,4,6]:\\n                self.dfs(grid,q,w)\\n        if z==2:\\n            \\n            q=i-1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,3,4]:\\n                self.dfs(grid,q,w)\\n            q=i+1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,5,6]:\\n                self.dfs(grid,q,w)\\n        if z==3:\\n            \\n            q=i\\n            w=j-1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,4,6]:\\n                self.dfs(grid,q,w)\\n            q=i+1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,5,6]:\\n                self.dfs(grid,q,w)\\n        if z==4:\\n            \\n            q=i\\n            w=j+1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,3,5]:\\n                self.dfs(grid,q,w)\\n            q=i+1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,5,6]:\\n                self.dfs(grid,q,w)\\n        if z==5:\\n            \\n            q=i-1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,3,4]:\\n                self.dfs(grid,q,w)\\n            q=i\\n            w=j-1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,4,6]:\\n                self.dfs(grid,q,w)\\n        if z==6:\\n            \\n            q=i-1\\n            w=j\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [2,4,3]:\\n                self.dfs(grid,q,w)\\n            q=i\\n            w=j+1\\n            if q>=0 and w>=0 and q<len(grid) and w<len(grid[0]) and grid[q][w] in [1,5,3]:\\n                self.dfs(grid,q,w)\\n\\n\\n            \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        self.dfs(grid,0,0)\\n        if grid[-1][-1]==-1:\\n            return True\\n        return False\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075180,
                "title": "python-solution-beated-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        L, R, U, D = 0, 1, 2, 3\\n        exits = {\\n            (L, 1): L,\\n            (R, 1): R,\\n            (U, 2): U,\\n            (D, 2): D,\\n            (L, 3): U,\\n            (D, 3): R,\\n            (R, 4): U,\\n            (D, 4): L,\\n            (L, 5): D,\\n            (U, 5): R,\\n            (U, 6): L,\\n            (R, 6): D,\\n        }\\n        n, m = len(grid), len(grid[0])\\n        def solve(dir, curr):\\n            x, y = 0, 0\\n            while x != n - 1 or y != m - 1:\\n                next_dir = exits[(dir, curr)]\\n                if next_dir == L:\\n                    y += 1\\n                elif next_dir == R:\\n                    y -= 1\\n                elif next_dir == U:\\n                    x += 1\\n                elif next_dir == D:\\n                    x -= 1\\n                if x < 0 or x >= n:\\n                    return False\\n                if y < 0 or y >= m:\\n                    return False\\n                if x == 0 and y == 0:\\n                    return False\\n                if (next_dir, grid[x][y]) not in exits:\\n                    return False\\n                dir, curr = next_dir, grid[x][y]\\n            return True \\n        if grid[0][0] == 1:\\n            return solve(L, 1)\\n        if grid[0][0] == 2:\\n            return solve(U, 2)\\n        if grid[0][0] == 3:\\n            return solve(L, 3)\\n        if grid[0][0] == 4:\\n            return solve(R, 4) or solve(D, 4)\\n        if grid[0][0] == 6:\\n            return solve(U, 6)\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        L, R, U, D = 0, 1, 2, 3\\n        exits = {\\n            (L, 1): L,\\n            (R, 1): R,\\n            (U, 2): U,\\n            (D, 2): D,\\n            (L, 3): U,\\n            (D, 3): R,\\n            (R, 4): U,\\n            (D, 4): L,\\n            (L, 5): D,\\n            (U, 5): R,\\n            (U, 6): L,\\n            (R, 6): D,\\n        }\\n        n, m = len(grid), len(grid[0])\\n        def solve(dir, curr):\\n            x, y = 0, 0\\n            while x != n - 1 or y != m - 1:\\n                next_dir = exits[(dir, curr)]\\n                if next_dir == L:\\n                    y += 1\\n                elif next_dir == R:\\n                    y -= 1\\n                elif next_dir == U:\\n                    x += 1\\n                elif next_dir == D:\\n                    x -= 1\\n                if x < 0 or x >= n:\\n                    return False\\n                if y < 0 or y >= m:\\n                    return False\\n                if x == 0 and y == 0:\\n                    return False\\n                if (next_dir, grid[x][y]) not in exits:\\n                    return False\\n                dir, curr = next_dir, grid[x][y]\\n            return True \\n        if grid[0][0] == 1:\\n            return solve(L, 1)\\n        if grid[0][0] == 2:\\n            return solve(U, 2)\\n        if grid[0][0] == 3:\\n            return solve(L, 3)\\n        if grid[0][0] == 4:\\n            return solve(R, 4) or solve(D, 4)\\n        if grid[0][0] == 6:\\n            return solve(U, 6)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066466,
                "title": "simple-c-code-but-quite-messy",
                "content": "Now u surely need a therapy after seeing my code\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool valid(int i,int j,int n,int m)\\n{\\n if(i==n||j==m||i<0||j<0)return false;\\n return true;\\n}\\n bool f(int i,int j,vector<vector<int>>& grid,vector<vector<int>>&vis)\\n {   if(i==grid.size()-1&&j==grid[0].size()-1)return true;\\n    \\n    vis[i][j]=1;\\n     cout<<i<<\" \"<<j<<endl;\\n     bool b=false;\\n     if(grid[i][j]==1)\\n     {\\n         if(valid(i,j-1,grid.size(),grid[0].size())&&vis[i][j-1]==0&&(grid[i][j-1]==1||grid[i][j-1]==4||grid[i][j-1]==6))\\n    b=f(i,j-1,grid,vis);\\n    if(b==true)return true;\\n    if(valid(i,j+1,grid.size(),grid[0].size())&&vis[i][j+1]==0&&(grid[i][j+1]==1||grid[i][j+1]==3||grid[i][j+1]==5))\\n    b=f(i,j+1,grid,vis);\\n  return b;\\n     }\\n     if(grid[i][j]==2)\\n     {\\n  \\n    if(valid(i-1,j,grid.size(),grid[0].size())&&vis[i-1][j]==0&&(grid[i-1][j]==2||grid[i-1][j]==4||grid[i-1][j]==3))\\n    b=f(i-1,j,grid,vis);\\n    if(b==true)return true;\\n     if(valid(i+1,j,grid.size(),grid[0].size())&&vis[i+1][j]==0&&(grid[i+1][j]==2||grid[i+1][j]==5||grid[i+1][j]==6))\\n    b=f(i+1,j,grid,vis);\\n  return b;\\n     }\\n     if(grid[i][j]==3)\\n     {\\nif(valid(i,j-1,grid.size(),grid[0].size())&&vis[i][j-1]==0&&(grid[i][j-1]==4||grid[i][j-1]==1||grid[i][j-1]==6))\\n    b=f(i,j-1,grid,vis);\\n    if(b==true)return true;\\n     if(valid(i+1,j,grid.size(),grid[0].size())&&vis[i+1][j]==0&&(grid[i+1][j]==5||grid[i+1][j]==6||grid[i+1][j]==2))\\n    b=f(i+1,j,grid,vis);\\n  return b;\\n     }\\n     if(grid[i][j]==4)\\n     { \\nif(valid(i,j+1,grid.size(),grid[0].size())&&vis[i][j+1]==0&&(grid[i][j+1]==5||grid[i][j+1]==3||grid[i][j+1]==1))\\n    b=f(i,j+1,grid,vis);\\n\\n    if(b==true)return true;\\n     if(valid(i+1,j,grid.size(),grid[0].size())&&vis[i+1][j]==0&&(grid[i+1][j]==5||grid[i+1][j]==6||grid[i+1][j]==2))\\n    b=f(i+1,j,grid,vis);\\n  return b;\\n     }\\n      if(grid[i][j]==5)\\n     {\\n         \\n    if(valid(i,j-1,grid.size(),grid[0].size())&&vis[i][j-1]==0&&(grid[i][j-1]==3||grid[i][j-1]==4||grid[i][j-1]==1))\\n    b=f(i,j-1,grid,vis);\\n     if(b==true)return true;\\n     if(valid(i-1,j,grid.size(),grid[0].size())&&vis[i-1][j]==0&&(grid[i-1][j]==3||grid[i-1][j]==4||grid[i-1][j]==2))\\n    b=f(i-1,j,grid,vis);\\n    return b;\\n  \\n     }\\n      if(grid[i][j]==6)\\n     {  \\nif(valid(i-1,j,grid.size(),grid[0].size())&&vis[i-1][j]==0&&(grid[i-1][j]==3||grid[i-1][j]==4||grid[i-1][j]==2))\\n    b=f(i-1,j,grid,vis);\\n     if(b==true)return true;\\n    if(valid(i,j+1,grid.size(),grid[0].size())&&vis[i][j+1]==0&&(grid[i][j+1]==5||grid[i][j+1]==3||grid[i][j+1]==1))\\n    b=f(i,j+1,grid,vis);\\n\\n   \\n    return  b;\\n     }\\n     return false;\\n }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        return f(0,0,grid,vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool valid(int i,int j,int n,int m)\\n{\\n if(i==n||j==m||i<0||j<0)return false;\\n return true;\\n}\\n bool f(int i,int j,vector<vector<int>>& grid,vector<vector<int>>&vis)\\n {   if(i==grid.size()-1&&j==grid[0].size()-1)return true;\\n    \\n    vis[i][j]=1;\\n     cout<<i<<\" \"<<j<<endl;\\n     bool b=false;\\n     if(grid[i][j]==1)\\n     {\\n         if(valid(i,j-1,grid.size(),grid[0].size())&&vis[i][j-1]==0&&(grid[i][j-1]==1||grid[i][j-1]==4||grid[i][j-1]==6))\\n    b=f(i,j-1,grid,vis);\\n    if(b==true)return true;\\n    if(valid(i,j+1,grid.size(),grid[0].size())&&vis[i][j+1]==0&&(grid[i][j+1]==1||grid[i][j+1]==3||grid[i][j+1]==5))\\n    b=f(i,j+1,grid,vis);\\n  return b;\\n     }\\n     if(grid[i][j]==2)\\n     {\\n  \\n    if(valid(i-1,j,grid.size(),grid[0].size())&&vis[i-1][j]==0&&(grid[i-1][j]==2||grid[i-1][j]==4||grid[i-1][j]==3))\\n    b=f(i-1,j,grid,vis);\\n    if(b==true)return true;\\n     if(valid(i+1,j,grid.size(),grid[0].size())&&vis[i+1][j]==0&&(grid[i+1][j]==2||grid[i+1][j]==5||grid[i+1][j]==6))\\n    b=f(i+1,j,grid,vis);\\n  return b;\\n     }\\n     if(grid[i][j]==3)\\n     {\\nif(valid(i,j-1,grid.size(),grid[0].size())&&vis[i][j-1]==0&&(grid[i][j-1]==4||grid[i][j-1]==1||grid[i][j-1]==6))\\n    b=f(i,j-1,grid,vis);\\n    if(b==true)return true;\\n     if(valid(i+1,j,grid.size(),grid[0].size())&&vis[i+1][j]==0&&(grid[i+1][j]==5||grid[i+1][j]==6||grid[i+1][j]==2))\\n    b=f(i+1,j,grid,vis);\\n  return b;\\n     }\\n     if(grid[i][j]==4)\\n     { \\nif(valid(i,j+1,grid.size(),grid[0].size())&&vis[i][j+1]==0&&(grid[i][j+1]==5||grid[i][j+1]==3||grid[i][j+1]==1))\\n    b=f(i,j+1,grid,vis);\\n\\n    if(b==true)return true;\\n     if(valid(i+1,j,grid.size(),grid[0].size())&&vis[i+1][j]==0&&(grid[i+1][j]==5||grid[i+1][j]==6||grid[i+1][j]==2))\\n    b=f(i+1,j,grid,vis);\\n  return b;\\n     }\\n      if(grid[i][j]==5)\\n     {\\n         \\n    if(valid(i,j-1,grid.size(),grid[0].size())&&vis[i][j-1]==0&&(grid[i][j-1]==3||grid[i][j-1]==4||grid[i][j-1]==1))\\n    b=f(i,j-1,grid,vis);\\n     if(b==true)return true;\\n     if(valid(i-1,j,grid.size(),grid[0].size())&&vis[i-1][j]==0&&(grid[i-1][j]==3||grid[i-1][j]==4||grid[i-1][j]==2))\\n    b=f(i-1,j,grid,vis);\\n    return b;\\n  \\n     }\\n      if(grid[i][j]==6)\\n     {  \\nif(valid(i-1,j,grid.size(),grid[0].size())&&vis[i-1][j]==0&&(grid[i-1][j]==3||grid[i-1][j]==4||grid[i-1][j]==2))\\n    b=f(i-1,j,grid,vis);\\n     if(b==true)return true;\\n    if(valid(i,j+1,grid.size(),grid[0].size())&&vis[i][j+1]==0&&(grid[i][j+1]==5||grid[i][j+1]==3||grid[i][j+1]==1))\\n    b=f(i,j+1,grid,vis);\\n\\n   \\n    return  b;\\n     }\\n     return false;\\n }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        return f(0,0,grid,vis);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4059129,
                "title": "rust-dfs-iterative",
                "content": "# Approach\\n1. A stack is used to store tuples of `(i, j, d)`, where `[i, j]` is the coordinate and `d` represents the direction and `0 <= d < 4`.\\n2. `cell` is a 2D boolean array storing information of all street types, where `cell[x][d]` indicates from a street of value `x`, whether we can move in direction `d`.\\n3. A visited position will be marked with `grid[i][j] = 0;`.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn has_valid_path(mut grid: Vec<Vec<i32>>) -> bool {\\n        if grid.len() == 1 && grid[0].len() == 1 {\\n            return true;\\n        }\\n        let dir = [0, 1, 0, usize::MAX, 0];\\n        let cell = [\\n            [false, false, false, false],\\n            [true, false, true, false],\\n            [false, true, false, true],\\n            [false, true, true, false],\\n            [true, true, false, false],\\n            [false, false, true, true],\\n            [true, false, false, true]\\n        ];\\n        let mut stack = Vec::<(usize, usize, usize)>::new();\\n        for d in 0..4 {\\n            if cell[grid[0][0] as usize][d] {\\n                stack.push((0, 0, d));\\n            }\\n        }\\n        grid[0][0] = 0;\\n        while let Some((i, j, d)) = stack.pop() {\\n            let i2 = i.wrapping_add(dir[d]);\\n            let j2 = j.wrapping_add(dir[d + 1]);\\n            let d_inv = (d + 2) % 4;\\n            if i2 < grid.len()\\n            && j2 < grid[i2].len()\\n            && cell[grid[i2][j2] as usize][d_inv] {\\n                if i2 == grid.len() - 1\\n                && j2 == grid[i2].len() - 1 {\\n                    return true;\\n                }\\n                for d2 in 0..4 {\\n                    if d2 != d_inv\\n                    && cell[grid[i2][j2] as usize][d2] {\\n                        stack.push((i2, j2, d2));\\n                    }\\n                }\\n                grid[i2][j2] = 0;\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn has_valid_path(mut grid: Vec<Vec<i32>>) -> bool {\\n        if grid.len() == 1 && grid[0].len() == 1 {\\n            return true;\\n        }\\n        let dir = [0, 1, 0, usize::MAX, 0];\\n        let cell = [\\n            [false, false, false, false],\\n            [true, false, true, false],\\n            [false, true, false, true],\\n            [false, true, true, false],\\n            [true, true, false, false],\\n            [false, false, true, true],\\n            [true, false, false, true]\\n        ];\\n        let mut stack = Vec::<(usize, usize, usize)>::new();\\n        for d in 0..4 {\\n            if cell[grid[0][0] as usize][d] {\\n                stack.push((0, 0, d));\\n            }\\n        }\\n        grid[0][0] = 0;\\n        while let Some((i, j, d)) = stack.pop() {\\n            let i2 = i.wrapping_add(dir[d]);\\n            let j2 = j.wrapping_add(dir[d + 1]);\\n            let d_inv = (d + 2) % 4;\\n            if i2 < grid.len()\\n            && j2 < grid[i2].len()\\n            && cell[grid[i2][j2] as usize][d_inv] {\\n                if i2 == grid.len() - 1\\n                && j2 == grid[i2].len() - 1 {\\n                    return true;\\n                }\\n                for d2 in 0..4 {\\n                    if d2 != d_inv\\n                    && cell[grid[i2][j2] as usize][d2] {\\n                        stack.push((i2, j2, d2));\\n                    }\\n                }\\n                grid[i2][j2] = 0;\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051051,
                "title": "c-bfs-approach",
                "content": "# Intuition\\nmovement from each cell is restricted so we need to check which cell we can move ; these checks are prety exaustive so see carefully and you will understand\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        //do bfs and find the path;\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        queue<int> q;\\n        q.push(0);vis[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto node = q.front();q.pop();\\n            int i = node/m, j = node%m;\\n            \\n            if(i == n-1 && j == m-1)return true;\\n\\n            \\n            if(grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4){ //try down\\n                if(i+1 < n && !vis[i+1][j] && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6)){\\n                    vis[i+1][j] = 1;\\n                    q.push((i+1)*m + j);\\n                }\\n            }\\n            if(grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6){ //try up\\n                if(i-1 >= 0 && !vis[i-1][j] && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                    vis[i-1][j] = 1;\\n                    q.push((i-1)*m + j);\\n                }\\n            }\\n\\n            if(grid[i][j] ==1 || grid[i][j] == 3 || grid[i][j] == 5){ //try left\\n                  if(j-1 >= 0 && !vis[i][j-1] && (grid[i][j-1] == 1 || grid[i][j-1] == 5 || grid[i][j-1] == 4)){\\n                    vis[i][j-1] = 1;\\n                    q.push((i)*m + j-1);\\n                }\\n            }\\n\\n            if(grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6){ //try right\\n                  if(j+1 < m && !vis[i][j+1] && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5)){\\n                    vis[i][j+1] = 1;\\n                    q.push((i)*m + j+1);\\n                }\\n            }\\n\\n\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        //do bfs and find the path;\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        queue<int> q;\\n        q.push(0);vis[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto node = q.front();q.pop();\\n            int i = node/m, j = node%m;\\n            \\n            if(i == n-1 && j == m-1)return true;\\n\\n            \\n            if(grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4){ //try down\\n                if(i+1 < n && !vis[i+1][j] && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6)){\\n                    vis[i+1][j] = 1;\\n                    q.push((i+1)*m + j);\\n                }\\n            }\\n            if(grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6){ //try up\\n                if(i-1 >= 0 && !vis[i-1][j] && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                    vis[i-1][j] = 1;\\n                    q.push((i-1)*m + j);\\n                }\\n            }\\n\\n            if(grid[i][j] ==1 || grid[i][j] == 3 || grid[i][j] == 5){ //try left\\n                  if(j-1 >= 0 && !vis[i][j-1] && (grid[i][j-1] == 1 || grid[i][j-1] == 5 || grid[i][j-1] == 4)){\\n                    vis[i][j-1] = 1;\\n                    q.push((i)*m + j-1);\\n                }\\n            }\\n\\n            if(grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6){ //try right\\n                  if(j+1 < m && !vis[i][j+1] && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5)){\\n                    vis[i][j+1] = 1;\\n                    q.push((i)*m + j+1);\\n                }\\n            }\\n\\n\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042995,
                "title": "beats-95-solution-dfs-matrix",
                "content": "![WhatsApp Image 2023-09-14 at 13.10.56.jpeg](https://assets.leetcode.com/users/images/f9b87021-ad04-4d23-bb58-12c9b3c4d0fe_1694677295.7041726.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean  chk(int grid[][],int i,int j){ \\n// you pass the matrix grid mark it as -1;\\n        grid[i][j]=-1;\\n// if you reah final return true;\\n        if(i==grid.length-1 && j== grid[0].length-1){return true;}\\n        return false;\\n    }\\n    public static boolean call(int x,int y,int i,int j,int grid[][]){  \\n        \\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==-1 ){ \\n            return false;\\n        }\\n   // mainly you have yo remember that you are checking the parent of particular cell if particular cell has parent from where you came then it is good else at last it will return falsewe   \\n![WhatsApp Image 2023-09-14 at 13.10.56.jpeg](https://assets.leetcode.com/users/images/b90b40a3-a485-444f-a15a-efe561c44f16_1694677278.1096072.jpeg)\\n\\n        if(grid[i][j]==1 &&((i==x && j-1==y) || (i==x && j+1==y) || (x==-1 && y==-1)) ){\\n              if(chk(grid,i,j)){return true;}\\n            return call(i,j,i,j+1,grid) || call(i,j,i,j-1,grid);\\n        }\\n        else if(grid[i][j]==2 && ((i-1==x && j==y)  || (i+1==x && j==y)|| (x==-1 && y==-1) )){ \\n              if(chk(grid,i,j)){return true;}\\n            return call(i,j,i-1,j,grid) || call(i,j,i+1,j,grid); \\n        }\\n        else if(grid[i][j]==3 && ((i==x && j-1==y) || (i+1==x && j==y) || (x==-1 && y==-1))){ \\n              if(chk(grid,i,j)){return true;}\\n             return call(i,j,i,j-1,grid) || call(i,j,i+1,j,grid);\\n        }  \\n        else if(grid[i][j]==4 && ( (i+1==x && j==y) || (i==x && j+1==y) ||( x==-1 && y==-1))  ){ \\n              if(chk(grid,i,j)){return true;}\\n              return call(i,j,i,j+1,grid) || call(i,j,i+1,j,grid);\\n        }\\n        else if(grid[i][j]==5 && ( ( i==x && j-1==y)|| ( i-1==x && j==y ) || (x==-1 && y==-1))){ \\n              if(chk(grid,i,j)){return true;}\\n              return call(i,j,i,j-1,grid) || call(i,j,i-1,j,grid);\\n        }\\n        else if(grid[i][j]==6 && ( ( i==x && j+1==y) || ( i-1==x && j==y ) || (x==-1 && y==-1))){\\n                  if(chk(grid,i,j)){return true;}\\n                return call(i,j,i,j+1,grid) || call(i,j,i-1,j,grid);\\n\\n        }\\n\\n        return false;\\n    \\n\\n\\n    }\\n\\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        return call(-1,-1,0,0,grid);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Union Find",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean  chk(int grid[][],int i,int j){ \\n// you pass the matrix grid mark it as -1;\\n        grid[i][j]=-1;\\n// if you reah final return true;\\n        if(i==grid.length-1 && j== grid[0].length-1){return true;}\\n        return false;\\n    }\\n    public static boolean call(int x,int y,int i,int j,int grid[][]){  \\n        \\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==-1 ){ \\n            return false;\\n        }\\n   // mainly you have yo remember that you are checking the parent of particular cell if particular cell has parent from where you came then it is good else at last it will return falsewe   \\n![WhatsApp Image 2023-09-14 at 13.10.56.jpeg](https://assets.leetcode.com/users/images/b90b40a3-a485-444f-a15a-efe561c44f16_1694677278.1096072.jpeg)\\n\\n        if(grid[i][j]==1 &&((i==x && j-1==y) || (i==x && j+1==y) || (x==-1 && y==-1)) ){\\n              if(chk(grid,i,j)){return true;}\\n            return call(i,j,i,j+1,grid) || call(i,j,i,j-1,grid);\\n        }\\n        else if(grid[i][j]==2 && ((i-1==x && j==y)  || (i+1==x && j==y)|| (x==-1 && y==-1) )){ \\n              if(chk(grid,i,j)){return true;}\\n            return call(i,j,i-1,j,grid) || call(i,j,i+1,j,grid); \\n        }\\n        else if(grid[i][j]==3 && ((i==x && j-1==y) || (i+1==x && j==y) || (x==-1 && y==-1))){ \\n              if(chk(grid,i,j)){return true;}\\n             return call(i,j,i,j-1,grid) || call(i,j,i+1,j,grid);\\n        }  \\n        else if(grid[i][j]==4 && ( (i+1==x && j==y) || (i==x && j+1==y) ||( x==-1 && y==-1))  ){ \\n              if(chk(grid,i,j)){return true;}\\n              return call(i,j,i,j+1,grid) || call(i,j,i+1,j,grid);\\n        }\\n        else if(grid[i][j]==5 && ( ( i==x && j-1==y)|| ( i-1==x && j==y ) || (x==-1 && y==-1))){ \\n              if(chk(grid,i,j)){return true;}\\n              return call(i,j,i,j-1,grid) || call(i,j,i-1,j,grid);\\n        }\\n        else if(grid[i][j]==6 && ( ( i==x && j+1==y) || ( i-1==x && j==y ) || (x==-1 && y==-1))){\\n                  if(chk(grid,i,j)){return true;}\\n                return call(i,j,i,j+1,grid) || call(i,j,i-1,j,grid);\\n\\n        }\\n\\n        return false;\\n    \\n\\n\\n    }\\n\\n    public boolean hasValidPath(int[][] grid) {\\n        \\n        return call(-1,-1,0,0,grid);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035731,
                "title": "cpp-straight-forward-solution-an-attempt-for-improving-readability",
                "content": "I think this problem is easy but a bit tricky to implement.\\nHaven\\'t found a way to write a short while easy understanding solution.\\n\\n# Code\\n```\\nclass Solution {\\n    int m, n;\\n    vector<vector<int>> directions {\\n        {1, 0}, {-1, 0}, {0, 1}, {0, -1}\\n    }; // down, up, right, left\\n    enum {\\n        down = 0, up = 1, right = 2, left = 3\\n    };\\n    bool atValidPosition(int x, int y)\\n    {\\n        return x >= 0 && y >= 0 && x < m && y < n;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n\\n        // we need to make sure the first street can connect downward or rightward\\n        int initType {grid[0][0]};\\n        if (initType == 5) return false;\\n        if (initType == 1 || initType == 6) return explore(grid, right);\\n        if (initType == 2 || initType == 3) return explore(grid, down);\\n        return explore(grid, down) || explore(grid, right);\\n    }\\n    bool explore(const vector<vector<int>>& grid, int dir)\\n    {\\n        int x {}, y {};\\n        vector<vector<int>> visited(m, vector(n, 0)); // to avoid cycles\\n        while (atValidPosition(x, y))\\n        {\\n            if (x == m-1 && y == n-1) return true; // end\\n            if (visited[x][y]) return false;\\n            visited[x][y] = 1; \\n\\n            int dx {directions[dir][0]}, dy {directions[dir][1]};\\n            x += dx, y += dy;\\n\\n            if (!atValidPosition(x, y)) return false;\\n\\n            // after making sure the next position is valid\\n            // we need to check if we can make to the next position actually\\n\\n            // given current direction and next type of street\\n            // we can determine if next is reachable from current street\\n            // if it is reachable, we may change current direction according\\n            // to the type of the next street \\n            if ((dir = validMove(dir, grid[x][y])) == -1) return false;\\n        }\\n        return false;\\n    }\\n    int validMove(int dir, int nextType) \\n    {   // if move is invalid return -1\\n        switch (nextType) // down = 0, up = 1, right = 2, left = 3\\n        {\\n        case 1: // accept right or left direction, and do not change direction\\n            if (dir == right || dir == left) return dir; \\n            break;\\n\\n        case 2: // accept down or up direction, and do not change direction\\n            if (dir == down || dir == up) return dir;\\n            break;\\n\\n        case 3: // accept right and return down, or accept up and return left\\n            if (dir == right) return down;\\n            if (dir == up) return left;\\n            break;\\n\\n        case 4: // accept left and return down, or accept up and return right\\n            if (dir == left) return down;\\n            if (dir == up) return right;\\n            break;\\n\\n        case 5: // accept down and return left, or accept right and return up\\n            if (dir == down) return left;\\n            if (dir == right) return up;\\n            break;\\n        \\n        case 6: // accept down and return right, or accept left and return up\\n            if (dir == down) return right;\\n            if (dir == left) return up;\\n            break;\\n\\n        default:\\n            break;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    vector<vector<int>> directions {\\n        {1, 0}, {-1, 0}, {0, 1}, {0, -1}\\n    }; // down, up, right, left\\n    enum {\\n        down = 0, up = 1, right = 2, left = 3\\n    };\\n    bool atValidPosition(int x, int y)\\n    {\\n        return x >= 0 && y >= 0 && x < m && y < n;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n\\n        // we need to make sure the first street can connect downward or rightward\\n        int initType {grid[0][0]};\\n        if (initType == 5) return false;\\n        if (initType == 1 || initType == 6) return explore(grid, right);\\n        if (initType == 2 || initType == 3) return explore(grid, down);\\n        return explore(grid, down) || explore(grid, right);\\n    }\\n    bool explore(const vector<vector<int>>& grid, int dir)\\n    {\\n        int x {}, y {};\\n        vector<vector<int>> visited(m, vector(n, 0)); // to avoid cycles\\n        while (atValidPosition(x, y))\\n        {\\n            if (x == m-1 && y == n-1) return true; // end\\n            if (visited[x][y]) return false;\\n            visited[x][y] = 1; \\n\\n            int dx {directions[dir][0]}, dy {directions[dir][1]};\\n            x += dx, y += dy;\\n\\n            if (!atValidPosition(x, y)) return false;\\n\\n            // after making sure the next position is valid\\n            // we need to check if we can make to the next position actually\\n\\n            // given current direction and next type of street\\n            // we can determine if next is reachable from current street\\n            // if it is reachable, we may change current direction according\\n            // to the type of the next street \\n            if ((dir = validMove(dir, grid[x][y])) == -1) return false;\\n        }\\n        return false;\\n    }\\n    int validMove(int dir, int nextType) \\n    {   // if move is invalid return -1\\n        switch (nextType) // down = 0, up = 1, right = 2, left = 3\\n        {\\n        case 1: // accept right or left direction, and do not change direction\\n            if (dir == right || dir == left) return dir; \\n            break;\\n\\n        case 2: // accept down or up direction, and do not change direction\\n            if (dir == down || dir == up) return dir;\\n            break;\\n\\n        case 3: // accept right and return down, or accept up and return left\\n            if (dir == right) return down;\\n            if (dir == up) return left;\\n            break;\\n\\n        case 4: // accept left and return down, or accept up and return right\\n            if (dir == left) return down;\\n            if (dir == up) return right;\\n            break;\\n\\n        case 5: // accept down and return left, or accept right and return up\\n            if (dir == down) return left;\\n            if (dir == right) return up;\\n            break;\\n        \\n        case 6: // accept down and return right, or accept left and return up\\n            if (dir == down) return right;\\n            if (dir == left) return up;\\n            break;\\n\\n        default:\\n            break;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030384,
                "title": "dfs-simple-solution-with-comments-intuitive",
                "content": "# Intuition\\nThis looks like a graph problem we just need to figure out how to connect the cells\\n\\n# Approach\\nIf you are on a cell with street 1 then you can move to either left or right. If you chose to move left then your next cell must be either 1 or or 6 then only it will be connected. Similary if you chose to move right then next cell must be either 1 or 3 or 5.\\nThat\\'s how we can connect cells and solve it using DFS.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<char>>mp; //to map the streets with the direction they can lead\\n    unordered_map<char,vector<int>>dir; // this will map if you want to go to right which street must be there by which you can move to that direction\\n    unordered_map<char,vector<int>>change; // simply change in coordinates if you move to that direction\\n\\n//dfs\\n    bool dfs(vector<vector<int>>& grid,vector<vector<bool>>&vis,int row,int col){\\n        vis[row][col]=true;\\n        int n = grid.size(),m = grid[0].size();\\n        if(row==n-1 && col==m-1) return true;\\n        for(auto i:mp[grid[row][col]]){ //if the grid[row][col] is 1 then I can only move either to left or right similarly to others\\n            char d = i;\\n            int r = row+change[d][0]; // if I am going to left then this will be my coordinates change ie next cell will be r,c\\n            int c = col+change[d][1];\\n            if(r>=0 && r<n && c>=0 && c<m && !vis[r][c]){\\n                for(auto j:dir[d]){\\n                    if(grid[r][c]==j){ // to move left my next cell should be either 1,4,6 so I am checking if my [r][c] has any of these. \\n                        if(dfs(grid,vis,r,c)) return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        mp[1] ={\\'l\\',\\'r\\'}; // By 1 I can move either left or right.\\n        mp[2] ={\\'u\\',\\'d\\'}; // By 2 I can move either up or or down.\\n        mp[3] ={\\'l\\',\\'d\\'};\\n        mp[4] ={\\'r\\',\\'d\\'};\\n        mp[5] ={\\'u\\',\\'l\\'};\\n        mp[6] ={\\'u\\',\\'r\\'};\\n\\n        dir[\\'l\\'] = {1,4,6}; // I want to move left then the next cell should be either 1,4,6\\n        dir[\\'r\\'] = {1,3,5};\\n        dir[\\'u\\'] = {2,3,4};\\n        dir[\\'d\\'] = {2,5,6};\\n\\n        change[\\'l\\'] ={0,-1}; // if I move left my row col will be row+0,col-1\\n        change[\\'r\\'] ={0,1};\\n        change[\\'u\\'] ={-1,0};\\n        change[\\'d\\'] ={1,0};\\n\\n        int n = grid.size(),m = grid[0].size();\\n        vector<vector<bool>>vis(n,vector<bool>(m,false));\\n        return dfs(grid,vis,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<char>>mp; //to map the streets with the direction they can lead\\n    unordered_map<char,vector<int>>dir; // this will map if you want to go to right which street must be there by which you can move to that direction\\n    unordered_map<char,vector<int>>change; // simply change in coordinates if you move to that direction\\n\\n//dfs\\n    bool dfs(vector<vector<int>>& grid,vector<vector<bool>>&vis,int row,int col){\\n        vis[row][col]=true;\\n        int n = grid.size(),m = grid[0].size();\\n        if(row==n-1 && col==m-1) return true;\\n        for(auto i:mp[grid[row][col]]){ //if the grid[row][col] is 1 then I can only move either to left or right similarly to others\\n            char d = i;\\n            int r = row+change[d][0]; // if I am going to left then this will be my coordinates change ie next cell will be r,c\\n            int c = col+change[d][1];\\n            if(r>=0 && r<n && c>=0 && c<m && !vis[r][c]){\\n                for(auto j:dir[d]){\\n                    if(grid[r][c]==j){ // to move left my next cell should be either 1,4,6 so I am checking if my [r][c] has any of these. \\n                        if(dfs(grid,vis,r,c)) return true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        mp[1] ={\\'l\\',\\'r\\'}; // By 1 I can move either left or right.\\n        mp[2] ={\\'u\\',\\'d\\'}; // By 2 I can move either up or or down.\\n        mp[3] ={\\'l\\',\\'d\\'};\\n        mp[4] ={\\'r\\',\\'d\\'};\\n        mp[5] ={\\'u\\',\\'l\\'};\\n        mp[6] ={\\'u\\',\\'r\\'};\\n\\n        dir[\\'l\\'] = {1,4,6}; // I want to move left then the next cell should be either 1,4,6\\n        dir[\\'r\\'] = {1,3,5};\\n        dir[\\'u\\'] = {2,3,4};\\n        dir[\\'d\\'] = {2,5,6};\\n\\n        change[\\'l\\'] ={0,-1}; // if I move left my row col will be row+0,col-1\\n        change[\\'r\\'] ={0,1};\\n        change[\\'u\\'] ={-1,0};\\n        change[\\'d\\'] ={1,0};\\n\\n        int n = grid.size(),m = grid[0].size();\\n        vector<vector<bool>>vis(n,vector<bool>(m,false));\\n        return dfs(grid,vis,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029092,
                "title": "python-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool: \\n        n=len(grid)\\n        m=len(grid[0])\\n        a=[0]\\n        v=set() \\n         \\n        d={\\n            \\'down\\':[\\n                [2,3,4],[2,5,6]\\n            ],\\n            \\'right\\':[\\n                [1,4,6],[1,3,5]\\n            ],\\n            \\'up\\':[\\n                [2,5,6],[2,3,4]\\n            ],\\n            \\'left\\':[\\n                [1,3,5],[1,4,6]\\n            ]\\n        }   \\n\\n        def dfs(i,j):\\n            if (i,j) in v:\\n                return\\n            if i==n-1 and j==m-1:\\n                a[0]=1\\n                return\\n            v.add((i,j))\\n    \\n            if i-1>=0:\\n                if grid[i][j] in d[\\'up\\'][0] and grid[i-1][j] in d[\\'up\\'][1]:\\n                    dfs(i-1,j)\\n\\n            if i+1<n:\\n                if grid[i][j] in d[\\'down\\'][0] and grid[i+1][j] in d[\\'down\\'][1]:\\n                    dfs(i+1,j)\\n\\n            if j-1>=0:\\n                if grid[i][j] in d[\\'left\\'][0] and grid[i][j-1] in d[\\'left\\'][1]:\\n                    dfs(i,j-1)\\n\\n            if j+1<m:\\n                if grid[i][j] in d[\\'right\\'][0] and grid[i][j+1] in d[\\'right\\'][1]:\\n                    dfs(i,j+1)\\n\\n        dfs(0,0)\\n        return a[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool: \\n        n=len(grid)\\n        m=len(grid[0])\\n        a=[0]\\n        v=set() \\n         \\n        d={\\n            \\'down\\':[\\n                [2,3,4],[2,5,6]\\n            ],\\n            \\'right\\':[\\n                [1,4,6],[1,3,5]\\n            ],\\n            \\'up\\':[\\n                [2,5,6],[2,3,4]\\n            ],\\n            \\'left\\':[\\n                [1,3,5],[1,4,6]\\n            ]\\n        }   \\n\\n        def dfs(i,j):\\n            if (i,j) in v:\\n                return\\n            if i==n-1 and j==m-1:\\n                a[0]=1\\n                return\\n            v.add((i,j))\\n    \\n            if i-1>=0:\\n                if grid[i][j] in d[\\'up\\'][0] and grid[i-1][j] in d[\\'up\\'][1]:\\n                    dfs(i-1,j)\\n\\n            if i+1<n:\\n                if grid[i][j] in d[\\'down\\'][0] and grid[i+1][j] in d[\\'down\\'][1]:\\n                    dfs(i+1,j)\\n\\n            if j-1>=0:\\n                if grid[i][j] in d[\\'left\\'][0] and grid[i][j-1] in d[\\'left\\'][1]:\\n                    dfs(i,j-1)\\n\\n            if j+1<m:\\n                if grid[i][j] in d[\\'right\\'][0] and grid[i][j+1] in d[\\'right\\'][1]:\\n                    dfs(i,j+1)\\n\\n        dfs(0,0)\\n        return a[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016672,
                "title": "c-with-floodfill",
                "content": "# Intuition\\nuse floodfill and check current step and next step\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int iHeight;\\n    int iWidth;\\n    int bRet = false;\\n    void floodfill(vector<vector<int>>& grid, vector<vector<int>>& path, int i, int j, int pre_i, int pre_j)\\n    {\\n        if(i==iHeight-1 && j==iWidth-1) \\n        {\\n            bRet = true;\\n            return;\\n        }\\n        if(path[i][j] == 1 || bRet == true) return;\\n\\n        path[i][j]=1;\\n\\n        if(i-1>=0 && path[i-1][j] ==0 && (i-1 !=pre_i) && \\n(grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6)&&(grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4))\\n            floodfill(grid, path, i-1, j, i, j);\\n\\n        if(i+1<iHeight && path[i+1][j] ==0 && (i+1 !=pre_i) && \\n(grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4)&&(grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6))\\n            floodfill(grid, path, i+1, j, i, j);\\n\\n        if(j-1>=0 && path[i][j-1] ==0 && (j-1 !=pre_j) &&\\n(grid[i][j] == 1 || grid[i][j] == 3 || grid[i][j] == 5)&&(grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6))\\n            floodfill(grid, path, i, j-1, i, j);            \\n\\n        if(j+1<iWidth && path[i][j+1] ==0 && (j+1 !=pre_j) && \\n(grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6)&&(grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5))\\n            floodfill(grid, path, i, j+1, i, j);            \\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        iHeight = grid.size();\\n        iWidth = grid[0].size();\\n        vector<vector<int>> path(iHeight, vector<int>(iWidth, 0));\\n        floodfill(grid, path, 0, 0, -1, -1);\\n\\n        return bRet;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int iHeight;\\n    int iWidth;\\n    int bRet = false;\\n    void floodfill(vector<vector<int>>& grid, vector<vector<int>>& path, int i, int j, int pre_i, int pre_j)\\n    {\\n        if(i==iHeight-1 && j==iWidth-1) \\n        {\\n            bRet = true;\\n            return;\\n        }\\n        if(path[i][j] == 1 || bRet == true) return;\\n\\n        path[i][j]=1;\\n\\n        if(i-1>=0 && path[i-1][j] ==0 && (i-1 !=pre_i) && \\n(grid[i][j] == 2 || grid[i][j] == 5 || grid[i][j] == 6)&&(grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4))\\n            floodfill(grid, path, i-1, j, i, j);\\n\\n        if(i+1<iHeight && path[i+1][j] ==0 && (i+1 !=pre_i) && \\n(grid[i][j] == 2 || grid[i][j] == 3 || grid[i][j] == 4)&&(grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6))\\n            floodfill(grid, path, i+1, j, i, j);\\n\\n        if(j-1>=0 && path[i][j-1] ==0 && (j-1 !=pre_j) &&\\n(grid[i][j] == 1 || grid[i][j] == 3 || grid[i][j] == 5)&&(grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6))\\n            floodfill(grid, path, i, j-1, i, j);            \\n\\n        if(j+1<iWidth && path[i][j+1] ==0 && (j+1 !=pre_j) && \\n(grid[i][j] == 1 || grid[i][j] == 4 || grid[i][j] == 6)&&(grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5))\\n            floodfill(grid, path, i, j+1, i, j);            \\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        iHeight = grid.size();\\n        iWidth = grid[0].size();\\n        vector<vector<int>> path(iHeight, vector<int>(iWidth, 0));\\n        floodfill(grid, path, 0, 0, -1, -1);\\n\\n        return bRet;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974103,
                "title": "python-dfs-1159ms-beat-90",
                "content": "Standard iterative DFS. \\nCode is pretty much self-explanatory.\\nFor each direction each cell can go, check if we can go to that direction.\\nIf we can go to that direction, and the cell in that direction is not yet visited, push it onto the stack.\\nThe hardest part is to write clean and easy-to-read code :)\\n\\n# Complexity\\n- Time complexity: $$O(mn)$$\\n\\n- Space complexity: $$O(mn)$$\\n\\n\\n# Code\\n**Easy-to-understand version:**\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = {\\n            1: [\"LEFT\", \"RIGHT\"],\\n            2: [\"UP\", \"DOWN\"],\\n            3: [\"LEFT\", \"DOWN\"],\\n            4: [\"DOWN\", \"RIGHT\"],\\n            5: [\"LEFT\", \"UP\"],\\n            6: [\"UP\", \"RIGHT\"]\\n        }\\n        stack = deque()\\n        stack.append((0, 0, grid[0][0]))\\n        visited = set()\\n        while stack:\\n            curr_i, curr_j, curr_cell = stack.pop()\\n            if curr_i == m - 1 and curr_j == n - 1:\\n                return True\\n            visited.add((curr_i, curr_j))\\n            for direction in directions[curr_cell]:\\n                if direction == \"LEFT\":\\n                    i, j = curr_i, curr_j - 1\\n                    if j >= 0 and \"RIGHT\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n\\n                if direction == \"RIGHT\":\\n                    i, j = curr_i, curr_j + 1\\n                    if j < n and \"LEFT\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n\\n                if direction == \"UP\":\\n                    i, j = curr_i - 1, curr_j\\n                    if i >= 0 and \"DOWN\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n\\n                if direction == \"DOWN\":\\n                    i, j = curr_i + 1, curr_j\\n                    if i < m and \"UP\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n        return False\\n```\\n**Simplied Version:**\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        LEFT, RIGHT, UP, DOWN = (0, -1), (0, 1), (-1, 0), (1, 0)\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = {\\n            1: [LEFT, RIGHT],\\n            2: [UP, DOWN],\\n            3: [LEFT, DOWN],\\n            4: [DOWN, RIGHT],\\n            5: [LEFT, UP],\\n            6: [UP, RIGHT]\\n        }\\n        stack = deque()\\n        stack.append((0, 0, grid[0][0]))\\n        visited = set()\\n        while stack:\\n            curr_i, curr_j, curr_cell = stack.pop()\\n            if curr_i == m - 1 and curr_j == n - 1:\\n                return True\\n            visited.add((curr_i, curr_j))\\n            for di, dj in directions[curr_cell]:\\n                i, j = curr_i + di, curr_j + dj\\n                if 0 <= i and i < m and 0 <= j and j < n and (-di, -dj) in directions[grid[i][j]] and (i, j) not in visited:\\n                    stack.append((i, j, grid[i][j]))\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = {\\n            1: [\"LEFT\", \"RIGHT\"],\\n            2: [\"UP\", \"DOWN\"],\\n            3: [\"LEFT\", \"DOWN\"],\\n            4: [\"DOWN\", \"RIGHT\"],\\n            5: [\"LEFT\", \"UP\"],\\n            6: [\"UP\", \"RIGHT\"]\\n        }\\n        stack = deque()\\n        stack.append((0, 0, grid[0][0]))\\n        visited = set()\\n        while stack:\\n            curr_i, curr_j, curr_cell = stack.pop()\\n            if curr_i == m - 1 and curr_j == n - 1:\\n                return True\\n            visited.add((curr_i, curr_j))\\n            for direction in directions[curr_cell]:\\n                if direction == \"LEFT\":\\n                    i, j = curr_i, curr_j - 1\\n                    if j >= 0 and \"RIGHT\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n\\n                if direction == \"RIGHT\":\\n                    i, j = curr_i, curr_j + 1\\n                    if j < n and \"LEFT\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n\\n                if direction == \"UP\":\\n                    i, j = curr_i - 1, curr_j\\n                    if i >= 0 and \"DOWN\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n\\n                if direction == \"DOWN\":\\n                    i, j = curr_i + 1, curr_j\\n                    if i < m and \"UP\" in directions[grid[i][j]] and (i, j) not in visited:\\n                        stack.append((i, j, grid[i][j]))\\n        return False\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        LEFT, RIGHT, UP, DOWN = (0, -1), (0, 1), (-1, 0), (1, 0)\\n        m = len(grid)\\n        n = len(grid[0])\\n        directions = {\\n            1: [LEFT, RIGHT],\\n            2: [UP, DOWN],\\n            3: [LEFT, DOWN],\\n            4: [DOWN, RIGHT],\\n            5: [LEFT, UP],\\n            6: [UP, RIGHT]\\n        }\\n        stack = deque()\\n        stack.append((0, 0, grid[0][0]))\\n        visited = set()\\n        while stack:\\n            curr_i, curr_j, curr_cell = stack.pop()\\n            if curr_i == m - 1 and curr_j == n - 1:\\n                return True\\n            visited.add((curr_i, curr_j))\\n            for di, dj in directions[curr_cell]:\\n                i, j = curr_i + di, curr_j + dj\\n                if 0 <= i and i < m and 0 <= j and j < n and (-di, -dj) in directions[grid[i][j]] and (i, j) not in visited:\\n                    stack.append((i, j, grid[i][j]))\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972676,
                "title": "cleanest-and-most-intuitive-c-program-i-have-ever-written",
                "content": "# Intuition\\nSelf explanatory.\\n\\n# Approach\\nSelf explanatory.\\n\\n# Complexity\\n- Time complexity:\\nO(n**2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool valid(int i,int j, vector<vector<int >> &grid){\\n        if(i<0 || j<0 || i>grid.size()-1 || j>grid[0].size()-1) return 0;\\n        return 1;\\n    }\\n\\n    void DFS(vector<vector<int>>& grid, int i, int j){\\n\\n        //cout<<i<<\" \"<<j<<endl;\\n        if(i<0 || j<0 || i>grid.size()-1 || j>grid[0].size()-1 || grid[i][j]==-1) return;\\n\\n        else if(grid[i][j]==1){\\n            grid[i][j] = -1;\\n            if(valid(i,j-1, grid) && ( grid[i][j-1]==4 || grid[i][j-1]==6 || grid[i][j-1] == 1)) DFS(grid, i, j-1);\\n            if(valid(i,j+1, grid) && ( grid[i][j+1]==3 || grid[i][j+1]==5 || grid[i][j+1] == 1)) DFS(grid, i, j+1);\\n        }\\n\\n        else if(grid[i][j]==2){\\n            grid[i][j] = -1;\\n            if(valid(i-1,j, grid) && ( grid[i-1][j]==4 || grid[i-1][j]==3 || grid[i-1][j] == 2)) DFS(grid, i-1, j);\\n            if(valid(i+1,j, grid) && ( grid[i+1][j]==5 || grid[i+1][j]==6 || grid[i+1][j] == 2)) DFS(grid, i+1, j);\\n        }\\n\\n        else if(grid[i][j]==3){\\n            grid[i][j] = -1;\\n            if(valid(i,j-1, grid) && ( grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1] == 6)) DFS(grid, i, j-1);\\n            if(valid(i+1,j, grid) && ( grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j] == 6)) DFS(grid, i+1, j);\\n        }\\n\\n        else if(grid[i][j]==4){\\n            grid[i][j] = -1;\\n            if(valid(i,j+1, grid) && ( grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1] == 5)) DFS(grid, i, j+1);\\n            if(valid(i+1,j, grid) && ( grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j] == 6)) DFS(grid, i+1, j);\\n        }\\n\\n        else if(grid[i][j]==5){\\n            grid[i][j] = -1;\\n            if(valid(i-1,j, grid) && ( grid[i-1][j]==4 || grid[i-1][j]==3 || grid[i-1][j] == 2)) DFS(grid, i-1, j);\\n            if(valid(i,j-1, grid) && ( grid[i][j-1]==4 || grid[i][j-1]==1 || grid[i][j-1] == 6)) DFS(grid, i, j-1);\\n        }\\n\\n        else if(grid[i][j]==6){\\n            grid[i][j] = -1;\\n            if(valid(i-1,j, grid) && ( grid[i-1][j]==4 || grid[i-1][j]==3 || grid[i-1][j] == 2)) DFS(grid, i-1, j);\\n            if(valid(i,j+1, grid) && ( grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1] == 5)) DFS(grid, i, j+1);\\n        }\\n\\n    }\\n\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        DFS(grid, 0, 0);\\n        return grid[grid.size()-1][grid[0].size()-1] == -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool valid(int i,int j, vector<vector<int >> &grid){\\n        if(i<0 || j<0 || i>grid.size()-1 || j>grid[0].size()-1) return 0;\\n        return 1;\\n    }\\n\\n    void DFS(vector<vector<int>>& grid, int i, int j){\\n\\n        //cout<<i<<\" \"<<j<<endl;\\n        if(i<0 || j<0 || i>grid.size()-1 || j>grid[0].size()-1 || grid[i][j]==-1) return;\\n\\n        else if(grid[i][j]==1){\\n            grid[i][j] = -1;\\n            if(valid(i,j-1, grid) && ( grid[i][j-1]==4 || grid[i][j-1]==6 || grid[i][j-1] == 1)) DFS(grid, i, j-1);\\n            if(valid(i,j+1, grid) && ( grid[i][j+1]==3 || grid[i][j+1]==5 || grid[i][j+1] == 1)) DFS(grid, i, j+1);\\n        }\\n\\n        else if(grid[i][j]==2){\\n            grid[i][j] = -1;\\n            if(valid(i-1,j, grid) && ( grid[i-1][j]==4 || grid[i-1][j]==3 || grid[i-1][j] == 2)) DFS(grid, i-1, j);\\n            if(valid(i+1,j, grid) && ( grid[i+1][j]==5 || grid[i+1][j]==6 || grid[i+1][j] == 2)) DFS(grid, i+1, j);\\n        }\\n\\n        else if(grid[i][j]==3){\\n            grid[i][j] = -1;\\n            if(valid(i,j-1, grid) && ( grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1] == 6)) DFS(grid, i, j-1);\\n            if(valid(i+1,j, grid) && ( grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j] == 6)) DFS(grid, i+1, j);\\n        }\\n\\n        else if(grid[i][j]==4){\\n            grid[i][j] = -1;\\n            if(valid(i,j+1, grid) && ( grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1] == 5)) DFS(grid, i, j+1);\\n            if(valid(i+1,j, grid) && ( grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j] == 6)) DFS(grid, i+1, j);\\n        }\\n\\n        else if(grid[i][j]==5){\\n            grid[i][j] = -1;\\n            if(valid(i-1,j, grid) && ( grid[i-1][j]==4 || grid[i-1][j]==3 || grid[i-1][j] == 2)) DFS(grid, i-1, j);\\n            if(valid(i,j-1, grid) && ( grid[i][j-1]==4 || grid[i][j-1]==1 || grid[i][j-1] == 6)) DFS(grid, i, j-1);\\n        }\\n\\n        else if(grid[i][j]==6){\\n            grid[i][j] = -1;\\n            if(valid(i-1,j, grid) && ( grid[i-1][j]==4 || grid[i-1][j]==3 || grid[i-1][j] == 2)) DFS(grid, i-1, j);\\n            if(valid(i,j+1, grid) && ( grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1] == 5)) DFS(grid, i, j+1);\\n        }\\n\\n    }\\n\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        DFS(grid, 0, 0);\\n        return grid[grid.size()-1][grid[0].size()-1] == -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3953267,
                "title": "longest-bfs-ever-c-straightforward-if-else",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLiterally just went through every possibility that a path has to join with another path.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, pair<int,int>>> q;\\n        q.push({grid[0][0], {0,0}});\\n        vis[0][0] = 1;\\n        while(!q.empty()){\\n            auto it = q.front();\\n            int val = it.first;\\n            int row = it.second.first;\\n            int col = it.second.second;\\n            q.pop();\\n            if(val==1){\\n                if(col+1<n && vis[row][col+1]==0 && (grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1)){\\n                    vis[row][col+1]=1;\\n                    q.push({grid[row][col+1], {row, col+1}});\\n                }\\n                if(col-1>=0 && vis[row][col-1]==0 && (grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1)){\\n                    vis[row][col-1]=1;\\n                    q.push({grid[row][col-1], {row, col-1}});\\n                }\\n                \\n            }\\n            else if(val==2){\\n                if(row+1<m && vis[row+1][col]==0 && (grid[row+1][col]==5 || grid[row+1][col]==6 || grid[row+1][col]==2)){\\n                    vis[row+1][col]=1;\\n                    q.push({grid[row+1][col], {row+1, col}});\\n                }\\n                if(row-1>=0 && vis[row-1][col]==0 && (grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2)){\\n                    vis[row-1][col]=1;\\n                    q.push({grid[row-1][col], {row-1, col}});\\n                }\\n                \\n            }\\n            else if(val==3){\\n                if(row+1<m && vis[row+1][col]==0 && (grid[row+1][col]==5 || grid[row+1][col]==6 || grid[row+1][col]==2)){\\n                    vis[row+1][col]=1;\\n                    q.push({grid[row+1][col], {row+1, col}});\\n                }\\n                if(col-1>=0 && vis[row][col-1]==0 && (grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1)){\\n                    vis[row][col-1]=1;\\n                    q.push({grid[row][col-1], {row, col-1}});\\n                }\\n                \\n            }\\n            else if(val==4){\\n                if(col+1<n && vis[row][col+1]==0 && (grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1)){\\n                    vis[row][col+1] = 1;\\n                    q.push({grid[row][col+1], {row, col+1}});\\n                }\\n                if(row+1<m && vis[row+1][col]==0 && (grid[row+1][col]==6 || grid[row+1][col]==5 || grid[row+1][col]==2)){\\n                    vis[row+1][col] = 1;\\n                    q.push({grid[row+1][col], {row+1, col}});\\n                }\\n                \\n            }\\n            else if(val==5){\\n                if(row-1>=0 && vis[row-1][col]==0 && (grid[row-1][col]==3 || grid[row-1][col]==4 || grid[row-1][col]==2)){\\n                    vis[row-1][col] = 1;\\n                    q.push({grid[row-1][col], {row-1, col}});\\n                }\\n                if(col-1>=0 && vis[row][col-1]==0 && (grid[row][col-1]==6 || grid[row][col-1]==4 || grid[row][col-1]==1)){\\n                    vis[row][col-1]=1;\\n                    q.push({grid[row][col-1], {row, col-1}});\\n                }\\n                \\n            }\\n            else if(val==6){\\n                if(col+1<n && vis[row][col+1]==0 && (grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1)){\\n                    vis[row][col+1]=1;\\n                    q.push({grid[row][col+1], {row, col+1}});\\n                }\\n                if(row-1>=0 && vis[row-1][col]==0 && (grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2)){\\n                    vis[row-1][col]=1;\\n                    q.push({grid[row-1][col], {row-1, col}});\\n                }\\n                \\n            }\\n            \\n        }\\n        if(vis[m-1][n-1]==1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n        queue<pair<int, pair<int,int>>> q;\\n        q.push({grid[0][0], {0,0}});\\n        vis[0][0] = 1;\\n        while(!q.empty()){\\n            auto it = q.front();\\n            int val = it.first;\\n            int row = it.second.first;\\n            int col = it.second.second;\\n            q.pop();\\n            if(val==1){\\n                if(col+1<n && vis[row][col+1]==0 && (grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1)){\\n                    vis[row][col+1]=1;\\n                    q.push({grid[row][col+1], {row, col+1}});\\n                }\\n                if(col-1>=0 && vis[row][col-1]==0 && (grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1)){\\n                    vis[row][col-1]=1;\\n                    q.push({grid[row][col-1], {row, col-1}});\\n                }\\n                \\n            }\\n            else if(val==2){\\n                if(row+1<m && vis[row+1][col]==0 && (grid[row+1][col]==5 || grid[row+1][col]==6 || grid[row+1][col]==2)){\\n                    vis[row+1][col]=1;\\n                    q.push({grid[row+1][col], {row+1, col}});\\n                }\\n                if(row-1>=0 && vis[row-1][col]==0 && (grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2)){\\n                    vis[row-1][col]=1;\\n                    q.push({grid[row-1][col], {row-1, col}});\\n                }\\n                \\n            }\\n            else if(val==3){\\n                if(row+1<m && vis[row+1][col]==0 && (grid[row+1][col]==5 || grid[row+1][col]==6 || grid[row+1][col]==2)){\\n                    vis[row+1][col]=1;\\n                    q.push({grid[row+1][col], {row+1, col}});\\n                }\\n                if(col-1>=0 && vis[row][col-1]==0 && (grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1)){\\n                    vis[row][col-1]=1;\\n                    q.push({grid[row][col-1], {row, col-1}});\\n                }\\n                \\n            }\\n            else if(val==4){\\n                if(col+1<n && vis[row][col+1]==0 && (grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1)){\\n                    vis[row][col+1] = 1;\\n                    q.push({grid[row][col+1], {row, col+1}});\\n                }\\n                if(row+1<m && vis[row+1][col]==0 && (grid[row+1][col]==6 || grid[row+1][col]==5 || grid[row+1][col]==2)){\\n                    vis[row+1][col] = 1;\\n                    q.push({grid[row+1][col], {row+1, col}});\\n                }\\n                \\n            }\\n            else if(val==5){\\n                if(row-1>=0 && vis[row-1][col]==0 && (grid[row-1][col]==3 || grid[row-1][col]==4 || grid[row-1][col]==2)){\\n                    vis[row-1][col] = 1;\\n                    q.push({grid[row-1][col], {row-1, col}});\\n                }\\n                if(col-1>=0 && vis[row][col-1]==0 && (grid[row][col-1]==6 || grid[row][col-1]==4 || grid[row][col-1]==1)){\\n                    vis[row][col-1]=1;\\n                    q.push({grid[row][col-1], {row, col-1}});\\n                }\\n                \\n            }\\n            else if(val==6){\\n                if(col+1<n && vis[row][col+1]==0 && (grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1)){\\n                    vis[row][col+1]=1;\\n                    q.push({grid[row][col+1], {row, col+1}});\\n                }\\n                if(row-1>=0 && vis[row-1][col]==0 && (grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2)){\\n                    vis[row-1][col]=1;\\n                    q.push({grid[row-1][col], {row-1, col}});\\n                }\\n                \\n            }\\n            \\n        }\\n        if(vis[m-1][n-1]==1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947025,
                "title": "python-bfs-with-complicated-next-state-calculation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinding a path through a maze can be done using the following schema for a Breadth-First Search (BFS):\\n1. Pick starting point and put in queue\\n2. While the queue is not empty, take current point\\n3. If current point equals stopping point, return True\\n4. Find successor(s) to current point and put in queue\\n5. If queue is empty, return False\\n\\nAmong these steps, number 4 -- finding successor points -- is the trickiest part:  We assume that a queue entry consists of *two* parts:  A point to move into, and a direction (N, W, S, E) to move\\ninto the point.  Given the point, we can look up its street configuration (1-6) and from that we can determine what the next point will be *and* what direction to move into it.  Then, that next point must be checked for validity:  Has it not been visited yet, and is it within the bounds of the ```grid```.\\n\\nThere\\'s one further wrinkle on step number 4, namely what to do about the ```start_point```:  We don\\'t really have a direction that we entered that point, so we look at the street configuration in ```start_point``` and check *both* of its entrances/exits for validity.  Generally, there will be 0, 1 or 2 successor points.  If it\\'s 0, then we\\'re done and return ```False```; otherwise, we push the successor(s) into the queue and start the BFS traversal.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we encode the information about the problem like:  for each street configuration, what two directions does its two entrances/exits face.  Second, we look at the first point\\'s street configuration to determine the 0, 1, or 2 entrance/exit to push in the queue.\\n\\nThird, we enter the BFS loop following the schema in Intuition.  We pop the current square and entry direction from the queue, then see whether we\\'ve reach the ```stopping_point```.  If not, then determine which exit direction we\\'ll take, see if it\\'s valid, and if so, push it in the queue.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn the worst case, the path from the start point to the stopping point passes through every square in the grid, and each square must be pushed, popped, and processed.  Thus, the time complexity is proportional to the number of grid points, which is $$O(n*m)$$.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIgnoring the input (```grid```), the only structure that may grow with the input is the ```queue```.  At worst (mainly in degenerate cases) the ```queue``` will have to hold $$O(n*m)$$ entries, hence this is the overall space complexity.\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def hasValidPath(self, grid: list[list[int]]) -> bool:\\n        nrows = len( grid ); ncols = len( grid[ 0 ] )\\n        # Directions:\\n        N = 0; W = 1; S = 2; E = 3\\n        dir_names = { N : \"N\", W : \"W\", S : \"S\", E : \"E\" }\\n        streets = { 1: (W, E), 2: (N, S), 3: (W, S), 4: (S, E), 5: (N, W),  6: (N, E)  }\\n        otherDirs = {N: S, W: E, S: N, E: W}\\n        self.moves = {N: (-1, 0), W: (0, -1), S: (1, 0), E: (0, 1)}\\n        visited = set()\\n\\n        # Do a breadth-first search, starting at grid square (0,0); this\\n        # requires a little extra work to figure out what the exit is,\\n        # based on the blockage to the North and West.\\n        start_square = (0, 0)\\n        stop_square = (len(grid) - 1, len(grid[0]) - 1 )\\n        if start_square == stop_square:\\n            return True\\n        visited.add(start_square)\\n        queue = []\\n        start_street = grid[0][0]\\n        if start_street == 5:  # Stuck in the corner!\\n            return False\\n        for street_port in streets[start_street]:\\n            dir_name = dir_names[ street_port ]\\n            if street_port == S:\\n                next_square = (1, 0)\\n                next_row, next_col = next_square\\n                if (0 <= next_row < nrows) and (0 <= next_col < ncols):\\n                    next_entrance = N\\n                    next_street = grid[ next_row ][ next_col ]\\n                    next_street_ports = streets[ next_street ]\\n                    if next_entrance in next_street_ports:\\n                        queue.append((next_square, next_entrance))\\n                        visited.add(next_square)\\n            elif street_port == E:\\n                next_square = (0, 1)\\n                next_row, next_col = next_square\\n                if ( 0 <= next_row < nrows ) and ( 0 <= next_col < ncols ):\\n                    next_entrance = W\\n                    next_street = grid[ next_row ][ next_col ]\\n                    next_street_ports = streets[ next_street ]\\n                    if next_entrance in next_street_ports:\\n                        queue.append((next_square, next_entrance))\\n                        visited.add(next_square)\\n        # OK, we\\'ve put one or two next square into the queue.  Now,\\n        # start going through the queue:\\n        while queue:\\n            curr_square, curr_entrance = queue.pop(0)\\n            if curr_square == stop_square:\\n                return True\\n            else:\\n                curr_row, curr_col = curr_square\\n                curr_street = grid[ curr_row ][ curr_col ]\\n                street_port1, street_port2 = streets[curr_street]\\n                if street_port1 == curr_entrance:\\n                    curr_exit = street_port2\\n                elif street_port2 == curr_entrance:\\n                    curr_exit = street_port1\\n                next_entrance = otherDirs[curr_exit]\\n                next_square = self.moveFromSquare(curr_square, curr_exit)\\n                next_row, next_col = next_square\\n                # See if \"next_square\" is OK to move into; if so, put it in the queue:\\n                if ( next_square not in visited ):\\n                    if ( 0 <= next_row < nrows ):\\n                        if ( 0 <= next_col < ncols ):\\n                            next_street = grid[next_row][next_col]\\n                            next_ports = streets[next_street]\\n                            if ( next_entrance in next_ports ):\\n                                queue.append( ( next_square, next_entrance ) )\\n                                visited.add( next_square )\\n        return False\\n    # Given \"curr_square\" and \"curr_exit\" direction from it, return\\n    # the (row, col) of the square to move to:\\n    def moveFromSquare(self, curr_square, curr_exit):\\n        d_row, d_col = self.moves[curr_exit]\\n        result = (curr_square[0] + d_row, curr_square[1] + d_col)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```grid```\n```start_point```\n```start_point```\n```False```\n```stopping_point```\n```grid```\n```queue```\n```queue```\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def hasValidPath(self, grid: list[list[int]]) -> bool:\\n        nrows = len( grid ); ncols = len( grid[ 0 ] )\\n        # Directions:\\n        N = 0; W = 1; S = 2; E = 3\\n        dir_names = { N : \"N\", W : \"W\", S : \"S\", E : \"E\" }\\n        streets = { 1: (W, E), 2: (N, S), 3: (W, S), 4: (S, E), 5: (N, W),  6: (N, E)  }\\n        otherDirs = {N: S, W: E, S: N, E: W}\\n        self.moves = {N: (-1, 0), W: (0, -1), S: (1, 0), E: (0, 1)}\\n        visited = set()\\n\\n        # Do a breadth-first search, starting at grid square (0,0); this\\n        # requires a little extra work to figure out what the exit is,\\n        # based on the blockage to the North and West.\\n        start_square = (0, 0)\\n        stop_square = (len(grid) - 1, len(grid[0]) - 1 )\\n        if start_square == stop_square:\\n            return True\\n        visited.add(start_square)\\n        queue = []\\n        start_street = grid[0][0]\\n        if start_street == 5:  # Stuck in the corner!\\n            return False\\n        for street_port in streets[start_street]:\\n            dir_name = dir_names[ street_port ]\\n            if street_port == S:\\n                next_square = (1, 0)\\n                next_row, next_col = next_square\\n                if (0 <= next_row < nrows) and (0 <= next_col < ncols):\\n                    next_entrance = N\\n                    next_street = grid[ next_row ][ next_col ]\\n                    next_street_ports = streets[ next_street ]\\n                    if next_entrance in next_street_ports:\\n                        queue.append((next_square, next_entrance))\\n                        visited.add(next_square)\\n            elif street_port == E:\\n                next_square = (0, 1)\\n                next_row, next_col = next_square\\n                if ( 0 <= next_row < nrows ) and ( 0 <= next_col < ncols ):\\n                    next_entrance = W\\n                    next_street = grid[ next_row ][ next_col ]\\n                    next_street_ports = streets[ next_street ]\\n                    if next_entrance in next_street_ports:\\n                        queue.append((next_square, next_entrance))\\n                        visited.add(next_square)\\n        # OK, we\\'ve put one or two next square into the queue.  Now,\\n        # start going through the queue:\\n        while queue:\\n            curr_square, curr_entrance = queue.pop(0)\\n            if curr_square == stop_square:\\n                return True\\n            else:\\n                curr_row, curr_col = curr_square\\n                curr_street = grid[ curr_row ][ curr_col ]\\n                street_port1, street_port2 = streets[curr_street]\\n                if street_port1 == curr_entrance:\\n                    curr_exit = street_port2\\n                elif street_port2 == curr_entrance:\\n                    curr_exit = street_port1\\n                next_entrance = otherDirs[curr_exit]\\n                next_square = self.moveFromSquare(curr_square, curr_exit)\\n                next_row, next_col = next_square\\n                # See if \"next_square\" is OK to move into; if so, put it in the queue:\\n                if ( next_square not in visited ):\\n                    if ( 0 <= next_row < nrows ):\\n                        if ( 0 <= next_col < ncols ):\\n                            next_street = grid[next_row][next_col]\\n                            next_ports = streets[next_street]\\n                            if ( next_entrance in next_ports ):\\n                                queue.append( ( next_square, next_entrance ) )\\n                                visited.add( next_square )\\n        return False\\n    # Given \"curr_square\" and \"curr_exit\" direction from it, return\\n    # the (row, col) of the square to move to:\\n    def moveFromSquare(self, curr_square, curr_exit):\\n        d_row, d_col = self.moves[curr_exit]\\n        result = (curr_square[0] + d_row, curr_square[1] + d_col)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936607,
                "title": "c-easy-clean-bfs-understandable",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     bool b=0;\\n     vector<vector<int>> w;\\n  void t(vector<vector<int>>& v,int i,int j,int m,int n)\\n        {\\n          if(i<0 || j<0 || i>=m || j>=n || w[i][j]) return ;\\n          if(i==v.size()-1 && j==v[0].size()-1)\\n          {\\n              b=1;\\n              return ;\\n          }   \\n          w[i][j]=1;\\n         if(v[i][j]==1 && j+1<n && (v[i][j+1]==3 || v[i][j+1]==1 || v[i][j+1]==5))\\n         t(v,i,j+1,m,n);\\n         \\n         if(v[i][j]==1 && j-1>=0 && (v[i][j-1]==4 || v[i][j-1]==6 || v[i][j-1]==1))\\n         t(v,i,j-1,m,n);\\n\\n         if(v[i][j]==2 && i-1>=0 && (v[i-1][j]==2 || v[i-1][j]==3 || v[i-1][j]==4))\\n         t(v,i-1,j,m,n);\\n         \\n         if(v[i][j]==2 && i+1<m && (v[i+1][j]==2 || v[i+1][j]==5 || v[i+1][j]==6))\\n         t(v,i+1,j,m,n);\\n\\n         if(v[i][j]==3 && i+1<m && (v[i+1][j]==2 || v[i+1][j]==5 || v[i+1][j]==6))\\n         t(v,i+1,j,m,n);\\n\\n         if(v[i][j]==3 && j-1>=0 && (v[i][j-1]==4 || v[i][j-1]==1 || v[i][j-1]==6))\\n         t(v,i,j-1,m,n);\\n\\n         if(v[i][j]==4 && j+1<n && (v[i][j+1]==3 || v[i][j+1]==1 || v[i][j+1]==5))\\n         t(v,i,j+1,m,n);\\n\\n         if(v[i][j]==4 && i+1<m && (v[i+1][j]==2 || v[i+1][j]==5 || v[i+1][j]==6))\\n         t(v,i+1,j,m,n);\\n\\n         if(v[i][j]==5 && i-1>=0 && (v[i-1][j]==2 || v[i-1][j]==3 || v[i-1][j]==4))\\n         t(v,i-1,j,m,n);\\n\\n         if(v[i][j]==5 && j-1>=0 && (v[i][j-1]==4 || v[i][j-1]==1 || v[i][j-1]==6))\\n         t(v,i,j-1,m,n);\\n\\n         if(v[i][j]==6 && i-1>=0 && (v[i-1][j]==2 || v[i-1][j]==3 || v[i-1][j]==4))\\n         t(v,i-1,j,m,n);\\n\\n         if(v[i][j]==6 && j+1<n && (v[i][j+1]==3 || v[i][j+1]==1 || v[i][j+1]==5))\\n         t(v,i,j+1,m,n);\\n         }\\n\\n    bool hasValidPath(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size();\\n        vector<vector<int>> h(m+1,vector<int> (n+1,0));\\n        w=h;\\n\\n        t(g,0,0,m,n);\\n\\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool b=0;\\n     vector<vector<int>> w;\\n  void t(vector<vector<int>>& v,int i,int j,int m,int n)\\n        {\\n          if(i<0 || j<0 || i>=m || j>=n || w[i][j]) return ;\\n          if(i==v.size()-1 && j==v[0].size()-1)\\n          {\\n              b=1;\\n              return ;\\n          }   \\n          w[i][j]=1;\\n         if(v[i][j]==1 && j+1<n && (v[i][j+1]==3 || v[i][j+1]==1 || v[i][j+1]==5))\\n         t(v,i,j+1,m,n);\\n         \\n         if(v[i][j]==1 && j-1>=0 && (v[i][j-1]==4 || v[i][j-1]==6 || v[i][j-1]==1))\\n         t(v,i,j-1,m,n);\\n\\n         if(v[i][j]==2 && i-1>=0 && (v[i-1][j]==2 || v[i-1][j]==3 || v[i-1][j]==4))\\n         t(v,i-1,j,m,n);\\n         \\n         if(v[i][j]==2 && i+1<m && (v[i+1][j]==2 || v[i+1][j]==5 || v[i+1][j]==6))\\n         t(v,i+1,j,m,n);\\n\\n         if(v[i][j]==3 && i+1<m && (v[i+1][j]==2 || v[i+1][j]==5 || v[i+1][j]==6))\\n         t(v,i+1,j,m,n);\\n\\n         if(v[i][j]==3 && j-1>=0 && (v[i][j-1]==4 || v[i][j-1]==1 || v[i][j-1]==6))\\n         t(v,i,j-1,m,n);\\n\\n         if(v[i][j]==4 && j+1<n && (v[i][j+1]==3 || v[i][j+1]==1 || v[i][j+1]==5))\\n         t(v,i,j+1,m,n);\\n\\n         if(v[i][j]==4 && i+1<m && (v[i+1][j]==2 || v[i+1][j]==5 || v[i+1][j]==6))\\n         t(v,i+1,j,m,n);\\n\\n         if(v[i][j]==5 && i-1>=0 && (v[i-1][j]==2 || v[i-1][j]==3 || v[i-1][j]==4))\\n         t(v,i-1,j,m,n);\\n\\n         if(v[i][j]==5 && j-1>=0 && (v[i][j-1]==4 || v[i][j-1]==1 || v[i][j-1]==6))\\n         t(v,i,j-1,m,n);\\n\\n         if(v[i][j]==6 && i-1>=0 && (v[i-1][j]==2 || v[i-1][j]==3 || v[i-1][j]==4))\\n         t(v,i-1,j,m,n);\\n\\n         if(v[i][j]==6 && j+1<n && (v[i][j+1]==3 || v[i][j+1]==1 || v[i][j+1]==5))\\n         t(v,i,j+1,m,n);\\n         }\\n\\n    bool hasValidPath(vector<vector<int>>& g) {\\n        int m=g.size(),n=g[0].size();\\n        vector<vector<int>> h(m+1,vector<int> (n+1,0));\\n        w=h;\\n\\n        t(g,0,0,m,n);\\n\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935860,
                "title": "cpp-implementation-beats-98-memory-beats-95-time",
                "content": "## **``v[a][b][c]`` denotes that one can move from sheet ``a`` to sheet ``c`` by taking action ``b``.**\\n\\n**Conventions used for moves are as :**\\n1. ``left -> 0``.\\n2. ``right -> 1``.\\n3. ``up -> 2``.\\n4. ``down -> 3``.\\n\\nFor example,``v[1][0][4]``denotes one can move from ``sheet1`` to ``sheet4`` by taking ``left`` turn.\\n\\nThis pre definition helps us to determine the safe move from the current sheets to its adjacents, and we keep on doing ``BFS`` untill we reach at that sheet from where we can\\'t get safe path.\\n\\n\\nAt this node we\\'ll check whether it is bottom rightmost sheet or not.\\n\\nIf Yes, return``true``else return ``false``. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        vector<vector<vector<int>>> v(7, vector<vector<int>> (4 , vector<int>(7, 0)));\\n        v[1][0][4]=1;\\n        v[1][0][6]=1;                        \\n        v[1][0][1]=1;                        // 0->left\\n                                             // 1->right\\n        v[1][1][1]=1;                        //2->up\\n        v[1][1][3]=1;                        //3->down\\n        v[1][1][5]=1;\\n\\n        v[2][2][2]=1;\\n        v[2][2][3]=1;\\n        v[2][2][4]=1;\\n\\n        v[2][3][2]=1;\\n        v[2][3][5]=1;\\n        v[2][3][6]=1;\\n\\n        v[3][0][1]=1;\\n        v[3][0][4]=1;\\n        v[3][0][6]=1;\\n\\n        v[3][3][2]=1;\\n        v[3][3][6]=1;\\n        v[3][3][5]=1;\\n\\n        v[4][3][2]=1;\\n        v[4][3][6]=1;\\n        v[4][3][5]=1;\\n\\n        v[4][1][1]=1;\\n        v[4][1][3]=1;\\n        v[4][1][5]=1;\\n\\n        v[5][0][1]=1;\\n        v[5][0][4]=1;\\n        v[5][0][6]=1;\\n\\n        v[5][2][2]=1;\\n        v[5][2][3]=1;\\n        v[5][2][4]=1;\\n\\n        v[6][2][2]=1;\\n        v[6][2][3]=1;\\n        v[6][2][4]=1;\\n\\n        v[6][1][1]=1;\\n        v[6][1][3]=1;\\n        v[6][1][5]=1;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        grid[0][0]=-grid[0][0];\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            int sheet=-grid[x][y];\\n            if(x==m-1 && y==n-1)return true;\\n            if(y-1>=0){\\n                if(grid[x][y-1]>0 && v[sheet][0][grid[x][y-1]]){\\n                    q.push({x,y-1});\\n                    grid[x][y-1] = -grid[x][y-1];\\n                }\\n            }\\n            if(y+1<n){\\n                if(grid[x][y+1]>0 && v[sheet][1][grid[x][y+1]]){\\n                    q.push({x,y+1});\\n                    grid[x][y+1] = -grid[x][y+1];\\n                }\\n            }\\n            if(x-1>=0){\\n                if(grid[x-1][y]>0 && v[sheet][2][grid[x-1][y]]){\\n                    q.push({x-1,y});\\n                    grid[x-1][y] = -grid[x-1][y];\\n                }\\n            }\\n            if(x+1<m){\\n                if(grid[x+1][y]>0 && v[sheet][3][grid[x+1][y]]){\\n                    q.push({x+1,y});\\n                    grid[x+1][y] = -grid[x+1][y];\\n                }\\n            }\\n        }\\n    return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        vector<vector<vector<int>>> v(7, vector<vector<int>> (4 , vector<int>(7, 0)));\\n        v[1][0][4]=1;\\n        v[1][0][6]=1;                        \\n        v[1][0][1]=1;                        // 0->left\\n                                             // 1->right\\n        v[1][1][1]=1;                        //2->up\\n        v[1][1][3]=1;                        //3->down\\n        v[1][1][5]=1;\\n\\n        v[2][2][2]=1;\\n        v[2][2][3]=1;\\n        v[2][2][4]=1;\\n\\n        v[2][3][2]=1;\\n        v[2][3][5]=1;\\n        v[2][3][6]=1;\\n\\n        v[3][0][1]=1;\\n        v[3][0][4]=1;\\n        v[3][0][6]=1;\\n\\n        v[3][3][2]=1;\\n        v[3][3][6]=1;\\n        v[3][3][5]=1;\\n\\n        v[4][3][2]=1;\\n        v[4][3][6]=1;\\n        v[4][3][5]=1;\\n\\n        v[4][1][1]=1;\\n        v[4][1][3]=1;\\n        v[4][1][5]=1;\\n\\n        v[5][0][1]=1;\\n        v[5][0][4]=1;\\n        v[5][0][6]=1;\\n\\n        v[5][2][2]=1;\\n        v[5][2][3]=1;\\n        v[5][2][4]=1;\\n\\n        v[6][2][2]=1;\\n        v[6][2][3]=1;\\n        v[6][2][4]=1;\\n\\n        v[6][1][1]=1;\\n        v[6][1][3]=1;\\n        v[6][1][5]=1;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        grid[0][0]=-grid[0][0];\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            int sheet=-grid[x][y];\\n            if(x==m-1 && y==n-1)return true;\\n            if(y-1>=0){\\n                if(grid[x][y-1]>0 && v[sheet][0][grid[x][y-1]]){\\n                    q.push({x,y-1});\\n                    grid[x][y-1] = -grid[x][y-1];\\n                }\\n            }\\n            if(y+1<n){\\n                if(grid[x][y+1]>0 && v[sheet][1][grid[x][y+1]]){\\n                    q.push({x,y+1});\\n                    grid[x][y+1] = -grid[x][y+1];\\n                }\\n            }\\n            if(x-1>=0){\\n                if(grid[x-1][y]>0 && v[sheet][2][grid[x-1][y]]){\\n                    q.push({x-1,y});\\n                    grid[x-1][y] = -grid[x-1][y];\\n                }\\n            }\\n            if(x+1<m){\\n                if(grid[x+1][y]>0 && v[sheet][3][grid[x+1][y]]){\\n                    q.push({x+1,y});\\n                    grid[x+1][y] = -grid[x+1][y];\\n                }\\n            }\\n        }\\n    return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896427,
                "title": "c-beats-99-25-and-super-concise-solution-with-explanation",
                "content": "# Intuition\\nCheck arrival at current cell is possible or not and then continue the path in possible ways as per current cell\\'s alignment\\n# Approach\\n1. From previous cell we arrived at curren cell. We check if any path is possible from the directions we used to arrive at current cell from previous cell\\n2. Invalidate current cell as it is visited\\n3. Look out for valid path emerging out of current cell and pass on the **directions** used to arrive at next cell\\n# Complexity\\n- Time complexity:\\nDFS approach - O(m*n)\\n\\n- Space complexity:\\nOccupied by the variables in the recursive calls - O(m*n)\\nNo \\'visited\\' matrix required here saving lots of memory!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m, n, temp;\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m=grid.size(); n=grid[0].size();\\n        int i=0, j=0;\\n        return helper(0, 0, 2, 2, grid);// passed 2 as it only matters if hdir and vdir are in {-1,0,1}\\n    }\\n    // hdir, vdir => direction in which the CURRENT CELL is APPROACHED FROM PREVIOUS CELL\\n    // if approached from top then vertical direction = -1\\n    // approached from bottom then vertical direction = 1\\n    // appproached from left then horizontal direction = 1\\n    // approached from right then horizontal direction = -1\\n    bool helper(int i, int j, int hdir, int vdir, vector<vector<int>>& grid){\\n        // if outliers then return false\\n        if(i<0 || i>=m || j<0 || j>=n || grid[i][j] == 0) return false;\\n        temp = grid[i][j];\\n        // check if the way currrent cell is approached, path is possible or not\\n        if((temp == 1 && (vdir==1 || vdir==-1)) // arriving from bottom or top is invalid\\n        || (temp == 2 && (hdir==-1 || hdir==1)) // arriving from right or left is invalid\\n        || (temp == 3 && (hdir==-1 || vdir==-1)) // arriving from right or up is invalid\\n        || (temp == 4 && (hdir==1 || vdir==-1)) // arriving from left or up is invalid\\n        || (temp == 5 && (hdir==-1 || vdir==1)) // arriving from right or down is invalid\\n        || (temp == 6 && (hdir==1 || vdir==1))) // arriving from left or down is invalid\\n            return false;\\n        // if approach is valid and we reached bottom right cell return true\\n        if(i==m-1 && j==n-1) return true;\\n        // assign 0 to already approached cell to mark it as VISITED\\n        grid[i][j] = 0;\\n        // as per current cell, try all possible paths with direction which is selected\\n        if(temp == 1) return helper(i, j+1, 1, 0, grid) || helper(i, j-1, -1, 0, grid);\\n        if(temp == 2) return helper(i-1, j, 0, 1, grid) || helper(i+1, j, 0, -1, grid);\\n        if(temp == 3) return helper(i, j-1, -1, 0, grid)|| helper(i+1, j, 0, -1, grid);\\n        if(temp == 4) return helper(i, j+1, 1, 0, grid) || helper(i+1, j, 0, -1, grid);\\n        if(temp == 5) return helper(i-1, j, 0, 1, grid) || helper(i, j-1, -1, 0, grid);\\n        if(temp == 6) return helper(i-1, j, 0, 1, grid) || helper(i, j+1, 1, 0, grid);\\n        // retain original value in recursion if no solution is found\\n        grid[i][j] = temp;\\n        // no solution so return false\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n, temp;\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m=grid.size(); n=grid[0].size();\\n        int i=0, j=0;\\n        return helper(0, 0, 2, 2, grid);// passed 2 as it only matters if hdir and vdir are in {-1,0,1}\\n    }\\n    // hdir, vdir => direction in which the CURRENT CELL is APPROACHED FROM PREVIOUS CELL\\n    // if approached from top then vertical direction = -1\\n    // approached from bottom then vertical direction = 1\\n    // appproached from left then horizontal direction = 1\\n    // approached from right then horizontal direction = -1\\n    bool helper(int i, int j, int hdir, int vdir, vector<vector<int>>& grid){\\n        // if outliers then return false\\n        if(i<0 || i>=m || j<0 || j>=n || grid[i][j] == 0) return false;\\n        temp = grid[i][j];\\n        // check if the way currrent cell is approached, path is possible or not\\n        if((temp == 1 && (vdir==1 || vdir==-1)) // arriving from bottom or top is invalid\\n        || (temp == 2 && (hdir==-1 || hdir==1)) // arriving from right or left is invalid\\n        || (temp == 3 && (hdir==-1 || vdir==-1)) // arriving from right or up is invalid\\n        || (temp == 4 && (hdir==1 || vdir==-1)) // arriving from left or up is invalid\\n        || (temp == 5 && (hdir==-1 || vdir==1)) // arriving from right or down is invalid\\n        || (temp == 6 && (hdir==1 || vdir==1))) // arriving from left or down is invalid\\n            return false;\\n        // if approach is valid and we reached bottom right cell return true\\n        if(i==m-1 && j==n-1) return true;\\n        // assign 0 to already approached cell to mark it as VISITED\\n        grid[i][j] = 0;\\n        // as per current cell, try all possible paths with direction which is selected\\n        if(temp == 1) return helper(i, j+1, 1, 0, grid) || helper(i, j-1, -1, 0, grid);\\n        if(temp == 2) return helper(i-1, j, 0, 1, grid) || helper(i+1, j, 0, -1, grid);\\n        if(temp == 3) return helper(i, j-1, -1, 0, grid)|| helper(i+1, j, 0, -1, grid);\\n        if(temp == 4) return helper(i, j+1, 1, 0, grid) || helper(i+1, j, 0, -1, grid);\\n        if(temp == 5) return helper(i-1, j, 0, 1, grid) || helper(i, j-1, -1, 0, grid);\\n        if(temp == 6) return helper(i-1, j, 0, 1, grid) || helper(i, j+1, 1, 0, grid);\\n        // retain original value in recursion if no solution is found\\n        grid[i][j] = temp;\\n        // no solution so return false\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893462,
                "title": "c-bfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int x,int y,int n,int m)\\n    {\\n        if(x>=0 && y>=0 && x<n && y<m)\\n        return true;\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n       map<int,vector<vector<int>>> dir;\\n       dir[1] = {{0,-1},{0,1}};\\n       dir[2] = {{-1,0},{1,0}};\\n       dir[3] = {{0,-1},{1,0}};\\n       dir[4] = {{0,1},{1,0}};\\n       dir[5] = {{-1,0},{0,-1}};\\n       dir[6] = {{-1,0},{0,1}};\\n       int n = grid.size();\\n       int m = grid[0].size();\\n       queue<vector<int>> q;\\n       q.push({0,0});\\n       vector<vector<int>> vis(n,vector<int>(m,0));\\n       while(!q.empty())\\n       {\\n           int x = q.front()[0];\\n           int y = q.front()[1];\\n           q.pop();\\n           if(x==n-1 && y==m-1)\\n           return true;\\n           int val = grid[x][y];\\n           vis[x][y] = 1;\\n           for(int j=0;j<dir[val].size();j++)\\n           {\\n               int newx = x+dir[val][j][0];\\n               int newy = y+dir[val][j][1];\\n               if(isValid(newx,newy,n,m) && vis[newx][newy]==0)\\n               {\\n                   int flg = 0;\\n                   int tmp = grid[newx][newy];\\n                   for(int k=0;k<dir[tmp].size();k++)\\n                   {\\n                       if(newx+dir[tmp][k][0]==x && \\n                       newy+dir[tmp][k][1]==y)\\n                       flg = 1;\\n                   }\\n                   if(flg)\\n                   q.push({newx,newy});\\n               }\\n           }\\n       }\\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int x,int y,int n,int m)\\n    {\\n        if(x>=0 && y>=0 && x<n && y<m)\\n        return true;\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n       map<int,vector<vector<int>>> dir;\\n       dir[1] = {{0,-1},{0,1}};\\n       dir[2] = {{-1,0},{1,0}};\\n       dir[3] = {{0,-1},{1,0}};\\n       dir[4] = {{0,1},{1,0}};\\n       dir[5] = {{-1,0},{0,-1}};\\n       dir[6] = {{-1,0},{0,1}};\\n       int n = grid.size();\\n       int m = grid[0].size();\\n       queue<vector<int>> q;\\n       q.push({0,0});\\n       vector<vector<int>> vis(n,vector<int>(m,0));\\n       while(!q.empty())\\n       {\\n           int x = q.front()[0];\\n           int y = q.front()[1];\\n           q.pop();\\n           if(x==n-1 && y==m-1)\\n           return true;\\n           int val = grid[x][y];\\n           vis[x][y] = 1;\\n           for(int j=0;j<dir[val].size();j++)\\n           {\\n               int newx = x+dir[val][j][0];\\n               int newy = y+dir[val][j][1];\\n               if(isValid(newx,newy,n,m) && vis[newx][newy]==0)\\n               {\\n                   int flg = 0;\\n                   int tmp = grid[newx][newy];\\n                   for(int k=0;k<dir[tmp].size();k++)\\n                   {\\n                       if(newx+dir[tmp][k][0]==x && \\n                       newy+dir[tmp][k][1]==y)\\n                       flg = 1;\\n                   }\\n                   if(flg)\\n                   q.push({newx,newy});\\n               }\\n           }\\n       }\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882958,
                "title": "fast-and-easy-java-solution-using-union-find-with-explanation-beats-80-43",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA valid path exists if there is a path from the first cell to the last cell in the grid so using union find if both of them have the same parent then there is a valid path.\\nMoving right and down only should be enough to check if the path exists. No need to move left or up as this is redundant.\\n\\nTo have an edge between two adjacent cells we have few possibilities that you can observe easily from the drawings\\n\\nFor example:\\n* If a cell can connect to another on its right, check if the other edge can connect to the cell on its left and so on.\\n\\nand as stated above you need to check if the right and down only. \\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Make 2 simple function of union find and the parent array (global).\\n2. Parent array size is the number of cells in the grid as each cell is considered as a node in the graph.\\n3. Loop over the grid and check the possible connections (take care of your boundaries).\\n4. If two cells can be connected, union these two.\\n5. Each cell is identified by its number from 0 to n * m - 1 using (row_num of the cell) * (overall colums number) + (col_num of the cell).\\n6. Check if the first and last cell of the grid are connected (Have the same parent).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n * m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n * m)\\n# Code\\n```\\nclass Solution {\\n    // Every cell will be identified uniquely from 0 to n * m - 1\\n    // using i * (number of columns) + j;\\n    int[] parent;\\n    public boolean hasValidPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        // parent size = number of cells in the grid\\n        parent = new int[n * m];\\n        for(int i=0;i<parent.length;i++){\\n            parent[i] = i;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j < m - 1){\\n                    int next = grid[i][j + 1];\\n                    int curr = grid[i][j];\\n                    if((curr == 1 || curr == 4 || curr == 6) \\n                    && (next == 1 || next == 3 || next == 5)) \\n                        union(i * m + j, i * m + j + 1);\\n                }\\n                if(i < n - 1){\\n                    int next = grid[i + 1][j];\\n                    int curr = grid[i][j];\\n                    if((curr == 2 || curr == 3 || curr == 4) \\n                    && (next == 2 || next == 6 || next == 5))\\n                        union(i * m + j, (i + 1) * m + j);\\n                }\\n            }\\n        }\\n        int first = find(0);\\n        int last = find((n - 1) * m + m - 1);\\n        return first == last;\\n    }\\n    \\n    public int find(int x){\\n        if(parent[x] != x) parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public boolean union(int x, int y){\\n        int xp = find(x);\\n        int yp = find(y);\\n        if(xp == yp) return false;\\n        parent[yp] = xp;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    // Every cell will be identified uniquely from 0 to n * m - 1\\n    // using i * (number of columns) + j;\\n    int[] parent;\\n    public boolean hasValidPath(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        // parent size = number of cells in the grid\\n        parent = new int[n * m];\\n        for(int i=0;i<parent.length;i++){\\n            parent[i] = i;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j < m - 1){\\n                    int next = grid[i][j + 1];\\n                    int curr = grid[i][j];\\n                    if((curr == 1 || curr == 4 || curr == 6) \\n                    && (next == 1 || next == 3 || next == 5)) \\n                        union(i * m + j, i * m + j + 1);\\n                }\\n                if(i < n - 1){\\n                    int next = grid[i + 1][j];\\n                    int curr = grid[i][j];\\n                    if((curr == 2 || curr == 3 || curr == 4) \\n                    && (next == 2 || next == 6 || next == 5))\\n                        union(i * m + j, (i + 1) * m + j);\\n                }\\n            }\\n        }\\n        int first = find(0);\\n        int last = find((n - 1) * m + m - 1);\\n        return first == last;\\n    }\\n    \\n    public int find(int x){\\n        if(parent[x] != x) parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public boolean union(int x, int y){\\n        int xp = find(x);\\n        int yp = find(y);\\n        if(xp == yp) return false;\\n        parent[yp] = xp;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860845,
                "title": "bfs-c-96-faster-1391-check-if-there-is-a-valid-path-in-a-grid",
                "content": "# Intuition\\nThe problem can be efficiently solved using a Breadth-First Search (BFS) approach.\\n\\n# Approach\\n1. Start the BFS from the current Pipe.\\n2. Explore the neighboring Pipes that are connected through its open side.\\n3. If a neighboring Pipe has an open side, move to that Pipe.\\n4. Repeat steps 2 and 3 until you either reach the end Pipe or exhaust all possibilities.\\n\\n# Complexity\\n- Time complexity: O(N), where N is the number of pipes in the input.\\n\\n- Space complexity: O(N) for the Queue used in the BFS algorithm.\\n\\nIf you find this helpful, please consider starring my GitHub repository:\\n[https://github.com/ZadeAbhishek/DSA-Dev](https://github.com/ZadeAbhishek/DSA-Dev)\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> grid;\\n    queue<pair<int,int>> que;\\n    \\n    // check if the left side is present or not\\n    bool left(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 1 || curr == 3 || curr == 5) return true;\\n        return false;\\n    }\\n\\n    // check if the right side is present or not\\n    bool right(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 1 || curr == 4 || curr == 6) return true;\\n        return false;\\n    }\\n\\n    // check if the top side is present or not\\n    bool top(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 2 || curr == 6 || curr == 5) return true;\\n        return false;\\n    }\\n\\n    // check if the bottom side is present or not\\n    bool bottom(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 2 || curr == 3 || curr == 4) return true;\\n        return false;\\n    }\\n    \\n\\n    // check validity of coordinates\\n    bool isValid(int x, int y){\\n        if(x < 0 || y < 0 || x > grid.size()-1 || y > grid[0].size()-1) return false;\\n        return true;\\n    }\\n    \\n    // check if right side has left or not\\n    void pushLeft(int currX, int currY){\\n         if(isValid(currX,currY+1) && left(currX,currY+1) && grid[currX][currY+1] != 0){\\n                    que.push({currX,currY+1});\\n            }\\n            return;\\n    }\\n\\n    // check if left side have right or not\\n    void pushRight(int currX, int currY){\\n         if(isValid(currX,currY-1) && right(currX,currY-1) && grid[currX][currY-1] != 0){\\n                    que.push({currX,currY-1});\\n            }\\n            return;\\n    }\\n\\n    // check if bottom has top or not\\n    void pushTop(int currX, int currY){\\n         if(isValid(currX+1,currY) && top(currX+1,currY) && grid[currX+1][currY] != 0){\\n                    que.push({currX+1,currY});\\n            }\\n            return;\\n    }\\n\\n    // check if top has bottom or not\\n    void pushBottom(int currX, int currY){\\n         if(isValid(currX-1,currY) && bottom(currX-1,currY) && grid[currX-1][currY] != 0){\\n                    que.push({currX-1,currY});\\n        }\\n            return;\\n    }\\n\\n\\n\\n    bool traverse(int x, int y){\\n        \\n        // push starting coordinate in queue\\n        que.push({x,y}); \\n\\n        while(!que.empty()){\\n            \\n            // get current Coordinates\\n            auto currX = que.front().first;\\n            auto currY = que.front().second;\\n            que.pop();\\n\\n            // base case if we reached end return true\\n            if(currX == grid.size()-1 && currY == grid[0].size()-1) return true;\\n            \\n            // get current pipe/number of pipe\\n            int currPipe = grid[currX][currY];\\n\\n            // mark visited\\n            grid[currX][currY] = 0;\\n            \\n            /*\\n            Depend upon current pipe we will check its neighbour\\n            for example if currPipe is 1 we check right side of curr has\\n            left or not or left side of current has right or not\\n            */\\n            switch(currPipe){\\n                case 1:\\n                pushLeft(currX,currY); // check right has left or not\\n                pushRight(currX,currY); // check left has right or not\\n                break;\\n\\n                case 2:\\n                pushTop(currX,currY);  // check bottom has top or not\\n                pushBottom(currX,currY); // check top has bottom or not\\n                break;\\n\\n                case 3:\\n                pushTop(currX,currY);\\n                pushTop(currX,currY);\\n                break;\\n\\n                case 4:\\n                pushTop(currX,currY);\\n                pushLeft(currX,currY);\\n                break;\\n\\n                case 5:\\n                pushBottom(currX,currY);\\n                pushRight(currX,currY);\\n                break;\\n\\n                case 6:\\n                pushBottom(currX,currY);\\n                pushLeft(currX,currY);\\n                break;\\n\\n                default:\\n                break;\\n            \\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n\\n    public:\\n    bool hasValidPath(vector<vector<int>>& g) {\\n        grid = g;\\n        // pipes direction check\\n        return traverse(0,0);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> grid;\\n    queue<pair<int,int>> que;\\n    \\n    // check if the left side is present or not\\n    bool left(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 1 || curr == 3 || curr == 5) return true;\\n        return false;\\n    }\\n\\n    // check if the right side is present or not\\n    bool right(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 1 || curr == 4 || curr == 6) return true;\\n        return false;\\n    }\\n\\n    // check if the top side is present or not\\n    bool top(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 2 || curr == 6 || curr == 5) return true;\\n        return false;\\n    }\\n\\n    // check if the bottom side is present or not\\n    bool bottom(int x, int y){\\n        int curr = grid[x][y];\\n        if(curr == 2 || curr == 3 || curr == 4) return true;\\n        return false;\\n    }\\n    \\n\\n    // check validity of coordinates\\n    bool isValid(int x, int y){\\n        if(x < 0 || y < 0 || x > grid.size()-1 || y > grid[0].size()-1) return false;\\n        return true;\\n    }\\n    \\n    // check if right side has left or not\\n    void pushLeft(int currX, int currY){\\n         if(isValid(currX,currY+1) && left(currX,currY+1) && grid[currX][currY+1] != 0){\\n                    que.push({currX,currY+1});\\n            }\\n            return;\\n    }\\n\\n    // check if left side have right or not\\n    void pushRight(int currX, int currY){\\n         if(isValid(currX,currY-1) && right(currX,currY-1) && grid[currX][currY-1] != 0){\\n                    que.push({currX,currY-1});\\n            }\\n            return;\\n    }\\n\\n    // check if bottom has top or not\\n    void pushTop(int currX, int currY){\\n         if(isValid(currX+1,currY) && top(currX+1,currY) && grid[currX+1][currY] != 0){\\n                    que.push({currX+1,currY});\\n            }\\n            return;\\n    }\\n\\n    // check if top has bottom or not\\n    void pushBottom(int currX, int currY){\\n         if(isValid(currX-1,currY) && bottom(currX-1,currY) && grid[currX-1][currY] != 0){\\n                    que.push({currX-1,currY});\\n        }\\n            return;\\n    }\\n\\n\\n\\n    bool traverse(int x, int y){\\n        \\n        // push starting coordinate in queue\\n        que.push({x,y}); \\n\\n        while(!que.empty()){\\n            \\n            // get current Coordinates\\n            auto currX = que.front().first;\\n            auto currY = que.front().second;\\n            que.pop();\\n\\n            // base case if we reached end return true\\n            if(currX == grid.size()-1 && currY == grid[0].size()-1) return true;\\n            \\n            // get current pipe/number of pipe\\n            int currPipe = grid[currX][currY];\\n\\n            // mark visited\\n            grid[currX][currY] = 0;\\n            \\n            /*\\n            Depend upon current pipe we will check its neighbour\\n            for example if currPipe is 1 we check right side of curr has\\n            left or not or left side of current has right or not\\n            */\\n            switch(currPipe){\\n                case 1:\\n                pushLeft(currX,currY); // check right has left or not\\n                pushRight(currX,currY); // check left has right or not\\n                break;\\n\\n                case 2:\\n                pushTop(currX,currY);  // check bottom has top or not\\n                pushBottom(currX,currY); // check top has bottom or not\\n                break;\\n\\n                case 3:\\n                pushTop(currX,currY);\\n                pushTop(currX,currY);\\n                break;\\n\\n                case 4:\\n                pushTop(currX,currY);\\n                pushLeft(currX,currY);\\n                break;\\n\\n                case 5:\\n                pushBottom(currX,currY);\\n                pushRight(currX,currY);\\n                break;\\n\\n                case 6:\\n                pushBottom(currX,currY);\\n                pushLeft(currX,currY);\\n                break;\\n\\n                default:\\n                break;\\n            \\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n\\n    public:\\n    bool hasValidPath(vector<vector<int>>& g) {\\n        grid = g;\\n        // pipes direction check\\n        return traverse(0,0);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858258,
                "title": "easy-dfs-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>&vis){\\n        vis[row][col] = 1;\\n        if(row==grid.size()-1 && col == grid[0].size()-1) return true;\\n        //case 1:\\n        if(grid[row][col]==1){\\n            if(col - 1 >=0 && !vis[row][col-1]){\\n                if(grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1){\\n                   if(dfs(row,col-1,grid,vis)) return true;\\n                }\\n            }\\n            if(col + 1 <grid[0].size() && !vis[row][col+1]){\\n                if(grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1){\\n                   if(dfs(row,col+1,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        // case 2:\\n        if(grid[row][col]==2){\\n            if(row - 1 >=0 && !vis[row-1][col]){\\n                if(grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2){\\n                   if(dfs(row-1,col,grid,vis)) return true;\\n                }\\n            }\\n            if(row + 1 <grid.size() && !vis[row+1][col]){\\n                if(grid[row+1][col]==6 || grid[row+1][col]==5 || grid[row+1][col]==2){\\n                   if(dfs(row+1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 3:\\n        if(grid[row][col]==3){\\n            if(col - 1 >=0 && !vis[row][col-1]){\\n                if(grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1){\\n                   if(dfs(row,col-1,grid,vis)) return true;\\n                }\\n            }\\n            if(row + 1 <grid.size() && !vis[row+1][col]){\\n                if(grid[row+1][col]==5 || grid[row+1][col]==6 || grid[row+1][col]==2){\\n                   if(dfs(row+1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 4:\\n        if(grid[row][col]==4){\\n            if(col + 1 <grid[0].size() && !vis[row][col+1]){\\n                if(grid[row][col+1]==1 || grid[row][col+1]==3 || grid[row][col+1]==5){\\n                   if(dfs(row,col+1,grid,vis)) return true;\\n                }\\n            }\\n            if(row + 1 <grid.size() && !vis[row+1][col]){\\n                if(grid[row+1][col]==6 || grid[row+1][col]==5 || grid[row+1][col]==2){\\n                   if(dfs(row+1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 5:\\n        if(grid[row][col]==5){\\n            if(col - 1 >=0 && !vis[row][col-1]){\\n                if(grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1){\\n                   if(dfs(row,col-1,grid,vis)) return true;\\n                }\\n            }\\n            if(row - 1 >=0 && !vis[row-1][col]){\\n                if(grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2){\\n                   if(dfs(row-1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 6:\\n        if(grid[row][col]==6){\\n            if(row - 1 >=0 && !vis[row-1][col]){\\n                if(grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2){\\n                   if(dfs(row-1,col,grid,vis)) return true;\\n                }\\n            }\\n            if(col + 1 <grid[0].size() && !vis[row][col+1]){\\n                if(grid[row][col+1]==1 || grid[row][col+1]==3 || grid[row][col+1]==5){\\n                   if(dfs(row,col+1,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        return dfs(0,0,grid,vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>&vis){\\n        vis[row][col] = 1;\\n        if(row==grid.size()-1 && col == grid[0].size()-1) return true;\\n        //case 1:\\n        if(grid[row][col]==1){\\n            if(col - 1 >=0 && !vis[row][col-1]){\\n                if(grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1){\\n                   if(dfs(row,col-1,grid,vis)) return true;\\n                }\\n            }\\n            if(col + 1 <grid[0].size() && !vis[row][col+1]){\\n                if(grid[row][col+1]==3 || grid[row][col+1]==5 || grid[row][col+1]==1){\\n                   if(dfs(row,col+1,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        // case 2:\\n        if(grid[row][col]==2){\\n            if(row - 1 >=0 && !vis[row-1][col]){\\n                if(grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2){\\n                   if(dfs(row-1,col,grid,vis)) return true;\\n                }\\n            }\\n            if(row + 1 <grid.size() && !vis[row+1][col]){\\n                if(grid[row+1][col]==6 || grid[row+1][col]==5 || grid[row+1][col]==2){\\n                   if(dfs(row+1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 3:\\n        if(grid[row][col]==3){\\n            if(col - 1 >=0 && !vis[row][col-1]){\\n                if(grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1){\\n                   if(dfs(row,col-1,grid,vis)) return true;\\n                }\\n            }\\n            if(row + 1 <grid.size() && !vis[row+1][col]){\\n                if(grid[row+1][col]==5 || grid[row+1][col]==6 || grid[row+1][col]==2){\\n                   if(dfs(row+1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 4:\\n        if(grid[row][col]==4){\\n            if(col + 1 <grid[0].size() && !vis[row][col+1]){\\n                if(grid[row][col+1]==1 || grid[row][col+1]==3 || grid[row][col+1]==5){\\n                   if(dfs(row,col+1,grid,vis)) return true;\\n                }\\n            }\\n            if(row + 1 <grid.size() && !vis[row+1][col]){\\n                if(grid[row+1][col]==6 || grid[row+1][col]==5 || grid[row+1][col]==2){\\n                   if(dfs(row+1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 5:\\n        if(grid[row][col]==5){\\n            if(col - 1 >=0 && !vis[row][col-1]){\\n                if(grid[row][col-1]==4 || grid[row][col-1]==6 || grid[row][col-1]==1){\\n                   if(dfs(row,col-1,grid,vis)) return true;\\n                }\\n            }\\n            if(row - 1 >=0 && !vis[row-1][col]){\\n                if(grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2){\\n                   if(dfs(row-1,col,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        //case 6:\\n        if(grid[row][col]==6){\\n            if(row - 1 >=0 && !vis[row-1][col]){\\n                if(grid[row-1][col]==4 || grid[row-1][col]==3 || grid[row-1][col]==2){\\n                   if(dfs(row-1,col,grid,vis)) return true;\\n                }\\n            }\\n            if(col + 1 <grid[0].size() && !vis[row][col+1]){\\n                if(grid[row][col+1]==1 || grid[row][col+1]==3 || grid[row][col+1]==5){\\n                   if(dfs(row,col+1,grid,vis)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        return dfs(0,0,grid,vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807043,
                "title": "dfs-at-its-finest-faster-than-98-ez",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool help(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &vis){\\n    \\n        if(i==n-1 && j==m-1){\\n            return true;\\n        }\\n\\n        bool flag = false;\\n\\n        if(grid[i][j]==1){\\n            if(j>0 && vis[i][j-1]==0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                vis[i][j-1]++;\\n                flag=flag||help(i, j-1, n, m, grid, vis);\\n                vis[i][j-1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(j<m-1 && vis[i][j+1]==0 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                vis[i][j+1]++;\\n                flag=flag||help(i, j+1, n, m, grid, vis);\\n                vis[i][j+1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==2){\\n            if(i>0 && vis[i-1][j]==0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                vis[i-1][j]++;\\n                flag=flag||help(i-1, j, n, m, grid, vis);\\n                vis[i-1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(i<n-1 && vis[i+1][j]==0 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                vis[i+1][j]++;\\n                flag=flag||help(i+1, j, n, m, grid, vis);\\n                vis[i+1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==3){\\n            if(j>0 && vis[i][j-1]==0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                vis[i][j-1]++;\\n                flag=flag||help(i, j-1, n, m, grid, vis);\\n                vis[i][j-1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(i<n-1 && vis[i+1][j]==0 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                vis[i+1][j]++;\\n                flag=flag||help(i+1, j, n, m, grid, vis);\\n                vis[i+1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==4){\\n            if(j<m-1 && vis[i][j+1]==0 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                vis[i][j+1]++;\\n                flag=flag||help(i, j+1, n, m, grid, vis);\\n                vis[i][j+1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(i<n-1 && vis[i+1][j]==0 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                vis[i+1][j]++;\\n                flag=flag||help(i+1, j, n, m, grid, vis);\\n                vis[i+1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==5){\\n            if(i>0 && vis[i-1][j]==0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                vis[i-1][j]++;\\n                flag=flag||help(i-1, j, n, m, grid, vis);\\n                vis[i-1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(j>0 && vis[i][j-1]==0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                vis[i][j-1]++;\\n                flag=flag||help(i, j-1, n, m, grid, vis);\\n                vis[i][j-1]--;\\n            }\\n\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==6){\\n            if(i>0 && vis[i-1][j]==0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                vis[i-1][j]++;\\n                flag=flag||help(i-1, j, n, m, grid, vis);\\n                vis[i-1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(j<m-1 && vis[i][j+1]==0 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                vis[i][j+1]++;\\n                flag=flag||help(i, j+1, n, m, grid, vis);\\n                vis[i][j+1]--;\\n            }\\n\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        return flag;\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        vis[0][0]++;\\n        return help(0, 0, n, m, grid, vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool help(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &vis){\\n    \\n        if(i==n-1 && j==m-1){\\n            return true;\\n        }\\n\\n        bool flag = false;\\n\\n        if(grid[i][j]==1){\\n            if(j>0 && vis[i][j-1]==0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                vis[i][j-1]++;\\n                flag=flag||help(i, j-1, n, m, grid, vis);\\n                vis[i][j-1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(j<m-1 && vis[i][j+1]==0 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                vis[i][j+1]++;\\n                flag=flag||help(i, j+1, n, m, grid, vis);\\n                vis[i][j+1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==2){\\n            if(i>0 && vis[i-1][j]==0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                vis[i-1][j]++;\\n                flag=flag||help(i-1, j, n, m, grid, vis);\\n                vis[i-1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(i<n-1 && vis[i+1][j]==0 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                vis[i+1][j]++;\\n                flag=flag||help(i+1, j, n, m, grid, vis);\\n                vis[i+1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==3){\\n            if(j>0 && vis[i][j-1]==0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                vis[i][j-1]++;\\n                flag=flag||help(i, j-1, n, m, grid, vis);\\n                vis[i][j-1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(i<n-1 && vis[i+1][j]==0 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                vis[i+1][j]++;\\n                flag=flag||help(i+1, j, n, m, grid, vis);\\n                vis[i+1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==4){\\n            if(j<m-1 && vis[i][j+1]==0 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                vis[i][j+1]++;\\n                flag=flag||help(i, j+1, n, m, grid, vis);\\n                vis[i][j+1]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(i<n-1 && vis[i+1][j]==0 && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                vis[i+1][j]++;\\n                flag=flag||help(i+1, j, n, m, grid, vis);\\n                vis[i+1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==5){\\n            if(i>0 && vis[i-1][j]==0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                vis[i-1][j]++;\\n                flag=flag||help(i-1, j, n, m, grid, vis);\\n                vis[i-1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(j>0 && vis[i][j-1]==0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                vis[i][j-1]++;\\n                flag=flag||help(i, j-1, n, m, grid, vis);\\n                vis[i][j-1]--;\\n            }\\n\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        else if(grid[i][j]==6){\\n            if(i>0 && vis[i-1][j]==0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                vis[i-1][j]++;\\n                flag=flag||help(i-1, j, n, m, grid, vis);\\n                vis[i-1][j]--;\\n            }\\n\\n            if(flag){\\n                return true;\\n            }\\n\\n            if(j<m-1 && vis[i][j+1]==0 && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                vis[i][j+1]++;\\n                flag=flag||help(i, j+1, n, m, grid, vis);\\n                vis[i][j+1]--;\\n            }\\n\\n\\n            if(flag){\\n                return true;\\n            }\\n        }\\n\\n        return flag;\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n        vis[0][0]++;\\n        return help(0, 0, n, m, grid, vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779660,
                "title": "very-scuffed-beats-90",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n\\n        def backtrack(visited, location):\\n            visitedCopy = visited\\n            currR, currC = location[0], location[1]\\n            if location in visited:\\n                return False\\n            visited.add(location)\\n            if location == (len(grid)-1, len(grid[0])-1):\\n                return True\\n            \\n            if grid[currR][currC] == 1:\\n                temp = False\\n                #left\\n                if currC - 1 >= 0 and (grid[currR][currC-1] == 4 or grid[currR][currC-1] == 6 or grid[currR][currC-1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC-1))\\n                \\n                #right\\n                if currC + 1 < len(grid[0]) and (grid[currR][currC+1] == 3 or grid[currR][currC+1] == 5 or grid[currR][currC+1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC+1))\\n                \\n                return temp\\n\\n            elif grid[currR][currC] == 2:\\n                #up\\n                temp = False\\n                if currR - 1 >= 0 and (grid[currR-1][currC] == 3 or grid[currR-1][currC] == 4 or grid[currR-1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR-1, currC))\\n                #down\\n                if currR + 1 < len(grid) and (grid[currR+1][currC] == 5 or grid[currR+1][currC] == 6 or grid[currR+1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR+1, currC))\\n                return temp\\n\\n            elif grid[currR][currC] == 3:\\n                temp = False\\n                #left\\n                if currC - 1 >= 0 and (grid[currR][currC-1] == 4 or grid[currR][currC-1] == 6 or grid[currR][currC-1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC-1))\\n                #down\\n                if currR + 1 < len(grid) and (grid[currR+1][currC] == 5 or grid[currR+1][currC] == 6 or  grid[currR+1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR+1, currC))\\n                return temp\\n\\n            elif grid[currR][currC] == 4:\\n                temp = False\\n                #down\\n                if currR + 1 < len(grid) and (grid[currR+1][currC] == 5 or grid[currR+1][currC] == 6 or  grid[currR+1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR+1, currC))\\n                #right\\n                if currC + 1 < len(grid[0]) and (grid[currR][currC+1] == 3 or grid[currR][currC+1] == 5 or grid[currR][currC+1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC+1))\\n                return temp\\n            elif grid[currR][currC] == 5:\\n                temp = False\\n                #left\\n                if currC - 1 >= 0 and (grid[currR][currC-1] == 4 or grid[currR][currC-1] == 6 or grid[currR][currC-1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC-1))\\n                #up\\n                if currR - 1 >= 0 and (grid[currR-1][currC] == 3 or grid[currR-1][currC] == 4 or grid[currR-1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR-1, currC))\\n                return temp\\n            else:\\n                #right\\n                temp = False\\n                if currC + 1 < len(grid[0]) and (grid[currR][currC+1] == 3 or grid[currR][currC+1] == 5 or grid[currR][currC+1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC+1))\\n                #up\\n                if currR - 1 >= 0 and (grid[currR-1][currC] == 3 or grid[currR-1][currC] == 4 or grid[currR-1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR-1, currC))\\n                return temp\\n            visited.remove(location)\\n\\n        return backtrack(set(), (0,0))\\n                \\n\\n                \\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n\\n        def backtrack(visited, location):\\n            visitedCopy = visited\\n            currR, currC = location[0], location[1]\\n            if location in visited:\\n                return False\\n            visited.add(location)\\n            if location == (len(grid)-1, len(grid[0])-1):\\n                return True\\n            \\n            if grid[currR][currC] == 1:\\n                temp = False\\n                #left\\n                if currC - 1 >= 0 and (grid[currR][currC-1] == 4 or grid[currR][currC-1] == 6 or grid[currR][currC-1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC-1))\\n                \\n                #right\\n                if currC + 1 < len(grid[0]) and (grid[currR][currC+1] == 3 or grid[currR][currC+1] == 5 or grid[currR][currC+1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC+1))\\n                \\n                return temp\\n\\n            elif grid[currR][currC] == 2:\\n                #up\\n                temp = False\\n                if currR - 1 >= 0 and (grid[currR-1][currC] == 3 or grid[currR-1][currC] == 4 or grid[currR-1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR-1, currC))\\n                #down\\n                if currR + 1 < len(grid) and (grid[currR+1][currC] == 5 or grid[currR+1][currC] == 6 or grid[currR+1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR+1, currC))\\n                return temp\\n\\n            elif grid[currR][currC] == 3:\\n                temp = False\\n                #left\\n                if currC - 1 >= 0 and (grid[currR][currC-1] == 4 or grid[currR][currC-1] == 6 or grid[currR][currC-1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC-1))\\n                #down\\n                if currR + 1 < len(grid) and (grid[currR+1][currC] == 5 or grid[currR+1][currC] == 6 or  grid[currR+1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR+1, currC))\\n                return temp\\n\\n            elif grid[currR][currC] == 4:\\n                temp = False\\n                #down\\n                if currR + 1 < len(grid) and (grid[currR+1][currC] == 5 or grid[currR+1][currC] == 6 or  grid[currR+1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR+1, currC))\\n                #right\\n                if currC + 1 < len(grid[0]) and (grid[currR][currC+1] == 3 or grid[currR][currC+1] == 5 or grid[currR][currC+1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC+1))\\n                return temp\\n            elif grid[currR][currC] == 5:\\n                temp = False\\n                #left\\n                if currC - 1 >= 0 and (grid[currR][currC-1] == 4 or grid[currR][currC-1] == 6 or grid[currR][currC-1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC-1))\\n                #up\\n                if currR - 1 >= 0 and (grid[currR-1][currC] == 3 or grid[currR-1][currC] == 4 or grid[currR-1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR-1, currC))\\n                return temp\\n            else:\\n                #right\\n                temp = False\\n                if currC + 1 < len(grid[0]) and (grid[currR][currC+1] == 3 or grid[currR][currC+1] == 5 or grid[currR][currC+1] == 1):\\n                    temp = temp or backtrack(visitedCopy, (currR, currC+1))\\n                #up\\n                if currR - 1 >= 0 and (grid[currR-1][currC] == 3 or grid[currR-1][currC] == 4 or grid[currR-1][currC] == 2):\\n                    temp = temp or backtrack(visitedCopy, (currR-1, currC))\\n                return temp\\n            visited.remove(location)\\n\\n        return backtrack(set(), (0,0))\\n                \\n\\n                \\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777924,
                "title": "java-simple-solution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean hasValidPath(int[][] a) {\\n        dirMap = new HashMap<>();\\n        dirMap.put(1, new int[][]{{0,-1},{0,1}});\\n        dirMap.put(2, new int[][]{{-1,0},{1,0}});\\n        dirMap.put(3, new int[][]{{0,-1},{1,0}});\\n        dirMap.put(4, new int[][]{{0,1},{1,0}});\\n        dirMap.put(5, new int[][]{{0,-1},{-1,0}});\\n        dirMap.put(6, new int[][]{{0,1},{-1,0}});\\n        visited = new HashSet<>();\\n        return dfs(a, 0, 0);\\n    }\\n    static Map<Integer,int[][]> dirMap;\\n    static Set<List<Integer>> visited;\\n    static boolean dfs(int[][] a, int i, int j){\\n        List<Integer> list =new ArrayList<>();\\n        list.add(i); list.add(j);\\n        if(i<0 || j<0 || i>a.length-1 || j>a[0].length-1 || visited.contains(list)) return false;\\n        visited.add(list);\\n        if(i==a.length-1 && j==a[0].length-1) return true;\\n        for(int[] dir: dirMap.get(a[i][j])){\\n            // Next index in matrix\\n            int row = i + dir[0];\\n            int col = j + dir[1];\\n            if(row>=0 && col>=0 && row<a.length && col<a[0].length){\\n                // Check if we come back to previous index  \\n                for(int[] ndir: dirMap.get(a[row][col])){\\n                    int r = row + ndir[0];\\n                    int c = col + ndir[1];\\n                    if(r==i && c==j) {\\n                        if(dfs(a, row, col)) return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(int[][] a) {\\n        dirMap = new HashMap<>();\\n        dirMap.put(1, new int[][]{{0,-1},{0,1}});\\n        dirMap.put(2, new int[][]{{-1,0},{1,0}});\\n        dirMap.put(3, new int[][]{{0,-1},{1,0}});\\n        dirMap.put(4, new int[][]{{0,1},{1,0}});\\n        dirMap.put(5, new int[][]{{0,-1},{-1,0}});\\n        dirMap.put(6, new int[][]{{0,1},{-1,0}});\\n        visited = new HashSet<>();\\n        return dfs(a, 0, 0);\\n    }\\n    static Map<Integer,int[][]> dirMap;\\n    static Set<List<Integer>> visited;\\n    static boolean dfs(int[][] a, int i, int j){\\n        List<Integer> list =new ArrayList<>();\\n        list.add(i); list.add(j);\\n        if(i<0 || j<0 || i>a.length-1 || j>a[0].length-1 || visited.contains(list)) return false;\\n        visited.add(list);\\n        if(i==a.length-1 && j==a[0].length-1) return true;\\n        for(int[] dir: dirMap.get(a[i][j])){\\n            // Next index in matrix\\n            int row = i + dir[0];\\n            int col = j + dir[1];\\n            if(row>=0 && col>=0 && row<a.length && col<a[0].length){\\n                // Check if we come back to previous index  \\n                for(int[] ndir: dirMap.get(a[row][col])){\\n                    int r = row + ndir[0];\\n                    int c = col + ndir[1];\\n                    if(r==i && c==j) {\\n                        if(dfs(a, row, col)) return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777311,
                "title": "java-dfs-solution-clearly-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This problem states the starting point is (0,0).\\n- we should keep in mind that the next possible direction of the route should also have a entry point to enter.\\n- When we reach a point from the previous point we need to go in possible directions (here we have only two possible directions for values 1 to 6)\\n- At every dfs call we need to handle the visited points so that we dont encounter any loop or tle.\\n- Below approach make you understand better. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a HashMap of opposite routes so that we can check the incoming route  can lead to enter the present point or not. Like l maps to r and vice versa.\\n- Create another hashmap for mapping direction to its correspoding row col direction. Like l maps to {0,-1} and so on.\\n- Create a array of Pair class where we can easily find the two possible directions for every point (1 to 6).\\n- Now start the dfs from (0,0) by taking the input direction any from a and b.\\n- In dfs, first we check if any of (i,j) are not out of bounds or have been already visited. If so we return false immediately.\\n- then we take the route from the grid and checks where the entered d direction can enter into the present route by checking from the opposite direction map. If no direction leads to enter the present point we return false.\\n- If we can enter the present (i,j) point then we check for the destination (m-1,n-1). If equals we return true.\\n- Else we try to go to the next two possible routes.\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(7(array of pair class) + dirs + map + (m*n)recursive stack)--->   overall it comes to O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    HashMap<Character,Character> map;\\n    HashMap<Character,int[]> dirs;\\n    public boolean hasValidPath(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        map=new HashMap<>();\\n        dirs=new HashMap<>();\\n        dirs.put(\\'l\\',new int[]{0,-1});dirs.put(\\'r\\',new int[]{0,1});dirs.put(\\'t\\',new int[]{-1,0});\\n        dirs.put(\\'b\\',new int[]{1,0});\\n        map.put(\\'l\\',\\'r\\');map.put(\\'r\\',\\'l\\');map.put(\\'t\\',\\'b\\');map.put(\\'b\\',\\'t\\');\\n        Pair[] arr=new Pair[7];\\n        arr[1]=new Pair(\\'l\\',\\'r\\');\\n        arr[2]=new Pair(\\'t\\',\\'b\\');\\n        arr[3]=new Pair(\\'l\\',\\'b\\');\\n        arr[4]=new Pair(\\'r\\',\\'b\\');\\n        arr[5]=new Pair(\\'t\\',\\'l\\');\\n        arr[6]=new Pair(\\'t\\',\\'r\\');\\n        return dfs(grid,0,0,m,n,arr,map.get(arr[grid[0][0]].a));\\n    }\\n    public boolean dfs(int[][] grid,int i,int j,int m,int n,Pair[] arr,char d){\\n        if(Math.min(i,j)<0 || i>=m || j>=n || grid[i][j]==0)return false;\\n        int idx=grid[i][j];\\n        if(map.get(arr[idx].a)!=d && map.get(arr[idx].b)!=d)return false;\\n        if(i==m-1 && j==n-1)return true;\\n        grid[i][j]=0;\\n        char a=arr[idx].a;\\n        char b=arr[idx].b;\\n        int[] x=dirs.get(a);\\n        int[] y=dirs.get(b);\\n        return dfs(grid,i+x[0],j+x[1],m,n,arr,a) || dfs(grid,i+y[0],j+y[1],m,n,arr,b);\\n    }\\n}\\nclass Pair{\\n    char a;\\n    char b;\\n    Pair(char a,char b){\\n        this.a=a;\\n        this.b=b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Character,Character> map;\\n    HashMap<Character,int[]> dirs;\\n    public boolean hasValidPath(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        map=new HashMap<>();\\n        dirs=new HashMap<>();\\n        dirs.put(\\'l\\',new int[]{0,-1});dirs.put(\\'r\\',new int[]{0,1});dirs.put(\\'t\\',new int[]{-1,0});\\n        dirs.put(\\'b\\',new int[]{1,0});\\n        map.put(\\'l\\',\\'r\\');map.put(\\'r\\',\\'l\\');map.put(\\'t\\',\\'b\\');map.put(\\'b\\',\\'t\\');\\n        Pair[] arr=new Pair[7];\\n        arr[1]=new Pair(\\'l\\',\\'r\\');\\n        arr[2]=new Pair(\\'t\\',\\'b\\');\\n        arr[3]=new Pair(\\'l\\',\\'b\\');\\n        arr[4]=new Pair(\\'r\\',\\'b\\');\\n        arr[5]=new Pair(\\'t\\',\\'l\\');\\n        arr[6]=new Pair(\\'t\\',\\'r\\');\\n        return dfs(grid,0,0,m,n,arr,map.get(arr[grid[0][0]].a));\\n    }\\n    public boolean dfs(int[][] grid,int i,int j,int m,int n,Pair[] arr,char d){\\n        if(Math.min(i,j)<0 || i>=m || j>=n || grid[i][j]==0)return false;\\n        int idx=grid[i][j];\\n        if(map.get(arr[idx].a)!=d && map.get(arr[idx].b)!=d)return false;\\n        if(i==m-1 && j==n-1)return true;\\n        grid[i][j]=0;\\n        char a=arr[idx].a;\\n        char b=arr[idx].b;\\n        int[] x=dirs.get(a);\\n        int[] y=dirs.get(b);\\n        return dfs(grid,i+x[0],j+x[1],m,n,arr,a) || dfs(grid,i+y[0],j+y[1],m,n,arr,b);\\n    }\\n}\\nclass Pair{\\n    char a;\\n    char b;\\n    Pair(char a,char b){\\n        this.a=a;\\n        this.b=b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768958,
                "title": "straight-forward-solution-bfs",
                "content": "`you can go to next cell and check whether you can come back.`\\n\\n`{{0, -1}, {0, 1}}`: This indicates that from a cell of street type 1, you can move either left or right.\\netc...........\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        vector<vector<vector<int>>> direct({\\n            {{0, -1}, {0, 1}},\\n            {{-1, 0}, {1, 0}},\\n            {{0, -1}, {1, 0}},\\n            {{0, 1}, {1, 0}},\\n            {{0, -1}, {-1, 0}},\\n            {{0, 1}, {-1, 0}}\\n        });\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<vector<int>>Q;\\n        Q.push({0,0});\\n        vector<vector<bool>>visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n        while(!Q.empty()){\\n            vector<int>curr=Q.front();\\n            Q.pop();\\n            int row=curr[0];\\n            int col=curr[1];\\n            for(auto &d:direct[grid[row][col]-1]){\\n                int nr=row+d[0];\\n                int nc=col+d[1];\\n                if(nr<0 || nr>=m || nc<0 || nc>=n || visited[nr][nc]){\\n                    continue;\\n                }\\n                for(auto &dir:direct[grid[nr][nc]-1]){\\n                    if(nr+dir[0]==row && nc+dir[1]==col){\\n                        visited[nr][nc]=true;\\n                        Q.push({nr,nc});\\n                    }\\n                }\\n            }\\n        }\\n        return visited[m-1][n-1];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        vector<vector<vector<int>>> direct({\\n            {{0, -1}, {0, 1}},\\n            {{-1, 0}, {1, 0}},\\n            {{0, -1}, {1, 0}},\\n            {{0, 1}, {1, 0}},\\n            {{0, -1}, {-1, 0}},\\n            {{0, 1}, {-1, 0}}\\n        });\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<vector<int>>Q;\\n        Q.push({0,0});\\n        vector<vector<bool>>visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n        while(!Q.empty()){\\n            vector<int>curr=Q.front();\\n            Q.pop();\\n            int row=curr[0];\\n            int col=curr[1];\\n            for(auto &d:direct[grid[row][col]-1]){\\n                int nr=row+d[0];\\n                int nc=col+d[1];\\n                if(nr<0 || nr>=m || nc<0 || nc>=n || visited[nr][nc]){\\n                    continue;\\n                }\\n                for(auto &dir:direct[grid[nr][nc]-1]){\\n                    if(nr+dir[0]==row && nc+dir[1]==col){\\n                        visited[nr][nc]=true;\\n                        Q.push({nr,nc});\\n                    }\\n                }\\n            }\\n        }\\n        return visited[m-1][n-1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766424,
                "title": "javascript-union-find-475ms",
                "content": "Main idea: \\n(1) figure out all the cases of two board connections. here we use \\'H\\': horizontal to represent LR directions, V: vertical to represent UD directions\\n(2) union find to connect matrix node values: (i * m + j), answer is to check connectivity of [0, 0] and [n-1, m-1] node values.\\n```\\n////////////////////////// Template /////////////////////////\\nfunction DJSet(n) {\\n    let parent = Array(n).fill(-1);\\n    return { find, union, count, equiv, par }\\n    function find(x) {\\n        return parent[x] < 0 ? x : parent[x] = find(parent[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x == y) return false;\\n        if (parent[x] < parent[y]) [x, y] = [y, x];\\n        parent[x] += parent[y];\\n        parent[y] = x;\\n        return true;\\n    }\\n    function count() { // total groups\\n        return parent.filter(v => v < 0).length;\\n    }\\n    function equiv(x, y) { // isConnected\\n        return find(x) == find(y);\\n    }\\n    function par() {\\n        return parent;\\n    }\\n}\\n//////////////////////////////////////////////////////////\\n\\nconst hasValidPath = (g) => {\\n    let se = new Set([\\n        \\'H11\\', \\'H13\\', \\'H41\\', \\'H15\\', \\'H61\\',\\n        \\'V22\\', \\'V32\\', \\'V42\\', \\'V25\\', \\'V26\\',\\n        \\'H43\\', \\'V35\\', \\'V36\\', \\'H63\\',\\n        \\'V45\\', \\'H45\\', \\'V46\\',\\n        \\'H65\\']); // connected cases, example, H13: horizontal 1 -> 3  V32: vertical 3 -> 2\\n    let n = g.length, m = g[0].length, ds = new DJSet(n * m);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            let mark; // build 4 cases, if connected, union nodes value: i * m + j\\n            if (i + 1 < n) {\\n                mark = \\'V\\' + g[i][j] + g[i + 1][j];\\n                if (se.has(mark)) ds.union(i * m + j, (i + 1) * m + j)\\n            }\\n            if (i - 1 >= 0) {\\n                mark = \\'V\\' + g[i - 1][j] + g[i][j];\\n                if (se.has(mark)) ds.union(i * m + j, (i - 1) * m + j)\\n            }\\n            if (j + 1 < m) {\\n                mark = \\'H\\' + g[i][j] + g[i][j + 1];\\n                if (se.has(mark)) ds.union(i * m + j, i * m + j + 1);\\n            }\\n            if (j - 1 >= 0) {\\n                mark = \\'H\\' + g[i][j - 1] + g[i][j];\\n                if (se.has(mark)) ds.union(i * m + j, i * m + j - 1);\\n            }\\n        }\\n    }\\n    return ds.equiv(0, (n - 1) * m + m - 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find",
                    "Matrix"
                ],
                "code": "```\\n////////////////////////// Template /////////////////////////\\nfunction DJSet(n) {\\n    let parent = Array(n).fill(-1);\\n    return { find, union, count, equiv, par }\\n    function find(x) {\\n        return parent[x] < 0 ? x : parent[x] = find(parent[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x == y) return false;\\n        if (parent[x] < parent[y]) [x, y] = [y, x];\\n        parent[x] += parent[y];\\n        parent[y] = x;\\n        return true;\\n    }\\n    function count() { // total groups\\n        return parent.filter(v => v < 0).length;\\n    }\\n    function equiv(x, y) { // isConnected\\n        return find(x) == find(y);\\n    }\\n    function par() {\\n        return parent;\\n    }\\n}\\n//////////////////////////////////////////////////////////\\n\\nconst hasValidPath = (g) => {\\n    let se = new Set([\\n        \\'H11\\', \\'H13\\', \\'H41\\', \\'H15\\', \\'H61\\',\\n        \\'V22\\', \\'V32\\', \\'V42\\', \\'V25\\', \\'V26\\',\\n        \\'H43\\', \\'V35\\', \\'V36\\', \\'H63\\',\\n        \\'V45\\', \\'H45\\', \\'V46\\',\\n        \\'H65\\']); // connected cases, example, H13: horizontal 1 -> 3  V32: vertical 3 -> 2\\n    let n = g.length, m = g[0].length, ds = new DJSet(n * m);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            let mark; // build 4 cases, if connected, union nodes value: i * m + j\\n            if (i + 1 < n) {\\n                mark = \\'V\\' + g[i][j] + g[i + 1][j];\\n                if (se.has(mark)) ds.union(i * m + j, (i + 1) * m + j)\\n            }\\n            if (i - 1 >= 0) {\\n                mark = \\'V\\' + g[i - 1][j] + g[i][j];\\n                if (se.has(mark)) ds.union(i * m + j, (i - 1) * m + j)\\n            }\\n            if (j + 1 < m) {\\n                mark = \\'H\\' + g[i][j] + g[i][j + 1];\\n                if (se.has(mark)) ds.union(i * m + j, i * m + j + 1);\\n            }\\n            if (j - 1 >= 0) {\\n                mark = \\'H\\' + g[i][j - 1] + g[i][j];\\n                if (se.has(mark)) ds.union(i * m + j, i * m + j - 1);\\n            }\\n        }\\n    }\\n    return ds.equiv(0, (n - 1) * m + m - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765490,
                "title": "python-union-find-with-template-to-use-everwhere",
                "content": "```\\nclass UnionFind:     # union find template to use every where with amorized O(1) time and O(n) space complexity\\n    def __init__(self):\\n        self.root = dict()\\n        self.rank = defaultdict(int)\\n\\n    def find(self, x):\\n        self.check(x)         # check if the x exist in self root \\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x]) # path compression\\n        return self.root[x]\\n    \\n    def check(self, node):\\n        if not node in self.root:      # add node:node key to root dict if node does not exist in root\\n            self.root[node] = node\\n        return\\n        \\n       \\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] > self.rank[rootY]:   # optimizing union function using rank\\n                self.root[rootY] = rootX\\n                \\n            elif self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += 1\\n\\nclass Solution:\\n    def check(self, row, col):\\n        return 0 <= col < self.m and 0 <= row < self.n \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        self.n = len(grid)\\n        self.m = len(grid[0])\\n        n = len(grid)\\n        m = len(grid[0])\\n        uf = UnionFind()\\n        for row in range(n):\\n            for col in range(m):\\n                st = grid[row][col]\\n                if st == 1:\\n                    if self.check(row, col + 1) and grid[row][col + 1] in {1, 3, 5}:\\n                        uf.union((row, col), (row, col + 1))\\n                elif st == 2:\\n                    if self.check(row + 1, col) and grid[row+ 1][col] in {2, 5, 6}:\\n                        uf.union((row, col), (row + 1, col))\\n                elif st == 3:\\n                    if self.check(row + 1, col) and grid[row+ 1][col] in {2, 5, 6}:\\n                        uf.union((row, col), (row + 1, col))\\n                elif st == 4:\\n                    if self.check(row + 1, col) and grid[row+ 1][col] in {2, 5, 6}:\\n                        uf.union((row, col), (row + 1, col))\\n                    if self.check(row, col + 1) and grid[row][col + 1] in {1, 3, 5}:\\n                        uf.union((row, col), (row, col + 1))\\n                elif st == 6:\\n                    if self.check(row, col + 1) and grid[row][col + 1] in {1, 3, 5}:\\n                        uf.union((row, col), (row, col + 1))\\n        \\n        return uf.find((0, 0)) == uf.find((n - 1, m - 1))\\n",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "class Solution:\\n    def check(self, row, col):\\n        return 0 <= col < self.m and 0 <= row < self.n \\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        self.n = len(grid)\\n        self.m = len(grid[0])\\n        n = len(grid)\\n        m = len(grid[0])\\n        uf = UnionFind()\\n        for row in range(n):\\n            for col in range(m):\\n                st = grid[row][col]\\n                if st == 1:\\n                    if self.check(row, col + 1) and grid[row][col + 1] in {1, 3, 5}",
                "codeTag": "Java"
            },
            {
                "id": 3748749,
                "title": "the-simplest-solution-using-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfollow the path\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to follow the street and eliminate each street u have ben in until u end up in the bottom right corner, nothing special just want it to be so simple. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool HasValidPath(int[][] grid) {\\n        Dictionary<int, string[]> streets = new Dictionary<int, string[]>();\\n        streets.Add(0, new string[] { \"nothin\", \"nothing\" });\\n        streets.Add(1, new string[] { \"left\", \"right\" });\\n        streets.Add(2, new string[] { \"up\", \"down\" });\\n        streets.Add(3, new string[] { \"left\", \"down\" });\\n        streets.Add(4, new string[] { \"right\", \"down\" });\\n        streets.Add(5, new string[] { \"left\", \"up\" });\\n        streets.Add(6, new string[] { \"right\", \"up\" });\\n\\n        int iPos = 0;\\n        int jPos = 0;\\n        int firstStreet = grid[0][0];\\n        int currentStreet = grid[0][0];\\n        bool canWalkToNextStreet = true;\\n        bool walked = false;\\n        for (int i = 0; i < 2; i++)\\n        {\\n            if (i == 1)//if went right and got stuck, just go back and go down instead of right\\n            {\\n                iPos = 0;\\n                jPos = 0;\\n                currentStreet = firstStreet;\\n                grid[0][0] = firstStreet;\\n                canWalkToNextStreet = true;\\n                walked = false;\\n                if (iPos + 1 <= grid.Length - 1 && !walked)\\n                {\\n                    //checkDown\\n                    if (streets[grid[iPos][jPos]][0] == \"down\" || streets[grid[iPos][jPos]][1] == \"down\")\\n                    {\\n                        if (streets[grid[iPos + 1][jPos]][0] == \"up\" || streets[grid[iPos + 1][jPos]][1] == \"up\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos + 1][jPos];\\n                            grid[iPos][jPos] = 0;\\n                            iPos++;\\n                        }\\n                    }\\n                }\\n                if (!walked)\\n                {\\n                    canWalkToNextStreet = false;\\n                }\\n            }\\n\\n            while (canWalkToNextStreet)\\n            {\\n                walked = false;\\n                if (iPos - 1 >= 0 && !walked)\\n                {\\n                    //checkUp\\n                    if (streets[grid[iPos][jPos]][0] == \"up\" || streets[grid[iPos][jPos]][1] == \"up\")\\n                    {\\n                        if (streets[grid[iPos - 1][jPos]][0] == \"down\" || streets[grid[iPos - 1][jPos]][1] == \"down\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos - 1][jPos];\\n                            grid[iPos][jPos] = 0;\\n                            iPos--;\\n                        }\\n                    }\\n                }\\n                if (jPos + 1 <= grid[iPos].Length - 1 && !walked)\\n                {\\n                    //checkRight\\n                    if (streets[grid[iPos][jPos]][0] == \"right\" || streets[grid[iPos][jPos]][1] == \"right\")\\n                    {\\n                        if (streets[grid[iPos][jPos + 1]][0] == \"left\" || streets[grid[iPos][jPos + 1]][1] == \"left\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos][jPos + 1];\\n                            grid[iPos][jPos] = 0;\\n                            jPos++;\\n                        }\\n                    }\\n                }\\n                if (iPos + 1 <= grid.Length - 1 && !walked)\\n                {\\n                    //checkDown\\n                    if (streets[grid[iPos][jPos]][0] == \"down\" || streets[grid[iPos][jPos]][1] == \"down\")\\n                    {\\n                        if (streets[grid[iPos + 1][jPos]][0] == \"up\" || streets[grid[iPos + 1][jPos]][1] == \"up\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos + 1][jPos];\\n                            grid[iPos][jPos] = 0;\\n                            iPos++;\\n                        }\\n                    }\\n                }\\n                if (jPos - 1 >= 0 && !walked)\\n                {\\n                    //checkLeft\\n                    if (streets[grid[iPos][jPos]][0] == \"left\" || streets[grid[iPos][jPos]][1] == \"left\")\\n                    {\\n                        if (streets[grid[iPos][jPos - 1]][0] == \"right\" || streets[grid[iPos][jPos - 1]][1] == \"right\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos][jPos - 1];\\n                            grid[iPos][jPos] = 0;\\n                            jPos--;\\n                        }\\n                    }\\n                }\\n                if (!walked)\\n                {\\n                    canWalkToNextStreet = false;\\n                }\\n                if (iPos == grid.Length - 1 && jPos == grid[grid.Length - 1].Length - 1)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public bool HasValidPath(int[][] grid) {\\n        Dictionary<int, string[]> streets = new Dictionary<int, string[]>();\\n        streets.Add(0, new string[] { \"nothin\", \"nothing\" });\\n        streets.Add(1, new string[] { \"left\", \"right\" });\\n        streets.Add(2, new string[] { \"up\", \"down\" });\\n        streets.Add(3, new string[] { \"left\", \"down\" });\\n        streets.Add(4, new string[] { \"right\", \"down\" });\\n        streets.Add(5, new string[] { \"left\", \"up\" });\\n        streets.Add(6, new string[] { \"right\", \"up\" });\\n\\n        int iPos = 0;\\n        int jPos = 0;\\n        int firstStreet = grid[0][0];\\n        int currentStreet = grid[0][0];\\n        bool canWalkToNextStreet = true;\\n        bool walked = false;\\n        for (int i = 0; i < 2; i++)\\n        {\\n            if (i == 1)//if went right and got stuck, just go back and go down instead of right\\n            {\\n                iPos = 0;\\n                jPos = 0;\\n                currentStreet = firstStreet;\\n                grid[0][0] = firstStreet;\\n                canWalkToNextStreet = true;\\n                walked = false;\\n                if (iPos + 1 <= grid.Length - 1 && !walked)\\n                {\\n                    //checkDown\\n                    if (streets[grid[iPos][jPos]][0] == \"down\" || streets[grid[iPos][jPos]][1] == \"down\")\\n                    {\\n                        if (streets[grid[iPos + 1][jPos]][0] == \"up\" || streets[grid[iPos + 1][jPos]][1] == \"up\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos + 1][jPos];\\n                            grid[iPos][jPos] = 0;\\n                            iPos++;\\n                        }\\n                    }\\n                }\\n                if (!walked)\\n                {\\n                    canWalkToNextStreet = false;\\n                }\\n            }\\n\\n            while (canWalkToNextStreet)\\n            {\\n                walked = false;\\n                if (iPos - 1 >= 0 && !walked)\\n                {\\n                    //checkUp\\n                    if (streets[grid[iPos][jPos]][0] == \"up\" || streets[grid[iPos][jPos]][1] == \"up\")\\n                    {\\n                        if (streets[grid[iPos - 1][jPos]][0] == \"down\" || streets[grid[iPos - 1][jPos]][1] == \"down\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos - 1][jPos];\\n                            grid[iPos][jPos] = 0;\\n                            iPos--;\\n                        }\\n                    }\\n                }\\n                if (jPos + 1 <= grid[iPos].Length - 1 && !walked)\\n                {\\n                    //checkRight\\n                    if (streets[grid[iPos][jPos]][0] == \"right\" || streets[grid[iPos][jPos]][1] == \"right\")\\n                    {\\n                        if (streets[grid[iPos][jPos + 1]][0] == \"left\" || streets[grid[iPos][jPos + 1]][1] == \"left\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos][jPos + 1];\\n                            grid[iPos][jPos] = 0;\\n                            jPos++;\\n                        }\\n                    }\\n                }\\n                if (iPos + 1 <= grid.Length - 1 && !walked)\\n                {\\n                    //checkDown\\n                    if (streets[grid[iPos][jPos]][0] == \"down\" || streets[grid[iPos][jPos]][1] == \"down\")\\n                    {\\n                        if (streets[grid[iPos + 1][jPos]][0] == \"up\" || streets[grid[iPos + 1][jPos]][1] == \"up\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos + 1][jPos];\\n                            grid[iPos][jPos] = 0;\\n                            iPos++;\\n                        }\\n                    }\\n                }\\n                if (jPos - 1 >= 0 && !walked)\\n                {\\n                    //checkLeft\\n                    if (streets[grid[iPos][jPos]][0] == \"left\" || streets[grid[iPos][jPos]][1] == \"left\")\\n                    {\\n                        if (streets[grid[iPos][jPos - 1]][0] == \"right\" || streets[grid[iPos][jPos - 1]][1] == \"right\")\\n                        {\\n                            canWalkToNextStreet = true;\\n                            walked = true;\\n                            currentStreet = grid[iPos][jPos - 1];\\n                            grid[iPos][jPos] = 0;\\n                            jPos--;\\n                        }\\n                    }\\n                }\\n                if (!walked)\\n                {\\n                    canWalkToNextStreet = false;\\n                }\\n                if (iPos == grid.Length - 1 && jPos == grid[grid.Length - 1].Length - 1)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743957,
                "title": "c-easy-bfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Keep All directions in 3D vector\\n2. In BFS, restrict moves as per street number given in matrix[i][j]\\n3. Keep a visited matrix also, to avoid revisiting same cells\\n3. Check if the cell which we are moving to can recieve our movement. \\n4. For e.g. we have 2 direction left or right in street 1, so street 1 tells us to move right suppose, but we have street 2 to the right, which cannot recieve our movement\\n\\n\\n\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkReciever(vector<vector<int>>& reciever, int dx, int dy){\\n        for(int i=0;i<2;i++){\\n            if(reciever[i][0]==-1*dx && reciever[i][1]==-1*dy) return true;;\\n        }\\n        return false;\\n    }\\n\\n    bool bfs(vector<vector<int>>& grid,vector<vector<vector<int>>>& moves){\\n        int m=grid.size(), n=grid[0].size();\\n\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n\\n        while(!q.empty()){\\n            auto p=q.front();   q.pop();\\n            int i=p[0], j=p[1];\\n\\n            vector<vector<int>> directions=moves[grid[i][j]];\\n\\n            for(int k=0;k<2;k++){\\n                int dx=directions[k][0], dy=directions[k][1];\\n                int x=i+dx,y=j+dy;\\n\\n                if(x>=0 && x<m && y>=0 && y<n && !visited[x][y]){\\n                    vector<vector<int>> reciever=moves[grid[x][y]];\\n                    if(!checkReciever(reciever,dx,dy)) continue;\\n                    \\n                    if(x==m-1 && y==n-1) return true;\\n                    q.push({x,y});\\n                    visited[x][y]=true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        if(m==1 && n==1) return true;\\n\\n        vector<vector<vector<int>>> moves={{}\\n                                            ,{{0,-1},{0,1}}\\n                                            ,{{1,0},{-1,0}}\\n                                            ,{{0,-1},{1,0}}\\n                                            ,{{1,0},{0,1}}\\n                                            ,{{-1,0},{0,-1}}\\n                                            ,{{-1,0},{0,1}}\\n                                            };\\n        \\n        return bfs(grid,moves);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkReciever(vector<vector<int>>& reciever, int dx, int dy){\\n        for(int i=0;i<2;i++){\\n            if(reciever[i][0]==-1*dx && reciever[i][1]==-1*dy) return true;;\\n        }\\n        return false;\\n    }\\n\\n    bool bfs(vector<vector<int>>& grid,vector<vector<vector<int>>>& moves){\\n        int m=grid.size(), n=grid[0].size();\\n\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n\\n        while(!q.empty()){\\n            auto p=q.front();   q.pop();\\n            int i=p[0], j=p[1];\\n\\n            vector<vector<int>> directions=moves[grid[i][j]];\\n\\n            for(int k=0;k<2;k++){\\n                int dx=directions[k][0], dy=directions[k][1];\\n                int x=i+dx,y=j+dy;\\n\\n                if(x>=0 && x<m && y>=0 && y<n && !visited[x][y]){\\n                    vector<vector<int>> reciever=moves[grid[x][y]];\\n                    if(!checkReciever(reciever,dx,dy)) continue;\\n                    \\n                    if(x==m-1 && y==n-1) return true;\\n                    q.push({x,y});\\n                    visited[x][y]=true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        if(m==1 && n==1) return true;\\n\\n        vector<vector<vector<int>>> moves={{}\\n                                            ,{{0,-1},{0,1}}\\n                                            ,{{1,0},{-1,0}}\\n                                            ,{{0,-1},{1,0}}\\n                                            ,{{1,0},{0,1}}\\n                                            ,{{-1,0},{0,-1}}\\n                                            ,{{-1,0},{0,1}}\\n                                            };\\n        \\n        return bfs(grid,moves);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743956,
                "title": "c-easy-bfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Keep All directions in 3D vector\\n2. In BFS, restrict moves as per street number given in matrix[i][j]\\n3. Keep a visited matrix also, to avoid revisiting same cells\\n3. Check if the cell which we are moving to can recieve our movement. \\n4. For e.g. we have 2 direction left or right in street 1, so street 1 tells us to move right suppose, but we have street 2 to the right, which cannot recieve our movement\\n\\n\\n\\n# Complexity\\n- Time complexity:O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkReciever(vector<vector<int>>& reciever, int dx, int dy){\\n        for(int i=0;i<2;i++){\\n            if(reciever[i][0]==-1*dx && reciever[i][1]==-1*dy) return true;;\\n        }\\n        return false;\\n    }\\n\\n    bool bfs(vector<vector<int>>& grid,vector<vector<vector<int>>>& moves){\\n        int m=grid.size(), n=grid[0].size();\\n\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n\\n        while(!q.empty()){\\n            auto p=q.front();   q.pop();\\n            int i=p[0], j=p[1];\\n\\n            vector<vector<int>> directions=moves[grid[i][j]];\\n\\n            for(int k=0;k<2;k++){\\n                int dx=directions[k][0], dy=directions[k][1];\\n                int x=i+dx,y=j+dy;\\n\\n                if(x>=0 && x<m && y>=0 && y<n && !visited[x][y]){\\n                    vector<vector<int>> reciever=moves[grid[x][y]];\\n                    if(!checkReciever(reciever,dx,dy)) continue;\\n                    \\n                    if(x==m-1 && y==n-1) return true;\\n                    q.push({x,y});\\n                    visited[x][y]=true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        if(m==1 && n==1) return true;\\n\\n        vector<vector<vector<int>>> moves={{}\\n                                            ,{{0,-1},{0,1}}\\n                                            ,{{1,0},{-1,0}}\\n                                            ,{{0,-1},{1,0}}\\n                                            ,{{1,0},{0,1}}\\n                                            ,{{-1,0},{0,-1}}\\n                                            ,{{-1,0},{0,1}}\\n                                            };\\n        \\n        return bfs(grid,moves);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkReciever(vector<vector<int>>& reciever, int dx, int dy){\\n        for(int i=0;i<2;i++){\\n            if(reciever[i][0]==-1*dx && reciever[i][1]==-1*dy) return true;;\\n        }\\n        return false;\\n    }\\n\\n    bool bfs(vector<vector<int>>& grid,vector<vector<vector<int>>>& moves){\\n        int m=grid.size(), n=grid[0].size();\\n\\n        queue<vector<int>> q;\\n        q.push({0,0});\\n\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        visited[0][0]=true;\\n\\n        while(!q.empty()){\\n            auto p=q.front();   q.pop();\\n            int i=p[0], j=p[1];\\n\\n            vector<vector<int>> directions=moves[grid[i][j]];\\n\\n            for(int k=0;k<2;k++){\\n                int dx=directions[k][0], dy=directions[k][1];\\n                int x=i+dx,y=j+dy;\\n\\n                if(x>=0 && x<m && y>=0 && y<n && !visited[x][y]){\\n                    vector<vector<int>> reciever=moves[grid[x][y]];\\n                    if(!checkReciever(reciever,dx,dy)) continue;\\n                    \\n                    if(x==m-1 && y==n-1) return true;\\n                    q.push({x,y});\\n                    visited[x][y]=true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        if(m==1 && n==1) return true;\\n\\n        vector<vector<vector<int>>> moves={{}\\n                                            ,{{0,-1},{0,1}}\\n                                            ,{{1,0},{-1,0}}\\n                                            ,{{0,-1},{1,0}}\\n                                            ,{{1,0},{0,1}}\\n                                            ,{{-1,0},{0,-1}}\\n                                            ,{{-1,0},{0,1}}\\n                                            };\\n        \\n        return bfs(grid,moves);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726821,
                "title": "dfs-dp-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O[m*n]$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O[m*n]$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> visited;\\n    vector<vector<int>> dp;\\n    bool hasValidPathHelper(int i,int j,vector<vector<int>>& grid,int m,int n){\\n        if(i<0 || j<0 || i>=m || j>=n || visited[i][j]){\\n            return false;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return true;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        visited[i][j]=true;\\n        if(grid[i][j]==1){\\n            bool possibleLeft=false,possibleRight=false;\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                possibleRight=hasValidPathHelper(i,j+1,grid,m,n);\\n            }\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                possibleLeft=hasValidPathHelper(i,j-1,grid,m,n);\\n            }\\n            return dp[i][j]=possibleLeft || possibleRight;\\n        }\\n        else if(grid[i][j]==2){\\n            bool possibleUp=false,possibleDown=false;\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                possibleUp=hasValidPathHelper(i-1,j,grid,m,n);\\n            }\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                possibleDown=hasValidPathHelper(i+1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleUp || possibleDown;\\n        }\\n        else if(grid[i][j]==3){\\n            bool possibleLeft=false,possibleDown=false;\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                possibleLeft=hasValidPathHelper(i,j-1,grid,m,n);\\n            }\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                possibleDown=hasValidPathHelper(i+1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleLeft || possibleDown;\\n        }\\n        else if(grid[i][j]==4){\\n            bool possibleRight=false,possibleDown=false;\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                possibleRight=hasValidPathHelper(i,j+1,grid,m,n);\\n            }\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                possibleDown=hasValidPathHelper(i+1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleRight || possibleDown;\\n        }\\n        else if(grid[i][j]==5){\\n            bool possibleLeft=false,possibleUp=false;\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                possibleLeft=hasValidPathHelper(i,j-1,grid,m,n);\\n            }\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                possibleUp=hasValidPathHelper(i-1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleLeft || possibleUp;\\n        }\\n        else if(grid[i][j]==6){\\n            bool possibleRight=false,possibleUp=false;\\n            if(j+1<n && grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5){\\n                possibleRight=hasValidPathHelper(i,j+1,grid,m,n);\\n            }\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                possibleUp=hasValidPathHelper(i-1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleRight || possibleUp;\\n        }\\n        visited[i][j]=false;\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        visited=vector<vector<bool>> (m,vector<bool> (n,0));\\n        dp=vector<vector<int>> (m,vector<int> (n,-1));\\n        return hasValidPathHelper(0,0,grid,m,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> visited;\\n    vector<vector<int>> dp;\\n    bool hasValidPathHelper(int i,int j,vector<vector<int>>& grid,int m,int n){\\n        if(i<0 || j<0 || i>=m || j>=n || visited[i][j]){\\n            return false;\\n        }\\n        if(i==m-1 && j==n-1){\\n            return true;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        visited[i][j]=true;\\n        if(grid[i][j]==1){\\n            bool possibleLeft=false,possibleRight=false;\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                possibleRight=hasValidPathHelper(i,j+1,grid,m,n);\\n            }\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                possibleLeft=hasValidPathHelper(i,j-1,grid,m,n);\\n            }\\n            return dp[i][j]=possibleLeft || possibleRight;\\n        }\\n        else if(grid[i][j]==2){\\n            bool possibleUp=false,possibleDown=false;\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                possibleUp=hasValidPathHelper(i-1,j,grid,m,n);\\n            }\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                possibleDown=hasValidPathHelper(i+1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleUp || possibleDown;\\n        }\\n        else if(grid[i][j]==3){\\n            bool possibleLeft=false,possibleDown=false;\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                possibleLeft=hasValidPathHelper(i,j-1,grid,m,n);\\n            }\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                possibleDown=hasValidPathHelper(i+1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleLeft || possibleDown;\\n        }\\n        else if(grid[i][j]==4){\\n            bool possibleRight=false,possibleDown=false;\\n            if(j+1<n && (grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5)){\\n                possibleRight=hasValidPathHelper(i,j+1,grid,m,n);\\n            }\\n            if(i+1<m && (grid[i+1][j]==2 || grid[i+1][j]==5 || grid[i+1][j]==6)){\\n                possibleDown=hasValidPathHelper(i+1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleRight || possibleDown;\\n        }\\n        else if(grid[i][j]==5){\\n            bool possibleLeft=false,possibleUp=false;\\n            if(j-1>=0 && (grid[i][j-1]==1 || grid[i][j-1]==4 || grid[i][j-1]==6)){\\n                possibleLeft=hasValidPathHelper(i,j-1,grid,m,n);\\n            }\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                possibleUp=hasValidPathHelper(i-1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleLeft || possibleUp;\\n        }\\n        else if(grid[i][j]==6){\\n            bool possibleRight=false,possibleUp=false;\\n            if(j+1<n && grid[i][j+1]==1 || grid[i][j+1]==3 || grid[i][j+1]==5){\\n                possibleRight=hasValidPathHelper(i,j+1,grid,m,n);\\n            }\\n            if(i-1>=0 && (grid[i-1][j]==2 || grid[i-1][j]==3 || grid[i-1][j]==4)){\\n                possibleUp=hasValidPathHelper(i-1,j,grid,m,n);\\n            }\\n            return dp[i][j]=possibleRight || possibleUp;\\n        }\\n        visited[i][j]=false;\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        visited=vector<vector<bool>> (m,vector<bool> (n,0));\\n        dp=vector<vector<int>> (m,vector<int> (n,-1));\\n        return hasValidPathHelper(0,0,grid,m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723257,
                "title": "simple-c-dfs-with-explanation-notes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we can see, there are only cells with exactly 2 entrances / exits. Thus, there are at most 2 ways to reach the final cell from the starting cell. Let\\'s employ DFS \\uD83D\\uDE09\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDepending on the cell kind we have a limited corresponding set of possible directions to go from that cell (aka we only have a limited set of allowed exits from the cell).\\n\\n**E.g.:** From the cell \\'1\\' we can only go left or right.\\n\\n![image.png](https://assets.leetcode.com/users/images/d660f0e6-6167-48f6-92e9-1644f0eb47d1_1688573510.0240421.png)\\n\\n\\nMoreover, we can\\'t just arrive into **any** the neighboring cell `y` by following the exits from the current cell `x`, because `y`\\'s entrance should be aligned with the used `x`\\'s exit (aka we only have a limited set of allowed enters into the cell).\\n\\n**E.g.:** Going right from cell 4 we can come into cell 5, but we can\\'t come to cell 6.\\n\\n![image.png](https://assets.leetcode.com/users/images/ad8e9dce-ef25-4f19-ab28-145a2e4f0078_1688573856.7739303.png)\\n\\nAlso, during our traversal we can\\'t enter into the cycle from outside the cycle (because each cell kind has only to enters/exits both of which should already be used be the cycle neighbors). But we can start from the cell inside the cycle. So, remembering the visited cells may come handy in order not enter the infinite loop.\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  \\nWorst time complexity example grid (and its traversal):\\n\\n![image.png](https://assets.leetcode.com/users/images/a5cfb716-6df5-4e41-9b39-c1c4e0ac132d_1688574424.0544958.png)\\n\\n# Code\\n```csharp\\npublic class Solution\\n{\\n\\tstatic readonly int[] Up = { -1, 0 };\\n\\tstatic readonly int[] Down = { 1, 0 };\\n\\tstatic readonly int[] Left = { 0, -1 };\\n\\tstatic readonly int[] Right = { 0, 1 };\\n\\n\\tstatic readonly int[] UpLandingZones = { 2, 3, 4 };\\n\\tstatic readonly int[] DownLandingZones = { 2, 5, 6 };\\n\\tstatic readonly int[] LeftLandingZones = { 1, 4, 6 };\\n\\tstatic readonly int[] RightLandingZones = { 1, 3, 5 };\\n\\n\\t// cellKind => [ (direction, validLandingCellKinds) ]\\n\\tstatic readonly (int[], int[])[][] Transitions = {\\n\\t\\tnull,\\n\\t\\tnew[]{ (Left, LeftLandingZones), (Right, RightLandingZones) },\\n\\t\\tnew[]{ (Up, UpLandingZones), (Down, DownLandingZones) },\\n\\t\\tnew[]{ (Down, DownLandingZones), (Left, LeftLandingZones) },\\n\\t\\tnew[]{ (Down, DownLandingZones), (Right, RightLandingZones) },\\n\\t\\tnew[]{ (Up, UpLandingZones), (Left, LeftLandingZones) },\\n\\t\\tnew[]{ (Up, UpLandingZones), (Right, RightLandingZones) },\\n\\t};\\n\\n\\tpublic bool HasValidPath(int[][] grid)\\n\\t{\\n\\t\\tint m = grid.Length, n = grid[0].Length;\\n\\t\\tvar visited = new bool[m, n];\\n\\n\\t\\treturn dfs(0, 0);\\n\\n\\t\\tbool dfs(int row, int col)\\n\\t\\t{\\n\\t\\t\\tif (row == m - 1 && col == n - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvisited[row, col] = true;\\n\\t\\t\\t\\n\\t\\t\\tforeach (var (dir, landingZones) in Transitions[grid[row][col]])\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar nextRow = row + dir[0];\\n\\t\\t\\t\\tvar nextCol = col + dir[1];\\n\\n\\t\\t\\t\\tif (0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n\\n\\t\\t\\t\\t\\t&& !visited[nextRow, nextCol]\\n\\t\\t\\t\\t\\t&& landingZones.Contains(grid[nextRow][nextCol]))\\n\\t\\t\\t\\t{\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (dfs(nextRow, nextCol))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n\\tstatic readonly int[] Up = { -1, 0 };\\n\\tstatic readonly int[] Down = { 1, 0 };\\n\\tstatic readonly int[] Left = { 0, -1 };\\n\\tstatic readonly int[] Right = { 0, 1 };\\n\\n\\tstatic readonly int[] UpLandingZones = { 2, 3, 4 };\\n\\tstatic readonly int[] DownLandingZones = { 2, 5, 6 };\\n\\tstatic readonly int[] LeftLandingZones = { 1, 4, 6 };\\n\\tstatic readonly int[] RightLandingZones = { 1, 3, 5 };\\n\\n\\t// cellKind => [ (direction, validLandingCellKinds) ]\\n\\tstatic readonly (int[], int[])[][] Transitions = {\\n\\t\\tnull,\\n\\t\\tnew[]{ (Left, LeftLandingZones), (Right, RightLandingZones) },\\n\\t\\tnew[]{ (Up, UpLandingZones), (Down, DownLandingZones) },\\n\\t\\tnew[]{ (Down, DownLandingZones), (Left, LeftLandingZones) },\\n\\t\\tnew[]{ (Down, DownLandingZones), (Right, RightLandingZones) },\\n\\t\\tnew[]{ (Up, UpLandingZones), (Left, LeftLandingZones) },\\n\\t\\tnew[]{ (Up, UpLandingZones), (Right, RightLandingZones) },\\n\\t};\\n\\n\\tpublic bool HasValidPath(int[][] grid)\\n\\t{\\n\\t\\tint m = grid.Length, n = grid[0].Length;\\n\\t\\tvar visited = new bool[m, n];\\n\\n\\t\\treturn dfs(0, 0);\\n\\n\\t\\tbool dfs(int row, int col)\\n\\t\\t{\\n\\t\\t\\tif (row == m - 1 && col == n - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvisited[row, col] = true;\\n\\t\\t\\t\\n\\t\\t\\tforeach (var (dir, landingZones) in Transitions[grid[row][col]])\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar nextRow = row + dir[0];\\n\\t\\t\\t\\tvar nextCol = col + dir[1];\\n\\n\\t\\t\\t\\tif (0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n\\n\\t\\t\\t\\t\\t&& !visited[nextRow, nextCol]\\n\\t\\t\\t\\t\\t&& landingZones.Contains(grid[nextRow][nextCol]))\\n\\t\\t\\t\\t{\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (dfs(nextRow, nextCol))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705359,
                "title": "easy-line-line-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool hasValidPath(vector<vector<int>> &grid)\\n    {\\n        // 1->r3, l4, r5 l6\\n        // 2->u3, d5, d6, u4\\n        // 3 ->l1, d2, l4, d5, d6\\n        // 4->r1, r3, d2, d5, d6;\\n        // 5->l1, u2, u3, u4, l6\\n        // 6-> r1, u2, u3, u4, r5\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        queue<pair<int, int>> qq;\\n        vector<vector<int>>vis(n, vector<int>(m, 0));\\n        vis[0][0]=1;\\n        qq.push({0, 0});\\n        while (!qq.empty())\\n        {\\n            int xx = qq.front().first;\\n            int yy = qq.front().second;\\n            if (xx == n - 1 && yy == m - 1)\\n            {\\n                return true;\\n            }\\n            qq.pop();\\n            for (int i = 0; i < 4; i++)\\n            {\\n                int nr = xx + drow[i];\\n                int nc = yy + dcol[i];\\n                if (nr >= 0 && nr < n && nc >= 0 && nc < m&&vis[nr][nc]==0)\\n                {\\n                    if (i == 0)\\n                    { // up\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 4||grid[nr][nc]==2)\\n                            {    vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 4 || grid[nr][nc] == 2)\\n                            {\\n                                vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 4 || grid[nr][nc] == 2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        // 1->r3, l4, r5 l6\\n                        // 2->u3, d5, d6, u4\\n                        // 3 ->l1, d2, l4, d5, d6\\n                        // 4->r1, r3, d2, d5, d6;\\n                        // 5->l1, u2, u3, u4, l6\\n                        // 6-> r1, u2, u3, u4, r5\\n                    }\\n                    else if (i == 1)\\n                    { // right\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 5||grid[nr][nc]==1)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        {   \\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 1||grid[nr][nc]==5)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 1||grid[nr][nc]==3)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                    }\\n                    else if (i == 2)\\n                    { // down\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        { // 1->r3, l4, r5 l6\\n                          // 2->u3, d5, d6, u4\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 6||grid[nr][nc]==2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n\\n                            } // 3 ->l1, d2, l4, d5, d6\\n                              // 4->r1, r3, d2, d5, d6;\\n                              // 5->l1, u2, u3, u4, l6\\n                            // 6-> r1, u2, u3, u4, r5\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 6 || grid[nr][nc] == 2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 6 || grid[nr][nc] == 2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            continue;\\n                        }\\n                    }\\n\\n                    // 1->r3, l4, r5 l6\\n                    // 2->u3, d5, d6, u4\\n                    // 3 ->l1, d2, l4, d5, d6\\n                    // 4->r1, r3, d2, d5, d6;\\n                    // 5->l1, u2, u3, u4, l6\\n                    // 6-> r1, u2, u3, u4, r5\\n                    else if (i == 3)\\n                    { // left\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            if (grid[nr][nc] == 4 || grid[nr][nc] == 6||grid[nr][nc]==1)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            if (grid[nr][nc] == 4 || grid[nr][nc] == 1||grid[nr][nc]==6)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            if (grid[nr][nc] == 1 || grid[nr][nc] == 6||grid[nr][nc]==4)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            continue;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool hasValidPath(vector<vector<int>> &grid)\\n    {\\n        // 1->r3, l4, r5 l6\\n        // 2->u3, d5, d6, u4\\n        // 3 ->l1, d2, l4, d5, d6\\n        // 4->r1, r3, d2, d5, d6;\\n        // 5->l1, u2, u3, u4, l6\\n        // 6-> r1, u2, u3, u4, r5\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        queue<pair<int, int>> qq;\\n        vector<vector<int>>vis(n, vector<int>(m, 0));\\n        vis[0][0]=1;\\n        qq.push({0, 0});\\n        while (!qq.empty())\\n        {\\n            int xx = qq.front().first;\\n            int yy = qq.front().second;\\n            if (xx == n - 1 && yy == m - 1)\\n            {\\n                return true;\\n            }\\n            qq.pop();\\n            for (int i = 0; i < 4; i++)\\n            {\\n                int nr = xx + drow[i];\\n                int nc = yy + dcol[i];\\n                if (nr >= 0 && nr < n && nc >= 0 && nc < m&&vis[nr][nc]==0)\\n                {\\n                    if (i == 0)\\n                    { // up\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 4||grid[nr][nc]==2)\\n                            {    vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 4 || grid[nr][nc] == 2)\\n                            {\\n                                vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 4 || grid[nr][nc] == 2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        // 1->r3, l4, r5 l6\\n                        // 2->u3, d5, d6, u4\\n                        // 3 ->l1, d2, l4, d5, d6\\n                        // 4->r1, r3, d2, d5, d6;\\n                        // 5->l1, u2, u3, u4, l6\\n                        // 6-> r1, u2, u3, u4, r5\\n                    }\\n                    else if (i == 1)\\n                    { // right\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 5||grid[nr][nc]==1)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        {   \\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            if (grid[nr][nc] == 3 || grid[nr][nc] == 1||grid[nr][nc]==5)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 1||grid[nr][nc]==3)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                    }\\n                    else if (i == 2)\\n                    { // down\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        { // 1->r3, l4, r5 l6\\n                          // 2->u3, d5, d6, u4\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 6||grid[nr][nc]==2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n\\n                            } // 3 ->l1, d2, l4, d5, d6\\n                              // 4->r1, r3, d2, d5, d6;\\n                              // 5->l1, u2, u3, u4, l6\\n                            // 6-> r1, u2, u3, u4, r5\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 6 || grid[nr][nc] == 2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            if (grid[nr][nc] == 5 || grid[nr][nc] == 6 || grid[nr][nc] == 2)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            continue;\\n                        }\\n                    }\\n\\n                    // 1->r3, l4, r5 l6\\n                    // 2->u3, d5, d6, u4\\n                    // 3 ->l1, d2, l4, d5, d6\\n                    // 4->r1, r3, d2, d5, d6;\\n                    // 5->l1, u2, u3, u4, l6\\n                    // 6-> r1, u2, u3, u4, r5\\n                    else if (i == 3)\\n                    { // left\\n                        if (grid[xx][yy] == 1)\\n                        {\\n                            if (grid[nr][nc] == 4 || grid[nr][nc] == 6||grid[nr][nc]==1)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 2)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 3)\\n                        {\\n                            if (grid[nr][nc] == 4 || grid[nr][nc] == 1||grid[nr][nc]==6)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 4)\\n                        {\\n                            continue;\\n                        }\\n                        else if (grid[xx][yy] == 5)\\n                        {\\n                            if (grid[nr][nc] == 1 || grid[nr][nc] == 6||grid[nr][nc]==4)\\n                            {   vis[nr][nc]=1;\\n                                qq.push({nr, nc});\\n                            }\\n                        }\\n                        else if (grid[xx][yy] == 6)\\n                        {\\n                            continue;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703440,
                "title": "easy-to-understand-javascript-solution-dfs",
                "content": "```\\nvar hasValidPath = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const connectMap = { left: \\'right\\', right: \\'left\\', upper: \\'lower\\', lower: \\'upper\\' };\\n    const moreMap = {\\n        left: { row: 0, col: -1 }, \\n        right: { row: 0, col: 1 },  \\n        upper: { row: -1, col: 0 }, \\n        lower: { row: 1, col: 0 }, \\n    };\\n    const streetMap = {\\n        1: [\\'left\\', \\'right\\'],\\n        2: [\\'upper\\', \\'lower\\'],\\n        3: [\\'left\\', \\'lower\\'],\\n        4: [\\'lower\\', \\'right\\'],\\n        5: [\\'left\\', \\'upper\\'],\\n        6: [\\'upper\\', \\'right\\'],\\n    };\\n    const isValidPath = (row, col, connect, visited = new Set()) => {\\n        if (row >= m || col >= n || row < 0 || col < 0) return false;\\n        if (visited.has(`${row}_${col}`)) return false;\\n        const street = streetMap[grid[row][col]];\\n        const startStreet = street.indexOf(connect);\\n        const isConnect = startStreet > -1;\\n        if (!isConnect) return false;\\n        if (row === m - 1 && col === n - 1) return true;\\n\\n        const endStreet = startStreet ? street[0] : street[1];\\n        const move = moreMap[endStreet];\\n        const nextConnect = connectMap[endStreet];\\n\\n        visited.add(`${row}_${col}`);\\n        return isValidPath(row + move.row, col + move.col, nextConnect, visited);\\n    };\\n    const [directionA, directionB] = streetMap[grid[0][0]];\\n\\n    return isValidPath(0, 0, directionA) || isValidPath(0, 0, directionB);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasValidPath = function(grid) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const connectMap = { left: \\'right\\', right: \\'left\\', upper: \\'lower\\', lower: \\'upper\\' };\\n    const moreMap = {\\n        left: { row: 0, col: -1 }, \\n        right: { row: 0, col: 1 },  \\n        upper: { row: -1, col: 0 }, \\n        lower: { row: 1, col: 0 }, \\n    };\\n    const streetMap = {\\n        1: [\\'left\\', \\'right\\'],\\n        2: [\\'upper\\', \\'lower\\'],\\n        3: [\\'left\\', \\'lower\\'],\\n        4: [\\'lower\\', \\'right\\'],\\n        5: [\\'left\\', \\'upper\\'],\\n        6: [\\'upper\\', \\'right\\'],\\n    };\\n    const isValidPath = (row, col, connect, visited = new Set()) => {\\n        if (row >= m || col >= n || row < 0 || col < 0) return false;\\n        if (visited.has(`${row}_${col}`)) return false;\\n        const street = streetMap[grid[row][col]];\\n        const startStreet = street.indexOf(connect);\\n        const isConnect = startStreet > -1;\\n        if (!isConnect) return false;\\n        if (row === m - 1 && col === n - 1) return true;\\n\\n        const endStreet = startStreet ? street[0] : street[1];\\n        const move = moreMap[endStreet];\\n        const nextConnect = connectMap[endStreet];\\n\\n        visited.add(`${row}_${col}`);\\n        return isValidPath(row + move.row, col + move.col, nextConnect, visited);\\n    };\\n    const [directionA, directionB] = streetMap[grid[0][0]];\\n\\n    return isValidPath(0, 0, directionA) || isValidPath(0, 0, directionB);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683045,
                "title": "c-iterative",
                "content": "# Intuition\\nBecause there aren\\'t crossroads in this task we can move straingforward along the road there is a iterative solution.\\n\\n# Approach\\nFor easier reading I put position offsets, that depends on the road type in a vector `roads`.\\n\\n# Complexity\\n- Time complexity: $$O(nm)$$\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nnamespace {\\nstruct V {\\n    int x{}, y{};\\n    bool operator==(const V& rhs) const {\\n        return rhs.x == x && rhs.y == y;\\n    }\\n    V operator+(const V& rhs) const {\\n        return V{x + rhs.x, y + rhs.y};\\n    }\\n};\\nconst vector<pair<V, V>> roads = {\\n    {{-1, 0}, {1, 0}},\\n    {{0, -1}, {0, 1}},\\n    {{-1, 0}, {0, 1}},\\n    {{1, 0}, {0, 1}},\\n    {{-1, 0}, {0, -1}},\\n    {{0, -1}, {1, 0}},\\n};\\n}\\n\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        if (grid.size() == 1 && grid[0].size() == 1)\\n            return true;\\n        const auto& t = roads[grid[0][0] - 1];\\n        return trackPath(grid, t.first) || trackPath(grid, t.second);\\n    }\\n\\nprivate:\\n    bool trackPath(vector<vector<int>>& grid, V c) {\\n        V p;  // previous position; start from (0, 0)\\n        while (c.x != grid[0].size() - 1 || c.y != grid.size() - 1) {\\n            // returned to the start - found a loop\\n            if (c.x == 0 && c.y == 0)\\n                return false;\\n            // moved from the field\\n            if (c.x < 0 || c.y < 0 || c.x >= grid[0].size() || c.y >= grid.size())\\n                return false;\\n\\n            const auto& t = roads[grid[c.y][c.x] - 1];\\n            if (p == c + t.first) {\\n                // from first to second\\n                p = exchange(c, c + t.second);\\n            } else if (p == c + t.second) {\\n                // from second to first\\n                p = exchange(c, c + t.first);\\n            } else {\\n                // meet incorrect road configuration\\n                return false;\\n            }\\n        }\\n\\n        const auto& t = roads[grid[c.y][c.x] - 1];\\n        return t.first + c == p || t.second + c == p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnamespace {\\nstruct V {\\n    int x{}, y{};\\n    bool operator==(const V& rhs) const {\\n        return rhs.x == x && rhs.y == y;\\n    }\\n    V operator+(const V& rhs) const {\\n        return V{x + rhs.x, y + rhs.y};\\n    }\\n};\\nconst vector<pair<V, V>> roads = {\\n    {{-1, 0}, {1, 0}},\\n    {{0, -1}, {0, 1}},\\n    {{-1, 0}, {0, 1}},\\n    {{1, 0}, {0, 1}},\\n    {{-1, 0}, {0, -1}},\\n    {{0, -1}, {1, 0}},\\n};\\n}\\n\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        if (grid.size() == 1 && grid[0].size() == 1)\\n            return true;\\n        const auto& t = roads[grid[0][0] - 1];\\n        return trackPath(grid, t.first) || trackPath(grid, t.second);\\n    }\\n\\nprivate:\\n    bool trackPath(vector<vector<int>>& grid, V c) {\\n        V p;  // previous position; start from (0, 0)\\n        while (c.x != grid[0].size() - 1 || c.y != grid.size() - 1) {\\n            // returned to the start - found a loop\\n            if (c.x == 0 && c.y == 0)\\n                return false;\\n            // moved from the field\\n            if (c.x < 0 || c.y < 0 || c.x >= grid[0].size() || c.y >= grid.size())\\n                return false;\\n\\n            const auto& t = roads[grid[c.y][c.x] - 1];\\n            if (p == c + t.first) {\\n                // from first to second\\n                p = exchange(c, c + t.second);\\n            } else if (p == c + t.second) {\\n                // from second to first\\n                p = exchange(c, c + t.first);\\n            } else {\\n                // meet incorrect road configuration\\n                return false;\\n            }\\n        }\\n\\n        const auto& t = roads[grid[c.y][c.x] - 1];\\n        return t.first + c == p || t.second + c == p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682239,
                "title": "very-brute-method-simple-implementation-of-basic-dfs-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,set<pair<int,int>>> m;\\n    int n,mm;\\n    bool dfs(vector<vector<int>>& v, int r, int c, vector<vector<int>>&vis){\\n        vis[r][c]=1;\\n        if(r==n-1 && c==mm-1) return true;\\n        // vector<int> temp=m[v[r][c]];\\n        for(auto i:m[v[r][c]]){\\n            int nr=r+i.first;\\n            int nc=c+i.second;\\n            if(nr>=0 && nc>=0 && nr<n && nc<mm && vis[nr][nc]==0 && m[v[nr][nc]].find({-1*i.first,-1*i.second})!=m[v[nr][nc]].end()){\\n                /* in this checking if current node has right than its child must have left and so on */\\n                if(dfs(v,nr,nc,vis)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m[1]={{0,-1},{0,1}};\\n        m[2]={{-1,0},{1,0}};\\n        m[3]={{0,-1},{1,0}};\\n        m[4]={{0,1},{1,0}};\\n        m[5]={{0,-1},{-1,0}};\\n        m[6]={{0,1},{-1,0}};\\n        n=grid.size();\\n        mm=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(mm,0));\\n        return dfs(grid,0,0,vis);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,set<pair<int,int>>> m;\\n    int n,mm;\\n    bool dfs(vector<vector<int>>& v, int r, int c, vector<vector<int>>&vis){\\n        vis[r][c]=1;\\n        if(r==n-1 && c==mm-1) return true;\\n        // vector<int> temp=m[v[r][c]];\\n        for(auto i:m[v[r][c]]){\\n            int nr=r+i.first;\\n            int nc=c+i.second;\\n            if(nr>=0 && nc>=0 && nr<n && nc<mm && vis[nr][nc]==0 && m[v[nr][nc]].find({-1*i.first,-1*i.second})!=m[v[nr][nc]].end()){\\n                /* in this checking if current node has right than its child must have left and so on */\\n                if(dfs(v,nr,nc,vis)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        m[1]={{0,-1},{0,1}};\\n        m[2]={{-1,0},{1,0}};\\n        m[3]={{0,-1},{1,0}};\\n        m[4]={{0,1},{1,0}};\\n        m[5]={{0,-1},{-1,0}};\\n        m[6]={{0,1},{-1,0}};\\n        n=grid.size();\\n        mm=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(mm,0));\\n        return dfs(grid,0,0,vis);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676946,
                "title": "bfs-python-solution",
                "content": "# Approach\\nWe have taken entry and exit coordinates for each direction given in the question as shown below.\\n```\\ndirections={1:[(0,-1),(0,1)],\\n            2:[(1,0),(-1,0)],\\n            3:[(0,-1),(1,0)],\\n            4:[(0,1),(1,0)],\\n            5:[(0,-1),(-1,0)],\\n            6:[(0,1),(-1,0)]}\\n```\\nTo explain the above directions let me take an example.\\n![image.png](https://assets.leetcode.com/users/images/93eed343-f352-433a-bd89-8a6be083e0f8_1687605830.341373.png)\\n\\n```\\n1:[ Entrypoint->(0,-1),exitpoint->(0,1) ]\\n\\nlets say, street 1 grid position is (x,y)\\nyou can enter into steet-1 (x,y) from grid position (x,y-1) ie.,(x+0,y-1)\\nand to exit from street-1 (x,y) to (x,y+1) ie., (x+0,y+1)\\n```\\n**We can exit from one street and enter other street only when they are connected.**\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        rows,cols=len(grid),len(grid[0])\\n        directions={1:[(0,-1),(0,1)],2:[(1,0),(-1,0)],3:[(0,-1),(1,0)],\\n                    4:[(0,1),(1,0)],5:[(0,-1),(-1,0)],6:[(0,1),(-1,0)]}\\n        queue=deque()\\n        visit=set()\\n        queue.append((0,0))\\n        visit.add((0,0))\\n        while queue:\\n            x,y=queue.popleft()\\n            if x==rows-1 and y==cols-1:\\n                return True\\n            for dx,dy in directions[grid[x][y]]:\\n                newx=x+dx\\n                newy=y+dy\\n                if 0<=newx<rows and 0<=newy<cols and (newx,newy) not in visit:\\n                    #Checking whether two streets are connected or not\\n                    #If connected append (newx,newy) to the queue\\n                    if (-dx,-dy) in directions[grid[newx][newy]]:\\n                        queue.append((newx,newy))\\n                        visit.add((newx,newy))\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\ndirections={1:[(0,-1),(0,1)],\\n            2:[(1,0),(-1,0)],\\n            3:[(0,-1),(1,0)],\\n            4:[(0,1),(1,0)],\\n            5:[(0,-1),(-1,0)],\\n            6:[(0,1),(-1,0)]}\\n```\n```\\n1:[ Entrypoint->(0,-1),exitpoint->(0,1) ]\\n\\nlets say, street 1 grid position is (x,y)\\nyou can enter into steet-1 (x,y) from grid position (x,y-1) ie.,(x+0,y-1)\\nand to exit from street-1 (x,y) to (x,y+1) ie., (x+0,y+1)\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        rows,cols=len(grid),len(grid[0])\\n        directions={1:[(0,-1),(0,1)],2:[(1,0),(-1,0)],3:[(0,-1),(1,0)],\\n                    4:[(0,1),(1,0)],5:[(0,-1),(-1,0)],6:[(0,1),(-1,0)]}\\n        queue=deque()\\n        visit=set()\\n        queue.append((0,0))\\n        visit.add((0,0))\\n        while queue:\\n            x,y=queue.popleft()\\n            if x==rows-1 and y==cols-1:\\n                return True\\n            for dx,dy in directions[grid[x][y]]:\\n                newx=x+dx\\n                newy=y+dy\\n                if 0<=newx<rows and 0<=newy<cols and (newx,newy) not in visit:\\n                    #Checking whether two streets are connected or not\\n                    #If connected append (newx,newy) to the queue\\n                    if (-dx,-dy) in directions[grid[newx][newy]]:\\n                        queue.append((newx,newy))\\n                        visit.add((newx,newy))\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669998,
                "title": "93-faster-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n\\n        def left(x,y, vis):\\n            if 0<= y and (x,y) not in vis and grid[x][y] in (1,4,6):\\n                return True\\n            return False\\n\\n        def right(x,y, vis):\\n            if y < n and (x, y) not in vis and grid[x][y] in (1,3,5):\\n                return True\\n            return False\\n\\n        def up(x,y, vis):\\n            if 0<= x and (x, y) not in vis and grid[x][y] in (3,4,2):\\n                return True\\n            return False\\n        \\n        def down(x,y, vis):\\n            if x < m and (x,y) not in vis and grid[x][y] in (5,6,2):\\n                return True\\n            return False\\n\\n\\n        def dfs(i, j, visit):\\n            if i == m -1 and j == n-1:\\n                return True\\n            \\n            visit.add((i,j))\\n            if grid[i][j] == 1:\\n                if left(i, j-1, visit) and dfs(i, j-1, visit):\\n                    return True\\n                if right(i, j+1, visit) and dfs(i, j+1, visit):\\n                    return True\\n                \\n            elif grid[i][j] == 2:\\n                if up(i-1, j, visit) and dfs(i-1, j, visit):\\n                    return True\\n                if down(i+1, j, visit) and dfs(i+1, j, visit):\\n                    return True\\n                \\n            elif grid[i][j] == 3:\\n                if left(i, j-1, visit) and dfs(i, j-1, visit):\\n                    return True\\n                if down(i+1, j, visit) and dfs(i+1, j, visit):\\n                    return True\\n            elif grid[i][j] ==4:\\n                if right(i, j+1, visit) and dfs(i, j+1, visit):\\n                    return True\\n                if down(i+1,j, visit) and dfs(i+1,j, visit):\\n                    return True\\n            elif grid[i][j] == 5:\\n                if left(i, j-1, visit) and dfs(i, j-1, visit):\\n                    return True\\n                if up(i-1, j, visit) and dfs(i-1, j, visit):\\n                    return True\\n            elif grid[i][j] ==6:\\n                if right(i, j+1, visit) and dfs(i, j+1, visit):\\n                    return True\\n                if up(i-1, j , visit) and dfs(i-1, j, visit):\\n                    return True\\n            return False\\n            \\n        \\n\\n        return dfs(0,0, set())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n\\n        def left(x,y, vis):\\n            if 0<= y and (x,y) not in vis and grid[x][y] in (1,4,6):\\n                return True\\n            return False\\n\\n        def right(x,y, vis):\\n            if y < n and (x, y) not in vis and grid[x][y] in (1,3,5):\\n                return True\\n            return False\\n\\n        def up(x,y, vis):\\n            if 0<= x and (x, y) not in vis and grid[x][y] in (3,4,2):\\n                return True\\n            return False\\n        \\n        def down(x,y, vis):\\n            if x < m and (x,y) not in vis and grid[x][y] in (5,6,2):\\n                return True\\n            return False\\n\\n\\n        def dfs(i, j, visit):\\n            if i == m -1 and j == n-1:\\n                return True\\n            \\n            visit.add((i,j))\\n            if grid[i][j] == 1:\\n                if left(i, j-1, visit) and dfs(i, j-1, visit):\\n                    return True\\n                if right(i, j+1, visit) and dfs(i, j+1, visit):\\n                    return True\\n                \\n            elif grid[i][j] == 2:\\n                if up(i-1, j, visit) and dfs(i-1, j, visit):\\n                    return True\\n                if down(i+1, j, visit) and dfs(i+1, j, visit):\\n                    return True\\n                \\n            elif grid[i][j] == 3:\\n                if left(i, j-1, visit) and dfs(i, j-1, visit):\\n                    return True\\n                if down(i+1, j, visit) and dfs(i+1, j, visit):\\n                    return True\\n            elif grid[i][j] ==4:\\n                if right(i, j+1, visit) and dfs(i, j+1, visit):\\n                    return True\\n                if down(i+1,j, visit) and dfs(i+1,j, visit):\\n                    return True\\n            elif grid[i][j] == 5:\\n                if left(i, j-1, visit) and dfs(i, j-1, visit):\\n                    return True\\n                if up(i-1, j, visit) and dfs(i-1, j, visit):\\n                    return True\\n            elif grid[i][j] ==6:\\n                if right(i, j+1, visit) and dfs(i, j+1, visit):\\n                    return True\\n                if up(i-1, j , visit) and dfs(i-1, j, visit):\\n                    return True\\n            return False\\n            \\n        \\n\\n        return dfs(0,0, set())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652084,
                "title": "easy-solution-java-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int M,N;\\n    static int[][] dirs = {{-1,0},{0,-1},{1,0},{0,1}};\\n    static Map<Integer,int[][]> rulesMap = new HashMap<>();\\n    static {\\n        int[][] fs = {{0,-1,1,4,6},{0,1,1,3,5}};\\n        rulesMap.put(1, fs);\\n        fs = new int[][]{{-1,0,2,3,4},{1,0,2,5,6}};\\n        rulesMap.put(2,fs);\\n        fs = new int[][]{{0,-1,1,4,6},{1,0,2,5,6}};\\n        rulesMap.put(3,fs);\\n        fs = new int[][]{{1,0, 2,5,6}, {0,1,1,3,5}};\\n        rulesMap.put(4,fs);\\n        fs = new int[][]{{-1,0,2,3,4},{0,-1,1,4,6}};\\n        rulesMap.put(5,fs);\\n        fs = new int[][]{{-1,0,2,3,4}, {0,1,1,3,5}};\\n        rulesMap.put(6,fs);\\n    }\\n    public boolean hasValidPath(int[][] grid) {\\n        M = grid.length;\\n        N = grid[0].length;\\n        boolean[][] visited = new boolean[M][N];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0});\\n        visited[0][0] = true;\\n        while(!q.isEmpty()) {\\n            int[] curr = q.poll();\\n            if(curr[0]==M-1 && curr[1]==N-1)\\n            return true;\\n            for(int[] dir : dirs) {\\n                int x = dir[0]+curr[0];\\n                int y = dir[1]+curr[1];\\n                if(isValid(x,y) && !visited[x][y]) {\\n                    int rl = grid[curr[0]][curr[1]];\\n                    int[][] rules = rulesMap.get(rl);\\n                    boolean flag = false;\\n                    for(int[] rule : rules) {\\n                        if(dir[0]==rule[0] && dir[1]==rule[1]) {\\n                            for(int i=2; i<rule.length; i++) {\\n                                if(grid[x][y]==rule[i]) {\\n                                    q.add(new int[]{x,y});\\n                                    visited[x][y] = true;\\n                                    flag= true;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        if(flag)\\n                        break;\\n                    }\\n                 }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    boolean isValid(int i, int j) {\\n        if(i<0 || j<0 || i>=M || j>=N)\\n        return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int M,N;\\n    static int[][] dirs = {{-1,0},{0,-1},{1,0},{0,1}};\\n    static Map<Integer,int[][]> rulesMap = new HashMap<>();\\n    static {\\n        int[][] fs = {{0,-1,1,4,6},{0,1,1,3,5}};\\n        rulesMap.put(1, fs);\\n        fs = new int[][]{{-1,0,2,3,4},{1,0,2,5,6}};\\n        rulesMap.put(2,fs);\\n        fs = new int[][]{{0,-1,1,4,6},{1,0,2,5,6}};\\n        rulesMap.put(3,fs);\\n        fs = new int[][]{{1,0, 2,5,6}, {0,1,1,3,5}};\\n        rulesMap.put(4,fs);\\n        fs = new int[][]{{-1,0,2,3,4},{0,-1,1,4,6}};\\n        rulesMap.put(5,fs);\\n        fs = new int[][]{{-1,0,2,3,4}, {0,1,1,3,5}};\\n        rulesMap.put(6,fs);\\n    }\\n    public boolean hasValidPath(int[][] grid) {\\n        M = grid.length;\\n        N = grid[0].length;\\n        boolean[][] visited = new boolean[M][N];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0});\\n        visited[0][0] = true;\\n        while(!q.isEmpty()) {\\n            int[] curr = q.poll();\\n            if(curr[0]==M-1 && curr[1]==N-1)\\n            return true;\\n            for(int[] dir : dirs) {\\n                int x = dir[0]+curr[0];\\n                int y = dir[1]+curr[1];\\n                if(isValid(x,y) && !visited[x][y]) {\\n                    int rl = grid[curr[0]][curr[1]];\\n                    int[][] rules = rulesMap.get(rl);\\n                    boolean flag = false;\\n                    for(int[] rule : rules) {\\n                        if(dir[0]==rule[0] && dir[1]==rule[1]) {\\n                            for(int i=2; i<rule.length; i++) {\\n                                if(grid[x][y]==rule[i]) {\\n                                    q.add(new int[]{x,y});\\n                                    visited[x][y] = true;\\n                                    flag= true;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        if(flag)\\n                        break;\\n                    }\\n                 }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    boolean isValid(int i, int j) {\\n        if(i<0 || j<0 || i>=M || j>=N)\\n        return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644539,
                "title": "follow-the-route-until-you-can",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        ## edges bottom 0, left 1, top 2, right 3\\n        street_cons = [(-1, -1), (1, 3), (0, 2), (0, 1), (0, 3), (1, 2), (2, 3)]\\n        dirs = [(1, 0), (0, -1), (-1, 0), (0, 1)]\\n\\n        m, n = len(grid), len(grid[0])\\n        if m==1 and n==1:\\n            return True\\n\\n        def next_cell(pos, side):\\n            i, j = pos\\n            a, b = street_cons[grid[i][j]]\\n            if a == side:\\n                out = b\\n            elif b == side:\\n                out = a\\n            else:\\n                return  -1, -1\\n            \\n            di, dj = dirs[out]\\n            i, j = i+di, j+dj\\n            if i < 0 or i >= m or j < 0 or j >= n or (i, j) == (0, 0):\\n                return -1, -1\\n            return (i, j), (out + 2) % 4\\n\\n        \\n        for side in street_cons[grid[0][0]]:\\n            pos, side = next_cell((0, 0), side)\\n            while side != -1 and pos != (m-1, n-1):\\n                pos, side = next_cell(pos, side)\\n            if pos == (m-1, n-1) and (side in street_cons[grid[-1][-1]]):\\n                return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        ## edges bottom 0, left 1, top 2, right 3\\n        street_cons = [(-1, -1), (1, 3), (0, 2), (0, 1), (0, 3), (1, 2), (2, 3)]\\n        dirs = [(1, 0), (0, -1), (-1, 0), (0, 1)]\\n\\n        m, n = len(grid), len(grid[0])\\n        if m==1 and n==1:\\n            return True\\n\\n        def next_cell(pos, side):\\n            i, j = pos\\n            a, b = street_cons[grid[i][j]]\\n            if a == side:\\n                out = b\\n            elif b == side:\\n                out = a\\n            else:\\n                return  -1, -1\\n            \\n            di, dj = dirs[out]\\n            i, j = i+di, j+dj\\n            if i < 0 or i >= m or j < 0 or j >= n or (i, j) == (0, 0):\\n                return -1, -1\\n            return (i, j), (out + 2) % 4\\n\\n        \\n        for side in street_cons[grid[0][0]]:\\n            pos, side = next_cell((0, 0), side)\\n            while side != -1 and pos != (m-1, n-1):\\n                pos, side = next_cell(pos, side)\\n            if pos == (m-1, n-1) and (side in street_cons[grid[-1][-1]]):\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619631,
                "title": "c-dfs-path",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tvector<vector<pair<int, int>>> direction = {\\n\\t\\t{{0,-1}, {0,1}}, {{-1,0}, {1,0}}, // left-right, up-down\\n\\t\\t{{0,-1}, {1,0}}, {{0,1}, {1,0}}, // left-down, right-down\\n\\t\\t{{0,-1}, {-1,0}}, {{0,1}, {-1,0}} // left-up, right-up\\n\\t};\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n    \\tint m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({0,0}); \\n\\t\\tvis[0][0] = true;\\n        bool reachDestination = false;\\n        while(q.size() && !reachDestination){\\n        \\tint size = q.size();\\n        \\tfor(int i=0; i<size; i++){\\n        \\t\\tint curX = q.front().first;\\n        \\t\\tint curY = q.front().second;\\n        \\t\\tq.pop();\\n        \\t\\tif(curX == m-1 && curY==n-1){\\n        \\t\\t\\treachDestination = true;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\tfor(auto p: direction[grid[curX][curY]-1]){ \\n        \\t\\t\\tint x = curX+p.first;\\n        \\t\\t\\tint y = curY+p.second;\\n        \\t\\t\\tif(x<0 or y<0 or x>=m or y>= n or vis[x][y]){\\n        \\t\\t\\t\\tcontinue;\\n        \\t\\t\\t}else{ \\n        \\t\\t\\t\\tfor(auto p2: direction[grid[x][y]-1]){\\n        \\t\\t\\t\\t\\tif(curX == x+p2.first && curY == y+p2.second){\\n        \\t\\t\\t\\t\\t\\tq.push({x, y});\\n\\t\\t\\t\\t\\t\\t\\t\\tvis[x][y] = true;\\n        \\t\\t\\t\\t\\t}\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return reachDestination;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<pair<int, int>>> direction = {\\n\\t\\t{{0,-1}, {0,1}}, {{-1,0}, {1,0}}, // left-right, up-down\\n\\t\\t{{0,-1}, {1,0}}, {{0,1}, {1,0}}, // left-down, right-down\\n\\t\\t{{0,-1}, {-1,0}}, {{0,1}, {-1,0}} // left-up, right-up\\n\\t};\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n    \\tint m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> vis(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({0,0}); \\n\\t\\tvis[0][0] = true;\\n        bool reachDestination = false;\\n        while(q.size() && !reachDestination){\\n        \\tint size = q.size();\\n        \\tfor(int i=0; i<size; i++){\\n        \\t\\tint curX = q.front().first;\\n        \\t\\tint curY = q.front().second;\\n        \\t\\tq.pop();\\n        \\t\\tif(curX == m-1 && curY==n-1){\\n        \\t\\t\\treachDestination = true;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t\\tfor(auto p: direction[grid[curX][curY]-1]){ \\n        \\t\\t\\tint x = curX+p.first;\\n        \\t\\t\\tint y = curY+p.second;\\n        \\t\\t\\tif(x<0 or y<0 or x>=m or y>= n or vis[x][y]){\\n        \\t\\t\\t\\tcontinue;\\n        \\t\\t\\t}else{ \\n        \\t\\t\\t\\tfor(auto p2: direction[grid[x][y]-1]){\\n        \\t\\t\\t\\t\\tif(curX == x+p2.first && curY == y+p2.second){\\n        \\t\\t\\t\\t\\t\\tq.push({x, y});\\n\\t\\t\\t\\t\\t\\t\\t\\tvis[x][y] = true;\\n        \\t\\t\\t\\t\\t}\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return reachDestination;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610090,
                "title": "1391-check-if-there-is-a-valid-path-in-a-grid",
                "content": "[Java Solution BFS](https://github.com/pratham1singh/Leetcode-Solutions-In-Java/commit/3f338a1cfe54e075b71c84fec86eaf6ca68f36ef)\\n```\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600116,
                "title": "c-solution-with-explanation-clean-code-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPath is to be finded . So BFS or DFS can be used to traverse the matrix.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple , we just have to apply bfs to matrix ,hard thing is know if we can go from one cell to another or not.\\n    I\\'m using map to store if it possible to go from one type to another and in which direction.\\n\\n---\\n\\n\\nmp[type,dir]={types we cann go };\\ndirections==> 0 - left, 1 - up, 2 - right, 3 - down\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n       queue<pair<int,pair<int,int>>>qt;//store {type,{row,col}}\\n       qt.push({grid[0][0],{0,0}});\\n       vector<vector<int>>visited(m,vector<int>(n,0));//visited arr\\n       visited[0][0]=1;\\n       int drow[]={0,-1,0,1};//all possible dirn 0->left (index)\\n       int dcol[]={-1,0,1,0};\\n        map<pair<int,int>,vector<int>>mp;//map to store valid path\\n       mp[{1,0}]={1,4,6};\\n       mp[{1,2}]={1,3,5};\\n       mp[{2,1}]={2,4,3};\\n       mp[{2,3}]={2,5,6};\\n       mp[{3,0}]={4,6,1};\\n       mp[{3,3}]={5,6,2};\\n       mp[{4,3}]={5,6,2};\\n       mp[{4,2}]={3,1,5};\\n       mp[{5,0}]={1,4,6};\\n       mp[{5,1}]={2,3,4};\\n       mp[{6,1}]={2,3,4};\\n       mp[{6,2}]={3,5,1};\\n         while(!qt.empty()){\\n             auto it=qt.front();\\n             qt.pop();\\n             int type=it.first;\\n             int r=it.second.first;\\n             int c=it.second.second;\\n             for(int i=0;i<4;i++){\\n                 int nrow=r+drow[i];\\n                 int ncol=c+dcol[i];\\n                 if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && visited[nrow][ncol]==0){\\n                     int newType=grid[nrow][ncol];\\n                     vector<int>can=mp[{type,i}];\\n                    //checking if we can go there or not\\n                     auto it=find(can.begin(),can.end(),newType);\\n                     if(it !=can.end()){\\n                         visited[nrow][ncol]=1;\\n                         qt.push({newType,{nrow,ncol}});\\n                     }\\n                 }\\n             }\\n        }\\n        return visited[m-1][n-1]==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n       queue<pair<int,pair<int,int>>>qt;//store {type,{row,col}}\\n       qt.push({grid[0][0],{0,0}});\\n       vector<vector<int>>visited(m,vector<int>(n,0));//visited arr\\n       visited[0][0]=1;\\n       int drow[]={0,-1,0,1};//all possible dirn 0->left (index)\\n       int dcol[]={-1,0,1,0};\\n        map<pair<int,int>,vector<int>>mp;//map to store valid path\\n       mp[{1,0}]={1,4,6};\\n       mp[{1,2}]={1,3,5};\\n       mp[{2,1}]={2,4,3};\\n       mp[{2,3}]={2,5,6};\\n       mp[{3,0}]={4,6,1};\\n       mp[{3,3}]={5,6,2};\\n       mp[{4,3}]={5,6,2};\\n       mp[{4,2}]={3,1,5};\\n       mp[{5,0}]={1,4,6};\\n       mp[{5,1}]={2,3,4};\\n       mp[{6,1}]={2,3,4};\\n       mp[{6,2}]={3,5,1};\\n         while(!qt.empty()){\\n             auto it=qt.front();\\n             qt.pop();\\n             int type=it.first;\\n             int r=it.second.first;\\n             int c=it.second.second;\\n             for(int i=0;i<4;i++){\\n                 int nrow=r+drow[i];\\n                 int ncol=c+dcol[i];\\n                 if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && visited[nrow][ncol]==0){\\n                     int newType=grid[nrow][ncol];\\n                     vector<int>can=mp[{type,i}];\\n                    //checking if we can go there or not\\n                     auto it=find(can.begin(),can.end(),newType);\\n                     if(it !=can.end()){\\n                         visited[nrow][ncol]=1;\\n                         qt.push({newType,{nrow,ncol}});\\n                     }\\n                 }\\n             }\\n        }\\n        return visited[m-1][n-1]==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588071,
                "title": "simple-c-dfs-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple dfs solution\\n\\n![image.png](https://assets.leetcode.com/users/images/c51d0872-6b43-4763-894e-aa41dcd2431c_1685681344.537065.png)\\n\\nabove image is represented as\\n[2,4,3]\\n[6,5,2]\\n\\nabove grid is converted into 3*n X 3*m matrix\\n0 1 0  0 0 0  0 0 0 \\n0 1 0  0 1 1  1 1 0 \\n0 1 0  0 1 0  0 1 0 \\n0 1 0  0 1 0  0 1 0 \\n0 1 1  1 1 0  0 1 0 \\n0 0 0  0 0 0  0 1 0 \\n\\n2-> [[0 1 0],[0 1 0],[0 1 0]]\\n4-> [[0 0 0],[0 1 1],[0 1 0]]\\nand so on\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,bool &ans,vector<vector<int>>& mat)\\n    {\\n        if(i<0||j<0||i>=mat.size()||j>=mat[0].size()||mat[i][j]==0)\\n        {\\n            return ;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n\\n        //check bottom right cell centre\\n        if(i==n-2&&j==m-2)\\n        {\\n            ans=1;\\n            return;\\n        }\\n        mat[i][j]=0;\\n        \\n        dfs(i+1,j,ans,mat);\\n        dfs(i,j+1,ans,mat);\\n        dfs(i-1,j,ans,mat);\\n        dfs(i,j-1,ans,mat);\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // each cell of grid is divided into 3*3 matrix\\n        vector<vector<int>> mat(3*n,vector<int>(3*m,0));\\n        \\n        //mat\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int x1=i*3;\\n                int y1=j*3;\\n                \\n                if(grid[i][j]==1)\\n                {\\n                    mat[x1+1][y1+2]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+1][y1]=1;\\n                }\\n                else if(grid[i][j]==2)\\n                {\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+2][y1+1]=1;\\n                    mat[x1][y1+1]=1;\\n                }\\n                else if(grid[i][j]==3)\\n                {\\n                    mat[x1+1][y1]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+2][y1+1]=1;\\n                }\\n                else if(grid[i][j]==4)\\n                {\\n                    mat[x1+1][y1+2]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+2][y1+1]=1;\\n                }\\n                else if(grid[i][j]==5)\\n                {\\n                    mat[x1][y1+1]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+1][y1]=1;\\n                }\\n                else if(grid[i][j]==6)\\n                {\\n                    mat[x1][y1+1]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+1][y1+2]=1;\\n                }\\n            }\\n        }\\n        //print the matrix to check it is correct or not\\n//         for(int i=0;i<mat.size();i++)\\n//         {\\n//             for(int j=0;j<mat[0].size();j++)\\n//             {\\n//                 cout<<mat[i][j]<<\" \";\\n//             }\\n//             cout<<endl;\\n//         }\\n        \\n        bool ans=0;\\n        //dfs start from 1,1 because all street pass through centre\\n        if(mat[1][1]==1)dfs(1,1,ans,mat);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,bool &ans,vector<vector<int>>& mat)\\n    {\\n        if(i<0||j<0||i>=mat.size()||j>=mat[0].size()||mat[i][j]==0)\\n        {\\n            return ;\\n        }\\n        int n=mat.size();\\n        int m=mat[0].size();\\n\\n        //check bottom right cell centre\\n        if(i==n-2&&j==m-2)\\n        {\\n            ans=1;\\n            return;\\n        }\\n        mat[i][j]=0;\\n        \\n        dfs(i+1,j,ans,mat);\\n        dfs(i,j+1,ans,mat);\\n        dfs(i-1,j,ans,mat);\\n        dfs(i,j-1,ans,mat);\\n    }\\n    \\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        // each cell of grid is divided into 3*3 matrix\\n        vector<vector<int>> mat(3*n,vector<int>(3*m,0));\\n        \\n        //mat\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int x1=i*3;\\n                int y1=j*3;\\n                \\n                if(grid[i][j]==1)\\n                {\\n                    mat[x1+1][y1+2]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+1][y1]=1;\\n                }\\n                else if(grid[i][j]==2)\\n                {\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+2][y1+1]=1;\\n                    mat[x1][y1+1]=1;\\n                }\\n                else if(grid[i][j]==3)\\n                {\\n                    mat[x1+1][y1]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+2][y1+1]=1;\\n                }\\n                else if(grid[i][j]==4)\\n                {\\n                    mat[x1+1][y1+2]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+2][y1+1]=1;\\n                }\\n                else if(grid[i][j]==5)\\n                {\\n                    mat[x1][y1+1]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+1][y1]=1;\\n                }\\n                else if(grid[i][j]==6)\\n                {\\n                    mat[x1][y1+1]=1;\\n                    mat[x1+1][y1+1]=1;\\n                    mat[x1+1][y1+2]=1;\\n                }\\n            }\\n        }\\n        //print the matrix to check it is correct or not\\n//         for(int i=0;i<mat.size();i++)\\n//         {\\n//             for(int j=0;j<mat[0].size();j++)\\n//             {\\n//                 cout<<mat[i][j]<<\" \";\\n//             }\\n//             cout<<endl;\\n//         }\\n        \\n        bool ans=0;\\n        //dfs start from 1,1 because all street pass through centre\\n        if(mat[1][1]==1)dfs(1,1,ans,mat);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3587576,
                "title": "10-line-simple-dfs-w-less-constants-defined-above",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        directions = {\\n            1: [(0,-1),(0,1)],\\n            2: [(-1,0),(1,0)],\\n            3: [(0,-1),(1,0)],\\n            4: [(0,1),(1,0)],\\n            5: [(0,-1),(-1,0)],\\n            6: [(0,1),(-1,0)]\\n        }\\n        visited = set()\\n        def dfs(i, j):\\n            visited.add((i,j))\\n            if (i,j) == (len(grid)-1, len(grid[0]) - 1):\\n                return True \\n            ret = False\\n            for r, c in directions[grid[i][j]]:\\n                row, col = i+r, j+c\\n                if row<0 or col<0 or row>=len(grid) or col>=len(grid[0]):\\n                    continue \\n                if (row, col) in visited:\\n                    continue \\n                nexx = grid[row][col]\\n                if (-r, -c) in directions[nexx]:\\n                    ret = ret or dfs(row, col)\\n            return ret\\n        return dfs(0,0)\\n```\\n\\n# Inside the recursive dfs: [See above code]\\n- We start at current cell (i, j).\\n- We add current cell to visited set() so we don\\'t revisit it.\\n- If we have reached the last cell already, we return True.\\n- If not, we fetch the two directions we can move to from here on, that we have already defined in directions.\\n- We loop through those directions and move over if:\\n        1. next (row, col) is inbound  and\\n        2. inverse of (-r, -c) is in directions of grid[row][col], i.e it is possible to even get in that cell from the direction we are trying to get in, and\\n        3. (row, col) is not already visited \\n- Now we start at first cell and move to all possible cells following the current path, returning OR of result of all those paths. If we ever get to target cell, we return True.\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        directions = {\\n            1: [(0,-1),(0,1)],\\n            2: [(-1,0),(1,0)],\\n            3: [(0,-1),(1,0)],\\n            4: [(0,1),(1,0)],\\n            5: [(0,-1),(-1,0)],\\n            6: [(0,1),(-1,0)]\\n        }\\n        visited = set()\\n        def dfs(i, j):\\n            visited.add((i,j))\\n            if (i,j) == (len(grid)-1, len(grid[0]) - 1):\\n                return True \\n            ret = False\\n            for r, c in directions[grid[i][j]]:\\n                row, col = i+r, j+c\\n                if row<0 or col<0 or row>=len(grid) or col>=len(grid[0]):\\n                    continue \\n                if (row, col) in visited:\\n                    continue \\n                nexx = grid[row][col]\\n                if (-r, -c) in directions[nexx]:\\n                    ret = ret or dfs(row, col)\\n            return ret\\n        return dfs(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546663,
                "title": "go-bfs",
                "content": "\\n# Code\\n```\\nfunc hasValidPath(grid [][]int) bool {\\n    m, n := len(grid), len(grid[0])\\n    up, down, left, right := [2]int{-1, 0}, [2]int{1, 0}, [2]int{0, -1}, [2]int{0, 1}\\n    directions := [][2]int{up, down, left, right}\\n    validNext := map[int]map[[2]int][]int{\\n        1: {left: {1, 4, 6}, right: {1, 3, 5}},\\n        2: {up: {2, 3, 4}, down: {2, 5, 6}},\\n        3: {left: {1, 4, 6}, down: {2, 5, 6}},\\n        4: {right: {1, 3, 5}, down: {2, 5, 6}},\\n        5: {left: {1, 4, 6}, up: {2, 3, 4}},\\n        6: {right: {1, 3, 5}, up: {2, 3, 4}},\\n    }\\n    visited := make([][]int, m)\\n    for i := 0; i < m; i++ {\\n        visited[i] = make([]int, n)\\n    }\\n    visited[0][0] = 1\\n    queue := make([][2]int, 0, 10)\\n    queue = append(queue, [2]int{0, 0})\\n    for len(queue) > 0 {\\n        x, y := queue[0][0], queue[0][1]\\n        queue = queue[1:]\\n        if x == m-1 && y == n-1 {\\n            return true\\n        }\\n        curr := grid[x][y]\\n        // fmt.Println(curr)\\n        for _, dir := range directions {\\n            dx, dy := x+dir[0], y+dir[1]\\n            if dx >= 0 && dx < m && dy >= 0 && dy < n && visited[dx][dy] == 0 {\\n                // fmt.Println(curr, dir)\\n                for _, next := range validNext[curr][dir] {\\n                    // fmt.Println(curr, next)\\n                    if next == grid[dx][dy] {\\n                        queue = append(queue, [2]int{dx, dy})\\n                        visited[dx][dy] = 1\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc hasValidPath(grid [][]int) bool {\\n    m, n := len(grid), len(grid[0])\\n    up, down, left, right := [2]int{-1, 0}, [2]int{1, 0}, [2]int{0, -1}, [2]int{0, 1}\\n    directions := [][2]int{up, down, left, right}\\n    validNext := map[int]map[[2]int][]int{\\n        1: {left: {1, 4, 6}, right: {1, 3, 5}},\\n        2: {up: {2, 3, 4}, down: {2, 5, 6}},\\n        3: {left: {1, 4, 6}, down: {2, 5, 6}},\\n        4: {right: {1, 3, 5}, down: {2, 5, 6}},\\n        5: {left: {1, 4, 6}, up: {2, 3, 4}},\\n        6: {right: {1, 3, 5}, up: {2, 3, 4}},\\n    }\\n    visited := make([][]int, m)\\n    for i := 0; i < m; i++ {\\n        visited[i] = make([]int, n)\\n    }\\n    visited[0][0] = 1\\n    queue := make([][2]int, 0, 10)\\n    queue = append(queue, [2]int{0, 0})\\n    for len(queue) > 0 {\\n        x, y := queue[0][0], queue[0][1]\\n        queue = queue[1:]\\n        if x == m-1 && y == n-1 {\\n            return true\\n        }\\n        curr := grid[x][y]\\n        // fmt.Println(curr)\\n        for _, dir := range directions {\\n            dx, dy := x+dir[0], y+dir[1]\\n            if dx >= 0 && dx < m && dy >= 0 && dy < n && visited[dx][dy] == 0 {\\n                // fmt.Println(curr, dir)\\n                for _, next := range validNext[curr][dir] {\\n                    // fmt.Println(curr, next)\\n                    if next == grid[dx][dy] {\\n                        queue = append(queue, [2]int{dx, dy})\\n                        visited[dx][dy] = 1\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536100,
                "title": "painful-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npain\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> adj(n * m);\\n        vector<int> vis(n * m, 0);\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    if (j < m - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j + 1);\\n                    }\\n                    if (j > 0 && (grid[i][j - 1] == 4 || grid[i][j - 1] == 6 || grid[i][j - 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j - 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 2) {\\n                    if (i < n - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i + 1) * m) + j);\\n                    }\\n                    if (i > 0 && (grid[i - 1][j] == 4 || grid[i - 1][j] == 6 || grid[i - 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i - 1) * m) + j);\\n                    }\\n                }\\n                else if (grid[i][j] == 3) {\\n                    if (i < n - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i + 1) * m) + j);\\n                    }\\n                    if (j > 0 && (grid[i][j - 1] == 4 || grid[i][j - 1] == 6 || grid[i][j - 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j - 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 4) {\\n                    if (i < n - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i + 1) * m) + j);\\n                    }\\n                    if (j < m - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j + 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 5) {\\n                    if (i > 0 && (grid[i - 1][j] == 3 || grid[i - 1][j] == 4 || grid[i - 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i - 1) * m) + j);\\n                    }\\n                    if (j > 0 && (grid[i][j - 1] == 6 || grid[i][j - 1] == 4 || grid[i][j - 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j - 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 6) {\\n                    if (i > 0 && (grid[i - 1][j] == 3 || grid[i - 1][j] == 4 || grid[i - 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i - 1) * m) + j);\\n                    }\\n                    if (j < m - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j + 1);\\n                    }\\n                }\\n            }\\n        }\\n        q.push(0);\\n        while(!q.empty()) {\\n            int k = q.front();\\n            q.pop();\\n            if (k == n * m - 1) {\\n                return true;\\n            }\\n            for (int i = 0; i < adj[k].size(); ++i) {\\n                if (!vis[adj[k][i]]) {\\n                    vis[adj[k][i]] = 1;\\n                    q.push(adj[k][i]);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> adj(n * m);\\n        vector<int> vis(n * m, 0);\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    if (j < m - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j + 1);\\n                    }\\n                    if (j > 0 && (grid[i][j - 1] == 4 || grid[i][j - 1] == 6 || grid[i][j - 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j - 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 2) {\\n                    if (i < n - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i + 1) * m) + j);\\n                    }\\n                    if (i > 0 && (grid[i - 1][j] == 4 || grid[i - 1][j] == 6 || grid[i - 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i - 1) * m) + j);\\n                    }\\n                }\\n                else if (grid[i][j] == 3) {\\n                    if (i < n - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i + 1) * m) + j);\\n                    }\\n                    if (j > 0 && (grid[i][j - 1] == 4 || grid[i][j - 1] == 6 || grid[i][j - 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j - 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 4) {\\n                    if (i < n - 1 && (grid[i + 1][j] == 5 || grid[i + 1][j] == 6 || grid[i + 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i + 1) * m) + j);\\n                    }\\n                    if (j < m - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j + 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 5) {\\n                    if (i > 0 && (grid[i - 1][j] == 3 || grid[i - 1][j] == 4 || grid[i - 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i - 1) * m) + j);\\n                    }\\n                    if (j > 0 && (grid[i][j - 1] == 6 || grid[i][j - 1] == 4 || grid[i][j - 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j - 1);\\n                    }\\n                }\\n                else if (grid[i][j] == 6) {\\n                    if (i > 0 && (grid[i - 1][j] == 3 || grid[i - 1][j] == 4 || grid[i - 1][j] == 2)) {\\n                        adj[(i * m) + j].push_back(((i - 1) * m) + j);\\n                    }\\n                    if (j < m - 1 && (grid[i][j + 1] == 3 || grid[i][j + 1] == 5 || grid[i][j + 1] == 1)) {\\n                        adj[(i * m) + j].push_back((i * m) + j + 1);\\n                    }\\n                }\\n            }\\n        }\\n        q.push(0);\\n        while(!q.empty()) {\\n            int k = q.front();\\n            q.pop();\\n            if (k == n * m - 1) {\\n                return true;\\n            }\\n            for (int i = 0; i < adj[k].size(); ++i) {\\n                if (!vis[adj[k][i]]) {\\n                    vis[adj[k][i]] = 1;\\n                    q.push(adj[k][i]);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440897,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][][] dirs = {\\n                {{0, -1}, {0, 1}},\\n                {{-1, 0}, {1, 0}},\\n                {{0, -1}, {1, 0}},\\n                {{0, 1}, {1, 0}},\\n                {{0, -1}, {-1, 0}},\\n                {{0, 1}, {-1, 0}}\\n    };\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int x = cur[0], y = cur[1];\\n            int num = grid[x][y] - 1;\\n            for (int[] dir : dirs[num]) {\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || visited[nx][ny]) continue;\\n                for (int[] backDir : dirs[grid[nx][ny] - 1])\\n                    if (nx + backDir[0] == x && ny + backDir[1] == y) {\\n                        visited[nx][ny] = true;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n            }\\n        }\\n        return visited[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][][] dirs = {\\n                {{0, -1}, {0, 1}},\\n                {{-1, 0}, {1, 0}},\\n                {{0, -1}, {1, 0}},\\n                {{0, 1}, {1, 0}},\\n                {{0, -1}, {-1, 0}},\\n                {{0, 1}, {-1, 0}}\\n    };\\n    public boolean hasValidPath(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n        while (!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int x = cur[0], y = cur[1];\\n            int num = grid[x][y] - 1;\\n            for (int[] dir : dirs[num]) {\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || visited[nx][ny]) continue;\\n                for (int[] backDir : dirs[grid[nx][ny] - 1])\\n                    if (nx + backDir[0] == x && ny + backDir[1] == y) {\\n                        visited[nx][ny] = true;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n            }\\n        }\\n        return visited[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410542,
                "title": "java-16ms-beats-95-dfs-and-clear-code",
                "content": "# Approach\\n1. Starting from cell [m][n] determine if you reach [0][0] if you walk on the road described/linked by each cell\\n2. Use 4 directions to travel: UP (1), RIGHT 2, DOWN 3 and LEFT 4.\\n3. Each cell/street has two modifiers, depending of the direction in which you ENTER this cell.\\n    - if you enter a cell 6 with a LEFT orientation, then your coords modifiers will be {-1, 0} (going up by 1 row)\\n    - if you enter a cell 6 with a DOWN orientation, then your coords modifiers will be {0, 1} (going left by 1 )\\n4. Declare an array of 6 such objects, each with two modifiers, based on direction\\n5. Pay special attention to edge case of [m][n]\\n    - if cell is 4. Return false immediately\\n    - if cell if 5, you could be stepping here from cell above or cell on the right, so you need to check both\\n6. Starting from cell [m][n] step each cell and see if you reach [0][0].\\nIf you get stuck in a cell (cell 2 cannot connect to cell 1) or step outside matrix, return false.\\n7. Use a recursive function to step each connected cell. \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(6)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static final int UP = 1, RIGHT = 2, DOWN = 3, LEFT = 4;\\n    private static StreetConnection[] streets;\\n    public boolean hasValidPath(int[][] grid) {\\n        initializeStreets();\\n        int[] location = {grid.length -1, grid[0].length -1};\\n        int cellNo = grid[location[0]][location[1]];\\n        boolean canFinish;\\n        if (cellNo == 4) {\\n            canFinish = false;\\n        } else if (cellNo == 5) {\\n            int[] cloneLoc = {location[0], location[1]};\\n            canFinish = hasValidPath(RIGHT, location, grid) || hasValidPath(DOWN, cloneLoc, grid);\\n        } else {\\n            canFinish = hasValidPath(cellNo == 1 || cellNo == 6 ? LEFT : UP, location, grid);\\n        }\\n        return canFinish;\\n    }\\n\\n    private boolean hasValidPath(int direction, int[] location, int[][] grid) {\\n        if (location[0] == 0 && location[1] == 0) {\\n            return true;\\n        }\\n        if (location[0] < 0 || location[0] >= grid.length || location[1] < 0 || location[1] >= grid[0].length) {\\n            return false;\\n        }\\n        StreetConnection currentCell = streets[grid[location[0]][location[1]]];\\n        int newDirection = currentCell.getNewCoordsAndDirection(direction, location);\\n        if (newDirection != -1) {\\n            return hasValidPath(newDirection, location, grid);\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    private void initializeStreets() {\\n        if (streets == null) {\\n            streets = new StreetConnection[]{null,\\n                new StreetConnection(RIGHT, new int[]{0, 1}, LEFT, new int[]{0, -1}),\\n                new StreetConnection(UP, new int[]{-1, 0}, DOWN, new int[]{1, 0}),\\n                new StreetConnection(RIGHT, new int[]{1, 0}, UP, new int[]{0, -1}),\\n                new StreetConnection(LEFT, new int[]{1, 0}, UP, new int[]{0, 1}),\\n                new StreetConnection(DOWN, new int[]{0, -1}, RIGHT, new int[]{-1, 0}),\\n                new StreetConnection(DOWN, new int[]{0, 1}, LEFT, new int[]{-1, 0})};\\n        }\\n    }\\n\\n    private static class StreetConnection {\\n        private int direction1, direction2;\\n        private int[] coefficient1, coefficient2;\\n\\n        public StreetConnection(int d1, int[] c1, int d2, int[] c2) {\\n            this.direction1 = d1;\\n            this.coefficient1 = c1;\\n            this.direction2 = d2;\\n            this.coefficient2 = c2;\\n        }\\n\\n        public int getNewCoordsAndDirection(int direction, int[] current) {\\n            int x = current[0];\\n            int y = current[1];\\n            if (direction == direction1) {\\n                current[0] += coefficient1[0];\\n                current[1] += coefficient1[1];\\n            } else if (direction == direction2) {\\n                current[0] += coefficient2[0];\\n                current[1] += coefficient2[1];\\n            } else {\\n                return -1;\\n            }\\n            return detectChangeOfDirection(x, y, current[0], current[1]);\\n        }\\n\\n        private int detectChangeOfDirection(int oldX, int oldY, int newX, int newY) {\\n            if (oldX == newX) {\\n                return oldY < newY ? RIGHT : LEFT;\\n            } else {\\n                return oldX < newX ? DOWN : UP;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int UP = 1, RIGHT = 2, DOWN = 3, LEFT = 4;\\n    private static StreetConnection[] streets;\\n    public boolean hasValidPath(int[][] grid) {\\n        initializeStreets();\\n        int[] location = {grid.length -1, grid[0].length -1};\\n        int cellNo = grid[location[0]][location[1]];\\n        boolean canFinish;\\n        if (cellNo == 4) {\\n            canFinish = false;\\n        } else if (cellNo == 5) {\\n            int[] cloneLoc = {location[0], location[1]};\\n            canFinish = hasValidPath(RIGHT, location, grid) || hasValidPath(DOWN, cloneLoc, grid);\\n        } else {\\n            canFinish = hasValidPath(cellNo == 1 || cellNo == 6 ? LEFT : UP, location, grid);\\n        }\\n        return canFinish;\\n    }\\n\\n    private boolean hasValidPath(int direction, int[] location, int[][] grid) {\\n        if (location[0] == 0 && location[1] == 0) {\\n            return true;\\n        }\\n        if (location[0] < 0 || location[0] >= grid.length || location[1] < 0 || location[1] >= grid[0].length) {\\n            return false;\\n        }\\n        StreetConnection currentCell = streets[grid[location[0]][location[1]]];\\n        int newDirection = currentCell.getNewCoordsAndDirection(direction, location);\\n        if (newDirection != -1) {\\n            return hasValidPath(newDirection, location, grid);\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    private void initializeStreets() {\\n        if (streets == null) {\\n            streets = new StreetConnection[]{null,\\n                new StreetConnection(RIGHT, new int[]{0, 1}, LEFT, new int[]{0, -1}),\\n                new StreetConnection(UP, new int[]{-1, 0}, DOWN, new int[]{1, 0}),\\n                new StreetConnection(RIGHT, new int[]{1, 0}, UP, new int[]{0, -1}),\\n                new StreetConnection(LEFT, new int[]{1, 0}, UP, new int[]{0, 1}),\\n                new StreetConnection(DOWN, new int[]{0, -1}, RIGHT, new int[]{-1, 0}),\\n                new StreetConnection(DOWN, new int[]{0, 1}, LEFT, new int[]{-1, 0})};\\n        }\\n    }\\n\\n    private static class StreetConnection {\\n        private int direction1, direction2;\\n        private int[] coefficient1, coefficient2;\\n\\n        public StreetConnection(int d1, int[] c1, int d2, int[] c2) {\\n            this.direction1 = d1;\\n            this.coefficient1 = c1;\\n            this.direction2 = d2;\\n            this.coefficient2 = c2;\\n        }\\n\\n        public int getNewCoordsAndDirection(int direction, int[] current) {\\n            int x = current[0];\\n            int y = current[1];\\n            if (direction == direction1) {\\n                current[0] += coefficient1[0];\\n                current[1] += coefficient1[1];\\n            } else if (direction == direction2) {\\n                current[0] += coefficient2[0];\\n                current[1] += coefficient2[1];\\n            } else {\\n                return -1;\\n            }\\n            return detectChangeOfDirection(x, y, current[0], current[1]);\\n        }\\n\\n        private int detectChangeOfDirection(int oldX, int oldY, int newX, int newY) {\\n            if (oldX == newX) {\\n                return oldY < newY ? RIGHT : LEFT;\\n            } else {\\n                return oldX < newX ? DOWN : UP;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398931,
                "title": "bfs-for-my-own-reference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        h=[[], [1,0,1,0], [0,1,0,1], [1,0,0,1], [0,0,1,1], [1,1,0,0], [0,1,1,0]]\\n        n, m, x, y = len(grid), len(grid[0]), 0, 0\\n        def isValid(new_x, new_y):\\n            return 0 <= new_x < n and 0 <= new_y < m and grid[new_x][new_y] > 0\\n        q = deque([(x, y)])\\n        while q:\\n            x, y = q.popleft()\\n            left, up, right, down = h[grid[x][y]]\\n            grid[x][y] = -grid[x][y]\\n            if left:\\n                new_x, new_y = x, y - 1\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [1, 3, 5] and new in [1, 4, 6]:\\n                        q.append((new_x, new_y))\\n            if up:\\n                new_x, new_y = x - 1, y\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [2, 5, 6] and new in [2, 3, 4]:\\n                        q.append((new_x, new_y))\\n            if right:\\n                new_x, new_y = x, y + 1\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [1, 4, 6] and new in [1, 3, 5]:\\n                        q.append((new_x, new_y))\\n            if down:\\n                new_x, new_y = x + 1, y\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [2, 3, 4] and new in [2, 5, 6]:\\n                        q.append((new_x, new_y))\\n        return grid[-1][-1] < 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        h=[[], [1,0,1,0], [0,1,0,1], [1,0,0,1], [0,0,1,1], [1,1,0,0], [0,1,1,0]]\\n        n, m, x, y = len(grid), len(grid[0]), 0, 0\\n        def isValid(new_x, new_y):\\n            return 0 <= new_x < n and 0 <= new_y < m and grid[new_x][new_y] > 0\\n        q = deque([(x, y)])\\n        while q:\\n            x, y = q.popleft()\\n            left, up, right, down = h[grid[x][y]]\\n            grid[x][y] = -grid[x][y]\\n            if left:\\n                new_x, new_y = x, y - 1\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [1, 3, 5] and new in [1, 4, 6]:\\n                        q.append((new_x, new_y))\\n            if up:\\n                new_x, new_y = x - 1, y\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [2, 5, 6] and new in [2, 3, 4]:\\n                        q.append((new_x, new_y))\\n            if right:\\n                new_x, new_y = x, y + 1\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [1, 4, 6] and new in [1, 3, 5]:\\n                        q.append((new_x, new_y))\\n            if down:\\n                new_x, new_y = x + 1, y\\n                if isValid(new_x, new_y):\\n                    old, new = abs(grid[x][y]), grid[new_x][new_y]\\n                    if old in [2, 3, 4] and new in [2, 5, 6]:\\n                        q.append((new_x, new_y))\\n        return grid[-1][-1] < 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395182,
                "title": "python-bfs-beats-97-44",
                "content": "# Intuition\\nBreadth-first search, try to go through all possible destinations\\n\\n# Approach\\ndirection is represented by int:\\n0: left\\n1: top\\n2: right\\n3: bottom\\nwe also hard-code all kinds of streets.\\n\\nfor each pos, we first try to see if the direction we enter it is valid. after that, we get the new position after it goes through this street.\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        h, w = len(grid), len(grid[0])\\n        queue = [(0,0,i) for i in range(4)]\\n        visited = set()\\n        xs = [0, -1, 0, 1]\\n        ys = [-1, 0, 1, 0]\\n        streets = [(0, 2), (1, 3), (0, 3), (2, 3), (0, 1), (1, 2)]\\n        for p in queue:\\n            if p in visited:\\n                continue\\n            x, y, side = p\\n            if x < 0 or x >= h or y < 0 or y >= w:\\n                continue\\n            # print(p)\\n            visited.add(p)\\n            s_type = streets[grid[x][y]-1]\\n            if side not in s_type:\\n                continue\\n            if x == h-1 and y == w-1:\\n                return True\\n            d = sum(s_type) - side\\n            nx, ny = x + xs[d], y + ys[d]\\n            nside = (d + 2) % 4\\n            queue.append((nx, ny, nside))\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        h, w = len(grid), len(grid[0])\\n        queue = [(0,0,i) for i in range(4)]\\n        visited = set()\\n        xs = [0, -1, 0, 1]\\n        ys = [-1, 0, 1, 0]\\n        streets = [(0, 2), (1, 3), (0, 3), (2, 3), (0, 1), (1, 2)]\\n        for p in queue:\\n            if p in visited:\\n                continue\\n            x, y, side = p\\n            if x < 0 or x >= h or y < 0 or y >= w:\\n                continue\\n            # print(p)\\n            visited.add(p)\\n            s_type = streets[grid[x][y]-1]\\n            if side not in s_type:\\n                continue\\n            if x == h-1 and y == w-1:\\n                return True\\n            d = sum(s_type) - side\\n            nx, ny = x + xs[d], y + ys[d]\\n            nside = (d + 2) % 4\\n            queue.append((nx, ny, nside))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358842,
                "title": "python-dfs-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\ndfs(i, j) walk to the bottom-right cell from position(i, j),\\nAt position (0, 0), we have 2 paths to go at most.\\nAt the bottom-right cell, dfs return true\\nat the rest cells (i, j), we only has 1 path to go, and should check the next cell we go have `road`,\\ne.g., we go to right, and the right cell have road at its left side.\\nWhen passing throgh the cell, we destroy the cell, so we never go back.\\ntc is O(len(grid)*len(grid[0])), sc is O(road length) = O(len(grid)*len(grid[0]))\\n\\'\\'\\'\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        streets = [\\n            [0,0,1,1], [1,1,0,0],\\n            [0,1,1,0], [0,1,0,1],\\n            [1,0,1,0], [1,0,0,1],\\n        ] # [top, bottom, left, right], 1 is road\\n        numRow, numCol = len(grid), len(grid[0])\\n        if numRow == numCol == 1: return True\\n\\n        def dfs(i, j):\\n            if i == numRow - 1 and j == numCol - 1: return True\\n            if streets[grid[i][j]-1][0] and i-1 >= 0 and grid[i-1][j] != -1 and streets[grid[i-1][j]-1][1]:\\n                grid[i][j] = -1\\n                return dfs(i-1, j)\\n            elif streets[grid[i][j]-1][1] and i+1 < numRow and grid[i+1][j] != -1 and streets[grid[i+1][j]-1][0]:\\n                grid[i][j] = -1\\n                return dfs(i+1, j) \\n            elif streets[grid[i][j]-1][2] and j-1 >= 0 and grid[i][j-1] != -1 and streets[grid[i][j-1]-1][3]:\\n                grid[i][j] = -1\\n                return dfs(i, j-1) \\n            elif streets[grid[i][j]-1][3] and j+1 < numCol and grid[i][j+1] != -1 and streets[grid[i][j+1]-1][2]:\\n                grid[i][j] = -1\\n                return dfs(i, j+1)\\n            return False\\n        tmp = grid[0][0] - 1\\n        grid[0][0] = -1\\n        \\n        if (streets[tmp][1] and 1 < numRow and streets[grid[1][0]-1][0] and dfs(1, 0)) or (streets[tmp][3] and 1 < numCol and streets[grid[0][1]-1][2] and dfs(0, 1)): return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\n\\'\\'\\'\\ndfs(i, j) walk to the bottom-right cell from position(i, j),\\nAt position (0, 0), we have 2 paths to go at most.\\nAt the bottom-right cell, dfs return true\\nat the rest cells (i, j), we only has 1 path to go, and should check the next cell we go have `road`,\\ne.g., we go to right, and the right cell have road at its left side.\\nWhen passing throgh the cell, we destroy the cell, so we never go back.\\ntc is O(len(grid)*len(grid[0])), sc is O(road length) = O(len(grid)*len(grid[0]))\\n\\'\\'\\'\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        streets = [\\n            [0,0,1,1], [1,1,0,0],\\n            [0,1,1,0], [0,1,0,1],\\n            [1,0,1,0], [1,0,0,1],\\n        ] # [top, bottom, left, right], 1 is road\\n        numRow, numCol = len(grid), len(grid[0])\\n        if numRow == numCol == 1: return True\\n\\n        def dfs(i, j):\\n            if i == numRow - 1 and j == numCol - 1: return True\\n            if streets[grid[i][j]-1][0] and i-1 >= 0 and grid[i-1][j] != -1 and streets[grid[i-1][j]-1][1]:\\n                grid[i][j] = -1\\n                return dfs(i-1, j)\\n            elif streets[grid[i][j]-1][1] and i+1 < numRow and grid[i+1][j] != -1 and streets[grid[i+1][j]-1][0]:\\n                grid[i][j] = -1\\n                return dfs(i+1, j) \\n            elif streets[grid[i][j]-1][2] and j-1 >= 0 and grid[i][j-1] != -1 and streets[grid[i][j-1]-1][3]:\\n                grid[i][j] = -1\\n                return dfs(i, j-1) \\n            elif streets[grid[i][j]-1][3] and j+1 < numCol and grid[i][j+1] != -1 and streets[grid[i][j+1]-1][2]:\\n                grid[i][j] = -1\\n                return dfs(i, j+1)\\n            return False\\n        tmp = grid[0][0] - 1\\n        grid[0][0] = -1\\n        \\n        if (streets[tmp][1] and 1 < numRow and streets[grid[1][0]-1][0] and dfs(1, 0)) or (streets[tmp][3] and 1 < numCol and streets[grid[0][1]-1][2] and dfs(0, 1)): return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355896,
                "title": "c-simple-simulation-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    enum { _N = 0, _E, _S, _W };\\n\\n    vector<vector<int>> grid;\\n\\n    bool check(int dir)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int rules[6][4] = {\\n            /* N   E   S   W */\\n            { -1, _E, -1, _W },\\n            { _N, -1, _S, -1 },\\n\\n            { _W, _S, -1, -1 },\\n            { _E, -1, -1, _S },\\n\\n            { -1, _N, _W, -1 },\\n            { -1, -1, _E, _N },\\n        };\\n\\n        int dx[] = { 0, 1, 0, -1 };\\n        int dy[] = { -1, 0, 1, 0 };\\n\\n        int x = 0;\\n        int y = 0;\\n\\n        set<pair<int, int>> visited;\\n\\n        while (true)\\n        {\\n            if (x < 0 || x >= n || y < 0 || y >= m)\\n                return false;\\n\\n            if (visited.count({ x, y }))\\n                return false;\\n\\n            visited.insert({ x,y });\\n\\n            dir = rules[grid[y][x] - 1][dir];\\n\\n            if (dir == -1)\\n                return false;\\n\\n            if (x == n - 1 && y == m - 1)\\n                return true;\\n\\n            x += dx[dir];\\n            y += dy[dir];\\n        }\\n\\n        throw;\\n    }\\n\\n    bool hasValidPath(vector<vector<int>>& grid)\\n    {\\n        this->grid = grid;\\n\\n        switch (grid[0][0])\\n        {\\n        case 1: return check(_E);\\n        case 2: return check(_S);\\n        case 3: return check(_E);\\n        case 4: return check(_N) || check(_W);\\n        case 5: return false;\\n        case 6: return check(_S);\\n        default: throw;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    enum { _N = 0, _E, _S, _W };\\n\\n    vector<vector<int>> grid;\\n\\n    bool check(int dir)\\n    {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int rules[6][4] = {\\n            /* N   E   S   W */\\n            { -1, _E, -1, _W },\\n            { _N, -1, _S, -1 },\\n\\n            { _W, _S, -1, -1 },\\n            { _E, -1, -1, _S },\\n\\n            { -1, _N, _W, -1 },\\n            { -1, -1, _E, _N },\\n        };\\n\\n        int dx[] = { 0, 1, 0, -1 };\\n        int dy[] = { -1, 0, 1, 0 };\\n\\n        int x = 0;\\n        int y = 0;\\n\\n        set<pair<int, int>> visited;\\n\\n        while (true)\\n        {\\n            if (x < 0 || x >= n || y < 0 || y >= m)\\n                return false;\\n\\n            if (visited.count({ x, y }))\\n                return false;\\n\\n            visited.insert({ x,y });\\n\\n            dir = rules[grid[y][x] - 1][dir];\\n\\n            if (dir == -1)\\n                return false;\\n\\n            if (x == n - 1 && y == m - 1)\\n                return true;\\n\\n            x += dx[dir];\\n            y += dy[dir];\\n        }\\n\\n        throw;\\n    }\\n\\n    bool hasValidPath(vector<vector<int>>& grid)\\n    {\\n        this->grid = grid;\\n\\n        switch (grid[0][0])\\n        {\\n        case 1: return check(_E);\\n        case 2: return check(_S);\\n        case 3: return check(_E);\\n        case 4: return check(_N) || check(_W);\\n        case 5: return false;\\n        case 6: return check(_S);\\n        default: throw;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349178,
                "title": "largest-code-on-leetcode-i-think-so",
                "content": "# Complexity\\n- Time complexity:\\nO(N*m)\\n\\n- Space complexity:\\nO(N*m)\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\n    bool fun(int x, int y, int xn, int yn, vector<vector<int>> &grid, int dirX, int dirY)\\n    {\\n        if (grid[x][y] == 1)\\n        {\\n            if (dirX == 0 && dirY == 1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 3 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 0 && dirY == -1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 4 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        if (grid[x][y] == 2)\\n        {\\n            if (dirX == 1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 6 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == -1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 3 || grid[xn][yn] == 4)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if (grid[x][y] == 3)\\n        {\\n            if (dirX == 0 && dirY == -1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 4 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 5 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        if (grid[x][y] == 4)\\n        {\\n            if (dirX == 0 && dirY == 1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 3 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 5 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if (grid[x][y] == 5)\\n        {\\n            if (dirX == -1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 3 || grid[xn][yn] == 4)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 0 && dirY == -1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 4 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if (grid[x][y] == 6)\\n        {\\n            if (dirX == -1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 3 || grid[xn][yn] == 4)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 0 && dirY == 1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 3 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    bool hasValidPath(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        queue<vector<int>> q;\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n\\n        q.push({0, 0});\\n        vis[0][0] = 1;\\n\\n\\n        int dirX[4] = {1, 0, -1, 0};\\n        int dirY[4] = {0, 1, 0, -1};\\n\\n\\n        while (q.size())\\n        {\\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            q.pop();\\n\\n\\n            if (x == n - 1 && y == m - 1)\\n            {\\n                return true;\\n            }\\n\\n\\n            for (int k = 0; k < 4; k++)\\n            {\\n                int xn = x + dirX[k];\\n                int yn = y + dirY[k];\\n\\n\\n                if (xn >= 0 && yn >= 0 && xn < n && yn < m && vis[xn][yn] == 0)\\n                {\\n                    if (fun(x, y, xn, yn, grid, dirX[k], dirY[k]))\\n                    {\\n                        q.push({xn, yn});\\n                        vis[xn][yn] = 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Breadth-First Search"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\n    bool fun(int x, int y, int xn, int yn, vector<vector<int>> &grid, int dirX, int dirY)\\n    {\\n        if (grid[x][y] == 1)\\n        {\\n            if (dirX == 0 && dirY == 1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 3 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 0 && dirY == -1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 4 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        if (grid[x][y] == 2)\\n        {\\n            if (dirX == 1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 6 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == -1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 3 || grid[xn][yn] == 4)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if (grid[x][y] == 3)\\n        {\\n            if (dirX == 0 && dirY == -1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 4 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 5 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        if (grid[x][y] == 4)\\n        {\\n            if (dirX == 0 && dirY == 1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 3 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 5 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if (grid[x][y] == 5)\\n        {\\n            if (dirX == -1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 3 || grid[xn][yn] == 4)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 0 && dirY == -1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 4 || grid[xn][yn] == 6)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        if (grid[x][y] == 6)\\n        {\\n            if (dirX == -1 && dirY == 0)\\n            {\\n                if (grid[xn][yn] == 2 || grid[xn][yn] == 3 || grid[xn][yn] == 4)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else if (dirX == 0 && dirY == 1)\\n            {\\n                if (grid[xn][yn] == 1 || grid[xn][yn] == 3 || grid[xn][yn] == 5)\\n                {\\n                    return true;\\n                }\\n\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    bool hasValidPath(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        queue<vector<int>> q;\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n\\n\\n        q.push({0, 0});\\n        vis[0][0] = 1;\\n\\n\\n        int dirX[4] = {1, 0, -1, 0};\\n        int dirY[4] = {0, 1, 0, -1};\\n\\n\\n        while (q.size())\\n        {\\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            q.pop();\\n\\n\\n            if (x == n - 1 && y == m - 1)\\n            {\\n                return true;\\n            }\\n\\n\\n            for (int k = 0; k < 4; k++)\\n            {\\n                int xn = x + dirX[k];\\n                int yn = y + dirY[k];\\n\\n\\n                if (xn >= 0 && yn >= 0 && xn < n && yn < m && vis[xn][yn] == 0)\\n                {\\n                    if (fun(x, y, xn, yn, grid, dirX[k], dirY[k]))\\n                    {\\n                        q.push({xn, yn});\\n                        vis[xn][yn] = 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3344938,
                "title": "huh-better-not-write-this-in-interview",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Move{\\n    int[] valid;\\n    int row;\\n    int col;\\n    public Move(int[] valid, int row, int col){\\n        this.valid = valid;\\n        this.row = row;\\n        this.col = col;\\n    }\\n\\n    public String toString(){\\n        return (row + \" \" + col);\\n    }\\n}\\n\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n\\n        Move[][] dirs = new Move[7][2];\\n        dirs[1][0] = new Move(new int[]{4,6,1}, 0, -1);\\n        dirs[1][1] = new Move(new int[]{3,5,1}, 0, 1);\\n\\n        dirs[2][0] = new Move(new int[]{6,5,2}, 1, 0);\\n        dirs[2][1] = new Move(new int[]{4,3,2}, -1, 0);\\n\\n        dirs[3][0] = new Move(new int[]{1, 4, 6}, 0, -1);\\n        dirs[3][1] = new Move(new int[]{5, 6, 2}, 1, 0);\\n        \\n        dirs[4][0] = new Move(new int[]{6, 5, 2}, 1, 0);\\n        dirs[4][1] = new Move(new int[]{3,5,1}, 0, 1);\\n\\n        dirs[5][0] = new Move(new int[]{6,4,1}, 0, -1);\\n        dirs[5][1] = new Move(new int[]{3,4,2}, -1, 0);\\n\\n        dirs[6][0] = new Move(new int[]{3,5,1}, 0, 1);\\n        dirs[6][1] = new Move(new int[]{4,3,2}, -1, 0);\\n\\n        return helper(dirs, grid, 0, 0, new HashSet<Integer>(), new int[]{1,2,3,4,5,6});\\n\\n    }\\n\\n    private boolean helper(Move[][] dirs, int[][] grid, int r, int c,HashSet<Integer> visited, int[] valid_moves){\\n        if (r<0 || r>=grid.length || c<0 || c>=grid[0].length) return false;\\n\\n        int index = getIndex(r, c, grid);\\n        if (visited.contains(index)) return false;\\n\\n        boolean isValid = false;\\n        for(int valid_move : valid_moves){\\n            if (grid[r][c] == valid_move) {\\n                isValid = true;\\n                break;\\n            }\\n        }\\n        if (!isValid) return false;\\n\\n        if (r == grid.length-1 && c == grid[0].length -1) return true;\\n\\n        visited.add(index);\\n\\n        for(Move move : dirs[grid[r][c]]){\\n            int next_r = move.row;\\n            int next_c = move.col;\\n            int valid[] = move.valid;\\n            if (helper(dirs, grid, next_r + r, next_c + c, visited, valid)) return true;\\n        }\\n        visited.remove(index);\\n        return false;\\n\\n    }\\n\\n    private int getIndex(int r, int c, int[][] grid){\\n        return (r*grid[0].length + c);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Move{\\n    int[] valid;\\n    int row;\\n    int col;\\n    public Move(int[] valid, int row, int col){\\n        this.valid = valid;\\n        this.row = row;\\n        this.col = col;\\n    }\\n\\n    public String toString(){\\n        return (row + \" \" + col);\\n    }\\n}\\n\\nclass Solution {\\n    public boolean hasValidPath(int[][] grid) {\\n\\n        Move[][] dirs = new Move[7][2];\\n        dirs[1][0] = new Move(new int[]{4,6,1}, 0, -1);\\n        dirs[1][1] = new Move(new int[]{3,5,1}, 0, 1);\\n\\n        dirs[2][0] = new Move(new int[]{6,5,2}, 1, 0);\\n        dirs[2][1] = new Move(new int[]{4,3,2}, -1, 0);\\n\\n        dirs[3][0] = new Move(new int[]{1, 4, 6}, 0, -1);\\n        dirs[3][1] = new Move(new int[]{5, 6, 2}, 1, 0);\\n        \\n        dirs[4][0] = new Move(new int[]{6, 5, 2}, 1, 0);\\n        dirs[4][1] = new Move(new int[]{3,5,1}, 0, 1);\\n\\n        dirs[5][0] = new Move(new int[]{6,4,1}, 0, -1);\\n        dirs[5][1] = new Move(new int[]{3,4,2}, -1, 0);\\n\\n        dirs[6][0] = new Move(new int[]{3,5,1}, 0, 1);\\n        dirs[6][1] = new Move(new int[]{4,3,2}, -1, 0);\\n\\n        return helper(dirs, grid, 0, 0, new HashSet<Integer>(), new int[]{1,2,3,4,5,6});\\n\\n    }\\n\\n    private boolean helper(Move[][] dirs, int[][] grid, int r, int c,HashSet<Integer> visited, int[] valid_moves){\\n        if (r<0 || r>=grid.length || c<0 || c>=grid[0].length) return false;\\n\\n        int index = getIndex(r, c, grid);\\n        if (visited.contains(index)) return false;\\n\\n        boolean isValid = false;\\n        for(int valid_move : valid_moves){\\n            if (grid[r][c] == valid_move) {\\n                isValid = true;\\n                break;\\n            }\\n        }\\n        if (!isValid) return false;\\n\\n        if (r == grid.length-1 && c == grid[0].length -1) return true;\\n\\n        visited.add(index);\\n\\n        for(Move move : dirs[grid[r][c]]){\\n            int next_r = move.row;\\n            int next_c = move.col;\\n            int valid[] = move.valid;\\n            if (helper(dirs, grid, next_r + r, next_c + c, visited, valid)) return true;\\n        }\\n        visited.remove(index);\\n        return false;\\n\\n    }\\n\\n    private int getIndex(int r, int c, int[][] grid){\\n        return (r*grid[0].length + c);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338334,
                "title": "recursive-dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    int[] dr = new int[]{-1,1,0,0};\\n    int[] dc = new int[]{0,0,1,-1};\\n\\n\\n    public HashMap<Integer,List<String>> generatePathConfig() {\\n        HashMap<Integer,List<String>> pathConfig = new HashMap<>();\\n        List<String> path = new ArrayList<>();\\n        path.add(\"R\");\\n        path.add(\"L\");\\n        pathConfig.put(1,new ArrayList<String>(path));\\n        path.clear();\\n\\n        path.add(\"D\");\\n        path.add(\"U\");\\n        pathConfig.put(2,new ArrayList<String>(path));\\n        path.clear();\\n\\n\\n        path.add(\"RD\");\\n        path.add(\"UL\");      \\n        pathConfig.put(3,new ArrayList<String>(path));\\n        path.clear();\\n\\n\\n        path.add(\"LD\");\\n        path.add(\"UR\");\\n        pathConfig.put(4,new ArrayList<String>(path));\\n        path.clear();\\n\\n        path.add(\"RU\");\\n        path.add(\"DL\");\\n        pathConfig.put(5,new ArrayList<String>(path));\\n        path.clear();\\n\\n        \\n\\n        path.add(\"LU\");\\n        path.add(\"DR\");\\n        pathConfig.put(6,new ArrayList<String>(path));\\n        path.clear();\\n\\n        return pathConfig;\\n    }\\n\\n    public boolean isValid(int i, int j, int[][] grid) {\\n        return i>=0 && i < grid.length && j>=0 && j<grid[0].length;\\n    }\\n\\n    public boolean solve(int i, int j, String pathSoFar,int[][] grid,boolean[][] visited,HashMap<Integer,List<String>> pathConfig) {\\n        if (i == grid.length-1 && j == grid[0].length - 1) \\n        return true;\\n\\n        if (isValid(i,j,grid))\\n        visited[i][j] = true;\\n\\n        boolean answer = false;\\n        for (int k=0;k<4;k++) {\\n            int adjR = i + dr[k];\\n            int adjC = j + dc[k];\\n            if (isValid(adjR,adjC,grid) && !visited[adjR][adjC]) {\\n                int val = grid[adjR][adjC];\\n                List<String> pathsAvailable = pathConfig.get(val);\\n                for (String path: pathsAvailable) {\\n                    char lastChar = \\'#\\';\\n                    if (pathSoFar.length() > 0)\\n                    lastChar = pathSoFar.charAt(pathSoFar.length()-1);\\n                    if (lastChar == \\'#\\') {\\n                        answer |= solve(adjR,adjC,pathSoFar+path,grid,visited,pathConfig);\\n                    } else {\\n                        switch(lastChar) {\\n                            case \\'U\\':\\n                                if (adjR == i - 1 && adjC == j) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                            case \\'R\\':\\n                                if (adjR == i && adjC == j + 1) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                            case \\'D\\':\\n                                if (adjR == i + 1 && adjC == j) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                            case \\'L\\':\\n                                if (adjR == i  && adjC == j - 1) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n\\n\\n    public boolean hasValidPath(int[][] grid) {\\n      boolean[][] visited = new boolean[grid.length][grid[0].length];\\n      HashMap<Integer,List<String>> pathConfig = generatePathConfig();\\n      return solve(0,-1,\"\",grid,visited,pathConfig);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[] dr = new int[]{-1,1,0,0};\\n    int[] dc = new int[]{0,0,1,-1};\\n\\n\\n    public HashMap<Integer,List<String>> generatePathConfig() {\\n        HashMap<Integer,List<String>> pathConfig = new HashMap<>();\\n        List<String> path = new ArrayList<>();\\n        path.add(\"R\");\\n        path.add(\"L\");\\n        pathConfig.put(1,new ArrayList<String>(path));\\n        path.clear();\\n\\n        path.add(\"D\");\\n        path.add(\"U\");\\n        pathConfig.put(2,new ArrayList<String>(path));\\n        path.clear();\\n\\n\\n        path.add(\"RD\");\\n        path.add(\"UL\");      \\n        pathConfig.put(3,new ArrayList<String>(path));\\n        path.clear();\\n\\n\\n        path.add(\"LD\");\\n        path.add(\"UR\");\\n        pathConfig.put(4,new ArrayList<String>(path));\\n        path.clear();\\n\\n        path.add(\"RU\");\\n        path.add(\"DL\");\\n        pathConfig.put(5,new ArrayList<String>(path));\\n        path.clear();\\n\\n        \\n\\n        path.add(\"LU\");\\n        path.add(\"DR\");\\n        pathConfig.put(6,new ArrayList<String>(path));\\n        path.clear();\\n\\n        return pathConfig;\\n    }\\n\\n    public boolean isValid(int i, int j, int[][] grid) {\\n        return i>=0 && i < grid.length && j>=0 && j<grid[0].length;\\n    }\\n\\n    public boolean solve(int i, int j, String pathSoFar,int[][] grid,boolean[][] visited,HashMap<Integer,List<String>> pathConfig) {\\n        if (i == grid.length-1 && j == grid[0].length - 1) \\n        return true;\\n\\n        if (isValid(i,j,grid))\\n        visited[i][j] = true;\\n\\n        boolean answer = false;\\n        for (int k=0;k<4;k++) {\\n            int adjR = i + dr[k];\\n            int adjC = j + dc[k];\\n            if (isValid(adjR,adjC,grid) && !visited[adjR][adjC]) {\\n                int val = grid[adjR][adjC];\\n                List<String> pathsAvailable = pathConfig.get(val);\\n                for (String path: pathsAvailable) {\\n                    char lastChar = \\'#\\';\\n                    if (pathSoFar.length() > 0)\\n                    lastChar = pathSoFar.charAt(pathSoFar.length()-1);\\n                    if (lastChar == \\'#\\') {\\n                        answer |= solve(adjR,adjC,pathSoFar+path,grid,visited,pathConfig);\\n                    } else {\\n                        switch(lastChar) {\\n                            case \\'U\\':\\n                                if (adjR == i - 1 && adjC == j) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                            case \\'R\\':\\n                                if (adjR == i && adjC == j + 1) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                            case \\'D\\':\\n                                if (adjR == i + 1 && adjC == j) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                            case \\'L\\':\\n                                if (adjR == i  && adjC == j - 1) {\\n                                    if (path.charAt(0) == lastChar) {\\n                                        answer |= solve(adjR,adjC,path,grid,visited,pathConfig);\\n                                    }\\n                                }\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n\\n\\n    public boolean hasValidPath(int[][] grid) {\\n      boolean[][] visited = new boolean[grid.length][grid[0].length];\\n      HashMap<Integer,List<String>> pathConfig = generatePathConfig();\\n      return solve(0,-1,\"\",grid,visited,pathConfig);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334818,
                "title": "dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int i,int j,int n,int m){\\n        if(i<0 or i>=n or j<0 or j>=m){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<int>>& grid,vector<vector<int>>&vis,int i,int j){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i<0 or i>=n or j<0 or j>=m or vis[i][j]==1){\\n            return false;\\n        }\\n        if(i==n-1 and j==m-1){\\n            return true;\\n        }\\n        vis[i][j]=1;\\n        int a=grid[i][j];\\n        if(a==2){\\n    if(isvalid(i+1,j,n,m)){  // check right direction instead of down\\n        int a=grid[i+1][j];\\n        if(a==2 or a==5 or a==6){\\n            bool b=solve(grid,vis,i+1,j);\\n            if(b){\\n                return true;\\n            }\\n        }\\n    }\\n    if(isvalid(i-1,j,n,m)){  // check left direction instead of up\\n        int a=grid[i-1][j];\\n        if(a==2 or a==3 or a==4){\\n            bool b=solve(grid,vis,i-1,j);\\n            if(b){\\n                return true;\\n            }\\n        }\\n    }\\n}\\n\\n        if(a==1){\\n            if(isvalid(i,j+1,n,m)){\\n                int a=grid[i][j+1];\\n                if(a==1 or a==3 or a==5){\\n                    bool b=solve(grid,vis,i,j+1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i,j-1,n,m)){\\n                int a=grid[i][j-1];\\n                if(a==1 or a==6 or a==4){\\n                    bool b=solve(grid,vis,i,j-1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==3){\\n            if(isvalid(i,j-1,n,m)){\\n                int a=grid[i][j-1];\\n                if(a==1 or a==4 or a==6){\\n                    bool b=solve(grid,vis,i,j-1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i+1,j,n,m)){\\n                int a=grid[i+1][j];\\n                if(a==2 or a==5 or a==6){\\n                    bool b=solve(grid,vis,i+1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==4){\\n             if(isvalid(i,j+1,n,m)){\\n                int a=grid[i][j+1];\\n                if(a==1 or a==3 or a==5){\\n                    bool b=solve(grid,vis,i,j+1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i+1,j,n,m)){\\n                int a=grid[i+1][j];\\n                if(a==2 or a==5 or a==6){\\n                    bool b=solve(grid,vis,i+1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==5){\\n             if(isvalid(i,j-1,n,m)){\\n                int a=grid[i][j-1];\\n                if(a==1 or a==4 or a==6){\\n                    bool b=solve(grid,vis,i,j-1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i-1,j,n,m)){\\n                int a=grid[i-1][j];\\n                if(a==2 or a==3 or a==4){\\n                    bool b=solve(grid,vis,i-1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==6){\\n             if(isvalid(i,j+1,n,m)){\\n                int a=grid[i][j+1];\\n                if(a==1 or a==3 or a==5){\\n                    bool b=solve(grid,vis,i,j+1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i-1,j,n,m)){\\n                int a=grid[i-1][j];\\n                if(a==2 or a==4 or a==3){\\n                    bool b=solve(grid,vis,i-1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        return solve(grid,vis,0,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int i,int j,int n,int m){\\n        if(i<0 or i>=n or j<0 or j>=m){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool solve(vector<vector<int>>& grid,vector<vector<int>>&vis,int i,int j){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(i<0 or i>=n or j<0 or j>=m or vis[i][j]==1){\\n            return false;\\n        }\\n        if(i==n-1 and j==m-1){\\n            return true;\\n        }\\n        vis[i][j]=1;\\n        int a=grid[i][j];\\n        if(a==2){\\n    if(isvalid(i+1,j,n,m)){  // check right direction instead of down\\n        int a=grid[i+1][j];\\n        if(a==2 or a==5 or a==6){\\n            bool b=solve(grid,vis,i+1,j);\\n            if(b){\\n                return true;\\n            }\\n        }\\n    }\\n    if(isvalid(i-1,j,n,m)){  // check left direction instead of up\\n        int a=grid[i-1][j];\\n        if(a==2 or a==3 or a==4){\\n            bool b=solve(grid,vis,i-1,j);\\n            if(b){\\n                return true;\\n            }\\n        }\\n    }\\n}\\n\\n        if(a==1){\\n            if(isvalid(i,j+1,n,m)){\\n                int a=grid[i][j+1];\\n                if(a==1 or a==3 or a==5){\\n                    bool b=solve(grid,vis,i,j+1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i,j-1,n,m)){\\n                int a=grid[i][j-1];\\n                if(a==1 or a==6 or a==4){\\n                    bool b=solve(grid,vis,i,j-1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==3){\\n            if(isvalid(i,j-1,n,m)){\\n                int a=grid[i][j-1];\\n                if(a==1 or a==4 or a==6){\\n                    bool b=solve(grid,vis,i,j-1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i+1,j,n,m)){\\n                int a=grid[i+1][j];\\n                if(a==2 or a==5 or a==6){\\n                    bool b=solve(grid,vis,i+1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==4){\\n             if(isvalid(i,j+1,n,m)){\\n                int a=grid[i][j+1];\\n                if(a==1 or a==3 or a==5){\\n                    bool b=solve(grid,vis,i,j+1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i+1,j,n,m)){\\n                int a=grid[i+1][j];\\n                if(a==2 or a==5 or a==6){\\n                    bool b=solve(grid,vis,i+1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==5){\\n             if(isvalid(i,j-1,n,m)){\\n                int a=grid[i][j-1];\\n                if(a==1 or a==4 or a==6){\\n                    bool b=solve(grid,vis,i,j-1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i-1,j,n,m)){\\n                int a=grid[i-1][j];\\n                if(a==2 or a==3 or a==4){\\n                    bool b=solve(grid,vis,i-1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        if(a==6){\\n             if(isvalid(i,j+1,n,m)){\\n                int a=grid[i][j+1];\\n                if(a==1 or a==3 or a==5){\\n                    bool b=solve(grid,vis,i,j+1);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            if(isvalid(i-1,j,n,m)){\\n                int a=grid[i-1][j];\\n                if(a==2 or a==4 or a==3){\\n                    bool b=solve(grid,vis,i-1,j);\\n                    if(b){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        return solve(grid,vis,0,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220737,
                "title": "simple-solution-using-bfs-intuitive-solution",
                "content": "Observation:\\n\\n1  :  Can connect only to adj left and right.\\n2  :  Can connect only to adj up and down.\\n3  :  Can connect only to adj left and down.\\n4  :  Can connect only to adj down and right.\\n5  :  Can connect only to adj up and left.\\n6  :  Can connect only to adj right and up.\\n\\n\\nCode :\\n\\nclass Solution {\\n\\nprivate:\\n    bool isValid(int r, int c, int n, int m, vector<vector<int>> &vis){\\n        return r<n && c<m && r>=0 && c>=0 && !vis[r][c];\\n    }\\n\\t\\n    bool isSafe(int left, int rgt, int up, int down, int nr, int nc, int r, int c, vector<vector<int>>& grid){\\n    if(left == 1 && nc == c-1){\\n        return grid[nr][nc] == 1 || grid[nr][nc] == 4 || grid[nr][nc] == 6;\\n    }\\n    else if(rgt == 1 && nc == c+1){\\n        return grid[nr][nc] == 1 || grid[nr][nc] == 3 || grid[nr][nc] == 5;\\n    }\\n    else if(up == 1 && nr == r-1){\\n        return grid[nr][nc] == 2 || grid[nr][nc] == 3 || grid[nr][nc] == 4;\\n    }\\n    else if(down == 1 && nr == r+1){\\n        return grid[nr][nc] == 2 || grid[nr][nc] == 5 || grid[nr][nc] == 6;\\n    }\\n    return false;\\n}\\n\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0)); \\n        queue<pair<int, pair<int, int>>> q;\\n        q.push({grid[0][0], {0, 0}});\\n        vis[0][0] = 1;\\n        int dx[] = {-1, 0, 1, 0};\\n        int dy[] = {0, 1, 0, -1};\\n        \\n        while(!q.empty()){\\n            auto it = q.front();\\n            int val = it.first;\\n            int row = it.second.first;\\n            int col = it.second.second;\\n            q.pop();\\n            \\n            if(row == n-1 && col == m-1) return true;\\n            \\n            int left = 0, rgt = 0, up = 0, down = 0;\\n            \\n            if(val == 1){\\n                left = rgt = 1;\\n            }\\n            else if(val == 2){\\n                up = down = 1;\\n            }\\n            else if(val == 3){\\n                left = down = 1;\\n            }\\n            else if(val == 4){\\n                rgt = down = 1;\\n            }\\n            else if(val == 5){\\n                left = up = 1;\\n            }\\n            else {\\n                up = rgt = 1;\\n            }\\n            \\n            for(int ind = 0; ind<4; ind++){\\n                int nr = row + dx[ind];\\n                int nc = col + dy[ind];\\n                \\n                if(isValid(nr, nc, n, m, vis)){\\n                    if(isSafe(left, rgt, up, down, nr, nc, row, col, grid)){ \\n                        q.push({grid[nr][nc], {nr, nc}});\\n                        vis[nr][nc] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\t\\n\\t\\n\\t\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\nprivate:\\n    bool isValid(int r, int c, int n, int m, vector<vector<int>> &vis){\\n        return r<n && c<m && r>=0 && c>=0 && !vis[r][c];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3177953,
                "title": "javascript-dfs-solution",
                "content": "This is a pretty standard DFS solution. The tricky part here is to figure where we come from and where we go next. This is solved by adding the opposite to `dirs` map. Every time we traverse to the next street, we check if streets[nextStreet] includes the direction we are coming from.\\n\\n```\\nconst hasValidPath = grid => {\\n    const streets = {\\n        1: [\\'l\\', \\'r\\'],\\n        2: [\\'u\\', \\'d\\'],\\n        3: [\\'l\\', \\'d\\'],\\n        4: [\\'d\\', \\'r\\'],\\n        5: [\\'l\\', \\'u\\'],\\n        6: [\\'u\\', \\'r\\']\\n    }\\n    \\n    const dirs = {\\n        u: [-1, 0, \\'d\\'],\\n        d: [1, 0, \\'u\\'],\\n        l: [0, -1, \\'r\\'],\\n        r: [0, 1, \\'l\\']\\n    }\\n    \\n    const m = grid.length\\n    const n = grid[0].length\\n    const visited = new Set()\\n    \\n    const dfs = (i, j) => {\\n        if (i === m - 1 && j === n - 1) return true\\n        if (i < 0 || i > m - 1) return false\\n        if (j < 0 || j > n - 1) return false\\n        const key = `${i}-${j}`\\n        if (visited.has(key)) return false\\n        visited.add(key)\\n        \\n        const street = grid[i][j]\\n        const paths = streets[street]\\n        for (const path of paths) {\\n            const [ni, nj, nFrom] = dirs[path]\\n            const nextI = i + ni\\n            const nextJ = j + nj\\n            const nextStreet = grid[nextI]?.[nextJ]\\n            \\n            if (streets[nextStreet]?.includes?.(nFrom)) {\\n                if (dfs(i + ni, j + nj)) return true\\n            }\\n        }\\n        return false\\n    }\\n    \\n    return dfs(0, 0)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nconst hasValidPath = grid => {\\n    const streets = {\\n        1: [\\'l\\', \\'r\\'],\\n        2: [\\'u\\', \\'d\\'],\\n        3: [\\'l\\', \\'d\\'],\\n        4: [\\'d\\', \\'r\\'],\\n        5: [\\'l\\', \\'u\\'],\\n        6: [\\'u\\', \\'r\\']\\n    }\\n    \\n    const dirs = {\\n        u: [-1, 0, \\'d\\'],\\n        d: [1, 0, \\'u\\'],\\n        l: [0, -1, \\'r\\'],\\n        r: [0, 1, \\'l\\']\\n    }\\n    \\n    const m = grid.length\\n    const n = grid[0].length\\n    const visited = new Set()\\n    \\n    const dfs = (i, j) => {\\n        if (i === m - 1 && j === n - 1) return true\\n        if (i < 0 || i > m - 1) return false\\n        if (j < 0 || j > n - 1) return false\\n        const key = `${i}-${j}`\\n        if (visited.has(key)) return false\\n        visited.add(key)\\n        \\n        const street = grid[i][j]\\n        const paths = streets[street]\\n        for (const path of paths) {\\n            const [ni, nj, nFrom] = dirs[path]\\n            const nextI = i + ni\\n            const nextJ = j + nj\\n            const nextStreet = grid[nextI]?.[nextJ]\\n            \\n            if (streets[nextStreet]?.includes?.(nFrom)) {\\n                if (dfs(i + ni, j + nj)) return true\\n            }\\n        }\\n        return false\\n    }\\n    \\n    return dfs(0, 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3174504,
                "title": "javascript-solution-bfs-matrix-time-space-o-n-m-with-explanation",
                "content": "# Intuition\\nBreadth First Search and Matrix Traversal.\\n\\n# Approach\\n\\nCheck neighbors\\nCheck if neighbor can reach your cell\\nMark as visited\\npush into queue\\n\\n# Complexity\\n- Time complexity:\\nO(n * m) for rows * columns\\n\\n- Space complexity:\\nO(n * m) for rows * columns for visited array\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\n// Breadth-First-Search, Matrix Traversal\\n// Time and Space: O(m * n)...rows * columns\\nvar hasValidPath = function(grid) {\\n    let m = grid.length, n = grid[0].length;\\n    let visited = [...new Array(m)].map(a => [...new Array(n)].fill(false))\\n    let left = [0, -1], right = [0, 1], up = [-1, 0], down = [1, 0]\\n    let queue = [[0,0]];\\n    visited[0][0] = true;\\n    while (queue.length) {\\n        let [x, y] = queue.shift();\\n        if (x === m-1 && y === n-1) return true;\\n        let val = grid[x][y]\\n\\n        const checkPosition = (pos, type) =>{\\n            let set = new Set();\\n            if (type === \"left\") {\\n                set = new Set([6, 1, 4])\\n            } else if (type === \"right\") {\\n                set = new Set([5, 1, 3])\\n            } else if (type === \"up\") {\\n                set = new Set([2, 4, 3])\\n            } else if (type === \"down\") {\\n                set = new Set([2, 5, 6])\\n            }\\n            let x1 = x + pos[0], y1 = y + pos[1]\\n            if (x1 >= 0 && y1 >= 0 && x1 < m && y1 < n) {\\n                if (!visited[x1][y1] && set.has(grid[x1][y1])) {\\n                    visited[x1][y1] = true;\\n                    queue.push([x1, y1])\\n                }\\n            }\\n        }\\n        if (val === 1) {\\n            checkPosition(left, \"left\"); checkPosition(right, \"right\")\\n        } else if (val === 2) {\\n            checkPosition(up, \"up\"); checkPosition(down, \"down\")\\n        } else if (val === 3) {\\n            checkPosition(left, \"left\"); checkPosition(down, \"down\")\\n        } else if (val === 4) {\\n            checkPosition(right, \"right\"); checkPosition(down, \"down\")\\n        } else if (val === 5) {\\n            checkPosition(left, \"left\"); checkPosition(up, \"up\")\\n        } else if (val === 6) {\\n            checkPosition(up, \"up\"); checkPosition(right, \"right\")\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\n// Breadth-First-Search, Matrix Traversal\\n// Time and Space: O(m * n)...rows * columns\\nvar hasValidPath = function(grid) {\\n    let m = grid.length, n = grid[0].length;\\n    let visited = [...new Array(m)].map(a => [...new Array(n)].fill(false))\\n    let left = [0, -1], right = [0, 1], up = [-1, 0], down = [1, 0]\\n    let queue = [[0,0]];\\n    visited[0][0] = true;\\n    while (queue.length) {\\n        let [x, y] = queue.shift();\\n        if (x === m-1 && y === n-1) return true;\\n        let val = grid[x][y]\\n\\n        const checkPosition = (pos, type) =>{\\n            let set = new Set();\\n            if (type === \"left\") {\\n                set = new Set([6, 1, 4])\\n            } else if (type === \"right\") {\\n                set = new Set([5, 1, 3])\\n            } else if (type === \"up\") {\\n                set = new Set([2, 4, 3])\\n            } else if (type === \"down\") {\\n                set = new Set([2, 5, 6])\\n            }\\n            let x1 = x + pos[0], y1 = y + pos[1]\\n            if (x1 >= 0 && y1 >= 0 && x1 < m && y1 < n) {\\n                if (!visited[x1][y1] && set.has(grid[x1][y1])) {\\n                    visited[x1][y1] = true;\\n                    queue.push([x1, y1])\\n                }\\n            }\\n        }\\n        if (val === 1) {\\n            checkPosition(left, \"left\"); checkPosition(right, \"right\")\\n        } else if (val === 2) {\\n            checkPosition(up, \"up\"); checkPosition(down, \"down\")\\n        } else if (val === 3) {\\n            checkPosition(left, \"left\"); checkPosition(down, \"down\")\\n        } else if (val === 4) {\\n            checkPosition(right, \"right\"); checkPosition(down, \"down\")\\n        } else if (val === 5) {\\n            checkPosition(left, \"left\"); checkPosition(up, \"up\")\\n        } else if (val === 6) {\\n            checkPosition(up, \"up\"); checkPosition(right, \"right\")\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3173421,
                "title": "python-union-find-approach",
                "content": "# Intuition\\nWe can traverse the grid and connect cells on the right and on the bottom of the current: \\n1. If current cell is 1, 4 or 6 (has road on the right) then it could be connected to the right cell having road on the left (1, 3 or 5)\\n2. If current cell is 2, 3 or 4 (has road on the bottom) then it could be connected to the bottom cell having road on the left (2, 5 or 6)\\n\\nWe can connect cells using Union-Find, and then check whether top-left and bottom-right cells pertain to the same cluster.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        n, m = len(grid), len(grid[0])\\n        p, rank = [[(i, j) for j in range(m)] for i in range(n)], [[1 for _ in range(m)] for _ in range(n)]\\n\\n        def get(i, j):\\n            while p[i][j] != (i, j):\\n                i, j = p[i][j]\\n            return i, j\\n\\n        def connect(i1, j1, i2, j2):\\n            i1, j1 = get(i1, j1)\\n            i2, j2 = get(i2, j2)\\n            if rank[i1][j1] >= rank[i2][j2]:\\n                p[i2][j2] = p[i1][j1]\\n                rank[i1][j1] += 1\\n            else:\\n                p[i1][j1] = p[i2][j2]\\n                rank[i2][j2] += 1\\n\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] in [1, 4, 6] and j+1 < m and grid[i][j+1] in [1, 3, 5]:\\n                    connect(i, j, i, j+1)\\n                if grid[i][j] in [2, 3, 4] and i+1 < n and grid[i+1][j] in [2, 5, 6]:\\n                    connect(i, j, i+1, j)\\n\\n        return get(0, 0) == get(n-1, m-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        n, m = len(grid), len(grid[0])\\n        p, rank = [[(i, j) for j in range(m)] for i in range(n)], [[1 for _ in range(m)] for _ in range(n)]\\n\\n        def get(i, j):\\n            while p[i][j] != (i, j):\\n                i, j = p[i][j]\\n            return i, j\\n\\n        def connect(i1, j1, i2, j2):\\n            i1, j1 = get(i1, j1)\\n            i2, j2 = get(i2, j2)\\n            if rank[i1][j1] >= rank[i2][j2]:\\n                p[i2][j2] = p[i1][j1]\\n                rank[i1][j1] += 1\\n            else:\\n                p[i1][j1] = p[i2][j2]\\n                rank[i2][j2] += 1\\n\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] in [1, 4, 6] and j+1 < m and grid[i][j+1] in [1, 3, 5]:\\n                    connect(i, j, i, j+1)\\n                if grid[i][j] in [2, 3, 4] and i+1 < n and grid[i+1][j] in [2, 5, 6]:\\n                    connect(i, j, i+1, j)\\n\\n        return get(0, 0) == get(n-1, m-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137498,
                "title": "standard-union-find-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    int[] parent;\\n    int[] sz;\\n\\n    public bool HasValidPath(int[][] grid) {\\n        var n = grid.Length;\\n        var m = grid[0].Length;\\n\\n        if (n == 1 && m == 1) return true;\\n\\n        parent = new int[n * m];\\n        sz = new int[n * m];\\n\\n        for (var i = 0; i < n * m; i++) {\\n            parent[i] = i;\\n            sz[i] = 1;\\n        }\\n        \\n        for (var i = 0; i < n; i++) {\\n            for (var j = 0; j < m; j++) {\\n                var road = grid[i][j];\\n\\n                // left\\n                if (j > 0 && (road == 1 || road == 3 || road == 5)) {\\n                    var road2 = grid[i][j - 1];\\n\\n                    if (road2 == 1 || road2 == 4 || road2 == 6) {\\n                        Union(i * m + j, i * m + j - 1);\\n                    }\\n                }\\n\\n                // up\\n                if (i > 0 && (road == 2 || road == 5 || road == 6)) {\\n                    var road2 = grid[i - 1][j];\\n\\n                    if (road2 == 2 || road2 == 3 || road2 == 4) {\\n                        Union(i * m + j, (i - 1) * m + j);\\n                    }\\n                }\\n\\n                // right\\n                if (j < m - 1 && (road == 1 || road == 4 || road == 6)) {\\n                    var road2 = grid[i][j + 1];\\n\\n                    if (road2 == 1 || road2 == 3 || road2 == 5) {\\n                        Union(i * m + j, i * m + j + 1);\\n                    }\\n                }\\n\\n                // down\\n                if (i < n - 1 && (road == 2 || road == 3 || road == 4)) {\\n                    var road2 = grid[i + 1][j];\\n\\n                    if (road2 == 2 || road2 == 5 || road2 == 6) {\\n                        Union(i * m + j, (i + 1) * m + j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return Find(0) == Find(n * m - 1);\\n    }\\n\\n    private int Find(int a) {\\n        while (a != parent[a]) {\\n            a = parent[a];\\n            parent[a] = parent[parent[a]];\\n        }\\n\\n        return a;\\n    }\\n\\n    private void Union(int a, int b) {\\n        var root_a = Find(a);\\n        var root_b = Find(b);\\n        if (root_a == root_b) return;\\n\\n        if (sz[root_a] < sz[root_b])  {\\n            parent[root_a] = root_b;\\n            sz[root_b] += sz[root_a];\\n        } else {\\n            parent[root_b] = root_a;\\n            sz[root_a] += sz[root_b];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int[] parent;\\n    int[] sz;\\n\\n    public bool HasValidPath(int[][] grid) {\\n        var n = grid.Length;\\n        var m = grid[0].Length;\\n\\n        if (n == 1 && m == 1) return true;\\n\\n        parent = new int[n * m];\\n        sz = new int[n * m];\\n\\n        for (var i = 0; i < n * m; i++) {\\n            parent[i] = i;\\n            sz[i] = 1;\\n        }\\n        \\n        for (var i = 0; i < n; i++) {\\n            for (var j = 0; j < m; j++) {\\n                var road = grid[i][j];\\n\\n                // left\\n                if (j > 0 && (road == 1 || road == 3 || road == 5)) {\\n                    var road2 = grid[i][j - 1];\\n\\n                    if (road2 == 1 || road2 == 4 || road2 == 6) {\\n                        Union(i * m + j, i * m + j - 1);\\n                    }\\n                }\\n\\n                // up\\n                if (i > 0 && (road == 2 || road == 5 || road == 6)) {\\n                    var road2 = grid[i - 1][j];\\n\\n                    if (road2 == 2 || road2 == 3 || road2 == 4) {\\n                        Union(i * m + j, (i - 1) * m + j);\\n                    }\\n                }\\n\\n                // right\\n                if (j < m - 1 && (road == 1 || road == 4 || road == 6)) {\\n                    var road2 = grid[i][j + 1];\\n\\n                    if (road2 == 1 || road2 == 3 || road2 == 5) {\\n                        Union(i * m + j, i * m + j + 1);\\n                    }\\n                }\\n\\n                // down\\n                if (i < n - 1 && (road == 2 || road == 3 || road == 4)) {\\n                    var road2 = grid[i + 1][j];\\n\\n                    if (road2 == 2 || road2 == 5 || road2 == 6) {\\n                        Union(i * m + j, (i + 1) * m + j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return Find(0) == Find(n * m - 1);\\n    }\\n\\n    private int Find(int a) {\\n        while (a != parent[a]) {\\n            a = parent[a];\\n            parent[a] = parent[parent[a]];\\n        }\\n\\n        return a;\\n    }\\n\\n    private void Union(int a, int b) {\\n        var root_a = Find(a);\\n        var root_b = Find(b);\\n        if (root_a == root_b) return;\\n\\n        if (sz[root_a] < sz[root_b])  {\\n            parent[root_a] = root_b;\\n            sz[root_b] += sz[root_a];\\n        } else {\\n            parent[root_b] = root_a;\\n            sz[root_a] += sz[root_b];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136116,
                "title": "java-very-easy-to-understand-solution-simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif the curr ele can reach to its parent ele then move ahead,else stop there\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n) m=grid.length n=grid[0].length\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n# Code\\n```\\nclass Solution {\\n    public boolean helper(int row,int col,int prevr,int prevc,int[][] grid,int[][][] arr,boolean[][] visited){\\n        if(row<0||row==grid.length||col<0||col==grid[0].length){\\n            return false;\\n        }\\n        if(visited[row][col]){\\n            return false;\\n        }\\n        visited[row][col]=true;\\n        if(prevr!=-1&&prevc!=-1){\\n            int[][] check=arr[grid[row][col]-1];\\n            if(row+check[0][0]==prevr&&col+check[0][1]==prevc||row+check[1][0]==prevr&&col+check[1][1]==prevc){\\n                if(row==grid.length-1&&col==grid[0].length-1){\\n                    return true;\\n                }\\n                else{\\n                if(row+check[0][0]==prevr&&col+check[0][1]==prevc){\\n                   return helper(row+check[1][0],col+check[1][1],row,col,grid,arr,visited);\\n                }\\n                else{\\n                  return  helper(row+check[0][0],col+check[0][1],row,col,grid,arr,visited);\\n                }\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        else{\\n            if(row==grid.length-1&&col==grid[0].length-1){\\n                return true;\\n            }\\n            int[][] check=arr[grid[row][col]-1];\\n            return helper(row+check[0][0],col+check[0][1],row,col,grid,arr,visited)||helper(row+check[1][0],col+check[1][1],row,col,grid,arr,visited);\\n        }\\n    }\\n    public boolean hasValidPath(int[][] grid) {\\n        int[][][] arr={{{0,-1},{0,1}},\\n                        {{-1,0},{1,0}},\\n                        {{0,-1},{1,0}},\\n                        {{0,1},{1,0}},\\n                        {{-1,0},{0,-1}},\\n                        {{-1,0},{0,1}}};\\n        boolean[][] visited=new boolean[grid.length][grid[0].length];\\n        return helper(0,0,-1,-1,grid,arr,visited);\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean helper(int row,int col,int prevr,int prevc,int[][] grid,int[][][] arr,boolean[][] visited){\\n        if(row<0||row==grid.length||col<0||col==grid[0].length){\\n            return false;\\n        }\\n        if(visited[row][col]){\\n            return false;\\n        }\\n        visited[row][col]=true;\\n        if(prevr!=-1&&prevc!=-1){\\n            int[][] check=arr[grid[row][col]-1];\\n            if(row+check[0][0]==prevr&&col+check[0][1]==prevc||row+check[1][0]==prevr&&col+check[1][1]==prevc){\\n                if(row==grid.length-1&&col==grid[0].length-1){\\n                    return true;\\n                }\\n                else{\\n                if(row+check[0][0]==prevr&&col+check[0][1]==prevc){\\n                   return helper(row+check[1][0],col+check[1][1],row,col,grid,arr,visited);\\n                }\\n                else{\\n                  return  helper(row+check[0][0],col+check[0][1],row,col,grid,arr,visited);\\n                }\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        else{\\n            if(row==grid.length-1&&col==grid[0].length-1){\\n                return true;\\n            }\\n            int[][] check=arr[grid[row][col]-1];\\n            return helper(row+check[0][0],col+check[0][1],row,col,grid,arr,visited)||helper(row+check[1][0],col+check[1][1],row,col,grid,arr,visited);\\n        }\\n    }\\n    public boolean hasValidPath(int[][] grid) {\\n        int[][][] arr={{{0,-1},{0,1}},\\n                        {{-1,0},{1,0}},\\n                        {{0,-1},{1,0}},\\n                        {{0,1},{1,0}},\\n                        {{-1,0},{0,-1}},\\n                        {{-1,0},{0,1}}};\\n        boolean[][] visited=new boolean[grid.length][grid[0].length];\\n        return helper(0,0,-1,-1,grid,arr,visited);\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123173,
                "title": "dfs-c",
                "content": "```\\nclass Solution {\\n    bool good(int i, int j, vector<vector<int>> &g, vector<vector<int>> &vis) {\\n        int n = g.size(), m = g[0].size();\\n        if(i >= 0 && i < n && j >= 0 && j < m && !vis[i][j]) return true;\\n        return false;\\n    }\\n    bool dfs(int i, int j, int n, int m, vector<vector<int>> &g, vector<vector<int>> &vis) {\\n        if(i == n - 1 && j == m - 1) return true;\\n        vis[i][j] = 1;\\n\\n        if(g[i][j] == 1) {\\n            if(good(i, j - 1, g, vis) && (g[i][j - 1] == 4 || g[i][j - 1] == 6 || g[i][j - 1] == 1) \\n            && dfs(i, j - 1, n, m, g, vis)) return true;\\n            if(good(i, j + 1, g, vis) && (g[i][j + 1] == 3 || g[i][j + 1] == 5 || g[i][j + 1] == 1) \\n            && dfs(i, j + 1, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 2) {\\n            if(good(i + 1, j, g, vis) && (g[i + 1][j] == 5 || g[i + 1][j] == 6 || g[i + 1][j] == 2) \\n            && dfs(i + 1, j, n, m, g, vis)) return true;\\n            if(good(i - 1, j, g, vis) && (g[i - 1][j] == 3 || g[i - 1][j] == 4 || g[i - 1][j] == 2) \\n            && dfs(i - 1, j, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 3) {\\n            if(good(i, j - 1, g, vis) && (g[i][j - 1] == 1 || g[i][j - 1] == 4 || g[i][j - 1] == 6) \\n            && dfs(i, j - 1, n, m, g, vis)) return true;\\n            if(good(i + 1, j, g, vis) && (g[i + 1][j] == 2 || g[i + 1][j] == 5 || g[i + 1][j] == 6)\\n            && dfs(i + 1, j, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 4) {\\n            if(good(i, j + 1, g, vis) && (g[i][j + 1] == 1 || g[i][j + 1] == 3 || g[i][j + 1] == 5) \\n            && dfs(i, j + 1, n, m, g, vis)) return true;\\n            if(good(i + 1, j, g, vis) && (g[i + 1][j] == 2 || g[i + 1][j] == 5 || g[i + 1][j] == 6)\\n            && dfs(i + 1, j, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 5) {\\n            if(good(i - 1, j, g, vis) && (g[i - 1][j] == 3 || g[i - 1][j] == 4 || g[i - 1][j] == 2) \\n            && dfs(i - 1, j, n, m, g, vis)) return true;\\n            if(good(i, j - 1, g, vis) && (g[i][j - 1] == 1 || g[i][j - 1] == 4 || g[i][j - 1] == 6) \\n            && dfs(i, j - 1, n, m, g, vis)) return true;\\n        }\\n        else {\\n            if(good(i - 1, j, g, vis) && (g[i - 1][j] == 3 || g[i - 1][j] == 4 || g[i - 1][j] == 2) \\n            && dfs(i - 1, j, n, m, g, vis)) return true;\\n            if(good(i, j + 1, g, vis) && (g[i][j + 1] == 3 || g[i][j + 1] == 5 || g[i][j + 1] == 1) \\n            && dfs(i, j + 1, n, m, g, vis)) return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m));\\n\\n        return dfs(0, 0, n, m, grid, vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good(int i, int j, vector<vector<int>> &g, vector<vector<int>> &vis) {\\n        int n = g.size(), m = g[0].size();\\n        if(i >= 0 && i < n && j >= 0 && j < m && !vis[i][j]) return true;\\n        return false;\\n    }\\n    bool dfs(int i, int j, int n, int m, vector<vector<int>> &g, vector<vector<int>> &vis) {\\n        if(i == n - 1 && j == m - 1) return true;\\n        vis[i][j] = 1;\\n\\n        if(g[i][j] == 1) {\\n            if(good(i, j - 1, g, vis) && (g[i][j - 1] == 4 || g[i][j - 1] == 6 || g[i][j - 1] == 1) \\n            && dfs(i, j - 1, n, m, g, vis)) return true;\\n            if(good(i, j + 1, g, vis) && (g[i][j + 1] == 3 || g[i][j + 1] == 5 || g[i][j + 1] == 1) \\n            && dfs(i, j + 1, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 2) {\\n            if(good(i + 1, j, g, vis) && (g[i + 1][j] == 5 || g[i + 1][j] == 6 || g[i + 1][j] == 2) \\n            && dfs(i + 1, j, n, m, g, vis)) return true;\\n            if(good(i - 1, j, g, vis) && (g[i - 1][j] == 3 || g[i - 1][j] == 4 || g[i - 1][j] == 2) \\n            && dfs(i - 1, j, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 3) {\\n            if(good(i, j - 1, g, vis) && (g[i][j - 1] == 1 || g[i][j - 1] == 4 || g[i][j - 1] == 6) \\n            && dfs(i, j - 1, n, m, g, vis)) return true;\\n            if(good(i + 1, j, g, vis) && (g[i + 1][j] == 2 || g[i + 1][j] == 5 || g[i + 1][j] == 6)\\n            && dfs(i + 1, j, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 4) {\\n            if(good(i, j + 1, g, vis) && (g[i][j + 1] == 1 || g[i][j + 1] == 3 || g[i][j + 1] == 5) \\n            && dfs(i, j + 1, n, m, g, vis)) return true;\\n            if(good(i + 1, j, g, vis) && (g[i + 1][j] == 2 || g[i + 1][j] == 5 || g[i + 1][j] == 6)\\n            && dfs(i + 1, j, n, m, g, vis)) return true;\\n        }\\n        else if(g[i][j] == 5) {\\n            if(good(i - 1, j, g, vis) && (g[i - 1][j] == 3 || g[i - 1][j] == 4 || g[i - 1][j] == 2) \\n            && dfs(i - 1, j, n, m, g, vis)) return true;\\n            if(good(i, j - 1, g, vis) && (g[i][j - 1] == 1 || g[i][j - 1] == 4 || g[i][j - 1] == 6) \\n            && dfs(i, j - 1, n, m, g, vis)) return true;\\n        }\\n        else {\\n            if(good(i - 1, j, g, vis) && (g[i - 1][j] == 3 || g[i - 1][j] == 4 || g[i - 1][j] == 2) \\n            && dfs(i - 1, j, n, m, g, vis)) return true;\\n            if(good(i, j + 1, g, vis) && (g[i][j + 1] == 3 || g[i][j + 1] == 5 || g[i][j + 1] == 1) \\n            && dfs(i, j + 1, n, m, g, vis)) return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m));\\n\\n        return dfs(0, 0, n, m, grid, vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091770,
                "title": "python-video-walkthrough-6-line-solution",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/gnt9ym9IV-g)\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        up, down, left, right, grid[0][0], queue = {x: set([2,3,4]) for x in [2,5,6]}, {x: set([2,5,6]) for x in [2,3,4]}, {x: set([1,4,6]) for x in [1,3,5]}, {x: set([1,3,5]) for x in [1,4,6]}, -grid[0][0], deque([(0,0)])\\n        while queue:\\n            i, j = queue.popleft()\\n            if i == len(grid) - 1 and j == len(grid[0]) -1: return True\\n            for k, l, d in filter(lambda a:  0 <= a[0] < len(grid) and 0 <= a[1] < len(grid[0]) and  -grid[i][j] in a[2] and grid[a[0]][a[1]] in a[2][-grid[i][j]] , [(i-1,j, up),(i+1,j, down),(i,j-1, left),(i,j+1, right)] ): grid[k][l], _ = -grid[k][l], queue.append((k,l))\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[int]]) -> bool:\\n        up, down, left, right, grid[0][0], queue = {x: set([2,3,4]) for x in [2,5,6]}, {x: set([2,5,6]) for x in [2,3,4]}, {x: set([1,4,6]) for x in [1,3,5]}, {x: set([1,3,5]) for x in [1,4,6]}, -grid[0][0], deque([(0,0)])\\n        while queue:\\n            i, j = queue.popleft()\\n            if i == len(grid) - 1 and j == len(grid[0]) -1: return True\\n            for k, l, d in filter(lambda a:  0 <= a[0] < len(grid) and 0 <= a[1] < len(grid[0]) and  -grid[i][j] in a[2] and grid[a[0]][a[1]] in a[2][-grid[i][j]] , [(i-1,j, up),(i+1,j, down),(i,j-1, left),(i,j+1, right)] ): grid[k][l], _ = -grid[k][l], queue.append((k,l))\\n        return False\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566004,
                "content": [
                    {
                        "username": "jbrad",
                        "content": "The description explicitly says:\\n * A<b> valid</b> path in the grid is a path which starts from the upper left cell (0,0) and <b>ends at the bottom-right cell</b> (m - 1, n - 1).*\\n  \\nHowever, it requires these two cases to pass: \\n*    {{6,1,3}, {4,1,5}},    which ends in the <b>bottom left</b> corner \\n*    {{3,4,3,4},{2,2,2,2},{6,5,6,5 }},   which ends in the <b>top right</b> corner\\n\\nWhile requiring this case to fail, which also ends in the bottom left corner.\\n *  {{2,6}},    which also ends in the <b>bottom left</b> corner as\\n   \\nI haven\\'t checked too many other solutions, but my version (which just followed the path) ended up with lots of code to check these extra edge cases.\\n"
                    },
                    {
                        "username": "ctlang",
                        "content": "Knowledge Complexity: O(easy)\\nTime Complexity: O(hard)"
                    },
                    {
                        "username": "d42jh",
                        "content": "The expected result for this case is true, but I thought the valid path should be from upper left to bottom right? In this graph the path is upper left to bottom left...\\nCould anyone explain this to me? Thanks"
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Any non-hardcoding solutions?"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Very Good Qn.If You solved this by your own means you have successfully cleared concept of DFS.\\nFollowing are some hints:\\nAt Each Node try to check that does the node above / below worth that position i.e. is path from current node to that node is possible or not.\\nWhenever you arrive at node when you can\\'t move then check is that last node of matrix or not \\nOtherwise it is Simple DFS Qn.."
                    }
                ]
            },
            {
                "id": 1804771,
                "content": [
                    {
                        "username": "jbrad",
                        "content": "The description explicitly says:\\n * A<b> valid</b> path in the grid is a path which starts from the upper left cell (0,0) and <b>ends at the bottom-right cell</b> (m - 1, n - 1).*\\n  \\nHowever, it requires these two cases to pass: \\n*    {{6,1,3}, {4,1,5}},    which ends in the <b>bottom left</b> corner \\n*    {{3,4,3,4},{2,2,2,2},{6,5,6,5 }},   which ends in the <b>top right</b> corner\\n\\nWhile requiring this case to fail, which also ends in the bottom left corner.\\n *  {{2,6}},    which also ends in the <b>bottom left</b> corner as\\n   \\nI haven\\'t checked too many other solutions, but my version (which just followed the path) ended up with lots of code to check these extra edge cases.\\n"
                    },
                    {
                        "username": "ctlang",
                        "content": "Knowledge Complexity: O(easy)\\nTime Complexity: O(hard)"
                    },
                    {
                        "username": "d42jh",
                        "content": "The expected result for this case is true, but I thought the valid path should be from upper left to bottom right? In this graph the path is upper left to bottom left...\\nCould anyone explain this to me? Thanks"
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Any non-hardcoding solutions?"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Very Good Qn.If You solved this by your own means you have successfully cleared concept of DFS.\\nFollowing are some hints:\\nAt Each Node try to check that does the node above / below worth that position i.e. is path from current node to that node is possible or not.\\nWhenever you arrive at node when you can\\'t move then check is that last node of matrix or not \\nOtherwise it is Simple DFS Qn.."
                    }
                ]
            },
            {
                "id": 1573542,
                "content": [
                    {
                        "username": "jbrad",
                        "content": "The description explicitly says:\\n * A<b> valid</b> path in the grid is a path which starts from the upper left cell (0,0) and <b>ends at the bottom-right cell</b> (m - 1, n - 1).*\\n  \\nHowever, it requires these two cases to pass: \\n*    {{6,1,3}, {4,1,5}},    which ends in the <b>bottom left</b> corner \\n*    {{3,4,3,4},{2,2,2,2},{6,5,6,5 }},   which ends in the <b>top right</b> corner\\n\\nWhile requiring this case to fail, which also ends in the bottom left corner.\\n *  {{2,6}},    which also ends in the <b>bottom left</b> corner as\\n   \\nI haven\\'t checked too many other solutions, but my version (which just followed the path) ended up with lots of code to check these extra edge cases.\\n"
                    },
                    {
                        "username": "ctlang",
                        "content": "Knowledge Complexity: O(easy)\\nTime Complexity: O(hard)"
                    },
                    {
                        "username": "d42jh",
                        "content": "The expected result for this case is true, but I thought the valid path should be from upper left to bottom right? In this graph the path is upper left to bottom left...\\nCould anyone explain this to me? Thanks"
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Any non-hardcoding solutions?"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Very Good Qn.If You solved this by your own means you have successfully cleared concept of DFS.\\nFollowing are some hints:\\nAt Each Node try to check that does the node above / below worth that position i.e. is path from current node to that node is possible or not.\\nWhenever you arrive at node when you can\\'t move then check is that last node of matrix or not \\nOtherwise it is Simple DFS Qn.."
                    }
                ]
            },
            {
                "id": 2022775,
                "content": [
                    {
                        "username": "jbrad",
                        "content": "The description explicitly says:\\n * A<b> valid</b> path in the grid is a path which starts from the upper left cell (0,0) and <b>ends at the bottom-right cell</b> (m - 1, n - 1).*\\n  \\nHowever, it requires these two cases to pass: \\n*    {{6,1,3}, {4,1,5}},    which ends in the <b>bottom left</b> corner \\n*    {{3,4,3,4},{2,2,2,2},{6,5,6,5 }},   which ends in the <b>top right</b> corner\\n\\nWhile requiring this case to fail, which also ends in the bottom left corner.\\n *  {{2,6}},    which also ends in the <b>bottom left</b> corner as\\n   \\nI haven\\'t checked too many other solutions, but my version (which just followed the path) ended up with lots of code to check these extra edge cases.\\n"
                    },
                    {
                        "username": "ctlang",
                        "content": "Knowledge Complexity: O(easy)\\nTime Complexity: O(hard)"
                    },
                    {
                        "username": "d42jh",
                        "content": "The expected result for this case is true, but I thought the valid path should be from upper left to bottom right? In this graph the path is upper left to bottom left...\\nCould anyone explain this to me? Thanks"
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Any non-hardcoding solutions?"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Very Good Qn.If You solved this by your own means you have successfully cleared concept of DFS.\\nFollowing are some hints:\\nAt Each Node try to check that does the node above / below worth that position i.e. is path from current node to that node is possible or not.\\nWhenever you arrive at node when you can\\'t move then check is that last node of matrix or not \\nOtherwise it is Simple DFS Qn.."
                    }
                ]
            },
            {
                "id": 1849547,
                "content": [
                    {
                        "username": "jbrad",
                        "content": "The description explicitly says:\\n * A<b> valid</b> path in the grid is a path which starts from the upper left cell (0,0) and <b>ends at the bottom-right cell</b> (m - 1, n - 1).*\\n  \\nHowever, it requires these two cases to pass: \\n*    {{6,1,3}, {4,1,5}},    which ends in the <b>bottom left</b> corner \\n*    {{3,4,3,4},{2,2,2,2},{6,5,6,5 }},   which ends in the <b>top right</b> corner\\n\\nWhile requiring this case to fail, which also ends in the bottom left corner.\\n *  {{2,6}},    which also ends in the <b>bottom left</b> corner as\\n   \\nI haven\\'t checked too many other solutions, but my version (which just followed the path) ended up with lots of code to check these extra edge cases.\\n"
                    },
                    {
                        "username": "ctlang",
                        "content": "Knowledge Complexity: O(easy)\\nTime Complexity: O(hard)"
                    },
                    {
                        "username": "d42jh",
                        "content": "The expected result for this case is true, but I thought the valid path should be from upper left to bottom right? In this graph the path is upper left to bottom left...\\nCould anyone explain this to me? Thanks"
                    },
                    {
                        "username": "DongmingShen",
                        "content": "Any non-hardcoding solutions?"
                    },
                    {
                        "username": "Shivam_Sikotra",
                        "content": "Very Good Qn.If You solved this by your own means you have successfully cleared concept of DFS.\\nFollowing are some hints:\\nAt Each Node try to check that does the node above / below worth that position i.e. is path from current node to that node is possible or not.\\nWhenever you arrive at node when you can\\'t move then check is that last node of matrix or not \\nOtherwise it is Simple DFS Qn.."
                    }
                ]
            }
        ]
    },
    {
        "title": "Equal Sum Arrays With Minimum Number of Operations",
        "question_content": "<p>You are given two arrays of integers <code>nums1</code> and <code><font face=\"monospace\">nums2</font></code>, possibly of different lengths. The values in the arrays are between <code>1</code> and <code>6</code>, inclusive.</p>\n\n<p>In one operation, you can change any integer&#39;s value in <strong>any </strong>of the arrays to <strong>any</strong> value between <code>1</code> and <code>6</code>, inclusive.</p>\n\n<p>Return <em>the minimum number of operations required to make the sum of values in </em><code>nums1</code><em> equal to the sum of values in </em><code>nums2</code><em>.</em> Return <code>-1</code> if it is not possible to make the sum of the two arrays equal.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed.\n- Change nums2[0] to 6. nums1 = [1,2,3,4,5,6], nums2 = [<u><strong>6</strong></u>,1,2,2,2,2].\n- Change nums1[5] to 1. nums1 = [1,2,3,4,5,<strong><u>1</u></strong>], nums2 = [6,1,2,2,2,2].\n- Change nums1[2] to 2. nums1 = [1,2,<strong><u>2</u></strong>,4,5,1], nums2 = [6,1,2,2,2,2].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,1,1,1,1,1,1], nums2 = [6]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There is no way to decrease the sum of nums1 or to increase the sum of nums2 to make them equal.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [6,6], nums2 = [1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed. \n- Change nums1[0] to 2. nums1 = [<strong><u>2</u></strong>,6], nums2 = [1].\n- Change nums1[1] to 2. nums1 = [2,<strong><u>2</u></strong>], nums2 = [1].\n- Change nums2[0] to 4. nums1 = [2,2], nums2 = [<strong><u>4</u></strong>].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 6</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1085786,
                "title": "java-python-3-2-greedy-codes-sort-and-count-w-brief-explanation-and-analysis",
                "content": "1. In order to make the two sum\\'s equal, we need either to increase to `6` the numbers in the smaller sum array or decrease to `1` the numbers in the bigger sum array;\\n2. Since we want to complete the task with minimum operations, it is optimal to choose the greater between the increase and decrease. Hence this is a greedy algorithm.\\n\\nNote:\\nIf all numbers in an array increasing to `6` still ends up with a sum less than the sum of the other array with all numbers decreasing to `1`\\'s, then it is impossible to make their sums equal.\\n\\n----\\n\\n**Method 1: Sort and 2 pointers**\\n1. Sort both arrays and get their sums respectively: `sum1` and `sum2`;\\n2. Use two pointers in the two arrays; one pointer from left to right in the array with smaller sum and the other from right to left in the array with bigger sum;\\n3. In the array with smaller sum, check the difference between current element with `6`; in the array with bigger sum, check the difference between current element with `1`; choose the larger difference and add it to `sum1`.\\n4. repeat 3 till `sum1 >= sum2 `.\\n```java\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        if (nums1.length * 6 < nums2.length || nums1.length > 6 * nums2.length) {\\n            return -1;\\n        }\\n        int sum1 = IntStream.of(nums1).sum(); \\n        int sum2 = IntStream.of(nums2).sum();\\n        if (sum1 > sum2) {\\n            return minOperations(nums2, nums1); // make sure the sum of 1st array <= sum of 2nd one.\\n        }\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int i = 0, j = nums2.length - 1, operations = 0;\\n        while (sum2 > sum1) {\\n            // increase the number in nums1 or decrease the number in nums2? \\n            if (j < 0 || i < nums1.length && 6 - nums1[i] > nums2[j] - 1) {\\n                sum1 += 6 - nums1[i++]; // increase to 6 the number in nums1.\\n            }else {\\n                sum2 -= nums2[j--] - 1; // decrease to 1 the number in nums2.\\n            }\\n            ++operations;\\n        }\\n        return operations;\\n    }\\n```\\n```python\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1) > len(nums2) * 6 or len(nums1) * 6 < len(nums2):\\n            return -1\\n        sm1, sm2 = map(sum, (nums1, nums2))\\n        if sm1 > sm2:\\n            return self.minOperations(nums2, nums1)\\n        nums1.sort()\\n        nums2.sort()\\n        i, j = 0, len(nums2) - 1\\n        operations = 0\\n        while sm2 > sm1:\\n            if j < 0 or i < len(nums1) and 6 - nums1[i] > nums2[j] - 1:\\n                sm1 += 6 - nums1[i]\\n                i += 1\\n            else:\\n                sm2 -= nums2[j] - 1    \\n                j -= 1\\n            operations += 1\\n        return operations\\n```\\n**Analysis:**\\nMajor part of time and space cost lie in the sorting in two arrays. Therefore\\n\\nTime: `O(m * logm + n * logn)`, space: `O(m + n)`, where `m = nums1.length, n = nums2.length`.\\n\\n----\\n\\n**Method 2: Count the increases and decreases.** -- Inspired by **@lenchen1112**.\\n`sum1 = sum(nums1), sum2 = sum(nums2)`\\n1. Swap `nums1` and `nums2` if `sum1 > sum2` to make sure `sum1 <= sum2`;\\n2. Use an array `cnt` to count the increases in `nums1` and decreases in`nums2`;\\n3. Starting from `5`, the largest increase or decrease, to add it to `sum1` and decrease the corresponding counter in `cnt` by 1; repeat till the counter reaches `0`; then for `4, 3, 2, 1`, repeat the procedure till `sum1 >= sum2`.\\n\\n```java\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        if (nums1.length * 6 < nums2.length || nums1.length > nums2.length * 6) {\\n            return -1;\\n        }\\n        int sum1 = IntStream.of(nums1).sum(); \\n        int sum2 = IntStream.of(nums2).sum();\\n        if (sum1 > sum2) {\\n            return minOperations(nums2, nums1); // make sure the sum of 1st array <= sum of 2nd one.\\n        }\\n        int[] cnt = new int[6]; // array used to count the increases in nums1 and the decreases in nums2.\\n        IntStream.of(nums1).forEach(n -> ++cnt[6 - n]);\\n        IntStream.of(nums2).forEach(n -> ++cnt[n - 1]);\\n        int i = 5, operations = 0;\\n        while (sum2 > sum1) {\\n            while (cnt[i] == 0) { // skip 0 count of increases or decreases.\\n                --i;\\n            }\\n            sum1 += i; // located current biggest increase or decrease.\\n            --cnt[i]; // deduct the count.\\n            ++operations; // increase the operation counter.\\n        }\\n        return operations;\\n    }\\n```\\n```python\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1) * 6 < len(nums2) or len(nums1) > len(nums2) * 6:\\n            return -1\\n        sm1, sm2 = map(sum, (nums1, nums2))\\n        if sm1 > sm2:\\n            return self.minOperations(nums2, nums1)\\n        cnt = Counter([6 - n for n in nums1] + [n - 1 for n in nums2])\\n        i, operations = 5, 0\\n        while sm2 > sm1:\\n            while cnt[i] == 0:\\n                i -= 1\\n            sm1 += i\\n            cnt[i] -= 1\\n            operations += 1\\n        return operations\\n```\\n\\n**Analysis:**\\n\\nTime: `O(m + n)`, space: `O(1)`, where `m = nums1.length, n = nums2.length`.",
                "solutionTags": [],
                "code": "```java\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        if (nums1.length * 6 < nums2.length || nums1.length > 6 * nums2.length) {\\n            return -1;\\n        }\\n        int sum1 = IntStream.of(nums1).sum(); \\n        int sum2 = IntStream.of(nums2).sum();\\n        if (sum1 > sum2) {\\n            return minOperations(nums2, nums1); // make sure the sum of 1st array <= sum of 2nd one.\\n        }\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int i = 0, j = nums2.length - 1, operations = 0;\\n        while (sum2 > sum1) {\\n            // increase the number in nums1 or decrease the number in nums2? \\n            if (j < 0 || i < nums1.length && 6 - nums1[i] > nums2[j] - 1) {\\n                sum1 += 6 - nums1[i++]; // increase to 6 the number in nums1.\\n            }else {\\n                sum2 -= nums2[j--] - 1; // decrease to 1 the number in nums2.\\n            }\\n            ++operations;\\n        }\\n        return operations;\\n    }\\n```\n```python\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1) > len(nums2) * 6 or len(nums1) * 6 < len(nums2):\\n            return -1\\n        sm1, sm2 = map(sum, (nums1, nums2))\\n        if sm1 > sm2:\\n            return self.minOperations(nums2, nums1)\\n        nums1.sort()\\n        nums2.sort()\\n        i, j = 0, len(nums2) - 1\\n        operations = 0\\n        while sm2 > sm1:\\n            if j < 0 or i < len(nums1) and 6 - nums1[i] > nums2[j] - 1:\\n                sm1 += 6 - nums1[i]\\n                i += 1\\n            else:\\n                sm2 -= nums2[j] - 1    \\n                j -= 1\\n            operations += 1\\n        return operations\\n```\n```java\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        if (nums1.length * 6 < nums2.length || nums1.length > nums2.length * 6) {\\n            return -1;\\n        }\\n        int sum1 = IntStream.of(nums1).sum(); \\n        int sum2 = IntStream.of(nums2).sum();\\n        if (sum1 > sum2) {\\n            return minOperations(nums2, nums1); // make sure the sum of 1st array <= sum of 2nd one.\\n        }\\n        int[] cnt = new int[6]; // array used to count the increases in nums1 and the decreases in nums2.\\n        IntStream.of(nums1).forEach(n -> ++cnt[6 - n]);\\n        IntStream.of(nums2).forEach(n -> ++cnt[n - 1]);\\n        int i = 5, operations = 0;\\n        while (sum2 > sum1) {\\n            while (cnt[i] == 0) { // skip 0 count of increases or decreases.\\n                --i;\\n            }\\n            sum1 += i; // located current biggest increase or decrease.\\n            --cnt[i]; // deduct the count.\\n            ++operations; // increase the operation counter.\\n        }\\n        return operations;\\n    }\\n```\n```python\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1) * 6 < len(nums2) or len(nums1) > len(nums2) * 6:\\n            return -1\\n        sm1, sm2 = map(sum, (nums1, nums2))\\n        if sm1 > sm2:\\n            return self.minOperations(nums2, nums1)\\n        cnt = Counter([6 - n for n in nums1] + [n - 1 for n in nums2])\\n        i, operations = 5, 0\\n        while sm2 > sm1:\\n            while cnt[i] == 0:\\n                i -= 1\\n            sm1 += i\\n            cnt[i] -= 1\\n            operations += 1\\n        return operations\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1086142,
                "title": "c-java-o-n",
                "content": "#### Intuition\\nWe can increase sum of the smaller array up 5 per move (if we have `1` in there).\\nWe can decrease sum of the larger array up to 5 points per move (if we have `6` there).\\n\\n#### Solution 1 - O(n)\\nI suggest going through the heap solution below to get a good feel of this problem. In this solution, we use the same approach, but we count numbers [1...6] in each array and then calculate how many of each number we need to change.\\n\\nIn a way, we go from O(n log n) to O(n) by using counting sort.\\n\\n> Why then I put this solution first, and not after the easier one? Because this is so exciting, so exciting! And there is a Java version :)\\n\\n**C++**\\n```cpp\\n int minOperations(vector<int>& n1, vector<int>& n2) {\\n    if (n2.size() * 6 < n1.size() || n1.size() * 6 < n2.size())\\n        return -1;\\n    int sum1 = accumulate(begin(n1), end(n1), 0), sum2 = accumulate(begin(n2), end(n2), 0);    \\n    if (sum1 > sum2)\\n        swap(n1, n2);    \\n    int cnt[6] = {}, diff = abs(sum1 - sum2), res = 0;\\n    for (auto n : n1)\\n        ++cnt[6 - n];\\n    for (auto n : n2)\\n        ++cnt[n - 1];\\n    for (int i = 5; i > 0 && diff > 0; --i) {\\n        int take = min(cnt[i], diff / i + (diff % i != 0));\\n        diff -= take * i;\\n        res += take;\\n    }\\n    return res;\\n}\\n```\\n**Java**\\n```java\\nint minOperations(int[] n1, int[] n2) {\\n    if (n2.length * 6 < n1.length || n1.length * 6 < n2.length)\\n        return -1;\\n    int sum1 = Arrays.stream(n1).sum(), sum2 = Arrays.stream(n2).sum();\\n    if (sum1 < sum2)\\n        return minOperations(n1, n2, sum1, sum2);\\n    return minOperations(n2, n1, sum2, sum1);\\n}\\nint minOperations(int[] n1, int[] n2, int sum1, int sum2) {\\n    int cnt[] = new int[6], diff = sum2 - sum1, res = 0;\\n    for (var n : n1)\\n        ++cnt[6 - n];\\n    for (var n : n2)\\n        ++cnt[n - 1];\\n    for (int i = 5; i > 0 && diff > 0; --i) {\\n        int take = Math.min(cnt[i], diff / i + (diff % i != 0 ? 1 : 0));\\n        diff -= take * i;\\n        res += take;\\n    }    \\n    return res;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n + m), where n and m are sizes of our arrays.\\n- Memory: O(1).\\n\\n#### Solution 2 - Heap\\n1. Use min heap for the smaller, and max heap for larger arrays.\\n2. Pull a value from one of the heaps; pick a heap that would give us the most points.\\n3. Repeat till the sum of two arrays is equalized.\\n\\n**Why we use heaps instead of sorting?**\\nTwo reasons. \\n1. Heaps are great when you do not know how many elements you\\'ll need to process. The runtime complexity of a heap is O(k log n), where `k` is the number of `pop` operations.\\n2. If you \"heapify\" original arrays, your memory complexity would be O(1), because heapsort is O(1). A sorting algorithm, such as quick sort, needs O(log n) memory for the stack.\\n\\n**C++ Priority Queue**\\n```cpp\\nint minOperations(vector<int>& n1, vector<int>& n2) {\\n    if (n2.size() * 6 < n1.size() || n1.size() * 6 < n2.size())\\n        return -1;\\n    int sum1 = accumulate(begin(n1), end(n1), 0), sum2 = accumulate(begin(n2), end(n2), 0);\\n    if (sum1 > sum2)\\n        swap(n1, n2);\\n    priority_queue <int, vector<int>, greater<int>> q1(begin(n1), end(n1));\\n    priority_queue<int> q2(begin(n2), end(n2));\\n    int cnt = 0, diff = abs(sum1 - sum2);\\n    while (diff > 0) {\\n        ++cnt;\\n        if (q1.empty() || (!q2.empty() && q2.top() - 1 > 6 - q1.top())) {\\n            diff -= q2.top() - 1;\\n            q2.pop();\\n        } else {\\n            diff -= 6 - q1.top();\\n            q1.pop();\\n        }\\n    }\\n    return cnt;\\n}\\n```\\n**C++ make_heap**\\n```cpp\\nint minOperations(vector<int>& n1, vector<int>& n2) {\\n    if (n2.size() * 6 < n1.size() || n1.size() * 6 < n2.size())\\n        return -1;\\n    int sum1 = accumulate(begin(n1), end(n1), 0), sum2 = accumulate(begin(n2), end(n2), 0);\\n    if (sum1 > sum2)\\n        swap(n1, n2);\\n    make_heap(begin(n1), end(n1), greater<int>());\\n    make_heap(begin(n2), end(n2));\\n    int cnt = 0, diff = abs(sum1 - sum2);\\n    while (diff > 0) {\\n        ++cnt;\\n        if (n1.empty() || (!n2.empty() && n2.front() - 1 > 6 - n1.front())) {\\n            diff -= n2.front() - 1;\\n            pop_heap(begin(n2), end(n2)); n2.pop_back();\\n        } else {\\n            diff -= 6 - n1.front();\\n            pop_heap(begin(n1), end(n1), greater<int>()); n1.pop_back();            \\n        }\\n    }\\n    return cnt;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n log n + m log m), where n and m are sizes of our arrays.\\n- Memory: O(n + m) for the first solution, and O(1) - for the second (we re-use the original arrays as heaps).",
                "solutionTags": [],
                "code": "```cpp\\n int minOperations(vector<int>& n1, vector<int>& n2) {\\n    if (n2.size() * 6 < n1.size() || n1.size() * 6 < n2.size())\\n        return -1;\\n    int sum1 = accumulate(begin(n1), end(n1), 0), sum2 = accumulate(begin(n2), end(n2), 0);    \\n    if (sum1 > sum2)\\n        swap(n1, n2);    \\n    int cnt[6] = {}, diff = abs(sum1 - sum2), res = 0;\\n    for (auto n : n1)\\n        ++cnt[6 - n];\\n    for (auto n : n2)\\n        ++cnt[n - 1];\\n    for (int i = 5; i > 0 && diff > 0; --i) {\\n        int take = min(cnt[i], diff / i + (diff % i != 0));\\n        diff -= take * i;\\n        res += take;\\n    }\\n    return res;\\n}\\n```\n```java\\nint minOperations(int[] n1, int[] n2) {\\n    if (n2.length * 6 < n1.length || n1.length * 6 < n2.length)\\n        return -1;\\n    int sum1 = Arrays.stream(n1).sum(), sum2 = Arrays.stream(n2).sum();\\n    if (sum1 < sum2)\\n        return minOperations(n1, n2, sum1, sum2);\\n    return minOperations(n2, n1, sum2, sum1);\\n}\\nint minOperations(int[] n1, int[] n2, int sum1, int sum2) {\\n    int cnt[] = new int[6], diff = sum2 - sum1, res = 0;\\n    for (var n : n1)\\n        ++cnt[6 - n];\\n    for (var n : n2)\\n        ++cnt[n - 1];\\n    for (int i = 5; i > 0 && diff > 0; --i) {\\n        int take = Math.min(cnt[i], diff / i + (diff % i != 0 ? 1 : 0));\\n        diff -= take * i;\\n        res += take;\\n    }    \\n    return res;\\n}\\n```\n```cpp\\nint minOperations(vector<int>& n1, vector<int>& n2) {\\n    if (n2.size() * 6 < n1.size() || n1.size() * 6 < n2.size())\\n        return -1;\\n    int sum1 = accumulate(begin(n1), end(n1), 0), sum2 = accumulate(begin(n2), end(n2), 0);\\n    if (sum1 > sum2)\\n        swap(n1, n2);\\n    priority_queue <int, vector<int>, greater<int>> q1(begin(n1), end(n1));\\n    priority_queue<int> q2(begin(n2), end(n2));\\n    int cnt = 0, diff = abs(sum1 - sum2);\\n    while (diff > 0) {\\n        ++cnt;\\n        if (q1.empty() || (!q2.empty() && q2.top() - 1 > 6 - q1.top())) {\\n            diff -= q2.top() - 1;\\n            q2.pop();\\n        } else {\\n            diff -= 6 - q1.top();\\n            q1.pop();\\n        }\\n    }\\n    return cnt;\\n}\\n```\n```cpp\\nint minOperations(vector<int>& n1, vector<int>& n2) {\\n    if (n2.size() * 6 < n1.size() || n1.size() * 6 < n2.size())\\n        return -1;\\n    int sum1 = accumulate(begin(n1), end(n1), 0), sum2 = accumulate(begin(n2), end(n2), 0);\\n    if (sum1 > sum2)\\n        swap(n1, n2);\\n    make_heap(begin(n1), end(n1), greater<int>());\\n    make_heap(begin(n2), end(n2));\\n    int cnt = 0, diff = abs(sum1 - sum2);\\n    while (diff > 0) {\\n        ++cnt;\\n        if (n1.empty() || (!n2.empty() && n2.front() - 1 > 6 - n1.front())) {\\n            diff -= n2.front() - 1;\\n            pop_heap(begin(n2), end(n2)); n2.pop_back();\\n        } else {\\n            diff -= 6 - n1.front();\\n            pop_heap(begin(n1), end(n1), greater<int>()); n1.pop_back();            \\n        }\\n    }\\n    return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1085859,
                "title": "python-o-nlogn-faster-than-100-00-with-explanation",
                "content": "We have two arrays, by calculating the sum, we can know which is larger and which is the smaller.\\nTo reach a same sum value (reduce the difference on sum to 0):\\n* For larger array, at each operation, we want to decrease the number as much as possible.\\nSince the min value we can decrease to is 1, at position` i`, the max contribution (to reduce the difference) we can \"gain\"  is ` larger_array[i] - 1`\\n* Similarly, for smaller array, we want to increase the number as much as possible.  \\nSince the max value we can increase to is 6, the \"gain\" at position `i` is ` 6-smaller_array[i]`\\n\\nThus, following this idea, we can: \\n1. calculate the \"gain\" at each position in the larger and smaller array\\n2. sort them together in an ascending order.\\n3. by accumulating the \"gain\" from large to small, we can know the least steps to reduce the difference to 0 \\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n\\t\\t# step1. determine the larger array and the smaller array, and get the difference on sum\\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        \\n        if sum1==sum2:\\n            return 0\\n        elif sum1>sum2:\\n            larger_sum_nums = nums1\\n            smaller_sum_nums = nums2\\n        else:\\n            larger_sum_nums = nums2\\n            smaller_sum_nums = nums1\\n\\t\\t\\n        sum_diff = abs(sum1-sum2)\\n            \\n        # step2. calculate the max \"gain\" at each position (how much difference we can reduce if operating on that position)    \\n        gains_in_larger_array = [num-1 for num in larger_sum_nums]\\n        gains_in_smaller_array = [6-num for num in smaller_sum_nums]\\n        \\n\\t\\t# step3. sort the \"gain\" and check the least number of steps to reduce the difference to 0\\n        gains = gains_in_larger_array + gains_in_smaller_array\\n        gains.sort(reverse = True)\\n        \\n        count = 0\\n        target_diff = sum_diff\\n        \\n        for i in range(len(gains)):\\n            target_diff -= gains[i]\\n            count += 1\\n            \\n            if target_diff <= 0:\\n                return count\\n\\t\\t\\n\\t\\t# return -1 if the difference still cannot be reduced to 0 even after operating on all positions\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n\\t\\t# step1. determine the larger array and the smaller array, and get the difference on sum\\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        \\n        if sum1==sum2:\\n            return 0\\n        elif sum1>sum2:\\n            larger_sum_nums = nums1\\n            smaller_sum_nums = nums2\\n        else:\\n            larger_sum_nums = nums2\\n            smaller_sum_nums = nums1\\n\\t\\t\\n        sum_diff = abs(sum1-sum2)\\n            \\n        # step2. calculate the max \"gain\" at each position (how much difference we can reduce if operating on that position)    \\n        gains_in_larger_array = [num-1 for num in larger_sum_nums]\\n        gains_in_smaller_array = [6-num for num in smaller_sum_nums]\\n        \\n\\t\\t# step3. sort the \"gain\" and check the least number of steps to reduce the difference to 0\\n        gains = gains_in_larger_array + gains_in_smaller_array\\n        gains.sort(reverse = True)\\n        \\n        count = 0\\n        target_diff = sum_diff\\n        \\n        for i in range(len(gains)):\\n            target_diff -= gains[i]\\n            count += 1\\n            \\n            if target_diff <= 0:\\n                return count\\n\\t\\t\\n\\t\\t# return -1 if the difference still cannot be reduced to 0 even after operating on all positions\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085827,
                "title": "easy-to-understand-c-greedy-short-code",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int s1 =0, s2 = 0;\\n        for(int &x: nums1) s1 += x;\\n        for(int &x: nums2) s2 += x;\\n        if(s1 > s2) swap(nums1, nums2), swap(s1, s2);\\n\\t\\t\\n        // from here sum(nums1) <= sum(nums2) ie, s1 <= s2\\n\\t\\t// now our task is to make both s1 and s2 equal by some good operations.\\n\\t\\t// we have two ways to do that \\n\\t\\t//      1. either increase some elements to \\'6\\' in nums1.\\n\\t\\t//      2. decrease some elements to \\'1\\' in nums2.\\n\\t\\t\\n        int ans = 0, diff = s2 - s1; // so,  we need to recover this \\'diff\\'.\\n        if(diff == 0) return 0;\\n       \\n        vector<int>arr;\\n        for(int &x: nums1) arr.push_back(6 - x);\\n\\t\\t// 6 - x signifies how much increment it does if we change a element \\'x\\' to \\'6\\' in nums1 in one operation. ( 1st way )\\n\\t\\t// this operation increases s1 by \\'6 - x\\', (diff = s2 - s1) (as s1 increases then diff decreases).\\n\\t\\t\\n        for(int &x: nums2) arr.push_back(x - 1);\\n        // similarly, x - 1 signifies how much decrement it does if we change a element \\'x\\' to \\'1\\' in nums2 in one operation. (2nd way)\\n\\t\\t// this operation decreases s2 by \\'x - 1\\', (diff = s2 - s1) (as s2 decreases then diff decreases).\\n\\t\\t\\n        sort(arr.rbegin(), arr.rend());\\n\\t\\t// sorting in desending order to pick the most valuable operation that decreases the \\'diff\\'. (Yes, Greedy)\\n        \\n        for(int &x: arr){\\n            ans++; \\n            diff -= x;\\n            if(diff <= 0) return ans; // at some operation may diff == 0 \\n\\t\\t\\t// if diff < 0 then we can adjust last operation to our needs.\\n        }\\n        return -1;\\n    }\\n\\t// follow up we can make this works in O(n) using count sort instead.\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int s1 =0, s2 = 0;\\n        for(int &x: nums1) s1 += x;\\n        for(int &x: nums2) s2 += x;\\n        if(s1 > s2) swap(nums1, nums2), swap(s1, s2);\\n\\t\\t\\n        // from here sum(nums1) <= sum(nums2) ie, s1 <= s2\\n\\t\\t// now our task is to make both s1 and s2 equal by some good operations.\\n\\t\\t// we have two ways to do that \\n\\t\\t//      1. either increase some elements to \\'6\\' in nums1.\\n\\t\\t//      2. decrease some elements to \\'1\\' in nums2.\\n\\t\\t\\n        int ans = 0, diff = s2 - s1; // so,  we need to recover this \\'diff\\'.\\n        if(diff == 0) return 0;\\n       \\n        vector<int>arr;\\n        for(int &x: nums1) arr.push_back(6 - x);\\n\\t\\t// 6 - x signifies how much increment it does if we change a element \\'x\\' to \\'6\\' in nums1 in one operation. ( 1st way )\\n\\t\\t// this operation increases s1 by \\'6 - x\\', (diff = s2 - s1) (as s1 increases then diff decreases).\\n\\t\\t\\n        for(int &x: nums2) arr.push_back(x - 1);\\n        // similarly, x - 1 signifies how much decrement it does if we change a element \\'x\\' to \\'1\\' in nums2 in one operation. (2nd way)\\n\\t\\t// this operation decreases s2 by \\'x - 1\\', (diff = s2 - s1) (as s2 decreases then diff decreases).\\n\\t\\t\\n        sort(arr.rbegin(), arr.rend());\\n\\t\\t// sorting in desending order to pick the most valuable operation that decreases the \\'diff\\'. (Yes, Greedy)\\n        \\n        for(int &x: arr){\\n            ans++; \\n            diff -= x;\\n            if(diff <= 0) return ans; // at some operation may diff == 0 \\n\\t\\t\\t// if diff < 0 then we can adjust last operation to our needs.\\n        }\\n        return -1;\\n    }\\n\\t// follow up we can make this works in O(n) using count sort instead.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085772,
                "title": "java-priorityqueue",
                "content": "I have added smaller sum array to min priority queue and larger sum array to max priority queue.\\nWe need to make the sum equal, so I greedily pick an item from the queue that will minimize the difference.\\n\\nSince we need to minimize the difference between sum of 2 arrays, \\n* we can decrease the sum2 by pq2.peek()-1 \\n* or increase the sum1 by 6 - pq1.peek()\\n\\n```\\npublic int minOperations(int[] nums1, int[] nums2) {\\n\\tif(nums1.length > nums2.length * 6 || nums2.length > nums1.length * 6) \\n\\t\\treturn -1;\\n\\tint sum1=0, sum2 =0, operations = 0;\\n\\tfor(int i: nums2) sum2+=i;\\n\\tfor(int i: nums1) sum1+=i;\\n\\tif(sum1>sum2) {\\n\\t\\tint[] temp = nums1;\\n\\t\\tnums1= nums2;\\n\\t\\tnums2 = temp;\\n\\n\\t\\tint tempSum = sum1;\\n\\t\\tsum1 = sum2;\\n\\t\\tsum2 = tempSum;\\n\\t}\\n\\tPriorityQueue<Integer> pq1 = new PriorityQueue<>(), pq2 = new PriorityQueue<>((x,y)->y-x);\\n\\tfor(int i:nums1) pq1.offer(i);\\n\\tfor(int i:nums2) pq2.offer(i);\\n\\n\\tfor(;sum1 < sum2;operations++)\\n\\t\\tif(pq2.isEmpty() || pq2.peek() - 1 < 6 - pq1.peek())\\n\\t\\t\\tsum1 += 6 - pq1.poll();\\n\\t\\telse\\n\\t\\t\\tsum2 -= pq2.poll() - 1;\\n\\treturn operations;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(int[] nums1, int[] nums2) {\\n\\tif(nums1.length > nums2.length * 6 || nums2.length > nums1.length * 6) \\n\\t\\treturn -1;\\n\\tint sum1=0, sum2 =0, operations = 0;\\n\\tfor(int i: nums2) sum2+=i;\\n\\tfor(int i: nums1) sum1+=i;\\n\\tif(sum1>sum2) {\\n\\t\\tint[] temp = nums1;\\n\\t\\tnums1= nums2;\\n\\t\\tnums2 = temp;\\n\\n\\t\\tint tempSum = sum1;\\n\\t\\tsum1 = sum2;\\n\\t\\tsum2 = tempSum;\\n\\t}\\n\\tPriorityQueue<Integer> pq1 = new PriorityQueue<>(), pq2 = new PriorityQueue<>((x,y)->y-x);\\n\\tfor(int i:nums1) pq1.offer(i);\\n\\tfor(int i:nums2) pq2.offer(i);\\n\\n\\tfor(;sum1 < sum2;operations++)\\n\\t\\tif(pq2.isEmpty() || pq2.peek() - 1 < 6 - pq1.peek())\\n\\t\\t\\tsum1 += 6 - pq1.poll();\\n\\t\\telse\\n\\t\\t\\tsum2 -= pq2.poll() - 1;\\n\\treturn operations;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1085806,
                "title": "python3-two-heaps",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if 6*len(nums1) < len(nums2) or 6*len(nums2) < len(nums1): return -1 # impossible \\n        \\n        if sum(nums1) < sum(nums2): nums1, nums2 = nums2, nums1\\n        s1, s2 = sum(nums1), sum(nums2)\\n            \\n        nums1 = [-x for x in nums1] # max-heap \\n        heapify(nums1)\\n        heapify(nums2)\\n        \\n        ans = 0\\n        while s1 > s2: \\n            x1, x2 = nums1[0], nums2[0]\\n            if -1-x1 > 6-x2: # change x1 to 1\\n                s1 += x1 + 1\\n                heapreplace(nums1, -1)\\n            else: \\n                s2 += 6 - x2\\n                heapreplace(nums2, 6)\\n            ans += 1\\n        return ans \\n```\\n\\nEdited on 2/28/2021\\nAdding 2-pointer approach \\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if 6*len(nums1) < len(nums2) or 6*len(nums2) < len(nums1): return -1 # impossible \\n        \\n        if sum(nums1) < sum(nums2): nums1, nums2 = nums2, nums1\\n        s1, s2 = sum(nums1), sum(nums2) # s1 >= s2\\n            \\n        nums1.sort()\\n        nums2.sort()\\n        \\n        ans = j = 0\\n        i = len(nums1)-1\\n        \\n        while s1 > s2: \\n            if j >= len(nums2) or 0 <= i and nums1[i] - 1 > 6 - nums2[j]: \\n                s1 += 1 - nums1[i]\\n                i -= 1\\n            else: \\n                s2 += 6 - nums2[j]\\n                j += 1\\n            ans += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if 6*len(nums1) < len(nums2) or 6*len(nums2) < len(nums1): return -1 # impossible \\n        \\n        if sum(nums1) < sum(nums2): nums1, nums2 = nums2, nums1\\n        s1, s2 = sum(nums1), sum(nums2)\\n            \\n        nums1 = [-x for x in nums1] # max-heap \\n        heapify(nums1)\\n        heapify(nums2)\\n        \\n        ans = 0\\n        while s1 > s2: \\n            x1, x2 = nums1[0], nums2[0]\\n            if -1-x1 > 6-x2: # change x1 to 1\\n                s1 += x1 + 1\\n                heapreplace(nums1, -1)\\n            else: \\n                s2 += 6 - x2\\n                heapreplace(nums2, 6)\\n            ans += 1\\n        return ans \\n```\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if 6*len(nums1) < len(nums2) or 6*len(nums2) < len(nums1): return -1 # impossible \\n        \\n        if sum(nums1) < sum(nums2): nums1, nums2 = nums2, nums1\\n        s1, s2 = sum(nums1), sum(nums2) # s1 >= s2\\n            \\n        nums1.sort()\\n        nums2.sort()\\n        \\n        ans = j = 0\\n        i = len(nums1)-1\\n        \\n        while s1 > s2: \\n            if j >= len(nums2) or 0 <= i and nums1[i] - 1 > 6 - nums2[j]: \\n                s1 += 1 - nums1[i]\\n                i -= 1\\n            else: \\n                s2 += 6 - nums2[j]\\n                j += 1\\n            ans += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086127,
                "title": "greedy-c-o-n-time-and-o-1-space-short-easy-to-understand-100-beat",
                "content": "Arrays can\\'t be equalised if one of the array is all `1s` and other is all `6s`, and still the first array is greater in sum. In all other cases, we can equalise the array through some operation. \\n\\nTo minimize the operations, we need to start reducing the `diff`(difference of sum of arrays) by maximum amount possible till it becomes 0. If sum of `nums1` is less than sum of `nums2`:\\n*  elements from `nums1` will only be used for increment and vice-versa.\\n\\nIf sum of `nums1` is greater than sum of `nums2`, just swap the arrays to avoid writing multiple conditions.\\n\\nNow, both the elements of `nums1` and `nums2` will be used to reduce `diff` to 0 either by incrementing or decrementing the elements(which doesn\\'t matter to us). We just start reducing the `diff` by maximum amounts possible - (5, then 4, ... lastly 1) and increment the corresponding operations `op` required.\\n\\n\\n```\\nint minOperations(vector<int>& nums1, vector<int>& nums2) {\\n\\t    // not possible to equalize under following conditions\\n        if(6 * nums1.size() < 1 * nums2.size() || 6 * nums2.size() < 1 * nums1.size())\\n            return -1;\\n        int diff = 0, op = 0, j = 5;\\n        vector<int>arr(6);\\n        diff = accumulate(begin(nums1), end(nums1), 0) - accumulate(begin(nums2), end(nums2), 0);\\n        // if diff is positive, switch array bcoz numbers from first array will be used for subtracting and vice-versa\\n        if(diff > 0) swap(nums1, nums2);\\n        // arr stores frequency of numbers(1-5) that can be subtracted from diff to make it 0\\n        for(int &num : nums1) arr[6 - num]++;  \\n        for(int &num : nums2) arr[num - 1]++;        \\n        diff = abs(diff);\\n        \\n        while(diff > 0){\\n            if(arr[j]){\\n                op += min(arr[j], (int)ceil(1.0 * diff / j));\\n                diff -= arr[j] * j;\\n                if(diff <= 0)return op;                \\n            }\\n\\t\\t\\tj--;\\n\\t\\t}\\n        return op;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint minOperations(vector<int>& nums1, vector<int>& nums2) {\\n\\t    // not possible to equalize under following conditions\\n        if(6 * nums1.size() < 1 * nums2.size() || 6 * nums2.size() < 1 * nums1.size())\\n            return -1;\\n        int diff = 0, op = 0, j = 5;\\n        vector<int>arr(6);\\n        diff = accumulate(begin(nums1), end(nums1), 0) - accumulate(begin(nums2), end(nums2), 0);\\n        // if diff is positive, switch array bcoz numbers from first array will be used for subtracting and vice-versa\\n        if(diff > 0) swap(nums1, nums2);\\n        // arr stores frequency of numbers(1-5) that can be subtracted from diff to make it 0\\n        for(int &num : nums1) arr[6 - num]++;  \\n        for(int &num : nums2) arr[num - 1]++;        \\n        diff = abs(diff);\\n        \\n        while(diff > 0){\\n            if(arr[j]){\\n                op += min(arr[j], (int)ceil(1.0 * diff / j));\\n                diff -= arr[j] * j;\\n                if(diff <= 0)return op;                \\n            }\\n\\t\\t\\tj--;\\n\\t\\t}\\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1085956,
                "title": "python-3-heap-greedy-explanations",
                "content": "### Explanation\\n- There will be a difference (`diff`) between `the sum of nums1` and `the sum of nums2`\\n- To make the `diff` converges to 0 the fastest way, we want to make \\n\\t- The list with larger sum, become smaller\\n\\t- The list with smaller sum, become larger\\n\\t- We define `effort` as the absolute difference between the new value & the original value\\n\\t- In each turn, whoever makes the greater `effort` will get picked (use `heap` for the help)\\n- Above is the idea for the first `while` loop\\n- If there are `nums1` or `nums2` left over, use them up until the difference is less than or equal to 0\\n\\t- Second & third `while` loop\\n- Return `ans` only if `diff` is less than or equal to 0, otherwise return -1 as there is no way to make `diff` to 0\\n### Implementation\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = sum(nums1), sum(nums2)\\n        if s1 > s2:\\n            s1, s2 = s2, s1\\n            nums1, nums2 = nums2, nums1\\n        # to make s1 < s2            \\n        heapq.heapify(nums1)            \\n        nums2 = [-num for num in nums2]\\n        heapq.heapify(nums2)            \\n        ans = 0\\n        diff = s2 - s1\\n        while diff > 0 and nums1 and nums2:\\n            a = 6 - nums1[0]\\n            b = - (1 + nums2[0])\\n            if a > b:\\n                heapq.heappop(nums1)                \\n                diff -= a\\n            else:\\n                heapq.heappop(nums2)                \\n                diff -= b\\n            ans += 1                \\n        while diff > 0 and nums1:            \\n            a = 6 - heapq.heappop(nums1)                \\n            diff -= a\\n            ans += 1                \\n        while diff > 0 and nums2:            \\n            b = - (1 + heapq.heappop(nums2))\\n            diff -= b\\n            ans += 1                \\n        return ans if diff <= 0 else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = sum(nums1), sum(nums2)\\n        if s1 > s2:\\n            s1, s2 = s2, s1\\n            nums1, nums2 = nums2, nums1\\n        # to make s1 < s2            \\n        heapq.heapify(nums1)            \\n        nums2 = [-num for num in nums2]\\n        heapq.heapify(nums2)            \\n        ans = 0\\n        diff = s2 - s1\\n        while diff > 0 and nums1 and nums2:\\n            a = 6 - nums1[0]\\n            b = - (1 + nums2[0])\\n            if a > b:\\n                heapq.heappop(nums1)                \\n                diff -= a\\n            else:\\n                heapq.heappop(nums2)                \\n                diff -= b\\n            ans += 1                \\n        while diff > 0 and nums1:            \\n            a = 6 - heapq.heappop(nums1)                \\n            diff -= a\\n            ans += 1                \\n        while diff > 0 and nums2:            \\n            b = - (1 + heapq.heappop(nums2))\\n            diff -= b\\n            ans += 1                \\n        return ans if diff <= 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702229,
                "title": "c-priority-queue-greedy-easy-understanding-clean-code",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size(); \\n        \\n        int sum1 = accumulate(nums1.begin(),nums1.end(),0);\\n        int sum2 = accumulate(nums2.begin(),nums2.end(),0); \\n\\n        priority_queue<int>pq;\\n\\n        int req = abs(sum1-sum2);\\n        int cnt = 0;\\n\\n        if(sum1>sum2)\\n        {\\n           for(int i = 0;i<n1;++i) pq.push(nums1[i]-1);\\n        \\n           for(int i = 0;i<n2;++i) pq.push(6-nums2[i]);\\n    \\n        }\\n\\n        else\\n        {\\n           for(int i = 0;i<n2;++i) pq.push(nums2[i]-1);\\n           \\n           for(int i = 0;i<n1;++i) pq.push(6-nums1[i]);\\n           \\n        }\\n\\n        while(pq.top() > 0)\\n        {\\n            if(req <= 0) break;\\n\\n            int top = pq.top();\\n            pq.pop();\\n            req -= top;\\n            cnt++;  \\n        }\\n\\n        if(req > 0) return -1;\\n\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n1 = nums1.size();\\n        int n2 = nums2.size(); \\n        \\n        int sum1 = accumulate(nums1.begin(),nums1.end(),0);\\n        int sum2 = accumulate(nums2.begin(),nums2.end(),0); \\n\\n        priority_queue<int>pq;\\n\\n        int req = abs(sum1-sum2);\\n        int cnt = 0;\\n\\n        if(sum1>sum2)\\n        {\\n           for(int i = 0;i<n1;++i) pq.push(nums1[i]-1);\\n        \\n           for(int i = 0;i<n2;++i) pq.push(6-nums2[i]);\\n    \\n        }\\n\\n        else\\n        {\\n           for(int i = 0;i<n2;++i) pq.push(nums2[i]-1);\\n           \\n           for(int i = 0;i<n1;++i) pq.push(6-nums1[i]);\\n           \\n        }\\n\\n        while(pq.top() > 0)\\n        {\\n            if(req <= 0) break;\\n\\n            int top = pq.top();\\n            pq.pop();\\n            req -= top;\\n            cnt++;  \\n        }\\n\\n        if(req > 0) return -1;\\n\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085918,
                "title": "java-greedy-priorityqueue-solution-easiest-to-understand",
                "content": "The first thing to notice about this question is that it is a greedy question.\\n\\nGiven two array\\nnums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2] \\nWe are trying to make their difference bewteen them become 0.\\nLet\\'s consider the case that the sum of first array is always bigger than the secon one.\\nThen, we would decrease the number in the first array and increase numbers in the second array to achieve our goal.\\n\\n**Greedy : Decrease all element in the first array to 1 and Increase all element in the second array to 6.**\\n\\nWe could see the array as this way\\n```\\n\\tnums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2] \\ndecrease = [0,1,2,3,4,5],  increase = [5,5,4,4,4]\\n```\\n*This means that the first index 1 is possible to decrease 0 in the first array.\\nThis means that the second index 2 is possible to decrease 1 in the first array.\\nThis means that the third index 3 is possible to decrease 2 in the first array.\\n...\\n....\\nthe first index 1 is possible to increase 5 in the second array.\\nthe second index 1 is possible to increase 5 in the first array.*\\n \\n We would like to get the biggest number in each iteration because we want to make their difference bewteen them become 0.\\n For this example, we would like to choose 5 in either the last index of the first array, the first index of second array or in the second index of the second array.\\n \\n```\\n nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]  \\n```\\nPreviously, sumA = 21, sumB = 10, diff=11\\nIf we choose the last index of the first array, we would get sumA = 16, sumB = 10, diff=6\\nNotice that we only need to choose the element that give the maximum difference in each iteration.\\nThus, we could use a max priorityQueue to store those information.\\nThen, we would repeately choose the biggest number in the priorityQueue until the difference is smaller than 0.\\n```\\nclass Solution {\\n    public int minOperations(int[] a, int[] b) {\\n        int sumA=0, sumB=0;\\n        for(int i: a) sumA+=i;\\n        for(int i: b) sumB+=i;\\n        //exchange if sumA < sumB\\n        //We want to ensure that the first array sum is bigger than the smaller\\n        if(sumA < sumB){\\n            int[] tmp = a;\\n            a = b;\\n            b = tmp;\\n            int tmp2 = sumA;\\n            sumA = sumB;\\n            sumB = tmp2;\\n        }\\n        \\n        //edge case for returning -1\\n        if(a.length > b.length * 6) return -1;\\n        \\n        //create a max pq to find the max change that I can make in each iteration\\n        Queue<Integer> pq = new PriorityQueue<Integer>((a1,b1)-> b1 - a1);\\n        for(int i=0; i<a.length; i++) pq.add(a[i] - 1);\\n        for(int i=0; i<b.length; i++) pq.add(6 - b[i]);\\n        \\n        int diff = sumA - sumB;\\n        int count = 0;\\n        while(diff > 0){\\n                int pop =pq.poll();\\n                diff -= pop;\\n                count++;\\n            }\\n        return count;\\n    }\\n}\\n```\\nn stands for number of element in the array\\nTime Complexity = `O(nlogn)` \\nSpace Complexity = `O(N)`\\n\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n\\tnums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2] \\ndecrease = [0,1,2,3,4,5],  increase = [5,5,4,4,4]\\n```\n```\\n nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]  \\n```\n```\\nclass Solution {\\n    public int minOperations(int[] a, int[] b) {\\n        int sumA=0, sumB=0;\\n        for(int i: a) sumA+=i;\\n        for(int i: b) sumB+=i;\\n        //exchange if sumA < sumB\\n        //We want to ensure that the first array sum is bigger than the smaller\\n        if(sumA < sumB){\\n            int[] tmp = a;\\n            a = b;\\n            b = tmp;\\n            int tmp2 = sumA;\\n            sumA = sumB;\\n            sumB = tmp2;\\n        }\\n        \\n        //edge case for returning -1\\n        if(a.length > b.length * 6) return -1;\\n        \\n        //create a max pq to find the max change that I can make in each iteration\\n        Queue<Integer> pq = new PriorityQueue<Integer>((a1,b1)-> b1 - a1);\\n        for(int i=0; i<a.length; i++) pq.add(a[i] - 1);\\n        for(int i=0; i<b.length; i++) pq.add(6 - b[i]);\\n        \\n        int diff = sumA - sumB;\\n        int count = 0;\\n        while(diff > 0){\\n                int pop =pq.poll();\\n                diff -= pop;\\n                count++;\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085795,
                "title": "python-binary-search",
                "content": "Given a number of `moves` we want to check if we can equate the sums with at most this number of moves. Let `nums1` be the array with larger sum (rearrange if not). The best choice is to replace the largest elements of `nums1` with 1 and the smallest elements of `nums2` with 6. We can distribute `moves` between `nums1` and `nums2`. The `check` function below implements that. The rest is handled in binary search.\\n\\n**About check function:** Let\\'s say the arrays are `nums1 = [1 6 6]` and `nums2 = [2 2]` and you have `moves=2`. How many different ways can you change the sums of nums1 and nums2? You can use all your moves on nums1, so it can go as low as `[1 1 1]`. Or with nums2 it can go as high as `[6 6]`. Alternatively you can distribute moves between the two. You can get `[1 1 6]` and `[2 6]`. You can see that this choice is not trivial. If you allocate all your moves to `nums2` you can\\'t reach to the sum of `nums1`; but in the other two cases you can. The check function scans for all possible allocations given moves. \\n\\n**Illustration:** Shown below. Note that this is for `moves=3`.\\n\\n![image](https://assets.leetcode.com/users/images/57a68e29-5234-47bb-870f-aa779b893fe1_1614491616.7407281.png)\\n\\n```python\\nclass Solution:\\n    def minOperations(self, nums1, nums2):\\n        #if this holds, sums cannot be equated\\n        if max(len(nums1), len(nums2)) > 6*min(len(nums1), len(nums2)): \\n            return -1\\n        \\n        #nums1 will always be the array with larger sum\\n        if sum(nums1) < sum(nums2):\\n            nums1, nums2 = nums2, nums1\\n        \\n        #prefix sums\\n        prefix1 = list(itertools.accumulate(sorted(nums1), func=operator.add, initial = 0))\\n        prefix2 = list(itertools.accumulate(sorted(nums2), func=operator.add, initial = 0))\\n        \\n        #check if sum can be achieved with moves\\n        def check(moves):\\n            left, right = 0, moves\\n            while right >= 0:\\n                #try to allocate left amount of moves to first array\\n                left_sum = prefix1[-1]\\n                if left>0:\\n                    l = min(len(prefix1)-1, left)\\n                    #this is how much left sum decreases when you set highest l elements to 1\\n                    left_sum = left_sum - (prefix1[-1] - prefix1[-1-l] - l)\\n                #allocate the rest to right array\\n                right_sum = prefix2[-1]\\n                if right>0:\\n                    r = min(len(prefix2)-1, right)\\n                    #this is how much right sum increases when you set lowest r elements to 6\\n                    right_sum = right_sum + (6*r - prefix2[r])\\n                if left_sum <= right_sum:\\n                    return True\\n                left, right = left+1, right-1\\n            return False\\n        \\n        #binary search\\n        lo, hi = 0, len(nums1)+len(nums2)\\n        while lo < hi:\\n            mi = lo + hi >> 1\\n            if check(mi):\\n                hi = mi\\n            else:\\n                lo = mi+1\\n        return lo\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, nums1, nums2):\\n        #if this holds, sums cannot be equated\\n        if max(len(nums1), len(nums2)) > 6*min(len(nums1), len(nums2)): \\n            return -1\\n        \\n        #nums1 will always be the array with larger sum\\n        if sum(nums1) < sum(nums2):\\n            nums1, nums2 = nums2, nums1\\n        \\n        #prefix sums\\n        prefix1 = list(itertools.accumulate(sorted(nums1), func=operator.add, initial = 0))\\n        prefix2 = list(itertools.accumulate(sorted(nums2), func=operator.add, initial = 0))\\n        \\n        #check if sum can be achieved with moves\\n        def check(moves):\\n            left, right = 0, moves\\n            while right >= 0:\\n                #try to allocate left amount of moves to first array\\n                left_sum = prefix1[-1]\\n                if left>0:\\n                    l = min(len(prefix1)-1, left)\\n                    #this is how much left sum decreases when you set highest l elements to 1\\n                    left_sum = left_sum - (prefix1[-1] - prefix1[-1-l] - l)\\n                #allocate the rest to right array\\n                right_sum = prefix2[-1]\\n                if right>0:\\n                    r = min(len(prefix2)-1, right)\\n                    #this is how much right sum increases when you set lowest r elements to 6\\n                    right_sum = right_sum + (6*r - prefix2[r])\\n                if left_sum <= right_sum:\\n                    return True\\n                left, right = left+1, right-1\\n            return False\\n        \\n        #binary search\\n        lo, hi = 0, len(nums1)+len(nums2)\\n        while lo < hi:\\n            mi = lo + hi >> 1\\n            if check(mi):\\n                hi = mi\\n            else:\\n                lo = mi+1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735252,
                "title": "python-greedy-approach-explained-faster-than-82",
                "content": "Few Things to consider before approching to the solution:\\n1. We should always decrease the elements of an array having higher sum.\\n2. We should always increase the elements of an array having lower sum.\\n3. It\\'s always better to target the element having higher flexibility to change (Greedy). \\n\\n**What is element flexibility?** \\nElement flexibility is capability of stretching or shriking the value. \\nFor Example,\\nIf my number is 4, it has maximum stretchability of 2 (6-4) in the right direction.\\nand maximum shrikability of 3 (4-1) in the left direction.\\n1 <- 2 <- 3 <- *4* -> 5 -> 6\\nAs discussed above, we\\'ll go towards only one direction for a particular element.\\n\\n```\\nclass Solution:\\n\\t# This function takes the merged arrays and sort them according to the flexibilties of element.\\n\\t# No matter whether the element shrink or stretch, we are concerned about how much change they bring.\\n    def findNums(self, arr, val):\\n        arr = sorted(arr, reverse = True)\\n        count = 0\\n        flag = False\\n\\t\\t# Taking the highest number and reducing the difference\\n        for i in arr:\\n            if val >= i:\\n                val -= i\\n                count += 1\\n            elif val > 0:\\n                return count + 1\\n            if val == 0:\\n                return count\\n        return -1\\n        \\n    def minOperations(self, num1: List[int], num2: List[int]) -> int:\\n        s1, s2 = sum(num1), sum(num2)\\n        # difference to cover\\n\\t\\tdiff = abs(s1-s2)\\n        if s1 == s2:\\n            return 0\\n\\t\\t# we define flexibilities of each item in one direction.\\n        if s1 > s2: \\n            cnum1 = [i-1 for i in num1]\\n            cnum2 = [6-i for i in num2]\\n        else:\\n            cnum1 = [6-i for i in num1]\\n            cnum2 = [i-1 for i in num2]\\n        return self.findNums(cnum1 + cnum2, diff)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n\\t# This function takes the merged arrays and sort them according to the flexibilties of element.\\n\\t# No matter whether the element shrink or stretch, we are concerned about how much change they bring.\\n    def findNums(self, arr, val):\\n        arr = sorted(arr, reverse = True)\\n        count = 0\\n        flag = False\\n\\t\\t# Taking the highest number and reducing the difference\\n        for i in arr:\\n            if val >= i:\\n                val -= i\\n                count += 1\\n            elif val > 0:\\n                return count + 1\\n            if val == 0:\\n                return count\\n        return -1\\n        \\n    def minOperations(self, num1: List[int], num2: List[int]) -> int:\\n        s1, s2 = sum(num1), sum(num2)\\n        # difference to cover\\n\\t\\tdiff = abs(s1-s2)\\n        if s1 == s2:\\n            return 0\\n\\t\\t# we define flexibilities of each item in one direction.\\n        if s1 > s2: \\n            cnum1 = [i-1 for i in num1]\\n            cnum2 = [6-i for i in num2]\\n        else:\\n            cnum1 = [6-i for i in num1]\\n            cnum2 = [i-1 for i in num2]\\n        return self.findNums(cnum1 + cnum2, diff)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416208,
                "title": "c-sorting-greedy-with-thinking-proccess",
                "content": "```\\n/**\\n * @brief \\n * Given two array, return the minimum numbers we have to change the values to make two arrays sum equal\\n * \\n * [Observation]\\n * Since the value is from 1 ~ 6\\n * \\n * Min sum of the array = len(arr)\\n * Max sum of the array = 6 len(arr) \\n * \\n * When to arrays range cannot overlap -> no answer \\n * \\n * If there is a answer -> sum s, value will be between s1 and s2\\n * So, let\\'s say if s1 is smaller, we would like to increase s1\\'s element and decrease s2\\'s element\\n * -> We only have to design for s1 is smaller than s2.\\n * \\n * [Key] Which element\\'s should we increase and decrease? \\n * To minimize the changing elements, we change the number who can mostly decrease the differences.\\n * So, we compare the smallest element in num1 and largest in num2.  \\n * -> sorting\\n * \\n * @algo sorting + greedy\\n * Time O(NlogN) for sorting\\n * Space O(1)\\n */\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int l1 = nums1.size(); // l1 ~ 6l1\\n        int l2 = nums2.size(); // l2 ~ 6l2\\n\\n        if(6*l1 < l2 || 6*l2 < l1) {\\n            return -1;\\n        }\\n        \\n        int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n        int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n        if(sum1 > sum2) return minOperations(nums2, nums1);\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end(), greater<int>());\\n        // let us design the way where sum1 <= sum2\\n        int ans = 0, ptr1 = 0, ptr2 = 0; \\n        int diff = sum2 - sum1;\\n\\n        while(diff > 0) {\\n            if(ptr2 == l2 || ptr1 < l1 && (6 - nums1[ptr1]) >= (nums2[ptr2] - 1)) {\\n                diff -= (6 - nums1[ptr1]);\\n                ans++;\\n                ptr1++;\\n            }\\n            else {\\n                diff -= (nums2[ptr2] - 1);\\n                ans++;\\n                ptr2++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @brief \\n * Given two array, return the minimum numbers we have to change the values to make two arrays sum equal\\n * \\n * [Observation]\\n * Since the value is from 1 ~ 6\\n * \\n * Min sum of the array = len(arr)\\n * Max sum of the array = 6 len(arr) \\n * \\n * When to arrays range cannot overlap -> no answer \\n * \\n * If there is a answer -> sum s, value will be between s1 and s2\\n * So, let\\'s say if s1 is smaller, we would like to increase s1\\'s element and decrease s2\\'s element\\n * -> We only have to design for s1 is smaller than s2.\\n * \\n * [Key] Which element\\'s should we increase and decrease? \\n * To minimize the changing elements, we change the number who can mostly decrease the differences.\\n * So, we compare the smallest element in num1 and largest in num2.  \\n * -> sorting\\n * \\n * @algo sorting + greedy\\n * Time O(NlogN) for sorting\\n * Space O(1)\\n */\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int l1 = nums1.size(); // l1 ~ 6l1\\n        int l2 = nums2.size(); // l2 ~ 6l2\\n\\n        if(6*l1 < l2 || 6*l2 < l1) {\\n            return -1;\\n        }\\n        \\n        int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n        int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n        if(sum1 > sum2) return minOperations(nums2, nums1);\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end(), greater<int>());\\n        // let us design the way where sum1 <= sum2\\n        int ans = 0, ptr1 = 0, ptr2 = 0; \\n        int diff = sum2 - sum1;\\n\\n        while(diff > 0) {\\n            if(ptr2 == l2 || ptr1 < l1 && (6 - nums1[ptr1]) >= (nums2[ptr2] - 1)) {\\n                diff -= (6 - nums1[ptr1]);\\n                ans++;\\n                ptr1++;\\n            }\\n            else {\\n                diff -= (nums2[ptr2] - 1);\\n                ans++;\\n                ptr2++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1093677,
                "title": "easy-c-solution",
                "content": "**Idea** :- We can either increase the smaller array upto 5 or decrease the larger array upto 5 per move.\\n\\neg:-\\n\\n\\tif we have the array like -\\n\\tnums1 = [1,2,5,3]\\n\\tnums2 = [2,6,4]\\n\\t(since sum_nums1 > sum_nums2 -> nums1 is larger than nums2)\\n\\t\\n\\tIncrease possible is - [5,4,1,3] for nums1 (if all increased to 6)\\n\\tdecrease possible is - [1,4,3] for nums2   (if all decreased to 1)\\n\\t\\nwe get all the possible values of increase/decrease and store their count in a map.\\nNow from the biggest to the smallest value available in the map we reduce the difference and get the number of operations\\n\\n```\\nint minOperations(vector<int>& nums1, vector<int>& nums2) {\\n\\n\\t\\t// If sum of all numbers in an array increased to 6 is less than the sum of the other array with all numbers decreased to 1\\'s then its impossible\\n        if(6 * nums1.size() < 1 * nums2.size() || 6 * nums2.size() < 1 * nums1.size())\\n            return -1;\\n        int sum=0,curr=0,ans=0,j=5,diff;\\n        for(auto it : nums2)  sum+=it;\\n        for(auto it : nums1)  curr+=it;\\n\\t\\t//to maintain the fact that nums1 is the larger array\\n        if(sum > curr)\\n            swap(nums1,nums2);\\n\\t\\tdiff = abs(curr-sum);\\n        map<int,int> mp;\\n\\t\\t//map to store the possible increase/decrease values\\n        for(auto it : nums1) mp[it-1]++;\\n        for(auto it: nums2)  mp[6-it]++;\\n\\t\\t\\n        while(diff>0)\\n        {\\n\\t\\t\\t//get number of the operations required for this particular value\\n            int ops = min(mp[j],(int)ceil(diff*1.0/j*1.0));\\n            ans+=ops;\\n            diff-=j*ops;\\n            if(diff<=0)\\n                return ans;\\n            j--;\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nint minOperations(vector<int>& nums1, vector<int>& nums2) {\\n\\n\\t\\t// If sum of all numbers in an array increased to 6 is less than the sum of the other array with all numbers decreased to 1\\'s then its impossible\\n        if(6 * nums1.size() < 1 * nums2.size() || 6 * nums2.size() < 1 * nums1.size())\\n            return -1;\\n        int sum=0,curr=0,ans=0,j=5,diff;\\n        for(auto it : nums2)  sum+=it;\\n        for(auto it : nums1)  curr+=it;\\n\\t\\t//to maintain the fact that nums1 is the larger array\\n        if(sum > curr)\\n            swap(nums1,nums2);\\n\\t\\tdiff = abs(curr-sum);\\n        map<int,int> mp;\\n\\t\\t//map to store the possible increase/decrease values\\n        for(auto it : nums1) mp[it-1]++;\\n        for(auto it: nums2)  mp[6-it]++;\\n\\t\\t\\n        while(diff>0)\\n        {\\n\\t\\t\\t//get number of the operations required for this particular value\\n            int ops = min(mp[j],(int)ceil(diff*1.0/j*1.0));\\n            ans+=ops;\\n            diff-=j*ops;\\n            if(diff<=0)\\n                return ans;\\n            j--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1085847,
                "title": "python-3-simple-greedy-solution",
                "content": "let me try to explain this as best as i can. the minium amount of changes necessary would be when the sum of each list equals the other, if one list is less than the other, we can greedily modify all the 1s in the smaller list and all the 6s in the larger array. the other observation is that if there is any 1s those 1s can be changed to values 2-6, likewise 6s can be changed to values 1-5, now apply this to all other numbers.\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        M = len(nums2)\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if N > 6*M or M > 6*N:\\n            return -1\\n        elif s1 == s2:\\n            return 0\\n        else:\\n            c1 = collections.Counter(nums1)\\n            c2 = collections.Counter(nums2)\\n            if s2 > s1:\\n                s1, s2 = s2, s1\\n                c1, c2 = c2, c1\\n            res = 0\\n            dif = abs(s1-s2)\\n            for i in range(6):\\n                ct = c1[6-i] + c2[1+i]\\n                val = 5-i\\n                if val*ct < dif:\\n                    dif -= val*ct\\n                    res += ct\\n                elif val*ct >= dif:\\n                    ct = math.ceil(dif/val)\\n                    dif -= val*ct\\n                    res += ct\\n                if dif <= 0:\\n                    return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        M = len(nums2)\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if N > 6*M or M > 6*N:\\n            return -1\\n        elif s1 == s2:\\n            return 0\\n        else:\\n            c1 = collections.Counter(nums1)\\n            c2 = collections.Counter(nums2)\\n            if s2 > s1:\\n                s1, s2 = s2, s1\\n                c1, c2 = c2, c1\\n            res = 0\\n            dif = abs(s1-s2)\\n            for i in range(6):\\n                ct = c1[6-i] + c2[1+i]\\n                val = 5-i\\n                if val*ct < dif:\\n                    dif -= val*ct\\n                    res += ct\\n                elif val*ct >= dif:\\n                    ct = math.ceil(dif/val)\\n                    dif -= val*ct\\n                    res += ct\\n                if dif <= 0:\\n                    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235526,
                "title": "java-clean-o-n-solution",
                "content": "\\n```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int m = nums1.length, n = nums2.length;\\n        if (m > 6 * n || n > 6 * m) return -1;\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i : nums1) sum1 += i;\\n        for (int i : nums2) sum2 += i;\\n        \\n        int diff = sum1 - sum2;\\n        if (diff == 0) return 0;\\n        \\n        return (diff > 0 ? helper(nums1, nums2, diff) \\n                         : helper(nums2, nums1, -diff));\\n    }\\n    \\n    private int helper(int[] nums1, int[] nums2, int diff) {\\n        // count[i] : frequency of numbers that can reduce the diff by i\\n        int[] count = new int[6];\\n        for (int num : nums1) count[num - 1]++;\\n        for (int num : nums2) count[6 - num]++;\\n        \\n        int res = 0;\\n        for (int i = 5; i > 0; i--) {\\n            int c = Math.min(count[i], diff / i + (diff % i == 0 ? 0 : 1));\\n            \\n            res += c;\\n            diff -= c * i;\\n            \\n            if (diff <= 0) break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int m = nums1.length, n = nums2.length;\\n        if (m > 6 * n || n > 6 * m) return -1;\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i : nums1) sum1 += i;\\n        for (int i : nums2) sum2 += i;\\n        \\n        int diff = sum1 - sum2;\\n        if (diff == 0) return 0;\\n        \\n        return (diff > 0 ? helper(nums1, nums2, diff) \\n                         : helper(nums2, nums1, -diff));\\n    }\\n    \\n    private int helper(int[] nums1, int[] nums2, int diff) {\\n        // count[i] : frequency of numbers that can reduce the diff by i\\n        int[] count = new int[6];\\n        for (int num : nums1) count[num - 1]++;\\n        for (int num : nums2) count[6 - num]++;\\n        \\n        int res = 0;\\n        for (int i = 5; i > 0; i--) {\\n            int c = Math.min(count[i], diff / i + (diff % i == 0 ? 0 : 1));\\n            \\n            res += c;\\n            diff -= c * i;\\n            \\n            if (diff <= 0) break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410593,
                "title": "c-o-n-solution-commented-code-explained-greedy-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy + Math \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Count the frequency of each element from 1->6 in both vectors.\\n```\\n    vector<int> cnt1 ( 6, 0);\\n    vector<int> cnt2 ( 6, 0);\\n//counting the number of occureneces of 1->6 in both vectors\\n        for(auto i : nums1) cnt1[i-1]++;\\n        for(auto i : nums2) cnt2[i-1]++;\\n\\n```\\n2. Now, one with smaller sum willbe increased & other will be decreased.\\n\\n        if(s1>s2)   res= equate(nums1,nums2,s1-s2);\\n        if(s2>s1)   res= equate(nums2,nums1,s2-s1);\\n\\n3. Impacts +>\\n`6 -> 0 for increasing & 6 -> 5 for decreasing`\\n`5 -> 1 for increasing & 5 -> 4 for decreasing`\\n`4 -> 2 for increasing & 4 -> 3 for decreasing`\\n`3 -> 3 for increasing & 3 -> 2 for decreasing`\\n`2 -> 4 for increasing & 2 -> 1 for decreasing`\\n`1 -> 5 for increasing & 1 -> 0 for decreasing`\\n\\n4. Now , using the count vectors cnt1 & cnt2 , Apply two pointer approach for reaching the target Sum .\\nFirst evaluate the net possible change with current low & high index =>\\n\\n```\\nint impact_high = high;\\nint impact_low = 5-low; \\n\\nint count_high = cnt1[high];\\nint count_low = cnt2[low];\\n\\n//evaluating the maximum possible impact for current low & high\\nint net_max_impact =(impact_high*count_high) + (impact_low*count_low);\\n```\\n\\n5. Conisdering the following conditions :-\\n   \\n```\\nif(net_max_impact < target) {\\n        target -= net_max_impact;\\n        count += (count_high + count_low);\\n        low++;\\n        high--`\\n    }\\n\\nelse if(net_max_impact == target)   {\\n    count += (count_high + count_low);\\n    break;\\n}\\n//edge case when the result does NOT completely uses current low & high\\nelse {\\n    count += util(impact_high,count_high,impact_low,count_low,target);\\n    break;\\n}\\n```\\n\\n6. An extra function is used to evalute the minimum number of changes for the edge case . \\n\\n![download (1).jfif](https://assets.leetcode.com/users/images/0c50b9c4-c47b-4bf2-a5ce-92e18d67747d_1681344080.268401.jpeg)\\n\\n\\n# Complexity\\n- Time complexity   :   O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity  :   O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //second helping function : return minimum changes required in edge case. \\n    int util(int ih, int ch, int il, int cl, int t)    {\\n        int count = 0;\\n\\n        if(ih<il)   {\\n            return util(il,cl,ih,ch,t);\\n        }\\n\\n        if(t>ih*ch) {\\n            count += ch;\\n            int nt =  t-(ih*ch);\\n            count += (nt/il);\\n            if(nt%il != 0)\\n                count ++;\\n        }\\n        else {\\n            count += (t/ih);\\n            if(t%ih != 0)\\n                count ++;\\n        }\\n\\n        return count;\\n    }\\n\\n\\n    //main helping function : equates the minimum possible changes \\n    int equate(vector<int> nums1, vector<int>& nums2, int target) {\\n        vector<int> cnt1 ( 6, 0);\\n        vector<int> cnt2 ( 6, 0);\\n\\n        //counting the number of occureneces of 1->6 in both vectors\\n        for(auto i : nums1) cnt1[i-1]++;\\n        for(auto i : nums2) cnt2[i-1]++;\\n\\n        int low = 0, high = 5;\\n        int count = 0;\\n\\n        //using a two pointer approach to make the sums equal\\n        while(target>0 && low<6 && high>-1)    {\\n            int impact_high = high;\\n            int impact_low = 5-low;\\n\\n            int count_high = cnt1[high];\\n            int count_low = cnt2[low];\\n\\n            //evaluating the maximum possible impact for current low & high\\n            int net_max_impact = (impact_high*count_high) + (impact_low*count_low);\\n\\n            if(net_max_impact < target) {\\n                target -= net_max_impact;\\n                count += (count_high + count_low);\\n                low++;\\n                high--;\\n            }\\n            else if(net_max_impact == target)   {\\n                count += (count_high + count_low);\\n                break;\\n            }\\n            //edge case when the result does NOT completely uses current low & high\\n            else {\\n                count += util(impact_high,count_high,impact_low,count_low,target);\\n                break;\\n            }\\n        }\\n\\n        return count;        \\n    }\\n\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n\\n        //case for not possible \\n        if(max(n1,n2) > min(n1,n2)*6)\\n            return -1;\\n\\n        int s1=0,s2=0;\\n        int res = 0;\\n        for(auto i : nums1) s1+=i;\\n        for(auto i : nums2) s2+=i;\\n\\n        if(s1==s2)\\n            return res;\\n\\n        int s = (s1+s2)/2;\\n\\n        if(s1>s2)   res= equate(nums1,nums2,s1-s2);\\n        if(s2>s1)   res= equate(nums2,nums1,s2-s1);\\n\\n        return res;\\n    }\\n};\\n```\\n\\n![download (2).jfif](https://assets.leetcode.com/users/images/fe8aa0ad-7dca-4db5-a7ca-6b7b4e8e5a57_1681344090.8417618.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\n    vector<int> cnt1 ( 6, 0);\\n    vector<int> cnt2 ( 6, 0);\\n//counting the number of occureneces of 1->6 in both vectors\\n        for(auto i : nums1) cnt1[i-1]++;\\n        for(auto i : nums2) cnt2[i-1]++;\\n\\n```\n```\\nint impact_high = high;\\nint impact_low = 5-low; \\n\\nint count_high = cnt1[high];\\nint count_low = cnt2[low];\\n\\n//evaluating the maximum possible impact for current low & high\\nint net_max_impact =(impact_high*count_high) + (impact_low*count_low);\\n```\n```\\nif(net_max_impact < target) {\\n        target -= net_max_impact;\\n        count += (count_high + count_low);\\n        low++;\\n        high--`\\n    }\\n\\nelse if(net_max_impact == target)   {\\n    count += (count_high + count_low);\\n    break;\\n}\\n//edge case when the result does NOT completely uses current low & high\\nelse {\\n    count += util(impact_high,count_high,impact_low,count_low,target);\\n    break;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    //second helping function : return minimum changes required in edge case. \\n    int util(int ih, int ch, int il, int cl, int t)    {\\n        int count = 0;\\n\\n        if(ih<il)   {\\n            return util(il,cl,ih,ch,t);\\n        }\\n\\n        if(t>ih*ch) {\\n            count += ch;\\n            int nt =  t-(ih*ch);\\n            count += (nt/il);\\n            if(nt%il != 0)\\n                count ++;\\n        }\\n        else {\\n            count += (t/ih);\\n            if(t%ih != 0)\\n                count ++;\\n        }\\n\\n        return count;\\n    }\\n\\n\\n    //main helping function : equates the minimum possible changes \\n    int equate(vector<int> nums1, vector<int>& nums2, int target) {\\n        vector<int> cnt1 ( 6, 0);\\n        vector<int> cnt2 ( 6, 0);\\n\\n        //counting the number of occureneces of 1->6 in both vectors\\n        for(auto i : nums1) cnt1[i-1]++;\\n        for(auto i : nums2) cnt2[i-1]++;\\n\\n        int low = 0, high = 5;\\n        int count = 0;\\n\\n        //using a two pointer approach to make the sums equal\\n        while(target>0 && low<6 && high>-1)    {\\n            int impact_high = high;\\n            int impact_low = 5-low;\\n\\n            int count_high = cnt1[high];\\n            int count_low = cnt2[low];\\n\\n            //evaluating the maximum possible impact for current low & high\\n            int net_max_impact = (impact_high*count_high) + (impact_low*count_low);\\n\\n            if(net_max_impact < target) {\\n                target -= net_max_impact;\\n                count += (count_high + count_low);\\n                low++;\\n                high--;\\n            }\\n            else if(net_max_impact == target)   {\\n                count += (count_high + count_low);\\n                break;\\n            }\\n            //edge case when the result does NOT completely uses current low & high\\n            else {\\n                count += util(impact_high,count_high,impact_low,count_low,target);\\n                break;\\n            }\\n        }\\n\\n        return count;        \\n    }\\n\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n\\n        //case for not possible \\n        if(max(n1,n2) > min(n1,n2)*6)\\n            return -1;\\n\\n        int s1=0,s2=0;\\n        int res = 0;\\n        for(auto i : nums1) s1+=i;\\n        for(auto i : nums2) s2+=i;\\n\\n        if(s1==s2)\\n            return res;\\n\\n        int s = (s1+s2)/2;\\n\\n        if(s1>s2)   res= equate(nums1,nums2,s1-s2);\\n        if(s2>s1)   res= equate(nums2,nums1,s2-s1);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641936,
                "title": "faster-easy-to-understand-c-code",
                "content": "# *Intuition*\\nApply greedy approach and try to make diff between two sum equal to 0.\\n\\n# *Approach*\\nUsing Max. Heap and Greedy Approach\\n\\n# *Complexity*\\n- *Time complexity :- O(NlogN)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- *Space complexity :- O(N)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n1 = nums1.size();\\n\\n        int n2 = nums2.size();\\n\\n        // find the sum of nums1\\n\\n        int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n\\n        // find the sum of nums2\\n\\n        int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n\\n        // declare a max heap\\n\\n        priority_queue<int> pq;\\n\\n        // case 1 :- if sum1 > sum2 \\n\\n        // we have to check maximum decrement for each element of nums1\\n\\n        // we have to check maximum increment for each element of nums2\\n\\n        if(sum1 > sum2)\\n        {\\n            // find max. decrement for each element of nums1 and push into pq\\n\\n            for(int i = 0; i < n1; i++)\\n            {\\n                pq.push(nums1[i] - 1);\\n            }\\n\\n            // find max. increment for each element of nums2 and push into pq\\n\\n            for(int i = 0; i < n2; i++)\\n            {\\n                pq.push(6 - nums2[i]);\\n            }\\n        }\\n\\n        // case 2 :- if sum1 < sum2 \\n\\n        // we have to check maximum decrement for each element of nums2\\n\\n        // we have to check maximum increment for each element of nums1\\n\\n        else\\n        {\\n            // find max. increment for each element of nums1 and push into pq\\n\\n            for(int i = 0; i < n1; i++)\\n            {\\n                pq.push(6 - nums1[i]);\\n            }\\n\\n            // find the max. decrement for each element of nums2 and push into pq\\n\\n            for(int i = 0; i < n2; i++)\\n            {\\n                pq.push(nums2[i] - 1);\\n            }\\n        }\\n\\n        int diff = abs(sum1 - sum2);\\n\\n        int count = 0;\\n\\n        // now run the loop while diff becomes 0\\n\\n        while(diff > 0 && pq.size())\\n        {\\n            int top = pq.top();\\n\\n            pq.pop();\\n\\n            // update diff\\n\\n            diff -= min(diff, top);\\n\\n            // increment operation\\n\\n            count++;\\n        }\\n\\n        if(diff > 0)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return count;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n1 = nums1.size();\\n\\n        int n2 = nums2.size();\\n\\n        // find the sum of nums1\\n\\n        int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n\\n        // find the sum of nums2\\n\\n        int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n\\n        // declare a max heap\\n\\n        priority_queue<int> pq;\\n\\n        // case 1 :- if sum1 > sum2 \\n\\n        // we have to check maximum decrement for each element of nums1\\n\\n        // we have to check maximum increment for each element of nums2\\n\\n        if(sum1 > sum2)\\n        {\\n            // find max. decrement for each element of nums1 and push into pq\\n\\n            for(int i = 0; i < n1; i++)\\n            {\\n                pq.push(nums1[i] - 1);\\n            }\\n\\n            // find max. increment for each element of nums2 and push into pq\\n\\n            for(int i = 0; i < n2; i++)\\n            {\\n                pq.push(6 - nums2[i]);\\n            }\\n        }\\n\\n        // case 2 :- if sum1 < sum2 \\n\\n        // we have to check maximum decrement for each element of nums2\\n\\n        // we have to check maximum increment for each element of nums1\\n\\n        else\\n        {\\n            // find max. increment for each element of nums1 and push into pq\\n\\n            for(int i = 0; i < n1; i++)\\n            {\\n                pq.push(6 - nums1[i]);\\n            }\\n\\n            // find the max. decrement for each element of nums2 and push into pq\\n\\n            for(int i = 0; i < n2; i++)\\n            {\\n                pq.push(nums2[i] - 1);\\n            }\\n        }\\n\\n        int diff = abs(sum1 - sum2);\\n\\n        int count = 0;\\n\\n        // now run the loop while diff becomes 0\\n\\n        while(diff > 0 && pq.size())\\n        {\\n            int top = pq.top();\\n\\n            pq.pop();\\n\\n            // update diff\\n\\n            diff -= min(diff, top);\\n\\n            // increment operation\\n\\n            count++;\\n        }\\n\\n        if(diff > 0)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return count;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911534,
                "title": "c-hindi-variable-names-beats-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int chota_sum,vector<int> &chota_array,int bada_sum,vector<int> &bada_array)\\n    {\\n        int i = bada_array.size()-1;\\n        int j = 0;\\n        int count = 0;\\n        while(true)\\n        {\\n            if(bada_sum<=chota_sum)\\n            {\\n                break;\\n            }\\n            int chota_change = -1;\\n            int bada_change = -1;\\n\\n            if(i>=0)\\n            {\\n                bada_change = (bada_array[i]-1);\\n            }\\n            if(j<chota_array.size())\\n            {\\n                chota_change = (6-chota_array[j]);\\n            }\\n            if(bada_change>=chota_change)\\n            {\\n                bada_sum-=bada_change;\\n                i--;\\n                count++;\\n            }\\n            else\\n            {\\n                chota_sum+=chota_change;\\n                j++;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int nums1mn = nums1.size();\\n        int nums1mx = nums1.size()*6;\\n        int nums2mn = nums2.size();\\n        int nums2mx = 6*nums2.size();\\n\\n        if(nums1mn<=nums2mn)\\n        {\\n            if(nums1mx<nums2mn)\\n            return -1;\\n        }\\n        else\\n        {\\n            if(nums2mx<nums1mn)\\n            return -1;\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for(int i=0;i<nums1.size();i++)sum1+=nums1[i];\\n        for(int i=0;i<nums2.size();i++)sum2+=nums2[i];\\n\\n        int chota_sum;\\n        int bada_sum;\\n\\n        chota_sum = min(sum1,sum2);\\n        bada_sum = max(sum1,sum2);\\n\\n        if(chota_sum==bada_sum)\\n        return 0;\\n\\n        if(chota_sum==sum1)\\n        {\\n            return solve(chota_sum,nums1,bada_sum,nums2);\\n        }\\n        else\\n        {\\n            return solve(chota_sum,nums2,bada_sum,nums1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int chota_sum,vector<int> &chota_array,int bada_sum,vector<int> &bada_array)\\n    {\\n        int i = bada_array.size()-1;\\n        int j = 0;\\n        int count = 0;\\n        while(true)\\n        {\\n            if(bada_sum<=chota_sum)\\n            {\\n                break;\\n            }\\n            int chota_change = -1;\\n            int bada_change = -1;\\n\\n            if(i>=0)\\n            {\\n                bada_change = (bada_array[i]-1);\\n            }\\n            if(j<chota_array.size())\\n            {\\n                chota_change = (6-chota_array[j]);\\n            }\\n            if(bada_change>=chota_change)\\n            {\\n                bada_sum-=bada_change;\\n                i--;\\n                count++;\\n            }\\n            else\\n            {\\n                chota_sum+=chota_change;\\n                j++;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int nums1mn = nums1.size();\\n        int nums1mx = nums1.size()*6;\\n        int nums2mn = nums2.size();\\n        int nums2mx = 6*nums2.size();\\n\\n        if(nums1mn<=nums2mn)\\n        {\\n            if(nums1mx<nums2mn)\\n            return -1;\\n        }\\n        else\\n        {\\n            if(nums2mx<nums1mn)\\n            return -1;\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for(int i=0;i<nums1.size();i++)sum1+=nums1[i];\\n        for(int i=0;i<nums2.size();i++)sum2+=nums2[i];\\n\\n        int chota_sum;\\n        int bada_sum;\\n\\n        chota_sum = min(sum1,sum2);\\n        bada_sum = max(sum1,sum2);\\n\\n        if(chota_sum==bada_sum)\\n        return 0;\\n\\n        if(chota_sum==sum1)\\n        {\\n            return solve(chota_sum,nums1,bada_sum,nums2);\\n        }\\n        else\\n        {\\n            return solve(chota_sum,nums2,bada_sum,nums1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458728,
                "title": "java-two-priority-qeueue-operations",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        \\n        if(nums1.length > nums2.length * 6 || nums2.length > nums1.length * 6) \\n\\t\\t    return -1;\\n        \\n        int operations = 0;\\n        int sum1 = IntStream.of(nums1).sum(); \\n        int sum2 = IntStream.of(nums2).sum();\\n\\n        if(sum1>sum2) \\n             return minOperations(nums2, nums1); // make sure the sum of 1st array <= sum of 2nd one.\\n\\n        PriorityQueue<Integer> minq = new PriorityQueue<>();\\n        PriorityQueue<Integer> maxq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for(int i:nums1) \\n            minq.offer(i);\\n\\n        for(int i:nums2) \\n            maxq.offer(i);\\n\\n        while(sum1 < sum2){\\n            if(maxq.isEmpty() || maxq.peek() - 1 < 6 - minq.peek())\\n                sum1 += 6 - minq.poll();\\n            else\\n                sum2 -= maxq.poll() - 1;\\n            operations++;\\n        }\\n\\n        return operations;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        \\n        if(nums1.length > nums2.length * 6 || nums2.length > nums1.length * 6) \\n\\t\\t    return -1;\\n        \\n        int operations = 0;\\n        int sum1 = IntStream.of(nums1).sum(); \\n        int sum2 = IntStream.of(nums2).sum();\\n\\n        if(sum1>sum2) \\n             return minOperations(nums2, nums1); // make sure the sum of 1st array <= sum of 2nd one.\\n\\n        PriorityQueue<Integer> minq = new PriorityQueue<>();\\n        PriorityQueue<Integer> maxq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for(int i:nums1) \\n            minq.offer(i);\\n\\n        for(int i:nums2) \\n            maxq.offer(i);\\n\\n        while(sum1 < sum2){\\n            if(maxq.isEmpty() || maxq.peek() - 1 < 6 - minq.peek())\\n                sum1 += 6 - minq.poll();\\n            else\\n                sum2 -= maxq.poll() - 1;\\n            operations++;\\n        }\\n\\n        return operations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987812,
                "title": "python-o-n-time-o-1-space-counting",
                "content": "Suppose sum(nums1) < sum(nums2).\\nCompare the difference of sums by changing all 1 -> 6 in num1 and 6->1 in num2, then 2->5 in num1 and 5->2 in num2 ... until difference == 0.\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if sum(nums1) > sum(nums2):\\n            nums1, nums2 = nums2, nums1\\n        c1, c2 = collections.Counter(nums1), collections.Counter(nums2)\\n        ans,  diff = 0, sum(nums2) - sum(nums1)\\n        if diff <= (c1[1] + c2[6]) * 5: return math.ceil(diff/5)\\n        ans, diff = ans + c1[1] + c2[6], diff - (c1[1] + c2[6]) * 5\\n        if diff <= (c1[2] + c2[5]) * 4: return ans + math.ceil(diff/4)\\n        ans, diff = ans + c1[2] + c2[5], diff - (c1[2] + c2[5]) * 4\\n        if diff <= (c1[3] + c2[4]) * 3: return ans + math.ceil(diff/3)\\n        ans, diff = ans + c1[3] + c2[4], diff - (c1[3] + c2[4]) * 3\\n        if diff <= (c1[4] + c2[3]) * 2: return ans + math.ceil(diff/2)\\n        ans, diff = ans + c1[4] + c2[3], diff - (c1[4] + c2[3]) * 2\\n        if diff <= c1[5] + c2[2]: return ans + diff\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if sum(nums1) > sum(nums2):\\n            nums1, nums2 = nums2, nums1\\n        c1, c2 = collections.Counter(nums1), collections.Counter(nums2)\\n        ans,  diff = 0, sum(nums2) - sum(nums1)\\n        if diff <= (c1[1] + c2[6]) * 5: return math.ceil(diff/5)\\n        ans, diff = ans + c1[1] + c2[6], diff - (c1[1] + c2[6]) * 5\\n        if diff <= (c1[2] + c2[5]) * 4: return ans + math.ceil(diff/4)\\n        ans, diff = ans + c1[2] + c2[5], diff - (c1[2] + c2[5]) * 4\\n        if diff <= (c1[3] + c2[4]) * 3: return ans + math.ceil(diff/3)\\n        ans, diff = ans + c1[3] + c2[4], diff - (c1[3] + c2[4]) * 3\\n        if diff <= (c1[4] + c2[3]) * 2: return ans + math.ceil(diff/2)\\n        ans, diff = ans + c1[4] + c2[3], diff - (c1[4] + c2[3]) * 2\\n        if diff <= c1[5] + c2[2]: return ans + diff\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824299,
                "title": "simple-solution-easy-to-understand-heaps",
                "content": "```\\n// Time Complexity:- O(nlogn + mlogm)\\n// Space Complexity:- O(n+m)\\nclass Solution {\\npublic:    \\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(),m = nums2.size();\\n        if(n>m){\\n            return minOperations(nums2,nums1);\\n        }\\n        if(n*6<m){\\n            return -1;\\n        }\\n        int sum1 = accumulate(nums1.begin(),nums1.end(),0);\\n        int sum2 = accumulate(nums2.begin(),nums2.end(),0);\\n        if(sum1>sum2){\\n            swap(sum1,sum2);\\n            swap(nums1,nums2);\\n        }\\n        int ans = 0,change = sum2-sum1;\\n        priority_queue<int> q2(nums2.begin(),nums2.end());\\n        priority_queue<int,vector<int>,greater<int>> q1(nums1.begin(),nums1.end());\\n    \\n        // first vector contains smaller sum\\n        while(change>0){\\n            int d1 = INT_MIN,d2 = INT_MIN;\\n            if(!q1.empty()){\\n                d1 = 6-q1.top();\\n            }\\n            if(!q2.empty()){\\n                d2 = q2.top()-1;\\n            }\\n            \\n            if(d1>d2){\\n                change-=d1;\\n                q1.pop();\\n            }\\n            else{\\n                change-=d2;\\n                q2.pop();\\n            }\\n            \\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Time Complexity:- O(nlogn + mlogm)\\n// Space Complexity:- O(n+m)\\nclass Solution {\\npublic:    \\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(),m = nums2.size();\\n        if(n>m){\\n            return minOperations(nums2,nums1);\\n        }\\n        if(n*6<m){\\n            return -1;\\n        }\\n        int sum1 = accumulate(nums1.begin(),nums1.end(),0);\\n        int sum2 = accumulate(nums2.begin(),nums2.end(),0);\\n        if(sum1>sum2){\\n            swap(sum1,sum2);\\n            swap(nums1,nums2);\\n        }\\n        int ans = 0,change = sum2-sum1;\\n        priority_queue<int> q2(nums2.begin(),nums2.end());\\n        priority_queue<int,vector<int>,greater<int>> q1(nums1.begin(),nums1.end());\\n    \\n        // first vector contains smaller sum\\n        while(change>0){\\n            int d1 = INT_MIN,d2 = INT_MIN;\\n            if(!q1.empty()){\\n                d1 = 6-q1.top();\\n            }\\n            if(!q2.empty()){\\n                d2 = q2.top()-1;\\n            }\\n            \\n            if(d1>d2){\\n                change-=d1;\\n                q1.pop();\\n            }\\n            else{\\n                change-=d2;\\n                q2.pop();\\n            }\\n            \\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233077,
                "title": "c-simple-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& arr0, vector<int>& arr1) {\\n        int s0 = 0, s1 = 0;\\n        \\n        for (auto i : arr0) s0 += i;\\n        for (auto i : arr1) s1 += i;\\n        \\n\\t\\t// Swap arrays so first is smaller (first always increments, second always decrements)\\n        if (s1 < s0) {\\n            std::swap(s0, s1);\\n            std::swap(arr0, arr1);\\n        }\\n        else if (s0 == s1)\\n            return 0;\\n        \\n        std::priority_queue<int> pq;\\n\\t\\t// Elements from the first array can decrease sum difference by 6 - x (increment to 6)\\n        for (int i = 0; i < arr0.size(); i++)\\n            if (arr0[i] < 6)\\n                pq.push(6 - arr0[i]);\\n\\t\\t// Elements from the second array can decrease sum difference by x - 1 (decrement to 1)\\n        for (int i = 0; i < arr1.size(); i++)\\n            if (arr1[i] > 1)\\n                pq.push(arr1[i] - 1);\\n        \\n        int ops = 0;\\n        int diff = s1 - s0;\\n        while (diff && pq.size()) {\\n            ++ops;\\n            \\n\\t\\t\\t// Take element with the largest capacity to increment/decrement\\n            auto p = pq.top();\\n            pq.pop();\\n            \\n\\t\\t\\t// Decrease capacity of p by c\\n            int c = std::min(diff, p);\\n            diff -= c;\\n            p -= c;\\n            if (p)\\n                pq.push(p);\\n        }\\n                \\n\\t\\t// No difference left = success\\n        return diff ? -1 : ops;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& arr0, vector<int>& arr1) {\\n        int s0 = 0, s1 = 0;\\n        \\n        for (auto i : arr0) s0 += i;\\n        for (auto i : arr1) s1 += i;\\n        \\n\\t\\t// Swap arrays so first is smaller (first always increments, second always decrements)\\n        if (s1 < s0) {\\n            std::swap(s0, s1);\\n            std::swap(arr0, arr1);\\n        }\\n        else if (s0 == s1)\\n            return 0;\\n        \\n        std::priority_queue<int> pq;\\n\\t\\t// Elements from the first array can decrease sum difference by 6 - x (increment to 6)\\n        for (int i = 0; i < arr0.size(); i++)\\n            if (arr0[i] < 6)\\n                pq.push(6 - arr0[i]);\\n\\t\\t// Elements from the second array can decrease sum difference by x - 1 (decrement to 1)\\n        for (int i = 0; i < arr1.size(); i++)\\n            if (arr1[i] > 1)\\n                pq.push(arr1[i] - 1);\\n        \\n        int ops = 0;\\n        int diff = s1 - s0;\\n        while (diff && pq.size()) {\\n            ++ops;\\n            \\n\\t\\t\\t// Take element with the largest capacity to increment/decrement\\n            auto p = pq.top();\\n            pq.pop();\\n            \\n\\t\\t\\t// Decrease capacity of p by c\\n            int c = std::min(diff, p);\\n            diff -= c;\\n            p -= c;\\n            if (p)\\n                pq.push(p);\\n        }\\n                \\n\\t\\t// No difference left = success\\n        return diff ? -1 : ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092826,
                "title": "java-priorityqueue-o-n1-log-n1-n2-log-n2",
                "content": "\\n\\t// O(n1*log(n1) + n2*log(n2))\\n    public int minOperations(int[] nums1, int[] nums2) {\\n\\n\\t\\tint sum1 = 0, sum2 = 0, ans = 0;\\n\\t\\tfor (int num : nums1)\\n\\t\\t\\tsum1 += num;\\n\\t\\tfor (int num : nums2)\\n\\t\\t\\tsum2 += num;\\n\\n\\t\\tif (sum1 == sum2)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (sum1 > sum2) {\\n\\t\\t\\tint[] temp = nums1;\\n\\t\\t\\tnums1 = nums2;\\n\\t\\t\\tnums2 = temp;\\n\\n\\t\\t\\tint temp2 = sum1;\\n\\t\\t\\tsum1 = sum2;\\n\\t\\t\\tsum2 = temp2;\\n\\t\\t}\\n\\n\\t\\tif (6 * nums1.length < nums2.length)\\n\\t\\t\\treturn -1;\\n\\n\\t\\tPriorityQueue<Integer> heap1 = new PriorityQueue<Integer>();\\n\\t\\tPriorityQueue<Integer> heap2 = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\n\\t\\tfor (int num : nums1)\\n\\t\\t\\theap1.add(num);\\n\\n\\t\\tfor (int num : nums2)\\n\\t\\t\\theap2.add(num);\\n\\n\\t\\twhile (sum1 < sum2) {\\n\\t\\t\\tint increment = 6 - heap1.peek();\\n            int decrement = (heap2.size() != 0) ? heap2.peek() - 1 : 0;\\n            \\n\\t\\t\\tif (increment > decrement) {\\n\\t\\t\\t\\tsum1 += increment;\\n\\t\\t\\t\\theap1.poll();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsum2 -= decrement;\\n\\t\\t\\t\\theap2.poll();\\n\\t\\t\\t}\\n\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n\\t// O(n1*log(n1) + n2*log(n2))\\n    public int minOperations(int[] nums1, int[] nums2) {\\n\\n\\t\\tint sum1 = 0, sum2 = 0, ans = 0;\\n\\t\\tfor (int num : nums1)\\n\\t\\t\\tsum1 += num;\\n\\t\\tfor (int num : nums2)\\n\\t\\t\\tsum2 += num;\\n\\n\\t\\tif (sum1 == sum2)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (sum1 > sum2) {\\n\\t\\t\\tint[] temp = nums1;\\n\\t\\t\\tnums1 = nums2;\\n\\t\\t\\tnums2 = temp;\\n\\n\\t\\t\\tint temp2 = sum1;\\n\\t\\t\\tsum1 = sum2;\\n\\t\\t\\tsum2 = temp2;\\n\\t\\t}\\n\\n\\t\\tif (6 * nums1.length < nums2.length)\\n\\t\\t\\treturn -1;\\n\\n\\t\\tPriorityQueue<Integer> heap1 = new PriorityQueue<Integer>();\\n\\t\\tPriorityQueue<Integer> heap2 = new PriorityQueue<Integer>(Collections.reverseOrder());\\n\\n\\t\\tfor (int num : nums1)\\n\\t\\t\\theap1.add(num);\\n\\n\\t\\tfor (int num : nums2)\\n\\t\\t\\theap2.add(num);\\n\\n\\t\\twhile (sum1 < sum2) {\\n\\t\\t\\tint increment = 6 - heap1.peek();\\n            int decrement = (heap2.size() != 0) ? heap2.peek() - 1 : 0;\\n            \\n\\t\\t\\tif (increment > decrement) {\\n\\t\\t\\t\\tsum1 += increment;\\n\\t\\t\\t\\theap1.poll();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsum2 -= decrement;\\n\\t\\t\\t\\theap2.poll();\\n\\t\\t\\t}\\n\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1088875,
                "title": "priority-queue-with-comments-beat-100-when-posting",
                "content": "* Use maxHeap and minHeap to restore list with larger sum and smaller sum.\\n\\n* Every time make a bigger change by comparing hightDelta(high - 1) and \\nlowDelta(6 - low).\\n    * exit if no more room for changes ```if hightDelta == lowDelta == 0```\\n    * break out to return count if delta is greater than sum differ\\n    * update sum and heap after change\\n\\n```python\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        # make sure nums1 has the larger sum\\n        highSum, lowSum = sum(nums1), sum(nums2)\\n        if highSum == lowSum:\\n            return 0\\n        if highSum < lowSum:\\n            nums1, nums2 = nums2, nums1\\n            highSum, lowSum = lowSum, highSum\\n\\n        # push nums1 into max heap\\n        # push nums2 into min heap\\n        maxHeap = []\\n        for num in nums1:\\n            heapq.heappush(maxHeap, -num)\\n        minHeap = []\\n        for num in nums2:\\n            heapq.heappush(minHeap, num)\\n\\n        count = 0\\n        while highSum != lowSum:\\n            count += 1\\n            diff = highSum - lowSum\\n            high = -maxHeap[0]\\n            low = minHeap[0]\\n            # pick the biggest change\\n            hightDelta = high - 1\\n            lowDelta = 6 - low\\n            # end case -- impossible\\n            if hightDelta == lowDelta == 0:\\n                return -1\\n            if hightDelta >= lowDelta:\\n                if hightDelta >= diff:\\n                    break\\n                else:\\n                    # update sum and heap after change\\n                    heapq.heapreplace(maxHeap, -1)\\n                    highSum -= hightDelta\\n            else:\\n                if lowDelta >= diff:\\n                    break\\n                else:\\n                    # update sum and heap after change\\n                    heapq.heapreplace(minHeap, 6)\\n                    lowSum += lowDelta\\n\\n        return count\\n```\\n\\n> Runtime: 1576 ms, faster than 100.00% of Python3 online submissions for Equal Sum Arrays With Minimum Number of Operations.\\n> Memory Usage: 19.6 MB, less than 100.00% of Python3 online submissions for Equal Sum Arrays With Minimum Number of Operations.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```if hightDelta == lowDelta == 0```\n```python\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        # make sure nums1 has the larger sum\\n        highSum, lowSum = sum(nums1), sum(nums2)\\n        if highSum == lowSum:\\n            return 0\\n        if highSum < lowSum:\\n            nums1, nums2 = nums2, nums1\\n            highSum, lowSum = lowSum, highSum\\n\\n        # push nums1 into max heap\\n        # push nums2 into min heap\\n        maxHeap = []\\n        for num in nums1:\\n            heapq.heappush(maxHeap, -num)\\n        minHeap = []\\n        for num in nums2:\\n            heapq.heappush(minHeap, num)\\n\\n        count = 0\\n        while highSum != lowSum:\\n            count += 1\\n            diff = highSum - lowSum\\n            high = -maxHeap[0]\\n            low = minHeap[0]\\n            # pick the biggest change\\n            hightDelta = high - 1\\n            lowDelta = 6 - low\\n            # end case -- impossible\\n            if hightDelta == lowDelta == 0:\\n                return -1\\n            if hightDelta >= lowDelta:\\n                if hightDelta >= diff:\\n                    break\\n                else:\\n                    # update sum and heap after change\\n                    heapq.heapreplace(maxHeap, -1)\\n                    highSum -= hightDelta\\n            else:\\n                if lowDelta >= diff:\\n                    break\\n                else:\\n                    # update sum and heap after change\\n                    heapq.heapreplace(minHeap, 6)\\n                    lowSum += lowDelta\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086395,
                "title": "c-simple-solution-100-faster-simple-two-pointer-approach",
                "content": "1. Sort both array\\n2. Find difference in sum of two array. Keep left pointer on array with smaller sum (SArr) and right on rightmost element of array with bigger sum (BArr)\\n3. In each step increase count by one, Decrease difference by larger of two i.e. 6 - SArr[l] and BArr[r] - 1(this is the max amount by which we can decrease the difference at each step) . Increase l or decrease r based on which one we pick. When diff is 0 or negative return the count.\\n\\n```\\npublic class Solution {\\n    public int MinOperations(int[] nums1, int[] nums2) {\\n        \\n        Array.Sort(nums1);\\n        Array.Sort(nums2);\\n        \\n        int sum1 = nums1.Sum();\\n        int sum2 = nums2.Sum();\\n        \\n        int diff = Math.Abs(sum1 - sum2);\\n        if(diff == 0)\\n            return 0;\\n        \\n        var BArr = sum1 > sum2 ? nums1 : nums2;\\n        var SArr = sum1 > sum2 ? nums2 : nums1;\\n        \\n        int l = 0, r = BArr.Length-1;\\n        int count=0;\\n        \\n        while(l < SArr.Length && r >= 0)\\n        {\\n            count++;\\n            int d1 = 6 - SArr[l];\\n            int d2 = BArr[r] - 1;\\n            if(d1 >= d2)\\n                l++;\\n            else\\n                r--;\\n            diff -= Math.Max(d1,d2);\\n            \\n            //Console.WriteLine($\"diff : {diff}, l : {l}, r: {r}\");\\n            if(diff <= 0)\\n                return count;            \\n        }\\n        \\n        while(diff > 0 && l < SArr.Length)\\n        {\\n            count++;\\n            diff -= (6 - SArr[l]);\\n            l++;\\n            if(diff <= 0)\\n                return count; \\n        }\\n        \\n        while(diff > 0 && r >= 0)\\n        {\\n            count++;\\n            diff -= (BArr[r]-1);\\n            r--;\\n            if(diff <= 0)\\n                return count; \\n        }\\n        \\n        return -1;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums1, int[] nums2) {\\n        \\n        Array.Sort(nums1);\\n        Array.Sort(nums2);\\n        \\n        int sum1 = nums1.Sum();\\n        int sum2 = nums2.Sum();\\n        \\n        int diff = Math.Abs(sum1 - sum2);\\n        if(diff == 0)\\n            return 0;\\n        \\n        var BArr = sum1 > sum2 ? nums1 : nums2;\\n        var SArr = sum1 > sum2 ? nums2 : nums1;\\n        \\n        int l = 0, r = BArr.Length-1;\\n        int count=0;\\n        \\n        while(l < SArr.Length && r >= 0)\\n        {\\n            count++;\\n            int d1 = 6 - SArr[l];\\n            int d2 = BArr[r] - 1;\\n            if(d1 >= d2)\\n                l++;\\n            else\\n                r--;\\n            diff -= Math.Max(d1,d2);\\n            \\n            //Console.WriteLine($\"diff : {diff}, l : {l}, r: {r}\");\\n            if(diff <= 0)\\n                return count;            \\n        }\\n        \\n        while(diff > 0 && l < SArr.Length)\\n        {\\n            count++;\\n            diff -= (6 - SArr[l]);\\n            l++;\\n            if(diff <= 0)\\n                return count; \\n        }\\n        \\n        while(diff > 0 && r >= 0)\\n        {\\n            count++;\\n            diff -= (BArr[r]-1);\\n            r--;\\n            if(diff <= 0)\\n                return count; \\n        }\\n        \\n        return -1;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085955,
                "title": "java-greedy-time-o-n-space-o-1-no-sort-no-pointer-no-queue",
                "content": "\\n```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int l1=nums1.length,l2=nums2.length;\\n        if(l1>l2) return minOperations(nums2,nums1);\\n\\t\\t// if shorter array length * 6 (max number) is less than longer  array length, not possible \\n        if(l1*6<l2) return -1;\\n\\t\\t// count of numbers and sum\\n        int sum1=0,sum2=0;\\n        int[] cnt1=new int[7],cnt2=new int[7];\\n        for(var n:nums1) {\\n            sum1+=n;\\n            cnt1[n]++;\\n        }\\n        for(var n:nums2) {\\n            sum2+=n;\\n            cnt2[n]++;\\n        }\\n\\t\\t\\n\\t\\t// modify which could change most, starts with ones of smaller sum array and sixes of greater sum array\\n        if(sum1>sum2) {\\n            return helper(cnt2,cnt1,sum1-sum2,1);\\n        } else {\\n            return helper(cnt1,cnt2,sum2-sum1,1);\\n        }\\n    }\\n    \\n\\t// solve the difference\\n    int helper(int[] lower,int[] higher,int diff,int l) {\\n\\t\\t// no change if no diff\\n        if(diff==0) return 0;\\n\\t\\t// modify l of lower array and 7-l of higher array\\n        int cnt=lower[l]+higher[7-l];\\n\\t\\t// max change can be made\\n        int k=6-l;\\n\\t\\t// total max change can be made\\n        int ch=cnt*k;\\n        if(ch<diff) {\\n\\t\\t\\t// not enough, change all and move to next numbers which is l+1 and 6-l\\n            return cnt+helper(lower,higher,diff-ch,l+1);\\n        } else {\\n\\t\\t\\t// return the changes required\\n            return (diff+k-1)/k;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int l1=nums1.length,l2=nums2.length;\\n        if(l1>l2) return minOperations(nums2,nums1);\\n\\t\\t// if shorter array length * 6 (max number) is less than longer  array length, not possible \\n        if(l1*6<l2) return -1;\\n\\t\\t// count of numbers and sum\\n        int sum1=0,sum2=0;\\n        int[] cnt1=new int[7],cnt2=new int[7];\\n        for(var n:nums1) {\\n            sum1+=n;\\n            cnt1[n]++;\\n        }\\n        for(var n:nums2) {\\n            sum2+=n;\\n            cnt2[n]++;\\n        }\\n\\t\\t\\n\\t\\t// modify which could change most, starts with ones of smaller sum array and sixes of greater sum array\\n        if(sum1>sum2) {\\n            return helper(cnt2,cnt1,sum1-sum2,1);\\n        } else {\\n            return helper(cnt1,cnt2,sum2-sum1,1);\\n        }\\n    }\\n    \\n\\t// solve the difference\\n    int helper(int[] lower,int[] higher,int diff,int l) {\\n\\t\\t// no change if no diff\\n        if(diff==0) return 0;\\n\\t\\t// modify l of lower array and 7-l of higher array\\n        int cnt=lower[l]+higher[7-l];\\n\\t\\t// max change can be made\\n        int k=6-l;\\n\\t\\t// total max change can be made\\n        int ch=cnt*k;\\n        if(ch<diff) {\\n\\t\\t\\t// not enough, change all and move to next numbers which is l+1 and 6-l\\n            return cnt+helper(lower,higher,diff-ch,l+1);\\n        } else {\\n\\t\\t\\t// return the changes required\\n            return (diff+k-1)/k;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085880,
                "title": "python-o-n-time-o-1-space-greedy",
                "content": "### Key idea\\n\\nLet `A` and `B` represent the input arrays such that `sum(A) < sum(B)`.\\n\\nNote that if `A[i] = 1`, we can **increase** `sum(A)` by a maximum of 5 if we change `A[i]` from 1 to 6. Similarly, note that if `B[i] = 6`, we can **decrease** `sum(B)` by a maximum of 5 if we change `B[i]` from 6 to 1. In other words, both operations **equivalently** reduce the difference `sum(B) - sum(A)` by 5.\\n\\n### Approach\\n\\nGet the element frequencies in each array `A` and `B`.\\n\\nWe look at how many times we can reduce the difference between `sum(B) - sum(A)` by up to 5. Let\\'s say there are `a1` 1s in `A` and `b6` 6s in `B`. Then there are a total of of `a1 + b6` operations we can do to either increase `A` by 5 or decrease `B` by 5. We obviously want to do these operations (converting 1s in `A` and 6s in `B`) first, since these increase `A` or decrease `B` by the most. \\n\\nAfterwards we convert 2s in `A` and 5s in `B` (which increase `sum(A)` and decrease `sum(B)` by 4), then 3s in `A` and 4s in `B`, etc.\\n\\nSpace is constant since the frequency counts have a maximum of 6 elements (1, 2, 3, 4, 5, 6).\\n\\n\\n### Code\\n\\nFor a really short, clean version of this, check out #12. @azala\\'s submission for Q3: https://leetcode.com/contest/weekly-contest-230/ranking\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        A, B = nums1, nums2\\n        sum_a, sum_b = sum(A), sum(B)\\n        if sum_a > sum_b:\\n            # keep sum(B) > sum(A)\\n            A, B = B, A\\n            sum_a, sum_b = sum_b, sum_a\\n           \\n\\t\\t# get element frequencies\\n        freq_A, freq_B = [0] * 7, [0] * 7\\n        for a in A:\\n            freq_A[a] += 1\\n        for b in B:\\n            freq_B[b] += 1\\n        \\n        # make sure it\\'s possible\\n        na, nb = len(A), len(B)\\n        min_a, max_a = na, 6 * na\\n        min_b, max_b = nb, 6 * nb\\n        if min_a > max_b or min_b > max_a:\\n            return -1\\n        elif sum_a == sum_b:\\n            return 0\\n        \\n        # get number of equivalent difference-reducing operations available\\n        num_ops_by_distance = [0] * 6\\n        for elem in range(1, 7):\\n            # element A[i] can be increased by up to (6 - A[i])\\n            num_ops_by_distance[6 - elem] += freq_A[elem]\\n            # element B[i] can be decreased by up to (B[i] - 1)\\n            num_ops_by_distance[elem - 1] += freq_B[elem]\\n            \\n        diff = sum_b - sum_a\\n        res = 0\\n        \\n        # decrease diff = sum(B) - sum(A) by largest remaining incr/decrements of size delta\\n        for delta in range(5, 0, -1):\\n            max_reduction = num_ops_by_distance[delta] * delta\\n            if diff >= max_reduction:\\n                # all incr/decrements of size delta are not enough to bridge the remaining difference\\n                res += num_ops_by_distance[delta]\\n                diff -= max_reduction\\n                if diff <= 0:\\n                    break\\n            else:\\n                # get the actual number of operations needed for changes of given size delta\\n                num_ops_needed, rem = divmod(diff, delta)\\n                num_ops_needed += (rem > 0)\\n                res += num_ops_needed\\n                break\\n        \\n        return res\\n```\\n\\n#### Example\\n\\n`A = [1,1,1,1,1,2]`, `sum(A) = 7`\\n`B = [2,3,5,6,6]`, `sum(B) = 22` \\n\\nNumber of times we can increase `A` by up to:\\n- 5: 5 (five 1s)\\n- 4: 1 (one 2)\\n\\nNumber of times we can decrease `B` by up to:\\n- 5: 2 (two 6s)\\n- 4: 1 (one 5)\\n- 2: 1 (one 3)\\n- 1: 1 (one 2)\\n\\nNumber of times we can reduce the difference between `A` and `B` by:\\n- 5: 7 = 5 + 2 (four 1s in `A`, two 6s in `B`)\\n- 4: 2 = 1 + 1\\n- 2: 1 = 0 + 1\\n- 1: 1 = 0 + 1\\n\\nSo we first convert as many `1->6`s in `A` (and/or `6->1`s in `B`) as we can. Since we have 7 operations available to reduce the difference between `A` and `B` by 5, and the actual difference is `22-7=15`, we can use 3 of these operations to get `A` and `B` to the same sum.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        A, B = nums1, nums2\\n        sum_a, sum_b = sum(A), sum(B)\\n        if sum_a > sum_b:\\n            # keep sum(B) > sum(A)\\n            A, B = B, A\\n            sum_a, sum_b = sum_b, sum_a\\n           \\n\\t\\t# get element frequencies\\n        freq_A, freq_B = [0] * 7, [0] * 7\\n        for a in A:\\n            freq_A[a] += 1\\n        for b in B:\\n            freq_B[b] += 1\\n        \\n        # make sure it\\'s possible\\n        na, nb = len(A), len(B)\\n        min_a, max_a = na, 6 * na\\n        min_b, max_b = nb, 6 * nb\\n        if min_a > max_b or min_b > max_a:\\n            return -1\\n        elif sum_a == sum_b:\\n            return 0\\n        \\n        # get number of equivalent difference-reducing operations available\\n        num_ops_by_distance = [0] * 6\\n        for elem in range(1, 7):\\n            # element A[i] can be increased by up to (6 - A[i])\\n            num_ops_by_distance[6 - elem] += freq_A[elem]\\n            # element B[i] can be decreased by up to (B[i] - 1)\\n            num_ops_by_distance[elem - 1] += freq_B[elem]\\n            \\n        diff = sum_b - sum_a\\n        res = 0\\n        \\n        # decrease diff = sum(B) - sum(A) by largest remaining incr/decrements of size delta\\n        for delta in range(5, 0, -1):\\n            max_reduction = num_ops_by_distance[delta] * delta\\n            if diff >= max_reduction:\\n                # all incr/decrements of size delta are not enough to bridge the remaining difference\\n                res += num_ops_by_distance[delta]\\n                diff -= max_reduction\\n                if diff <= 0:\\n                    break\\n            else:\\n                # get the actual number of operations needed for changes of given size delta\\n                num_ops_needed, rem = divmod(diff, delta)\\n                num_ops_needed += (rem > 0)\\n                res += num_ops_needed\\n                break\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645751,
                "title": "c-o-n-tc-o-1-sc-100-beats-in-time",
                "content": "All explanations are written along with code below.\\n \\n\\n```\\nstatic const auto speedup = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return 0; }();\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        // calculate the frequency and find the sum\\n        vector<int> cnt1(7,0), cnt2(7,0);\\n        for(auto &a:nums1) cnt1[a]++;\\n        for(auto &a:nums2) cnt2[a]++;\\n        int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n        int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n        \\n        // already equal\\n        if(sum1 == sum2) return 0;\\n        \\n        // reduce sum1 < sum2 to sum1 > sum2....so only one problem we have to deal wiith\\n        if(sum1 < sum2){\\n            swap(sum1, sum2);\\n            cnt1.swap(cnt2);\\n        }\\n        \\n        // since sum1 > sum2 ... we have two options \\n                // 1) decrease val in first array \\n                // 2) increase val in second array\\n        \\n        // if we have 6 in first array, maximum decrease of sum1 can be of 5 So, sum1-sum2 decreases by 5 \\n\\t\\t// Similarly if we have 1 in second array, maximum incrase of sum2 can be 5. And hence sum1-sum2 decreases by 5. \\n\\t\\t// So, decreasing 6 in first array and increasing 1 in second lead to maximum deduction of 5 in the difference.\\n        \\n        // Similary, If we consider 5 from first array and 2 from the second array, it can lead to maximum deduction of 4 in the difference.\\n        \\n        // Now, cnt1[i] (i=2,3,4,5,6) will have the number of times it can decrese the difference by (i-1);\\n        for(int i=1; i<=6; i++)\\n            cnt1[i] += cnt2[7-i];\\n        \\n        int diff = sum1-sum2;\\n        int curr = 6;      // start by i=6 and go upto i=2;\\n        int ops = 0;        // to store the # of operations\\n        \\n        while(diff && (curr>1)){\\n            // count the # of substraction needs to be done where the substraction can be of (curr-1) \\n            int needed = ceil(1.0*diff/(curr-1));\\n            \\n            // maximum operations is bounded by count of the (curr-1) substraction\\n\\t\\t\\t// As stated earlier cnt1[curr] have the count of how many (curr-1) deduction can be done\\n\\t\\t\\t// So, we can only do min(needed, cnt1[curr-1]) ops\\n            ops += min(needed, cnt1[curr]);\\n            \\n            // deacrese the difference accordingly\\n            diff -= min(needed, cnt1[curr])*(curr-1);\\n            \\n            // for last deduction diff can be -ve. E.g. diff was 3 and we deduct 5. So, we can assume that we deducted 3 only and make diff = 0\\n            if(diff < 0) diff = 0;\\n            \\n            // go for next smaller value\\n            curr--;\\n        }\\n        \\n\\t\\t// if diff is non-zero, then return -1. Otherwise return the # of operations\\n        return (diff ? -1 : ops);\\n    }\\n};\\n```\\n\\n\\n\\nTIme complexity:\\nSince we are first calculating sum and storing count. These operations can be done in O(n) time. Now, counting the number of operations takes 5 iterations maximum. Overall time complexity is O(n)\\n\\nSpace Complexity:\\nSInce we only stores the frequency which is constant memory. And hence space complexity is O(1).\\n\\nTC: O(n)\\nSC: O(1)\\n\\nThank you :)\\n\\nDo upvote the solution if you found it useful.",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nstatic const auto speedup = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return 0; }();\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        // calculate the frequency and find the sum\\n        vector<int> cnt1(7,0), cnt2(7,0);\\n        for(auto &a:nums1) cnt1[a]++;\\n        for(auto &a:nums2) cnt2[a]++;\\n        int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n        int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n        \\n        // already equal\\n        if(sum1 == sum2) return 0;\\n        \\n        // reduce sum1 < sum2 to sum1 > sum2....so only one problem we have to deal wiith\\n        if(sum1 < sum2){\\n            swap(sum1, sum2);\\n            cnt1.swap(cnt2);\\n        }\\n        \\n        // since sum1 > sum2 ... we have two options \\n                // 1) decrease val in first array \\n                // 2) increase val in second array\\n        \\n        // if we have 6 in first array, maximum decrease of sum1 can be of 5 So, sum1-sum2 decreases by 5 \\n\\t\\t// Similarly if we have 1 in second array, maximum incrase of sum2 can be 5. And hence sum1-sum2 decreases by 5. \\n\\t\\t// So, decreasing 6 in first array and increasing 1 in second lead to maximum deduction of 5 in the difference.\\n        \\n        // Similary, If we consider 5 from first array and 2 from the second array, it can lead to maximum deduction of 4 in the difference.\\n        \\n        // Now, cnt1[i] (i=2,3,4,5,6) will have the number of times it can decrese the difference by (i-1);\\n        for(int i=1; i<=6; i++)\\n            cnt1[i] += cnt2[7-i];\\n        \\n        int diff = sum1-sum2;\\n        int curr = 6;      // start by i=6 and go upto i=2;\\n        int ops = 0;        // to store the # of operations\\n        \\n        while(diff && (curr>1)){\\n            // count the # of substraction needs to be done where the substraction can be of (curr-1) \\n            int needed = ceil(1.0*diff/(curr-1));\\n            \\n            // maximum operations is bounded by count of the (curr-1) substraction\\n\\t\\t\\t// As stated earlier cnt1[curr] have the count of how many (curr-1) deduction can be done\\n\\t\\t\\t// So, we can only do min(needed, cnt1[curr-1]) ops\\n            ops += min(needed, cnt1[curr]);\\n            \\n            // deacrese the difference accordingly\\n            diff -= min(needed, cnt1[curr])*(curr-1);\\n            \\n            // for last deduction diff can be -ve. E.g. diff was 3 and we deduct 5. So, we can assume that we deducted 3 only and make diff = 0\\n            if(diff < 0) diff = 0;\\n            \\n            // go for next smaller value\\n            curr--;\\n        }\\n        \\n\\t\\t// if diff is non-zero, then return -1. Otherwise return the # of operations\\n        return (diff ? -1 : ops);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546613,
                "title": "python3-2-pointers-after-sorting-w-comments",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        # idea is to decrement values the array having larger sum and increment values in the array having small sum\\n        # choose biggest element always to decrement values in large_sum_array\\n        # choose smallest element always to increment values in small_sum_array\\n        # both above points suggest , to have sorted arrays for better selection \\n        # Now , once you get to this point , we need to select whether to decrement or increment in either of array for that\\n        # we need to check which one in either of them , making differnece smaller and select that\\n        \\n         \\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        \\n        if sum1 == sum2:        # if sum is same , nothing is needed\\n            return 0\\n        # sort arrays , that will help in selecting elements in sorted order\\n        nums1.sort()\\n        nums2.sort()\\n       \\n        # below is needed to make the code is simple\\n        if sum1 > sum2:\\n            larger_sum_array , smaller_sum_array = nums1 , nums2\\n        else:\\n            larger_sum_array , smaller_sum_array = nums2 , nums1\\n         \\n        # normal initialization\\n        largeSum = sum(larger_sum_array)\\n        smallSum = sum(smaller_sum_array)\\n        largeSumArrayLen = len(larger_sum_array)    \\n        smallSumArrayLen = len(smaller_sum_array)\\n        \\n        left,right = 0, largeSumArrayLen-1\\n        count = 0\\n        diff = largeSum - smallSum\\n        \\n        # we will have 2 pointer , right will iterate over large_sum_array for decreasing, biggest element\\n        # left will iterate over small_sum_array for incrementing, smallest element\\n        # once you see, which way is better minimizing diff of 2 arrays , move pointers accordingly\\n        \\n        while left < smallSumArrayLen and right >= 0:\\n          \\n            diffIfDecrement = diff - (larger_sum_array[right]-1)   # value if you decide on decrement in largest sum array\\n            diffIfIncrement = diff - (6-smaller_sum_array[left])   # value if you decide on increment in small_sum_array\\n            \\n            if diffIfIncrement < diffIfDecrement:              # selection which way is better i.e. who minimizes the diff better\\n                smallSum += (6-smaller_sum_array[left])\\n                left +=1\\n            else:\\n                largeSum -= (larger_sum_array[right]-1)\\n                right -=1\\n            count +=1\\n            \\n            diff = largeSum - smallSum               \\n            if diff <=0:        # point where largeSum is going down => suggests that point where sum can be equal\\n                return count\\n            \\n      \\n        \\n        while left < smallSumArrayLen:               # largest_sum_array exhausted , only way is increment in small_sum_array\\n            smallSum += (6-smaller_sum_array[left])\\n            left +=1\\n            count +=1\\n            diff = largeSum - smallSum \\n            if diff <=0:    # point where largeSum is going down => suggests that point where sum can be equal\\n                return count\\n        \\n        while right > 0:                # small_sum+array exhausted , only way is decrement in larget_sum_array\\n            largeSum -= (larger_sum_array[right]-1)\\n            right -=1\\n            count +=1\\n            diff = largeSum - smallSum\\n            if diff <=0:# point where largeSum is going down => suggests that point where sum can be equal\\n                return count\\n        \\n        return -1            # sorry , you could not make them equal```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        # idea is to decrement values the array having larger sum and increment values in the array having small sum\\n        # choose biggest element always to decrement values in large_sum_array\\n        # choose smallest element always to increment values in small_sum_array\\n        # both above points suggest , to have sorted arrays for better selection \\n        # Now , once you get to this point , we need to select whether to decrement or increment in either of array for that\\n        # we need to check which one in either of them , making differnece smaller and select that\\n        \\n         \\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        \\n        if sum1 == sum2:        # if sum is same , nothing is needed\\n            return 0\\n        # sort arrays , that will help in selecting elements in sorted order\\n        nums1.sort()\\n        nums2.sort()\\n       \\n        # below is needed to make the code is simple\\n        if sum1 > sum2:\\n            larger_sum_array , smaller_sum_array = nums1 , nums2\\n        else:\\n            larger_sum_array , smaller_sum_array = nums2 , nums1\\n         \\n        # normal initialization\\n        largeSum = sum(larger_sum_array)\\n        smallSum = sum(smaller_sum_array)\\n        largeSumArrayLen = len(larger_sum_array)    \\n        smallSumArrayLen = len(smaller_sum_array)\\n        \\n        left,right = 0, largeSumArrayLen-1\\n        count = 0\\n        diff = largeSum - smallSum\\n        \\n        # we will have 2 pointer , right will iterate over large_sum_array for decreasing, biggest element\\n        # left will iterate over small_sum_array for incrementing, smallest element\\n        # once you see, which way is better minimizing diff of 2 arrays , move pointers accordingly\\n        \\n        while left < smallSumArrayLen and right >= 0:\\n          \\n            diffIfDecrement = diff - (larger_sum_array[right]-1)   # value if you decide on decrement in largest sum array\\n            diffIfIncrement = diff - (6-smaller_sum_array[left])   # value if you decide on increment in small_sum_array\\n            \\n            if diffIfIncrement < diffIfDecrement:              # selection which way is better i.e. who minimizes the diff better\\n                smallSum += (6-smaller_sum_array[left])\\n                left +=1\\n            else:\\n                largeSum -= (larger_sum_array[right]-1)\\n                right -=1\\n            count +=1\\n            \\n            diff = largeSum - smallSum               \\n            if diff <=0:        # point where largeSum is going down => suggests that point where sum can be equal\\n                return count\\n            \\n      \\n        \\n        while left < smallSumArrayLen:               # largest_sum_array exhausted , only way is increment in small_sum_array\\n            smallSum += (6-smaller_sum_array[left])\\n            left +=1\\n            count +=1\\n            diff = largeSum - smallSum \\n            if diff <=0:    # point where largeSum is going down => suggests that point where sum can be equal\\n                return count\\n        \\n        while right > 0:                # small_sum+array exhausted , only way is decrement in larget_sum_array\\n            largeSum -= (larger_sum_array[right]-1)\\n            right -=1\\n            count +=1\\n            diff = largeSum - smallSum\\n            if diff <=0:# point where largeSum is going down => suggests that point where sum can be equal\\n                return count\\n        \\n        return -1            # sorry , you could not make them equal```",
                "codeTag": "Java"
            },
            {
                "id": 1501255,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) \\n    {\\n        int sum1 = 0, sum2 = 0;\\n        \\n        for(int num : nums1) sum1 += num;\\n        for(int num : nums2) sum2 += num;\\n        \\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a,b) -> (b-a));\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>((a,b) -> (a-b));\\n        \\n        int diff = 0;\\n        if(sum1 > sum2)\\n        {\\n            diff = sum1 - sum2;\\n            for(int num : nums1) maxHeap.add(num);\\n            for(int num : nums2) minHeap.add(num);\\n        }\\n        else\\n        {\\n            diff = sum2 - sum1;\\n            for(int num : nums1) minHeap.add(num);\\n            for(int num : nums2) maxHeap.add(num);\\n        }\\n        \\n        int operations = 0;\\n        if(diff == 0) return operations;\\n        \\n        while(!maxHeap.isEmpty() || !minHeap.isEmpty())\\n        {\\n            if(diff == 0)\\n            {\\n                break;\\n            }\\n            \\n            int first = maxHeap.isEmpty() ? -1 : Math.abs(maxHeap.peek() - 1);\\n            int second = minHeap.isEmpty() ? -1 :  Math.abs(6 - minHeap.peek()); \\n            if(first > second)\\n            {\\n                diff -= (diff > first) ? first : diff;\\n                operations += 1;\\n                maxHeap.poll();\\n            }\\n            else\\n            {\\n                diff -= (diff > second) ? second : diff;\\n                operations += 1;\\n                minHeap.poll();\\n            }\\n        }\\n        \\n        return diff == 0 ? operations : -1;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperations(int[] nums1, int[] nums2) \\n    {\\n        int sum1 = 0, sum2 = 0;\\n        \\n        for(int num : nums1) sum1 += num;\\n        for(int num : nums2) sum2 += num;\\n        \\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a,b) -> (b-a));\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>((a,b) -> (a-b));\\n        \\n        int diff = 0;\\n        if(sum1 > sum2)\\n        {\\n            diff = sum1 - sum2;\\n            for(int num : nums1) maxHeap.add(num);\\n            for(int num : nums2) minHeap.add(num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1296411,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int s1=0,s2=0;\\n        if(min(n1,n2) * 6 < max(n1, n2))\\n            return -1;\\n        for(int i=0;i<n1;i++)\\n            s1+=nums1[i];\\n        for(int i=0;i<n2;i++)\\n            s2+=nums2[i];\\n        if(s1<s2){\\n            swap(nums1, nums2); // consdering nums1 sum to be always greater\\n        }\\n        int diff=abs(s1-s2);\\n        map<int, int> m;\\n        for(int i=0;i<nums2.size();i++){\\n            m[6-nums2[i]]++; // it shows by how much we can increment in nums2 as it has smaller sum\\n        }\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i]-1]++; // it shows by how much we can decrement in nums1 as it has greater sum\\n        }\\n        int c=0;\\n        map<int, int>::reverse_iterator it;\\n        for(it=m.rbegin(); it!=m.rend(); it++){\\n            int k=it->second;\\n            int ele=it->first;\\n            while(k-->0 && diff>0){\\n                diff-=ele;\\n                c++;\\n            }\\n            if(diff<=0)\\n                return c;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int s1=0,s2=0;\\n        if(min(n1,n2) * 6 < max(n1, n2))\\n            return -1;\\n        for(int i=0;i<n1;i++)\\n            s1+=nums1[i];\\n        for(int i=0;i<n2;i++)\\n            s2+=nums2[i];\\n        if(s1<s2){\\n            swap(nums1, nums2); // consdering nums1 sum to be always greater\\n        }\\n        int diff=abs(s1-s2);\\n        map<int, int> m;\\n        for(int i=0;i<nums2.size();i++){\\n            m[6-nums2[i]]++; // it shows by how much we can increment in nums2 as it has smaller sum\\n        }\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i]-1]++; // it shows by how much we can decrement in nums1 as it has greater sum\\n        }\\n        int c=0;\\n        map<int, int>::reverse_iterator it;\\n        for(it=m.rbegin(); it!=m.rend(); it++){\\n            int k=it->second;\\n            int ele=it->first;\\n            while(k-->0 && diff>0){\\n                diff-=ele;\\n                c++;\\n            }\\n            if(diff<=0)\\n                return c;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095425,
                "title": "c-greedy-scan-o-n-log-n-m-log-m",
                "content": "```csharp\\npublic int MinOperations(int[] nums1, int[] nums2) \\n{\\n\\tif ((nums1.Length * 6 < nums2.Length) || (nums1.Length > 6 * nums2.Length)) \\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tint sum1 = nums1.Sum();\\n\\tint sum2 = nums2.Sum();\\n\\n\\tif(sum1 == sum2)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tArray.Sort(nums1);\\n\\tArray.Sort(nums2); \\n\\n\\tif(sum1 < sum2)\\n\\t{\\n\\t\\treturn findMinOperations(nums1, nums2, sum1, sum2);\\n\\t}\\n\\n\\telse\\n\\t{\\n\\t\\treturn findMinOperations(nums2, nums1, sum2, sum1);\\n\\t} \\n}\\n\\nprivate int findMinOperations(int[] nums1, int[] nums2, int sum1, int sum2)\\n{\\n\\tint first = 0, second = nums2.Length - 1;\\n\\tint result = 0;\\n\\n\\twhile(sum2 > sum1)\\n\\t{\\n\\t\\tif(first < nums1.Length && second >= 0)\\n\\t\\t{\\n\\t\\t\\tint diff1 = 6 - nums1[first];\\n\\t\\t\\tint diff2 = nums2[second] - 1;\\n\\n\\t\\t\\tif(diff1 > diff2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum1 += diff1;\\n\\t\\t\\t\\tfirst++;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum2 -= diff2;\\n\\t\\t\\t\\tsecond--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\telse if(first < nums1.Length)\\n\\t\\t{\\n\\t\\t\\tsum1 += 6 - nums1[first];\\n\\t\\t\\tfirst++;\\n\\t\\t}\\n\\n\\t\\telse if(second >= 0)\\n\\t\\t{\\n\\t\\t\\tsum2 -= nums2[second] - 1;\\n\\t\\t\\tsecond--;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tresult++;\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinOperations(int[] nums1, int[] nums2) \\n{\\n\\tif ((nums1.Length * 6 < nums2.Length) || (nums1.Length > 6 * nums2.Length)) \\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tint sum1 = nums1.Sum();\\n\\tint sum2 = nums2.Sum();\\n\\n\\tif(sum1 == sum2)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tArray.Sort(nums1);\\n\\tArray.Sort(nums2); \\n\\n\\tif(sum1 < sum2)\\n\\t{\\n\\t\\treturn findMinOperations(nums1, nums2, sum1, sum2);\\n\\t}\\n\\n\\telse\\n\\t{\\n\\t\\treturn findMinOperations(nums2, nums1, sum2, sum1);\\n\\t} \\n}\\n\\nprivate int findMinOperations(int[] nums1, int[] nums2, int sum1, int sum2)\\n{\\n\\tint first = 0, second = nums2.Length - 1;\\n\\tint result = 0;\\n\\n\\twhile(sum2 > sum1)\\n\\t{\\n\\t\\tif(first < nums1.Length && second >= 0)\\n\\t\\t{\\n\\t\\t\\tint diff1 = 6 - nums1[first];\\n\\t\\t\\tint diff2 = nums2[second] - 1;\\n\\n\\t\\t\\tif(diff1 > diff2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum1 += diff1;\\n\\t\\t\\t\\tfirst++;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum2 -= diff2;\\n\\t\\t\\t\\tsecond--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\telse if(first < nums1.Length)\\n\\t\\t{\\n\\t\\t\\tsum1 += 6 - nums1[first];\\n\\t\\t\\tfirst++;\\n\\t\\t}\\n\\n\\t\\telse if(second >= 0)\\n\\t\\t{\\n\\t\\t\\tsum2 -= nums2[second] - 1;\\n\\t\\t\\tsecond--;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tresult++;\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1092950,
                "title": "java-2-pointer-count-sort-o-n-m",
                "content": "\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int sum1 = 0, sum2 = 0, ans = 0;\\n\\t\\tint[] freq1 = new int[7], freq2 = new int[7];\\n\\n\\t\\tfor (int num : nums1) {\\n\\t\\t\\tsum1 += num;\\n\\t\\t\\tfreq1[num] += 1;\\n\\t\\t}\\n\\n\\t\\tfor (int num : nums2) {\\n\\t\\t\\tsum2 += num;\\n\\t\\t\\tfreq2[num] += 1;\\n\\t\\t}\\n\\n\\t\\tif (sum1 == sum2)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (sum1 > sum2) {\\n\\t\\t\\tint[] temp = nums1;\\n\\t\\t\\tnums1 = nums2;\\n\\t\\t\\tnums2 = temp;\\n\\n\\t\\t\\tint temp2 = sum1;\\n\\t\\t\\tsum1 = sum2;\\n\\t\\t\\tsum2 = temp2;\\n            \\n            int[] temp3 = freq1;\\n\\t\\t\\tfreq1 = freq2;\\n\\t\\t\\tfreq2 = temp3;\\n\\t\\t}\\n\\n\\t\\tif (6 * nums1.length < nums2.length)\\n\\t\\t\\treturn -1;\\n        \\n\\t\\twhile (sum1 < sum2) {\\n            \\n\\t\\t\\tans++;\\n\\t\\t\\tint increment = 0, decrement = 0;\\n\\t\\t\\tint ptr1 = 1;\\n\\t\\t\\twhile (ptr1 <= 6) {\\n\\t\\t\\t\\tif (freq1[ptr1] != 0) {\\n\\t\\t\\t\\t\\tincrement = 6 - ptr1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tptr1++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ptr2 = 6;\\n\\t\\t\\twhile (ptr2 >= 1) {\\n\\t\\t\\t\\tif (freq2[ptr2] != 0) {\\n\\t\\t\\t\\t\\tdecrement = ptr2 - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n                ptr2--;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (increment > decrement) {\\n\\t\\t\\t\\tsum1 += increment;\\n\\t\\t\\t\\tfreq1[ptr1]--;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsum2 -= decrement;\\n\\t\\t\\t\\tfreq2[ptr2]--;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int sum1 = 0, sum2 = 0, ans = 0;\\n\\t\\tint[] freq1 = new int[7], freq2 = new int[7];\\n\\n\\t\\tfor (int num : nums1) {\\n\\t\\t\\tsum1 += num;\\n\\t\\t\\tfreq1[num] += 1;\\n\\t\\t}\\n\\n\\t\\tfor (int num : nums2) {\\n\\t\\t\\tsum2 += num;\\n\\t\\t\\tfreq2[num] += 1;\\n\\t\\t}\\n\\n\\t\\tif (sum1 == sum2)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (sum1 > sum2) {\\n\\t\\t\\tint[] temp = nums1;\\n\\t\\t\\tnums1 = nums2;\\n\\t\\t\\tnums2 = temp;\\n\\n\\t\\t\\tint temp2 = sum1;\\n\\t\\t\\tsum1 = sum2;\\n\\t\\t\\tsum2 = temp2;\\n            \\n            int[] temp3 = freq1;\\n\\t\\t\\tfreq1 = freq2;\\n\\t\\t\\tfreq2 = temp3;\\n\\t\\t}\\n\\n\\t\\tif (6 * nums1.length < nums2.length)\\n\\t\\t\\treturn -1;\\n        \\n\\t\\twhile (sum1 < sum2) {\\n            \\n\\t\\t\\tans++;\\n\\t\\t\\tint increment = 0, decrement = 0;\\n\\t\\t\\tint ptr1 = 1;\\n\\t\\t\\twhile (ptr1 <= 6) {\\n\\t\\t\\t\\tif (freq1[ptr1] != 0) {\\n\\t\\t\\t\\t\\tincrement = 6 - ptr1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tptr1++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ptr2 = 6;\\n\\t\\t\\twhile (ptr2 >= 1) {\\n\\t\\t\\t\\tif (freq2[ptr2] != 0) {\\n\\t\\t\\t\\t\\tdecrement = ptr2 - 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n                ptr2--;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (increment > decrement) {\\n\\t\\t\\t\\tsum1 += increment;\\n\\t\\t\\t\\tfreq1[ptr1]--;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsum2 -= decrement;\\n\\t\\t\\t\\tfreq2[ptr2]--;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1092228,
                "title": "straightforward-priorityqueue-java",
                "content": "```\\n  public int minOperations(int[] nums1, int[] nums2) {\\n    if (nums1.length > 6 * nums2.length || nums2.length > 6 * nums1.length) {\\n      return -1;\\n    }\\n    int sum1 = Arrays.stream(nums1).sum();\\n    int sum2 = Arrays.stream(nums2).sum();\\n    int diff = Math.abs(sum1 - sum2);\\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n    if (sum1 > sum2) {\\n      for (int num : nums1) {\\n        pq.add(num - 1);\\n      }\\n      for (int num : nums2) {\\n        pq.add(6 - num);\\n      }\\n    } else {\\n      for (int num : nums1) {\\n        pq.add(6 - num);\\n      }\\n      for (int num : nums2) {\\n        pq.add(num - 1);\\n      }\\n    }\\n    int minOps = 0;\\n    while (!pq.isEmpty() && diff > 0) {\\n      diff -= pq.poll();\\n      minOps++;\\n    }\\n    return diff > 0 ? -1 : minOps;\\n  }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n  public int minOperations(int[] nums1, int[] nums2) {\\n    if (nums1.length > 6 * nums2.length || nums2.length > 6 * nums1.length) {\\n      return -1;\\n    }\\n    int sum1 = Arrays.stream(nums1).sum();\\n    int sum2 = Arrays.stream(nums2).sum();\\n    int diff = Math.abs(sum1 - sum2);\\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n    if (sum1 > sum2) {\\n      for (int num : nums1) {\\n        pq.add(num - 1);\\n      }\\n      for (int num : nums2) {\\n        pq.add(6 - num);\\n      }\\n    } else {\\n      for (int num : nums1) {\\n        pq.add(6 - num);\\n      }\\n      for (int num : nums2) {\\n        pq.add(num - 1);\\n      }\\n    }\\n    int minOps = 0;\\n    while (!pq.isEmpty() && diff > 0) {\\n      diff -= pq.poll();\\n      minOps++;\\n    }\\n    return diff > 0 ? -1 : minOps;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1085969,
                "title": "o-nlogn-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            sum1+=nums1[i];\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            sum2+=nums2[i];\\n        }\\n        int tr=abs(sum1-sum2);\\n        int ans=0;\\n        if(nums1.size()>nums2.size())   \\n        {\\n            if(nums2.size()*6<nums1.size())\\n            {\\n                return -1;\\n            }\\n        }\\n        else\\n        {\\n            if(nums1.size()*6<nums2.size())\\n            {\\n                return -1;\\n            }\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n            if(sum1<sum2)\\n            {\\n                int li=0,ri=nums2.size()-1;\\n                while(li<nums1.size() && ri>=0 && tr>0)\\n                {\\n                    if(6-nums1[li]<nums2[ri]-1)\\n                    {\\n                        tr-=nums2[ri]-1;\\n                        ri--;\\n                    }\\n                    else\\n                    {\\n                        tr-=6-nums1[li];\\n                        li++;\\n                    }\\n                    ans+=1;\\n                }\\n                if(tr<=0)\\n                {\\n                    return ans;\\n                }\\n                while(li<nums1.size() && tr>0)\\n                {\\n                    tr-=6-nums1[li];\\n                    li++;\\n                    ans+=1;\\n                }\\n                if(tr<=0)\\n                {\\n                    return ans;\\n                }\\n                while(ri>=0 && tr>0)\\n                {\\n                    tr-=nums2[ri--]-1;\\n                    ans+=1;\\n                }\\n                if(tr<=0)\\n                {\\n                    return ans;\\n                }\\n                return -1;\\n            }\\n            else\\n            {\\n                int li=0,ri=nums1.size()-1;\\n                while(li<nums2.size() && ri>=0 && tr>0)\\n                {\\n                    if(6-nums2[li]<nums1[ri]-1)\\n                    {\\n                        tr-=nums1[ri]-1;\\n                        ri--;\\n                    }\\n                    else\\n                    {\\n                        tr-=6-nums2[li];\\n                        li++;\\n                    }\\n                    ans+=1;\\n                }\\n                if(tr<=0)\\n                {\\n                    return ans;\\n                }\\n                while(li<nums2.size() && tr>0)\\n                {\\n                    tr-=6-nums2[li];\\n                    li++;\\n                    ans+=1;\\n                }\\n                if(tr<=0)\\n                {\\n                    return ans;\\n                }\\n                while(ri>=0 && tr>0)\\n                {\\n                    tr-=nums1[ri--]-1;\\n                    ans+=1;\\n                }\\n                if(tr<=0)\\n                {\\n                    return ans;\\n                }\\n                return -1;\\n        }\\n        return 0;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            sum1+=nums1[i];\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            sum2+=nums2[i];\\n        }\\n        int tr=abs(sum1-sum2);\\n        int ans=0;\\n        if(nums1.size()>nums2.size())   \\n        {\\n            if(nums2.size()*6<nums1.size())\\n            {\\n                return -1;\\n            }\\n        }\\n        else\\n        {\\n            if(nums1.size()*6<nums2.size())\\n            {\\n                return -1;\\n            }\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n            if(sum1<sum2)\\n            {\\n                int li=0,ri=nums2.size()-1;\\n                while(li<nums1.size() && ri>=0 && tr>0)\\n                {\\n                    if(6-nums1[li]<nums2[ri]-1)\\n                    {\\n                        tr-=nums2[ri]-1;\\n                        ri--;\\n                    }\\n                    else\\n                    {\\n                        tr-=6-nums1[li];\\n                        li++;\\n                    }\\n                    ans+=1;\\n                }\\n                if(tr<=0)\\n                {\\n                    return ans;\\n                }\\n                while(li<nums1.size() && tr>0)\\n                {\\n                    tr-=6-nums1[li];\\n                    li++;\\n                    ans+=1;\\n                }\\n                if(tr<=0)\\n                {\\n                    return ans;\\n                }\\n                while(ri>=0 && tr>0)\\n                {\\n                    tr-=nums2[ri--]-1;\\n                    ans+=1;\\n                }\\n                if(tr<=0)\\n                {\\n                    return ans;\\n                }\\n                return -1;\\n            }\\n            else\\n            {\\n                int li=0,ri=nums1.size()-1;\\n                while(li<nums2.size() && ri>=0 && tr>0)\\n                {\\n                    if(6-nums2[li]<nums1[ri]-1)\\n                    {\\n                        tr-=nums1[ri]-1;\\n                        ri--;\\n                    }\\n                    else\\n                    {\\n                        tr-=6-nums2[li];\\n                        li++;\\n                    }\\n                    ans+=1;\\n                }\\n                if(tr<=0)\\n                {\\n                    return ans;\\n                }\\n                while(li<nums2.size() && tr>0)\\n                {\\n                    tr-=6-nums2[li];\\n                    li++;\\n                    ans+=1;\\n                }\\n                if(tr<=0)\\n                {\\n                    return ans;\\n                }\\n                while(ri>=0 && tr>0)\\n                {\\n                    tr-=nums1[ri--]-1;\\n                    ans+=1;\\n                }\\n                if(tr<=0)\\n                {\\n                    return ans;\\n                }\\n                return -1;\\n        }\\n        return 0;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085796,
                "title": "java-clean-sort-two-pointers",
                "content": "```\\n public int minOperations(int[] nums1, int[] nums2) {\\n        if(nums1.length > nums2.length * 6) return -1;\\n        if(nums2.length > nums1.length * 6) return -1;\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for(int num : nums1) sum1 += num;\\n        for(int num : nums2) sum2 += num;\\n        if(sum1 == sum2) return 0;\\n        int diff = Math.abs(sum1 - sum2);\\n        if(sum1 < sum2) return getStep(nums1, nums2, diff);\\n        return getStep(nums2, nums1, diff);\\n    }\\n    \\n    public int getStep(int[] nums1, int[] nums2, int diff){\\n        int step = 0, i = 0, j = nums2.length - 1;\\n        while(diff > 0){\\n           int maxIncrease = i < nums1.length? 6 - nums1[i]: -1;\\n           int maxDecrease = j >= 0 ? nums2[j] - 1 : -1;\\n           if(maxIncrease >= diff || maxDecrease >= diff) return step + 1;\\n           if(maxIncrease > maxDecrease){\\n               diff -= maxIncrease;\\n               i++;\\n           }else{\\n               diff -= maxDecrease;\\n               j--;\\n           }\\n           step++;\\n        }\\n        return step;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int minOperations(int[] nums1, int[] nums2) {\\n        if(nums1.length > nums2.length * 6) return -1;\\n        if(nums2.length > nums1.length * 6) return -1;\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for(int num : nums1) sum1 += num;\\n        for(int num : nums2) sum2 += num;\\n        if(sum1 == sum2) return 0;\\n        int diff = Math.abs(sum1 - sum2);\\n        if(sum1 < sum2) return getStep(nums1, nums2, diff);\\n        return getStep(nums2, nums1, diff);\\n    }\\n    \\n    public int getStep(int[] nums1, int[] nums2, int diff){\\n        int step = 0, i = 0, j = nums2.length - 1;\\n        while(diff > 0){\\n           int maxIncrease = i < nums1.length? 6 - nums1[i]: -1;\\n           int maxDecrease = j >= 0 ? nums2[j] - 1 : -1;\\n           if(maxIncrease >= diff || maxDecrease >= diff) return step + 1;\\n           if(maxIncrease > maxDecrease){\\n               diff -= maxIncrease;\\n               i++;\\n           }else{\\n               diff -= maxDecrease;\\n               j--;\\n           }\\n           step++;\\n        }\\n        return step;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850903,
                "title": "c-solution-o-n-histogram-the-only-c-solution-so-it-s-the-fastest",
                "content": "# Intuition\\nMake a histogram of the absolute potential of each value.\\n\\n# Approach\\nFind the sum of each array.  Consider one array as the larger and the other as the smaller based on sums.  Use function parameters to sort this out to keep it simple.  Build a histogram of the combined absolute potential values in both arrays.  \\n\\nThe potential of a value is the maximum absolute change the value can make towards making the array sums equal.  For example a 1 in the smaller array has a potential of 5 since it can be changed to 6, a 6 in the larger array also has a potential of 5 because it can change to 1.\\n\\nDigest the histogram from smallest to largest until the difference of sums of the arrays is zero.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(0)$$\\n\\n# Code\\n```\\nint getSum(int *n, int s)\\n{\\n    int sum = 0;\\n    while(s--) sum += *n++;\\n    return sum;\\n}\\n\\n// Check if the max sum of the smaller array is at least the min sum of the larger array\\nbool canDo(int s1, int s2)\\n{\\n    return s1 < s2 ? s1 * 6 >= s2 : s2 * 6 >= s1;\\n}\\n\\nint countOperations(int diff, int *map)\\n{\\n    int operations = 0;\\n\\n    // Subtract absolute values from the difference starting with the largest\\n    for(int i = 5; i > 0; i--) // Count down starting with the largest differences\\n    {\\n        if(map[i] * i < diff)  // more work to do\\n        {\\n            operations += map[i];\\n            diff -= map[i] * i;\\n        }\\n        else // can get the work done with these numbers\\n        {\\n            operations += ceil((float)diff / i);  // Maybe didn\\'t need all of them\\n            diff = 0;\\n            return operations;\\n        }\\n    }\\n\\n    return -1; // Couldn\\'t get it done\\n}\\n\\n// Assume n1 has the larger sum, passing diff to not waste time recalculating\\nint minOperationsOrdered(int *n1, int s1, int *n2, int s2, int diff)\\n{\\n    // Build a histogram of absolute potential for each value\\n    int map[7] = { 0 };    \\n    while(s1--) map[*n1++ - 1]++;\\n    while(s2--) map[6 - *n2++]++;\\n\\n    return countOperations(diff, map);\\n}\\n\\nint minOperations(int *n1, int s1, int *n2, int s2)\\n{\\n    if(!canDo(s1, s2)) return -1;\\n    int diff = getSum(n1, s1) - getSum(n2, s2);\\n    \\n    // Build a histogram of absolute potential for each value\\n    if(diff > 0) // n1 has a larger sum\\n    {\\n        return minOperationsOrdered(n1, s1, n2, s2, diff);\\n    }\\n    else // n2 has a larger sum\\n    {\\n        return minOperationsOrdered(n2, s2, n1, s1, -diff);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint getSum(int *n, int s)\\n{\\n    int sum = 0;\\n    while(s--) sum += *n++;\\n    return sum;\\n}\\n\\n// Check if the max sum of the smaller array is at least the min sum of the larger array\\nbool canDo(int s1, int s2)\\n{\\n    return s1 < s2 ? s1 * 6 >= s2 : s2 * 6 >= s1;\\n}\\n\\nint countOperations(int diff, int *map)\\n{\\n    int operations = 0;\\n\\n    // Subtract absolute values from the difference starting with the largest\\n    for(int i = 5; i > 0; i--) // Count down starting with the largest differences\\n    {\\n        if(map[i] * i < diff)  // more work to do\\n        {\\n            operations += map[i];\\n            diff -= map[i] * i;\\n        }\\n        else // can get the work done with these numbers\\n        {\\n            operations += ceil((float)diff / i);  // Maybe didn\\'t need all of them\\n            diff = 0;\\n            return operations;\\n        }\\n    }\\n\\n    return -1; // Couldn\\'t get it done\\n}\\n\\n// Assume n1 has the larger sum, passing diff to not waste time recalculating\\nint minOperationsOrdered(int *n1, int s1, int *n2, int s2, int diff)\\n{\\n    // Build a histogram of absolute potential for each value\\n    int map[7] = { 0 };    \\n    while(s1--) map[*n1++ - 1]++;\\n    while(s2--) map[6 - *n2++]++;\\n\\n    return countOperations(diff, map);\\n}\\n\\nint minOperations(int *n1, int s1, int *n2, int s2)\\n{\\n    if(!canDo(s1, s2)) return -1;\\n    int diff = getSum(n1, s1) - getSum(n2, s2);\\n    \\n    // Build a histogram of absolute potential for each value\\n    if(diff > 0) // n1 has a larger sum\\n    {\\n        return minOperationsOrdered(n1, s1, n2, s2, diff);\\n    }\\n    else // n2 has a larger sum\\n    {\\n        return minOperationsOrdered(n2, s2, n1, s1, -diff);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3091255,
                "title": "c-complete-noise-keep-minimizing-difference",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& n1, vector<int>& n2) {\\n        if (6 * min(n1.size(), n2.size()) <  max(n1.size(), n2.size()) ) return -1;\\n        \\n        int sum1 = accumulate(begin(n1), end(n1), 0), sum2 = accumulate(begin(n2), end(n2), 0);\\n        if (sum1 > sum2) swap(n1, n2);\\n        \\n        priority_queue <int, vector<int>, greater<int>> q1(begin(n1), end(n1));\\n        priority_queue<int> q2(begin(n2), end(n2));\\n        \\n        int cnt = 0, diff = abs(sum1 - sum2);\\n        while (diff > 0 && q1.size() && q2.size()) {\\n            ++cnt;\\n            auto greaterToLess = q2.top() - 1, lessToGreater = 6 - q1.top();\\n            if (greaterToLess > lessToGreater) diff -= greaterToLess, q2.pop();\\n            else diff -= lessToGreater, q1.pop();\\n        }\\n        while (diff > 0 && q1.size()) diff -= 6 - q1.top(), q1.pop(), cnt++;\\n        while (diff > 0 && q2.size()) diff -= q2.top() - 1, q2.pop(), cnt++;\\n        return diff > 0 ? -1: cnt;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& n1, vector<int>& n2) {\\n        if (6 * min(n1.size(), n2.size()) <  max(n1.size(), n2.size()) ) return -1;\\n        \\n        int sum1 = accumulate(begin(n1), end(n1), 0), sum2 = accumulate(begin(n2), end(n2), 0);\\n        if (sum1 > sum2) swap(n1, n2);\\n        \\n        priority_queue <int, vector<int>, greater<int>> q1(begin(n1), end(n1));\\n        priority_queue<int> q2(begin(n2), end(n2));\\n        \\n        int cnt = 0, diff = abs(sum1 - sum2);\\n        while (diff > 0 && q1.size() && q2.size()) {\\n            ++cnt;\\n            auto greaterToLess = q2.top() - 1, lessToGreater = 6 - q1.top();\\n            if (greaterToLess > lessToGreater) diff -= greaterToLess, q2.pop();\\n            else diff -= lessToGreater, q1.pop();\\n        }\\n        while (diff > 0 && q1.size()) diff -= 6 - q1.top(), q1.pop(), cnt++;\\n        while (diff > 0 && q2.size()) diff -= q2.top() - 1, q2.pop(), cnt++;\\n        return diff > 0 ? -1: cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875336,
                "title": "python-short-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate the difference in sum between the two lists. Then put them in the same heap. Pull the biggest difference maker each time from the heap until you compensate for the difference or run the heap out of items.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmax heap is used so everything needs to be negative in python. When calculating how big of a difference a number can make in your calculation need to see how close it is to either 6 or 1. Also need to determine which direction it should go to get you closer to zeroing out the difference.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) where n is the total length of list1 + list2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        diff, cnt = sum(nums2) - sum(nums1), 0\\n        \\n        if diff == 0:\\n            return 0\\n        if diff < 0:\\n            combo = [num - 6 for num in nums2] + [1 - num for num in nums1]\\n            diff = -diff\\n        else:\\n            combo = [num - 6 for num in nums1] + [1 - num for num in nums2]\\n        heapq.heapify(combo)\\n        while diff > 0 and combo:\\n            diff += heapq.heappop(combo)\\n            cnt += 1\\n\\n        return cnt if cnt and diff <= 0 else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        diff, cnt = sum(nums2) - sum(nums1), 0\\n        \\n        if diff == 0:\\n            return 0\\n        if diff < 0:\\n            combo = [num - 6 for num in nums2] + [1 - num for num in nums1]\\n            diff = -diff\\n        else:\\n            combo = [num - 6 for num in nums1] + [1 - num for num in nums2]\\n        heapq.heapify(combo)\\n        while diff > 0 and combo:\\n            diff += heapq.heappop(combo)\\n            cnt += 1\\n\\n        return cnt if cnt and diff <= 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805402,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n1 = nums1.size();\\n\\n        int n2 = nums2.size();\\n\\n\\n        int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n\\n\\n        int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n\\n\\n        priority_queue<int> pq;\\n\\n\\n        if(sum1 > sum2)\\n        {\\n\\n            for(int i = 0; i < n1; i++)\\n            {\\n                pq.push(nums1[i] - 1);\\n            }\\n\\n\\n            for(int i = 0; i < n2; i++)\\n            {\\n                pq.push(6 - nums2[i]);\\n            }\\n        }\\n\\n        \\n        else\\n        {\\n\\n            for(int i = 0; i < n1; i++)\\n            {\\n                pq.push(6 - nums1[i]);\\n            }\\n\\n\\n            for(int i = 0; i < n2; i++)\\n            {\\n                pq.push(nums2[i] - 1);\\n            }\\n        }\\n\\n        int diff = abs(sum1 - sum2);\\n\\n        int count = 0;\\n\\n\\n        while(diff > 0 && pq.size())\\n        {\\n            int top = pq.top();\\n\\n            pq.pop();\\n\\n\\n            diff -= min(diff, top);\\n\\n\\n            count++;\\n        }\\n\\n        if(diff > 0)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return count;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n1 = nums1.size();\\n\\n        int n2 = nums2.size();\\n\\n\\n        int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n\\n\\n        int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n\\n\\n        priority_queue<int> pq;\\n\\n\\n        if(sum1 > sum2)\\n        {\\n\\n            for(int i = 0; i < n1; i++)\\n            {\\n                pq.push(nums1[i] - 1);\\n            }\\n\\n\\n            for(int i = 0; i < n2; i++)\\n            {\\n                pq.push(6 - nums2[i]);\\n            }\\n        }\\n\\n        \\n        else\\n        {\\n\\n            for(int i = 0; i < n1; i++)\\n            {\\n                pq.push(6 - nums1[i]);\\n            }\\n\\n\\n            for(int i = 0; i < n2; i++)\\n            {\\n                pq.push(nums2[i] - 1);\\n            }\\n        }\\n\\n        int diff = abs(sum1 - sum2);\\n\\n        int count = 0;\\n\\n\\n        while(diff > 0 && pq.size())\\n        {\\n            int top = pq.top();\\n\\n            pq.pop();\\n\\n\\n            diff -= min(diff, top);\\n\\n\\n            count++;\\n        }\\n\\n        if(diff > 0)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return count;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662674,
                "title": "go-counting-o-n-m-o-1",
                "content": "The amount of difference between sums changed by one operation  is `[1, 5]`.\\n\\nTo minimize the number of operations, we start from 5 to 1.\\n\\nn: Length of the input array `nums1`\\nm: Length of the input array `nums2`\\nTime: **O(n+m)**\\nExtra Space: **O(1)**\\n\\n```\\nfunc minOperations(nums1 []int, nums2 []int) int {\\n\\tn := len(nums1)\\n\\tm := len(nums2)\\n\\tif n > 6*m || m > 6*n {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tsum1 := sumOf(nums1)\\n\\tsum2 := sumOf(nums2)\\n\\n\\tcnts1 := cntsOf(nums1)\\n\\tcnts2 := cntsOf(nums2)\\n\\n\\tif sum2 > sum1 {\\n\\t\\tcnts1, cnts2 = cnts2, cnts1\\n\\t\\tsum1, sum2 = sum2, sum1\\n\\t}\\n\\n\\tdiff := sum1 - sum2\\n\\tres := 0\\n\\n\\tfor d := 5; d >= 1; d-- {\\n\\t\\tnum := d + 1\\n\\t\\tnum2 := 6 - d\\n\\n\\t\\tcnt := cnts1[num] + cnts2[num2]\\n\\n\\t\\tif cnt*d >= diff {\\n\\t\\t\\tres += diff / d\\n\\t\\t\\tif diff%d > 0 {\\n\\t\\t\\t\\tres++\\n\\t\\t\\t}\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tdiff -= cnt * d\\n\\t\\tres += cnt\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc cntsOf(nums []int) []int {\\n\\tres := make([]int, 7)\\n\\tfor i := range nums {\\n\\t\\tres[nums[i]]++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc sumOf(nums []int) int {\\n\\tres := 0\\n\\tfor i := range nums {\\n\\t\\tres += nums[i]\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minOperations(nums1 []int, nums2 []int) int {\\n\\tn := len(nums1)\\n\\tm := len(nums2)\\n\\tif n > 6*m || m > 6*n {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tsum1 := sumOf(nums1)\\n\\tsum2 := sumOf(nums2)\\n\\n\\tcnts1 := cntsOf(nums1)\\n\\tcnts2 := cntsOf(nums2)\\n\\n\\tif sum2 > sum1 {\\n\\t\\tcnts1, cnts2 = cnts2, cnts1\\n\\t\\tsum1, sum2 = sum2, sum1\\n\\t}\\n\\n\\tdiff := sum1 - sum2\\n\\tres := 0\\n\\n\\tfor d := 5; d >= 1; d-- {\\n\\t\\tnum := d + 1\\n\\t\\tnum2 := 6 - d\\n\\n\\t\\tcnt := cnts1[num] + cnts2[num2]\\n\\n\\t\\tif cnt*d >= diff {\\n\\t\\t\\tres += diff / d\\n\\t\\t\\tif diff%d > 0 {\\n\\t\\t\\t\\tres++\\n\\t\\t\\t}\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tdiff -= cnt * d\\n\\t\\tres += cnt\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc cntsOf(nums []int) []int {\\n\\tres := make([]int, 7)\\n\\tfor i := range nums {\\n\\t\\tres[nums[i]]++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc sumOf(nums []int) int {\\n\\tres := 0\\n\\tfor i := range nums {\\n\\t\\tres += nums[i]\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2584568,
                "title": "python-olution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = sum(nums1), sum(nums2)\\n        dif = abs(s1-s2)\\n        if s1 > s2:\\n            greater, lower = nums1, nums2\\n        else:\\n            greater, lower = nums2, nums1\\n        up, down = 0,0\\n        d = []\\n        for i in greater:\\n            down += (i-1)\\n            d.append(i-1)\\n        for i in lower:\\n            up += (6-i)\\n            d.append(6-i)\\n        d = sorted(d,reverse=True)\\n        if dif <= (up+down):\\n            j = 0\\n            while dif > 0:\\n                dif -= d[j]\\n                j += 1\\n        else:\\n            return -1\\n        return j\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = sum(nums1), sum(nums2)\\n        dif = abs(s1-s2)\\n        if s1 > s2:\\n            greater, lower = nums1, nums2\\n        else:\\n            greater, lower = nums2, nums1\\n        up, down = 0,0\\n        d = []\\n        for i in greater:\\n            down += (i-1)\\n            d.append(i-1)\\n        for i in lower:\\n            up += (6-i)\\n            d.append(6-i)\\n        d = sorted(d,reverse=True)\\n        if dif <= (up+down):\\n            j = 0\\n            while dif > 0:\\n                dif -= d[j]\\n                j += 1\\n        else:\\n            return -1\\n        return j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581703,
                "title": "java-2-sols-explained-in-detail-o-nlogn-to-o-n-explained",
                "content": "// Solution 1: Using PQ\\n\\n// TC : (mlogm + nlogn); m = nums1.length, n = nums2.length \\n// SC : O(m + n)\\n```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int num : nums1) {\\n            sum1 += num;\\n        }\\n        \\n        for(int num : nums2) {\\n            sum2 += num;\\n        }\\n        \\n        return sum1 > sum2 ? helper(nums1, nums2, sum1 - sum2) : helper(nums2, nums1, sum2 - sum1);\\n    }\\n    \\n    private int helper(int[] largeSum, int[] smallSum, int diff) {\\n        if(largeSum.length > smallSum.length * 6) return -1;\\n        int res = 0;\\n        \\n        PriorityQueue<Integer> minQue = new PriorityQueue<>(); // min que for smallSum array, so min element at top (we will try to maximize the smallest element)\\n        PriorityQueue<Integer> maxQue = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int num : smallSum) { // takes mlogm time\\n            minQue.add(num);\\n        }\\n        \\n        for(int num : largeSum) { // take nlogn time\\n            maxQue.add(num);\\n        }\\n        \\n        while(diff > 0) {\\n            // we should either decrease sum1(of largeSum[]) or increase sum2(of smallSum[])\\n            // inc the sum2 by 6 - minQue.peek() (the peek() has the smallest element and to MAX inc the sum we need to increase the minimum numbers; the max element we can make is 6, so if we have 2 at peek then max sum inc is 6 - 2 = 4)\\n            // dec the sum1 by maxQue.peek() - 1 (the peek() has the largest element and if by making smallest element of minQue to maximum possible if that makes it greater than we should change that)\\n            if(!minQue.isEmpty() && 6 - minQue.peek() >= maxQue.peek() - 1) {\\n                diff -= 6 - minQue.poll(); // if 6 - minQue.peek() >= maxQue.peek() - 1, we should decrease the diff by 6 - minQue.poll() because we need to REDUCE the diff to 0 FASTEST (so take larger)\\n            } else {\\n                diff -= maxQue.poll() - 1; // if  maxQue.peek() - 1 > 6 - minQue.peek(), then decrease the diff by maxQue.poll() - 1 because we need to REDUCE the diff to 0 FASTEST (so take larger)\\n            }\\n            res++; // this is 1 step we took\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n// Solution 2: Without using PQ\\n\\n// TC : O(N + M); N = nums1.length, M = nums2.length\\n// SC : O(6)\\n```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int num : nums1) {\\n            sum1 += num;\\n        }\\n        \\n        for(int num : nums2) {\\n            sum2 += num;\\n        }\\n        \\n        return sum1 > sum2 ? helper(nums1, nums2, sum1 - sum2) : helper(nums2, nums1, sum2 - sum1);\\n    }\\n    \\n    private int helper(int[] largeSum, int[] smallSum, int diff) {\\n        if(largeSum.length > smallSum.length * 6) return -1;\\n        int res = 0;\\n        // freq of numbers that can reduce the diff by \\'i\\'\\n        // cntNumThatReduceDiffByI[5] means HOW MANY NUMBERS are there which can help in reducing the total diff by 5\\n        int[] cntNumThatReduceDiffByI = new int[6];\\n        \\n        for(int num : smallSum) { // takes m time\\n            cntNumThatReduceDiffByI[6 - num]++; // to reduce the diff, INC the elements of the array which is less in sum\\n        }\\n        \\n        for(int num : largeSum) { // take n time\\n            cntNumThatReduceDiffByI[num - 1]++; // to reduce the diff, DEC the elements of the array which is higher in sum\\n        }\\n        \\n        // Since we need to find MINIMUM op, so start REDUCING the DIFF with changing BIGGER numbers\\n        for(int i = 5; i >= 0; i--) {\\n            // how many operation we would require to completely REDUCE the DIFF by utilizing the present\\n            // diff / i = how many operations to reducde the diff if we reduce it by \\'i\\'\\n            // diff % i = does something remains if we reduce the diff by above operation\\n            int numOpToCompletelyUseI = (diff / i) + (diff % i != 0 ? 1 : 0);\\n            int opToReduceDiff = Math.min(cntNumThatReduceDiffByI[i], numOpToCompletelyUseI);\\n            \\n            res += opToReduceDiff; \\n            diff -= opToReduceDiff * i; // diff is reduced by how many num of \\'i\\' we take * i\\n            \\n            if(diff <= 0) break; // if we have reduced the diff, come out of for loop\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int num : nums1) {\\n            sum1 += num;\\n        }\\n        \\n        for(int num : nums2) {\\n            sum2 += num;\\n        }\\n        \\n        return sum1 > sum2 ? helper(nums1, nums2, sum1 - sum2) : helper(nums2, nums1, sum2 - sum1);\\n    }\\n    \\n    private int helper(int[] largeSum, int[] smallSum, int diff) {\\n        if(largeSum.length > smallSum.length * 6) return -1;\\n        int res = 0;\\n        \\n        PriorityQueue<Integer> minQue = new PriorityQueue<>(); // min que for smallSum array, so min element at top (we will try to maximize the smallest element)\\n        PriorityQueue<Integer> maxQue = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int num : smallSum) { // takes mlogm time\\n            minQue.add(num);\\n        }\\n        \\n        for(int num : largeSum) { // take nlogn time\\n            maxQue.add(num);\\n        }\\n        \\n        while(diff > 0) {\\n            // we should either decrease sum1(of largeSum[]) or increase sum2(of smallSum[])\\n            // inc the sum2 by 6 - minQue.peek() (the peek() has the smallest element and to MAX inc the sum we need to increase the minimum numbers; the max element we can make is 6, so if we have 2 at peek then max sum inc is 6 - 2 = 4)\\n            // dec the sum1 by maxQue.peek() - 1 (the peek() has the largest element and if by making smallest element of minQue to maximum possible if that makes it greater than we should change that)\\n            if(!minQue.isEmpty() && 6 - minQue.peek() >= maxQue.peek() - 1) {\\n                diff -= 6 - minQue.poll(); // if 6 - minQue.peek() >= maxQue.peek() - 1, we should decrease the diff by 6 - minQue.poll() because we need to REDUCE the diff to 0 FASTEST (so take larger)\\n            } else {\\n                diff -= maxQue.poll() - 1; // if  maxQue.peek() - 1 > 6 - minQue.peek(), then decrease the diff by maxQue.poll() - 1 because we need to REDUCE the diff to 0 FASTEST (so take larger)\\n            }\\n            res++; // this is 1 step we took\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int sum1 = 0, sum2 = 0;\\n        for(int num : nums1) {\\n            sum1 += num;\\n        }\\n        \\n        for(int num : nums2) {\\n            sum2 += num;\\n        }\\n        \\n        return sum1 > sum2 ? helper(nums1, nums2, sum1 - sum2) : helper(nums2, nums1, sum2 - sum1);\\n    }\\n    \\n    private int helper(int[] largeSum, int[] smallSum, int diff) {\\n        if(largeSum.length > smallSum.length * 6) return -1;\\n        int res = 0;\\n        // freq of numbers that can reduce the diff by \\'i\\'\\n        // cntNumThatReduceDiffByI[5] means HOW MANY NUMBERS are there which can help in reducing the total diff by 5\\n        int[] cntNumThatReduceDiffByI = new int[6];\\n        \\n        for(int num : smallSum) { // takes m time\\n            cntNumThatReduceDiffByI[6 - num]++; // to reduce the diff, INC the elements of the array which is less in sum\\n        }\\n        \\n        for(int num : largeSum) { // take n time\\n            cntNumThatReduceDiffByI[num - 1]++; // to reduce the diff, DEC the elements of the array which is higher in sum\\n        }\\n        \\n        // Since we need to find MINIMUM op, so start REDUCING the DIFF with changing BIGGER numbers\\n        for(int i = 5; i >= 0; i--) {\\n            // how many operation we would require to completely REDUCE the DIFF by utilizing the present\\n            // diff / i = how many operations to reducde the diff if we reduce it by \\'i\\'\\n            // diff % i = does something remains if we reduce the diff by above operation\\n            int numOpToCompletelyUseI = (diff / i) + (diff % i != 0 ? 1 : 0);\\n            int opToReduceDiff = Math.min(cntNumThatReduceDiffByI[i], numOpToCompletelyUseI);\\n            \\n            res += opToReduceDiff; \\n            diff -= opToReduceDiff * i; // diff is reduced by how many num of \\'i\\' we take * i\\n            \\n            if(diff <= 0) break; // if we have reduced the diff, come out of for loop\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489662,
                "title": "c-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int a=0,b=0;\\n        vector<int>res;\\n        for(int x:nums1){\\n            a+=x;\\n        }\\n        for(int x:nums2){\\n            b+=x;\\n        }\\n        if(a>b){\\n            swap(nums1,nums2);\\n            swap(a,b);\\n        }\\n        int diff=b-a;\\n        if(diff==0){\\n            return 0;\\n        }\\n        for(int x:nums1){\\n            res.push_back(6-x);\\n        }\\n        for(int x:nums2){\\n            res.push_back(x-1);\\n        }\\n        int ans=0;\\n        sort(res.begin(),res.end(),greater<int>());\\n        for(int i=0;i<res.size();i++){\\n            ans++;\\n            diff-=res[i];\\n            if(diff<=0){\\n                return ans;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\'\\'\\'\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int a=0,b=0;\\n        vector<int>res;\\n        for(int x:nums1){\\n            a+=x;\\n        }\\n        for(int x:nums2){\\n            b+=x;\\n        }\\n        if(a>b){\\n            swap(nums1,nums2);\\n            swap(a,b);\\n        }\\n        int diff=b-a;\\n        if(diff==0){\\n            return 0;\\n        }\\n        for(int x:nums1){\\n            res.push_back(6-x);\\n        }\\n        for(int x:nums2){\\n            res.push_back(x-1);\\n        }\\n        int ans=0;\\n        sort(res.begin(),res.end(),greater<int>());\\n        for(int i=0;i<res.size();i++){\\n            ans++;\\n            diff-=res[i];\\n            if(diff<=0){\\n                return ans;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\'\\'\\'\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322208,
                "title": "python-simple-maths",
                "content": "\\n    def minOperations(self, nums1, nums2):\\n        total1, total2 = sum(nums1), sum(nums2)\\n        nums_smaller, nums_larger = (nums1, nums2) if total1 < total2 else (nums2, nums1)\\n        ans = sorted([x - 1 for x in nums_larger] + [6 - x for x in nums_smaller], reverse = True)\\n        diff = abs(total1 - total2)\\n        \\n        if diff == 0:\\n            return 0\\n        else:\\n            for idx, num in enumerate(ans):\\n                diff -= num\\n            \\n                if diff <= 0:\\n                    return idx + 1\\n            \\n            if diff <= 0:\\n                return len(ans)\\n        \\n            return -1",
                "solutionTags": [],
                "code": "\\n    def minOperations(self, nums1, nums2):\\n        total1, total2 = sum(nums1), sum(nums2)\\n        nums_smaller, nums_larger = (nums1, nums2) if total1 < total2 else (nums2, nums1)\\n        ans = sorted([x - 1 for x in nums_larger] + [6 - x for x in nums_smaller], reverse = True)\\n        diff = abs(total1 - total2)\\n        \\n        if diff == 0:\\n            return 0\\n        else:\\n            for idx, num in enumerate(ans):\\n                diff -= num\\n            \\n                if diff <= 0:\\n                    return idx + 1\\n            \\n            if diff <= 0:\\n                return len(ans)\\n        \\n            return -1",
                "codeTag": "Python3"
            },
            {
                "id": 2287618,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        //obtain the difference vector then 6-i for smaller vector and i-1 for the larger vector\\n        //sort greatest element first\\n        //try to reduce one by one\\n        //once the diff is 0 or leess than 0 return count\\n        int sum1=accumulate(nums1.begin(),nums1.end(),0);\\n        int sum2=accumulate(nums2.begin(),nums2.end(),0);\\n        if(sum1>sum2)return minOperations(nums2,nums1);\\n        //the diff vector\\n        vector<int>diff;\\n        int c=0,d=sum2-sum1;\\n        if(d==0)return 0;\\n        for(auto i:nums1)diff.push_back(6-i);\\n        for(auto i:nums2)diff.push_back(i-1);\\n        sort(diff.begin(),diff.end(),greater<int>());\\n        for(auto i:diff){\\n            d-=i;\\n            c++;\\n            if(d<=0)return c;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        //obtain the difference vector then 6-i for smaller vector and i-1 for the larger vector\\n        //sort greatest element first\\n        //try to reduce one by one\\n        //once the diff is 0 or leess than 0 return count\\n        int sum1=accumulate(nums1.begin(),nums1.end(),0);\\n        int sum2=accumulate(nums2.begin(),nums2.end(),0);\\n        if(sum1>sum2)return minOperations(nums2,nums1);\\n        //the diff vector\\n        vector<int>diff;\\n        int c=0,d=sum2-sum1;\\n        if(d==0)return 0;\\n        for(auto i:nums1)diff.push_back(6-i);\\n        for(auto i:nums2)diff.push_back(i-1);\\n        sort(diff.begin(),diff.end(),greater<int>());\\n        for(auto i:diff){\\n            d-=i;\\n            c++;\\n            if(d<=0)return c;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192558,
                "title": "python3-explained-using-2-priority-queues",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        ## RC ##\\n        ## LOGIC ##\\n        # GIST: Will an increment +5 on nums1 or decrement -5 on nums2 makes more difference ? ##\\n        # 1. Take 2 priority queues, one max heap(store elements of higher sum nums arr ) and other min heap( store elements of lesser sum nums arr)\\n        # 2. we are looking to minimize the difference here, so will substracting some number to max_heap will bring big change or adding some number to min_heap will bring big change ?\\n        # 3. so, compute the big change for that iteration, substract it from main diff, when diff becomes 0, then exit\\n\\n        \\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if(s1 < s2):\\n            pq_max=[ -x for x in nums2 ]\\n            pq_min=nums1\\n        elif(s2 < s1):\\n            pq_max=[ -x for x in nums1 ]\\n            pq_min=nums2\\n        else:\\n            return 0\\n        \\n        heapq.heapify(pq_max)\\n        heapq.heapify(pq_min)\\n        \\n        diff = abs(sum(nums1) - sum(nums2))\\n        res = 0\\n        prev_diff = float(\\'inf\\')\\n        while(diff > 0):\\n            \\n            if diff == prev_diff:\\n                return -1\\n            \\n            # peek max and min elements from priority queues\\n            max_ele = -1 * pq_max[0]\\n            min_ele = pq_min[0]\\n            \\n            # maximum number that you can substract from max_heap element\\n            max_change = max_ele - 1\\n            # max number that you can add to min heap element\\n            min_change = 6 - min_ele\\n            \\n            if max_change > diff:\\n                max_change = diff\\n            if min_change > diff:\\n                min_change = diff\\n            \\n            if max_change > min_change:\\n                # pull out max element, update it and push it back\\n                heapq.heappop(pq_max)\\n                heapq.heappush(pq_max, (-1 * max_ele) + max_change)\\n            else:\\n                # pull out min element, update it and push it back\\n                heapq.heappop(pq_min)\\n                heapq.heappush(pq_min, min_ele + min_change)\\n            \\n            # previous diff is to just check invalid cases, if you cannot do another in one loop, you can exit and return -1\\n            prev_diff = diff\\n            # chose the element which produces big difference\\n            diff -= max(max_change, min_change)\\n            # count number of iterations\\n            res += 1\\n            if diff==0:\\n                return res\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        ## RC ##\\n        ## LOGIC ##\\n        # GIST: Will an increment +5 on nums1 or decrement -5 on nums2 makes more difference ? ##\\n        # 1. Take 2 priority queues, one max heap(store elements of higher sum nums arr ) and other min heap( store elements of lesser sum nums arr)\\n        # 2. we are looking to minimize the difference here, so will substracting some number to max_heap will bring big change or adding some number to min_heap will bring big change ?\\n        # 3. so, compute the big change for that iteration, substract it from main diff, when diff becomes 0, then exit\\n\\n        \\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if(s1 < s2):\\n            pq_max=[ -x for x in nums2 ]\\n            pq_min=nums1\\n        elif(s2 < s1):\\n            pq_max=[ -x for x in nums1 ]\\n            pq_min=nums2\\n        else:\\n            return 0\\n        \\n        heapq.heapify(pq_max)\\n        heapq.heapify(pq_min)\\n        \\n        diff = abs(sum(nums1) - sum(nums2))\\n        res = 0\\n        prev_diff = float(\\'inf\\')\\n        while(diff > 0):\\n            \\n            if diff == prev_diff:\\n                return -1\\n            \\n            # peek max and min elements from priority queues\\n            max_ele = -1 * pq_max[0]\\n            min_ele = pq_min[0]\\n            \\n            # maximum number that you can substract from max_heap element\\n            max_change = max_ele - 1\\n            # max number that you can add to min heap element\\n            min_change = 6 - min_ele\\n            \\n            if max_change > diff:\\n                max_change = diff\\n            if min_change > diff:\\n                min_change = diff\\n            \\n            if max_change > min_change:\\n                # pull out max element, update it and push it back\\n                heapq.heappop(pq_max)\\n                heapq.heappush(pq_max, (-1 * max_ele) + max_change)\\n            else:\\n                # pull out min element, update it and push it back\\n                heapq.heappop(pq_min)\\n                heapq.heappush(pq_min, min_ele + min_change)\\n            \\n            # previous diff is to just check invalid cases, if you cannot do another in one loop, you can exit and return -1\\n            prev_diff = diff\\n            # chose the element which produces big difference\\n            diff -= max(max_change, min_change)\\n            # count number of iterations\\n            res += 1\\n            if diff==0:\\n                return res\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922921,
                "title": "python3-without-sorting-o-n",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        left,right=sum(nums1),sum(nums2)\\n        if left==right: return 0\\n        if right<left:\\n            nums1,nums2=nums2,nums1\\n            left,right=right,left\\n        dct1=collections.Counter(nums1)\\n        dct2=collections.Counter(nums2)\\n        res=0\\n        while left<right:\\n            mn=min(dct1) if dct1 else 6\\n            mx=max(dct2) if dct2 else 1\\n            val1=6-mn\\n            val2=mx-1\\n            if val1==val2==0: return -1\\n            if val1>val2:\\n                left+=val1\\n                dct1[mn]-=1\\n                if dct1[mn]==0: del dct1[mn]\\n            else:\\n                right-=val2\\n                dct2[mx]-=1 \\n                if dct2[mx]==0: del dct2[mx]\\n            res+=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        left,right=sum(nums1),sum(nums2)\\n        if left==right: return 0\\n        if right<left:\\n            nums1,nums2=nums2,nums1\\n            left,right=right,left\\n        dct1=collections.Counter(nums1)\\n        dct2=collections.Counter(nums2)\\n        res=0\\n        while left<right:\\n            mn=min(dct1) if dct1 else 6\\n            mx=max(dct2) if dct2 else 1\\n            val1=6-mn\\n            val2=mx-1\\n            if val1==val2==0: return -1\\n            if val1>val2:\\n                left+=val1\\n                dct1[mn]-=1\\n                if dct1[mn]==0: del dct1[mn]\\n            else:\\n                right-=val2\\n                dct2[mx]-=1 \\n                if dct2[mx]==0: del dct2[mx]\\n            res+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696665,
                "title": "c-greedy-with-intution",
                "content": "you just need to see greedily at each point that which of the two arrays will take us closer to the other one\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>&A, vector<int>&B) {\\n        int n1 = A.size();\\n        int n2 = B.size();\\n        int sum1 = accumulate(A.begin(),A.end(),0);\\n        int sum2 = accumulate(B.begin(),B.end(),0);\\n        if(sum1 == sum2)\\n            return 0;\\n        sort(A.begin(),A.end());\\n        sort(B.begin(),B.end());\\n        int diff = abs(sum1 - sum2);\\n        int count = 0;\\n        if(sum1 < sum2)\\n        {\\n            swap(A,B);\\n            swap(sum1,sum2);\\n            swap(n1,n2);\\n        }\\n        int l = 0;\\n        int r = n1 - 1;\\n        while(l < n2 || r >= 0)\\n        {\\n            int help1 = INT_MIN;\\n            if(r >= 0)\\n            help1 = min(diff,(A[r] - 1));\\n            int help2 = INT_MIN;\\n            if(l < n2)\\n                help2 = min(diff,(6 - B[l]));\\n            if(help1 > help2)\\n            {\\n                r--;\\n                diff -= help1;\\n                count++;\\n                \\n            }\\n            else\\n            {\\n                l++;\\n                diff -= help2;\\n                count++;\\n            }\\n            if(diff == 0)\\n                return count;\\n        }\\n        return -1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>&A, vector<int>&B) {\\n        int n1 = A.size();\\n        int n2 = B.size();\\n        int sum1 = accumulate(A.begin(),A.end(),0);\\n        int sum2 = accumulate(B.begin(),B.end(),0);\\n        if(sum1 == sum2)\\n            return 0;\\n        sort(A.begin(),A.end());\\n        sort(B.begin(),B.end());\\n        int diff = abs(sum1 - sum2);\\n        int count = 0;\\n        if(sum1 < sum2)\\n        {\\n            swap(A,B);\\n            swap(sum1,sum2);\\n            swap(n1,n2);\\n        }\\n        int l = 0;\\n        int r = n1 - 1;\\n        while(l < n2 || r >= 0)\\n        {\\n            int help1 = INT_MIN;\\n            if(r >= 0)\\n            help1 = min(diff,(A[r] - 1));\\n            int help2 = INT_MIN;\\n            if(l < n2)\\n                help2 = min(diff,(6 - B[l]));\\n            if(help1 > help2)\\n            {\\n                r--;\\n                diff -= help1;\\n                count++;\\n                \\n            }\\n            else\\n            {\\n                l++;\\n                diff -= help2;\\n                count++;\\n            }\\n            if(diff == 0)\\n                return count;\\n        }\\n        return -1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673038,
                "title": "c-o-nlogn-can-be-done-in-o-n-but-this-approach-uses-the-two-pointer-approach",
                "content": "```\\nint minop(int i,int j,int m,int n,vector<int> nums1,vector<int> nums2,int si,int diff)\\n    {\\n        int oper = 0;\\n        while(i >= 0 || j <= si)\\n        {\\n            if(j == n || nums1[i]-1 > 6-nums2[j])\\n            {\\n                diff-=(nums1[i]-1);\\n                i--;\\n            }\\n            else\\n                if(i == -1 || nums1[i]-1 <= 6-nums2[j])\\n            {\\n                diff-=(6-nums2[j]);\\n                j++;\\n            }\\n            oper++;\\n            if(diff <= 0)\\n                return oper;\\n        }\\n        return -1;\\n    }\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        int sum1,sum2;\\n        sum1 = sum2 = 0;\\n        for(int i=0;i<m;i++)\\n            sum1+=nums1[i];\\n        for(int i=0;i<n;i++)\\n            sum2+=nums2[i];\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i,j;\\n        int ans;\\n        if(sum1 > sum2)\\n        {\\n            int diff = sum1-sum2;\\n            i = m-1;\\n            j = 0;\\n            ans = minop(i,j,m,n,nums1,nums2,n-1,diff);\\n        }\\n        else\\n            if(sum2 > sum1)\\n            {\\n                int diff = sum2-sum1;\\n                i = n-1;\\n                j = 0;\\n              ans = minop(i,j,n,m,nums2,nums1,m-1,diff);\\n            }\\n        else\\n        {\\n            return 0;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nint minop(int i,int j,int m,int n,vector<int> nums1,vector<int> nums2,int si,int diff)\\n    {\\n        int oper = 0;\\n        while(i >= 0 || j <= si)\\n        {\\n            if(j == n || nums1[i]-1 > 6-nums2[j])\\n            {\\n                diff-=(nums1[i]-1);\\n                i--;\\n            }\\n            else\\n                if(i == -1 || nums1[i]-1 <= 6-nums2[j])\\n            {\\n                diff-=(6-nums2[j]);\\n                j++;\\n            }\\n            oper++;\\n            if(diff <= 0)\\n                return oper;\\n        }\\n        return -1;\\n    }\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        int sum1,sum2;\\n        sum1 = sum2 = 0;\\n        for(int i=0;i<m;i++)\\n            sum1+=nums1[i];\\n        for(int i=0;i<n;i++)\\n            sum2+=nums2[i];\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i,j;\\n        int ans;\\n        if(sum1 > sum2)\\n        {\\n            int diff = sum1-sum2;\\n            i = m-1;\\n            j = 0;\\n            ans = minop(i,j,m,n,nums1,nums2,n-1,diff);\\n        }\\n        else\\n            if(sum2 > sum1)\\n            {\\n                int diff = sum2-sum1;\\n                i = n-1;\\n                j = 0;\\n              ans = minop(i,j,n,m,nums2,nums1,m-1,diff);\\n            }\\n        else\\n        {\\n            return 0;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1597195,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        if(nums1.size()>6*nums2.size()||nums1.size()*6<nums2.size())\\n        {\\n            return -1;\\n        }\\n        int sum1=accumulate(nums1.begin(),nums1.end(),0);\\n        int sum2=accumulate(nums2.begin(),nums2.end(),0);\\n        if(sum1<sum2)\\n        {\\n            swap(nums1,nums2);\\n            swap(sum1,sum2);\\n        }\\n        int diff=sum1-sum2;\\n        vector<int>ans;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ans.push_back(nums1[i]-1);\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            ans.push_back(6-nums2[i]);\\n        }\\n        if(sum1==sum2)\\n        {\\n            return 0;\\n        }\\n        int count=0;\\n        int size=ans.size();\\n        sort(ans.rbegin(),ans.rend());\\n        for(int i=0;i<size;i++)\\n        {\\n            count++;\\n            diff-=ans[i];\\n            if(diff<=0)\\n            {\\n                return count;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        if(nums1.size()>6*nums2.size()||nums1.size()*6<nums2.size())\\n        {\\n            return -1;\\n        }\\n        int sum1=accumulate(nums1.begin(),nums1.end(),0);\\n        int sum2=accumulate(nums2.begin(),nums2.end(),0);\\n        if(sum1<sum2)\\n        {\\n            swap(nums1,nums2);\\n            swap(sum1,sum2);\\n        }\\n        int diff=sum1-sum2;\\n        vector<int>ans;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ans.push_back(nums1[i]-1);\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            ans.push_back(6-nums2[i]);\\n        }\\n        if(sum1==sum2)\\n        {\\n            return 0;\\n        }\\n        int count=0;\\n        int size=ans.size();\\n        sort(ans.rbegin(),ans.rend());\\n        for(int i=0;i<size;i++)\\n        {\\n            count++;\\n            diff-=ans[i];\\n            if(diff<=0)\\n            {\\n                return count;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492995,
                "title": "c-greedy-explained",
                "content": "\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n      int n1=nums1.size();\\n      int n2=nums2.size();\\n      if(min(n1,n2)*6 < max(n1,n2))\\n        return -1;\\n      \\n        int sum1=0,sum2=0;\\n      for(int x:nums1)\\n        sum1+=x;\\n      for(int y:nums2)\\n        sum2+=y;\\n      if(sum1==sum2)\\n        return 0;\\n      int count=0;\\n\\n      if(sum1<sum2 )\\n        swap(nums1,nums2);\\n      \\n      // now nums1 sum is greater (sum1)\\n      \\n       int diff=abs(sum1-sum2);\\n\\n      map<int,int>mp;\\n      \\n      for(int x:nums1)\\n        mp[x-1]++;      // storing by how many times we can decrease no x\\n      for(int y:nums2)\\n        mp[6-y]++;      // storing by how many times we can increase no y\\n      \\n      for(auto itr=mp.rbegin();itr!=mp.rend(); itr++){\\n        int no=itr->first;    // no can be used to decrease the differnce by t times\\n        int t=itr->second;\\n        while(t && diff>0){\\n          diff=diff-no;          // utilizing no to decrease the difference\\n          t--;\\n          count++;\\n        }\\n        if(diff<=0)\\n          return count;\\n      }\\n      return -1;\\n    }\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n      int n1=nums1.size();\\n      int n2=nums2.size();\\n      if(min(n1,n2)*6 < max(n1,n2))\\n        return -1;\\n      \\n        int sum1=0,sum2=0;\\n      for(int x:nums1)\\n        sum1+=x;\\n      for(int y:nums2)\\n        sum2+=y;\\n      if(sum1==sum2)\\n        return 0;\\n      int count=0;\\n\\n      if(sum1<sum2 )\\n        swap(nums1,nums2);\\n      \\n      // now nums1 sum is greater (sum1)\\n      \\n       int diff=abs(sum1-sum2);\\n\\n      map<int,int>mp;\\n      \\n      for(int x:nums1)\\n        mp[x-1]++;      // storing by how many times we can decrease no x\\n      for(int y:nums2)\\n        mp[6-y]++;      // storing by how many times we can increase no y\\n      \\n      for(auto itr=mp.rbegin();itr!=mp.rend(); itr++){\\n        int no=itr->first;    // no can be used to decrease the differnce by t times\\n        int t=itr->second;\\n        while(t && diff>0){\\n          diff=diff-no;          // utilizing no to decrease the difference\\n          t--;\\n          count++;\\n        }\\n        if(diff<=0)\\n          return count;\\n      }\\n      return -1;\\n    }\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1416184,
                "title": "c-greedy-solution-with-explanation",
                "content": "Took a minute to understand the idea. We are using a greedy approach, why? we need to find minimum number of operations with which we can equal sum of all elements in nums 1 to sum of all elements in nums2. Now, greedy will always work as we can try increase/decreasing the maximum amount in each element. i.e. consider 1st array has total sum less than second array and -> [1, 2, 3, .....] and [3, 2, 3, .....], we can obivously increase 1 to 3, but we  increase 1 directly to 6 and continue, what this will do is save the steps of operations to change further elements as we get closer to end the gap between sum1 and sum2.\\nThe idea is same, first calculate the sum of elements in array1 and array2, if difference between 2 is already 0, min operatinons required = 0. Else, depending on if total1>total2 or vice versa, push_back (nums1[i]-1) and (6-nums2[i]) in another array nums respectively. Notice that we are pushing back the maximum change we can make in any element of nums1 and nums2. One might argue that what if we want to increase the element in larger sum array and decrease any element in smaller sum array -> this will then not get us minimum number of operations to make the sum equal. \\nAfter the parent array nums is filled, sort it and reverse it. reverse because we want to start decreasing the difference between two arrays as much as we can (so that we can have minimum number of steps). \\nIf any element \\'i\\' in nums==0, we know rest of the array is also 0 (wont effect difference and hence, break the loop as we already have minimum number of steps). Else subtract that per element difference stored in nums from the total difference (abs(tota1-total2)). As soon as we hit diff<=0, we break the loop as we have the closed the gap between two arrays. Notice that diff<0 is also included because remember we are decrementing smaller array/incrementing larger array with max amount possible and it may happen that we need to increment/decrement any element by smaller amount to achieve diff = 0, for example [1] needs to be change by 2 to get [3], but we directly changed [1] to [6] and now have diff<0.\\nAlso, keep a flag that will be only set to true only if diff hits <=0. Atlast, if the flag is set, return answer or else return -1. \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int total1 = 0, total2 = 0;\\n        for(int i:nums1)\\n            total1+=i;\\n        for(int i:nums2)\\n            total2+=i;\\n        int diff = abs(total1-total2);\\n        if(diff==0)\\n            return 0;\\n        vector<int> nums;\\n        if(total1<total2)\\n        {\\n            for(int i:nums1)\\n                nums.push_back(6-i);\\n            for(int i:nums2)\\n                nums.push_back(i-1);\\n        }\\n        else\\n        {\\n            for(int i:nums1)\\n                nums.push_back(i-1);\\n            for(int i:nums2)\\n                nums.push_back(6-i);\\n        }\\n        sort(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.end());\\n        bool flag = false;\\n        int ans = 0;\\n        for(int i:nums)\\n        {\\n            if(i==0)\\n                break;\\n            diff-=i;\\n            ans++;\\n            if(diff<=0)\\n            {\\n                flag = true;\\n                break;\\n            }\\n        }\\n        return (flag==true)?ans:-1;\\n    }\\n};\\n```\\nTime complexity: O(nlogn) ->sorting takes more time than all O(n) loops\\nSpace complexity: O(n)\\nwhere n is number of elements in both they arrays",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int total1 = 0, total2 = 0;\\n        for(int i:nums1)\\n            total1+=i;\\n        for(int i:nums2)\\n            total2+=i;\\n        int diff = abs(total1-total2);\\n        if(diff==0)\\n            return 0;\\n        vector<int> nums;\\n        if(total1<total2)\\n        {\\n            for(int i:nums1)\\n                nums.push_back(6-i);\\n            for(int i:nums2)\\n                nums.push_back(i-1);\\n        }\\n        else\\n        {\\n            for(int i:nums1)\\n                nums.push_back(i-1);\\n            for(int i:nums2)\\n                nums.push_back(6-i);\\n        }\\n        sort(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.end());\\n        bool flag = false;\\n        int ans = 0;\\n        for(int i:nums)\\n        {\\n            if(i==0)\\n                break;\\n            diff-=i;\\n            ans++;\\n            if(diff<=0)\\n            {\\n                flag = true;\\n                break;\\n            }\\n        }\\n        return (flag==true)?ans:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298146,
                "title": "python3-greedy-with-counter",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if s1==s2:\\n            return 0\\n        C = Counter()\\n        if s1<s2:\\n            C.update(6-v for v in nums1)\\n            C.update(v-1 for v in nums2)\\n        else:\\n            C.update(6-v for v in nums2)\\n            C.update(v-1 for v in nums1)\\n        \\n        R = abs(s2-s1)\\n        # C contains all the changes we can make\\n        # R is how much we must change\\n        \\n        ops = 0\\n        for delta in sorted(C.keys(), reverse=True):\\n            if not delta:\\n                break\\n            assert(delta>0)\\n            required = (R+delta-1)//delta\\n            if C[delta]>=required:\\n                return ops+required\\n            ops += C[delta]\\n            R -= C[delta]*delta\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if s1==s2:\\n            return 0\\n        C = Counter()\\n        if s1<s2:\\n            C.update(6-v for v in nums1)\\n            C.update(v-1 for v in nums2)\\n        else:\\n            C.update(6-v for v in nums2)\\n            C.update(v-1 for v in nums1)\\n        \\n        R = abs(s2-s1)\\n        # C contains all the changes we can make\\n        # R is how much we must change\\n        \\n        ops = 0\\n        for delta in sorted(C.keys(), reverse=True):\\n            if not delta:\\n                break\\n            assert(delta>0)\\n            required = (R+delta-1)//delta\\n            if C[delta]>=required:\\n                return ops+required\\n            ops += C[delta]\\n            R -= C[delta]*delta\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253451,
                "title": "o-n-js-solution-w-explanation",
                "content": "```\\nvar minOperations = function(nums1, nums2) {\\n    /*\\n    Two impossible cases:\\n    min1...max1 ... min2...max2 -> we can\\'t make them equal\\n    min2...max2 ... min1...max1 -> we can\\'t make them equal\\n    */\\n    let min1 = nums1.length * 1;\\n    let max1 = nums1.length * 6;\\n    let min2 = nums2.length * 1;\\n    let max2 = nums2.length * 6;\\n    if (min2 > max1 || min1 > max2) {\\n        return -1;\\n    }\\n    let sum1 = nums1.reduce((acc,cur) => acc + cur);\\n    let sum2 = nums2.reduce((acc,cur) => acc + cur);\\n    if (sum1 === sum2) return 0;\\n    if (sum1 < sum2) {\\n        return helper(nums1, nums2, sum1, sum2);\\n    } else {\\n        return helper(nums2, nums1, sum2, sum1);\\n    }\\n    // T.C: O(M + N), M = # of nums1, N = # of nums2\\n    // S.C: O(1)\\n};\\n\\n// Condition: sum of A < sum of B\\n// the idea is to add the maximum possible value to sumA and\\n// subtract the maximum possible value from sumB so that\\n// we make sumA >= sumB as soon as possible\\nfunction helper(A, B, sumA, sumB) {\\n    let freqA = new Array(7).fill(0);\\n    let freqB = new Array(7).fill(0);\\n    for (let i = 0; i < A.length; i++) {\\n        freqA[A[i]]++;\\n    }\\n    for (let i = 0; i < B.length; i++) {\\n        freqB[B[i]]++;\\n    }\\n    let count = 0;\\n    for (let i = 1; i <= 6; i++) {\\n        // increase sumA\\n        while (freqA[i] > 0 && sumA < sumB) {\\n            sumA += 6-i;\\n            freqA[i]--;\\n            count++;\\n        }\\n        let j = 7-i;\\n        // decrease sumB\\n        while (freqB[j] > 0 && sumA < sumB) {\\n            sumB -= j-1;\\n            freqB[j]--;\\n            count++;\\n        }\\n        if (sumA >= sumB) break;\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(nums1, nums2) {\\n    /*\\n    Two impossible cases:\\n    min1...max1 ... min2...max2 -> we can\\'t make them equal\\n    min2...max2 ... min1...max1 -> we can\\'t make them equal\\n    */\\n    let min1 = nums1.length * 1;\\n    let max1 = nums1.length * 6;\\n    let min2 = nums2.length * 1;\\n    let max2 = nums2.length * 6;\\n    if (min2 > max1 || min1 > max2) {\\n        return -1;\\n    }\\n    let sum1 = nums1.reduce((acc,cur) => acc + cur);\\n    let sum2 = nums2.reduce((acc,cur) => acc + cur);\\n    if (sum1 === sum2) return 0;\\n    if (sum1 < sum2) {\\n        return helper(nums1, nums2, sum1, sum2);\\n    } else {\\n        return helper(nums2, nums1, sum2, sum1);\\n    }\\n    // T.C: O(M + N), M = # of nums1, N = # of nums2\\n    // S.C: O(1)\\n};\\n\\n// Condition: sum of A < sum of B\\n// the idea is to add the maximum possible value to sumA and\\n// subtract the maximum possible value from sumB so that\\n// we make sumA >= sumB as soon as possible\\nfunction helper(A, B, sumA, sumB) {\\n    let freqA = new Array(7).fill(0);\\n    let freqB = new Array(7).fill(0);\\n    for (let i = 0; i < A.length; i++) {\\n        freqA[A[i]]++;\\n    }\\n    for (let i = 0; i < B.length; i++) {\\n        freqB[B[i]]++;\\n    }\\n    let count = 0;\\n    for (let i = 1; i <= 6; i++) {\\n        // increase sumA\\n        while (freqA[i] > 0 && sumA < sumB) {\\n            sumA += 6-i;\\n            freqA[i]--;\\n            count++;\\n        }\\n        let j = 7-i;\\n        // decrease sumB\\n        while (freqB[j] > 0 && sumA < sumB) {\\n            sumB -= j-1;\\n            freqB[j]--;\\n            count++;\\n        }\\n        if (sumA >= sumB) break;\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121906,
                "title": "java-o-n-greedy-solution-without-sorting-easy-to-understand",
                "content": "First, we compute the sum of each array. Then we calculate the gap between the sum of two array. Let the array of larger sum be nums1 and the other one be nums2.\\nWe observer that to close the gap, we should decrease the elements in nums1 and increase the elements in nums2.\\nTo minimize the operations, we should always increase/decrease the amount as much as possible. This can be done by choosing elements decreasingly in nums1 and increasingly in nums2.\\nFor example, by chosing a \"6\" in nums1 and decrease it to a \"1\", we close the gap by 5.\\n```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int[] bucket1 = new int[7];\\n        int[] bucket2 = new int[7];\\n        int sum1 = 0;\\n        int sum2 = 0;\\n\\n        for (int i : nums1) {\\n            bucket1[i]++;\\n            sum1 += i;\\n        }\\n        for (int i : nums2) {\\n            bucket2[i]++;\\n            sum2 += i;\\n        }\\n\\n        if (sum1 < sum2) {\\n            int[] temp = bucket1;\\n            bucket1 = bucket2;\\n            bucket2 = temp;\\n        }\\n\\n        int gap = Math.abs(sum1 - sum2);\\n        int ans = 0;\\n        for (int i = 1; i < 6; ++i) {\\n            int available = bucket1[7 - i] + bucket2[i];\\n            int close = 6 - i;\\n            if (gap - close * available <= 0) {\\n                ans += (gap + close - 1) / close;\\n                return ans;\\n            }\\n            gap -= close * available;\\n            ans += available;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int[] bucket1 = new int[7];\\n        int[] bucket2 = new int[7];\\n        int sum1 = 0;\\n        int sum2 = 0;\\n\\n        for (int i : nums1) {\\n            bucket1[i]++;\\n            sum1 += i;\\n        }\\n        for (int i : nums2) {\\n            bucket2[i]++;\\n            sum2 += i;\\n        }\\n\\n        if (sum1 < sum2) {\\n            int[] temp = bucket1;\\n            bucket1 = bucket2;\\n            bucket2 = temp;\\n        }\\n\\n        int gap = Math.abs(sum1 - sum2);\\n        int ans = 0;\\n        for (int i = 1; i < 6; ++i) {\\n            int available = bucket1[7 - i] + bucket2[i];\\n            int close = 6 - i;\\n            if (gap - close * available <= 0) {\\n                ans += (gap + close - 1) / close;\\n                return ans;\\n            }\\n            gap -= close * available;\\n            ans += available;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113473,
                "title": "c-sort-two-pointers",
                "content": "```\\n\\tint minOperations(vector<int>& a, vector<int>& b) {\\n        sort(a.begin(), a.end());\\n        sort(b.begin(), b.end());\\n        \\n        int sa = accumulate(a.begin(), a.end(), 0);\\n        int sb = accumulate(b.begin(), b.end(), 0);\\n        \\n        if(sb > sa) {\\n            swap(sa, sb);\\n            swap(a, b);\\n        }\\n        \\n        int diff = sa - sb, ch = 0;\\n        if(diff == 0) {\\n            return 0;\\n        }\\n        \\n        // here, sa > sb, decrease elements in a, increase elements in b\\n        int ia = a.size()-1, ib = 0;\\n        \\n        while((ib < b.size() || ia >= 0) && diff != 0) {\\n            // choose the one with max impact\\n            int inc = ib < b.size() ? 6-b[ib]: -1;\\n            int dec = ia >= 0 ? a[ia]-1 : -1;\\n            if(inc > dec) {\\n                int mn = min(diff, inc);\\n                diff -= mn;\\n                b[ib] += mn;\\n                ++ib;\\n            }\\n            else {\\n                int mn = min(diff, dec);\\n                diff -= mn;\\n                a[ia] -= mn;\\n                --ia;\\n            }\\n            ch++;\\n        }\\n        \\n        return (diff == 0) ? ch : -1;\\n    }\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n\\tint minOperations(vector<int>& a, vector<int>& b) {\\n        sort(a.begin(), a.end());\\n        sort(b.begin(), b.end());\\n        \\n        int sa = accumulate(a.begin(), a.end(), 0);\\n        int sb = accumulate(b.begin(), b.end(), 0);\\n        \\n        if(sb > sa) {\\n            swap(sa, sb);\\n            swap(a, b);\\n        }\\n        \\n        int diff = sa - sb, ch = 0;\\n        if(diff == 0) {\\n            return 0;\\n        }\\n        \\n        // here, sa > sb, decrease elements in a, increase elements in b\\n        int ia = a.size()-1, ib = 0;\\n        \\n        while((ib < b.size() || ia >= 0) && diff != 0) {\\n            // choose the one with max impact\\n            int inc = ib < b.size() ? 6-b[ib]: -1;\\n            int dec = ia >= 0 ? a[ia]-1 : -1;\\n            if(inc > dec) {\\n                int mn = min(diff, inc);\\n                diff -= mn;\\n                b[ib] += mn;\\n                ++ib;\\n            }\\n            else {\\n                int mn = min(diff, dec);\\n                diff -= mn;\\n                a[ia] -= mn;\\n                --ia;\\n            }\\n            ch++;\\n        }\\n        \\n        return (diff == 0) ? ch : -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1103943,
                "title": "go-golang-double-100",
                "content": "```\\nfunc helper(nums []int)(n, sum int, counts []int) {\\n    n = len(nums)\\n    counts = make([]int, 7)\\n    for _, v := range nums {\\n        sum += v\\n        counts[v]++\\n    }\\n    return\\n}\\n\\nfunc minOperations(nums1 []int, nums2 []int) int {\\n    n1, sum1, counts1 := helper(nums1)\\n    n2, sum2, counts2 := helper(nums2)\\n    if sum1 == sum2 {\\n        return 0\\n    }\\n    if n1 > n2 * 6 || n2 > n1 * 6 {\\n        return -1\\n    }\\n    \\n    if sum1 > sum2 {\\n        sum1, sum2 = sum2, sum1\\n        counts1, counts2 = counts2, counts1\\n    }\\n    \\n    ret := 0\\n    \\n    for i := 1; i <= 6; i++ {\\n        ci := counts1[i]\\n        dif := 6 - i\\n        difs := dif * ci\\n        if sum1 + difs >= sum2 {\\n            return ret + (sum2 - sum1 - 1) / dif + 1\\n        } else {\\n            sum1 += difs\\n            ret += ci\\n        }\\n        \\n        ci = counts2[7 - i]\\n        difs = dif * ci\\n        if sum2 - difs<= sum1 {\\n            return ret + (sum2 - sum1 - 1) / dif + 1\\n        } else {\\n            sum2 -= difs\\n            ret += ci\\n        }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc helper(nums []int)(n, sum int, counts []int) {\\n    n = len(nums)\\n    counts = make([]int, 7)\\n    for _, v := range nums {\\n        sum += v\\n        counts[v]++\\n    }\\n    return\\n}\\n\\nfunc minOperations(nums1 []int, nums2 []int) int {\\n    n1, sum1, counts1 := helper(nums1)\\n    n2, sum2, counts2 := helper(nums2)\\n    if sum1 == sum2 {\\n        return 0\\n    }\\n    if n1 > n2 * 6 || n2 > n1 * 6 {\\n        return -1\\n    }\\n    \\n    if sum1 > sum2 {\\n        sum1, sum2 = sum2, sum1\\n        counts1, counts2 = counts2, counts1\\n    }\\n    \\n    ret := 0\\n    \\n    for i := 1; i <= 6; i++ {\\n        ci := counts1[i]\\n        dif := 6 - i\\n        difs := dif * ci\\n        if sum1 + difs >= sum2 {\\n            return ret + (sum2 - sum1 - 1) / dif + 1\\n        } else {\\n            sum1 += difs\\n            ret += ci\\n        }\\n        \\n        ci = counts2[7 - i]\\n        difs = dif * ci\\n        if sum2 - difs<= sum1 {\\n            return ret + (sum2 - sum1 - 1) / dif + 1\\n        } else {\\n            sum2 -= difs\\n            ret += ci\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093928,
                "title": "python3-o-n-easy-to-understand",
                "content": "The intuition behind the code is simple and the examples in the problem description clearly describe all the scenarios well.\\n\\nThe main thing which we need to understand in the problem is we need to make the sum of arrays equal. So, we have 2 cases possible. Either sums are equal or sums are not equal.\\n\\nIf they are equal we can directly return 0 which isnt very interesting. The other case is if the sums of arr1 != arr2. This means one array is greater than the other (or else you could also say one array is smaller than the other).\\n\\nThe golden question is How do I know if I make the sums equal no matter what operations I do. Its simple, consider the example2 in description\\nEx: nums1 = [1,1,1,1,1,1,1], nums2 = [6]\\nWe can clearly see that sum of nums1 can go to a maximum of 42 (if all elements in array are replaced by 6) or it could go to a minimum sum of 7 (if all elements are replaced by 1).\\nSimilarly for nums2, maximum and minimum we can go is => maximumOfNums2 = 6, minimumOfNums2 = 1\\n\\nDont see the connection yet? It\\'s simple if either minimumOfNums1 belongs to the [minimumOfNums2, maximumOfNums2] or maximumOfNums1 belongs to  [minimumOfNums2, maximumOfNums2]. Then we can make the sums equal. If there isnt any overlap in either of those we cannot make sums equal and so we return -1.\\n\\nStill not clear? Let me expand a little, \\nconsider nums1 = [1,1,1,1,1,1,1] and nums2 = [6]\\nRanges of nums1 sums = [7, 42] (we can form a sum in between 7 to 42)\\nRanges of nums2 sums = [1, 6] (we can form a sum in between 1 to 6)\\nSee the pattern now? There are no values(I mean sums) that are common in both arrays. So, we return a -1 in this case\\n\\nNow, lets think of the actual logic. We are told to get to the result in minimum steps possible. That means we are thinking greedy. Aha! It\\'s a GREEDY algorithm. For it to work we can increase the smaller sum array\\'s values or decrease the larger sum array\\'s values. For each step we have to choose b/w whether should we increase or whether should we decrease. It\\'s simple, since we are thinking GREEDILY, we want to pick the CHOICE that gets us closer to the solution(In this problem, the solution is to make sums of both arrays equal). Also, inorder for the greedy algorithm to work we have to first sort the arrays to make bigger moves in every step. \\n\\nI used counting sort here as we only have a fixed size values in each array i.e., 1 to 6. Since, Counting sort works on if the values of array are bounded. We can use it to get down the complexity of sort(O(NlogN)) to O(N).\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\n\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        if sum(nums1) == sum(nums2):\\n            return 0\\n            \\n        nums1Length = len(nums1)\\n        nums2Length = len(nums2)\\n        \\n        minimumOfNums1, maximumOfNums1 = 1*nums1Length, 6*nums1Length\\n        minimumOfNums2, maximumOfNums2 = 1*nums2Length, 6*nums2Length\\n        \\n        if (not (minimumOfNums2<=minimumOfNums1<=maximumOfNums2)) and (not (minimumOfNums2<=maximumOfNums1<=maximumOfNums2)):\\n            return -1\\n        \\n        # Counting sort\\n        countsOfNum1 = [0]*7\\n        countsOfNum2 = [0]*7\\n        \\n        for n in nums1:\\n            countsOfNum1[n] += 1\\n        \\n        for n in nums2:\\n            countsOfNum2[n] += 1\\n        \\n        idx1 = idx2 = 0\\n        i = 1\\n        while i < 7:\\n            while countsOfNum1[i] > 0:\\n                nums1[idx1] = i\\n                countsOfNum1[i] -= 1\\n                idx1 += 1\\n            \\n            while countsOfNum2[i] > 0:\\n                nums2[idx2] = i\\n                countsOfNum2[i] -= 1\\n                idx2 += 1\\n            \\n            i += 1\\n        \\n        sumOfNums1 = sum(nums1)\\n        sumOfNums2 = sum(nums2)\\n        \\n        if sumOfNums1 < sumOfNums2:\\n            nums1, nums2 = nums2, nums1\\n            sumOfNums1, sumOfNums2 = sumOfNums2, sumOfNums1\\n        \\n        idx1 = -1\\n        idx2 = 0\\n        steps = 0\\n        while sumOfNums1 != sumOfNums2:\\n            # Decrease sumOfNums1\\n            if abs(idx1) <= len(nums1):\\n                decreaseAmount = min(5, sumOfNums1-sumOfNums2, nums1[idx1]-1)\\n            else:\\n                decreaseAmount = 0\\n            \\n            # Increase sumOfNums2\\n            if idx2 < len(nums2):\\n                increaseAmount = min(5, sumOfNums1-sumOfNums2, 6-nums2[idx2])\\n            else:\\n                increaseAmount = 0\\n            \\n            if increaseAmount > decreaseAmount:\\n                sumOfNums2 += increaseAmount\\n                nums2[idx2] += increaseAmount\\n                idx2 += 1\\n            else:\\n                sumOfNums1 -= decreaseAmount\\n                nums1[idx1] -= decreaseAmount\\n                idx1 -= 1\\n            \\n            steps += 1\\n            \\n        return steps\\n            \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        if sum(nums1) == sum(nums2):\\n            return 0\\n            \\n        nums1Length = len(nums1)\\n        nums2Length = len(nums2)\\n        \\n        minimumOfNums1, maximumOfNums1 = 1*nums1Length, 6*nums1Length\\n        minimumOfNums2, maximumOfNums2 = 1*nums2Length, 6*nums2Length\\n        \\n        if (not (minimumOfNums2<=minimumOfNums1<=maximumOfNums2)) and (not (minimumOfNums2<=maximumOfNums1<=maximumOfNums2)):\\n            return -1\\n        \\n        # Counting sort\\n        countsOfNum1 = [0]*7\\n        countsOfNum2 = [0]*7\\n        \\n        for n in nums1:\\n            countsOfNum1[n] += 1\\n        \\n        for n in nums2:\\n            countsOfNum2[n] += 1\\n        \\n        idx1 = idx2 = 0\\n        i = 1\\n        while i < 7:\\n            while countsOfNum1[i] > 0:\\n                nums1[idx1] = i\\n                countsOfNum1[i] -= 1\\n                idx1 += 1\\n            \\n            while countsOfNum2[i] > 0:\\n                nums2[idx2] = i\\n                countsOfNum2[i] -= 1\\n                idx2 += 1\\n            \\n            i += 1\\n        \\n        sumOfNums1 = sum(nums1)\\n        sumOfNums2 = sum(nums2)\\n        \\n        if sumOfNums1 < sumOfNums2:\\n            nums1, nums2 = nums2, nums1\\n            sumOfNums1, sumOfNums2 = sumOfNums2, sumOfNums1\\n        \\n        idx1 = -1\\n        idx2 = 0\\n        steps = 0\\n        while sumOfNums1 != sumOfNums2:\\n            # Decrease sumOfNums1\\n            if abs(idx1) <= len(nums1):\\n                decreaseAmount = min(5, sumOfNums1-sumOfNums2, nums1[idx1]-1)\\n            else:\\n                decreaseAmount = 0\\n            \\n            # Increase sumOfNums2\\n            if idx2 < len(nums2):\\n                increaseAmount = min(5, sumOfNums1-sumOfNums2, 6-nums2[idx2])\\n            else:\\n                increaseAmount = 0\\n            \\n            if increaseAmount > decreaseAmount:\\n                sumOfNums2 += increaseAmount\\n                nums2[idx2] += increaseAmount\\n                idx2 += 1\\n            else:\\n                sumOfNums1 -= decreaseAmount\\n                nums1[idx1] -= decreaseAmount\\n                idx1 -= 1\\n            \\n            steps += 1\\n            \\n        return steps\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089774,
                "title": "my-easy-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int s1=0,s2=0;\\n       for(auto it:nums1)\\n           s1+=it;\\n        for(auto it:nums2)\\n            s2+=it;\\n        if(s1==s2)\\n            return 0;\\n        if(s1<s2)\\n        {\\n            swap(nums1,nums2);\\n            swap(s1,s2);\\n        }\\n        int diff=(s1-s2),z1;\\n        vector<int>v;\\n        for(auto it:nums1)\\n        {\\n            z1=(it-1);\\n            v.push_back(z1);\\n        }\\n        for(auto it:nums2)\\n        {\\n            z1=(6-it);\\n            v.push_back(z1);\\n        }\\n        sort(v.begin(),v.end(),greater<int>());\\n        int x=0,ans=0;\\n        for(auto it:v)\\n        {\\n            x+=it;\\n            ans++;\\n            if(x>=diff)\\n                break;\\n        }\\n        if(x<diff)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int s1=0,s2=0;\\n       for(auto it:nums1)\\n           s1+=it;\\n        for(auto it:nums2)\\n            s2+=it;\\n        if(s1==s2)\\n            return 0;\\n        if(s1<s2)\\n        {\\n            swap(nums1,nums2);\\n            swap(s1,s2);\\n        }\\n        int diff=(s1-s2),z1;\\n        vector<int>v;\\n        for(auto it:nums1)\\n        {\\n            z1=(it-1);\\n            v.push_back(z1);\\n        }\\n        for(auto it:nums2)\\n        {\\n            z1=(6-it);\\n            v.push_back(z1);\\n        }\\n        sort(v.begin(),v.end(),greater<int>());\\n        int x=0,ans=0;\\n        for(auto it:v)\\n        {\\n            x+=it;\\n            ans++;\\n            if(x>=diff)\\n                break;\\n        }\\n        if(x<diff)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088051,
                "title": "c-o-n-time-o-1-space-sorting-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void call(vector<int> &v1,vector<int> &v2,int &st,int &diff) //(smaller sum array, larger sum array,total operations , difference of sums )\\n    {\\n        sort(v1.begin(),v1.end()); //sort smaller sum array in ascending order[so we can cover up maximum difference]\\n        sort(v2.begin(),v2.end(),greater<int>()); //sort greater sum array in decending array[so we can get cover up maximum differencr]\\n         \\n        int fir = 0,sec = 0; //initilizing two pointers\\n        \\n        while(fir < v1.size() && sec < v2.size() && diff > 0)\\n        {\\n            int up = 6 - v1[fir]; \\n            int low = v2[sec] - 1;\\n            \\n            if(up >= low) //if can cover maximum difference from v1 array\\n            {\\n                if(diff > up) \\n                diff -= up;\\n                else\\n                diff = 0;\\n                \\n                \\n                ++st;\\n                ++fir;\\n            }\\n            else\\n            {\\n                if(diff > low)\\n                    diff -= low;\\n                else\\n                    diff = 0;\\n                ++st;\\n                ++sec;\\n            }\\n        }\\n        \\n        while(fir < v1.size() && diff > 0)\\n        {\\n            int up = 6 - v1[fir];\\n            if(diff > up)\\n                diff -= up;\\n            else\\n                diff = 0;\\n            \\n            ++st;\\n            ++fir;\\n        }\\n        \\n        while(sec < v2.size() && diff > 0)\\n        {\\n            int down = v2[sec] - 1;\\n            if(diff > down)\\n                diff -= down;\\n            else\\n                diff = 0;\\n            \\n            ++st;\\n            ++sec;\\n        }\\n    }\\n    \\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int sum1=0,sum2=0;\\n        \\n        for(int i=0;i<nums1.size();++i)\\n            sum1+=nums1[i];\\n        \\n        for(int i=0;i<nums2.size();++i)\\n            sum2+=nums2[i];\\n        \\n        \\n        int diff = abs(sum1-sum2);  //find the difference of both arrays sums\\n        int ans = 0;\\n        \\n        if(sum1 < sum2)\\n        {\\n            call(nums1,nums2,ans,diff);\\n        }\\n        else\\n        {\\n            call(nums2,nums1,ans,diff);\\n        }\\n        \\n        if(diff == 0)\\n            return ans;\\n        else\\n            return -1;\\n            \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void call(vector<int> &v1,vector<int> &v2,int &st,int &diff) //(smaller sum array, larger sum array,total operations , difference of sums )\\n    {\\n        sort(v1.begin(),v1.end()); //sort smaller sum array in ascending order[so we can cover up maximum difference]\\n        sort(v2.begin(),v2.end(),greater<int>()); //sort greater sum array in decending array[so we can get cover up maximum differencr]\\n         \\n        int fir = 0,sec = 0; //initilizing two pointers\\n        \\n        while(fir < v1.size() && sec < v2.size() && diff > 0)\\n        {\\n            int up = 6 - v1[fir]; \\n            int low = v2[sec] - 1;\\n            \\n            if(up >= low) //if can cover maximum difference from v1 array\\n            {\\n                if(diff > up) \\n                diff -= up;\\n                else\\n                diff = 0;\\n                \\n                \\n                ++st;\\n                ++fir;\\n            }\\n            else\\n            {\\n                if(diff > low)\\n                    diff -= low;\\n                else\\n                    diff = 0;\\n                ++st;\\n                ++sec;\\n            }\\n        }\\n        \\n        while(fir < v1.size() && diff > 0)\\n        {\\n            int up = 6 - v1[fir];\\n            if(diff > up)\\n                diff -= up;\\n            else\\n                diff = 0;\\n            \\n            ++st;\\n            ++fir;\\n        }\\n        \\n        while(sec < v2.size() && diff > 0)\\n        {\\n            int down = v2[sec] - 1;\\n            if(diff > down)\\n                diff -= down;\\n            else\\n                diff = 0;\\n            \\n            ++st;\\n            ++sec;\\n        }\\n    }\\n    \\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int sum1=0,sum2=0;\\n        \\n        for(int i=0;i<nums1.size();++i)\\n            sum1+=nums1[i];\\n        \\n        for(int i=0;i<nums2.size();++i)\\n            sum2+=nums2[i];\\n        \\n        \\n        int diff = abs(sum1-sum2);  //find the difference of both arrays sums\\n        int ans = 0;\\n        \\n        if(sum1 < sum2)\\n        {\\n            call(nums1,nums2,ans,diff);\\n        }\\n        else\\n        {\\n            call(nums2,nums1,ans,diff);\\n        }\\n        \\n        if(diff == 0)\\n            return ans;\\n        else\\n            return -1;\\n            \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087129,
                "title": "c-short-linear-solution",
                "content": "Run-time is `O(N)`, space is `O(1)`. \\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        std::vector<int> f1(7, 0), f2(7, 0);\\n        int diff{0}, avail, res{0};\\n        for(const auto &n: nums1) diff -= n, ++f1[n];\\n        for(const auto &n: nums2) diff += n, ++f2[n];\\n        \\n        if(diff < 0) diff *= -1, std::swap(f1, f2);\\n        \\n        // s1 < s2\\n        for(int i{1}; i < 6; ++i) {\\n            avail = f1[i] + f2[7-i];\\n            if(avail * (6-i) >= diff) return res + std::ceil((double)diff/(6-i));\\n            else diff -= avail * (6-i), res += avail;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        std::vector<int> f1(7, 0), f2(7, 0);\\n        int diff{0}, avail, res{0};\\n        for(const auto &n: nums1) diff -= n, ++f1[n];\\n        for(const auto &n: nums2) diff += n, ++f2[n];\\n        \\n        if(diff < 0) diff *= -1, std::swap(f1, f2);\\n        \\n        // s1 < s2\\n        for(int i{1}; i < 6; ++i) {\\n            avail = f1[i] + f2[7-i];\\n            if(avail * (6-i) >= diff) return res + std::ceil((double)diff/(6-i));\\n            else diff -= avail * (6-i), res += avail;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086954,
                "title": "java-bucketsort-greedy-o-n-time-o-1-space",
                "content": "Bucket sort the arrays to get the number of the values.\\n\\nGreedily, for the array with larger sum : \\n- `6 -> 1` for the most change `5`\\n- `2 -> 1` for the most change `1`\\n- `1 -> 1` no contribution\\n- every value has the potential decrease change from `1 ~ 5`.\\n\\nVice versa for the array with the smaller sum.\\nSo we can obtain a `change` array to record the number of the these changes.\\n\\nGreedily, the difference `diff`  between two sums can be decreased by subtracting the changes.\\n\\nTime Complexity: O(N)\\n`N` is the length of the longer array.\\nSpace Complexity: O(1)\\n`bucket` array and `change` has the fixed length of 6\\n\\n```java\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        \\n        int shorter = Math.min(nums1.length, nums2.length), longer = Math.max(nums1.length, nums2.length);\\n        // return -1 if \\n        // MIN_VALUE of longer array > MAX_VALUE of shorter array\\n        if(longer > shorter * 6)\\n            return -1;\\n        \\n        // bucket sort the given array\\n        int[] bucket1 = new int[7], bucket2 = new int[7];\\n        int sum1 = 0, sum2 = 0;\\n        for(int n : nums1){\\n            sum1 += n;\\n            bucket1[n]++;\\n        }\\n        for(int n : nums2){\\n            sum2 += n;\\n            bucket2[n]++;\\n        }\\n        if(sum1 == sum2)\\n            return 0;\\n        \\n        int[] largeBucket = sum1 > sum2 ? bucket1 : bucket2, smallBucket = sum1 > sum2 ? bucket2 : bucket1;\\n        int diff = sum1 > sum2 ? sum1 - sum2 : sum2 - sum1;\\n        \\n        // idx : the value of changes from 1 to 5\\n        // value: the number of changes\\n        int[] change = new int[6];\\n        for(int i = 2; i < largeBucket.length; i++){\\n            change[i-1] += largeBucket[i];\\n        }\\n        for(int i = 5; i >= 1; i--){\\n            change[6-i] += smallBucket[i];\\n        }\\n        \\n        // greedy\\n        int count = 0;\\n        for(int idx = 5; diff > 0; idx--){\\n            if(change[idx] * idx < diff){\\n                diff -= change[idx] * idx;\\n                count += change[idx];\\n            } else {\\n                int need = diff / idx;\\n                count += need;\\n                if(need * idx < diff)\\n                    count += 1;\\n                diff = 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        \\n        int shorter = Math.min(nums1.length, nums2.length), longer = Math.max(nums1.length, nums2.length);\\n        // return -1 if \\n        // MIN_VALUE of longer array > MAX_VALUE of shorter array\\n        if(longer > shorter * 6)\\n            return -1;\\n        \\n        // bucket sort the given array\\n        int[] bucket1 = new int[7], bucket2 = new int[7];\\n        int sum1 = 0, sum2 = 0;\\n        for(int n : nums1){\\n            sum1 += n;\\n            bucket1[n]++;\\n        }\\n        for(int n : nums2){\\n            sum2 += n;\\n            bucket2[n]++;\\n        }\\n        if(sum1 == sum2)\\n            return 0;\\n        \\n        int[] largeBucket = sum1 > sum2 ? bucket1 : bucket2, smallBucket = sum1 > sum2 ? bucket2 : bucket1;\\n        int diff = sum1 > sum2 ? sum1 - sum2 : sum2 - sum1;\\n        \\n        // idx : the value of changes from 1 to 5\\n        // value: the number of changes\\n        int[] change = new int[6];\\n        for(int i = 2; i < largeBucket.length; i++){\\n            change[i-1] += largeBucket[i];\\n        }\\n        for(int i = 5; i >= 1; i--){\\n            change[6-i] += smallBucket[i];\\n        }\\n        \\n        // greedy\\n        int count = 0;\\n        for(int idx = 5; diff > 0; idx--){\\n            if(change[idx] * idx < diff){\\n                diff -= change[idx] * idx;\\n                count += change[idx];\\n            } else {\\n                int need = diff / idx;\\n                count += need;\\n                if(need * idx < diff)\\n                    count += 1;\\n                diff = 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086555,
                "title": "java-o-n-time-explanation-with-approach-and-o-1-space-solution",
                "content": "```\\n/*\\nShort Explanation:\\nWe will calculate sum of 2 array elemenst if two sum are equal then return 0 let say sum1 and sum2\\nElse we have to think about absolute difference between two sum(sum2-sum1)\\n\\nNow we can increase sum of array whose sum less than second array or decrease sum of array whose sum is greater than other array\\nWe have to do above process in minimum operation\\n\\nSuppose we have to increase then we can increase 1 to 2,3,4,5,6\\nAs we have to compensate our difference in min operation it is always preferable to increase 1 to 6\\nand if we want to decrease in other array to 6 to 1 (diff=5)\\nHere we came to know that we should use greedy method\\n\\nImplementation:\\n* find sum of both arrays\\n* General Idea is we will increase elemnt from array whose sum is smalller and decrease elemnt from array whose sum is greater\\n* then we will find frequency of element in array whose sum is greater and store in frequency array\\n* While storing I have store current elemnt-1 (as max difference will be always curr-1 (if not clear see example in explanation)\\n* Similarly we will find frequency of element whose sum is smaller\\n* While storing above we will use (6-curr) (consider example conversion of 1 to 6 here diff is (6-1)==s) \\n```\\n\\n```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int n1=nums1.length;\\n        int n2=nums2.length;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<n1;i++)\\n            sum1+=nums1[i];\\n        for(int i=0;i<n2;i++)\\n            sum2+=nums2[i];\\n        if(sum1==sum2)\\n            return 0;\\n        int small=n1<n2?n1:n2;\\n        int big=n1<n2?n2:n1;\\n        if(small*6<big*1)\\n            return -1;\\n        int great[]=new int[6];\\n        if(sum1<sum2)\\n        {\\n            for(int i=0;i<n1;i++)\\n                great[5-nums1[i]+1]++;\\n            for(int i=0;i<n2;i++)\\n                great[nums2[i]-1]++;\\n        }\\n        else\\n        {\\n            for(int i=0;i<n1;i++)\\n                great[nums1[i]-1]++;\\n            for(int i=0;i<n2;i++)\\n                great[5-nums2[i]+1]++;\\n        }\\n        int req=Math.abs(sum2-sum1);\\n        int op=0;\\n        for(int i=5;i>=1 && req>0;i--)\\n        {\\n            for(int j=0;j<great[i] && req>0;j++)\\n            {\\n                op++;\\n                req=req-i;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nShort Explanation:\\nWe will calculate sum of 2 array elemenst if two sum are equal then return 0 let say sum1 and sum2\\nElse we have to think about absolute difference between two sum(sum2-sum1)\\n\\nNow we can increase sum of array whose sum less than second array or decrease sum of array whose sum is greater than other array\\nWe have to do above process in minimum operation\\n\\nSuppose we have to increase then we can increase 1 to 2,3,4,5,6\\nAs we have to compensate our difference in min operation it is always preferable to increase 1 to 6\\nand if we want to decrease in other array to 6 to 1 (diff=5)\\nHere we came to know that we should use greedy method\\n\\nImplementation:\\n* find sum of both arrays\\n* General Idea is we will increase elemnt from array whose sum is smalller and decrease elemnt from array whose sum is greater\\n* then we will find frequency of element in array whose sum is greater and store in frequency array\\n* While storing I have store current elemnt-1 (as max difference will be always curr-1 (if not clear see example in explanation)\\n* Similarly we will find frequency of element whose sum is smaller\\n* While storing above we will use (6-curr) (consider example conversion of 1 to 6 here diff is (6-1)==s) \\n```\n```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int n1=nums1.length;\\n        int n2=nums2.length;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<n1;i++)\\n            sum1+=nums1[i];\\n        for(int i=0;i<n2;i++)\\n            sum2+=nums2[i];\\n        if(sum1==sum2)\\n            return 0;\\n        int small=n1<n2?n1:n2;\\n        int big=n1<n2?n2:n1;\\n        if(small*6<big*1)\\n            return -1;\\n        int great[]=new int[6];\\n        if(sum1<sum2)\\n        {\\n            for(int i=0;i<n1;i++)\\n                great[5-nums1[i]+1]++;\\n            for(int i=0;i<n2;i++)\\n                great[nums2[i]-1]++;\\n        }\\n        else\\n        {\\n            for(int i=0;i<n1;i++)\\n                great[nums1[i]-1]++;\\n            for(int i=0;i<n2;i++)\\n                great[5-nums2[i]+1]++;\\n        }\\n        int req=Math.abs(sum2-sum1);\\n        int op=0;\\n        for(int i=5;i>=1 && req>0;i--)\\n        {\\n            for(int j=0;j<great[i] && req>0;j++)\\n            {\\n                op++;\\n                req=req-i;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085982,
                "title": "c-greedy-o-n-time-no-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0, sum2=0, op;\\n        vector<int> counts1(6,0), counts2(6,0), counts(6,0);\\n        \\n        for( int i=0; i<nums1.size(); i++){\\n            counts1[nums1[i]-1]+=1;\\n            sum1+=nums1[i];\\n        }\\n        for( int i=0; i<nums2.size(); i++){\\n            counts2[nums2[i]-1]+=1;\\n            sum2+=nums2[i];\\n        }\\n        \\n        if(sum1<sum2){\\n            for( int i=0; i<6; i++)\\n                counts[i]+=counts1[5-i]+counts2[i];\\n            return calOperations( sum2-sum1, counts);\\n        }else if(sum2<sum1){\\n            for( int i=0; i<6; i++)\\n                counts[i]+=counts1[i]+counts2[5-i];\\n            return calOperations( sum1-sum2, counts);\\n        }else{\\n            return 0;\\n        }\\n    }\\n    \\nprotected:\\n    int calOperations( int d, vector<int> & counts){\\n        int ops=0, op;\\n        \\n        for( int i=5; 0<i; i--){// Greedy \\n            op=d/i<counts[i]?d/i:counts[i];\\n            d-=op*i;\\n            ops+=op;\\n            \\n            if(d==0)    return ops;\\n            else if(d<i&&1<=counts[i]-op)   return ops+1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0, sum2=0, op;\\n        vector<int> counts1(6,0), counts2(6,0), counts(6,0);\\n        \\n        for( int i=0; i<nums1.size(); i++){\\n            counts1[nums1[i]-1]+=1;\\n            sum1+=nums1[i];\\n        }\\n        for( int i=0; i<nums2.size(); i++){\\n            counts2[nums2[i]-1]+=1;\\n            sum2+=nums2[i];\\n        }\\n        \\n        if(sum1<sum2){\\n            for( int i=0; i<6; i++)\\n                counts[i]+=counts1[5-i]+counts2[i];\\n            return calOperations( sum2-sum1, counts);\\n        }else if(sum2<sum1){\\n            for( int i=0; i<6; i++)\\n                counts[i]+=counts1[i]+counts2[5-i];\\n            return calOperations( sum1-sum2, counts);\\n        }else{\\n            return 0;\\n        }\\n    }\\n    \\nprotected:\\n    int calOperations( int d, vector<int> & counts){\\n        int ops=0, op;\\n        \\n        for( int i=5; 0<i; i--){// Greedy \\n            op=d/i<counts[i]?d/i:counts[i];\\n            d-=op*i;\\n            ops+=op;\\n            \\n            if(d==0)    return ops;\\n            else if(d<i&&1<=counts[i]-op)   return ops+1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085979,
                "title": "c-priority-queue-easy-solution-with-explanation",
                "content": "int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n\\n        priority_queue<int> pq1; \\n        // pq 1 will Store array with greater sum so to extract max value at every time\\n        priority_queue<int,vector<int>,greater<int>> pq2; \\n        // pq 2 will  Store array with smaller sum so to extract min value at every time\\n        int sum1=0,sum2=0;\\n        \\n\\t\\tfor(auto x:nums1){\\n            sum1+=x;\\n        }\\n        for(auto x:nums2){\\n            sum2+=x;\\n        }\\n\\t\\t\\n        if(sum1<sum2){\\n            for(auto x:nums1){\\n                pq2.push(x);\\n            }\\n            for(auto x:nums2){\\n                pq1.push(x);\\n            }\\n            swap(sum1,sum2); \\n        }\\n        else{\\n            for(auto x:nums1){\\n                pq1.push(x);\\n            }\\n            for(auto x:nums2){\\n                pq2.push(x);\\n            }\\n        }\\n\\t\\t\\n        int ans=0;\\n\\t\\t\\n        while(sum1!=sum2){\\n            int diff=abs(sum1-sum2);\\n            // No more operations can be applied \\n            if(pq1.top()==1 && pq2.top()==6){\\n                return -1;\\n            }\\n\\t\\t\\t//Check from which priority queue the element should be picked that will make bigger impact(which result in minimum operation)\\n            int d1=pq1.top()-1;\\n            int d2=6-pq2.top();\\n            \\n            if(d1>=d2){ // Picking top element from priority queue 1  make bigger impact when d1>=d2 \\n                int temp=pq1.top();\\n                pq1.pop();\\n                if(diff>d1){\\n                    pq1.push(1);\\n                    sum1=sum1-temp+1;\\n                }\\n                else{\\n                    pq1.push(temp-diff);\\n                    sum1=sum1-diff;\\n                }\\n            }\\n            else{ //  Picking top element from priority queue 2  make bigger impact when d2>d1\\n                int temp=pq2.top();\\n                pq2.pop();\\n                if(diff>d2){\\n                    pq2.push(6);\\n                    sum2=sum2-temp+6;\\n                }\\n                else{\\n                    pq2.push(temp+diff);\\n                    sum2=sum2+diff;\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n\\n        priority_queue<int> pq1; \\n        // pq 1 will Store array with greater sum so to extract max value at every time\\n        priority_queue<int,vector<int>,greater<int>> pq2; \\n        // pq 2 will  Store array with smaller sum so to extract min value at every time\\n        int sum1=0,sum2=0;\\n        \\n\\t\\tfor(auto x:nums1){\\n            sum1+=x;\\n        }\\n        for(auto x:nums2){\\n            sum2+=x;\\n        }\\n\\t\\t\\n        if(sum1<sum2){\\n            for(auto x:nums1){\\n                pq2.push(x);\\n            }\\n            for(auto x:nums2){\\n                pq1.push(x);\\n            }\\n            swap(sum1,sum2); \\n        }\\n        else{\\n            for(auto x:nums1){\\n                pq1.push(x);\\n            }\\n            for(auto x:nums2){\\n                pq2.push(x);\\n            }\\n        }\\n\\t\\t\\n        int ans=0;\\n\\t\\t\\n        while(sum1!=sum2){\\n            int diff=abs(sum1-sum2);\\n            // No more operations can be applied \\n            if(pq1.top()==1 && pq2.top()==6){\\n                return -1;\\n            }\\n\\t\\t\\t//Check from which priority queue the element should be picked that will make bigger impact(which result in minimum operation)\\n            int d1=pq1.top()-1;\\n            int d2=6-pq2.top();\\n            \\n            if(d1>=d2){ // Picking top element from priority queue 1  make bigger impact when d1>=d2 \\n                int temp=pq1.top();\\n                pq1.pop();\\n                if(diff>d1){\\n                    pq1.push(1);\\n                    sum1=sum1-temp+1;\\n                }\\n                else{\\n                    pq1.push(temp-diff);\\n                    sum1=sum1-diff;\\n                }\\n            }\\n            else{ //  Picking top element from priority queue 2  make bigger impact when d2>d1\\n                int temp=pq2.top();\\n                pq2.pop();\\n                if(diff>d2){\\n                    pq2.push(6);\\n                    sum2=sum2-temp+6;\\n                }\\n                else{\\n                    pq2.push(temp+diff);\\n                    sum2=sum2+diff;\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1085879,
                "title": "python-greedy-solution-easy-to-understand-o-1-space",
                "content": "Below is the greed solution with time complexity O(nlogn) cause sorting and space complexity is O(1). We can also use Counter to record the number of 1 -6. It will have a O(n) time complexity and O(n) space complexity.\\n```code\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        diff = abs(sum1 - sum2)\\n        if sum1 < sum2:\\n            nums1, nums2 = nums2, nums1\\n        res = 0\\n        nums1.sort(reverse = True)\\n        nums2.sort()\\n        i, j, m, n = 0, 0, len(nums1), len(nums2)\\n        while i < m or j < n:\\n            if not diff:\\n                break\\n            if i < m and j < n:\\n                if nums1[i] - 1 >= 6 - nums2[j]:\\n                    if diff > nums1[i] - 1:\\n                        diff -= nums1[i] - 1\\n                        res += 1\\n                    else:\\n                        diff = 0\\n                        res += 1\\n                    i += 1\\n                else:\\n                    if diff > 6 - nums2[j]:\\n                        diff -= 6 - nums2[j]\\n                        res += 1\\n                    else:\\n                        diff = 0\\n                        res += 1\\n                    j += 1\\n            elif i < m:\\n                if diff > nums1[i] - 1:\\n                    diff -= nums1[i] - 1\\n                    res += 1\\n                else:\\n                    diff = 0\\n                    res += 1\\n                i += 1\\n            else:\\n                if diff > 6 - nums2[j]:\\n                    diff -= 6 - nums2[j]\\n                    res += 1\\n                else:\\n                    diff = 0\\n                    res += 1\\n                j += 1\\n        return res if not diff else -1",
                "solutionTags": [],
                "code": "Below is the greed solution with time complexity O(nlogn) cause sorting and space complexity is O(1). We can also use Counter to record the number of 1 -6. It will have a O(n) time complexity and O(n) space complexity.\\n```code\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        diff = abs(sum1 - sum2)\\n        if sum1 < sum2:\\n            nums1, nums2 = nums2, nums1\\n        res = 0\\n        nums1.sort(reverse = True)\\n        nums2.sort()\\n        i, j, m, n = 0, 0, len(nums1), len(nums2)\\n        while i < m or j < n:\\n            if not diff:\\n                break\\n            if i < m and j < n:\\n                if nums1[i] - 1 >= 6 - nums2[j]:\\n                    if diff > nums1[i] - 1:\\n                        diff -= nums1[i] - 1\\n                        res += 1\\n                    else:\\n                        diff = 0\\n                        res += 1\\n                    i += 1\\n                else:\\n                    if diff > 6 - nums2[j]:\\n                        diff -= 6 - nums2[j]\\n                        res += 1\\n                    else:\\n                        diff = 0\\n                        res += 1\\n                    j += 1\\n            elif i < m:\\n                if diff > nums1[i] - 1:\\n                    diff -= nums1[i] - 1\\n                    res += 1\\n                else:\\n                    diff = 0\\n                    res += 1\\n                i += 1\\n            else:\\n                if diff > 6 - nums2[j]:\\n                    diff -= 6 - nums2[j]\\n                    res += 1\\n                else:\\n                    diff = 0\\n                    res += 1\\n                j += 1\\n        return res if not diff else -1",
                "codeTag": "Java"
            },
            {
                "id": 1085832,
                "title": "python-solution-o-n",
                "content": "```\\n\\nclass Solution(object):\\n    def minOperations(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if min(len(nums1), len(nums2)) * 6 < max(len(nums1), len(nums2)) * 1:\\n            return -1\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if s1 == s2:\\n            return 0\\n        elif s1 > s2:\\n            nums1, nums2 = nums2, nums1\\n            s1, s2 = s2, s1\\n        diff = s2 - s1\\n\\n        dic1 = collections.Counter(nums1)\\n        dic2 = collections.Counter(nums2)\\n        dic = {}\\n        lst = []\\n\\n        for i in range(6, 0, -1):\\n            dic[i] = dic1[i] + dic2[7-i]\\n            lst += [i for _ in range(dic[i])]\\n\\n        cnt = 0    \\n\\n        while lst and diff > 0:\\n            diff -= 6 - lst.pop()  # start the operation with elements that lead to the largest possible change\\n            cnt += 1\\n        return cnt\\n```        \\n            \\n            \\n            \\n   \\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def minOperations(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if min(len(nums1), len(nums2)) * 6 < max(len(nums1), len(nums2)) * 1:\\n            return -1\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if s1 == s2:\\n            return 0\\n        elif s1 > s2:\\n            nums1, nums2 = nums2, nums1\\n            s1, s2 = s2, s1\\n        diff = s2 - s1\\n\\n        dic1 = collections.Counter(nums1)\\n        dic2 = collections.Counter(nums2)\\n        dic = {}\\n        lst = []\\n\\n        for i in range(6, 0, -1):\\n            dic[i] = dic1[i] + dic2[7-i]\\n            lst += [i for _ in range(dic[i])]\\n\\n        cnt = 0    \\n\\n        while lst and diff > 0:\\n            diff -= 6 - lst.pop()  # start the operation with elements that lead to the largest possible change\\n            cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085791,
                "title": "python-o-nlogn-with-description",
                "content": "```\\n    def minOperations(self, nums1, nums2):\\n        if sum(nums1) == sum(nums2): #replace nums1 and nums2 in such away that sum(nums1) is always bigger than sum(num2) \\n            return 0\\n        elif sum(nums2) > sum(nums1):\\n            nums1 , nums2 = nums2,nums1\\n        \\n        su1 = sum(nums1)\\n        su2 = sum(nums2)\\n      \\n        cnt = 0\\n        dif = su1-su2\\n        nums1 = sorted(nums1,reverse = True) #sort the nums1 and nums2 in such a way that in each step we select biggest number to decrease and increse \\n        nums2 = sorted(nums2)\\n        tmpnums1 = []\\n        tmpnums2 = []\\n        for i in range(len(nums1)):\\n            if nums1[i] - 1 != 0:\\n                tmpnums1.append(nums1[i] - 1)\\n        for j in range(len(nums2)):\\n            if (6 - nums2[j] != 0):\\n                tmpnums2.append(6 - nums2[j])\\n        \\n        \\n        \\n        while dif >= 0 : # while dif != 0 decrese diff and max(tmpnums1,tmpnums2) to find the smallest diff\\n            if tmpnums1 == [] and tmpnums2 == [] and dif != 0 :\\n                return -1\\n            elif tmpnums2== [] or (tmpnums1 and tmpnums1[0] >= tmpnums2[0]): \\n                dif -= min(tmpnums1[0],dif)\\n                tmpnums1.pop(0)\\n                cnt+=1\\n                \\n            elif tmpnums1 == [] or (tmpnums2 and tmpnums1[0] < tmpnums2[0]):\\n                dif -= min(tmpnums2[0],dif)\\n                tmpnums2.pop(0)\\n                cnt+=1\\n            \\n            if dif == 0:\\n                return cnt\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minOperations(self, nums1, nums2):\\n        if sum(nums1) == sum(nums2): #replace nums1 and nums2 in such away that sum(nums1) is always bigger than sum(num2) \\n            return 0\\n        elif sum(nums2) > sum(nums1):\\n            nums1 , nums2 = nums2,nums1\\n        \\n        su1 = sum(nums1)\\n        su2 = sum(nums2)\\n      \\n        cnt = 0\\n        dif = su1-su2\\n        nums1 = sorted(nums1,reverse = True) #sort the nums1 and nums2 in such a way that in each step we select biggest number to decrease and increse \\n        nums2 = sorted(nums2)\\n        tmpnums1 = []\\n        tmpnums2 = []\\n        for i in range(len(nums1)):\\n            if nums1[i] - 1 != 0:\\n                tmpnums1.append(nums1[i] - 1)\\n        for j in range(len(nums2)):\\n            if (6 - nums2[j] != 0):\\n                tmpnums2.append(6 - nums2[j])\\n        \\n        \\n        \\n        while dif >= 0 : # while dif != 0 decrese diff and max(tmpnums1,tmpnums2) to find the smallest diff\\n            if tmpnums1 == [] and tmpnums2 == [] and dif != 0 :\\n                return -1\\n            elif tmpnums2== [] or (tmpnums1 and tmpnums1[0] >= tmpnums2[0]): \\n                dif -= min(tmpnums1[0],dif)\\n                tmpnums1.pop(0)\\n                cnt+=1\\n                \\n            elif tmpnums1 == [] or (tmpnums2 and tmpnums1[0] < tmpnums2[0]):\\n                dif -= min(tmpnums2[0],dif)\\n                tmpnums2.pop(0)\\n                cnt+=1\\n            \\n            if dif == 0:\\n                return cnt\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1085788,
                "title": "python-greedy-solution-o-n",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        mins = [ len(nums1), len(nums2) ]\\n        maxs = [ len(nums1) * 6, len(nums2) * 6 ]\\n        if mins[0] > maxs[1] or mins[1] > maxs[0]:\\n            return -1\\n        \\n        isOneLower = False\\n        sums = [ sum(nums1), sum(nums2) ]\\n        if sums[0] == sums[1]:\\n            return 0\\n        elif sums[0] < sums[1]:\\n            isOneLower = True\\n        diff = abs(sums[1] - sums[0])\\n        \\n        if isOneLower:\\n            nums1 = list(map(lambda x : 6 - x, nums1))\\n            nums2 = list(map(lambda x : x - 1, nums2))\\n        else:\\n            nums1 = list(map(lambda x : x - 1, nums1))\\n            nums2 = list(map(lambda x : 6 - x, nums2))\\n        \\n        nums = nums1 + nums2\\n        nums.sort(reverse=True)\\n        i = 0\\n        while diff > 0:\\n            diff = diff - nums[i]\\n            i += 1\\n        return i\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        mins = [ len(nums1), len(nums2) ]\\n        maxs = [ len(nums1) * 6, len(nums2) * 6 ]\\n        if mins[0] > maxs[1] or mins[1] > maxs[0]:\\n            return -1\\n        \\n        isOneLower = False\\n        sums = [ sum(nums1), sum(nums2) ]\\n        if sums[0] == sums[1]:\\n            return 0\\n        elif sums[0] < sums[1]:\\n            isOneLower = True\\n        diff = abs(sums[1] - sums[0])\\n        \\n        if isOneLower:\\n            nums1 = list(map(lambda x : 6 - x, nums1))\\n            nums2 = list(map(lambda x : x - 1, nums2))\\n        else:\\n            nums1 = list(map(lambda x : x - 1, nums1))\\n            nums2 = list(map(lambda x : 6 - x, nums2))\\n        \\n        nums = nums1 + nums2\\n        nums.sort(reverse=True)\\n        i = 0\\n        while diff > 0:\\n            diff = diff - nums[i]\\n            i += 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085784,
                "title": "java-pq-solution-easy-to-understand",
                "content": "```\\npublic int minOperations(int[] nums1, int[] nums2) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->(b-a));\\n        int sum1=0,sum2=0;\\n        for(int num:nums1)\\n            sum1+=num;\\n        for(int num:nums2)\\n            sum2+=num;\\n        int dis=Math.abs(sum1-sum2);\\n        for(int num:nums1){\\n            if(sum1>sum2) pq.add(num-1);\\n            else pq.add(6-num);\\n        }\\n        for(int num:nums2){\\n            if(sum1>sum2) pq.add(6-num);\\n            else pq.add(num-1);\\n        }\\n        int res=0;\\n        while(!pq.isEmpty()&&dis>0){\\n            int cur=pq.poll();\\n            dis-=cur;\\n            res++;\\n        }\\n        if(dis<=0) return res;\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(int[] nums1, int[] nums2) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)->(b-a));\\n        int sum1=0,sum2=0;\\n        for(int num:nums1)\\n            sum1+=num;\\n        for(int num:nums2)\\n            sum2+=num;\\n        int dis=Math.abs(sum1-sum2);\\n        for(int num:nums1){\\n            if(sum1>sum2) pq.add(num-1);\\n            else pq.add(6-num);\\n        }\\n        for(int num:nums2){\\n            if(sum1>sum2) pq.add(6-num);\\n            else pq.add(num-1);\\n        }\\n        int res=0;\\n        while(!pq.isEmpty()&&dis>0){\\n            int cur=pq.poll();\\n            dis-=cur;\\n            res++;\\n        }\\n        if(dis<=0) return res;\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038505,
                "title": "in-place-sort-find-maximum-step-size-o-n-logn-time-complexity-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        sum1=sum(nums1)\\n        sum2=sum(nums2)\\n\\n        if sum2> sum1: \\n            nums1, nums2 = nums2, nums1\\n            sum1, sum2 = sum2, sum1\\n        \\n        nums1.sort()\\n        nums2.sort(reverse = True)\\n        m=len(nums1)\\n        n=len(nums2)\\n\\n        if max(m,n) *1 > min(m,n) *6: return -1\\n\\n        ans=0\\n\\n        while sum1 > sum2: \\n\\n            if nums1:\\n                maxdecrease = nums1[-1]-1\\n            else: maxdecrease=0\\n\\n            if nums2:\\n                maxincrease = 6 - nums2[-1]\\n            else: maxincrease=0\\n\\n            if maxdecrease > maxincrease: \\n\\n                sum1 -= maxdecrease\\n                nums1.pop()\\n            else: \\n                sum2 += maxincrease\\n                nums2.pop()\\n\\n            # print(nums1, nums2)\\n            ans+=1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        sum1=sum(nums1)\\n        sum2=sum(nums2)\\n\\n        if sum2> sum1: \\n            nums1, nums2 = nums2, nums1\\n            sum1, sum2 = sum2, sum1\\n        \\n        nums1.sort()\\n        nums2.sort(reverse = True)\\n        m=len(nums1)\\n        n=len(nums2)\\n\\n        if max(m,n) *1 > min(m,n) *6: return -1\\n\\n        ans=0\\n\\n        while sum1 > sum2: \\n\\n            if nums1:\\n                maxdecrease = nums1[-1]-1\\n            else: maxdecrease=0\\n\\n            if nums2:\\n                maxincrease = 6 - nums2[-1]\\n            else: maxincrease=0\\n\\n            if maxdecrease > maxincrease: \\n\\n                sum1 -= maxdecrease\\n                nums1.pop()\\n            else: \\n                sum2 += maxincrease\\n                nums2.pop()\\n\\n            # print(nums1, nums2)\\n            ans+=1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038210,
                "title": "simple-c-solution",
                "content": "# Intuition\\nIf we simply count the number of times each element appears in two arrays and maintain it in separate vectors, then we increase the lowest number say 1 to 6 in vector that has lower sum and decrease the highest number say 6 to 1 in vector that has higher sum and continue doing this till we get difference of sums equal to zero.\\n\\n# Approach\\nExample - \\nnums1 - {1, 2, 3, 4, 5, 6}\\nnums2 - {1, 1, 2, 2, 2, 2}\\nfreq_nums1 - {0, 1, 1, 1, 1, 1, 1}\\nfreq_nums2 - {0, 2, 4, 0, 0, 0, 0}\\nsum1 = 21\\nsum2 = 10\\ndiff = 11\\nIt is very natural here that we increase integer 1 in nums2 to 6 and integer 6 in nums1 to 1 making our diff = 1.\\nNow the difference is small enough to change either any other number of the two arrays to make the sum equal.\\n\\n# Complexity\\n- Time complexity:\\nO(n) or O(m) depending if n > m or m > n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int min_nums2_sum = 1*nums2.size();\\n        int max_nums2_sum = 6*nums2.size();\\n        int min_nums1_sum = 1*nums1.size();\\n        int max_nums1_sum = 6*nums1.size();\\n        if (min_nums1_sum > max_nums2_sum ||\\n            min_nums2_sum > max_nums1_sum) {\\n            return -1;\\n        }\\n        vector<int> freq_map1(7, 0);\\n        vector<int> freq_map2(7, 0);\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for (int i = 0; i < nums1.size(); i++) {\\n            sum1 += nums1[i];\\n            freq_map1[nums1[i]]++;\\n        }\\n        for (int i = 0; i < nums2.size(); i++) {\\n            sum2 += nums2[i];\\n            freq_map2[nums2[i]]++;\\n        }\\n        if (sum1 == sum2) {\\n            return 0;\\n        }\\n        int minOps = 0;\\n        int diff = sum1 - sum2;\\n        if (sum1 < sum2) {\\n            int diff = sum2 - sum1;\\n            int i = 6; \\n            int j = 1;\\n            for (i = 6, j = 1; i >= 1 && j <= 6; i--, j++) {\\n                int diff_d = diff/(i);\\n                int diff_m = diff%(i);\\n                if (diff_d > 0) {\\n                    while (freq_map2[i] > 0 && diff_d > 0) {\\n                        diff -= (i-1);\\n                        diff_d = diff/i;\\n                        freq_map2[i]--;\\n                        //freq_map2[7-i]++;\\n                        minOps++;\\n                    }\\n                    while (freq_map1[j] > 0 && diff_d > 0) {\\n                        diff -= (i-1);\\n                        diff_d = diff/i;\\n                        freq_map1[j]--;\\n                        //freq_map1[7-j]++;\\n                        minOps++;\\n                    }\\n                }\\n                if (diff_d == 0) {\\n                    return minOps + 1;\\n\\n                }\\n            }\\n            \\n        } else {\\n            int i = 6;\\n            int j = 1;\\n            for (i = 6, j = 1; i >= 1 && j <= 6; i--, j++) {\\n                int diff_d = diff/(i);\\n                int diff_m = diff%(i);\\n                if (diff_d > 0) {\\n                    while (freq_map1[i] > 0 && diff_d > 0) {\\n                        diff -= (i-1);\\n                        diff_d = diff/i;\\n                        freq_map1[i]--;\\n                        //freq_map1[7-i]++;\\n                        minOps++;\\n                    }\\n                    while (freq_map2[j] > 0 && diff_d > 0) {\\n                        diff -= (i-1);\\n                        diff_d = diff/i;\\n                        freq_map2[j]--;\\n                        //freq_map2[7-j]++;\\n                        minOps++;\\n                    }\\n                }\\n                if (diff_d == 0) {\\n                    return minOps + 1;\\n\\n                }\\n            }\\n            \\n        }\\n        return minOps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int min_nums2_sum = 1*nums2.size();\\n        int max_nums2_sum = 6*nums2.size();\\n        int min_nums1_sum = 1*nums1.size();\\n        int max_nums1_sum = 6*nums1.size();\\n        if (min_nums1_sum > max_nums2_sum ||\\n            min_nums2_sum > max_nums1_sum) {\\n            return -1;\\n        }\\n        vector<int> freq_map1(7, 0);\\n        vector<int> freq_map2(7, 0);\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for (int i = 0; i < nums1.size(); i++) {\\n            sum1 += nums1[i];\\n            freq_map1[nums1[i]]++;\\n        }\\n        for (int i = 0; i < nums2.size(); i++) {\\n            sum2 += nums2[i];\\n            freq_map2[nums2[i]]++;\\n        }\\n        if (sum1 == sum2) {\\n            return 0;\\n        }\\n        int minOps = 0;\\n        int diff = sum1 - sum2;\\n        if (sum1 < sum2) {\\n            int diff = sum2 - sum1;\\n            int i = 6; \\n            int j = 1;\\n            for (i = 6, j = 1; i >= 1 && j <= 6; i--, j++) {\\n                int diff_d = diff/(i);\\n                int diff_m = diff%(i);\\n                if (diff_d > 0) {\\n                    while (freq_map2[i] > 0 && diff_d > 0) {\\n                        diff -= (i-1);\\n                        diff_d = diff/i;\\n                        freq_map2[i]--;\\n                        //freq_map2[7-i]++;\\n                        minOps++;\\n                    }\\n                    while (freq_map1[j] > 0 && diff_d > 0) {\\n                        diff -= (i-1);\\n                        diff_d = diff/i;\\n                        freq_map1[j]--;\\n                        //freq_map1[7-j]++;\\n                        minOps++;\\n                    }\\n                }\\n                if (diff_d == 0) {\\n                    return minOps + 1;\\n\\n                }\\n            }\\n            \\n        } else {\\n            int i = 6;\\n            int j = 1;\\n            for (i = 6, j = 1; i >= 1 && j <= 6; i--, j++) {\\n                int diff_d = diff/(i);\\n                int diff_m = diff%(i);\\n                if (diff_d > 0) {\\n                    while (freq_map1[i] > 0 && diff_d > 0) {\\n                        diff -= (i-1);\\n                        diff_d = diff/i;\\n                        freq_map1[i]--;\\n                        //freq_map1[7-i]++;\\n                        minOps++;\\n                    }\\n                    while (freq_map2[j] > 0 && diff_d > 0) {\\n                        diff -= (i-1);\\n                        diff_d = diff/i;\\n                        freq_map2[j]--;\\n                        //freq_map2[7-j]++;\\n                        minOps++;\\n                    }\\n                }\\n                if (diff_d == 0) {\\n                    return minOps + 1;\\n\\n                }\\n            }\\n            \\n        }\\n        return minOps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033756,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n    if (nums1.size() * 6 < nums2.size() || nums2.size() * 6 < nums1.size())\\n      return -1;\\n\\n    int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n    int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n    if (sum1 > sum2)\\n      return minOperations(nums2, nums1);\\n\\n    int ans = 0;\\n    // Increases in nums1 & decreases in nums2\\n    vector<int> count(6);\\n\\n    for (const int num : nums1)\\n      ++count[6 - num];\\n\\n    for (const int num : nums2)\\n      ++count[num - 1];\\n\\n    for (int i = 5; sum2 > sum1;) {\\n      while (count[i] == 0)\\n        --i;\\n      sum1 += i;\\n      --count[i];\\n      ++ans;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n    if (nums1.size() * 6 < nums2.size() || nums2.size() * 6 < nums1.size())\\n      return -1;\\n\\n    int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n    int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n    if (sum1 > sum2)\\n      return minOperations(nums2, nums1);\\n\\n    int ans = 0;\\n    // Increases in nums1 & decreases in nums2\\n    vector<int> count(6);\\n\\n    for (const int num : nums1)\\n      ++count[6 - num];\\n\\n    for (const int num : nums2)\\n      ++count[num - 1];\\n\\n    for (int i = 5; sum2 > sum1;) {\\n      while (count[i] == 0)\\n        --i;\\n      sum1 += i;\\n      --count[i];\\n      ++ans;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975460,
                "title": "optimized-greedy-approach-to-minimize-operations-for-equal-array-sums",
                "content": "# Minimum Operations to Make Sum of Two Arrays Equal\\n\\n## Problem Description\\n\\nYou are given two arrays of integers `nums1` and `nums2`, possibly of different lengths. The values in the arrays are between 1 and 6, inclusive.\\n\\nIn one operation, you can change any integer\\'s value in any of the arrays to any value between 1 and 6, inclusive.\\n\\nReturn the minimum number of operations required to make the sum of values in `nums1` equal to the sum of values in `nums2`. Return -1 if it is not possible to make the sum of the two arrays equal.\\n\\n## Intuition\\n\\nThe problem can be solved by trying to bridge the gap between the sum of the two arrays. We can achieve this by either increasing the sum of the smaller array or decreasing the sum of the larger array, or both.\\n\\n## Approach\\n\\n1. Sort both arrays.\\n2. Calculate the sums of both arrays.\\n3. Depending on which array has a greater sum, use a helper function to determine the minimum number of operations needed.\\n\\n## Algorithm\\n\\n1. Sort `nums1` and `nums2`.\\n2. Calculate `sumNums1` and `sumNums2`.\\n3. If `sumNums1` is greater, call the helper function with `nums1` and `nums2`.\\n4. Else, call the helper function with `nums2` and `nums1`.\\n\\n### Helper Function\\n\\n#### Purpose\\n\\nThe `helper` function is designed to find the minimum number of operations needed to make the sums of two arrays, `numsGreater` and `numsLessThan`, equal. Here `numsGreater` is the array with the larger sum, and `numsLessThan` has the smaller sum. The variables `s1` and `s2` store these sums, respectively.\\n\\n#### Steps\\n\\n1. **Calculate the Extremes**: The function starts by calculating the lowest possible sum for `numsGreater` (if all elements are 1) and the highest possible sum for `numsLessThan` (if all elements are 6).\\n\\n2. **Check Feasibility**: If it\\'s not possible to make the sums equal by changing the elements, the function returns -1. This is checked by comparing `lowestPossibleNumsGreater` and `highestPossibleNumsLessThan`.\\n\\n3. **Initialize Pointers and Counters**: Two pointers `i` and `j` are initialized to traverse `numsGreater` and `numsLessThan`, respectively. The variable `ops` counts the number of operations.\\n\\n4. **Iterate and Update**: The function enters a loop that iterates as long as one of the pointers is within the array bounds. In each iteration:\\n    - It checks if the sums are already equal; if so, it breaks out of the loop.\\n    - It calculates the maximum possible change for both arrays (`change1` for `numsGreater` and `change2` for `numsLessThan`).\\n    - Depending on which change is larger, it updates the corresponding sum and moves the pointer.\\n    - Increments the operations counter `ops`.\\n\\n#### Return Value\\n\\nThe function returns the minimum number of operations `ops` needed to make the sums equal.\\n\\n## Complexity Analysis\\n\\n- **Time Complexity:** \\\\( O(n \\\\log n) \\\\) where \\\\( n \\\\) is the length of the longest array. This is because we sort both arrays.\\n- **Space Complexity:** \\\\( O(1) \\\\) for constant space.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n\\n        sumNums1 = sum(nums1)\\n        sumNums2 = sum(nums2)\\n\\n        if sumNums1 == sumNums2:\\n            return 0\\n        \\n        if sumNums1>sumNums2:\\n            return self.helper(nums1, nums2, sumNums1, sumNums2)\\n        \\n        return self.helper(nums2, nums1, sumNums2, sumNums1)\\n    \\n    def helper(self, numsGreater: List[int], numsLessThan: List[int], s1:int, s2:int) -> int:\\n        lowestPossibleNumsGreater = len(numsGreater) # when all are 1\\n        highestPossibleNumsLessThan = len(numsLessThan) * 6 # when all are 6\\n\\n        if highestPossibleNumsLessThan < lowestPossibleNumsGreater:\\n            return -1\\n        \\n        i = len(numsGreater) -1\\n        j = 0\\n        ops = 0\\n\\n        while i>=0 or j<len(numsLessThan):\\n            if s1<=s2:\\n                break\\n            change1 = -1 #represents the value which can be decreased in arr1\\n            change2 = -1 #represents by how much we can increase the sum of arr2\\n            # initialized them as -1 as it might be that one of the arr is completely used so we should not do any ops \\n            if i>=0:\\n                change1 = numsGreater[i] -1\\n            if j<len(numsLessThan):\\n                change2 = 6 - numsLessThan[j]\\n            \\n            if change1 >= change2:\\n                s1 = s1 - numsGreater[i] + 1\\n                i-=1\\n            else:\\n                s2 = s2 + 6 -  numsLessThan[j]\\n                j+=1\\n            \\n            ops+=1\\n\\n        \\n        return ops\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n\\n        sumNums1 = sum(nums1)\\n        sumNums2 = sum(nums2)\\n\\n        if sumNums1 == sumNums2:\\n            return 0\\n        \\n        if sumNums1>sumNums2:\\n            return self.helper(nums1, nums2, sumNums1, sumNums2)\\n        \\n        return self.helper(nums2, nums1, sumNums2, sumNums1)\\n    \\n    def helper(self, numsGreater: List[int], numsLessThan: List[int], s1:int, s2:int) -> int:\\n        lowestPossibleNumsGreater = len(numsGreater) # when all are 1\\n        highestPossibleNumsLessThan = len(numsLessThan) * 6 # when all are 6\\n\\n        if highestPossibleNumsLessThan < lowestPossibleNumsGreater:\\n            return -1\\n        \\n        i = len(numsGreater) -1\\n        j = 0\\n        ops = 0\\n\\n        while i>=0 or j<len(numsLessThan):\\n            if s1<=s2:\\n                break\\n            change1 = -1 #represents the value which can be decreased in arr1\\n            change2 = -1 #represents by how much we can increase the sum of arr2\\n            # initialized them as -1 as it might be that one of the arr is completely used so we should not do any ops \\n            if i>=0:\\n                change1 = numsGreater[i] -1\\n            if j<len(numsLessThan):\\n                change2 = 6 - numsLessThan[j]\\n            \\n            if change1 >= change2:\\n                s1 = s1 - numsGreater[i] + 1\\n                i-=1\\n            else:\\n                s2 = s2 + 6 -  numsLessThan[j]\\n                j+=1\\n            \\n            ops+=1\\n\\n        \\n        return ops\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973296,
                "title": "simple-c-greedy-solution-using-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& arr1, vector<int>& arr2) {\\n        int n = arr1.size();\\n        int m = arr2.size();\\n\\n        sort(arr1.begin(), arr1.end());\\n        sort(arr2.begin() , arr2.end());\\n\\n        int sum1 = accumulate(arr1.begin()  , arr1.end() , 0);\\n        int sum2 = accumulate(arr2.begin()  , arr2.end() , 0);\\n\\n        if(sum1==sum2) return 0;\\n\\n        \\n\\n        if(sum1>sum2){\\n            priority_queue<int> q;\\n            for(int i=0 ; i<n ; i++){\\n                if(arr1[i]>1)q.push(arr1[i]-1);\\n            }\\n            for(int i=0 ; i<m ; i++){\\n                if(arr2[i]<6)q.push(6-arr2[i]);\\n            }\\n\\n            int ct = 0;\\n\\n            while(!q.empty() and sum1>sum2){\\n                ct++;\\n                sum1 -= q.top();\\n                q.pop();\\n            }\\n\\n            if(sum1>sum2) return -1;\\n\\n            return ct;\\n        }\\n\\n        priority_queue<int> q;\\n        for(int i=0 ; i<m ; i++){\\n            if(arr2[i]>1)q.push(arr2[i]-1);\\n        }\\n        for(int i=0 ; i<n ; i++){\\n            if(arr1[i]<6)q.push(6-arr1[i]);\\n        }\\n\\n        int ct = 0;\\n\\n        while(!q.empty() and sum2>sum1){\\n            ct++;\\n            sum2 -= q.top();\\n            q.pop();\\n        }\\n\\n        if(sum2>sum1) return -1;\\n\\n        return ct;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& arr1, vector<int>& arr2) {\\n        int n = arr1.size();\\n        int m = arr2.size();\\n\\n        sort(arr1.begin(), arr1.end());\\n        sort(arr2.begin() , arr2.end());\\n\\n        int sum1 = accumulate(arr1.begin()  , arr1.end() , 0);\\n        int sum2 = accumulate(arr2.begin()  , arr2.end() , 0);\\n\\n        if(sum1==sum2) return 0;\\n\\n        \\n\\n        if(sum1>sum2){\\n            priority_queue<int> q;\\n            for(int i=0 ; i<n ; i++){\\n                if(arr1[i]>1)q.push(arr1[i]-1);\\n            }\\n            for(int i=0 ; i<m ; i++){\\n                if(arr2[i]<6)q.push(6-arr2[i]);\\n            }\\n\\n            int ct = 0;\\n\\n            while(!q.empty() and sum1>sum2){\\n                ct++;\\n                sum1 -= q.top();\\n                q.pop();\\n            }\\n\\n            if(sum1>sum2) return -1;\\n\\n            return ct;\\n        }\\n\\n        priority_queue<int> q;\\n        for(int i=0 ; i<m ; i++){\\n            if(arr2[i]>1)q.push(arr2[i]-1);\\n        }\\n        for(int i=0 ; i<n ; i++){\\n            if(arr1[i]<6)q.push(6-arr1[i]);\\n        }\\n\\n        int ct = 0;\\n\\n        while(!q.empty() and sum2>sum1){\\n            ct++;\\n            sum2 -= q.top();\\n            q.pop();\\n        }\\n\\n        if(sum2>sum1) return -1;\\n\\n        return ct;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928064,
                "title": "easy-fast-solution",
                "content": "# Approach\\ncheck initial difference then sort them if sum of first array is greater then sort it **descendingly** since we have to subtract from it in **minimum** possible moves and ascending for other array since we can only add in that. **If the difference between 1 and larger array element is greater than between 6 and smaller array element then take it first to subtract fron total SUM difference and vice versa**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O( NLogN )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O( 1 )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n  int sol ( vector<int>& a , vector<int>& b , int& d ) {\\n    sort ( a.begin ( ) , a.end ( ) , greater<int> ( ) );\\n    sort ( b.begin ( ) , b.end ( ) );\\n    int in = 0 , jn = 0 , ans = 0;\\n    while ( d > 0 ) {\\n      if ( in == a.size ( ) and jn == b.size ( ) ) return -1;\\n      int p = in < a.size ( ) ? a [ in ] - 1 : -1 , q = jn < b.size ( ) ? 6 - b [ jn ] : -1;\\n      if ( p > q ) {\\n        ++in;\\n        if ( p < d ) d -= p;\\n        else return ++ans;\\n        }\\n      else {\\n        ++jn;\\n        if ( q < d ) d -= q;\\n        else return ++ans;\\n        }\\n      ++ans;\\n      }\\n    return ans;\\n    }\\n\\n  int minOperations ( vector<int>& a , vector<int>& b ) {\\n    int sa = accumulate ( a.begin ( ) , a.end ( ) , 0 ) , sb = accumulate ( b.begin ( ) , b.end ( ) , 0 ) , d = sa - sb;\\n    if ( d >= 0 ) return sol ( a , b , d );\\n    d = -d;\\n    return sol ( b , a , d );\\n    }\\n  };\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n  int sol ( vector<int>& a , vector<int>& b , int& d ) {\\n    sort ( a.begin ( ) , a.end ( ) , greater<int> ( ) );\\n    sort ( b.begin ( ) , b.end ( ) );\\n    int in = 0 , jn = 0 , ans = 0;\\n    while ( d > 0 ) {\\n      if ( in == a.size ( ) and jn == b.size ( ) ) return -1;\\n      int p = in < a.size ( ) ? a [ in ] - 1 : -1 , q = jn < b.size ( ) ? 6 - b [ jn ] : -1;\\n      if ( p > q ) {\\n        ++in;\\n        if ( p < d ) d -= p;\\n        else return ++ans;\\n        }\\n      else {\\n        ++jn;\\n        if ( q < d ) d -= q;\\n        else return ++ans;\\n        }\\n      ++ans;\\n      }\\n    return ans;\\n    }\\n\\n  int minOperations ( vector<int>& a , vector<int>& b ) {\\n    int sa = accumulate ( a.begin ( ) , a.end ( ) , 0 ) , sb = accumulate ( b.begin ( ) , b.end ( ) , 0 ) , d = sa - sb;\\n    if ( d >= 0 ) return sol ( a , b , d );\\n    d = -d;\\n    return sol ( b , a , d );\\n    }\\n  };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881282,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2,int sm1,int sm2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0,j=nums2.size()-1;\\n        int ans=0;\\n        int dif=sm2-sm1;\\n        \\n        while(dif>0 && (j >= 0 || i<nums1.size())  )\\n        {\\n            if(j < 0 || i<nums1.size() && 6-nums1[i]>nums2[j]-1)\\n            {\\n                dif-=6-nums1[i++];\\n            }\\n            else\\n            {\\n                dif-=nums2[j--]-1;\\n            }\\n            ans++;\\n           \\n        }\\n        return dif>0? -1 :ans;\\n    }\\n    \\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sm1=0,sm2=0;\\n        for(auto n : nums1)\\n        {\\n            sm1+=n;\\n        }\\n        for(auto n : nums2)\\n        {\\n            sm2+=n;\\n        }\\n        if(sm1==sm2) return 0;\\n        if (sm1 > sm2) \\n            return minOperations(nums2, nums1,sm2,sm1); \\n        return minOperations(nums1, nums2,sm1,sm2); \\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2,int sm1,int sm2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0,j=nums2.size()-1;\\n        int ans=0;\\n        int dif=sm2-sm1;\\n        \\n        while(dif>0 && (j >= 0 || i<nums1.size())  )\\n        {\\n            if(j < 0 || i<nums1.size() && 6-nums1[i]>nums2[j]-1)\\n            {\\n                dif-=6-nums1[i++];\\n            }\\n            else\\n            {\\n                dif-=nums2[j--]-1;\\n            }\\n            ans++;\\n           \\n        }\\n        return dif>0? -1 :ans;\\n    }\\n    \\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sm1=0,sm2=0;\\n        for(auto n : nums1)\\n        {\\n            sm1+=n;\\n        }\\n        for(auto n : nums2)\\n        {\\n            sm2+=n;\\n        }\\n        if(sm1==sm2) return 0;\\n        if (sm1 > sm2) \\n            return minOperations(nums2, nums1,sm2,sm1); \\n        return minOperations(nums1, nums2,sm1,sm2); \\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873502,
                "title": "greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if intervals overlap, if not return -1\\n2. Use map to compress array\\n3. Perform linear scan\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < nums1.size(); i++) sum1 += nums1[i];\\n        for (int i = 0; i < nums2.size(); i++) sum2 += nums2[i];\\n\\n        if (sum1 == sum2) return 0;\\n\\n        int lo1 = nums1.size(), hi1 = nums1.size() * 6;\\n        int lo2 = nums2.size(), hi2 = nums2.size() * 6;\\n\\n        // check if intervals overlap\\n        if (std::min(hi1, hi2) < std::max(lo1, lo2)) return -1;\\n        \\n        if (sum1 > sum2) {\\n            std::swap(nums1, nums2);\\n            std::swap(sum1, sum2);\\n        }\\n\\n        std::vector<int> count1(7, 0);\\n        for (auto e: nums1) count1[e]++;\\n\\n        std::vector<int> count2(7, 0);\\n        for (auto e: nums2) count2[e]++;\\n\\n\\n        int moves = 0;\\n        int i = 1, j = 6;\\n\\n        while (true) {\\n            auto d1 = i < 7? (6 - i) * count1[i] : INT_MIN;\\n            auto d2 = j > 0? (j - 1) * count2[j] : INT_MIN;\\n\\n            if (6 - i > j - 1) {\\n                if (sum1 + d1 >= sum2) {\\n                    return moves + std::ceil((float)(sum2 - sum1) / (6 - i));\\n                }\\n                sum1 += d1; moves += count1[i]; i++;\\n            } else {\\n                if (sum2 - d2 <= sum1) {\\n                    return moves + std::ceil((float)(sum2 - sum1) / (j - 1));\\n                }\\n                sum2 -= d2; moves += count2[j]; j--;\\n            }\\n        }\\n        return -1; // wont be used;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < nums1.size(); i++) sum1 += nums1[i];\\n        for (int i = 0; i < nums2.size(); i++) sum2 += nums2[i];\\n\\n        if (sum1 == sum2) return 0;\\n\\n        int lo1 = nums1.size(), hi1 = nums1.size() * 6;\\n        int lo2 = nums2.size(), hi2 = nums2.size() * 6;\\n\\n        // check if intervals overlap\\n        if (std::min(hi1, hi2) < std::max(lo1, lo2)) return -1;\\n        \\n        if (sum1 > sum2) {\\n            std::swap(nums1, nums2);\\n            std::swap(sum1, sum2);\\n        }\\n\\n        std::vector<int> count1(7, 0);\\n        for (auto e: nums1) count1[e]++;\\n\\n        std::vector<int> count2(7, 0);\\n        for (auto e: nums2) count2[e]++;\\n\\n\\n        int moves = 0;\\n        int i = 1, j = 6;\\n\\n        while (true) {\\n            auto d1 = i < 7? (6 - i) * count1[i] : INT_MIN;\\n            auto d2 = j > 0? (j - 1) * count2[j] : INT_MIN;\\n\\n            if (6 - i > j - 1) {\\n                if (sum1 + d1 >= sum2) {\\n                    return moves + std::ceil((float)(sum2 - sum1) / (6 - i));\\n                }\\n                sum1 += d1; moves += count1[i]; i++;\\n            } else {\\n                if (sum2 - d2 <= sum1) {\\n                    return moves + std::ceil((float)(sum2 - sum1) / (j - 1));\\n                }\\n                sum2 -= d2; moves += count2[j]; j--;\\n            }\\n        }\\n        return -1; // wont be used;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848144,
                "title": "python3-beats-98-98-greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nShould be a greedy problem, because we need to find the most profitable element to turn it either into 1 / 6 to make the sum of both arr the same\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck if the argument is possible to solve by the array length. \\nSort array with bigger sum (desc)\\nSort array with smaller sum (asc)\\nTurn element in array with the bigger sum into 1\\nTurn element in array with the smaller sum into 6\\nRepeat until the difference is =< 0\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn = length nums1\\nm = length nums2\\n$$O(nlogn) + O(mlogm) + O(n+m)$$ = $$O((m+n)log (m+n))$$\\n\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n+m)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        high_sum = sum(nums1)\\n        low_sum = sum(nums2)\\n        if high_sum > low_sum:\\n            high_arr = nums1\\n            low_arr = nums2\\n        else:\\n            high_arr = nums2\\n            low_arr = nums1\\n            high_sum, low_sum = low_sum, high_sum\\n\\n        difference = high_sum - low_sum\\n\\n        # check if possible\\n        a = len(nums1)\\n        b = len(nums2)\\n\\n        min_length = min(a,b)\\n        max_length = max(a,b)\\n\\n        if min_length * 6 < max_length:\\n            return -1\\n\\n        # start the process\\n        high_arr.sort(reverse=True)\\n        low_arr.sort()\\n\\n        count = 0\\n        i = 0\\n        j = 0 \\n        while difference > 0 and i < len(high_arr) and j < len(low_arr):\\n            high_potential = high_arr[i] - 1\\n            low_potential = 6 - low_arr[j]\\n\\n\\n            if high_potential > low_potential:\\n                difference -= high_potential\\n                i += 1\\n            else:\\n                difference -= low_potential\\n                j += 1\\n            count += 1\\n\\n        while difference > 0 and i < len(high_arr):\\n            difference -= (high_arr[i] - 1)\\n            i += 1\\n            count += 1\\n\\n        while difference > 0 and j < len(low_arr):\\n            difference -= (6 - low_arr[j])\\n            j += 1\\n            count += 1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        high_sum = sum(nums1)\\n        low_sum = sum(nums2)\\n        if high_sum > low_sum:\\n            high_arr = nums1\\n            low_arr = nums2\\n        else:\\n            high_arr = nums2\\n            low_arr = nums1\\n            high_sum, low_sum = low_sum, high_sum\\n\\n        difference = high_sum - low_sum\\n\\n        # check if possible\\n        a = len(nums1)\\n        b = len(nums2)\\n\\n        min_length = min(a,b)\\n        max_length = max(a,b)\\n\\n        if min_length * 6 < max_length:\\n            return -1\\n\\n        # start the process\\n        high_arr.sort(reverse=True)\\n        low_arr.sort()\\n\\n        count = 0\\n        i = 0\\n        j = 0 \\n        while difference > 0 and i < len(high_arr) and j < len(low_arr):\\n            high_potential = high_arr[i] - 1\\n            low_potential = 6 - low_arr[j]\\n\\n\\n            if high_potential > low_potential:\\n                difference -= high_potential\\n                i += 1\\n            else:\\n                difference -= low_potential\\n                j += 1\\n            count += 1\\n\\n        while difference > 0 and i < len(high_arr):\\n            difference -= (high_arr[i] - 1)\\n            i += 1\\n            count += 1\\n\\n        while difference > 0 and j < len(low_arr):\\n            difference -= (6 - low_arr[j])\\n            j += 1\\n            count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829599,
                "title": "best-solution-beats-100-space-and-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n=nums1.size();\\n        int m=nums2.size();\\n\\n        if(m*6<n || n*6<m)\\n        {\\n            return -1;\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        int sum=accumulate(nums1.begin(),nums1.end(),0);\\n        int sum1=accumulate(nums2.begin(),nums2.end(),0);\\n        \\n        int count=0;\\n     \\n        if(sum>sum1)\\n        {\\n            int i=n-1;\\n            int j=0;\\n            int dif=sum-sum1;\\n            cout<<dif<<endl;\\n            while(dif>0)\\n            {\\n                \\n                if(i<0 || ((6-nums2[j])>(nums1[i]-1) && j<m))\\n                {\\n                    dif-=6-nums2[j++];\\n                }\\n                else\\n                {\\n                    dif-=(nums1[i--]-1);\\n                }\\n                count++;\\n            }\\n        }\\n        else\\n        {\\n            int i=0;\\n            int j=m-1;\\n            int dif=sum1-sum;\\n            while(dif>0)\\n            {\\n                \\n                if(i>=n || ((nums2[j]-1)>(6-nums1[i]) && j>=0))\\n                {\\n                    dif-=nums2[j--]-1;\\n                }\\n                else\\n                {\\n                    dif-=(6-nums1[i++]);\\n                }\\n                count++;\\n\\n            }\\n            \\n        }\\n        return count;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n=nums1.size();\\n        int m=nums2.size();\\n\\n        if(m*6<n || n*6<m)\\n        {\\n            return -1;\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        int sum=accumulate(nums1.begin(),nums1.end(),0);\\n        int sum1=accumulate(nums2.begin(),nums2.end(),0);\\n        \\n        int count=0;\\n     \\n        if(sum>sum1)\\n        {\\n            int i=n-1;\\n            int j=0;\\n            int dif=sum-sum1;\\n            cout<<dif<<endl;\\n            while(dif>0)\\n            {\\n                \\n                if(i<0 || ((6-nums2[j])>(nums1[i]-1) && j<m))\\n                {\\n                    dif-=6-nums2[j++];\\n                }\\n                else\\n                {\\n                    dif-=(nums1[i--]-1);\\n                }\\n                count++;\\n            }\\n        }\\n        else\\n        {\\n            int i=0;\\n            int j=m-1;\\n            int dif=sum1-sum;\\n            while(dif>0)\\n            {\\n                \\n                if(i>=n || ((nums2[j]-1)>(6-nums1[i]) && j>=0))\\n                {\\n                    dif-=nums2[j--]-1;\\n                }\\n                else\\n                {\\n                    dif-=(6-nums1[i++]);\\n                }\\n                count++;\\n\\n            }\\n            \\n        }\\n        return count;\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3799462,
                "title": "python-runtime-o-n-m-98-96-memory-o-1",
                "content": "`p` is the maximum difference it could make, for the smaller array it is adding `p`, for the larger array it is subtracting `p`. \\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        M = len(nums2)\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if N*6 < M or M*6 < N:\\n            return -1\\n        elif s1 == s2:\\n            return 0\\n        cnt1 = [0]*7\\n        cnt2 = [0]*7\\n        for e in nums1:\\n            cnt1[e] += 1\\n        for e in nums2:\\n            cnt2[e] += 1\\n        ans = 0\\n        for p in range(5, 0, -1):\\n            if s1 <= s2:\\n                if (cnt1[6-p]+cnt2[p+1])*p >= s2-s1:\\n                    return ans + math.ceil((s2-s1)/p)\\n                ans += cnt1[6-p]+cnt2[p+1]\\n                s2 -= (cnt1[6-p]+cnt2[p+1])*p\\n            else:\\n                if (cnt1[p+1]+cnt2[6-p])*p >= s1-s2:\\n                    return ans + math.ceil((s1-s2)/p)\\n                ans += cnt1[p+1]+cnt2[6-p]\\n                s1 -= (cnt1[p+1]+cnt2[6-p])*p\\n\\n                  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        M = len(nums2)\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if N*6 < M or M*6 < N:\\n            return -1\\n        elif s1 == s2:\\n            return 0\\n        cnt1 = [0]*7\\n        cnt2 = [0]*7\\n        for e in nums1:\\n            cnt1[e] += 1\\n        for e in nums2:\\n            cnt2[e] += 1\\n        ans = 0\\n        for p in range(5, 0, -1):\\n            if s1 <= s2:\\n                if (cnt1[6-p]+cnt2[p+1])*p >= s2-s1:\\n                    return ans + math.ceil((s2-s1)/p)\\n                ans += cnt1[6-p]+cnt2[p+1]\\n                s2 -= (cnt1[6-p]+cnt2[p+1])*p\\n            else:\\n                if (cnt1[p+1]+cnt2[6-p])*p >= s1-s2:\\n                    return ans + math.ceil((s1-s2)/p)\\n                ans += cnt1[p+1]+cnt2[6-p]\\n                s1 -= (cnt1[p+1]+cnt2[6-p])*p\\n\\n                  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751996,
                "title": "simple-java-method",
                "content": "# Intuition\\nJust find the situation of -1. then how to narrow down the difference between there sum.\\n\\n# Approach\\nif length of more size array >6*length of less size then not possible\\nthen just find the difference between there sum\\nand sort them\\nthe array with less sum of lesser digit will have higher priority then array with more sum of higher digit will have higher priority accordingly change the postions of indexes throughout the 2 arrays.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] num1, int[] num2) {\\n       int x=0,y=0;\\n       for(int i=0;i<num1.length;i++){x+=num1[i];}\\n       for(int i=0;i<num2.length;i++){y+=num2[i];}\\n    int n1=num1.length,n2=num2.length;\\n    if(n1>n2){if(n1>(6*n2))return -1;}\\n    else if(n1<n2){if(n2>(6*n1))return -1;}\\n      int u=0;\\n      if(x>y){u=1;}\\n       if(x==y)return 0;\\n       int t=Math.max(x,y)-Math.min(x,y);\\nArrays.sort(num1);\\nArrays.sort(num2);\\nreturn u==0?find(num1,num2,t):find(num2,num1,t);\\n\\n\\n\\n    }\\npublic int find(int num1[],int num2[],int t)\\n{\\nint i=0,j=num2.length-1,c=0;\\nint n1=num1.length,n2=num2.length;\\nwhile(t>0)\\n{\\n    if(i<n1&&j>=0){\\n    if(6-num1[i]>=num2[j]-1){t-=6-num1[i];i++;c++;}\\n    else{t-=num2[j]-1;j--;c++;}\\n    }\\n    else{\\n    if(i>=n1){t-=num2[j]-1;j--;c++;}\\n    else {t-=6-num1[i];i++;c++;}\\n    }\\n}\\nreturn c;\\n}\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] num1, int[] num2) {\\n       int x=0,y=0;\\n       for(int i=0;i<num1.length;i++){x+=num1[i];}\\n       for(int i=0;i<num2.length;i++){y+=num2[i];}\\n    int n1=num1.length,n2=num2.length;\\n    if(n1>n2){if(n1>(6*n2))return -1;}\\n    else if(n1<n2){if(n2>(6*n1))return -1;}\\n      int u=0;\\n      if(x>y){u=1;}\\n       if(x==y)return 0;\\n       int t=Math.max(x,y)-Math.min(x,y);\\nArrays.sort(num1);\\nArrays.sort(num2);\\nreturn u==0?find(num1,num2,t):find(num2,num1,t);\\n\\n\\n\\n    }\\npublic int find(int num1[],int num2[],int t)\\n{\\nint i=0,j=num2.length-1,c=0;\\nint n1=num1.length,n2=num2.length;\\nwhile(t>0)\\n{\\n    if(i<n1&&j>=0){\\n    if(6-num1[i]>=num2[j]-1){t-=6-num1[i];i++;c++;}\\n    else{t-=num2[j]-1;j--;c++;}\\n    }\\n    else{\\n    if(i>=n1){t-=num2[j]-1;j--;c++;}\\n    else {t-=6-num1[i];i++;c++;}\\n    }\\n}\\nreturn c;\\n}\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672164,
                "title": "c-3-passes-beats-99",
                "content": "# Intuition\\nStart with the assumption that `Sum(A) > Sum(B)`\\n\\nWhere `A` and `B` are both arrays.\\n\\nThen `Target=Sum(A)-Sum(B)` must be positive.\\n\\nThe core idea, is to minimze this sum somehow.\\n\\n# Approach\\n\\nUse a frequency array, to store the counts of integers `1-6`\\nfor `A` and `B` separately. \\n\\nIn one pass, we start with the values that will have the most impact. For `A` because the Sum of `A\\'s`values are larger, we want to attempt to bring higher values down to lower values in `A`, so if we encounter a `6` for example, we can bring it to `1` potentially yielding us a delta of `5` that we could detract from `Target`\\n\\nUnderstand this, the rest is details.\\n\\nP.S\\nTook me several hours to figure out on my own, I think this is a hard question. Also the code can be made more reusable, I just wanted to get over this problem and move on :)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        // Build 2 freq maps\\n        // Let the larger  of nums1, nums2 be  A\\n        // Let the smaller of nums1, nums2 be B\\n        // Let the target sum be A-B  which is always positive by definition\\n        // The idea is to detract as much as possible which would require using the highest numbers in A and the lowest numbers in B\\n        // For A we want to choose the highest i.e 6, because A > B and 6 has the potential to go down by 5 points and become 1\\n        // For B we want to choose the lowest i.e 1 because   B < A and 1 has the potenital to go up by 5 points and become 6\\n        // Either way we detract from the target sum until we hit 0 \\n\\n        vector<int>& a = nums1;\\n        vector<int>& b = nums2;\\n\\n        int freq[2][6] = {{0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}};\\n\\n        int sum_a = 0;\\n        for(int i = 0; i < a.size(); ++i) {\\n            int val = a[i];\\n            ++freq[0][val-1];            \\n            sum_a+=val;\\n        }\\n\\n        int sum_b = 0;\\n        for(int i = 0; i < b.size(); ++i) {\\n            int val = b[i];\\n            ++freq[1][val-1];\\n            sum_b+=val;\\n        }\\n\\n\\n        int* freq_a = freq[0];\\n        int* freq_b = freq[1];\\n\\n        // This must be a positive number!\\n        int target = abs(sum_a - sum_b);\\n        if(sum_a <= sum_b) {\\n            freq_a = freq[1]; \\n            freq_b = freq[0];\\n        }\\n\\n        int total_ops = 0;\\n        for(int i = 1; i <= 6; ++i) {\\n            int val_a = 6-i;\\n            int val_b = i;\\n            \\n            if(val_a > 0) {\\n                int needed = target / val_a;\\n                int avail = freq_a[val_a]; \\n                int amount = min(needed, avail);\\n\\n                if(avail > needed ) {\\n                    int mod = target % val_a;\\n                    if(mod > 0) ++total_ops;\\n                    target -= mod;\\n                    if(target <= 0) break;\\n                }\\n\\n                if(amount) {\\n                    target -= (amount*val_a);\\n                    total_ops += amount;\\n                }\\n            }\\n\\n            if(target <= 0) break;\\n\\n            if(val_b < 6) {\\n                int needed = target / (6-val_b); \\n                int avail = freq_b[i-1];\\n                int amount = min(needed, avail);\\n\\n                if(avail > needed) {\\n                    int mod = target % (6-val_b);\\n                    if(mod > 0) ++total_ops;\\n                    target -= mod;\\n                    if(target <= 0) break;\\n                }\\n\\n                if(amount) {\\n                    target -= (amount*(6-val_b));\\n                    total_ops += amount;\\n                }\\n            }\\n\\n            if(target <= 0) break;\\n        }\\n\\n        if(target <= 0) return total_ops;\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        // Build 2 freq maps\\n        // Let the larger  of nums1, nums2 be  A\\n        // Let the smaller of nums1, nums2 be B\\n        // Let the target sum be A-B  which is always positive by definition\\n        // The idea is to detract as much as possible which would require using the highest numbers in A and the lowest numbers in B\\n        // For A we want to choose the highest i.e 6, because A > B and 6 has the potential to go down by 5 points and become 1\\n        // For B we want to choose the lowest i.e 1 because   B < A and 1 has the potenital to go up by 5 points and become 6\\n        // Either way we detract from the target sum until we hit 0 \\n\\n        vector<int>& a = nums1;\\n        vector<int>& b = nums2;\\n\\n        int freq[2][6] = {{0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}};\\n\\n        int sum_a = 0;\\n        for(int i = 0; i < a.size(); ++i) {\\n            int val = a[i];\\n            ++freq[0][val-1];            \\n            sum_a+=val;\\n        }\\n\\n        int sum_b = 0;\\n        for(int i = 0; i < b.size(); ++i) {\\n            int val = b[i];\\n            ++freq[1][val-1];\\n            sum_b+=val;\\n        }\\n\\n\\n        int* freq_a = freq[0];\\n        int* freq_b = freq[1];\\n\\n        // This must be a positive number!\\n        int target = abs(sum_a - sum_b);\\n        if(sum_a <= sum_b) {\\n            freq_a = freq[1]; \\n            freq_b = freq[0];\\n        }\\n\\n        int total_ops = 0;\\n        for(int i = 1; i <= 6; ++i) {\\n            int val_a = 6-i;\\n            int val_b = i;\\n            \\n            if(val_a > 0) {\\n                int needed = target / val_a;\\n                int avail = freq_a[val_a]; \\n                int amount = min(needed, avail);\\n\\n                if(avail > needed ) {\\n                    int mod = target % val_a;\\n                    if(mod > 0) ++total_ops;\\n                    target -= mod;\\n                    if(target <= 0) break;\\n                }\\n\\n                if(amount) {\\n                    target -= (amount*val_a);\\n                    total_ops += amount;\\n                }\\n            }\\n\\n            if(target <= 0) break;\\n\\n            if(val_b < 6) {\\n                int needed = target / (6-val_b); \\n                int avail = freq_b[i-1];\\n                int amount = min(needed, avail);\\n\\n                if(avail > needed) {\\n                    int mod = target % (6-val_b);\\n                    if(mod > 0) ++total_ops;\\n                    target -= mod;\\n                    if(target <= 0) break;\\n                }\\n\\n                if(amount) {\\n                    target -= (amount*(6-val_b));\\n                    total_ops += amount;\\n                }\\n            }\\n\\n            if(target <= 0) break;\\n        }\\n\\n        if(target <= 0) return total_ops;\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629128,
                "title": "python3-greedy-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        if sum(nums1)<sum(nums2):\\n            nums1,nums2 = nums2,nums1\\n\\n        if len(nums1)>len(nums2)*6 or len(nums1)*6<len(nums2):\\n            return -1\\n\\n        freqDict1 = defaultdict(int)\\n        freqDict2 = defaultdict(int)\\n        for number in nums1:\\n            freqDict1[number]+=1\\n        for number in nums2:\\n            freqDict2[number]+=1\\n        diff = sum(nums1)-sum(nums2)\\n        ans = 0\\n        index = 1\\n        while diff>0:\\n            if diff>(6-index)*freqDict1[6-index+1]:\\n                diff-=(6-index)*freqDict1[6-index+1]\\n                ans+=freqDict1[6-index+1]\\n            else:\\n                ans+=math.ceil(diff/(6-index))\\n                break\\n\\n            if diff>(6-index)*freqDict2[index]:\\n                diff-=(6-index)*freqDict2[index]\\n                ans+=freqDict2[index]\\n            else:\\n                ans+=math.ceil(diff/(6-index))\\n                break\\n            index+=1\\n            if index>6:\\n                break\\n\\n\\n        return ans\\n\\n            \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        if sum(nums1)<sum(nums2):\\n            nums1,nums2 = nums2,nums1\\n\\n        if len(nums1)>len(nums2)*6 or len(nums1)*6<len(nums2):\\n            return -1\\n\\n        freqDict1 = defaultdict(int)\\n        freqDict2 = defaultdict(int)\\n        for number in nums1:\\n            freqDict1[number]+=1\\n        for number in nums2:\\n            freqDict2[number]+=1\\n        diff = sum(nums1)-sum(nums2)\\n        ans = 0\\n        index = 1\\n        while diff>0:\\n            if diff>(6-index)*freqDict1[6-index+1]:\\n                diff-=(6-index)*freqDict1[6-index+1]\\n                ans+=freqDict1[6-index+1]\\n            else:\\n                ans+=math.ceil(diff/(6-index))\\n                break\\n\\n            if diff>(6-index)*freqDict2[index]:\\n                diff-=(6-index)*freqDict2[index]\\n                ans+=freqDict2[index]\\n            else:\\n                ans+=math.ceil(diff/(6-index))\\n                break\\n            index+=1\\n            if index>6:\\n                break\\n\\n\\n        return ans\\n\\n            \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551846,
                "title": "c-python-count-greedy-solution-with-explanation",
                "content": "We can make the greater sum of array smaller or the smaller sum of array greater.\\n\\nTo find minimun number of operation, we should make the sum difference smaller as quick as possible, so we can select a greatest number comes from greater sum array to be smaller or select a smallest number comes from smaller sum array to be greater.\\n\\nTherefore, use a hash map or array to record the maximum change ```1~5``` that can be made by each operation of all numbers in the two arrays,\\nand walking through the maximun change```5,4,3,2,1``` in hash map, make the sum difference smaller as quick as possible.\\n```change * cnt[change] >= diff``` means we can make diff to ```0``` just use ```ceil(diff / change)``` steps.\\nif we make smaller sum array to all 6, and greater sum array to all 1, then smaller sum array still is smaller than greater sum array, it is no possible to make two array sum are equal.\\n\\ntc is O(n), sc is O(1).\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int s1 = 0, s2 = 0;\\n        for (int& n: nums1) s1 += n;\\n        for (int& n: nums2) s2 += n;\\n        if (s1 < s2) return this -> func(nums2, nums1, s2 - s1);\\n        else if (s1 > s2) return this -> func(nums1, nums2, s1 - s2);\\n        else return 0;\\n    }\\n    \\n    int func(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        if (nums1.size() > 6 * nums2.size()) return -1;\\n        int cnt[6] {0};\\n        int step = 0;\\n        for (int& n: nums1) cnt[n-1] += 1;\\n        for (int& n: nums2) cnt[6-n] += 1;\\n        for (int change = 5; change >= 1; change-=1) {\\n            if (change * cnt[change] >= diff) return step + (diff + change - 1) / change;\\n            diff -= change * cnt[change];\\n            step += cnt[change];\\n        }\\n        return -1;\\n    }\\n};\\n```\\n### python\\n```python\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        def func(nums1, nums2, diff):\\n\\t\\t\\t# sum(nums1) > sum(nums2)\\n            if len(nums1) > 6 * len(nums2): return -1\\n            cnt = [0] * 6\\n            step = 0\\n            for n in nums1: cnt[n-1] += 1\\n            for n in nums2: cnt[6-n] += 1\\n            for change in range(5, 0, -1):\\n                if change * cnt[change] >= diff: return step + (diff + change - 1) // change\\n                step += cnt[change]\\n                diff -= change * cnt[change]\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if s1 < s2:\\n            return func(nums2, nums1, s2-s1)\\n        elif s1 > s2:\\n            return func(nums1, nums2, s1-s2)\\n        else: return 0\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Greedy",
                    "Counting"
                ],
                "code": "```1~5```\n```5,4,3,2,1```\n```change * cnt[change] >= diff```\n```0```\n```ceil(diff / change)```\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int s1 = 0, s2 = 0;\\n        for (int& n: nums1) s1 += n;\\n        for (int& n: nums2) s2 += n;\\n        if (s1 < s2) return this -> func(nums2, nums1, s2 - s1);\\n        else if (s1 > s2) return this -> func(nums1, nums2, s1 - s2);\\n        else return 0;\\n    }\\n    \\n    int func(vector<int>& nums1, vector<int>& nums2, int diff) {\\n        if (nums1.size() > 6 * nums2.size()) return -1;\\n        int cnt[6] {0};\\n        int step = 0;\\n        for (int& n: nums1) cnt[n-1] += 1;\\n        for (int& n: nums2) cnt[6-n] += 1;\\n        for (int change = 5; change >= 1; change-=1) {\\n            if (change * cnt[change] >= diff) return step + (diff + change - 1) / change;\\n            diff -= change * cnt[change];\\n            step += cnt[change];\\n        }\\n        return -1;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        def func(nums1, nums2, diff):\\n\\t\\t\\t# sum(nums1) > sum(nums2)\\n            if len(nums1) > 6 * len(nums2): return -1\\n            cnt = [0] * 6\\n            step = 0\\n            for n in nums1: cnt[n-1] += 1\\n            for n in nums2: cnt[6-n] += 1\\n            for change in range(5, 0, -1):\\n                if change * cnt[change] >= diff: return step + (diff + change - 1) // change\\n                step += cnt[change]\\n                diff -= change * cnt[change]\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if s1 < s2:\\n            return func(nums2, nums1, s2-s1)\\n        elif s1 > s2:\\n            return func(nums1, nums2, s1-s2)\\n        else: return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540205,
                "title": "python-o-n-count-greedy",
                "content": "Get the sums of both arrays and count the occurances of each number in the arrays. \\n\\nWe can than just greedily update 1 -> 6 in the smallest array and 6 -> 1 in the largest array for best value through 1->5\\n\\n```py\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        res = 0\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if s1 == s2:\\n            return 0\\n        if s1 > s2:\\n            nums1,nums2 = nums2,nums1\\n            s1,s2 = s2,s1\\n        \\n        if len(nums1) * 6 < len(nums2):\\n            return -1\\n        \\n        gap = s2 - s1\\n        c1 = Counter(nums1)\\n        c2 = Counter(nums2)\\n        \\n        for i in range(1,6):\\n            take = math.ceil(gap / (6 - i))\\n            mx = (c1[i] * (6 - i)) + (c2[7-i] * (6 - i))\\n                \\n            if mx < take * (6-i):\\n                res += c1[i] + c2[7-i]\\n                gap -= mx\\n            else:\\n                res += take\\n                gap = 0\\n            if gap <= 0:\\n                break\\n    \\n        return res",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "Get the sums of both arrays and count the occurances of each number in the arrays. \\n\\nWe can than just greedily update 1 -> 6 in the smallest array and 6 -> 1 in the largest array for best value through 1->5\\n\\n```py\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        res = 0\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n        if s1 == s2:\\n            return 0\\n        if s1 > s2:\\n            nums1,nums2 = nums2,nums1\\n            s1,s2 = s2,s1\\n        \\n        if len(nums1) * 6 < len(nums2):\\n            return -1\\n        \\n        gap = s2 - s1\\n        c1 = Counter(nums1)\\n        c2 = Counter(nums2)\\n        \\n        for i in range(1,6):\\n            take = math.ceil(gap / (6 - i))\\n            mx = (c1[i] * (6 - i)) + (c2[7-i] * (6 - i))\\n                \\n            if mx < take * (6-i):\\n                res += c1[i] + c2[7-i]\\n                gap -= mx\\n            else:\\n                res += take\\n                gap = 0\\n            if gap <= 0:\\n                break\\n    \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3529493,
                "title": "priorityqueue-java-streams-and-lambdas",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        if (nums1.length > 6 * nums2.length || nums2.length > 6 * nums1.length) {\\n            return -1;\\n        }\\n        var total1 = Arrays.stream(nums1).sum();\\n        var total2 = Arrays.stream(nums2).sum();\\n\\n        if (total1 == total2) {\\n            return 0;\\n        }\\n\\n        var queue = new PriorityQueue<Integer>(Comparator.reverseOrder());\\n\\n        if (total1 > total2) {\\n            addComplimentToQueue(nums1, nums2, queue);\\n        } else {\\n            addComplimentToQueue(nums2, nums1, queue);\\n        }\\n\\n        var minops = 0;\\n        var diff = Math.abs(total1 - total2);\\n        while (!queue.isEmpty() && diff > 0) {\\n            diff -= queue.poll();\\n            minops++;\\n        }\\n        return minops;\\n    }\\n\\n    public void addComplimentToQueue(int[] v1, int[] v2, PriorityQueue<Integer> queue) {\\n        Arrays.stream(v1).forEach(n -> queue.add(n - 1));\\n        Arrays.stream(v2).forEach(n -> queue.add(6 - n));\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        if (nums1.length > 6 * nums2.length || nums2.length > 6 * nums1.length) {\\n            return -1;\\n        }\\n        var total1 = Arrays.stream(nums1).sum();\\n        var total2 = Arrays.stream(nums2).sum();\\n\\n        if (total1 == total2) {\\n            return 0;\\n        }\\n\\n        var queue = new PriorityQueue<Integer>(Comparator.reverseOrder());\\n\\n        if (total1 > total2) {\\n            addComplimentToQueue(nums1, nums2, queue);\\n        } else {\\n            addComplimentToQueue(nums2, nums1, queue);\\n        }\\n\\n        var minops = 0;\\n        var diff = Math.abs(total1 - total2);\\n        while (!queue.isEmpty() && diff > 0) {\\n            diff -= queue.poll();\\n            minops++;\\n        }\\n        return minops;\\n    }\\n\\n    public void addComplimentToQueue(int[] v1, int[] v2, PriorityQueue<Integer> queue) {\\n        Arrays.stream(v1).forEach(n -> queue.add(n - 1));\\n        Arrays.stream(v2).forEach(n -> queue.add(6 - n));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508975,
                "title": "c-solution-greedy-using-heap",
                "content": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums1, int[] nums2) {\\n        int sum1 = 0,sum2 = 0;\\n        for(int i = 0; i < nums1.Length;i++) sum1+= nums1[i];\\n        for(int i = 0; i < nums2.Length;i++) sum2+= nums2[i];\\n        if(sum1 == sum2) return 0;\\n        // PriorityQueue for sorting\\n        PriorityQueue<int,int> pq = new(Comparer<int>.Create((a, b) => b - a));\\n        if(sum1 > sum2){ // decrease nums1 or increase nums2\\n            for(int i = 0; i < nums1.Length;i++) pq.Enqueue(nums1[i] - 1, nums1[i] - 1);\\n            for(int i = 0; i < nums2.Length;i++) pq.Enqueue(6 - nums2[i], 6 - nums2[i]);\\n        }else{\\n            for(int i = 0; i < nums1.Length;i++) pq.Enqueue(6 - nums1[i], 6 - nums1[i]);\\n            for(int i = 0; i < nums2.Length;i++) pq.Enqueue(nums2[i] - 1,nums2[i] - 1);\\n        }\\n        int diff = Math.Abs(sum1 - sum2);\\n        int res = 0;\\n        while(pq.Count > 0 && pq.Peek() > 0 && diff > 0){\\n            diff-= pq.Dequeue();\\n            res++;\\n        }\\n        return (diff <= 0) ? res : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums1, int[] nums2) {\\n        int sum1 = 0,sum2 = 0;\\n        for(int i = 0; i < nums1.Length;i++) sum1+= nums1[i];\\n        for(int i = 0; i < nums2.Length;i++) sum2+= nums2[i];\\n        if(sum1 == sum2) return 0;\\n        // PriorityQueue for sorting\\n        PriorityQueue<int,int> pq = new(Comparer<int>.Create((a, b) => b - a));\\n        if(sum1 > sum2){ // decrease nums1 or increase nums2\\n            for(int i = 0; i < nums1.Length;i++) pq.Enqueue(nums1[i] - 1, nums1[i] - 1);\\n            for(int i = 0; i < nums2.Length;i++) pq.Enqueue(6 - nums2[i], 6 - nums2[i]);\\n        }else{\\n            for(int i = 0; i < nums1.Length;i++) pq.Enqueue(6 - nums1[i], 6 - nums1[i]);\\n            for(int i = 0; i < nums2.Length;i++) pq.Enqueue(nums2[i] - 1,nums2[i] - 1);\\n        }\\n        int diff = Math.Abs(sum1 - sum2);\\n        int res = 0;\\n        while(pq.Count > 0 && pq.Peek() > 0 && diff > 0){\\n            diff-= pq.Dequeue();\\n            res++;\\n        }\\n        return (diff <= 0) ? res : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393723,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn min_operations(mut nums1: Vec<i32>, mut nums2: Vec<i32>) -> i32 {\\n    if nums1.len() < nums2.len() {\\n      std::mem::swap(&mut nums1, &mut nums2);\\n    }\\n\\n    if nums1.len() > nums2.len() * 6 {\\n      return -1\\n    }\\n    nums1.sort();\\n    nums2.sort();\\n\\n    let sum1 = nums1.iter().sum::<i32>();\\n    let sum2 = nums2.iter().sum::<i32>();\\n    if sum1 < sum2 {\\n      std::mem::swap(&mut nums1, &mut nums2);\\n    }\\n\\n    let mut que1 = nums1.into_iter().collect::<VecDeque<i32>>();\\n    let mut que2 = nums2.into_iter().collect::<VecDeque<i32>>();\\n    let mut diff = (sum1 - sum2).abs();\\n\\n    let mut result = 0;\\n    while 0 < diff && (!que1.is_empty() || !que2.is_empty()) {\\n      if que1.is_empty() {\\n        let v2 =  6 - que2.pop_front().unwrap();\\n        diff -= v2;\\n      } else if que2.is_empty() {\\n        let v1 = que1.pop_back().unwrap() - 1;\\n        diff -= v1;\\n      } else {\\n        let v1 = que1[que1.len()-1] - 1;\\n        let v2 = 6 - que2[0];\\n\\n        if v1 < v2 {\\n          diff -= v2;\\n          que2.pop_front();\\n        } else {\\n          diff -= v1;\\n          que1.pop_back();\\n        }\\n      }\\n      result += 1;\\n    }\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn min_operations(mut nums1: Vec<i32>, mut nums2: Vec<i32>) -> i32 {\\n    if nums1.len() < nums2.len() {\\n      std::mem::swap(&mut nums1, &mut nums2);\\n    }\\n\\n    if nums1.len() > nums2.len() * 6 {\\n      return -1\\n    }\\n    nums1.sort();\\n    nums2.sort();\\n\\n    let sum1 = nums1.iter().sum::<i32>();\\n    let sum2 = nums2.iter().sum::<i32>();\\n    if sum1 < sum2 {\\n      std::mem::swap(&mut nums1, &mut nums2);\\n    }\\n\\n    let mut que1 = nums1.into_iter().collect::<VecDeque<i32>>();\\n    let mut que2 = nums2.into_iter().collect::<VecDeque<i32>>();\\n    let mut diff = (sum1 - sum2).abs();\\n\\n    let mut result = 0;\\n    while 0 < diff && (!que1.is_empty() || !que2.is_empty()) {\\n      if que1.is_empty() {\\n        let v2 =  6 - que2.pop_front().unwrap();\\n        diff -= v2;\\n      } else if que2.is_empty() {\\n        let v1 = que1.pop_back().unwrap() - 1;\\n        diff -= v1;\\n      } else {\\n        let v1 = que1[que1.len()-1] - 1;\\n        let v2 = 6 - que2[0];\\n\\n        if v1 < v2 {\\n          diff -= v2;\\n          que2.pop_front();\\n        } else {\\n          diff -= v1;\\n          que1.pop_back();\\n        }\\n      }\\n      result += 1;\\n    }\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3392332,
                "title": "c-greedy-sorting",
                "content": "# Intuition\\nWe can change the elements of either first or second array depending on our need i.e. the operation which gives us minimum answer at ith point, we move in that direction. Hence we take decisions greedily at each index. \\n# Approach\\nWe first calculate sum of elements of each array and check if **sum1>sum2** or **sum2>sum1**. If **sum1>sum2**, we sort first array in descending order and second array in ascending order and now we check which of the two operations will give us minimum answer. We change the element of the first array to be the smallest i.e. 1 and check the difference and then we change the second array\\'s first element to highest i.e. 6 and check the difference. Whichever is giving us minimum answer, we do that operation. The array whose sum is greater, we are changing it\\'s maximum element to min and the array which is smaller, we are changing it\\'s minimum element to max because if by doing this, sum1 becomes less than sum2 (initially sum1 was greater) then we can also make them equal in between because we are given the freedom to change any element by any value between 1 and 6. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        int sum1 = 0,sum2 = 0;\\n        for(auto &i:nums1)\\n        sum1+=i;\\n        for(auto &i:nums2)\\n        sum2+=i;\\n        if(sum1>sum2)\\n        {\\n            sort(nums1.rbegin(),nums1.rend());\\n            sort(nums2.begin(),nums2.end());\\n            int cnt=0;\\n            int p1 = 0,p2 = 0;\\n            while(p1<n1 && p2<n2 && sum1>sum2)\\n            {\\n                int tSum1 = sum1;\\n                int tSum2 = sum2;\\n                tSum1-=nums1[p1];\\n                tSum2+=1;\\n                int d1 = tSum1-sum2;\\n                tSum2-=nums2[p2];\\n                tSum2+=6;\\n                int d2 = sum1-tSum2;\\n                if(d1<d2)\\n                {\\n                    sum1-=nums1[p1++];\\n                    sum1+=1;\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    sum2-=nums2[p2++];\\n                    sum2+=6;\\n                    cnt++;\\n                }\\n            }\\n            while(sum1>sum2 && p1<n1)\\n            {\\n                sum1-=nums1[p1++];\\n                sum1+=1;\\n                cnt++;\\n            }\\n            while(sum1>sum2 && p2<n2)\\n            {\\n                sum2-=nums2[p2++];\\n                sum2+=6;\\n                cnt++;\\n            }\\n            if(sum1>sum2)\\n            return -1;\\n            return cnt;\\n        }   \\n        else if(sum2>sum1)\\n        {\\n            sort(nums2.rbegin(),nums2.rend());\\n            sort(nums1.begin(),nums1.end());\\n            int cnt=0;\\n            int p1 = 0,p2 = 0;\\n            while(p1<n1 && p2<n2 && sum2>sum1)\\n            {\\n                int tSum1 = sum1;\\n                int tSum2 = sum2;\\n                tSum1-=nums1[p1];\\n                tSum2+=6;\\n                int d1 = sum2-tSum1;\\n                tSum2-=nums2[p2];\\n                tSum2+=1;\\n                int d2 = tSum2-sum1;\\n                if(d1<d2)\\n                {\\n                    sum1-=nums1[p1++];\\n                    sum1+=6;\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    sum2-=nums2[p2++];\\n                    sum2+=1;\\n                    cnt++;\\n                }\\n            }\\n            while(sum2>sum1 && p1<n1)\\n            {\\n                sum1-=nums1[p1++];\\n                sum1+=6;\\n                cnt++;\\n            }\\n            while(sum2>sum1 && p2<n2)\\n            {\\n                sum2-=nums2[p2++];\\n                sum2+=1;\\n                cnt++;\\n            }\\n            if(sum2>sum1)\\n            return -1;\\n            return cnt;\\n        } \\n        else\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        int sum1 = 0,sum2 = 0;\\n        for(auto &i:nums1)\\n        sum1+=i;\\n        for(auto &i:nums2)\\n        sum2+=i;\\n        if(sum1>sum2)\\n        {\\n            sort(nums1.rbegin(),nums1.rend());\\n            sort(nums2.begin(),nums2.end());\\n            int cnt=0;\\n            int p1 = 0,p2 = 0;\\n            while(p1<n1 && p2<n2 && sum1>sum2)\\n            {\\n                int tSum1 = sum1;\\n                int tSum2 = sum2;\\n                tSum1-=nums1[p1];\\n                tSum2+=1;\\n                int d1 = tSum1-sum2;\\n                tSum2-=nums2[p2];\\n                tSum2+=6;\\n                int d2 = sum1-tSum2;\\n                if(d1<d2)\\n                {\\n                    sum1-=nums1[p1++];\\n                    sum1+=1;\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    sum2-=nums2[p2++];\\n                    sum2+=6;\\n                    cnt++;\\n                }\\n            }\\n            while(sum1>sum2 && p1<n1)\\n            {\\n                sum1-=nums1[p1++];\\n                sum1+=1;\\n                cnt++;\\n            }\\n            while(sum1>sum2 && p2<n2)\\n            {\\n                sum2-=nums2[p2++];\\n                sum2+=6;\\n                cnt++;\\n            }\\n            if(sum1>sum2)\\n            return -1;\\n            return cnt;\\n        }   \\n        else if(sum2>sum1)\\n        {\\n            sort(nums2.rbegin(),nums2.rend());\\n            sort(nums1.begin(),nums1.end());\\n            int cnt=0;\\n            int p1 = 0,p2 = 0;\\n            while(p1<n1 && p2<n2 && sum2>sum1)\\n            {\\n                int tSum1 = sum1;\\n                int tSum2 = sum2;\\n                tSum1-=nums1[p1];\\n                tSum2+=6;\\n                int d1 = sum2-tSum1;\\n                tSum2-=nums2[p2];\\n                tSum2+=1;\\n                int d2 = tSum2-sum1;\\n                if(d1<d2)\\n                {\\n                    sum1-=nums1[p1++];\\n                    sum1+=6;\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    sum2-=nums2[p2++];\\n                    sum2+=1;\\n                    cnt++;\\n                }\\n            }\\n            while(sum2>sum1 && p1<n1)\\n            {\\n                sum1-=nums1[p1++];\\n                sum1+=6;\\n                cnt++;\\n            }\\n            while(sum2>sum1 && p2<n2)\\n            {\\n                sum2-=nums2[p2++];\\n                sum2+=1;\\n                cnt++;\\n            }\\n            if(sum2>sum1)\\n            return -1;\\n            return cnt;\\n        } \\n        else\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361615,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int n1=nums1.size(),n2=nums2.size();\\n        if(n1>n2*6 || n2>n1*6)\\n            return -1;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        long long l1=0,l2=0;\\n        for(int i=0;i<n1;++i)\\n        {\\n            l1+=nums1[i];\\n        }\\n        for(int i=0;i<n2;++i)\\n            l2+=nums2[i];\\n        int i=n1-1;\\n        int j=n2-1;\\n        int c=0;\\n    if(l1>l2)\\n    {\\n        j=0;\\n        while(i>-1&&j<n2 && l1>l2)\\n        {\\n               if((nums1[i]-1)>=(6-nums2[j]))\\n               {\\n                   l1-=(nums1[i]-1);\\n                   --i;\\n               }\\n             else\\n              {\\n                 l2+=6-nums2[j];\\n                 ++j;\\n               }\\n               ++c;\\n        }\\n    \\n       if(l1>l2)\\n       {\\n           while(i>-1 && l1>l2)\\n           {\\n               l1-=(nums1[i]-1);\\n               --i;\\n               ++c;\\n           }\\n           while(j<n2 && l1>l2)\\n           {\\n               l2+=6-nums2[j];\\n                 ++j;\\n               ++c;\\n           }\\n       }\\n        return c;\\n    }\\n    else\\n    {\\n        i=0;\\n        while(j>-1 && i<n1 && l1<l2)\\n        {\\n            if((nums2[j]-1)>=(6-nums1[i]))\\n               {\\n                   l2-=(nums2[j]-1);\\n                   --j;\\n               }\\n            else\\n            {\\n                l1+=(6-nums1[i]);\\n                ++i;\\n            }\\n               ++c;\\n        }\\n        while(i<n1 && l1<l2)\\n        {\\n            l1+=(6-nums1[i]);\\n            ++i;\\n            ++c;\\n        }\\n        while(j>-1 && l1<l2)\\n        {\\n            l2-=(nums2[j]-1);\\n                   --j;\\n            ++c;\\n        }\\n        return c;\\n    }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int n1=nums1.size(),n2=nums2.size();\\n        if(n1>n2*6 || n2>n1*6)\\n            return -1;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        long long l1=0,l2=0;\\n        for(int i=0;i<n1;++i)\\n        {\\n            l1+=nums1[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3217853,
                "title": "c-solution-greedy-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        if (nums1.size() > nums2.size())\\n            nums1.swap(nums2);\\n        size_t buf[4] = { nums1.size(), nums1.size() * 6, nums2.size(), nums2.size() * 6 };\\n        if (buf[2] > buf[1])\\n            return -1;\\n\\n        int s1 = 0;\\n        int s2 = 0;\\n        for (int n : nums1)\\n            s1 += n;\\n        for (int n : nums2)\\n            s2 += n;\\n\\n        if (s1 < s2)\\n        {\\n            nums1.swap(nums2);\\n            std::swap(s1, s2);\\n        }\\n\\n        std::sort(nums1.begin(), nums1.end(), std::greater<int>());\\n        std::sort(nums2.begin(), nums2.end());\\n\\n        int count = 0;\\n        int diff = s1 - s2;\\n        int i1 = 0, i2 = 0;\\n        while (i1 < nums1.size() && i2 < nums2.size() && diff > 0)\\n        {\\n            int d1 = nums1[i1] - 1;\\n            int d2 = 6 - nums2[i2];\\n\\n            if (d1 >= d2)\\n            {\\n                diff -= d1;\\n                count++;\\n                i1++;\\n            }\\n            else\\n            {\\n                diff -= d2;\\n                count++;\\n                i2++;\\n            }\\n        }\\n\\n        while (i1 < nums1.size() && diff > 0)\\n        {\\n            int d1 = nums1[i1] - 1;\\n            diff -= d1;\\n            count++;\\n            i1++;\\n        }\\n\\n        while (i2 < nums2.size() && diff > 0)\\n        {\\n            int d2 = 6 - nums2[i2];\\n            diff -= d2;\\n            count++;\\n            i2++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        if (nums1.size() > nums2.size())\\n            nums1.swap(nums2);\\n        size_t buf[4] = { nums1.size(), nums1.size() * 6, nums2.size(), nums2.size() * 6 };\\n        if (buf[2] > buf[1])\\n            return -1;\\n\\n        int s1 = 0;\\n        int s2 = 0;\\n        for (int n : nums1)\\n            s1 += n;\\n        for (int n : nums2)\\n            s2 += n;\\n\\n        if (s1 < s2)\\n        {\\n            nums1.swap(nums2);\\n            std::swap(s1, s2);\\n        }\\n\\n        std::sort(nums1.begin(), nums1.end(), std::greater<int>());\\n        std::sort(nums2.begin(), nums2.end());\\n\\n        int count = 0;\\n        int diff = s1 - s2;\\n        int i1 = 0, i2 = 0;\\n        while (i1 < nums1.size() && i2 < nums2.size() && diff > 0)\\n        {\\n            int d1 = nums1[i1] - 1;\\n            int d2 = 6 - nums2[i2];\\n\\n            if (d1 >= d2)\\n            {\\n                diff -= d1;\\n                count++;\\n                i1++;\\n            }\\n            else\\n            {\\n                diff -= d2;\\n                count++;\\n                i2++;\\n            }\\n        }\\n\\n        while (i1 < nums1.size() && diff > 0)\\n        {\\n            int d1 = nums1[i1] - 1;\\n            diff -= d1;\\n            count++;\\n            i1++;\\n        }\\n\\n        while (i2 < nums2.size() && diff > 0)\\n        {\\n            int d2 = 6 - nums2[i2];\\n            diff -= d2;\\n            count++;\\n            i2++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179489,
                "title": "greedy-two-pointer-sort",
                "content": "APPROACH : \\nSorting both of vectors v1 and v2.Calculating sum of v1 and v2.If sum of v1 is greater than sum of v2 then swap v1 and v2 so that we can always ensure sum of v1 is always lesser than or equal to sum of v2.\\nTake two pointers i=0,j=v2.size()-1.The best optimal method is to make v1[i] to 6 or v2[j] to 1.\\nWe take the one which is giving more difference and proceed.\\n```\\nint minOperations(vector<int>& v1, vector<int>& v2) {\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        int s1=0,s2=0;\\n        for(auto it : v1)\\n            s1 += it;\\n        for(auto it : v2)\\n            s2 += it;\\n        if(s1 > s2)\\n        {\\n            swap(v1,v2);\\n            swap(s1,s2);\\n        }\\n        int diff = s2-s1;\\n        int cnt=0;\\n        if(diff == 0)\\n            return cnt;\\n        int i=0,j=v2.size()-1;\\n        while(diff > 0)\\n        {\\n            if(i == v1.size() && j < 0)\\n                break;\\n            int val1=INT_MIN,val2=INT_MIN;\\n            if(i<v1.size() && v1[i] == 6)\\n                i = v1.size();\\n            if(j>=0 && v2[j] == 1)\\n                j = -1;\\n            if(i < v1.size())\\n                val1 = 6 - v1[i];\\n            if(j >= 0)\\n                val2 = v2[j] - 1;\\n            if(val1 > val2)\\n            {\\n                diff -= val1;\\n                i++;\\n                cnt++;\\n            }\\n            else\\n            {\\n                if(val2 != INT_MIN)\\n                {\\n                diff -= val2;\\n                j--;\\n                cnt++;\\n                }\\n            }\\n        }\\n        if(diff > 0)\\n            return -1;\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "APPROACH : \\nSorting both of vectors v1 and v2.Calculating sum of v1 and v2.If sum of v1 is greater than sum of v2 then swap v1 and v2 so that we can always ensure sum of v1 is always lesser than or equal to sum of v2.\\nTake two pointers i=0,j=v2.size()-1.The best optimal method is to make v1[i] to 6 or v2[j] to 1.\\nWe take the one which is giving more difference and proceed.\\n```\\nint minOperations(vector<int>& v1, vector<int>& v2) {\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        int s1=0,s2=0;\\n        for(auto it : v1)\\n            s1 += it;\\n        for(auto it : v2)\\n            s2 += it;\\n        if(s1 > s2)\\n        {\\n            swap(v1,v2);\\n            swap(s1,s2);\\n        }\\n        int diff = s2-s1;\\n        int cnt=0;\\n        if(diff == 0)\\n            return cnt;\\n        int i=0,j=v2.size()-1;\\n        while(diff > 0)\\n        {\\n            if(i == v1.size() && j < 0)\\n                break;\\n            int val1=INT_MIN,val2=INT_MIN;\\n            if(i<v1.size() && v1[i] == 6)\\n                i = v1.size();\\n            if(j>=0 && v2[j] == 1)\\n                j = -1;\\n            if(i < v1.size())\\n                val1 = 6 - v1[i];\\n            if(j >= 0)\\n                val2 = v2[j] - 1;\\n            if(val1 > val2)\\n            {\\n                diff -= val1;\\n                i++;\\n                cnt++;\\n            }\\n            else\\n            {\\n                if(val2 != INT_MIN)\\n                {\\n                diff -= val2;\\n                j--;\\n                cnt++;\\n                }\\n            }\\n        }\\n        if(diff > 0)\\n            return -1;\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3159001,
                "title": "calculation-by-sorting",
                "content": "# Approach\\n- Convert each integer in the arrays to the maximum difference each integer can make\\n- Ensure the arrays are sorted\\n- Pop maximum differences until difference between the sums is less than or equal to 0\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$?\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        # Ensure that nums2 will be larger than nums1\\n        if sum(nums1) > sum(nums2):\\n            nums1, nums2 = nums2, nums1\\n        diff = sum(nums2) - sum(nums1)\\n\\n        nums1 = sorted([6 - i for i in nums1])\\n        nums2 = sorted([i - 1 for i in nums2])\\n\\n        counter = 0\\n        while diff > 0:\\n            if (len(nums1) > 0 and len(nums2) > 0):\\n                if nums1[-1] > nums2[-1]:\\n                    diff -= nums1.pop()\\n                else:\\n                    diff -= nums2.pop()\\n            elif (len(nums1) > 0):\\n                diff -= nums1.pop()\\n            elif (len(nums2) > 0):\\n                diff -= nums2.pop()\\n            else:\\n                return -1\\n            counter += 1\\n        return counter\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        # Ensure that nums2 will be larger than nums1\\n        if sum(nums1) > sum(nums2):\\n            nums1, nums2 = nums2, nums1\\n        diff = sum(nums2) - sum(nums1)\\n\\n        nums1 = sorted([6 - i for i in nums1])\\n        nums2 = sorted([i - 1 for i in nums2])\\n\\n        counter = 0\\n        while diff > 0:\\n            if (len(nums1) > 0 and len(nums2) > 0):\\n                if nums1[-1] > nums2[-1]:\\n                    diff -= nums1.pop()\\n                else:\\n                    diff -= nums2.pop()\\n            elif (len(nums1) > 0):\\n                diff -= nums1.pop()\\n            elif (len(nums2) > 0):\\n                diff -= nums2.pop()\\n            else:\\n                return -1\\n            counter += 1\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137356,
                "title": "python-short-solution-counter",
                "content": "```\\ndef minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n\\td = sum(nums2)-sum(nums1)  # sum(nums2)>sum(nums1)\\n\\tif d<=0:\\n\\t\\treturn 0 if d==0 else self.minOperations(nums2, nums1)\\n\\tcnter, c1, c2, ans = Counter(), Counter(nums1), Counter(nums2), 0\\n\\tfor n in range(1, 7):\\n\\t\\tcnter[6-n] += c1[n]  # change nums1 into 6\\n\\t\\tcnter[n-1] += c2[n]  # change nums2 into 1\\n\\tfor i in range(5, 0, -1):\\n\\t\\tif d>i*cnter[i]:\\n\\t\\t\\td, ans = d-i*cnter[i], ans+cnter[i]  # all \\'i\\' is used\\n\\t\\telse:\\n\\t\\t\\treturn ans+ceil(d/i)\\n\\treturn -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n\\td = sum(nums2)-sum(nums1)  # sum(nums2)>sum(nums1)\\n\\tif d<=0:\\n\\t\\treturn 0 if d==0 else self.minOperations(nums2, nums1)\\n\\tcnter, c1, c2, ans = Counter(), Counter(nums1), Counter(nums2), 0\\n\\tfor n in range(1, 7):\\n\\t\\tcnter[6-n] += c1[n]  # change nums1 into 6\\n\\t\\tcnter[n-1] += c2[n]  # change nums2 into 1\\n\\tfor i in range(5, 0, -1):\\n\\t\\tif d>i*cnter[i]:\\n\\t\\t\\td, ans = d-i*cnter[i], ans+cnter[i]  # all \\'i\\' is used\\n\\t\\telse:\\n\\t\\t\\treturn ans+ceil(d/i)\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3107294,
                "title": "python-sorting-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        lower_sum = min(sum1,sum2)\\n        higher_sum = max(sum1,sum2)\\n        res = 0\\n        arr = []\\n\\n        if sum1 > sum2:\\n            for i in range(len(nums1)):arr.append(nums1[i]-1)\\n            for i in range(len(nums2)):arr.append(6-nums2[i])\\n        elif sum2 > sum1:\\n            for i in range(len(nums2)):arr.append(nums2[i]-1)\\n            for i in range(len(nums1)):arr.append(6-nums1[i])\\n        else:\\n            return 0\\n\\n        arr = sorted(arr,reverse = True)\\n\\n        for i in range(len(arr)):\\n            lower_sum += arr[i]\\n            res += 1\\n            \\n            if lower_sum >= higher_sum: return res\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        lower_sum = min(sum1,sum2)\\n        higher_sum = max(sum1,sum2)\\n        res = 0\\n        arr = []\\n\\n        if sum1 > sum2:\\n            for i in range(len(nums1)):arr.append(nums1[i]-1)\\n            for i in range(len(nums2)):arr.append(6-nums2[i])\\n        elif sum2 > sum1:\\n            for i in range(len(nums2)):arr.append(nums2[i]-1)\\n            for i in range(len(nums1)):arr.append(6-nums1[i])\\n        else:\\n            return 0\\n\\n        arr = sorted(arr,reverse = True)\\n\\n        for i in range(len(arr)):\\n            lower_sum += arr[i]\\n            res += 1\\n            \\n            if lower_sum >= higher_sum: return res\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087820,
                "title": "java-greedy-solution-with-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n\\tprivate int sum(int[] nums) {\\n\\t\\tint sum = 0;\\n\\t\\tfor (int num : nums) {\\n\\t\\t\\tsum += num;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\t\\n\\tpublic int minOperations(int[] nums1, int[] nums2) {\\n\\t\\tint sum1 = sum(nums1);\\n\\t\\tint sum2 = sum(nums2);\\n\\t\\t\\n\\t\\tif (sum1 == sum2) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\tPriorityQueue<Integer> minHeap;\\n\\t\\tPriorityQueue<Integer> maxHeap;\\n\\t\\t\\n\\t\\tif (sum1 < sum2) {\\n\\t\\t\\tminHeap = new PriorityQueue<>(nums1.length);\\n\\t\\t\\tmaxHeap = new PriorityQueue<>(nums2.length, Collections.reverseOrder());\\n\\t\\t\\tfor (int num : nums1) {\\n\\t\\t\\t\\tminHeap.add(num);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int num : nums2) {\\n\\t\\t\\t\\tmaxHeap.add(num);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tminHeap = new PriorityQueue<>(nums2.length);\\n\\t\\t\\tmaxHeap = new PriorityQueue<>(nums1.length, Collections.reverseOrder());\\n\\t\\t\\tfor (int num : nums2) {\\n\\t\\t\\t\\tminHeap.add(num);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int num : nums1) {\\n\\t\\t\\t\\tmaxHeap.add(num);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tint solvedDiff = 0;\\n\\t\\tint flipCount = 0;\\n\\t\\tint diff = Math.abs(sum1 - sum2);\\n\\t\\t\\n\\t\\twhile (solvedDiff < diff) {\\n\\t\\t\\tint minHeapPeek = minHeap.peek();\\n\\t\\t\\tint maxHeapPeek = maxHeap.peek();\\n\\t\\t\\tif (minHeapPeek == 6 && maxHeapPeek == 1) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tint diffUsingMin = 6 - minHeapPeek;\\n\\t\\t\\tint diffUsingMax = maxHeapPeek - 1;\\n\\t\\t\\tif (diffUsingMin > diffUsingMax) {\\n\\t\\t\\t\\tminHeap.poll();\\n\\t\\t\\t\\tminHeap.offer(6);\\n\\t\\t\\t\\tsolvedDiff += diffUsingMin;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmaxHeap.poll();\\n\\t\\t\\t\\tmaxHeap.offer(1);\\n\\t\\t\\t\\tsolvedDiff += diffUsingMax;\\n\\t\\t\\t}\\n\\t\\t\\tflipCount++;\\n\\t\\t}\\n\\t\\treturn flipCount;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n\\tprivate int sum(int[] nums) {\\n\\t\\tint sum = 0;\\n\\t\\tfor (int num : nums) {\\n\\t\\t\\tsum += num;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\t\\n\\tpublic int minOperations(int[] nums1, int[] nums2) {\\n\\t\\tint sum1 = sum(nums1);\\n\\t\\tint sum2 = sum(nums2);\\n\\t\\t\\n\\t\\tif (sum1 == sum2) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\tPriorityQueue<Integer> minHeap;\\n\\t\\tPriorityQueue<Integer> maxHeap;\\n\\t\\t\\n\\t\\tif (sum1 < sum2) {\\n\\t\\t\\tminHeap = new PriorityQueue<>(nums1.length);\\n\\t\\t\\tmaxHeap = new PriorityQueue<>(nums2.length, Collections.reverseOrder());\\n\\t\\t\\tfor (int num : nums1) {\\n\\t\\t\\t\\tminHeap.add(num);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int num : nums2) {\\n\\t\\t\\t\\tmaxHeap.add(num);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tminHeap = new PriorityQueue<>(nums2.length);\\n\\t\\t\\tmaxHeap = new PriorityQueue<>(nums1.length, Collections.reverseOrder());\\n\\t\\t\\tfor (int num : nums2) {\\n\\t\\t\\t\\tminHeap.add(num);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int num : nums1) {\\n\\t\\t\\t\\tmaxHeap.add(num);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tint solvedDiff = 0;\\n\\t\\tint flipCount = 0;\\n\\t\\tint diff = Math.abs(sum1 - sum2);\\n\\t\\t\\n\\t\\twhile (solvedDiff < diff) {\\n\\t\\t\\tint minHeapPeek = minHeap.peek();\\n\\t\\t\\tint maxHeapPeek = maxHeap.peek();\\n\\t\\t\\tif (minHeapPeek == 6 && maxHeapPeek == 1) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tint diffUsingMin = 6 - minHeapPeek;\\n\\t\\t\\tint diffUsingMax = maxHeapPeek - 1;\\n\\t\\t\\tif (diffUsingMin > diffUsingMax) {\\n\\t\\t\\t\\tminHeap.poll();\\n\\t\\t\\t\\tminHeap.offer(6);\\n\\t\\t\\t\\tsolvedDiff += diffUsingMin;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmaxHeap.poll();\\n\\t\\t\\t\\tmaxHeap.offer(1);\\n\\t\\t\\t\\tsolvedDiff += diffUsingMax;\\n\\t\\t\\t}\\n\\t\\t\\tflipCount++;\\n\\t\\t}\\n\\t\\treturn flipCount;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945699,
                "title": "python-greedy-lengthy-but-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        sum1, sum2 = sum(nums1), sum(nums2)\\n        if sum1 == sum2: return 0\\n        if sum1 > sum2:\\n            nums1, nums2 = nums2, nums1\\n            sum1, sum2 = sum2, sum1\\n        nums1.sort()\\n        nums2.sort()\\n        m, n = len(nums1), len(nums2)\\n        i, j = 0, n - 1\\n        res = 0\\n        while i < m and j >= 0:\\n            if abs(6-nums1[i]) < nums2[j]:\\n                sum2 -= nums2[j] - 1\\n                j -= 1\\n            else:\\n                sum1 += abs(6-nums1[i])\\n                i += 1\\n            res += 1\\n            if sum1 >= sum2: return res\\n        while i < m:\\n            sum1 += abs(6-nums1[i])\\n            res += 1\\n            i += 1\\n            if sum1 >= sum2: return res\\n        while j >= 0:\\n            sum2 -= nums2[j] - 1\\n            res += 1\\n            j -= 1\\n            if sum1 >= sum2: return res\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        sum1, sum2 = sum(nums1), sum(nums2)\\n        if sum1 == sum2: return 0\\n        if sum1 > sum2:\\n            nums1, nums2 = nums2, nums1\\n            sum1, sum2 = sum2, sum1\\n        nums1.sort()\\n        nums2.sort()\\n        m, n = len(nums1), len(nums2)\\n        i, j = 0, n - 1\\n        res = 0\\n        while i < m and j >= 0:\\n            if abs(6-nums1[i]) < nums2[j]:\\n                sum2 -= nums2[j] - 1\\n                j -= 1\\n            else:\\n                sum1 += abs(6-nums1[i])\\n                i += 1\\n            res += 1\\n            if sum1 >= sum2: return res\\n        while i < m:\\n            sum1 += abs(6-nums1[i])\\n            res += 1\\n            i += 1\\n            if sum1 >= sum2: return res\\n        while j >= 0:\\n            sum2 -= nums2[j] - 1\\n            res += 1\\n            j -= 1\\n            if sum1 >= sum2: return res\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925129,
                "title": "greedy-intuitive-solution-simulation",
                "content": "# Intuition\\nThe idea is simply to check if we can change the inequality sign between the sum of both lists. We do not need to match them.\\n\\n# Approach\\nGreedy Approach would be the best fit for such problems. We simply find the maximum sum and change the numbers in that list to 1 in decreasing order while changing the numbers in the other list to 6 in increasing order. This happens until the sum1(initial max) > sum2(initial min)\\n\\n# Complexity\\n- Time complexity:\\nO(n+m)\\n\\n- Space complexity:\\nO(n+m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        if(max(nums1.size(),nums2.size())*1>min(nums1.size(),nums2.size())*6)\\n            return -1;\\n        int sum1=0;\\n        int sum2=0;\\n        vector<int> cache1(7,0);\\n        vector<int> cache2(7,0);\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            sum1 += nums1[i];\\n            cache1[nums1[i]] +=1;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            sum2 += nums2[i];\\n            cache2[nums2[i]] +=1;\\n        }\\n        int steps = 0;\\n        if(sum1 == sum2)\\n            return 0;\\n        if(sum1<sum2)\\n        {\\n            vector<int> temp = cache2;\\n            cache2 = cache1;\\n            cache1 = temp;\\n            int t = sum2;\\n            sum2 = sum1;\\n            sum1 = t;\\n        }\\n            for(int i=1;i<7;i++)\\n            {\\n                for(int j=0;j<cache2[i];j++)\\n                {\\n                    sum2+=6-i;\\n                    steps+=1;\\n                    if(sum1<=sum2)\\n                    {\\n                        return steps;\\n                    }\\n                }\\n                for(int j=0;j<cache1[7-i];j++)\\n                {\\n                    sum1=sum1 - (6-i);\\n                    steps+=1;\\n                    if(sum1<=sum2)\\n                    {\\n                        return steps;\\n                    }\\n                }\\n            }\\n            return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        if(max(nums1.size(),nums2.size())*1>min(nums1.size(),nums2.size())*6)\\n            return -1;\\n        int sum1=0;\\n        int sum2=0;\\n        vector<int> cache1(7,0);\\n        vector<int> cache2(7,0);\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            sum1 += nums1[i];\\n            cache1[nums1[i]] +=1;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            sum2 += nums2[i];\\n            cache2[nums2[i]] +=1;\\n        }\\n        int steps = 0;\\n        if(sum1 == sum2)\\n            return 0;\\n        if(sum1<sum2)\\n        {\\n            vector<int> temp = cache2;\\n            cache2 = cache1;\\n            cache1 = temp;\\n            int t = sum2;\\n            sum2 = sum1;\\n            sum1 = t;\\n        }\\n            for(int i=1;i<7;i++)\\n            {\\n                for(int j=0;j<cache2[i];j++)\\n                {\\n                    sum2+=6-i;\\n                    steps+=1;\\n                    if(sum1<=sum2)\\n                    {\\n                        return steps;\\n                    }\\n                }\\n                for(int j=0;j<cache1[7-i];j++)\\n                {\\n                    sum1=sum1 - (6-i);\\n                    steps+=1;\\n                    if(sum1<=sum2)\\n                    {\\n                        return steps;\\n                    }\\n                }\\n            }\\n            return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885854,
                "title": "python-solution-sort-greedy-faster-than-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Sort + Greedy \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn) + O(mlogm) + O(m+n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1_len = len(nums1)\\n        nums2_len = len(nums2)\\n\\n        if min(nums1_len, nums2_len)*6 < max(nums1_len, nums2_len): \\n            return -1 \\n            \\n        ops = 0 \\n        nums1_sum = sum(nums1) \\n        nums2_sum = sum(nums2)\\n        if nums1_sum == nums2_sum: \\n            return ops  \\n        nums1.sort()\\n        nums2.sort()\\n\\n        if nums1_sum < nums2_sum: \\n            sum_diff = nums2_sum - nums1_sum\\n            nums1_idx = 0 \\n            nums2_idx = nums2_len-1 \\n            while sum_diff>0: \\n                max_change = None \\n                nums1_change = 6-nums1[nums1_idx] if nums1_idx<nums1_len else 0 \\n                nums2_change = nums2[nums2_idx]-1 if nums2_idx>=0 else 0 \\n                if nums1_change>=nums2_change:\\n                    max_change = nums1_change\\n                    nums1[nums1_idx] = 6 \\n                    nums1_idx += 1  \\n                elif nums1_change<nums2_change: \\n                    max_change = nums2_change\\n                    nums2[nums2_idx] = 1 \\n                    nums2_idx -= 1   \\n                ops += 1 \\n                sum_diff -= max_change   \\n\\n        elif nums1_sum > nums2_sum: \\n            sum_diff = nums1_sum - nums2_sum \\n            nums1_idx = nums1_len-1 \\n            nums2_idx = 0 \\n            while sum_diff>0:\\n                max_change = None\\n                nums1_change = nums1[nums1_idx]-1 if nums1_idx>=0 else 0 \\n                nums2_change = 6-nums2[nums2_idx] if nums2_idx<nums2_len else 0 \\n                if nums1_change>=nums2_change: \\n                    max_change = nums1_change \\n                    nums1[nums1_idx]=1\\n                    nums1_idx-=1 \\n                elif nums1_change<nums2_change: \\n                    max_change = nums2_change\\n                    nums2[nums2_idx]=6\\n                    nums2_idx += 1              \\n                ops += 1 \\n                sum_diff -= max_change   \\n        return ops\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1_len = len(nums1)\\n        nums2_len = len(nums2)\\n\\n        if min(nums1_len, nums2_len)*6 < max(nums1_len, nums2_len): \\n            return -1 \\n            \\n        ops = 0 \\n        nums1_sum = sum(nums1) \\n        nums2_sum = sum(nums2)\\n        if nums1_sum == nums2_sum: \\n            return ops  \\n        nums1.sort()\\n        nums2.sort()\\n\\n        if nums1_sum < nums2_sum: \\n            sum_diff = nums2_sum - nums1_sum\\n            nums1_idx = 0 \\n            nums2_idx = nums2_len-1 \\n            while sum_diff>0: \\n                max_change = None \\n                nums1_change = 6-nums1[nums1_idx] if nums1_idx<nums1_len else 0 \\n                nums2_change = nums2[nums2_idx]-1 if nums2_idx>=0 else 0 \\n                if nums1_change>=nums2_change:\\n                    max_change = nums1_change\\n                    nums1[nums1_idx] = 6 \\n                    nums1_idx += 1  \\n                elif nums1_change<nums2_change: \\n                    max_change = nums2_change\\n                    nums2[nums2_idx] = 1 \\n                    nums2_idx -= 1   \\n                ops += 1 \\n                sum_diff -= max_change   \\n\\n        elif nums1_sum > nums2_sum: \\n            sum_diff = nums1_sum - nums2_sum \\n            nums1_idx = nums1_len-1 \\n            nums2_idx = 0 \\n            while sum_diff>0:\\n                max_change = None\\n                nums1_change = nums1[nums1_idx]-1 if nums1_idx>=0 else 0 \\n                nums2_change = 6-nums2[nums2_idx] if nums2_idx<nums2_len else 0 \\n                if nums1_change>=nums2_change: \\n                    max_change = nums1_change \\n                    nums1[nums1_idx]=1\\n                    nums1_idx-=1 \\n                elif nums1_change<nums2_change: \\n                    max_change = nums2_change\\n                    nums2[nums2_idx]=6\\n                    nums2_idx += 1              \\n                ops += 1 \\n                sum_diff -= max_change   \\n        return ops\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885500,
                "title": "python3-solution-with-counting",
                "content": "# Intuition\\nCount the number of 1, 2, ... 6 from nums1 and nums2. For the list with larger sum, count 6 as 0, 5 as 1, etc! For the list with smaller sum, count 1 as 0, 2 as 1, etc. In the end we have counts:\\n```\\n0: n0,\\n1: n1,\\n...\\n```\\n\\nNow the question is when it reaches the sum difference when we convert the 0s -> 5s, 1s -> 5s, etc.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def getCounts(self, nums1, nums2, n=6):\\n        # sum of nums1 < nums2, meaning nums1 goes up\\n        # nums2 goes down\\n        # to make everything go up, mark counts of nums1 as\\n        # is: 1 --> counts[0] += 1, \\n        # but counts of nums2 with conversion\\n        # 6 --> counts[0] += 1\\n\\n        counts = [0] * n\\n        for val in nums1:\\n            counts[val-1] += 1\\n        for val in nums2:\\n            counts[n-val] += 1\\n        return counts\\n\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        if min(n1, n2) * 6 < max(n1, n2): return -1\\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        if sum1 == sum2: return 0\\n        if sum1 < sum2:\\n            counts = self.getCounts(nums1, nums2)\\n        else:\\n            counts = self.getCounts(nums2, nums1)\\n        # fill the difference of two sums\\n        dif = abs(sum1 - sum2)\\n        n_operations = 0\\n        for i, cnt in enumerate(counts):\\n            # when i==0, it can take a step of 5 -> 5\\n            # when i==1, it can take a step of 4 -> 5\\n            for j in range(cnt):\\n                step = 5 - i\\n                n_operations += 1\\n                dif -= step\\n                if dif <= 0: return n_operations\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n0: n0,\\n1: n1,\\n...\\n```\n```\\nclass Solution:\\n    def getCounts(self, nums1, nums2, n=6):\\n        # sum of nums1 < nums2, meaning nums1 goes up\\n        # nums2 goes down\\n        # to make everything go up, mark counts of nums1 as\\n        # is: 1 --> counts[0] += 1, \\n        # but counts of nums2 with conversion\\n        # 6 --> counts[0] += 1\\n\\n        counts = [0] * n\\n        for val in nums1:\\n            counts[val-1] += 1\\n        for val in nums2:\\n            counts[n-val] += 1\\n        return counts\\n\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        if min(n1, n2) * 6 < max(n1, n2): return -1\\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        if sum1 == sum2: return 0\\n        if sum1 < sum2:\\n            counts = self.getCounts(nums1, nums2)\\n        else:\\n            counts = self.getCounts(nums2, nums1)\\n        # fill the difference of two sums\\n        dif = abs(sum1 - sum2)\\n        n_operations = 0\\n        for i, cnt in enumerate(counts):\\n            # when i==0, it can take a step of 5 -> 5\\n            # when i==1, it can take a step of 4 -> 5\\n            for j in range(cnt):\\n                step = 5 - i\\n                n_operations += 1\\n                dif -= step\\n                if dif <= 0: return n_operations\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835998,
                "title": "python-greedy-and-sorting-solution-o-nlogn-time-o-n-space",
                "content": "```\\n# * Greedy and Sorting Solution | O(nlogn) Time | O(n) Space\\n# * n -> The length of nums1 and nums2 array\\n\\n\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        total_sum1, total_sum2 = sum(nums1), sum(nums2)\\n        if total_sum1 == total_sum2:\\n            return 0\\n\\n        # * Swap the array so as to increase the values in the smaller array (nums1)\\n        # * and decrease the values in the larger array (nums2).\\n        if total_sum2 < total_sum1:\\n            nums1, nums2 = nums2, nums1\\n\\n        # * To increase the value -> UPPER_LIMIT (6) - num.\\n        # * To decrease the value -> num - LOWER_LIMIT (1).\\n        nums = [6 - num for num in nums1] + [num - 1 for num in nums2]\\n        nums.sort(reverse=True)\\n        sum_diff = abs(total_sum1 - total_sum2)\\n        count = 0\\n        for num in nums:\\n            count += 1\\n            sum_diff -= num\\n            if sum_diff <= 0:\\n                return count\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n# * Greedy and Sorting Solution | O(nlogn) Time | O(n) Space\\n# * n -> The length of nums1 and nums2 array\\n\\n\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        total_sum1, total_sum2 = sum(nums1), sum(nums2)\\n        if total_sum1 == total_sum2:\\n            return 0\\n\\n        # * Swap the array so as to increase the values in the smaller array (nums1)\\n        # * and decrease the values in the larger array (nums2).\\n        if total_sum2 < total_sum1:\\n            nums1, nums2 = nums2, nums1\\n\\n        # * To increase the value -> UPPER_LIMIT (6) - num.\\n        # * To decrease the value -> num - LOWER_LIMIT (1).\\n        nums = [6 - num for num in nums1] + [num - 1 for num in nums2]\\n        nums.sort(reverse=True)\\n        sum_diff = abs(total_sum1 - total_sum2)\\n        count = 0\\n        for num in nums:\\n            count += 1\\n            sum_diff -= num\\n            if sum_diff <= 0:\\n                return count\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824971,
                "title": "python-solution-with-math-check",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can think of this problem in two parts. One, determine if we can even solve the problem. Two, if the input is solvable, break down each array\\'s integers to see how much we can change them to bring us closer to equillibrium.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHello friends,\\n\\nFirst, we check if the sum adjustment is possible first. Since we can adjust the integers (1-6) in either array, we know with certainty that if one array is more than 6 times longer than the other, the two sums cannot be matched. We also know that if the lengths are within 6 times one another (inclusive), then we can always adjust all the numbers to be all 6s and 1s, or some other equal some combination. O(1) time for this step. For interviews, important to callout this is advantageous if you commonly expect to hit this case, saving us from O(nlogn) work later.\\n\\nThen, we see how much we can minimize the gap in sums by changing one int at each index. For the first array, (we ensure it\\'s larger), we see how much we can minimize each element, and for the second array, we see how much we can maximize each element.\\n\\nWe sort this in O(nlogn) time. For each element, we know we can change it to be any number 1-6 so it does not matter if the final elem. is > than the remainder.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        lDiv =  len(nums1) / len(nums2)\\n        if lDiv > 6 or lDiv < 1/6:\\n            return -1\\n        \\n        s1, s2 = sum(nums1), sum(nums2)\\n        if s1 < s2:\\n            s1, s2, nums1, nums2 = s2, s1, nums2, nums1\\n        \\n        adjustments = [num - 1 for num in nums1]\\n        adjustments += [6 - num for num in nums2]\\n        adjustments.sort(reverse= True)\\n\\n        ops = 0\\n        while s1 > s2:\\n            s1 -= adjustments[ops]\\n            ops += 1\\n        return ops\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        lDiv =  len(nums1) / len(nums2)\\n        if lDiv > 6 or lDiv < 1/6:\\n            return -1\\n        \\n        s1, s2 = sum(nums1), sum(nums2)\\n        if s1 < s2:\\n            s1, s2, nums1, nums2 = s2, s1, nums2, nums1\\n        \\n        adjustments = [num - 1 for num in nums1]\\n        adjustments += [6 - num for num in nums2]\\n        adjustments.sort(reverse= True)\\n\\n        ops = 0\\n        while s1 > s2:\\n            s1 -= adjustments[ops]\\n            ops += 1\\n        return ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805052,
                "title": "python-o-n-beats-98",
                "content": "# Intuition\\nAll we need to know is how many of each number there are in each array\\n\\n# Approach\\nCount the number of each int from 1 to 6 (Takes O(N)), and then use the two dictionaries (each with 6 key value pairs) because they contain all the information we need. \\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        if len(nums1) > len(nums2)*6 or len(nums1)*6 < len(nums2):\\n            return -1\\n\\n        c1 = Counter(nums1)\\n        c2 = Counter(nums2)\\n\\n        # Everything below uses only c1, c2 which are constant sized\\n\\n        def sum_counter(ct):\\n            s = 0\\n            for key, value in ct.items():\\n                s += key * value\\n            return s\\n        \\n        s1 = sum_counter(c1)\\n        s2 = sum_counter(c2)\\n        cs, cl = (c1, c2) if s1 < s2 else (c2, c1)\\n        sdiff = abs(s1-s2)\\n        remain = sdiff\\n        op = 0\\n        for i in range(1, 6):\\n            unit_diff = 6-i\\n            num_available = cs[i] + cl[7-i]\\n            if num_available*unit_diff >= remain:\\n                num_used = int(math.ceil(remain/unit_diff))\\n                op += num_used\\n                return op\\n            else:\\n                remain -= unit_diff*num_available\\n                op += num_available\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        if len(nums1) > len(nums2)*6 or len(nums1)*6 < len(nums2):\\n            return -1\\n\\n        c1 = Counter(nums1)\\n        c2 = Counter(nums2)\\n\\n        # Everything below uses only c1, c2 which are constant sized\\n\\n        def sum_counter(ct):\\n            s = 0\\n            for key, value in ct.items():\\n                s += key * value\\n            return s\\n        \\n        s1 = sum_counter(c1)\\n        s2 = sum_counter(c2)\\n        cs, cl = (c1, c2) if s1 < s2 else (c2, c1)\\n        sdiff = abs(s1-s2)\\n        remain = sdiff\\n        op = 0\\n        for i in range(1, 6):\\n            unit_diff = 6-i\\n            num_available = cs[i] + cl[7-i]\\n            if num_available*unit_diff >= remain:\\n                num_used = int(math.ceil(remain/unit_diff))\\n                op += num_used\\n                return op\\n            else:\\n                remain -= unit_diff*num_available\\n                op += num_available\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777464,
                "title": "c-accepted-solution-faster-than-59",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int N[2][7];\\n    int S[2];\\n    \\n    int result = 1e7;\\n    \\n    void opt(int nidx, vector<int>& n) {\\n        int s = 0;\\n        for (int v : n) {\\n            N[nidx][v]++;\\n            s += v;\\n        }\\n        S[nidx] = s;\\n    }\\n    void opt(int cvl, int cvs, int& li, int& si, int curcnt, int diff) {\\n        if (cvl >= 1 && cvs <= 6) {\\n            int cvlmd = (cvl - 1) * N[li][cvl];\\n            int cvsmd = (6 - cvs) * N[si][cvs];\\n            if (diff > cvlmd) {\\n                curcnt += N[li][cvl];\\n                diff -= cvlmd;\\n                opt(cvl - 1, cvs, li, si, curcnt, diff);\\n                diff += cvlmd;\\n                curcnt -= N[li][cvl];\\n            }\\n            else if (diff == cvlmd) {\\n                curcnt += N[li][cvl];\\n                result = std::min(result, curcnt);\\n                curcnt -= N[li][cvl];\\n            }\\n            else {\\n                int tc = diff / (cvl - 1);\\n                if ((diff % (cvl - 1)) != 0) {\\n                    tc++;\\n                }\\n                curcnt += tc;\\n                result = std::min(result, curcnt);\\n                curcnt -= tc;\\n            }\\n            if (diff > cvsmd) {\\n                curcnt += N[si][cvs];\\n                diff -= cvsmd;\\n                opt(cvl, cvs + 1, li, si, curcnt, diff);\\n                curcnt -= N[si][cvs];\\n                diff += cvsmd;\\n            }\\n            else if (diff == cvsmd) {\\n                curcnt += N[si][cvs];\\n                result = std::min(result, curcnt);\\n                curcnt -= N[si][cvs];\\n            }\\n            else {\\n                int tc = diff / (6 - cvs);\\n                if ((diff % (6 - cvs)) != 0) {\\n                    tc++;\\n                }\\n                curcnt += tc;\\n                result = std::min(result, curcnt);\\n                curcnt -= tc;\\n            }\\n        }\\n        else if (cvs <= 6) {\\n            int cvsmd = (6 - cvs) * N[si][cvs];\\n            if (diff > cvsmd) {\\n                curcnt += N[si][cvs];\\n                diff -= cvsmd;\\n                opt(cvl, cvs + 1, li, si, curcnt, diff);\\n                curcnt -= N[si][cvs];\\n                diff += cvsmd;\\n            }\\n            else if (diff == cvsmd) {\\n                curcnt += N[si][cvs];\\n                result = std::min(result, curcnt);\\n                curcnt -= N[si][cvs];\\n            }\\n            else {\\n                int tc = diff / (6 - cvs);\\n                if ((diff % (6 - cvs)) != 0) {\\n                    tc++;\\n                }\\n                curcnt += tc;\\n                result = std::min(result, curcnt);\\n                curcnt -= tc;\\n            }\\n        }\\n        else if (cvl >= 1) {\\n            int cvlmd = (cvl - 1) * N[li][cvl];\\n            if (diff > cvlmd) {\\n                curcnt += N[li][cvl];\\n                diff -= cvlmd;\\n                opt(cvl - 1, cvs, li, si, curcnt, diff);\\n                diff += cvlmd;\\n                curcnt -= N[li][cvl];\\n            }\\n            else if (diff == cvlmd) {\\n                curcnt += N[li][cvl];\\n                result = std::min(result, curcnt);\\n                curcnt -= N[li][cvl];\\n            }\\n            else {\\n                int tc = diff / (cvl - 1);\\n                if ((diff % (cvl - 1)) != 0) {\\n                    tc++;\\n                }\\n                curcnt += tc;\\n                result = std::min(result, curcnt);\\n                curcnt -= tc;\\n            }\\n        }\\n    }\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 7; j++) {\\n                N[i][j] = 0;\\n            }\\n        }\\n        opt(0, nums1);\\n        opt(1, nums2);\\n        if (S[0] == S[1])\\n            return 0;\\n        int li, si;\\n        int diff = std::abs(S[0] - S[1]);\\n        if (S[0] > S[1]) {\\n            li = 0;\\n            si = 1;\\n        }\\n        else {\\n            li = 1;\\n            si = 0;\\n        }\\n        opt(6, 1, li, si, 0, diff);        \\n        if (result == 1e7)\\n            return -1;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int N[2][7];\\n    int S[2];\\n    \\n    int result = 1e7;\\n    \\n    void opt(int nidx, vector<int>& n) {\\n        int s = 0;\\n        for (int v : n) {\\n            N[nidx][v]++;\\n            s += v;\\n        }\\n        S[nidx] = s;\\n    }\\n    void opt(int cvl, int cvs, int& li, int& si, int curcnt, int diff) {\\n        if (cvl >= 1 && cvs <= 6) {\\n            int cvlmd = (cvl - 1) * N[li][cvl];\\n            int cvsmd = (6 - cvs) * N[si][cvs];\\n            if (diff > cvlmd) {\\n                curcnt += N[li][cvl];\\n                diff -= cvlmd;\\n                opt(cvl - 1, cvs, li, si, curcnt, diff);\\n                diff += cvlmd;\\n                curcnt -= N[li][cvl];\\n            }\\n            else if (diff == cvlmd) {\\n                curcnt += N[li][cvl];\\n                result = std::min(result, curcnt);\\n                curcnt -= N[li][cvl];\\n            }\\n            else {\\n                int tc = diff / (cvl - 1);\\n                if ((diff % (cvl - 1)) != 0) {\\n                    tc++;\\n                }\\n                curcnt += tc;\\n                result = std::min(result, curcnt);\\n                curcnt -= tc;\\n            }\\n            if (diff > cvsmd) {\\n                curcnt += N[si][cvs];\\n                diff -= cvsmd;\\n                opt(cvl, cvs + 1, li, si, curcnt, diff);\\n                curcnt -= N[si][cvs];\\n                diff += cvsmd;\\n            }\\n            else if (diff == cvsmd) {\\n                curcnt += N[si][cvs];\\n                result = std::min(result, curcnt);\\n                curcnt -= N[si][cvs];\\n            }\\n            else {\\n                int tc = diff / (6 - cvs);\\n                if ((diff % (6 - cvs)) != 0) {\\n                    tc++;\\n                }\\n                curcnt += tc;\\n                result = std::min(result, curcnt);\\n                curcnt -= tc;\\n            }\\n        }\\n        else if (cvs <= 6) {\\n            int cvsmd = (6 - cvs) * N[si][cvs];\\n            if (diff > cvsmd) {\\n                curcnt += N[si][cvs];\\n                diff -= cvsmd;\\n                opt(cvl, cvs + 1, li, si, curcnt, diff);\\n                curcnt -= N[si][cvs];\\n                diff += cvsmd;\\n            }\\n            else if (diff == cvsmd) {\\n                curcnt += N[si][cvs];\\n                result = std::min(result, curcnt);\\n                curcnt -= N[si][cvs];\\n            }\\n            else {\\n                int tc = diff / (6 - cvs);\\n                if ((diff % (6 - cvs)) != 0) {\\n                    tc++;\\n                }\\n                curcnt += tc;\\n                result = std::min(result, curcnt);\\n                curcnt -= tc;\\n            }\\n        }\\n        else if (cvl >= 1) {\\n            int cvlmd = (cvl - 1) * N[li][cvl];\\n            if (diff > cvlmd) {\\n                curcnt += N[li][cvl];\\n                diff -= cvlmd;\\n                opt(cvl - 1, cvs, li, si, curcnt, diff);\\n                diff += cvlmd;\\n                curcnt -= N[li][cvl];\\n            }\\n            else if (diff == cvlmd) {\\n                curcnt += N[li][cvl];\\n                result = std::min(result, curcnt);\\n                curcnt -= N[li][cvl];\\n            }\\n            else {\\n                int tc = diff / (cvl - 1);\\n                if ((diff % (cvl - 1)) != 0) {\\n                    tc++;\\n                }\\n                curcnt += tc;\\n                result = std::min(result, curcnt);\\n                curcnt -= tc;\\n            }\\n        }\\n    }\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 7; j++) {\\n                N[i][j] = 0;\\n            }\\n        }\\n        opt(0, nums1);\\n        opt(1, nums2);\\n        if (S[0] == S[1])\\n            return 0;\\n        int li, si;\\n        int diff = std::abs(S[0] - S[1]);\\n        if (S[0] > S[1]) {\\n            li = 0;\\n            si = 1;\\n        }\\n        else {\\n            li = 1;\\n            si = 0;\\n        }\\n        opt(6, 1, li, si, 0, diff);        \\n        if (result == 1e7)\\n            return -1;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771141,
                "title": "greedy-solution-c",
                "content": "# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        //small sum  nums1 \\n        int s1=0,s2=0;\\n        for(int i=0;i<nums1.size();i++){s1+=nums1[i];}\\n        for(int i=0;i<nums2.size();i++){s2+=nums2[i];}\\n        if(s1>s2){swap(nums1,nums2);s1-=s2;}\\n        else{s1-=s2;s1*=-1;}\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        // GREEDY\\n        int i1=0,i2=nums2.size()-1;\\n        int ans=0;\\n        while(i1<nums1.size() && i2>=0 && s1>0)\\n        {\\n            if(6-nums1[i1]>nums2[i2]-1)\\n            {\\n                s1-=6-nums1[i1];\\n                i1++;\\n            }\\n            else\\n            {\\n                s1-=nums2[i2]-1;\\n                i2--;\\n            }\\n            ans++;\\n        }\\n        while(i1<nums1.size() && s1>0)\\n        {\\n            s1-=6-nums1[i1];\\n            i1++;\\n            ans++;\\n        }\\n        while(i2>=0 && s1>0)\\n        {\\n            s1-=nums2[i2]-1;\\n            i2--;\\n            ans++;\\n        }\\n        if(s1>0)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        //small sum  nums1 \\n        int s1=0,s2=0;\\n        for(int i=0;i<nums1.size();i++){s1+=nums1[i];}\\n        for(int i=0;i<nums2.size();i++){s2+=nums2[i];}\\n        if(s1>s2){swap(nums1,nums2);s1-=s2;}\\n        else{s1-=s2;s1*=-1;}\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        // GREEDY\\n        int i1=0,i2=nums2.size()-1;\\n        int ans=0;\\n        while(i1<nums1.size() && i2>=0 && s1>0)\\n        {\\n            if(6-nums1[i1]>nums2[i2]-1)\\n            {\\n                s1-=6-nums1[i1];\\n                i1++;\\n            }\\n            else\\n            {\\n                s1-=nums2[i2]-1;\\n                i2--;\\n            }\\n            ans++;\\n        }\\n        while(i1<nums1.size() && s1>0)\\n        {\\n            s1-=6-nums1[i1];\\n            i1++;\\n            ans++;\\n        }\\n        while(i2>=0 && s1>0)\\n        {\\n            s1-=nums2[i2]-1;\\n            i2--;\\n            ans++;\\n        }\\n        if(s1>0)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742459,
                "title": "simple-c-solution-o-n-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum(vector<int> &nums) {\\n        int s=0;\\n        for (auto i : nums) {\\n            s += i;\\n        }\\n        return s;\\n    }\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1 = sum(nums1), sum2 = sum(nums2);\\n        int target=sum2-sum1;\\n        if (sum2 < sum1) {   \\n            target=-target;\\n            swap(nums1, nums2);\\n        }\\n        vector<int> vars(6);\\n        for (auto i : nums1) {\\n            vars[6-i]++;\\n        }\\n        for (auto i : nums2) {\\n            vars[i-1]++;\\n        }\\n        int t = 0;\\n        for(int i = 5; i >= 1; i--) {\\n            if (target - i*vars[i] <= 0) {\\n                return t + (target+i-1)/i;\\n            }\\n            target -= i*vars[i];\\n            t += vars[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum(vector<int> &nums) {\\n        int s=0;\\n        for (auto i : nums) {\\n            s += i;\\n        }\\n        return s;\\n    }\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1 = sum(nums1), sum2 = sum(nums2);\\n        int target=sum2-sum1;\\n        if (sum2 < sum1) {   \\n            target=-target;\\n            swap(nums1, nums2);\\n        }\\n        vector<int> vars(6);\\n        for (auto i : nums1) {\\n            vars[6-i]++;\\n        }\\n        for (auto i : nums2) {\\n            vars[i-1]++;\\n        }\\n        int t = 0;\\n        for(int i = 5; i >= 1; i--) {\\n            if (target - i*vars[i] <= 0) {\\n                return t + (target+i-1)/i;\\n            }\\n            target -= i*vars[i];\\n            t += vars[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725484,
                "title": "python-greedy-solution-with-max-heap-easy-understanding",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        sz1, sz2 = len(nums1), len(nums2)\\n        sum1, sum2 = sum(nums1), sum(nums2)\\n        req, count, heap = abs(sum1 - sum2), 0, []\\n        if sum1 > sum2:\\n            for i in range(sz1):\\n                heappush(heap, -(nums1[i] - 1))\\n            for i in range(sz2):\\n                heappush(heap, -(6 - nums2[i]))\\n        else:\\n            for i in range(sz1):\\n                heappush(heap, -(6 - nums1[i]))\\n            for i in range(sz2):\\n                heappush(heap, -(nums2[i] - 1))\\n        while heap:\\n            if req <= 0:\\n                break\\n            req -= -heappop(heap)\\n            count += 1\\n        if req > 0:\\n            return -1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        sz1, sz2 = len(nums1), len(nums2)\\n        sum1, sum2 = sum(nums1), sum(nums2)\\n        req, count, heap = abs(sum1 - sum2), 0, []\\n        if sum1 > sum2:\\n            for i in range(sz1):\\n                heappush(heap, -(nums1[i] - 1))\\n            for i in range(sz2):\\n                heappush(heap, -(6 - nums2[i]))\\n        else:\\n            for i in range(sz1):\\n                heappush(heap, -(6 - nums1[i]))\\n            for i in range(sz2):\\n                heappush(heap, -(nums2[i] - 1))\\n        while heap:\\n            if req <= 0:\\n                break\\n            req -= -heappop(heap)\\n            count += 1\\n        if req > 0:\\n            return -1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714557,
                "title": "o-n-greedy-solution-python",
                "content": "Approach is simple, always try make the largest change first.\\nYou can make two types of changes (small -> big) in nums1 or (big -> small) in nums2. Assuming sum(nums1) < sum(nums2)\\nYou have to make changes simultaneously in both nums1 and nums2 because 1->6 is just as valuable as 6->1.   \\n```\\ndef minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n    freq1 = Counter(nums1)\\n    freq2 = Counter(nums2)\\n\\n    diff = sum(nums2) - sum(nums1)\\n    if diff == 0: return 0\\n    if diff < 0:\\n        nums1, nums2 = nums2, nums1\\n        freq1, freq2 = freq2, freq1\\n        diff *= -1\\n    \\n    i = 1; j = 6\\n    operations = 0\\n    while diff and i < 6:\\n        if freq1[i]:\\n            if (6 - i)*freq1[i] < diff:\\n                diff -= (6 - i)*freq1[i]\\n                operations += freq1[i]\\n            else:\\n                operations += math.ceil(diff/(6 - i))\\n                return operations\\n        if freq2[j]:\\n            if (j - 1)*freq2[j] < diff:\\n                diff -= (j - 1)*freq2[j]\\n                operations += freq2[j]\\n            else:\\n                operations += math.ceil(diff/(j - 1))\\n                return operations\\n        \\n        i += 1; j -= 1\\n    \\n    return -1 if diff else operations\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\ndef minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n    freq1 = Counter(nums1)\\n    freq2 = Counter(nums2)\\n\\n    diff = sum(nums2) - sum(nums1)\\n    if diff == 0: return 0\\n    if diff < 0:\\n        nums1, nums2 = nums2, nums1\\n        freq1, freq2 = freq2, freq1\\n        diff *= -1\\n    \\n    i = 1; j = 6\\n    operations = 0\\n    while diff and i < 6:\\n        if freq1[i]:\\n            if (6 - i)*freq1[i] < diff:\\n                diff -= (6 - i)*freq1[i]\\n                operations += freq1[i]\\n            else:\\n                operations += math.ceil(diff/(6 - i))\\n                return operations\\n        if freq2[j]:\\n            if (j - 1)*freq2[j] < diff:\\n                diff -= (j - 1)*freq2[j]\\n                operations += freq2[j]\\n            else:\\n                operations += math.ceil(diff/(j - 1))\\n                return operations\\n        \\n        i += 1; j -= 1\\n    \\n    return -1 if diff else operations\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2709190,
                "title": "java-2ms",
                "content": "```\\npublic int minOperations(int[] nums1, int[] nums2) {\\n\\tif(nums1.length>nums2.length*6 || nums2.length>nums1.length*6) return -1;\\n\\tint delta = 0;\\n\\tfor(int i:nums1) delta-=i;\\n\\tfor(int i:nums2) delta+=i;\\n\\tif(delta == 0) return 0;\\n\\tint[] m = new int[6];\\n\\tint pDelta = Math.abs(delta);\\n\\tfor(int i:nums1) m[i-1]++;\\n\\tfor(int i:nums2) m[6-i]++;\\n\\tint count = 0;\\n\\tint i = 0;\\n\\twhile(pDelta>0){\\n\\t\\tint val = delta>0?m[i]:m[5-i];\\n\\t\\tint d = Math.min((pDelta+4-i)/(5-i), val);\\n\\t\\tpDelta-=d*(5-i);\\n\\t\\tcount+=d;\\n\\t\\ti++;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minOperations(int[] nums1, int[] nums2) {\\n\\tif(nums1.length>nums2.length*6 || nums2.length>nums1.length*6) return -1;\\n\\tint delta = 0;\\n\\tfor(int i:nums1) delta-=i;\\n\\tfor(int i:nums2) delta+=i;\\n\\tif(delta == 0) return 0;\\n\\tint[] m = new int[6];\\n\\tint pDelta = Math.abs(delta);\\n\\tfor(int i:nums1) m[i-1]++;\\n\\tfor(int i:nums2) m[6-i]++;\\n\\tint count = 0;\\n\\tint i = 0;\\n\\twhile(pDelta>0){\\n\\t\\tint val = delta>0?m[i]:m[5-i];\\n\\t\\tint d = Math.min((pDelta+4-i)/(5-i), val);\\n\\t\\tpDelta-=d*(5-i);\\n\\t\\tcount+=d;\\n\\t\\ti++;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2698113,
                "title": "c-o-n-m",
                "content": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums1, int[] nums2) {\\n        \\n        int total1= nums1.Sum();\\n        int total2= nums2.Sum();\\n        \\n        int[] allNums = new int[nums1.Length + nums2.Length];\\n        \\n        if(total1 < total2)\\n        {\\n           allNums = BalanceArray(nums1,nums2);\\n        }\\n        else\\n        {\\n          allNums =   BalanceArray(nums2, nums1);\\n        }\\n        \\n        Array.Sort(allNums);\\n        Array.Reverse(allNums);\\n        \\n        int diff = Math.Abs(total1-total2);\\n        int ans=0;\\n        for(int i=0; i< allNums.Length; i++)\\n        {\\n             if(diff <= 0)\\n                break;\\n            \\n            diff -= allNums[i];\\n            ans+=1; \\n        }\\n        return diff <=0 ?  ans:-1; \\n        \\n    }\\n    \\n    \\n    private int[] BalanceArray(int[] nums1, int[] nums2)\\n    {\\n        int[] totalNums = new int[nums1.Length+ nums2.Length];\\n        \\n        for(int i=0; i< nums1.Length; i++)\\n        {\\n            //Subtract 6-num to increase the number\\n            totalNums[i] = 6 - nums1[i];\\n        }\\n        for(int i=0 ; i< nums2.Length; i++)\\n        {\\n            //Subtract num-1 to decrease the number\\n            totalNums[i+ nums1.Length] = nums2[i] -1;\\n        }\\n        return totalNums;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums1, int[] nums2) {\\n        \\n        int total1= nums1.Sum();\\n        int total2= nums2.Sum();\\n        \\n        int[] allNums = new int[nums1.Length + nums2.Length];\\n        \\n        if(total1 < total2)\\n        {\\n           allNums = BalanceArray(nums1,nums2);\\n        }\\n        else\\n        {\\n          allNums =   BalanceArray(nums2, nums1);\\n        }\\n        \\n        Array.Sort(allNums);\\n        Array.Reverse(allNums);\\n        \\n        int diff = Math.Abs(total1-total2);\\n        int ans=0;\\n        for(int i=0; i< allNums.Length; i++)\\n        {\\n             if(diff <= 0)\\n                break;\\n            \\n            diff -= allNums[i];\\n            ans+=1; \\n        }\\n        return diff <=0 ?  ans:-1; \\n        \\n    }\\n    \\n    \\n    private int[] BalanceArray(int[] nums1, int[] nums2)\\n    {\\n        int[] totalNums = new int[nums1.Length+ nums2.Length];\\n        \\n        for(int i=0; i< nums1.Length; i++)\\n        {\\n            //Subtract 6-num to increase the number\\n            totalNums[i] = 6 - nums1[i];\\n        }\\n        for(int i=0 ; i< nums2.Length; i++)\\n        {\\n            //Subtract num-1 to decrease the number\\n            totalNums[i+ nums1.Length] = nums2[i] -1;\\n        }\\n        return totalNums;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691183,
                "title": "greedy",
                "content": "```\\nint minOperations(vector<int>& n1, vector<int>& n2)\\n{\\n\\tint m[6]{}, d{};\\n\\tfor(const auto & n : n1) ++m[n-1], d-=n;\\n\\tfor(const auto & n : n2) ++m[6-n], d+=n;\\n\\n\\tif(d<0) d=-d, reverse(begin(m), end(m));\\n\\t\\n\\tfor(int i{}, out{}; i<5; ++i)\\n\\t\\tif(int t{(5-i)*m[i]}; t<d)\\n\\t\\t\\td-=t, out+=m[i];\\n\\t\\telse\\n\\t\\t\\treturn out+(d+4-i)/(5-i);\\n\\treturn -1;  \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minOperations(vector<int>& n1, vector<int>& n2)\\n{\\n\\tint m[6]{}, d{};\\n\\tfor(const auto & n : n1) ++m[n-1], d-=n;\\n\\tfor(const auto & n : n2) ++m[6-n], d+=n;\\n\\n\\tif(d<0) d=-d, reverse(begin(m), end(m));\\n\\t\\n\\tfor(int i{}, out{}; i<5; ++i)\\n\\t\\tif(int t{(5-i)*m[i]}; t<d)\\n\\t\\t\\td-=t, out+=m[i];\\n\\t\\telse\\n\\t\\t\\treturn out+(d+4-i)/(5-i);\\n\\treturn -1;  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2683238,
                "title": "c-greedy-o-m-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\n$$O(m+n)$$ ->\\n`m` is length of array `nums1`.\\n`n` is length of array `nums2`.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int minOperations(const vector<int>& nums1, const vector<int>& nums2) {\\n        const int m = size(nums1);\\n        const int n = size(nums2);\\n        if (n > 6 * m || m > 6 * n)\\n            return -1;\\n        array<int, 6> a1{}, a2{};\\n        for (auto i : nums1) {\\n            ++a1[i - 1];\\n            ++a2[6 - i];\\n        }\\n        for (auto i : nums2) {\\n            ++a1[6 - i];\\n            ++a2[i - 1];\\n        }\\n        int diff = reduce(begin(nums1), end(nums1)) - reduce(begin(nums2), end(nums2));\\n        cout << diff << endl;\\n        int ret = 0, i = 5;\\n        while (diff)\\n            if (diff < 0) {\\n                if (i * a2[i] >= -diff)\\n                    return ret += -diff / i + !!(-diff % i);\\n                diff += i * a2[i];\\n                ret += a2[i--];\\n            } else {\\n                if (i * a1[i] >= diff)\\n                    return ret += diff / i + !!(diff % i);\\n                diff -= i * a1[i];\\n                ret += a1[i--];\\n            }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int minOperations(const vector<int>& nums1, const vector<int>& nums2) {\\n        const int m = size(nums1);\\n        const int n = size(nums2);\\n        if (n > 6 * m || m > 6 * n)\\n            return -1;\\n        array<int, 6> a1{}, a2{};\\n        for (auto i : nums1) {\\n            ++a1[i - 1];\\n            ++a2[6 - i];\\n        }\\n        for (auto i : nums2) {\\n            ++a1[6 - i];\\n            ++a2[i - 1];\\n        }\\n        int diff = reduce(begin(nums1), end(nums1)) - reduce(begin(nums2), end(nums2));\\n        cout << diff << endl;\\n        int ret = 0, i = 5;\\n        while (diff)\\n            if (diff < 0) {\\n                if (i * a2[i] >= -diff)\\n                    return ret += -diff / i + !!(-diff % i);\\n                diff += i * a2[i];\\n                ret += a2[i--];\\n            } else {\\n                if (i * a1[i] >= diff)\\n                    return ret += diff / i + !!(diff % i);\\n                diff -= i * a1[i];\\n                ret += a1[i--];\\n            }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2677877,
                "title": "java-greedy-hashmap",
                "content": "```class Solution {\\n   public int minOperations(int[] nums1, int[] nums2) {\\n        int mSum = 0, nSum = 0;\\n        for (int num1 : nums1)\\n            mSum += num1;\\n        for (int num2 : nums2)\\n            nSum += num2;\\n\\n        int diff = mSum - nSum;\\n        if (diff == 0)\\n            return 0;\\n\\n        if (diff > 0)\\n            return getMinOps(nums1, nums2, diff);\\n        else\\n            return getMinOps(nums2, nums1, -diff);\\n    }\\n\\n    private int getMinOps(int[] nums1, int[] nums2, int diff) {\\n        int[] count = new int[6];\\n        for (int num1 : nums1)\\n            count[num1-1]++;\\n        for (int num2 : nums2)\\n            count[6-num2]++;\\n\\n        int minOps = 0;\\n        for (int i=5; i>0; i--) {\\n            if (diff <= 0) break;\\n            if (diff != 0) {\\n                if (count[i] != 0) {\\n                    int tempMinOps = Math.min(count[i], diff/i + ((diff%i != 0) ? 1 : 0));\\n                    diff -= i * tempMinOps;\\n                    minOps += tempMinOps;\\n                }\\n            }\\n        }\\n        if (diff > 0)\\n            minOps = -1;\\n        return minOps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```class Solution {\\n   public int minOperations(int[] nums1, int[] nums2) {\\n        int mSum = 0, nSum = 0;\\n        for (int num1 : nums1)\\n            mSum += num1;\\n        for (int num2 : nums2)\\n            nSum += num2;\\n\\n        int diff = mSum - nSum;\\n        if (diff == 0)\\n            return 0;\\n\\n        if (diff > 0)\\n            return getMinOps(nums1, nums2, diff);\\n        else\\n            return getMinOps(nums2, nums1, -diff);\\n    }\\n\\n    private int getMinOps(int[] nums1, int[] nums2, int diff) {\\n        int[] count = new int[6];\\n        for (int num1 : nums1)\\n            count[num1-1]++;\\n        for (int num2 : nums2)\\n            count[6-num2]++;\\n\\n        int minOps = 0;\\n        for (int i=5; i>0; i--) {\\n            if (diff <= 0) break;\\n            if (diff != 0) {\\n                if (count[i] != 0) {\\n                    int tempMinOps = Math.min(count[i], diff/i + ((diff%i != 0) ? 1 : 0));\\n                    diff -= i * tempMinOps;\\n                    minOps += tempMinOps;\\n                }\\n            }\\n        }\\n        if (diff > 0)\\n            minOps = -1;\\n        return minOps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668141,
                "title": "easy-sort-2pointer-approach",
                "content": "Steps:\\n1: Calculate sum of both nums\\n2: Check if possible by size conditionality\\n3: sort both arrays\\n4:POINTER i=0 at array with less sum\\n5:POINTER  j= array.size() -1  with more sum\\n6: KEEP CHECKING which to (increase to 6 in less sum array) or (which to decrease in more sum array)\\nCODE:\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int sum1=0,sum2=0;\\n        \\n        for(int i=0;i<nums1.size();i++) sum1+=nums1[i];\\n        for(int i=0;i<nums2.size();i++) sum2+=nums2[i];\\n        \\n        if(sum1==sum2)\\n            return 0;\\n\\n        \\n        int m=nums1.size();\\n        int n=nums2.size();\\n        \\n        if(m!=n){\\n            int a = max(m,n);\\n            int b = min(m,n);\\n            if(b*6<a){\\n                return -1;\\n            }\\n        }\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        \\n        if(sum2<sum1)  swap(nums1,nums2),swap(sum2,sum1);\\n        \\n        int i=0;\\n        int j=nums2.size()-1;\\n        int c=0;\\n        \\n        while(sum1<sum2){\\n            if(j<0 || i<nums1.size() && 6-nums1[i]>nums2[j]-1){\\n                sum1+= 6-nums1[i++];\\n            }else\\n                sum2-= nums2[j--]-1;\\n            c++;\\n        }\\n        \\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int sum1=0,sum2=0;\\n        \\n        for(int i=0;i<nums1.size();i++) sum1+=nums1[i];\\n        for(int i=0;i<nums2.size();i++) sum2+=nums2[i];\\n        \\n        if(sum1==sum2)\\n            return 0;\\n\\n        \\n        int m=nums1.size();\\n        int n=nums2.size();\\n        \\n        if(m!=n){\\n            int a = max(m,n);\\n            int b = min(m,n);\\n            if(b*6<a){\\n                return -1;\\n            }\\n        }\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        \\n        if(sum2<sum1)  swap(nums1,nums2),swap(sum2,sum1);\\n        \\n        int i=0;\\n        int j=nums2.size()-1;\\n        int c=0;\\n        \\n        while(sum1<sum2){\\n            if(j<0 || i<nums1.size() && 6-nums1[i]>nums2[j]-1){\\n                sum1+= 6-nums1[i++];\\n            }else\\n                sum2-= nums2[j--]-1;\\n            c++;\\n        }\\n        \\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657015,
                "title": "c-greedy-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a1, vector<int>& a2) {\\n        \\n        int m=a1.size();\\n        int n=a2.size();\\n//         if(m<n && m*6<n)return -1;\\n//         if(n<m && n*6<m)return -1;\\n        int s1=0;\\n        int s2=0;\\n        \\n        for(int i=0;i<m;i++){\\n            s1+=a1[i];\\n        }\\n        for(int i=0;i<n;i++){\\n            s2+=a2[i];\\n        }\\n        if(s1==s2)return 0;\\n        \\n        \\n        if(s1<s2){\\n            swap(s1,s2); swap(a1,a2);\\n        }\\n        int diff=s1-s2;\\n        vector<int>v;\\n        \\n        for(auto &i:a1){\\n            v.push_back(i-1);\\n        }\\n        for(auto &i: a2){\\n            v.push_back(6-i);\\n        }\\n        sort(v.begin(),v.end(),greater<int>());\\n        \\n        int cnt=0;\\n        for(int i=0;i<v.size();i++){\\n            diff-=v[i];\\n            cnt++;\\n            if(diff<=0)return cnt;\\n        }\\n        \\n       return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a1, vector<int>& a2) {\\n        \\n        int m=a1.size();\\n        int n=a2.size();\\n//         if(m<n && m*6<n)return -1;\\n//         if(n<m && n*6<m)return -1;\\n        int s1=0;\\n        int s2=0;\\n        \\n        for(int i=0;i<m;i++){\\n            s1+=a1[i];\\n        }\\n        for(int i=0;i<n;i++){\\n            s2+=a2[i];\\n        }\\n        if(s1==s2)return 0;\\n        \\n        \\n        if(s1<s2){\\n            swap(s1,s2); swap(a1,a2);\\n        }\\n        int diff=s1-s2;\\n        vector<int>v;\\n        \\n        for(auto &i:a1){\\n            v.push_back(i-1);\\n        }\\n        for(auto &i: a2){\\n            v.push_back(6-i);\\n        }\\n        sort(v.begin(),v.end(),greater<int>());\\n        \\n        int cnt=0;\\n        for(int i=0;i<v.size();i++){\\n            diff-=v[i];\\n            cnt++;\\n            if(diff<=0)return cnt;\\n        }\\n        \\n       return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654997,
                "title": "c-greedy-solution-easy-commented",
                "content": "```\\n  int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0,sum2=0;\\n        priority_queue<int> pq;\\n        for(auto it: nums1){\\n            sum1+=it;\\n        }\\n        for(auto it: nums2){\\n            sum2+=it;\\n        }\\n        if(sum1>sum2){           //storing the array with greater sum in nums2\\n            swap(sum1,sum2);\\n            swap(nums1,nums2);\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            pq.push(nums2[i]-1);   // max change in points that can be brought in greater sum array....-1 because numbers are between 1 to 6\\n        }\\n        for(int i=0;i<nums1.size();i++){\\n            pq.push(6-nums1[i]);   // max change in points that can be brought in less sum array....6- because numbers are between 1 to 6\\n        }\\n        int diff=sum2-sum1;\\n        int count=0;\\n        while(diff>0 && pq.size()){\\n            count++;\\n            diff-=pq.top();\\n            pq.pop();\\n        }\\n        if(diff>0){\\n            return -1;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n  int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0,sum2=0;\\n        priority_queue<int> pq;\\n        for(auto it: nums1){\\n            sum1+=it;\\n        }\\n        for(auto it: nums2){\\n            sum2+=it;\\n        }\\n        if(sum1>sum2){           //storing the array with greater sum in nums2\\n            swap(sum1,sum2);\\n            swap(nums1,nums2);\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            pq.push(nums2[i]-1);   // max change in points that can be brought in greater sum array....-1 because numbers are between 1 to 6\\n        }\\n        for(int i=0;i<nums1.size();i++){\\n            pq.push(6-nums1[i]);   // max change in points that can be brought in less sum array....6- because numbers are between 1 to 6\\n        }\\n        int diff=sum2-sum1;\\n        int count=0;\\n        while(diff>0 && pq.size()){\\n            count++;\\n            diff-=pq.top();\\n            pq.pop();\\n        }\\n        if(diff>0){\\n            return -1;\\n        }\\n        return count;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2654070,
                "title": "java-greedy-some-comments",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int m=nums2.length;\\n        if(n*6<m||m*6<n)return -1;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int x:nums1)\\n            sum1+=x;\\n        for(int x:nums2)\\n            sum2+=x;\\n        if(sum1>sum2)\\n            return minOperations(nums2,nums1);\\n           Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int operations=0;\\n        int i=0,j=m-1;\\n        while(sum2>sum1){\\n            //we have recahed the end of nums 2\\n            //or if the new number to be entered in nums1 is greater than nums2[j]-1 only then we increment sum1 by 6-nums1[i]\\n            //otherwise we keep decrementing sum2 by nums2[j]-1\\n            //in ohter words increment in sum1 is greater than decrement in sum2\\n            //only then we increment sum1\\n            if(j<0 ||( i<n && 6-nums1[i]>(nums2[j]-1))){\\n               // System.out.println(nums1[i]+ \" \"+nums2[j]);\\n                sum1=sum1+(6-nums1[i++]);\\n            }\\n            else\\n            {\\n                sum2=sum2-nums2[j--]+1;//de crementing sums2 by nums2[j]-1\\n            }\\n            operations++;\\n        }\\n        return operations;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int m=nums2.length;\\n        if(n*6<m||m*6<n)return -1;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int x:nums1)\\n            sum1+=x;\\n        for(int x:nums2)\\n            sum2+=x;\\n        if(sum1>sum2)\\n            return minOperations(nums2,nums1);\\n           Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int operations=0;\\n        int i=0,j=m-1;\\n        while(sum2>sum1){\\n            //we have recahed the end of nums 2\\n            //or if the new number to be entered in nums1 is greater than nums2[j]-1 only then we increment sum1 by 6-nums1[i]\\n            //otherwise we keep decrementing sum2 by nums2[j]-1\\n            //in ohter words increment in sum1 is greater than decrement in sum2\\n            //only then we increment sum1\\n            if(j<0 ||( i<n && 6-nums1[i]>(nums2[j]-1))){\\n               // System.out.println(nums1[i]+ \" \"+nums2[j]);\\n                sum1=sum1+(6-nums1[i++]);\\n            }\\n            else\\n            {\\n                sum2=sum2-nums2[j--]+1;//de crementing sums2 by nums2[j]-1\\n            }\\n            operations++;\\n        }\\n        return operations;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649173,
                "title": "c",
                "content": "Runtime: 261 ms, faster than 100.00% of C online submissions for Equal Sum Arrays With Minimum Number of Operations.\\nMemory Usage: 14.1 MB, less than 100.00% of C online submissions for Equal Sum Arrays With Minimum Number of Operations.\\n```\\nint minOperations(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    if(nums1Size > nums2Size && nums1Size > nums2Size * 6)\\n        return -1;\\n    if(nums2Size > nums1Size && nums2Size > nums1Size * 6)\\n        return -1;\\n\\n    int* hash1 = calloc(7 , sizeof(int));\\n    int* hash2 = calloc(7 , sizeof(int));\\n    int sum1 = 0, sum2 = 0;\\n    for(int i = 0; i < nums1Size; i++){\\n        sum1 += nums1[i];\\n        hash1[nums1[i]]++;\\n    }\\n    for(int i = 0; i < nums2Size; i++){\\n        sum2 += nums2[i];\\n        hash2[nums2[i]]++;\\n    }\\n    int diff = abs(sum1 - sum2);\\n    if(diff == 0)\\n        return 0;\\n    \\n    int* temp1;\\n    int* temp2;\\n    if(sum1 > sum2){\\n        temp1 = hash1;\\n        temp2 = hash2;\\n    }\\n    else{\\n        temp1 = hash2;\\n        temp2 = hash1;\\n    }\\n    \\n    int OP = 0;\\n    int k = 1;\\n    while(diff > 0){\\n        if(temp1[7-k] > 0){\\n            int a = ceil(1.0 *diff/(6-k));\\n            if(temp1[7-k] >=a){\\n                temp1[7-k] -=a;\\n                OP +=a;\\n                diff -= a*(6-k);\\n            }\\n            else{\\n                diff -= temp1[7-k] *(6-k);\\n                OP += temp1[7-k];\\n                temp1[7-k] = 0;\\n            }\\n            continue;\\n        }\\n        else if(temp2[k] > 0){\\n            int b = ceil(1.0 *diff/(6-k));\\n            if(temp2[k] >=b){\\n                temp2[k] -=b;\\n                OP +=b;\\n                diff -= b*(6-k);\\n            }\\n            else{\\n                diff -= temp2[k] *(6-k);\\n                OP += temp2[k];\\n                temp2[k] = 0;\\n            }            \\n            continue;\\n        }\\n        else\\n            k++;\\n    }\\n    \\n    return OP;\\n\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nint minOperations(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    if(nums1Size > nums2Size && nums1Size > nums2Size * 6)\\n        return -1;\\n    if(nums2Size > nums1Size && nums2Size > nums1Size * 6)\\n        return -1;\\n\\n    int* hash1 = calloc(7 , sizeof(int));\\n    int* hash2 = calloc(7 , sizeof(int));\\n    int sum1 = 0, sum2 = 0;\\n    for(int i = 0; i < nums1Size; i++){\\n        sum1 += nums1[i];\\n        hash1[nums1[i]]++;\\n    }\\n    for(int i = 0; i < nums2Size; i++){\\n        sum2 += nums2[i];\\n        hash2[nums2[i]]++;\\n    }\\n    int diff = abs(sum1 - sum2);\\n    if(diff == 0)\\n        return 0;\\n    \\n    int* temp1;\\n    int* temp2;\\n    if(sum1 > sum2){\\n        temp1 = hash1;\\n        temp2 = hash2;\\n    }\\n    else{\\n        temp1 = hash2;\\n        temp2 = hash1;\\n    }\\n    \\n    int OP = 0;\\n    int k = 1;\\n    while(diff > 0){\\n        if(temp1[7-k] > 0){\\n            int a = ceil(1.0 *diff/(6-k));\\n            if(temp1[7-k] >=a){\\n                temp1[7-k] -=a;\\n                OP +=a;\\n                diff -= a*(6-k);\\n            }\\n            else{\\n                diff -= temp1[7-k] *(6-k);\\n                OP += temp1[7-k];\\n                temp1[7-k] = 0;\\n            }\\n            continue;\\n        }\\n        else if(temp2[k] > 0){\\n            int b = ceil(1.0 *diff/(6-k));\\n            if(temp2[k] >=b){\\n                temp2[k] -=b;\\n                OP +=b;\\n                diff -= b*(6-k);\\n            }\\n            else{\\n                diff -= temp2[k] *(6-k);\\n                OP += temp2[k];\\n                temp2[k] = 0;\\n            }            \\n            continue;\\n        }\\n        else\\n            k++;\\n    }\\n    \\n    return OP;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2637826,
                "title": "python-o-n-solution-easy-understanding",
                "content": "In this problem, the only thing we need to do is to shrink the difference of the sum of array. After we make sure which one is bigger we can start to do operations with the most valuable element (the biggest step to shrink the distance). Notice that we can directly return -1 if there is no way to make the longer array to have the same sum with the shorter array.\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        min_arr_size = len(nums1) if len(nums1)< len(nums2) else len(nums2)\\n        max_arr_size = len(nums1) if len(nums1)>= len(nums2) else len(nums2)\\n        \\n        # return -1 , if the biggest sum of shorter array is smaller than the smallest sum of longer one\\n        if min_arr_size*6 < max_arr_size: \\n            return -1\\n        \\n        nums1_sum = sum(nums1)\\n        nums2_sum = sum(nums2)\\n        dis = abs(nums1_sum- nums2_sum)\\n        \\n        \\n        # calculate each step size\\n        steps = []\\n        if nums1_sum > nums2_sum:\\n            steps += [i-1 for i in nums1] + [6-i for i in nums2]\\n        else:\\n            steps += [i-1 for i in nums2] + [6-i for i in nums1]\\n            \\n        # need to do operation from the biggest step\\n        steps.sort(reverse = True)\\n        \\n        cnt = 0\\n        while dis > 0:\\n            dis -= steps[cnt]\\n            cnt+=1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        min_arr_size = len(nums1) if len(nums1)< len(nums2) else len(nums2)\\n        max_arr_size = len(nums1) if len(nums1)>= len(nums2) else len(nums2)\\n        \\n        # return -1 , if the biggest sum of shorter array is smaller than the smallest sum of longer one\\n        if min_arr_size*6 < max_arr_size: \\n            return -1\\n        \\n        nums1_sum = sum(nums1)\\n        nums2_sum = sum(nums2)\\n        dis = abs(nums1_sum- nums2_sum)\\n        \\n        \\n        # calculate each step size\\n        steps = []\\n        if nums1_sum > nums2_sum:\\n            steps += [i-1 for i in nums1] + [6-i for i in nums2]\\n        else:\\n            steps += [i-1 for i in nums2] + [6-i for i in nums1]\\n            \\n        # need to do operation from the biggest step\\n        steps.sort(reverse = True)\\n        \\n        cnt = 0\\n        while dis > 0:\\n            dis -= steps[cnt]\\n            cnt+=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617328,
                "title": "c-o-nlgn-simple-to-understand",
                "content": "Greedily pick max change that can be done \\n(6 - t) -> Max change that can be increased\\n(t - 1) -> Max change that can be decreased\\n\\n```\\nint minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int s1 = accumulate(nums1.begin(),nums1.end(), s1);\\n        int s2 = accumulate(nums2.begin(),nums2.end(), s2);\\n        \\n        if (s1 == s2) return 0;\\n        if (s1 > s2) {\\n            swap(s1,s2); swap(nums1,nums2);\\n        }\\n        int diff = s2 - s1, ans = 0;\\n        vector<int> A;\\n        for (int &t: nums1) A.push_back(6 - t);\\n        for (int &t: nums2) A.push_back(t - 1);\\n        sort(A.rbegin(),A.rend());\\n        for (int &x : A) {\\n            diff -= x;\\n            ++ans;\\n            if (diff <= 0) return ans;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int s1 = accumulate(nums1.begin(),nums1.end(), s1);\\n        int s2 = accumulate(nums2.begin(),nums2.end(), s2);\\n        \\n        if (s1 == s2) return 0;\\n        if (s1 > s2) {\\n            swap(s1,s2); swap(nums1,nums2);\\n        }\\n        int diff = s2 - s1, ans = 0;\\n        vector<int> A;\\n        for (int &t: nums1) A.push_back(6 - t);\\n        for (int &t: nums2) A.push_back(t - 1);\\n        sort(A.rbegin(),A.rend());\\n        for (int &x : A) {\\n            diff -= x;\\n            ++ans;\\n            if (diff <= 0) return ans;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607584,
                "title": "rust-using-binaryheap",
                "content": "~~~\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn min_operations(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        let a: i32 = nums1.iter().map(|&x| x as i32).sum();\\n        let b = nums2.iter().map(|&x| x as i32).sum();\\n        if (a < b) { return Self::min_operations(nums2, nums1); }\\n        \\n        let mut pq = BinaryHeap::new();\\n        let mut amt = a - b;\\n        \\n        for n in nums1 {\\n            if n > 1 { pq.push(n - 1); }\\n        }\\n        \\n        for n in nums2 {\\n            if n < 6 { pq.push(6 - n); }\\n        }\\n        \\n        let mut ret = 0;\\n        while amt > 0 && pq.is_empty() == false {\\n            amt -= pq.pop().unwrap();\\n            ret += 1;\\n        }\\n        \\n        if amt > 0 { return -1 }\\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn min_operations(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        let a: i32 = nums1.iter().map(|&x| x as i32).sum();\\n        let b = nums2.iter().map(|&x| x as i32).sum();\\n        if (a < b) { return Self::min_operations(nums2, nums1); }\\n        \\n        let mut pq = BinaryHeap::new();\\n        let mut amt = a - b;\\n        \\n        for n in nums1 {\\n            if n > 1 { pq.push(n - 1); }\\n        }\\n        \\n        for n in nums2 {\\n            if n < 6 { pq.push(6 - n); }\\n        }\\n        \\n        let mut ret = 0;\\n        while amt > 0 && pq.is_empty() == false {\\n            amt -= pq.pop().unwrap();\\n            ret += 1;\\n        }\\n        \\n        if amt > 0 { return -1 }\\n        ret\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2597678,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0,sum2=0;\\n        int size1=nums1.size();\\n        int size2=nums2.size();\\n        for(auto n:nums1)\\n            sum1+=n;\\n        for(auto n:nums2)\\n            sum2+=n;\\n        if(sum1>sum2)return minOper(nums1,nums2,sum1-sum2);\\n        return minOper(nums2,nums1,sum2-sum1);\\n        \\n    }\\n    int minOper(vector<int>& nums1, vector<int>& nums2,int res) {\\n        sort(nums1.begin(),nums1.end(),greater<int>());\\n        sort(nums2.begin(),nums2.end());\\n        int left=0;\\n        int right=0;\\n        int count=0;\\n        while(left<nums1.size()||right<nums2.size())\\n        {\\n            if(res<=0)break;\\n            if(left>=nums1.size())res-=6-nums2[right++];\\n            else if(right>=nums2.size())res-=nums1[left++]-1;\\n            else if(nums1[left]-1>6-nums2[right])\\n                res-=nums1[left++]-1;\\n            else \\n                res-=6-nums2[right++];\\n            count++;   \\n        }\\n        return res>0?-1:count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0,sum2=0;\\n        int size1=nums1.size();\\n        int size2=nums2.size();\\n        for(auto n:nums1)\\n            sum1+=n;\\n        for(auto n:nums2)\\n            sum2+=n;\\n        if(sum1>sum2)return minOper(nums1,nums2,sum1-sum2);\\n        return minOper(nums2,nums1,sum2-sum1);\\n        \\n    }\\n    int minOper(vector<int>& nums1, vector<int>& nums2,int res) {\\n        sort(nums1.begin(),nums1.end(),greater<int>());\\n        sort(nums2.begin(),nums2.end());\\n        int left=0;\\n        int right=0;\\n        int count=0;\\n        while(left<nums1.size()||right<nums2.size())\\n        {\\n            if(res<=0)break;\\n            if(left>=nums1.size())res-=6-nums2[right++];\\n            else if(right>=nums2.size())res-=nums1[left++]-1;\\n            else if(nums1[left]-1>6-nums2[right])\\n                res-=nums1[left++]-1;\\n            else \\n                res-=6-nums2[right++];\\n            count++;   \\n        }\\n        return res>0?-1:count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579104,
                "title": "easy-c-solution",
                "content": "First we will sort both the vectors.Than we will store the sum of all the elements of the vector and now we will do out calculations.\\n\\nWe will main two pointers.One will point to the last element of that vector whose sum is greater and the one will point to the fast element of that vector whose sum is less.Now we will try to reduce the number of that vector whose sum is larger and we will try to increase the sum of that vector whose sum is  smaller.\\n\\nWe can increase the number to maximum 6 and we can decrease the number to minimum 1.\\n\\nSuppose nums1 sum is greater than nums2 sum.\\nLet  \\nd1=nums1[i]-1;\\nd2=6-nums2[j];\\nAs we try to minimise our operation we wil decrement only those pointer whose difference is more.\\n\\nSuppose if d1>d2 we will decrement i and replace that element with 1.\\n\\nSuppose if d2>d1 we will increase j and replace that number with 6.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums1,vector<int>&nums2,int s1,int s2)\\n    {\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int cnt=0;\\n        if(n1>6*n2) return -1;\\n        else\\n        {\\n            int diff=abs(s1-s2);\\n            int i=n1-1,j=0;\\n            while(i>=0 or j<n2)\\n            {\\n                int d1=-1,d2=-1;\\n                \\n                if(i>=0)\\n                {\\n                    d1=abs(nums1[i]-1);\\n                }\\n                if(j<n2)\\n                {\\n                    d2=abs(6-nums2[j]);\\n                }\\n                if(s1<=s2) break;\\n                if(d1>=d2)\\n                {\\n                    s1=s1-nums1[i]+1;\\n                    i--;\\n                }\\n                else if(d1<d2)\\n                {\\n                    s2=s2-nums2[j]+6;\\n                    j++;\\n                    \\n                }\\n                cnt++;\\n            }\\n            return cnt;\\n            \\n        }\\n    }\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int s1=0,s2=0;\\n        for(auto i:nums1) s1+=i;\\n        for(auto i:nums2) s2+=i;\\n        if(s1==s2) return 0;\\n        else if(s1>s2)\\n        {\\n            return solve(nums1,nums2,s1,s2);\\n        }\\n        else return solve(nums2,nums1,s2,s1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int solve(vector<int>&nums1,vector<int>&nums2,int s1,int s2)\\n    {\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        int cnt=0;\\n        if(n1>6*n2) return -1;\\n        else\\n        {\\n            int diff=abs(s1-s2);\\n            int i=n1-1,j=0;\\n            while(i>=0 or j<n2)\\n            {\\n                int d1=-1,d2=-1;\\n                \\n                if(i>=0)\\n                {\\n                    d1=abs(nums1[i]-1);\\n                }\\n                if(j<n2)\\n                {\\n                    d2=abs(6-nums2[j]);\\n                }\\n                if(s1<=s2) break;\\n                if(d1>=d2)\\n                {\\n                    s1=s1-nums1[i]+1;\\n                    i--;\\n                }\\n                else if(d1<d2)\\n                {\\n                    s2=s2-nums2[j]+6;\\n                    j++;\\n                    \\n                }\\n                cnt++;\\n            }\\n            return cnt;\\n            \\n        }\\n    }\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int s1=0,s2=0;\\n        for(auto i:nums1) s1+=i;\\n        for(auto i:nums2) s2+=i;\\n        if(s1==s2) return 0;\\n        else if(s1>s2)\\n        {\\n            return solve(nums1,nums2,s1,s2);\\n        }\\n        else return solve(nums2,nums1,s2,s1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554202,
                "title": "python3-priority-queue-o-nlogn",
                "content": "lets say sum difference is S . In 1 operation , either we can increase array element by maximum 5 or decrease array element by 5. We will decrease array element from array having bigger sum and increase array element from array having smaller sum until S becomes 0. Now we will reduce those element first which gives bigger difference after decreasing like 6 to 1. and similarly increase those element first which will give bigger difference like 1 to 6 so that we require minimum operations to make S=0. We will use max-heap to pop out max element first.\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1)>6*len(nums2) or len(nums2)>6*len(nums1):\\n            return -1\\n        s1,s2=sum(nums1),sum(nums2)\\n        pq=[]\\n        cnt=0\\n        if s1==s2:\\n            return cnt\\n        if s1<s2:\\n            nums1,nums2=nums2,nums1\\n            s1,s2=s2,s1\\n        diff=s1-s2\\n        for v in nums1:\\n            heappush(pq,-(v-1))\\n        for v in nums2:\\n            heappush(pq,-(6-v))\\n        while diff>0:\\n            curr=heappop(pq)\\n            diff-=-curr\\n            cnt+=1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1)>6*len(nums2) or len(nums2)>6*len(nums1):\\n            return -1\\n        s1,s2=sum(nums1),sum(nums2)\\n        pq=[]\\n        cnt=0\\n        if s1==s2:\\n            return cnt\\n        if s1<s2:\\n            nums1,nums2=nums2,nums1\\n            s1,s2=s2,s1\\n        diff=s1-s2\\n        for v in nums1:\\n            heappush(pq,-(v-1))\\n        for v in nums2:\\n            heappush(pq,-(6-v))\\n        while diff>0:\\n            curr=heappop(pq)\\n            diff-=-curr\\n            cnt+=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553537,
                "title": "c-greedy",
                "content": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums1, int[] nums2) {\\n\\n        int[] table1 = new int[7];\\n        int[] table2 = new int[7];\\n\\n        foreach (int x in nums1){\\n            table1[x]++;\\n        }\\n        foreach (int x in nums2){\\n            table2[x]++;\\n        }\\n\\n        int total1 = 0;\\n        int total2 = 0;\\n        for(int i=1; i<7; i++){\\n            total1 += (table1[i] * i);\\n            total2 += (table2[i] * i);\\n        }\\n\\n        if(total1 > total2){\\n            return CountOperations(total1-total2, table2, table1);\\n        }\\n\\n        return CountOperations(total2-total1, table1, table2);\\n    }\\n\\n    private int CountOperations(int d, int[] tableA, int[] tableB){\\n\\n        int ans = 0;\\n        for(int i=0; i<5; i++){\\n            int delta = 5-i;\\n            int needed = (d+delta-1)/delta;\\n            int count = Math.Min(needed, tableA[1+i] + tableB[6-i]);\\n            ans += count;\\n            d -= delta * count;\\n            if(d<=0){\\n                return ans;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums1, int[] nums2) {\\n\\n        int[] table1 = new int[7];\\n        int[] table2 = new int[7];\\n\\n        foreach (int x in nums1){\\n            table1[x]++;\\n        }\\n        foreach (int x in nums2){\\n            table2[x]++;\\n        }\\n\\n        int total1 = 0;\\n        int total2 = 0;\\n        for(int i=1; i<7; i++){\\n            total1 += (table1[i] * i);\\n            total2 += (table2[i] * i);\\n        }\\n\\n        if(total1 > total2){\\n            return CountOperations(total1-total2, table2, table1);\\n        }\\n\\n        return CountOperations(total2-total1, table1, table2);\\n    }\\n\\n    private int CountOperations(int d, int[] tableA, int[] tableB){\\n\\n        int ans = 0;\\n        for(int i=0; i<5; i++){\\n            int delta = 5-i;\\n            int needed = (d+delta-1)/delta;\\n            int count = Math.Min(needed, tableA[1+i] + tableB[6-i]);\\n            ans += count;\\n            d -= delta * count;\\n            if(d<=0){\\n                return ans;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551573,
                "title": "python-explained-commented-practice-using-deque-greedy-solution",
                "content": "The only reason I used a deque was because using array copy array[1:] resulted in memory limit.  \\n\\nThe first thing I thought about was... what if the numbers were sorted? Because relative ordering does not matter for this problem\\n\\nObservations:\\narray = [1,1,1,1,1,1,4]  [4, 4, 4, 4, 4]\\nsum =     10                 20\\n\\nIn this case, we know that sum1 < sum2 (10 < 20)\\nTherefore we have 3 options:\\n1) **increase** the 1 from array1 to a 6 -> [6,1,1,1,1,1,4] [4,4,4,4,4] -> maxIncrease = 5\\n2) **Decrease** the 4 from array2 to a 1 -> [1,1,1,1,1,1,4] [4,4,4,4,1] -> maxDecrease = 3\\n3) base case (more obvious in code)\\n\\nThis is a greedy problem. It is best to select that which results in getting us *closer* and *closer* to equillibrium. \\n\\nNow what happens is recursion... all the work above was only for **one** operation.\\nYou need to do something like this where the 1 represents 1 operation:\\n\\nSolve() could return -1, 0, or however many operations remain... \\n```\\nreturn 1 + solve(newNums1, newNums2, newSum1, newSum2)\\n```\\n\\nWhat happens next is we solve for smaller subproblems. More specifically, we ask:\\nNow that we\\'ve converted the array to \\n[6,1,1,1,1,1,4] [4,4,4,4,4], we ask the **same** question:\\n1) We are now **closer** to equality, *sum1 = 10 + 5 sum2 = 20*\\n2) Should we **increase** the 1 from array1 to a 6 or **decrease** the 4 from array2 to a 1?\\n\\n^^ this should result in [6,6,1,1,1,1,4] [4,4,4,4,4], which is equal. We probably would have some sort of base case that checks if jumping results in equality and terminate our function. \\n\\nNow I write the function definitions and implementation. It\\'s going to look something like this:\\n**solve(array1, array2, sum1, sum2)**\\n\\nTo gaurantee that sum1 is less than sum2, (it just makes life so much easier), there is a trick inside my code: we just reverse the arguments when needed\\n```\\n    if sum1 > sum2:\\n        return process(nums2, nums1, sum2, sum1)\\n```\\n\\nAlgorithm:\\n1) pick two options. a) **increase** the smallest number to 6 or b) **decrease** the largest number to a 1. In my code, I just create two variables,\\n ```maxIncrease = 6 - nums1[0]``` *remember: sum1 < sum2 therefore we will always try to **increase** the **smallest** number of **nums1*** \\n```maxDecrease = nums2[-1] - 1```\\nAnd then after defining the two variables, I just add an if statement of whichever is bigger\\n2) recursively find operations for future states\\nFor example, if we decidede to **increase** the smallest number by 4, we should say ```sum1 += 4```\\nAnd ```nums1.popleft()```  because in our future recursive code, it uses ```nums1[0]```, (zero-index) for simplicity.\\nThe other cases are obvious if you understand this case. \\n\\nSolution:\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        deque1 = collections.deque(sorted(nums1)) # sort initially\\n        deque2 = collections.deque(sorted(nums2)) # sort initially deque for popleft()\\n        print(deque1, deque2)\\n        if abs(sum(nums1) - sum(nums2)) == 0:\\n            return 0\\n        return process(deque1, deque2, sum(deque1), sum(deque2))\\n        \\ndef process(nums1, nums2, sum1, sum2):\\n    # print(f\\'nums1={nums1}, nums2={nums2}, sum1={sum1}, sum2={sum2}\\')\\n    if sum1 > sum2:\\n        return process(nums2, nums1, sum2, sum1)\\n    if not nums1 and not nums2:\\n        # this will happen if no solutions exist... \\n        return -1\\n    \\n    # edge case: if either of the arrays are empty, then I use else -1 to basically say \\n    # \"hey ignore me\"\\n    # if maxIncrease is -1, then maxDecrease is ALWAYS > maxIncrease, vice versa.\\n    maxIncrease = 6 - nums1[0] if nums1 else -1\\n    maxDecrease = nums2[-1] - 1 if nums2 else -1\\n    distance = abs(sum2 - sum1) # how close are we?\\n    if maxIncrease >= distance or maxDecrease >= distance:\\n        # if we can jump to here, just return 1 for one operation\\n        return 1\\n    if maxIncrease > maxDecrease:\\n        # if increasing the smallest number is better, then do so. Update the states. \\n        sum1 += maxIncrease\\n        nums1.popleft()\\n        works = process(nums1, nums2, sum1, sum2)\\n        return (1 + works) if works > -1 else -1 # if no operations were found, recursively return -1\\n    else:\\n        sum2 -= maxDecrease\\n        nums2.pop()\\n        works = process(nums1, nums2, sum1, sum2)\\n        return (1 + works) if works > -1 else -1\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nreturn 1 + solve(newNums1, newNums2, newSum1, newSum2)\\n```\n```\\n    if sum1 > sum2:\\n        return process(nums2, nums1, sum2, sum1)\\n```\n```maxIncrease = 6 - nums1[0]```\n```maxDecrease = nums2[-1] - 1```\n```sum1 += 4```\n```nums1.popleft()```\n```nums1[0]```\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        deque1 = collections.deque(sorted(nums1)) # sort initially\\n        deque2 = collections.deque(sorted(nums2)) # sort initially deque for popleft()\\n        print(deque1, deque2)\\n        if abs(sum(nums1) - sum(nums2)) == 0:\\n            return 0\\n        return process(deque1, deque2, sum(deque1), sum(deque2))\\n        \\ndef process(nums1, nums2, sum1, sum2):\\n    # print(f\\'nums1={nums1}, nums2={nums2}, sum1={sum1}, sum2={sum2}\\')\\n    if sum1 > sum2:\\n        return process(nums2, nums1, sum2, sum1)\\n    if not nums1 and not nums2:\\n        # this will happen if no solutions exist... \\n        return -1\\n    \\n    # edge case: if either of the arrays are empty, then I use else -1 to basically say \\n    # \"hey ignore me\"\\n    # if maxIncrease is -1, then maxDecrease is ALWAYS > maxIncrease, vice versa.\\n    maxIncrease = 6 - nums1[0] if nums1 else -1\\n    maxDecrease = nums2[-1] - 1 if nums2 else -1\\n    distance = abs(sum2 - sum1) # how close are we?\\n    if maxIncrease >= distance or maxDecrease >= distance:\\n        # if we can jump to here, just return 1 for one operation\\n        return 1\\n    if maxIncrease > maxDecrease:\\n        # if increasing the smallest number is better, then do so. Update the states. \\n        sum1 += maxIncrease\\n        nums1.popleft()\\n        works = process(nums1, nums2, sum1, sum2)\\n        return (1 + works) if works > -1 else -1 # if no operations were found, recursively return -1\\n    else:\\n        sum2 -= maxDecrease\\n        nums2.pop()\\n        works = process(nums1, nums2, sum1, sum2)\\n        return (1 + works) if works > -1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497719,
                "title": "simple-c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int Helper(vector<int>& greater, vector<int>& smaller, int diff) {\\n        int s = 0, g = greater.size()-1;\\n        int step = 0;\\n        while ((g >= 0 || s < smaller.size()) && diff != 0) {            \\n            int maxCanDecrease = g >= 0 ? greater[g] - 1 : 0;\\n            int maxCanIncrease = s < smaller.size() ? 6 - smaller[s] : 0;\\n            \\n            int decrease = min(maxCanDecrease, diff);\\n            int increase = min(maxCanIncrease, diff);\\n            if (decrease == 0 && increase == 0) break;\\n            \\n            if (decrease > increase) {\\n                diff -= decrease;\\n                g--;\\n            } else {\\n                diff -= increase;\\n                s++;\\n            }\\n            step++;\\n        }\\n        \\n        return diff == 0 ? step : -1;\\n    }\\n    \\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        int sum1 = 0, sum2 = 0; \\n        for (int n: nums1) sum1+=n;\\n        for (int n: nums2) sum2+=n;\\n        if (sum1 > sum2) return Helper(nums1, nums2, sum1 - sum2);\\n        return Helper(nums2, nums1, sum2 - sum1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int Helper(vector<int>& greater, vector<int>& smaller, int diff) {\\n        int s = 0, g = greater.size()-1;\\n        int step = 0;\\n        while ((g >= 0 || s < smaller.size()) && diff != 0) {            \\n            int maxCanDecrease = g >= 0 ? greater[g] - 1 : 0;\\n            int maxCanIncrease = s < smaller.size() ? 6 - smaller[s] : 0;\\n            \\n            int decrease = min(maxCanDecrease, diff);\\n            int increase = min(maxCanIncrease, diff);\\n            if (decrease == 0 && increase == 0) break;\\n            \\n            if (decrease > increase) {\\n                diff -= decrease;\\n                g--;\\n            } else {\\n                diff -= increase;\\n                s++;\\n            }\\n            step++;\\n        }\\n        \\n        return diff == 0 ? step : -1;\\n    }\\n    \\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        int sum1 = 0, sum2 = 0; \\n        for (int n: nums1) sum1+=n;\\n        for (int n: nums2) sum2+=n;\\n        if (sum1 > sum2) return Helper(nums1, nums2, sum1 - sum2);\\n        return Helper(nums2, nums1, sum2 - sum1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455602,
                "title": "java-greedy-without-queue-slow",
                "content": "```\\npublic int minOperations(int[] nums1, int[] nums2) {\\n        // greedy\\n        int res1 = 0, res2 = 0;\\n        for(int i = 0; i < nums1.length; i++) {\\n            res1 += nums1[i];\\n        }\\n        for(int j = 0; j < nums2.length; j++) {\\n            res2 += nums2[j];\\n        }\\n        int delta = Math.abs(res1 - res2);\\n        // Who has a larger sum?\\n        if(res1 == res2) return 0;\\n        int[] larger = res1 >= res2 ? nums1 : nums2;\\n        List<Integer> l = IntStream.of(larger)    // returns IntStream\\n                            .boxed()\\n                            .collect(Collectors.toList());\\n        // decreasing \\n        Collections.sort(l, (a, b) -> b - a);\\n        \\n        int[] smaller = res1 < res2 ? nums1 : nums2;\\n        List<Integer> s = IntStream.of(smaller)    // returns IntStream\\n                            .boxed()\\n                            .collect(Collectors.toList());\\n        // Increasing \\n        Collections.sort(s);\\n        \\n        \\n        int res = 0;\\n        int sp = 0, lp = 0;\\n        if((l.size()*1 - s.size()*6) > 0) return -1;\\n        while(delta > 0 && (lp < l.size() || sp < s.size())) {\\n            int deltaL = lp < l.size() ? l.get(lp) - 1 : 0;\\n            int deltaS = sp < s.size() ? 6 - s.get(sp) : 0;\\n            if(delta <= Math.max(deltaL, deltaS)) {\\n                return res + 1;\\n            }\\n            else {\\n                if(deltaL >= deltaS) {\\n                    delta -= deltaL;\\n                    lp++;\\n                } else {\\n                    delta -= deltaS;\\n                    sp++;\\n                }\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(int[] nums1, int[] nums2) {\\n        // greedy\\n        int res1 = 0, res2 = 0;\\n        for(int i = 0; i < nums1.length; i++) {\\n            res1 += nums1[i];\\n        }\\n        for(int j = 0; j < nums2.length; j++) {\\n            res2 += nums2[j];\\n        }\\n        int delta = Math.abs(res1 - res2);\\n        // Who has a larger sum?\\n        if(res1 == res2) return 0;\\n        int[] larger = res1 >= res2 ? nums1 : nums2;\\n        List<Integer> l = IntStream.of(larger)    // returns IntStream\\n                            .boxed()\\n                            .collect(Collectors.toList());\\n        // decreasing \\n        Collections.sort(l, (a, b) -> b - a);\\n        \\n        int[] smaller = res1 < res2 ? nums1 : nums2;\\n        List<Integer> s = IntStream.of(smaller)    // returns IntStream\\n                            .boxed()\\n                            .collect(Collectors.toList());\\n        // Increasing \\n        Collections.sort(s);\\n        \\n        \\n        int res = 0;\\n        int sp = 0, lp = 0;\\n        if((l.size()*1 - s.size()*6) > 0) return -1;\\n        while(delta > 0 && (lp < l.size() || sp < s.size())) {\\n            int deltaL = lp < l.size() ? l.get(lp) - 1 : 0;\\n            int deltaS = sp < s.size() ? 6 - s.get(sp) : 0;\\n            if(delta <= Math.max(deltaL, deltaS)) {\\n                return res + 1;\\n            }\\n            else {\\n                if(deltaL >= deltaS) {\\n                    delta -= deltaL;\\n                    lp++;\\n                } else {\\n                    delta -= deltaS;\\n                    sp++;\\n                }\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2450405,
                "title": "100-faster-less-than-100-memory-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n\\tdef minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n\\t\\ts1,s2 = 0,0\\n\\t\\td1,d2 = defaultdict(int),defaultdict(int)\\n\\t\\tfor n in nums1:\\n\\t\\t\\ts1 += n\\n\\t\\t\\td1[n]+=1\\n\\t\\tfor n in nums2:\\n\\t\\t\\ts2 += n\\n\\t\\t\\td2[n]+=1\\n\\n\\t\\tl1 = len(nums1)\\n\\t\\tl2 = len(nums2)\\n\\t\\tif l1 > l2 * 6 or l2 > l1 * 6:\\n\\t\\t\\treturn -1\\n\\n\\t\\tif s1 > s2:\\n\\t\\t\\tmd = d2\\n\\t\\t\\tMd = d1\\n\\t\\telif s1 < s2:\\n\\t\\t\\tmd = d1\\n\\t\\t\\tMd = d2\\n\\t\\telse:\\n\\t\\t\\treturn 0\\n\\n\\t\\tit = 6\\n\\t\\tdif = abs(s1-s2)\\n\\n\\t\\tans = 0\\n\\t\\twhile it > 0 and dif > 0:\\n\\t\\t\\tts = md[7-it] + Md[it]\\n\\t\\t\\tval = it - 1\\n\\t\\t\\tdiv = dif//val\\n\\t\\t\\tcl = math.ceil(dif/val)\\n\\t\\t\\tif ts >= cl:\\n\\t\\t\\t\\tans += cl\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tdif -= val * ts\\n\\t\\t\\tans += ts\\n\\t\\t\\tit-=1\\n\\n\\t\\treturn ans\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n\\t\\ts1,s2 = 0,0\\n\\t\\td1,d2 = defaultdict(int),defaultdict(int)\\n\\t\\tfor n in nums1:\\n\\t\\t\\ts1 += n\\n\\t\\t\\td1[n]+=1\\n\\t\\tfor n in nums2:\\n\\t\\t\\ts2 += n\\n\\t\\t\\td2[n]+=1\\n\\n\\t\\tl1 = len(nums1)\\n\\t\\tl2 = len(nums2)\\n\\t\\tif l1 > l2 * 6 or l2 > l1 * 6:\\n\\t\\t\\treturn -1\\n\\n\\t\\tif s1 > s2:\\n\\t\\t\\tmd = d2\\n\\t\\t\\tMd = d1\\n\\t\\telif s1 < s2:\\n\\t\\t\\tmd = d1\\n\\t\\t\\tMd = d2\\n\\t\\telse:\\n\\t\\t\\treturn 0\\n\\n\\t\\tit = 6\\n\\t\\tdif = abs(s1-s2)\\n\\n\\t\\tans = 0\\n\\t\\twhile it > 0 and dif > 0:\\n\\t\\t\\tts = md[7-it] + Md[it]\\n\\t\\t\\tval = it - 1\\n\\t\\t\\tdiv = dif//val\\n\\t\\t\\tcl = math.ceil(dif/val)\\n\\t\\t\\tif ts >= cl:\\n\\t\\t\\t\\tans += cl\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tdif -= val * ts\\n\\t\\t\\tans += ts\\n\\t\\t\\tit-=1\\n\\n\\t\\treturn ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402487,
                "title": "c-o-n-greedy-count-frequency-with-detailed-explanation",
                "content": "```\\nint sum1 = 0, sum2 = 0;\\n        vector<vector<int>> count(2,vector<int>(6));\\n        for(auto i:nums1){\\n            sum1 += i;\\n            count[0][i-1]++;\\n        }\\n        for(auto i:nums2){\\n            sum2 += i;\\n            count[1][i-1]++;\\n        }\\n        int dif = abs(sum1-sum2);\\n\\t\\t//big is the index of bigger array and small is the index of smaller array\\n\\t\\t// if sum2 >= sum1, big is 1, small is 0\\n\\t\\t// if sum2 < sum1, big is 0, small is 1\\n        int big = sum2>=sum1;\\n        int small = sum2<sum1;\\n\\t\\t// i is the smallest number of the smaller array\\n\\t\\t// j is the biggest number of the bigger array\\n\\t\\t//we want to make each operation has the maximum effect, so we either increment i to 5 or j to 0\\n\\t\\t//why 5 and 0? because this is 0 index.\\n        int i=0, j=5, res=0;\\n        while(dif>0){\\n\\t\\t\\t//skip numbers that have frequency of 0, in other words,  non-existing\\n            while(i<5&&count[small][i]==0) i++;\\n            while(j>0&&count[big][j]==0) j--;\\n\\t\\t\\t//can\\'t decrease the difference between big and small anymore, return -1;\\n            if(i==5&&j==0) return -1;\\n\\t\\t\\t//increment the smallest number in smaller array is better\\n            if(5-i>=j){\\n                dif -= 5-i;\\n                count[small][i]--;\\n            }\\n\\t\\t\\t//decrement the biggest number in bigger array is better\\n            else{\\n                dif -= j;\\n                count[big][j]--;\\n            }\\n            res++;\\n        }\\n        return res;\\n```",
                "solutionTags": [],
                "code": "```\\nint sum1 = 0, sum2 = 0;\\n        vector<vector<int>> count(2,vector<int>(6));\\n        for(auto i:nums1){\\n            sum1 += i;\\n            count[0][i-1]++;\\n        }\\n        for(auto i:nums2){\\n            sum2 += i;\\n            count[1][i-1]++;\\n        }\\n        int dif = abs(sum1-sum2);\\n\\t\\t//big is the index of bigger array and small is the index of smaller array\\n\\t\\t// if sum2 >= sum1, big is 1, small is 0\\n\\t\\t// if sum2 < sum1, big is 0, small is 1\\n        int big = sum2>=sum1;\\n        int small = sum2<sum1;\\n\\t\\t// i is the smallest number of the smaller array\\n\\t\\t// j is the biggest number of the bigger array\\n\\t\\t//we want to make each operation has the maximum effect, so we either increment i to 5 or j to 0\\n\\t\\t//why 5 and 0? because this is 0 index.\\n        int i=0, j=5, res=0;\\n        while(dif>0){\\n\\t\\t\\t//skip numbers that have frequency of 0, in other words,  non-existing\\n            while(i<5&&count[small][i]==0) i++;\\n            while(j>0&&count[big][j]==0) j--;\\n\\t\\t\\t//can\\'t decrease the difference between big and small anymore, return -1;\\n            if(i==5&&j==0) return -1;\\n\\t\\t\\t//increment the smallest number in smaller array is better\\n            if(5-i>=j){\\n                dif -= 5-i;\\n                count[small][i]--;\\n            }\\n\\t\\t\\t//decrement the biggest number in bigger array is better\\n            else{\\n                dif -= j;\\n                count[big][j]--;\\n            }\\n            res++;\\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2374943,
                "title": "two-priority-queues-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int s1 = 0, s2 = 0, ans = 0;\\n        for(int i : nums1) s1 += i;\\n        for(int i : nums2) s2 += i;\\n        \\n        int d = s1 - s2;\\n        if(!d) return 0;\\n        \\n        priority_queue<int> pq1;\\n        priority_queue<int, vector<int>, greater<int>> pq2;\\n        \\n        if(d > 0) {\\n            for(int i : nums1) pq1.push(i);\\n            for(int i : nums2) pq2.push(i);\\n        }\\n        else {  \\n            for(int i : nums2) pq1.push(i);\\n            for(int i : nums1) pq2.push(i);\\n        }\\n        \\n        d = abs(d);\\n        while(d > 0) {\\n            if(pq1.top() == 1 && pq2.top() == 6) return -1;\\n            \\n            if(pq1.top() - 1 > 6 - pq2.top()) {\\n                int i, h = pq1.top(); pq1.pop();\\n                for(i=1; i<h; i++) if(d - h + i >= 0) break;\\n                d -= h - i;\\n                if(i != h) ans++;\\n                pq1.push(i);\\n            }\\n            else {\\n                int j, l = pq2.top(); pq2.pop();\\n                for(j=6; j>l; j--) if(d - j + l >= 0) break;\\n                d -= j - l;\\n                if(j != l) ans++;\\n                pq2.push(j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int s1 = 0, s2 = 0, ans = 0;\\n        for(int i : nums1) s1 += i;\\n        for(int i : nums2) s2 += i;\\n        \\n        int d = s1 - s2;\\n        if(!d) return 0;\\n        \\n        priority_queue<int> pq1;\\n        priority_queue<int, vector<int>, greater<int>> pq2;\\n        \\n        if(d > 0) {\\n            for(int i : nums1) pq1.push(i);\\n            for(int i : nums2) pq2.push(i);\\n        }\\n        else {  \\n            for(int i : nums2) pq1.push(i);\\n            for(int i : nums1) pq2.push(i);\\n        }\\n        \\n        d = abs(d);\\n        while(d > 0) {\\n            if(pq1.top() == 1 && pq2.top() == 6) return -1;\\n            \\n            if(pq1.top() - 1 > 6 - pq2.top()) {\\n                int i, h = pq1.top(); pq1.pop();\\n                for(i=1; i<h; i++) if(d - h + i >= 0) break;\\n                d -= h - i;\\n                if(i != h) ans++;\\n                pq1.push(i);\\n            }\\n            else {\\n                int j, l = pq2.top(); pq2.pop();\\n                for(j=6; j>l; j--) if(d - j + l >= 0) break;\\n                d -= j - l;\\n                if(j != l) ans++;\\n                pq2.push(j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339614,
                "title": "c-142ms-maths",
                "content": "We can change any element of any array to any value between 1-6. This makes our life very easy. \\nWe will always change the max we can as it will reduce our no of operations.\\n# Approach\\nWe need to calculate the sum of both arrays. The array having larger sum will have its elements reduced and other will have increased. \\nWe can reduce any element min to 1. So we can call this operation value as **x-1**. \\nWe can increase any element max to 6. So we will call this operation value as **6-x**.\\nHere x is a element in arrays.\\nWe will store all the operations count from 1 to 5.\\n```\\nclass Solution {\\npublic:\\n    int utility(vector<int>& big, vector<int>& small, int b, int s, int req){\\n\\t\\t// to store count of each operation we can perform\\n        vector<int> B(6,0);\\n        for(int i=0; i<b; i++){\\n            if(big[i]-1) B[big[i]-1]++;\\n        }\\n        for(int i=0; i<s; i++){\\n           if(6-small[i]) B[6-small[i]]++;\\n        }\\n        int cnt = 0; int i=5;\\n        int x;\\n        while(i>0 && req){\\n\\t\\t\\t// if we can reduce req by curr operation, reduce till req becomes 0 or min by\\n\\t\\t\\t// currentoperation\\n            if(B[i] != 0){\\n                x = (int)ceil(req/double(i));\\n                if(B[i] >= x){\\n                    return cnt+x;\\n                }\\n                else{\\n                    req -= B[i]*i;\\n                    cnt += B[i];\\n                }\\n            }\\n            i--;\\n        }\\n        return req==0?cnt:-1;\\n    }\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(); int n2 = nums2.size();\\n        int x = accumulate(nums1.begin(), nums1.end(), 0);\\n        int y = accumulate(nums2.begin(), nums2.end(), 0);\\n        if(x == y) return 0;\\n        else if(x > y) return utility(nums1, nums2, n1, n2, x-y);\\n        else return utility(nums2, nums1, n2, n1, y-x);\\n    }\\n};\\nstatic const auto speedup = []() {\\n    std::ios::sync_with_stdio(false); \\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr); \\n    return 0;\\n}();\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int utility(vector<int>& big, vector<int>& small, int b, int s, int req){\\n\\t\\t// to store count of each operation we can perform\\n        vector<int> B(6,0);\\n        for(int i=0; i<b; i++){\\n            if(big[i]-1) B[big[i]-1]++;\\n        }\\n        for(int i=0; i<s; i++){\\n           if(6-small[i]) B[6-small[i]]++;\\n        }\\n        int cnt = 0; int i=5;\\n        int x;\\n        while(i>0 && req){\\n\\t\\t\\t// if we can reduce req by curr operation, reduce till req becomes 0 or min by\\n\\t\\t\\t// currentoperation\\n            if(B[i] != 0){\\n                x = (int)ceil(req/double(i));\\n                if(B[i] >= x){\\n                    return cnt+x;\\n                }\\n                else{\\n                    req -= B[i]*i;\\n                    cnt += B[i];\\n                }\\n            }\\n            i--;\\n        }\\n        return req==0?cnt:-1;\\n    }\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(); int n2 = nums2.size();\\n        int x = accumulate(nums1.begin(), nums1.end(), 0);\\n        int y = accumulate(nums2.begin(), nums2.end(), 0);\\n        if(x == y) return 0;\\n        else if(x > y) return utility(nums1, nums2, n1, n2, x-y);\\n        else return utility(nums2, nums1, n2, n1, y-x);\\n    }\\n};\\nstatic const auto speedup = []() {\\n    std::ios::sync_with_stdio(false); \\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr); \\n    return 0;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2313756,
                "title": "intuitive-greedy-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        priority_queue<int, vector<int>, less<int>> max_heap;\\n        priority_queue<int, vector<int>, greater<int>> min_heap;\\n        \\n        auto large = accumulate(nums1.begin(), nums1.end(), 0);\\n        auto small = accumulate(nums2.begin(), nums2.end(), 0);\\n        \\n        if (large > small) {\\n            for (auto n : nums1)\\n                max_heap.push(n);\\n            for (auto n : nums2)\\n                min_heap.push(n);\\n        } else {\\n            swap(large, small);\\n            for (auto n : nums2)\\n                max_heap.push(n);\\n            for (auto n : nums1)\\n                min_heap.push(n);\\n        }\\n        \\n        int res = 0;\\n        \\n        while (large > small and !max_heap.empty() and !min_heap.empty()) {\\n            auto max_reduce = max_heap.top() - 1;\\n            auto max_increase = 6 - min_heap.top();\\n            \\n            if (max_reduce > max_increase) {\\n                large -= max_reduce;\\n                max_heap.pop();\\n                ++res;\\n            } else {\\n                small += max_increase;\\n                min_heap.pop();\\n                ++res;\\n            }\\n        }\\n        \\n        while (large > small and !max_heap.empty()) {\\n            auto max_reduce = max_heap.top() - 1;\\n                large -= max_reduce;\\n                if (max_reduce > 0)\\n                    ++res;\\n            max_heap.pop();\\n        }\\n        \\n        while (large > small and !min_heap.empty()) {\\n            auto max_increase = 6 - min_heap.top();\\n                small += max_increase;\\n                if (max_increase > 0)\\n                    ++res;\\n            min_heap.pop();\\n        }\\n        \\n        return large <= small ? res : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        priority_queue<int, vector<int>, less<int>> max_heap;\\n        priority_queue<int, vector<int>, greater<int>> min_heap;\\n        \\n        auto large = accumulate(nums1.begin(), nums1.end(), 0);\\n        auto small = accumulate(nums2.begin(), nums2.end(), 0);\\n        \\n        if (large > small) {\\n            for (auto n : nums1)\\n                max_heap.push(n);\\n            for (auto n : nums2)\\n                min_heap.push(n);\\n        } else {\\n            swap(large, small);\\n            for (auto n : nums2)\\n                max_heap.push(n);\\n            for (auto n : nums1)\\n                min_heap.push(n);\\n        }\\n        \\n        int res = 0;\\n        \\n        while (large > small and !max_heap.empty() and !min_heap.empty()) {\\n            auto max_reduce = max_heap.top() - 1;\\n            auto max_increase = 6 - min_heap.top();\\n            \\n            if (max_reduce > max_increase) {\\n                large -= max_reduce;\\n                max_heap.pop();\\n                ++res;\\n            } else {\\n                small += max_increase;\\n                min_heap.pop();\\n                ++res;\\n            }\\n        }\\n        \\n        while (large > small and !max_heap.empty()) {\\n            auto max_reduce = max_heap.top() - 1;\\n                large -= max_reduce;\\n                if (max_reduce > 0)\\n                    ++res;\\n            max_heap.pop();\\n        }\\n        \\n        while (large > small and !min_heap.empty()) {\\n            auto max_increase = 6 - min_heap.top();\\n                small += max_increase;\\n                if (max_increase > 0)\\n                    ++res;\\n            min_heap.pop();\\n        }\\n        \\n        return large <= small ? res : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283043,
                "title": "greedy",
                "content": "```python\\n\\'\\'\\'\\ngreedy\\nO(n), O(1)\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1_sum, nums2_sum = sum(nums1), sum(nums2)\\n        if nums1_sum > nums2_sum:\\n            nums1, nums2 = nums2, nums1 # make nums1 the smaller-sumed array\\n        if 6 * len(nums1) < len(nums2): # not possible\\n            return -1\\n        \\n        diff = abs(nums2_sum - nums1_sum)\\n        \\n        # most impactful operations\\n        nums1 = [6 - num for num in nums1]\\n        nums2 = [num - 1 for num in nums2]\\n        ops = sorted(nums1 + nums2, reverse=True)\\n        \\n        print(ops, diff)\\n        \\n        res = 0 \\n        for op in ops:\\n            if diff <= 0:\\n                break\\n            res += 1\\n            diff -= op\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\ngreedy\\nO(n), O(1)\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1_sum, nums2_sum = sum(nums1), sum(nums2)\\n        if nums1_sum > nums2_sum:\\n            nums1, nums2 = nums2, nums1 # make nums1 the smaller-sumed array\\n        if 6 * len(nums1) < len(nums2): # not possible\\n            return -1\\n        \\n        diff = abs(nums2_sum - nums1_sum)\\n        \\n        # most impactful operations\\n        nums1 = [6 - num for num in nums1]\\n        nums2 = [num - 1 for num in nums2]\\n        ops = sorted(nums1 + nums2, reverse=True)\\n        \\n        print(ops, diff)\\n        \\n        res = 0 \\n        for op in ops:\\n            if diff <= 0:\\n                break\\n            res += 1\\n            diff -= op\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275894,
                "title": "java-solution-greedy",
                "content": "First we find the min and maximums if the array so we can compete if equalizing them is even possible, the max of the array is just 6 * length and min is just 1 * length, as those are in the min and max value for each index. if the min of one array is greater than the max of the other than we know the solution is impossible\\n\\nNow for the actually greddy algo, we essentially count the number of times each number appears in the nums, since we can to equalize the values we want to create the most amount of change in the sums per step, so we want to start decreasing values from 6 first ( as that subtracts the sum by 5) or if we are increasing the sum, try to increase a 1 to 6 (an increase of 5). \\n\\nSo we just keep trying to add the most amount we can to the sum before the two array sum equalize, but remeber you need to compare between the value your going to add vs the value your going to subtract to see which one is the more optimal step\\n\\n\\n\\n\\n```\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        \\n        int[] nums1Count = new int[7];\\n        int[] nums2Count = new int[7];\\n        \\n        int sum1 = 0;\\n        int sum2 = 0;\\n        \\n        int nums1Max = nums1.length * 6;\\n        int nums2Max = nums2.length * 6;\\n            \\n        int nums1Min = nums1.length; \\n        int nums2Min = nums2.length;\\n        \\n        if(nums2Min > nums1Max)\\n            return -1;\\n        else if(nums1Min > nums2Max)\\n            return -1;\\n        \\n        for(int i = 0; i < nums1.length; i++) {\\n            nums1Count[nums1[i]]++;\\n            sum1 += nums1[i];\\n        }\\n        \\n        for(int i = 0; i < nums2.length; i++) {\\n            nums2Count[nums2[i]]++;\\n            sum2 += nums2[i]; \\n        }\\n        \\n        if(sum1 == sum2)\\n            return 0;\\n        \\n        int steps = 0;\\n        \\n        int[] greaterNums =  sum1 > sum2 ? nums1Count : nums2Count;\\n        int[] lesserNums = sum1 > sum2 ? nums2Count : nums1Count;\\n        int greaterSum = sum1 > sum2 ? sum1 : sum2;\\n        int lesserSum = sum1 > sum2 ? sum2 : sum1;\\n\\n        \\n        \\n        int greaterIndex = 6;\\n        int lesserIndex = 1;\\n        \\n        while(greaterSum > lesserSum) {\\n            \\n            if(greaterIndex - 1 > 6 - lesserIndex && greaterNums[greaterIndex] > 0) {\\n                greaterSum -= greaterIndex - 1;\\n                greaterNums[greaterIndex]--;\\n                steps++;\\n            } else if(lesserNums[lesserIndex] > 0) {\\n                lesserSum += 6 - lesserIndex;\\n                lesserNums[lesserIndex]--;\\n                steps++;\\n            }\\n            \\n            while(lesserIndex < 6 && lesserNums[lesserIndex] == 0)\\n                lesserIndex++;\\n            while(greaterIndex > 1 && greaterNums[greaterIndex] == 0)\\n                greaterIndex--;\\n        }\\n        \\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        \\n        int[] nums1Count = new int[7];\\n        int[] nums2Count = new int[7];\\n        \\n        int sum1 = 0;\\n        int sum2 = 0;\\n        \\n        int nums1Max = nums1.length * 6;\\n        int nums2Max = nums2.length * 6;\\n            \\n        int nums1Min = nums1.length; \\n        int nums2Min = nums2.length;\\n        \\n        if(nums2Min > nums1Max)\\n            return -1;\\n        else if(nums1Min > nums2Max)\\n            return -1;\\n        \\n        for(int i = 0; i < nums1.length; i++) {\\n            nums1Count[nums1[i]]++;\\n            sum1 += nums1[i];\\n        }\\n        \\n        for(int i = 0; i < nums2.length; i++) {\\n            nums2Count[nums2[i]]++;\\n            sum2 += nums2[i]; \\n        }\\n        \\n        if(sum1 == sum2)\\n            return 0;\\n        \\n        int steps = 0;\\n        \\n        int[] greaterNums =  sum1 > sum2 ? nums1Count : nums2Count;\\n        int[] lesserNums = sum1 > sum2 ? nums2Count : nums1Count;\\n        int greaterSum = sum1 > sum2 ? sum1 : sum2;\\n        int lesserSum = sum1 > sum2 ? sum2 : sum1;\\n\\n        \\n        \\n        int greaterIndex = 6;\\n        int lesserIndex = 1;\\n        \\n        while(greaterSum > lesserSum) {\\n            \\n            if(greaterIndex - 1 > 6 - lesserIndex && greaterNums[greaterIndex] > 0) {\\n                greaterSum -= greaterIndex - 1;\\n                greaterNums[greaterIndex]--;\\n                steps++;\\n            } else if(lesserNums[lesserIndex] > 0) {\\n                lesserSum += 6 - lesserIndex;\\n                lesserNums[lesserIndex]--;\\n                steps++;\\n            }\\n            \\n            while(lesserIndex < 6 && lesserNums[lesserIndex] == 0)\\n                lesserIndex++;\\n            while(greaterIndex > 1 && greaterNums[greaterIndex] == 0)\\n                greaterIndex--;\\n        }\\n        \\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2272390,
                "title": "c-o-nlogn-greedy",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n\\t\\tif (n < m) {\\n\\t\\t\\tswap(nums1, nums2);\\n\\t\\t\\tswap(n, m);\\n\\t\\t}\\n\\t\\tint mn1 = n, mx1 = 6 * n;\\n\\t\\tint mn2 = m, mx2 = 6 * m;\\n\\t\\tif (mx2 < mn1) return -1;\\n\\t\\tint mn = mn2, mx = mx1;\\n\\t\\tint s1 = 0, s2 = 0;\\n\\t\\tfor (const int &x: nums1) s1 += x;\\n\\t\\tfor (const int &x: nums2) s2 += x;\\n\\t\\tif (s1 == s2) return 0;\\n\\t\\tvector<int> v;\\n\\t\\tint diff;\\n\\t\\tif (s1 > s2) {\\n\\t\\t\\tdiff = s1 - s2;\\n\\t\\t\\tfor (int i = 0; i < n; i++ ) v.push_back(nums1[i] - 1);\\n\\t\\t\\tfor (int i = 0; i < m; i++) v.push_back(6 - nums2[i]);\\n\\t\\t} else {\\n\\t\\t\\tdiff = s2 - s1;\\n\\t\\t\\tfor (int i = 0; i < m; i++) v.push_back(nums2[i] - 1);\\n\\t\\t\\tfor (int i = 0; i < n; i++) v.push_back(6 - nums1[i]);\\n\\t\\t}\\n\\t\\tsort(v.rbegin(), v.rend());\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < v.size(); i++) {\\n\\t\\t\\tdiff -= min(diff, v[i]);\\n\\t\\t\\tans++;\\n\\t\\t\\tif (diff == 0)\\n\\t\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tif (diff == 0) return ans;\\n\\t\\treturn -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n\\t\\tif (n < m) {\\n\\t\\t\\tswap(nums1, nums2);\\n\\t\\t\\tswap(n, m);\\n\\t\\t}\\n\\t\\tint mn1 = n, mx1 = 6 * n;\\n\\t\\tint mn2 = m, mx2 = 6 * m;\\n\\t\\tif (mx2 < mn1) return -1;\\n\\t\\tint mn = mn2, mx = mx1;\\n\\t\\tint s1 = 0, s2 = 0;\\n\\t\\tfor (const int &x: nums1) s1 += x;\\n\\t\\tfor (const int &x: nums2) s2 += x;\\n\\t\\tif (s1 == s2) return 0;\\n\\t\\tvector<int> v;\\n\\t\\tint diff;\\n\\t\\tif (s1 > s2) {\\n\\t\\t\\tdiff = s1 - s2;\\n\\t\\t\\tfor (int i = 0; i < n; i++ ) v.push_back(nums1[i] - 1);\\n\\t\\t\\tfor (int i = 0; i < m; i++) v.push_back(6 - nums2[i]);\\n\\t\\t} else {\\n\\t\\t\\tdiff = s2 - s1;\\n\\t\\t\\tfor (int i = 0; i < m; i++) v.push_back(nums2[i] - 1);\\n\\t\\t\\tfor (int i = 0; i < n; i++) v.push_back(6 - nums1[i]);\\n\\t\\t}\\n\\t\\tsort(v.rbegin(), v.rend());\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < v.size(); i++) {\\n\\t\\t\\tdiff -= min(diff, v[i]);\\n\\t\\t\\tans++;\\n\\t\\t\\tif (diff == 0)\\n\\t\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tif (diff == 0) return ans;\\n\\t\\treturn -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267172,
                "title": "python-o-nlogn-8-lines-clean-code",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums2,nums1 = sorted([nums1,nums2], key = sum)\\n        arr = sorted([x-1 for x in nums1 if x-1] + [6-x for x in nums2 if 6-x])\\n        diff = sum(nums1) - sum(nums2)\\n        ans = 0\\n        while diff > 0 and arr:\\n            diff -= arr.pop()\\n            ans += 1\\n        return ans if diff <= 0 else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums2,nums1 = sorted([nums1,nums2], key = sum)\\n        arr = sorted([x-1 for x in nums1 if x-1] + [6-x for x in nums2 if 6-x])\\n        diff = sum(nums1) - sum(nums2)\\n        ans = 0\\n        while diff > 0 and arr:\\n            diff -= arr.pop()\\n            ans += 1\\n        return ans if diff <= 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257905,
                "title": "python-o-n-o-1",
                "content": "```\\n\"\"\"\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\"\"\"\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        cnt = [0] * 6\\n        sum1, sum2 = 0, 0\\n        \\n        for n in nums1:\\n            sum1+=n\\n            cnt[n-1]+=1\\n        for n in nums2:\\n            sum2+=n\\n            cnt[6-n]+=1\\n\\n        if sum1 == sum2:\\n            return 0\\n        if sum2 < sum1:\\n            cnt = cnt[::-1]\\n\\n        diff = abs(sum1-sum2)\\n        res = 0\\n        for i, x in enumerate(cnt[:6]):\\n            if diff < (5-i)*x:\\n                return res + math.ceil(diff / (5-i))\\n            diff = diff - (5-i)*x\\n            res+=x\\n        return res if diff < 1 else -1\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\"\"\"\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        cnt = [0] * 6\\n        sum1, sum2 = 0, 0\\n        \\n        for n in nums1:\\n            sum1+=n\\n            cnt[n-1]+=1\\n        for n in nums2:\\n            sum2+=n\\n            cnt[6-n]+=1\\n\\n        if sum1 == sum2:\\n            return 0\\n        if sum2 < sum1:\\n            cnt = cnt[::-1]\\n\\n        diff = abs(sum1-sum2)\\n        res = 0\\n        for i, x in enumerate(cnt[:6]):\\n            if diff < (5-i)*x:\\n                return res + math.ceil(diff / (5-i))\\n            diff = diff - (5-i)*x\\n            res+=x\\n        return res if diff < 1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144862,
                "title": "python-two-pointer-greedy",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1) * 6 < len(nums2) or len(nums1) > len(nums2) * 6:\\n            return -1\\n        sum1, sum2 = sum(nums1), sum(nums2)\\n        if sum1 > sum2:\\n            return self.minOperations(nums2, nums1)\\n        nums1.sort()\\n        nums2.sort()\\n        m, n = len(nums1), len(nums2)\\n        p1, p2 = 0, n-1\\n        dif = sum2 - sum1 \\n        ans = 0\\n        while dif > 0 and p1 < m and p2 >= 0:\\n            # greedy choose the one with larger difference\\n            d1, d2 = 6 - nums1[p1], nums2[p2] - 1\\n            if d1 > dif or d2 > dif:\\n                return ans + 1\\n            if d1 >= d2:\\n                dif -= d1\\n                p1 += 1\\n            else:\\n                dif -= d2\\n                p2 -= 1\\n            ans += 1\\n            \\n        while dif > 0 and p1 < m:\\n            dif -= 6 - nums1[p1]\\n            p1 += 1\\n            ans += 1\\n            \\n        while dif > 0 and p2 >= 0:\\n            dif -= nums2[p2] - 1\\n            p2 -= 1\\n            ans += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1) * 6 < len(nums2) or len(nums1) > len(nums2) * 6:\\n            return -1\\n        sum1, sum2 = sum(nums1), sum(nums2)\\n        if sum1 > sum2:\\n            return self.minOperations(nums2, nums1)\\n        nums1.sort()\\n        nums2.sort()\\n        m, n = len(nums1), len(nums2)\\n        p1, p2 = 0, n-1\\n        dif = sum2 - sum1 \\n        ans = 0\\n        while dif > 0 and p1 < m and p2 >= 0:\\n            # greedy choose the one with larger difference\\n            d1, d2 = 6 - nums1[p1], nums2[p2] - 1\\n            if d1 > dif or d2 > dif:\\n                return ans + 1\\n            if d1 >= d2:\\n                dif -= d1\\n                p1 += 1\\n            else:\\n                dif -= d2\\n                p2 -= 1\\n            ans += 1\\n            \\n        while dif > 0 and p1 < m:\\n            dif -= 6 - nums1[p1]\\n            p1 += 1\\n            ans += 1\\n            \\n        while dif > 0 and p2 >= 0:\\n            dif -= nums2[p2] - 1\\n            p2 -= 1\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089146,
                "title": "java-not-the-most-simplified-but-intuitive-enough-greedy",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        //use greedy algorithm \\n        int sum1 = getSum(nums1);\\n        int sum2 = getSum(nums2);\\n        \\n        //make sure nums1 have bigger sum\\n        if(sum1 > sum2) return minOperations(nums2, nums1);\\n        \\n        if(sum1 == sum2) return 0;\\n        \\n        int length1 = nums1.length;\\n        int length2 = nums2.length;\\n        \\n        if(length1 * 6 < length2 || length2 * 6 < length1) return -1;\\n        \\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int diff = sum2 - sum1;\\n        int first = 0, second = length2-1;\\n        int count = 0;\\n        \\n        while(diff > 0){\\n            if(first >= length1 || second < 0) break;\\n            if(nums2[second] - 1 < 6 - nums1[first]){\\n                //use nums1\\n                diff -= 6 - nums1[first++];\\n            }else{\\n                diff -= nums2[second--] - 1;\\n            }\\n            count ++;\\n        }\\n        \\n        //diff <= 0 or one of the array is done\\n        if( diff <= 0) return count;\\n        \\n        //not done\\n        while(first < length1 && diff > 0){\\n            if(nums1[first] == 6) return -1;\\n            diff -= 6 - nums1[first++];\\n            count ++;\\n        }\\n        \\n        while(second >= 0 && diff > 0){\\n            if(nums2[second] == 1) return -1;\\n            diff -= nums2[second--] - 1;\\n            count ++;\\n        }\\n        \\n        if(diff > 0) return -1;\\n        \\n        return count; \\n        \\n\\n    }\\n    \\n    public int getSum(int[] num){\\n        int sum = 0;\\n        for(int i : num){\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        //use greedy algorithm \\n        int sum1 = getSum(nums1);\\n        int sum2 = getSum(nums2);\\n        \\n        //make sure nums1 have bigger sum\\n        if(sum1 > sum2) return minOperations(nums2, nums1);\\n        \\n        if(sum1 == sum2) return 0;\\n        \\n        int length1 = nums1.length;\\n        int length2 = nums2.length;\\n        \\n        if(length1 * 6 < length2 || length2 * 6 < length1) return -1;\\n        \\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int diff = sum2 - sum1;\\n        int first = 0, second = length2-1;\\n        int count = 0;\\n        \\n        while(diff > 0){\\n            if(first >= length1 || second < 0) break;\\n            if(nums2[second] - 1 < 6 - nums1[first]){\\n                //use nums1\\n                diff -= 6 - nums1[first++];\\n            }else{\\n                diff -= nums2[second--] - 1;\\n            }\\n            count ++;\\n        }\\n        \\n        //diff <= 0 or one of the array is done\\n        if( diff <= 0) return count;\\n        \\n        //not done\\n        while(first < length1 && diff > 0){\\n            if(nums1[first] == 6) return -1;\\n            diff -= 6 - nums1[first++];\\n            count ++;\\n        }\\n        \\n        while(second >= 0 && diff > 0){\\n            if(nums2[second] == 1) return -1;\\n            diff -= nums2[second--] - 1;\\n            count ++;\\n        }\\n        \\n        if(diff > 0) return -1;\\n        \\n        return count; \\n        \\n\\n    }\\n    \\n    public int getSum(int[] num){\\n        int sum = 0;\\n        for(int i : num){\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074568,
                "title": "clean-python-code",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        diff = sum(nums1) - sum(nums2)\\n        if diff == 0:\\n            return 0\\n        elif diff < 0:\\n            # nums1 is of bigger sum.\\n            nums1, nums2 = nums2, nums1\\n        # how many points for elements in nums1 can substract.\\n        gain1 = [num - 1 for num in nums1]\\n        # how many points for elements in nums2 can plus.\\n        gain2 = [6 - num for num in nums2]\\n        gain = gain1 + gain2\\n        gain.sort(reverse = True)\\n        \\n        res = 0\\n        makeup = 0\\n        for g in gain:\\n            makeup += g\\n            res += 1\\n            if makeup >= abs(diff):\\n                return res\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        diff = sum(nums1) - sum(nums2)\\n        if diff == 0:\\n            return 0\\n        elif diff < 0:\\n            # nums1 is of bigger sum.\\n            nums1, nums2 = nums2, nums1\\n        # how many points for elements in nums1 can substract.\\n        gain1 = [num - 1 for num in nums1]\\n        # how many points for elements in nums2 can plus.\\n        gain2 = [6 - num for num in nums2]\\n        gain = gain1 + gain2\\n        gain.sort(reverse = True)\\n        \\n        res = 0\\n        makeup = 0\\n        for g in gain:\\n            makeup += g\\n            res += 1\\n            if makeup >= abs(diff):\\n                return res\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065323,
                "title": "java-o-n-space-and-time-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int l1 = nums1.length;\\n        int l2 = nums2.length;\\n        \\n        if(l1 > 6 * l2 || l2 > 6 * l1){\\n            return -1;\\n        }\\n        \\n        int sum1 = 0;\\n        int sum2 = 0;\\n        \\n        for(int i:nums1) sum1+=i;\\n        for(int j:nums2) sum2+=j;\\n        \\n        int diff = sum1 - sum2;\\n        \\n        if(diff == 0){\\n            return 0;\\n        }\\n        return diff >0 ? solver(nums1,nums2,diff) : solver(nums2,nums1,-diff);\\n        \\n    }\\n    \\n    static int solver(int[] nums1,int[] nums2,int diff){\\n        int count[] = new int[6];\\n        \\n        for(int i:nums1) count[i-1]++;\\n        for(int k:nums2) count[6-k]++;\\n        \\n        int sum = 0;\\n        for(int j=5;j>0;j--){\\n            int c = Math.min(count[j],diff/j + (diff% j== 0 ? 0 : 1));\\n            \\n            sum+=c;\\n            diff-=c*j;\\n            \\n            if(diff<=0){\\n                break;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums1, int[] nums2) {\\n        int l1 = nums1.length;\\n        int l2 = nums2.length;\\n        \\n        if(l1 > 6 * l2 || l2 > 6 * l1){\\n            return -1;\\n        }\\n        \\n        int sum1 = 0;\\n        int sum2 = 0;\\n        \\n        for(int i:nums1) sum1+=i;\\n        for(int j:nums2) sum2+=j;\\n        \\n        int diff = sum1 - sum2;\\n        \\n        if(diff == 0){\\n            return 0;\\n        }\\n        return diff >0 ? solver(nums1,nums2,diff) : solver(nums2,nums1,-diff);\\n        \\n    }\\n    \\n    static int solver(int[] nums1,int[] nums2,int diff){\\n        int count[] = new int[6];\\n        \\n        for(int i:nums1) count[i-1]++;\\n        for(int k:nums2) count[6-k]++;\\n        \\n        int sum = 0;\\n        for(int j=5;j>0;j--){\\n            int c = Math.min(count[j],diff/j + (diff% j== 0 ? 0 : 1));\\n            \\n            sum+=c;\\n            diff-=c*j;\\n            \\n            if(diff<=0){\\n                break;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045512,
                "title": "python-hashmap-greedy-fast-approach",
                "content": "(1) first decide the -1 impossible case;\\n(2) count the frequencies in two arrays;\\n(3) greedy, decrease the array with larger sum and increase the small array with smaller sum;\\n(4) just manipulate the frequency and the remaining difference of sums\\n\\n\\n```\\ndef minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1)<len(nums2):\\n            nums1,nums2=nums2,nums1\\n        if len(nums1)>6*len(nums2):\\n            return -1\\n        if sum(nums1)<sum(nums2):\\n            nums1,nums2=nums2,nums1\\n        m1=Counter(nums1)\\n        m2=Counter(nums2)\\n        dif=sum(nums1)-sum(nums2)\\n        if dif==0:\\n            return 0\\n        res=0\\n        for i in range(6):\\n            ct=m1[6-i]+m2[i+1]\\n            delta=6-(i+1)\\n            if delta<=0:\\n                continue\\n            need=dif//delta\\n            rem=dif%delta\\n            if need<ct:\\n                res+=need+(1 if rem>0 else 0)\\n                dif=0\\n                return res\\n            elif need==ct:\\n                res+=need\\n                dif=rem\\n            else:\\n                res+=ct\\n                dif-=delta*ct\\n        return res",
                "solutionTags": [],
                "code": "(1) first decide the -1 impossible case;\\n(2) count the frequencies in two arrays;\\n(3) greedy, decrease the array with larger sum and increase the small array with smaller sum;\\n(4) just manipulate the frequency and the remaining difference of sums\\n\\n\\n```\\ndef minOperations(self, nums1: List[int], nums2: List[int]) -> int:\\n        if len(nums1)<len(nums2):\\n            nums1,nums2=nums2,nums1\\n        if len(nums1)>6*len(nums2):\\n            return -1\\n        if sum(nums1)<sum(nums2):\\n            nums1,nums2=nums2,nums1\\n        m1=Counter(nums1)\\n        m2=Counter(nums2)\\n        dif=sum(nums1)-sum(nums2)\\n        if dif==0:\\n            return 0\\n        res=0\\n        for i in range(6):\\n            ct=m1[6-i]+m2[i+1]\\n            delta=6-(i+1)\\n            if delta<=0:\\n                continue\\n            need=dif//delta\\n            rem=dif%delta\\n            if need<ct:\\n                res+=need+(1 if rem>0 else 0)\\n                dif=0\\n                return res\\n            elif need==ct:\\n                res+=need\\n                dif=rem\\n            else:\\n                res+=ct\\n                dif-=delta*ct\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2041288,
                "title": "sort-and-greedy-simulation",
                "content": "```cpp\\nint n1 = nums1.size();\\nint n2 = nums2.size();\\n\\n// check if the lower bound and the upper bound of the two arrays are overlapping.\\nint ub1 = n1 * 6;\\nint lb1 = n1;\\nint ub2 = n2 * 6;\\nint lb2 = n2;\\n\\nif (ub1 < lb2 || ub2 < lb1)\\n\\treturn -1;\\n\\n// the sum of two arrays.\\nint s1 = accumulate(begin(nums1), end(nums1), 0);\\nint s2 = accumulate(begin(nums2), end(nums2), 0);\\n\\n// let\\'s assume sum(nums1) >= sum(nums2), without loss of generality\\nif (s1 < s2)\\n\\treturn minOperations(nums2, nums1);\\n\\n// sort nums1 descendingly, since we assume sum(nums1) is larger, we start from the largest element and try to decrease it.\\n// sort nums2 ascendingly, we start from the smallest elemnt and try to increase it.\\nsort(begin(nums1), end(nums1), greater());\\nsort(begin(nums2), end(nums2));\\n\\n// two indexes for nums1 and nums2.\\nint i = 0;\\nint j = 0;\\n// the counter of operation.\\nint c = 0;\\n// difference\\nint ds = 0;\\nint d1 = 0;\\nint d2 = 0;\\n\\n// while sum1 still larger than sum2 and there are still elements to consider in both array.\\nwhile ((ds = s1 - s2) > 0 && i < n1 && j < n2)\\n{\\n\\t// the difference if we make the current element of nums1 become 1 and\\n\\t// the difference if we make the current element of nums2 become 6\\n\\td1 = nums1[i] - 1;\\n\\td2 = 6 - nums2[j];\\n\\t\\n\\t// if we apply the operation on nums1 will gain us more benefit,\\n\\t// we do it and consider next element.\\n\\tif (d1 > d2)\\n\\t{\\n\\t\\ts1 -= d1;\\n\\t\\t++ i;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\ts2 += d2;\\n\\t\\t++ j;\\n\\t}\\n\\t\\n\\t++ c;\\n}\\n\\n// while sum1 still larger than sum2, but there are only elements in nums1 left to consider\\nwhile (ds > 0 && i < n1)\\n{\\n\\tds -= nums1[i] - 1;\\n\\t++ i;\\n\\t++ c;\\n}\\n\\n// similarly, but only elements in nums2 left.\\nwhile (ds > 0 && j < n2)\\n{\\n\\tds -= 6 - nums2[j];\\n\\t++ j;\\n\\t++ c;\\n}\\n\\nreturn c;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```cpp\\nint n1 = nums1.size();\\nint n2 = nums2.size();\\n\\n// check if the lower bound and the upper bound of the two arrays are overlapping.\\nint ub1 = n1 * 6;\\nint lb1 = n1;\\nint ub2 = n2 * 6;\\nint lb2 = n2;\\n\\nif (ub1 < lb2 || ub2 < lb1)\\n\\treturn -1;\\n\\n// the sum of two arrays.\\nint s1 = accumulate(begin(nums1), end(nums1), 0);\\nint s2 = accumulate(begin(nums2), end(nums2), 0);\\n\\n// let\\'s assume sum(nums1) >= sum(nums2), without loss of generality\\nif (s1 < s2)\\n\\treturn minOperations(nums2, nums1);\\n\\n// sort nums1 descendingly, since we assume sum(nums1) is larger, we start from the largest element and try to decrease it.\\n// sort nums2 ascendingly, we start from the smallest elemnt and try to increase it.\\nsort(begin(nums1), end(nums1), greater());\\nsort(begin(nums2), end(nums2));\\n\\n// two indexes for nums1 and nums2.\\nint i = 0;\\nint j = 0;\\n// the counter of operation.\\nint c = 0;\\n// difference\\nint ds = 0;\\nint d1 = 0;\\nint d2 = 0;\\n\\n// while sum1 still larger than sum2 and there are still elements to consider in both array.\\nwhile ((ds = s1 - s2) > 0 && i < n1 && j < n2)\\n{\\n\\t// the difference if we make the current element of nums1 become 1 and\\n\\t// the difference if we make the current element of nums2 become 6\\n\\td1 = nums1[i] - 1;\\n\\td2 = 6 - nums2[j];\\n\\t\\n\\t// if we apply the operation on nums1 will gain us more benefit,\\n\\t// we do it and consider next element.\\n\\tif (d1 > d2)\\n\\t{\\n\\t\\ts1 -= d1;\\n\\t\\t++ i;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\ts2 += d2;\\n\\t\\t++ j;\\n\\t}\\n\\t\\n\\t++ c;\\n}\\n\\n// while sum1 still larger than sum2, but there are only elements in nums1 left to consider\\nwhile (ds > 0 && i < n1)\\n{\\n\\tds -= nums1[i] - 1;\\n\\t++ i;\\n\\t++ c;\\n}\\n\\n// similarly, but only elements in nums2 left.\\nwhile (ds > 0 && j < n2)\\n{\\n\\tds -= 6 - nums2[j];\\n\\t++ j;\\n\\t++ c;\\n}\\n\\nreturn c;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2010370,
                "title": "c-o-m-n-with-comments",
                "content": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums1, int[] nums2) {\\n        //Only one case makes the solution impossible: One array is more than 6 times longer than the other\\n        if (Math.Max(nums1.Length, nums2.Length) > \\n           Math.Min(nums1.Length, nums2.Length) * 6)\\n        {\\n            return -1;\\n        }\\n        \\n        var sum1 = nums1.Sum(); \\n        var sum2 = nums2.Sum(); \\n        \\n        //Get the frequencies of numbers in each of the arrays\\n        var freq1 = new int[7];\\n        foreach (var n in nums1)\\n        {\\n            freq1[n]++;\\n        }\\n        \\n        var freq2 = new int[7];\\n        foreach (var n in nums2)\\n        {\\n            freq2[n]++;\\n        }\\n        \\n        var minSum = Math.Min(sum1, sum2);\\n        var maxSum = Math.Max(sum1, sum2);\\n        \\n        var minArray = minSum == sum1 ? freq1 : freq2;\\n        var maxArray = maxSum == sum1 ? freq1 : freq2; \\n        \\n        var i = 1;\\n        var j = 6;\\n        var ops = 0;\\n        while (maxSum > minSum)\\n        {\\n            //Start looking for the best numbers to replace in each array \\n            while (i <= 5 && minArray[i] <= 0 ) //for the minArray - from 1 to 5 (cause 6 could not be replaced by anything higher)\\n                i++;\\n            \\n            while (j >= 2 && maxArray[j] <= 0 ) //for the maxArray - from 6 to 2 (cause 1 could not be replaced by anything lower)\\n                j--;\\n            \\n            var inc = 6 - i; //Best possible increment so far\\n            var dec = j - 1; //Best possible decrement so far\\n            \\n            if (inc > dec) \\n            {\\n                var reps = (maxSum - minSum)/inc; //The number of such increments we have to take to equalize the sums\\n                if ((maxSum - minSum) % inc != 0) //One additional non full increment (to a number lower than 6)\\n                    reps++;\\n\\n                var opsThisStep = Math.Min(minArray[i], reps); //Number of operations \\n                minSum += opsThisStep * inc;\\n                ops += opsThisStep;\\n                minArray[i] = 0; //We either used up all of the numbers, or got the answer\\n            }\\n            else\\n            {\\n                var reps = (maxSum - minSum)/dec; //The number of such decrements we have to take to equalize the sums\\n                if ((maxSum - minSum) % dec != 0) //One additional non full decrement (to a number higher than 1)\\n                    reps++;\\n\\n                var opsThisStep = Math.Min(maxArray[j], reps);\\n                maxSum -= opsThisStep * dec;\\n                ops += opsThisStep;\\n                maxArray[j] = 0; //We either used up all of the numbers, or got the answer\\n            }\\n            \\n        }\\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums1, int[] nums2) {\\n        //Only one case makes the solution impossible: One array is more than 6 times longer than the other\\n        if (Math.Max(nums1.Length, nums2.Length) > \\n           Math.Min(nums1.Length, nums2.Length) * 6)\\n        {\\n            return -1;\\n        }\\n        \\n        var sum1 = nums1.Sum(); \\n        var sum2 = nums2.Sum(); \\n        \\n        //Get the frequencies of numbers in each of the arrays\\n        var freq1 = new int[7];\\n        foreach (var n in nums1)\\n        {\\n            freq1[n]++;\\n        }\\n        \\n        var freq2 = new int[7];\\n        foreach (var n in nums2)\\n        {\\n            freq2[n]++;\\n        }\\n        \\n        var minSum = Math.Min(sum1, sum2);\\n        var maxSum = Math.Max(sum1, sum2);\\n        \\n        var minArray = minSum == sum1 ? freq1 : freq2;\\n        var maxArray = maxSum == sum1 ? freq1 : freq2; \\n        \\n        var i = 1;\\n        var j = 6;\\n        var ops = 0;\\n        while (maxSum > minSum)\\n        {\\n            //Start looking for the best numbers to replace in each array \\n            while (i <= 5 && minArray[i] <= 0 ) //for the minArray - from 1 to 5 (cause 6 could not be replaced by anything higher)\\n                i++;\\n            \\n            while (j >= 2 && maxArray[j] <= 0 ) //for the maxArray - from 6 to 2 (cause 1 could not be replaced by anything lower)\\n                j--;\\n            \\n            var inc = 6 - i; //Best possible increment so far\\n            var dec = j - 1; //Best possible decrement so far\\n            \\n            if (inc > dec) \\n            {\\n                var reps = (maxSum - minSum)/inc; //The number of such increments we have to take to equalize the sums\\n                if ((maxSum - minSum) % inc != 0) //One additional non full increment (to a number lower than 6)\\n                    reps++;\\n\\n                var opsThisStep = Math.Min(minArray[i], reps); //Number of operations \\n                minSum += opsThisStep * inc;\\n                ops += opsThisStep;\\n                minArray[i] = 0; //We either used up all of the numbers, or got the answer\\n            }\\n            else\\n            {\\n                var reps = (maxSum - minSum)/dec; //The number of such decrements we have to take to equalize the sums\\n                if ((maxSum - minSum) % dec != 0) //One additional non full decrement (to a number higher than 1)\\n                    reps++;\\n\\n                var opsThisStep = Math.Min(maxArray[j], reps);\\n                maxSum -= opsThisStep * dec;\\n                ops += opsThisStep;\\n                maxArray[j] = 0; //We either used up all of the numbers, or got the answer\\n            }\\n            \\n        }\\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994207,
                "title": "javascript-greedy-solution",
                "content": "```js\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minOperations = function(nums1, nums2) {\\n  if (nums1.length > nums2.length * 6 || nums1.length * 6 < nums2.length) {\\n    return -1;\\n  }\\n  let sum1 = nums1.reduce((p, v) => p + v);\\n  let sum2 = nums2.reduce((p, v) => p + v);\\n  if (sum1 < sum2) {\\n    [nums1, nums2] = [nums2, nums1];\\n    [sum1, sum2] = [sum2, sum1];\\n  }\\n\\n  nums1.sort((a, b) => b - a);\\n  nums2.sort((a, b) => a - b);\\n  let k1 = 0;\\n  let k2 = 0;\\n  let ans = 0;\\n\\n  while (sum1 > sum2) {\\n    const d1 = k1 < nums1.length ? nums1[k1] - 1 : 0;\\n    const d2 = k2 < nums2.length ? 6 - nums2[k2] : 0;\\n    if (d1 >= d2) {\\n      sum1 -= nums1[k1++] - 1;\\n    } else {\\n      sum2 += 6 - nums2[k2++];\\n    }\\n    ans += 1;\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minOperations = function(nums1, nums2) {\\n  if (nums1.length > nums2.length * 6 || nums1.length * 6 < nums2.length) {\\n    return -1;\\n  }\\n  let sum1 = nums1.reduce((p, v) => p + v);\\n  let sum2 = nums2.reduce((p, v) => p + v);\\n  if (sum1 < sum2) {\\n    [nums1, nums2] = [nums2, nums1];\\n    [sum1, sum2] = [sum2, sum1];\\n  }\\n\\n  nums1.sort((a, b) => b - a);\\n  nums2.sort((a, b) => a - b);\\n  let k1 = 0;\\n  let k2 = 0;\\n  let ans = 0;\\n\\n  while (sum1 > sum2) {\\n    const d1 = k1 < nums1.length ? nums1[k1] - 1 : 0;\\n    const d2 = k2 < nums2.length ? 6 - nums2[k2] : 0;\\n    if (d1 >= d2) {\\n      sum1 -= nums1[k1++] - 1;\\n    } else {\\n      sum2 += 6 - nums2[k2++];\\n    }\\n    ans += 1;\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1975439,
                "title": "c-2-priority-queues-max-min",
                "content": "**Idea:**\\n* **Find out the difference of two arrays sum and try to reduce that to zero. But how ??** \\n\\n* **The array whose sum is smaller , will try to increase its sum by increasing the most smaller elements present in the array to larger elements or say in this case , to 6 . This will ensure  maximum margin increment to reach the goal .**\\n\\n* **Conversely, Array whose sum is larger will try to decrease its sum by decreasing the larger elements present to smaller elements possible or in this case, to 1. This will again ensure maximum margin decrement to reach the goal.**\\n\\n* **But How to choose when to decrease and when to increase from the two arrays ?? --> simply pick the one which which provides maximum scope of decreasing the difference and hence making the sum equal in minimum number of steps.**\\n\\n **Priority_Queue is used for tracking the maximum and minium** \\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int s1 = accumulate(begin(nums1),end(nums1),0) ;\\n        int s2 = accumulate(begin(nums2),end(nums2),0) ;\\n        int diff = abs(s1-s2) ;\\n        \\n        if(s1 > s2) return minOperations(nums2,nums1) ;\\n        \\n        //assumed nums1 will have smaller sum than nums2 \\n        \\n        //get smaller elements first from nums1 ensuring maximum margin for increment\\n        priority_queue<int,vector<int>,greater<int>> pq1(begin(nums1),end(nums1)) ;\\n        //get larger elements first from nums2 ensuring maximum margin for decremenet\\n        priority_queue<int> pq2(begin(nums2),end(nums2)) ;\\n        \\n        int operations = 0 ;\\n        \\n        while(pq1.size() and pq2.size() and diff > 0 ){\\n            int margin1 = 6 - pq1.top() ;\\n            int margin2 = pq2.top() - 1 ;\\n            int margin = max(margin1,margin2) ;\\n            if(margin == margin1) pq1.pop() ;\\n            else pq2.pop() ;\\n            ++operations ;\\n            diff -= margin ;\\n        }\\n        \\n        while(pq1.size() and diff > 0 ){\\n            int margin = 6 - pq1.top() ;\\n            pq1.pop() ;\\n            ++operations ;\\n            diff -= margin ;\\n        }\\n        while(pq2.size() and diff > 0 ){\\n            int margin = pq2.top() - 1  ;\\n            pq2.pop() ;\\n            ++operations ;\\n            diff -= margin ;\\n        }\\n        \\n        return diff <=0 ? operations : -1 ;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\\n        int s1 = accumulate(begin(nums1),end(nums1),0) ;\\n        int s2 = accumulate(begin(nums2),end(nums2),0) ;\\n        int diff = abs(s1-s2) ;\\n        \\n        if(s1 > s2) return minOperations(nums2,nums1) ;\\n        \\n        //assumed nums1 will have smaller sum than nums2 \\n        \\n        //get smaller elements first from nums1 ensuring maximum margin for increment\\n        priority_queue<int,vector<int>,greater<int>> pq1(begin(nums1),end(nums1)) ;\\n        //get larger elements first from nums2 ensuring maximum margin for decremenet\\n        priority_queue<int> pq2(begin(nums2),end(nums2)) ;\\n        \\n        int operations = 0 ;\\n        \\n        while(pq1.size() and pq2.size() and diff > 0 ){\\n            int margin1 = 6 - pq1.top() ;\\n            int margin2 = pq2.top() - 1 ;\\n            int margin = max(margin1,margin2) ;\\n            if(margin == margin1) pq1.pop() ;\\n            else pq2.pop() ;\\n            ++operations ;\\n            diff -= margin ;\\n        }\\n        \\n        while(pq1.size() and diff > 0 ){\\n            int margin = 6 - pq1.top() ;\\n            pq1.pop() ;\\n            ++operations ;\\n            diff -= margin ;\\n        }\\n        while(pq2.size() and diff > 0 ){\\n            int margin = pq2.top() - 1  ;\\n            pq2.pop() ;\\n            ++operations ;\\n            diff -= margin ;\\n        }\\n        \\n        return diff <=0 ? operations : -1 ;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1887545,
                "content": [
                    {
                        "username": "gururaj88",
                        "content": "how is this a medium q.. lol"
                    },
                    {
                        "username": "mahad852",
                        "content": "you think it\\'s too easy? i don\\'t think it should be marked easy"
                    }
                ]
            }
        ]
    }
]