[
    {
        "title": "Edit Distance",
        "question_content": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\n\tInsert a character\n\tDelete a character\n\tReplace a character\n\n&nbsp;\nExample 1:\n\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\nExample 2:\n\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n\n&nbsp;\nConstraints:\n\n\t0 <= word1.length, word2.length <= 500\n\tword1 and word2 consist of lowercase English letters.",
        "solutions": [
            {
                "id": 159295,
                "title": "python-solutions-and-intuition",
                "content": "For those having difficulty cracking dynamic programming solutions, I find it easiest to solve by first starting with a naive, but working recursive implementation. It\\'s essential to do so, because dynamic programming is basically recursion with caching. With this workflow, deciphering dynamic programming problems becomes just a little more manageable for us normal people. :)\\n\\n**Thought process:**\\nGiven two strings, we\\'re tasked with finding the minimum number of transformations we need to make to arrive with equivalent strings. From the get-go, there doesn\\'t seem to be any way around trying all possibilities, and in this, possibilities refers to inserting, deleting, or replacing a character. Recursion is usually a good choice for trying all possilbilities. \\n\\nWhenever we write recursive functions, we\\'ll need some way to terminate, or else we\\'ll end up overflowing the stack via infinite recursion. With strings, the natural state to keep track of is the index. We\\'ll need two indexes, one for word1 and one for word2. Now we just need to handle our base cases, and recursive cases. \\nWhat happens when we\\'re done with either word? Some thought will tell you that the minimum number of transformations is simply to insert the rest of the other word. This is our base case. What about when we\\'re not done with either string? We\\'ll either match the currently indexed characters in both strings, or mismatch. In the first case, we don\\'t incur any penalty, and we can continue to compare the rest of the strings by recursing on the rest of both strings. In the case of a mismatch, we either insert, delete, or replace. To recap:\\n1. base case: word1 = \"\" or word2 = \"\" => return length of other string\\n2. recursive case: word1[0] == word2[0] => recurse on word1[1:] and word2[1:]\\n3. recursive case: word1[0] != word2[0] => recurse by inserting, deleting, or replacing \\n\\nAnd in Python:\\n```\\nclass Solution:\\n    def minDistance(self, word1, word2):\\n        \"\"\"Naive recursive solution\"\"\"\\n        if not word1 and not word2:\\n            return 0\\n        if not word1:\\n            return len(word2)\\n        if not word2:\\n            return len(word1)\\n        if word1[0] == word2[0]:\\n            return self.minDistance(word1[1:], word2[1:])\\n        insert = 1 + self.minDistance(word1, word2[1:])\\n        delete = 1 + self.minDistance(word1[1:], word2)\\n        replace = 1 + self.minDistance(word1[1:], word2[1:])\\n        return min(insert, replace, delete)\\n```\\n\\nWith a solution in hand, we\\'re ecstatic and we go to submit our code. All is well until we see the dreaded red text... **TIME LIMIT EXCEEDED**. What did we do wrong? Let\\'s look at a simple example, and for sake of brevity I\\'ll annotate the minDistance function as ```md```. \\n\\nword1 = \"horse\"\\nword2 = \"hello\"\\n\\nThe tree of recursive calls, 3 levels deep, looks like the following. I\\'ve highlighted recursive calls with multiple invocations. So now we see that we\\'re repeating work. I\\'m not going to try and analyze the runtime of this solution, but it\\'s exponential. \\n\\n```\\nmd(\"horse\", \"hello\")\\n\\tmd(\"orse\", \"ello\")\\n\\t\\tmd(\"orse\", \"llo\")\\n\\t\\t\\tmd(\"orse\", \"lo\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <- \\n\\t\\t\\tmd(\"rse\", \"lo\")\\n\\t\\tmd(\"rse\", \"ello\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <-\\n\\t\\t\\tmd(\"se\", \"ello\")\\n\\t\\t\\tmd(\"se\", \"llo\") <<-\\n\\t\\tmd(\"rse\", \"llo\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <-\\n\\t\\t\\tmd(\"se\", \"llo\") <<-\\n\\t\\t\\tmd(\"se\", \"lo\")\\n```\\n\\nThe way we fix this is by **caching**. We save intermediate computations in a dictionary and if we recur on the same subproblem, instead of doing the same work again, we return the saved value. Here is the memoized solution, where we build from bigger subproblems to smaller subproblems (top-down).\\n```\\nclass Solution:\\n    def minDistance(self, word1, word2, i, j, memo):\\n        \"\"\"Memoized solution\"\"\"\\n        if i == len(word1) and j == len(word2):\\n            return 0\\n        if i == len(word1):\\n            return len(word2) - j\\n        if j == len(word2):\\n            return len(word1) - i\\n\\n        if (i, j) not in memo:\\n            if word1[i] == word2[j]:\\n                ans = self.minDistance2(word1, word2, i + 1, j + 1, memo)\\n            else: \\n                insert = 1 + self.minDistance2(word1, word2, i, j + 1, memo)\\n                delete = 1 + self.minDistance2(word1, word2, i + 1, j, memo)\\n                replace = 1 + self.minDistance2(word1, word2, i + 1, j + 1, memo)\\n                ans = min(insert, delete, replace)\\n            memo[(i, j)] = ans\\n        return memo[(i, j)]\\n```\\n\\nOf course, an interative implementation is usually better than its recursive counterpart because we don\\'t risk blowing up our stack in case the number of recursive calls is very deep. We can also use a 2D array to do essentially the same thing as the dictionary of cached values. When we do this, we build up solutions from smaller subproblems to bigger subproblems (bottom-up). In this case, since we are no longer \"recurring\" in the traditional sense, we initialize our 2D table with base constraints. The first row and column of the table has known values since if one string is empty, we simply add the length of the non-empty string since that is the minimum number of edits necessary to arrive at equivalent strings. For both the memoized and dynamic programming solutions, the runtime is ```O(mn)``` and the space complexity is ```O(mn)``` where m and n are the lengths of word1 and word2, respectively.\\n```\\nclass Solution:\\n    def minDistance(self, word1, word2):\\n        \"\"\"Dynamic programming solution\"\"\"\\n        m = len(word1)\\n        n = len(word2)\\n        table = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n        for i in range(m + 1):\\n            table[i][0] = i\\n        for j in range(n + 1):\\n            table[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    table[i][j] = table[i - 1][j - 1]\\n                else:\\n                    table[i][j] = 1 + min(table[i - 1][j], table[i][j - 1], table[i - 1][j - 1])\\n        return table[-1][-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1, word2):\\n        \"\"\"Naive recursive solution\"\"\"\\n        if not word1 and not word2:\\n            return 0\\n        if not word1:\\n            return len(word2)\\n        if not word2:\\n            return len(word1)\\n        if word1[0] == word2[0]:\\n            return self.minDistance(word1[1:], word2[1:])\\n        insert = 1 + self.minDistance(word1, word2[1:])\\n        delete = 1 + self.minDistance(word1[1:], word2)\\n        replace = 1 + self.minDistance(word1[1:], word2[1:])\\n        return min(insert, replace, delete)\\n```\n```md```\n```\\nmd(\"horse\", \"hello\")\\n\\tmd(\"orse\", \"ello\")\\n\\t\\tmd(\"orse\", \"llo\")\\n\\t\\t\\tmd(\"orse\", \"lo\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <- \\n\\t\\t\\tmd(\"rse\", \"lo\")\\n\\t\\tmd(\"rse\", \"ello\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <-\\n\\t\\t\\tmd(\"se\", \"ello\")\\n\\t\\t\\tmd(\"se\", \"llo\") <<-\\n\\t\\tmd(\"rse\", \"llo\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <-\\n\\t\\t\\tmd(\"se\", \"llo\") <<-\\n\\t\\t\\tmd(\"se\", \"lo\")\\n```\n```\\nclass Solution:\\n    def minDistance(self, word1, word2, i, j, memo):\\n        \"\"\"Memoized solution\"\"\"\\n        if i == len(word1) and j == len(word2):\\n            return 0\\n        if i == len(word1):\\n            return len(word2) - j\\n        if j == len(word2):\\n            return len(word1) - i\\n\\n        if (i, j) not in memo:\\n            if word1[i] == word2[j]:\\n                ans = self.minDistance2(word1, word2, i + 1, j + 1, memo)\\n            else: \\n                insert = 1 + self.minDistance2(word1, word2, i, j + 1, memo)\\n                delete = 1 + self.minDistance2(word1, word2, i + 1, j, memo)\\n                replace = 1 + self.minDistance2(word1, word2, i + 1, j + 1, memo)\\n                ans = min(insert, delete, replace)\\n            memo[(i, j)] = ans\\n        return memo[(i, j)]\\n```\n```O(mn)```\n```O(mn)```\n```\\nclass Solution:\\n    def minDistance(self, word1, word2):\\n        \"\"\"Dynamic programming solution\"\"\"\\n        m = len(word1)\\n        n = len(word2)\\n        table = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n        for i in range(m + 1):\\n            table[i][0] = i\\n        for j in range(n + 1):\\n            table[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    table[i][j] = table[i - 1][j - 1]\\n                else:\\n                    table[i][j] = 1 + min(table[i - 1][j], table[i][j - 1], table[i - 1][j - 1])\\n        return table[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25846,
                "title": "c-o-n-space-dp",
                "content": "To apply DP, we define the state `dp[i][j]` to be the minimum number of operations to convert `word1[0..i)` to `word2[0..j)`.\\n\\nFor the base case, that is, to convert a string to an empty string, the mininum number of operations (deletions) is just the length of the string. So we have `dp[i][0] = i` and `dp[0][j] = j`.\\n\\nFor the general case to convert `word1[0..i)` to `word2[0..j)`, we break this problem down into sub-problems. Suppose we have already known how to convert `word1[0..i - 1)` to `word2[0..j - 1)` (`dp[i - 1][j - 1]`), if  `word1[i - 1] == word2[j - 1]`, then no more operation is needed and `dp[i][j] = dp[i - 1][j - 1]`.\\n\\nIf `word1[i - 1] != word2[j - 1]`, we need to consider three cases.\\n\\n 1. **Replace** `word1[i - 1]` by `word2[j - 1]` (`dp[i][j] = dp[i - 1][j - 1] + 1`);\\n 2. If `word1[0..i - 1) = word2[0..j)` then **delete** `word1[i - 1]` (`dp[i][j] = dp[i - 1][j] + 1`);\\n 3. If `word1[0..i) + word2[j - 1] = word2[0..j)` then **insert** `word2[j - 1]` to `word1[0..i)` (`dp[i][j] = dp[i][j - 1] + 1`).\\n\\nSo when `word1[i - 1] != word2[j - 1]`, `dp[i][j]` will just be the minimum of the above three cases.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size();\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        for (int j = 1; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\nNote that each time when we update `dp[i][j]`, we only need `dp[i - 1][j - 1]`, `dp[i][j - 1]` and `dp[i - 1][j]`. We may optimize the space of the code to use only two vectors.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size();\\n        vector<int> pre(n + 1, 0), cur(n + 1, 0);\\n        for (int j = 1; j <= n; j++) {\\n            pre[j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            cur[0] = i;\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    cur[j] = pre[j - 1];\\n                } else {\\n                    cur[j] = min(pre[j - 1], min(cur[j - 1], pre[j])) + 1;\\n                }\\n            }\\n            fill(pre.begin(), pre.end(), 0);\\n            swap(pre, cur);\\n        }\\n        return pre[n];\\n    }\\n};\\n```\\n\\nOr even just one vector.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size(), pre;\\n        vector<int> cur(n + 1, 0);\\n        for (int j = 1; j <= n; j++) {\\n            cur[j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            pre = cur[0];\\n            cur[0] = i;\\n            for (int j = 1; j <= n; j++) {\\n                int temp = cur[j];\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    cur[j] = pre;\\n                } else {\\n                    cur[j] = min(pre, min(cur[j - 1], cur[j])) + 1;\\n                }\\n                pre = temp;\\n            }\\n        }\\n        return cur[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size();\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        for (int j = 1; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size();\\n        vector<int> pre(n + 1, 0), cur(n + 1, 0);\\n        for (int j = 1; j <= n; j++) {\\n            pre[j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            cur[0] = i;\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    cur[j] = pre[j - 1];\\n                } else {\\n                    cur[j] = min(pre[j - 1], min(cur[j - 1], pre[j])) + 1;\\n                }\\n            }\\n            fill(pre.begin(), pre.end(), 0);\\n            swap(pre, cur);\\n        }\\n        return pre[n];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size(), pre;\\n        vector<int> cur(n + 1, 0);\\n        for (int j = 1; j <= n; j++) {\\n            cur[j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            pre = cur[0];\\n            cur[0] = i;\\n            for (int j = 1; j <= n; j++) {\\n                int temp = cur[j];\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    cur[j] = pre;\\n                } else {\\n                    cur[j] = min(pre, min(cur[j - 1], cur[j])) + 1;\\n                }\\n                pre = temp;\\n            }\\n        }\\n        return cur[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25895,
                "title": "step-by-step-explanation-of-how-to-optimize-the-solution-from-simple-recursion-to-dp",
                "content": "First we may want to consider recursion.\\n```\\npublic class Solution {\\n    /**\\n     * Recursive solution.\\n     * For each poisition, check three subproblem:\\n     * 1. insert\\n     * 2. delete\\n     * 3. replace\\n     * We only modify the first string since no matter which one we choose, the result is the same. \\n     * Got TLE since we recursively solve the same subproblem several times.\\n     * Appromixately O(len1 ^ 3) time in the worst case.\\n     * Need to optimize it using cache, which is the idea of dynamic programming. \\n     * The key point is to find out the subproblem we have solved duplicately and cache the recursion.\\n     * Noticed that each subproblem is specificed by i and j pointer, so we can cache the result of these subproblems. \\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word1.length() == 0) return word2.length();\\n        if (word2 == null || word2.length() == 0) return word1.length();\\n        \\n        return match(word1, word2, 0, 0);\\n    }\\n    \\n    private int match(String s1, String s2, int i, int j) {\\n        //If one of the string's pointer have reached the end of it\\n        if (s1.length() == i) {\\n            return s2.length() - j;\\n        }\\n        if (s2.length() == j) {\\n            return s1.length() - i;\\n        }\\n        \\n        int res;\\n        //If current poisition is the same.\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            res = match(s1, s2, i + 1, j + 1);\\n        } else {\\n            //Case1: insert\\n            int insert = match(s1, s2, i, j + 1);\\n            //Case2: delete\\n            int delete = match(s1, s2, i + 1, j);\\n            //Case3: replace\\n            int replace = match(s1, s2, i + 1, j + 1);\\n            res = Math.min(Math.min(insert, delete), replace) + 1;\\n        }\\n        \\n        return res;\\n    }\\n}  \\n```\\nThis got TLE. based on the analysis above, we may try DP. \\n```\\npublic class Solution {\\n    /**\\n     * Optimization using dynamic programming\\n     * Top-down solution\\n     * O(len1 * len2) time, O(len1 * len2) space\\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) return -1;\\n        if (word1.length() == 0) return word2.length();\\n        if (word2.length() == 0) return word1.length();\\n        \\n        char[] c1 = word1.toCharArray();\\n        char[] c2 = word2.toCharArray();\\n        \\n        int[][] cache = new int[c1.length][c2.length];\\n        for (int i = 0; i < c1.length; i++) {\\n            for (int j = 0; j < c2.length; j++) {\\n                cache[i][j] = -1;\\n            }\\n        }\\n        \\n        return match(c1, c2, 0, 0, cache);\\n    }\\n    \\n    private int match(char[] c1, char[] c2, int i, int j, int[][] cache) {\\n        if (c1.length == i) return c2.length - j;\\n        if (c2.length == j) return c1.length - i;\\n        \\n        if (cache[i][j] != -1) {\\n            return cache[i][j];\\n        }\\n        \\n        if (c1[i] == c2[j]) {\\n            cache[i][j] = match(c1, c2, i + 1, j + 1, cache);\\n        } else {\\n            //Case1: insert\\n            int insert = match(c1, c2, i, j + 1, cache);\\n            //Case2: delete\\n            int delete = match(c1, c2, i + 1, j, cache);\\n            //Case3: replace\\n            int replace = match(c1, c2, i + 1, j + 1, cache);\\n            \\n            cache[i][j] = Math.min(Math.min(insert, delete), replace) + 1;\\n        }\\n        \\n        return cache[i][j];\\n    }\\n    \\n    \\n    \\n    \\n    /**\\n     * Bottom-up approach\\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) return -1;\\n        if (word1.length() == 0) return word2.length();\\n        if (word2.length() == 0) return word1.length();\\n        \\n        char[] c1 = word1.toCharArray();\\n        char[] c2 = word2.toCharArray();\\n        \\n        int[][] matched = new int[c1.length + 1][c2.length + 1];\\n        //matched[length of c1 already been matched][length of c2 already been matched]\\n        \\n        for (int i = 0; i <= c1.length; i++) {\\n            matched[i][0] = i;\\n        }\\n        for (int j = 0; j <= c2.length; j++) {\\n            matched[0][j] = j;\\n        }\\n        \\n        for (int i = 0; i < c1.length; i++) {\\n            for (int j = 0; j < c2.length; j++) {\\n                if (c1[i] == c2[j]) {\\n                    matched[i + 1][j + 1] = matched[i][j];\\n                } else {\\n                    matched[i + 1][j + 1] = Math.min(Math.min(matched[i][j + 1], matched[i + 1][j]), matched[i][j]) + 1;\\n                    //Since it is bottom up, we are considering in the ascending order of indexes.\\n                    //Insert means plus 1 to j, delete means plus 1 to i, replace means plus 1 to both i and j. \\n                    //above sequence is delete, insert and replace. \\n                }\\n            }\\n        }\\n        \\n        return matched[c1.length][c2.length];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /**\\n     * Recursive solution.\\n     * For each poisition, check three subproblem:\\n     * 1. insert\\n     * 2. delete\\n     * 3. replace\\n     * We only modify the first string since no matter which one we choose, the result is the same. \\n     * Got TLE since we recursively solve the same subproblem several times.\\n     * Appromixately O(len1 ^ 3) time in the worst case.\\n     * Need to optimize it using cache, which is the idea of dynamic programming. \\n     * The key point is to find out the subproblem we have solved duplicately and cache the recursion.\\n     * Noticed that each subproblem is specificed by i and j pointer, so we can cache the result of these subproblems. \\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word1.length() == 0) return word2.length();\\n        if (word2 == null || word2.length() == 0) return word1.length();\\n        \\n        return match(word1, word2, 0, 0);\\n    }\\n    \\n    private int match(String s1, String s2, int i, int j) {\\n        //If one of the string's pointer have reached the end of it\\n        if (s1.length() == i) {\\n            return s2.length() - j;\\n        }\\n        if (s2.length() == j) {\\n            return s1.length() - i;\\n        }\\n        \\n        int res;\\n        //If current poisition is the same.\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            res = match(s1, s2, i + 1, j + 1);\\n        } else {\\n            //Case1: insert\\n            int insert = match(s1, s2, i, j + 1);\\n            //Case2: delete\\n            int delete = match(s1, s2, i + 1, j);\\n            //Case3: replace\\n            int replace = match(s1, s2, i + 1, j + 1);\\n            res = Math.min(Math.min(insert, delete), replace) + 1;\\n        }\\n        \\n        return res;\\n    }\\n}  \\n```\n```\\npublic class Solution {\\n    /**\\n     * Optimization using dynamic programming\\n     * Top-down solution\\n     * O(len1 * len2) time, O(len1 * len2) space\\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) return -1;\\n        if (word1.length() == 0) return word2.length();\\n        if (word2.length() == 0) return word1.length();\\n        \\n        char[] c1 = word1.toCharArray();\\n        char[] c2 = word2.toCharArray();\\n        \\n        int[][] cache = new int[c1.length][c2.length];\\n        for (int i = 0; i < c1.length; i++) {\\n            for (int j = 0; j < c2.length; j++) {\\n                cache[i][j] = -1;\\n            }\\n        }\\n        \\n        return match(c1, c2, 0, 0, cache);\\n    }\\n    \\n    private int match(char[] c1, char[] c2, int i, int j, int[][] cache) {\\n        if (c1.length == i) return c2.length - j;\\n        if (c2.length == j) return c1.length - i;\\n        \\n        if (cache[i][j] != -1) {\\n            return cache[i][j];\\n        }\\n        \\n        if (c1[i] == c2[j]) {\\n            cache[i][j] = match(c1, c2, i + 1, j + 1, cache);\\n        } else {\\n            //Case1: insert\\n            int insert = match(c1, c2, i, j + 1, cache);\\n            //Case2: delete\\n            int delete = match(c1, c2, i + 1, j, cache);\\n            //Case3: replace\\n            int replace = match(c1, c2, i + 1, j + 1, cache);\\n            \\n            cache[i][j] = Math.min(Math.min(insert, delete), replace) + 1;\\n        }\\n        \\n        return cache[i][j];\\n    }\\n    \\n    \\n    \\n    \\n    /**\\n     * Bottom-up approach\\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) return -1;\\n        if (word1.length() == 0) return word2.length();\\n        if (word2.length() == 0) return word1.length();\\n        \\n        char[] c1 = word1.toCharArray();\\n        char[] c2 = word2.toCharArray();\\n        \\n        int[][] matched = new int[c1.length + 1][c2.length + 1];\\n        //matched[length of c1 already been matched][length of c2 already been matched]\\n        \\n        for (int i = 0; i <= c1.length; i++) {\\n            matched[i][0] = i;\\n        }\\n        for (int j = 0; j <= c2.length; j++) {\\n            matched[0][j] = j;\\n        }\\n        \\n        for (int i = 0; i < c1.length; i++) {\\n            for (int j = 0; j < c2.length; j++) {\\n                if (c1[i] == c2[j]) {\\n                    matched[i + 1][j + 1] = matched[i][j];\\n                } else {\\n                    matched[i + 1][j + 1] = Math.min(Math.min(matched[i][j + 1], matched[i + 1][j]), matched[i][j]) + 1;\\n                    //Since it is bottom up, we are considering in the ascending order of indexes.\\n                    //Insert means plus 1 to j, delete means plus 1 to i, replace means plus 1 to both i and j. \\n                    //above sequence is delete, insert and replace. \\n                }\\n            }\\n        }\\n        \\n        return matched[c1.length][c2.length];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25849,
                "title": "java-dp-solution-o-nm",
                "content": "Let following be the function definition :-\\n\\nf(i, j) := minimum cost (or steps) required to convert first i characters of word1 to first j characters of word2\\n\\nCase 1: word1[i] == word2[j], i.e. the ith the jth character matches.\\n\\n> f(i, j) = f(i - 1, j - 1)\\n\\nCase 2: word1[i] != word2[j], then we must either insert, delete or replace, whichever is cheaper\\n\\n> f(i, j) = 1 + min { f(i, j - 1), f(i - 1, j), f(i - 1, j - 1) }\\n\\n1. f(i, j - 1) represents insert operation\\n2. f(i - 1, j) represents delete operation\\n3. f(i - 1, j - 1) represents replace operation\\n\\nHere, we consider any operation from word1 to word2. It means, when we say insert operation, we insert a new character after word1 that matches the jth character of word2. So, now have to match i characters of word1 to j - 1 characters of word2. Same goes for other 2 operations as well.\\n\\nNote that the problem is symmetric. The insert operation in one direction (i.e. from word1 to word2) is same as delete operation in other. So, we could choose any direction.\\n\\nAbove equations become the recursive definitions for DP.\\n\\nBase Case: \\n\\n> f(0, k) = f(k, 0) = k\\n\\nBelow is the direct bottom-up translation of this recurrent relation. It is only important to take care of 0-based index with actual code :-\\n\\n    public class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int m = word1.length();\\n            int n = word2.length();\\n            \\n            int[][] cost = new int[m + 1][n + 1];\\n            for(int i = 0; i <= m; i++)\\n                cost[i][0] = i;\\n            for(int i = 1; i <= n; i++)\\n                cost[0][i] = i;\\n            \\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(word1.charAt(i) == word2.charAt(j))\\n                        cost[i + 1][j + 1] = cost[i][j];\\n                    else {\\n                        int a = cost[i][j];\\n                        int b = cost[i][j + 1];\\n                        int c = cost[i + 1][j];\\n                        cost[i + 1][j + 1] = a < b ? (a < c ? a : c) : (b < c ? b : c);\\n                        cost[i + 1][j + 1]++;\\n                    }\\n                }\\n            }\\n            return cost[m][n];\\n        }\\n    }\\n\\nTime complexity : If n is the length of word1, m of word2, because of the two indented loops, it is O(nm)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int m = word1.length();\\n            int n = word2.length();\\n            \\n            int[][] cost = new int[m + 1][n + 1];\\n            for(int i = 0; i <= m; i++)\\n                cost[i][0] = i;\\n            for(int i = 1; i <= n; i++)\\n                cost[0][i] = i;\\n            \\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(word1.charAt(i) == word2.charAt(j))\\n                        cost[i + 1][j + 1] = cost[i][j];\\n                    else {\\n                        int a = cost[i][j];\\n                        int b = cost[i][j + 1];\\n                        int c = cost[i + 1][j];\\n                        cost[i + 1][j + 1] = a < b ? (a < c ? a : c) : (b < c ? b : c);\\n                        cost[i + 1][j + 1]++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3230662,
                "title": "clean-codes-full-explanation-dynamic-programming-c-java-python3",
                "content": "# Intuition :\\n- Here we have to find the minimum edit distance problem between two strings word1 and word2. \\n- The minimum edit distance is defined as the minimum number of operations required to transform one string into another.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\n- The approach here that I am using is dynamic programming. The idea is to build a 2D matrix dp where `dp[i][j] `represents the minimum number of operations required to transform the substring `word1[0...i-1]` into the substring `word2[0...j-1].`\\n# How is Matrix built :\\n- The matrix is built iteratively using the following recurrence relation:\\n1. If `word1[i-1] == word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`. That is, no operation is required because the characters at positions `i-1` and `j-1` are already the same.\\n2. Otherwise, `dp[i][j]` is the minimum of the following three values:\\n- `dp[i-1][j-1] + 1`: replace the character at position `i-1` in `word1` with the character at position `j-1` in` word2`.\\n- `dp[i-1][j] + 1`: delete the character at position `i-1` in `word1.`\\n- `dp[i][j-1] + 1`: insert the character at position `j-1` in `word2` into `word1` at position `i`.\\n# The base cases are:\\n- `dp[i][0] = i`: transforming `word1[0...i-1]` into an empty string requires `i` deletions.\\n- `dp[0][j] = j`: transforming an empty string into `word2[0...j-1] `requires `j` insertions.\\n<!-- Describe your approach to solving the problem. -->\\n# Final Step :\\n- Finally, return `dp[m][n]`, which represents the minimum number of operations required to transform `word1 `into `word2`, where `m` is the length of `word1` and `n` is the length of `word2`.\\n\\n# Complexity\\n- Time complexity : O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ |Java |Python3] : With Comments\\n```C++ []\\nclass Solution {\\n public:\\n  int minDistance(string word1, string word2) {\\n    const int m = word1.length();//first word length\\n    const int n = word2.length();//second word length\\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n\\n    for (int i = 1; i <= m; ++i)\\n      dp[i][0] = i;\\n\\n    for (int j = 1; j <= n; ++j)\\n      dp[0][j] = j;\\n\\n    for (int i = 1; i <= m; ++i)\\n      for (int j = 1; j <= n; ++j)\\n        if (word1[i - 1] == word2[j - 1])//same characters\\n          dp[i][j] = dp[i - 1][j - 1];//no operation\\n        else\\n          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\\n                             //replace       //delete        //insert\\n    return dp[m][n];\\n  }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public int minDistance(String word1, String word2) {\\n    final int m = word1.length();//first word length\\n    final int n = word2.length();///second word length\\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\\n    int[][] dp = new int[m + 1][n + 1];\\n\\n    for (int i = 1; i <= m; ++i)\\n      dp[i][0] = i;\\n\\n    for (int j = 1; j <= n; ++j)\\n      dp[0][j] = j;\\n\\n    for (int i = 1; i <= m; ++i)\\n      for (int j = 1; j <= n; ++j)\\n        if (word1.charAt(i - 1) == word2.charAt(j - 1))//same characters\\n          dp[i][j] = dp[i - 1][j - 1];//no operation\\n        else\\n          dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;                      //replace               //delete        //insert\\n\\n    return dp[m][n];\\n  }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n  def minDistance(self, word1: str, word2: str) -> int:\\n    m = len(word1)\\n    n = len(word2)\\n    # dp[i][j] := min # Of operations to convert word1[0..i) to word2[0..j)\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n    for i in range(1, m + 1):\\n      dp[i][0] = i\\n\\n    for j in range(1, n + 1):\\n      dp[0][j] = j\\n\\n    for i in range(1, m + 1):\\n      for j in range(1, n + 1):\\n        if word1[i - 1] == word2[j - 1]:\\n          dp[i][j] = dp[i - 1][j - 1]\\n        else:\\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\\n\\n    return dp[m][n]\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/399bb888-6ae6-4614-a338-fe33088c118d_1677378017.7506878.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution {\\n public:\\n  int minDistance(string word1, string word2) {\\n    const int m = word1.length();//first word length\\n    const int n = word2.length();//second word length\\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n\\n    for (int i = 1; i <= m; ++i)\\n      dp[i][0] = i;\\n\\n    for (int j = 1; j <= n; ++j)\\n      dp[0][j] = j;\\n\\n    for (int i = 1; i <= m; ++i)\\n      for (int j = 1; j <= n; ++j)\\n        if (word1[i - 1] == word2[j - 1])//same characters\\n          dp[i][j] = dp[i - 1][j - 1];//no operation\\n        else\\n          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\\n                             //replace       //delete        //insert\\n    return dp[m][n];\\n  }\\n};\\n```\n```Java []\\nclass Solution {\\n  public int minDistance(String word1, String word2) {\\n    final int m = word1.length();//first word length\\n    final int n = word2.length();///second word length\\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\\n    int[][] dp = new int[m + 1][n + 1];\\n\\n    for (int i = 1; i <= m; ++i)\\n      dp[i][0] = i;\\n\\n    for (int j = 1; j <= n; ++j)\\n      dp[0][j] = j;\\n\\n    for (int i = 1; i <= m; ++i)\\n      for (int j = 1; j <= n; ++j)\\n        if (word1.charAt(i - 1) == word2.charAt(j - 1))//same characters\\n          dp[i][j] = dp[i - 1][j - 1];//no operation\\n        else\\n          dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;                      //replace               //delete        //insert\\n\\n    return dp[m][n];\\n  }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n  def minDistance(self, word1: str, word2: str) -> int:\\n    m = len(word1)\\n    n = len(word2)\\n    # dp[i][j] := min # Of operations to convert word1[0..i) to word2[0..j)\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n    for i in range(1, m + 1):\\n      dp[i][0] = i\\n\\n    for j in range(1, n + 1):\\n      dp[0][j] = j\\n\\n    for i in range(1, m + 1):\\n      for j in range(1, n + 1):\\n        if word1[i - 1] == word2[j - 1]:\\n          dp[i][j] = dp[i - 1][j - 1]\\n        else:\\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\\n\\n    return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25911,
                "title": "my-o-mn-time-and-o-n-space-solution-using-dp-with-explanation",
                "content": "Use f[i][j] to represent the shortest edit distance between word1[0,i) and word2[0, j). Then compare the last character of word1[0,i) and word2[0,j), which are c and d respectively (c == word1[i-1], d == word2[j-1]):\\n\\nif c == d, then : f[i][j] = f[i-1][j-1]\\n\\nOtherwise we can use three operations to convert word1 to word2:\\n\\n(a) if we replaced c with d: f[i][j] = f[i-1][j-1] + 1;\\n\\n(b) if we added d after c: f[i][j] = f[i][j-1] + 1;\\n\\n(c) if we deleted c: f[i][j] = f[i-1][j] + 1;\\n\\n\\nNote that f[i][j] only depends on f[i-1][j-1], f[i-1][j] and f[i][j-1], therefore we can reduce the space to O(n) by using only the (i-1)th array and previous updated element(f[i][j-1]). \\n\\n\\n\\n     int minDistance(string word1, string word2) {\\n        \\n            int l1 = word1.size();\\n            int l2 = word2.size();\\n        \\n            vector<int> f(l2+1, 0);\\n            for (int j = 1; j <= l2; ++j)\\n                f[j] = j;\\n        \\n            for (int i = 1; i <= l1; ++i)\\n            {\\n                int prev = i;\\n                for (int j = 1; j <= l2; ++j)\\n                {\\n                    int cur;\\n                    if (word1[i-1] == word2[j-1]) {\\n                        cur = f[j-1];\\n                    } else {\\n                        cur = min(min(f[j-1], prev), f[j]) + 1;\\n                    }\\n        \\n                    f[j-1] = prev;\\n                    prev = cur;\\n                }\\n                f[l2] = prev;\\n            }\\n            return f[l2];\\n        \\n        }  \\n\\n\\nActually at first glance I thought this question was similar to Word Ladder and I tried to solve it using BFS(pretty stupid huh?). But in fact, the main difference is that there's a strict restriction on the intermediate words in Word Ladder problem, while there's no restriction in this problem.  If we added some restriction on intermediate words for this question, I don't think this DP solution would still work.",
                "solutionTags": [],
                "code": "Use f[i][j] to represent the shortest edit distance between word1[0,i) and word2[0, j). Then compare the last character of word1[0,i) and word2[0,j), which are c and d respectively (c == word1[i-1], d == word2[j-1]):\\n\\nif c == d, then : f[i][j] = f[i-1][j-1]\\n\\nOtherwise we can use three operations to convert word1 to word2:\\n\\n(a) if we replaced c with d: f[i][j] = f[i-1][j-1] + 1;\\n\\n(b) if we added d after c: f[i][j] = f[i][j-1] + 1;\\n\\n(c) if we deleted c: f[i][j] = f[i-1][j] + 1;\\n\\n\\nNote that f[i][j] only depends on f[i-1][j-1], f[i-1][j] and f[i][j-1], therefore we can reduce the space to O(n) by using only the (i-1)th array and previous updated element(f[i][j-1]). \\n\\n\\n\\n     int minDistance(string word1, string word2) {\\n        \\n            int l1 = word1.size();\\n            int l2 = word2.size();\\n        \\n            vector<int> f(l2+1, 0);\\n            for (int j = 1; j <= l2; ++j)\\n                f[j] = j;\\n        \\n            for (int i = 1; i <= l1; ++i)\\n            {\\n                int prev = i;\\n                for (int j = 1; j <= l2; ++j)\\n                {\\n                    int cur;\\n                    if (word1[i-1] == word2[j-1]) {\\n                        cur = f[j-1];\\n                    } else {\\n                        cur = min(min(f[j-1], prev), f[j]) + 1;\\n                    }\\n        \\n                    f[j-1] = prev;\\n                    prev = cur;\\n                }\\n                f[l2] = prev;\\n            }\\n            return f[l2];\\n        \\n        }  \\n\\n\\nActually at first glance I thought this question was similar to Word Ladder and I tried to solve it using BFS(pretty stupid huh?). But in fact, the main difference is that there's a strict restriction on the intermediate words in Word Ladder problem, while there's no restriction in this problem.  If we added some restriction on intermediate words for this question, I don't think this DP solution would still work.",
                "codeTag": "Unknown"
            },
            {
                "id": 662240,
                "title": "c-easy-dp-solution-well-commented",
                "content": "```\\nint minDistance(string word1, string word2) {\\n// Create a table to store results of subproblems\\n        int dp[word1.size()+1][word2.size()+1];\\n// If first string is empty, only option is to \\n// insert all characters of second string \\n        for(int k=0; k<=word1.size(); k++)\\n            dp[k][0] = k;\\n// If second string is empty, only option is to \\n// remove all characters of first string\\n        for(int k=0; k<=word2.size(); k++)\\n            dp[0][k] = k;\\n// Fill dp[][] in bottom up manner \\n        for(int i=1; i<=word1.size(); i++){\\n            for(int j=1; j<=word2.size(); j++){\\n//if characters at current position in 2 strings are equal\\n//there will be no new operation so copy value from previous position\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n// If the last character is different, consider all \\n// possibilities and find the minimum\\n                else\\n                    dp[i][j] = 1 + min({dp[i][j - 1], // Insert \\n                                   dp[i - 1][j], // Remove \\n                                   dp[i - 1][j - 1]}); // Replace \\n            }\\n        }\\n        \\n        return dp[word1.size()][word2.size()];\\n    }\\n```\\n**Upvotes are encouraging**",
                "solutionTags": [],
                "code": "```\\nint minDistance(string word1, string word2) {\\n// Create a table to store results of subproblems\\n        int dp[word1.size()+1][word2.size()+1];\\n// If first string is empty, only option is to \\n// insert all characters of second string \\n        for(int k=0; k<=word1.size(); k++)\\n            dp[k][0] = k;\\n// If second string is empty, only option is to \\n// remove all characters of first string\\n        for(int k=0; k<=word2.size(); k++)\\n            dp[0][k] = k;\\n// Fill dp[][] in bottom up manner \\n        for(int i=1; i<=word1.size(); i++){\\n            for(int j=1; j<=word2.size(); j++){\\n//if characters at current position in 2 strings are equal\\n//there will be no new operation so copy value from previous position\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n// If the last character is different, consider all \\n// possibilities and find the minimum\\n                else\\n                    dp[i][j] = 1 + min({dp[i][j - 1], // Insert \\n                                   dp[i - 1][j], // Remove \\n                                   dp[i - 1][j - 1]}); // Replace \\n            }\\n        }\\n        \\n        return dp[word1.size()][word2.size()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1217663,
                "title": "edit-distance-cpp-recursive-memoization-top-down-all-approaches-with-explanation",
                "content": "\\nThis problem is little bit tricky but don\\'t worry we will solve it together.\\nBasically, after reading the question carefully we can see that **we have two choices, either the character will be same or not same**.\\n\\n* So, In the first choice, if the character will be same we don\\'t have to do anything except for the fact that we have to call the function for the rest of the string.\\n\\n* For the second choice, if the character will not be the same we have three operations to do inorder to convert the word1 to word2\\n\\t1. Insert a character\\n\\t2. Delete a character\\n\\t3. Replace a character\\n\\nNow, Let\\'s talk about the operations that we have to perform on word1, I\\'m trying from the right side you can try from left also, depends on you.\\n\\n* So, for **Insert operation**, say for ex - we have two strings\\n`s1 = \"abc\" , s2 = \"bcd\" , m = 3 , n = 3` **i.e.** \\nlengths of the strings respectively `m` and `n` are pointing to the last characters of the string. So we will insert a character  from right side in `s1` and after inserting character string will be `\"abcd\"` and the `m` which  was pointing to `c` in `s1` will be at the same position but the `n` which was pointing to `d` in `s2` now, will point to `c` in `s2` i.e. `m, n-1` for the rest of the function calls.\\n\\n* Now, for **Delete operation**, same example\\n`s1 = \"abc\", s2=\"bcd\", m=3, n=3`\\n`m` and `n` are pointing to the last characters of the string. Now, after deleting a character from `s1` , the `m` will be `m-1` , but the `n`  will be same i.e. `m-1, n`  for the rest of the function calls.\\n\\n* Now, for the **Replace operation**, same example\\n`s1 = \"abc\", s2=\"bcd\", m=3, n=3`\\n`m` and `n` are pointing to the last characters of the string. Ultimately, the character at corresponding positions in strings will be the same after replacing the character in `s1` by\\nthe character in `s2`, \\n**Example** - `\"abc\", \"bcd\"` => replacing c by d => `\"abd\", \"bcd\"`\\nNow, call for the rest of the string, so here `m` will be `m-1` and `n` will be `n-1` , i.e. `m-1, n-1` for the rest of the function calls.\\n\\nNow, we have to take minimum of all the three operations and add to 1\\n\\n* And Let\\'s talk about **base conditions**\\n**Example** - `s1 = \"abc\", s2 = \"bcd\", m=3, n=3`  lengths of strings respectively\\n1. if `m = 0` , then Obviously, we have to insert `n`  characters from `s2`  in `s1`  to make `s2`. \\n2. if `n = 0` , then Obviously, we have to delete `m`  characters in `s1`  to make `s2`.\\n\\n**Recursive**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(min(3^m, 3^n)), Space: O(N);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        return editDistance(word1, word2, m, n);\\n    }\\n    \\n    int editDistance(string& word1, string& word2, int m, int n){\\n\\t\\t\\n\\t\\t//base condition\\n        if(m == 0) return n;\\n        if(n == 0) return m;\\n        \\n        if(word1[m-1] == word2[n-1]) \\n\\t\\t\\treturn editDistance(word1, word2, m-1, n-1);\\n        else{\\n            int insertChar = editDistance(word1, word2, m, n-1);\\n            int deleteChar = editDistance(word1, word2, m-1, n);\\n            int replaceChar = editDistance(word1, word2, m-1, n-1);\\n            \\n            return 1 + min({insertChar, deleteChar, replaceChar});\\n        }\\n    }\\n};\\n```\\n\\n**Recursive + Memoization - TopDown**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        vector<vector<int>> memo(m+1, vector<int>(n+1, -1));\\n        return editDistance(word1, word2, m, n, memo);\\n    }\\n    \\n    int editDistance(string& word1, string& word2, int m, int n, vector<vector<int>>& memo){\\n        if(m == 0) return memo[m][n] = n;\\n        if(n == 0) return memo[m][n] = m;\\n        \\n        if(memo[m][n] != -1)\\n            return memo[m][n];\\n        \\n        if(word1[m-1] == word2[n-1]) \\n            return memo[m][n] = editDistance(word1, word2, m-1, n-1, memo);\\n        else{\\n            int insertChar = editDistance(word1, word2, m, n-1, memo);\\n            int deleteChar = editDistance(word1, word2, m-1, n, memo);\\n            int replaceChar = editDistance(word1, word2, m-1, n-1, memo);\\n            \\n            return memo[m][n] = 1 + min({insertChar, deleteChar, replaceChar});\\n        }\\n    }\\n};\\n```\\n\\n**BottomUp**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        //Base conditions\\n        for(int i=0; i<m+1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int j=0; j<n+1; j++)\\n            dp[0][j] = j;\\n        \\n        //solving the sub-problems\\n        for(int i=1; i<m+1; i++){\\n            for(int j=1; j<n+1; j++){\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int insertChar = dp[i][j-1];\\n                    int deleteChar = dp[i-1][j];\\n                    int replaceChar = dp[i-1][j-1];\\n                    \\n                    dp[i][j] = 1 + min({insertChar, deleteChar, replaceChar});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Time: O(min(3^m, 3^n)), Space: O(N);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        return editDistance(word1, word2, m, n);\\n    }\\n    \\n    int editDistance(string& word1, string& word2, int m, int n){\\n\\t\\t\\n\\t\\t//base condition\\n        if(m == 0) return n;\\n        if(n == 0) return m;\\n        \\n        if(word1[m-1] == word2[n-1]) \\n\\t\\t\\treturn editDistance(word1, word2, m-1, n-1);\\n        else{\\n            int insertChar = editDistance(word1, word2, m, n-1);\\n            int deleteChar = editDistance(word1, word2, m-1, n);\\n            int replaceChar = editDistance(word1, word2, m-1, n-1);\\n            \\n            return 1 + min({insertChar, deleteChar, replaceChar});\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        vector<vector<int>> memo(m+1, vector<int>(n+1, -1));\\n        return editDistance(word1, word2, m, n, memo);\\n    }\\n    \\n    int editDistance(string& word1, string& word2, int m, int n, vector<vector<int>>& memo){\\n        if(m == 0) return memo[m][n] = n;\\n        if(n == 0) return memo[m][n] = m;\\n        \\n        if(memo[m][n] != -1)\\n            return memo[m][n];\\n        \\n        if(word1[m-1] == word2[n-1]) \\n            return memo[m][n] = editDistance(word1, word2, m-1, n-1, memo);\\n        else{\\n            int insertChar = editDistance(word1, word2, m, n-1, memo);\\n            int deleteChar = editDistance(word1, word2, m-1, n, memo);\\n            int replaceChar = editDistance(word1, word2, m-1, n-1, memo);\\n            \\n            return memo[m][n] = 1 + min({insertChar, deleteChar, replaceChar});\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        //Base conditions\\n        for(int i=0; i<m+1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int j=0; j<n+1; j++)\\n            dp[0][j] = j;\\n        \\n        //solving the sub-problems\\n        for(int i=1; i<m+1; i++){\\n            for(int j=1; j<n+1; j++){\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int insertChar = dp[i][j-1];\\n                    int deleteChar = dp[i-1][j];\\n                    int replaceChar = dp[i-1][j-1];\\n                    \\n                    dp[i][j] = 1 + min({insertChar, deleteChar, replaceChar});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475220,
                "title": "python-3-solutions-top-down-dp-bottom-up-dp-o-n-in-space-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP**\\n- Let `dp(i, j)` is the minimum number of operations required to convert `s1[0..i-1]` string to `s2[0..j-1]` string.\\n- Then `dp(len(s1), len(s2))` is our result.\\n- To compute `dp(i, j)`:\\n\\t- Base case: \\n\\t\\t- If `i == 0` then we need to insert `j` chars to convert `\"\"` into `s2[0..j-1]`\\n\\t\\t- If `j == 0` then we need to delete `i` chars to convert `s1[0..i-1]` into `\"\"`.\\n\\t- If `s1[i-1] == s2[j-1]` then `dp(i, j) = dp(i-1, j-1)`.\\n\\t- Else: Choose the minimum cost among 3 operators\\n\\t\\t- Delete: `dp(i-1, j) + 1`\\n\\t\\t- Insert: `dp(i, j-1) + 1`\\n\\t\\t- Replace: `dp(i-1, j-1) + 1`\\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == 0: return j  # Need to insert j chars\\n            if j == 0: return i  # Need to delete i chars\\n            if s1[i-1] == s2[j-1]:\\n                return dp(i-1, j-1)\\n            return min(dp(i-1, j), dp(i, j-1), dp(i-1, j-1)) + 1\\n        \\n        return dp(len(s1), len(s2))\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 500` is length of `s1` string, `N <= 500` is length of `s2` string.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Bottom up DP**\\n- Just convert **Top down DP** into **Bottom up DP**.\\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [[-1] * (n+1) for _ in range(m+1)]\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i == 0:\\n                    dp[i][j] = j  # Need to insert `j` chars to become s2[:j]\\n                elif j == 0:\\n                    dp[i][j] = i  # Need to delete `i` chars to become \"\"\\n                elif s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[m][n]\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 500` is length of `s1` string, `N <= 500` is length of `s2` string.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Bottom up DP (Space Optimized)**\\n- Since we build our dp rows by rows, we access only previous dp state `dpPrev` and current dp state `dp`.\\n- So we can optimize to `O(N)` in Space Complexity.\\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp, dpPrev = [-1] * (n+1), [-1] * (n+1)\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i == 0:\\n                    dp[j] = j  # Need to insert `j` chars to become s2[:j]\\n                elif j == 0:\\n                    dp[j] = i  # Need to delete `i` chars to become \"\"\\n                elif s1[i-1] == s2[j-1]:\\n                    dp[j] = dpPrev[j-1]\\n                else:\\n                    dp[j] = min(dpPrev[j], dp[j-1], dpPrev[j-1]) + 1\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[n]\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 500` is length of `s1` string, `N <= 500` is length of `s2` string.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == 0: return j  # Need to insert j chars\\n            if j == 0: return i  # Need to delete i chars\\n            if s1[i-1] == s2[j-1]:\\n                return dp(i-1, j-1)\\n            return min(dp(i-1, j), dp(i, j-1), dp(i-1, j-1)) + 1\\n        \\n        return dp(len(s1), len(s2))\\n```\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [[-1] * (n+1) for _ in range(m+1)]\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i == 0:\\n                    dp[i][j] = j  # Need to insert `j` chars to become s2[:j]\\n                elif j == 0:\\n                    dp[i][j] = i  # Need to delete `i` chars to become \"\"\\n                elif s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[m][n]\\n```\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp, dpPrev = [-1] * (n+1), [-1] * (n+1)\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i == 0:\\n                    dp[j] = j  # Need to insert `j` chars to become s2[:j]\\n                elif j == 0:\\n                    dp[j] = i  # Need to delete `i` chars to become \"\"\\n                elif s1[i-1] == s2[j-1]:\\n                    dp[j] = dpPrev[j-1]\\n                else:\\n                    dp[j] = min(dpPrev[j], dp[j-1], dpPrev[j-1]) + 1\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501094,
                "title": "c-recursive-memoization-and-tabulation-method",
                "content": "Recursive \\n```\\nclass Solution {\\npublic:\\n    \\n    int editDis(string& word1, string& word2, int n1, int n2)\\n    {\\n        if(n1 == 0)\\n            return n2;\\n        if(n2 == 0)\\n            return n1;\\n       // cout<<n1<<\" \"<<n2<<endl;\\n        if(word1[n1-1] == word2[n2-1]) {\\n            return editDis(word1, word2, n1-1, n2-1);\\n        }\\n            \\n        return 1+min(editDis(word1, word2, n1, n2-1),\\n                  min(editDis(word1, word2, n1-1, n2),\\n                  editDis(word1, word2, n1-1, n2-1)));\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        return editDis(word1, word2, n1, n2);\\n        \\n    }\\n};\\n```\\nMemoization:\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int editDis(string& word1, string& word2, int n1, int n2)\\n    {\\n        if(n1 == 0)\\n            return n2;\\n        if(n2 == 0)\\n            return n1;\\n       // cout<<n1<<\" \"<<n2<<endl;\\n        if(dp[n1][n2] !=-1)\\n        {\\n            return dp[n1][n2];\\n        }\\n        if(word1[n1-1] == word2[n2-1]) {\\n            dp[n1][n2] = editDis(word1, word2, n1-1, n2-1);\\n            return dp[n1][n2];\\n        }\\n            \\n        dp[n1][n2]=  1+min(editDis(word1, word2, n1, n2-1),\\n                  min(editDis(word1, word2, n1-1, n2),\\n                  editDis(word1, word2, n1-1, n2-1)));\\n        return dp[n1][n2];\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        for(int i=0;i<=n1+1;i++)\\n        {\\n            for(int j=0;j<=n2+1;j++)\\n            {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        dp[n1][n2] = editDis(word1, word2, n1, n2);\\n        return dp[n1][n2];\\n        \\n    }\\n};\\n```\\n\\nTabulation\\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        int dp[n1+2][n2+2];\\n        \\n        for(int i=0;i<n1+1;i++)\\n        {\\n             dp[i][0] = i;\\n        }\\n        \\n        for(int i=0;i<n2+1;i++)\\n        {\\n             dp[0][i] = i;\\n        }\\n        \\n        for(int i=1;i<n1+1;i++)\\n        {\\n            for(int j=1;j<n2+1;j++)\\n            {\\n                if(word1[i-1] == word2[j-1])\\n                {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                  dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1], dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int editDis(string& word1, string& word2, int n1, int n2)\\n    {\\n        if(n1 == 0)\\n            return n2;\\n        if(n2 == 0)\\n            return n1;\\n       // cout<<n1<<\" \"<<n2<<endl;\\n        if(word1[n1-1] == word2[n2-1]) {\\n            return editDis(word1, word2, n1-1, n2-1);\\n        }\\n            \\n        return 1+min(editDis(word1, word2, n1, n2-1),\\n                  min(editDis(word1, word2, n1-1, n2),\\n                  editDis(word1, word2, n1-1, n2-1)));\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        return editDis(word1, word2, n1, n2);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int editDis(string& word1, string& word2, int n1, int n2)\\n    {\\n        if(n1 == 0)\\n            return n2;\\n        if(n2 == 0)\\n            return n1;\\n       // cout<<n1<<\" \"<<n2<<endl;\\n        if(dp[n1][n2] !=-1)\\n        {\\n            return dp[n1][n2];\\n        }\\n        if(word1[n1-1] == word2[n2-1]) {\\n            dp[n1][n2] = editDis(word1, word2, n1-1, n2-1);\\n            return dp[n1][n2];\\n        }\\n            \\n        dp[n1][n2]=  1+min(editDis(word1, word2, n1, n2-1),\\n                  min(editDis(word1, word2, n1-1, n2),\\n                  editDis(word1, word2, n1-1, n2-1)));\\n        return dp[n1][n2];\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        for(int i=0;i<=n1+1;i++)\\n        {\\n            for(int j=0;j<=n2+1;j++)\\n            {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        dp[n1][n2] = editDis(word1, word2, n1, n2);\\n        return dp[n1][n2];\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        int dp[n1+2][n2+2];\\n        \\n        for(int i=0;i<n1+1;i++)\\n        {\\n             dp[i][0] = i;\\n        }\\n        \\n        for(int i=0;i<n2+1;i++)\\n        {\\n             dp[0][i] = i;\\n        }\\n        \\n        for(int i=1;i<n1+1;i++)\\n        {\\n            for(int j=1;j<n2+1;j++)\\n            {\\n                if(word1[i-1] == word2[j-1])\\n                {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                  dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1], dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 274951,
                "title": "python-classic-dp",
                "content": "Suppose ```dp[i][j]``` records the edit distance between ```word1[:i]``` and ```word2[:j]```. And now we proceed to ```word1[i]``` and ```word2[j]```. \\n1. If they are equal, then edit distance between ```word1[:i+1]``` and  ```word2[:j+1]``` are the same as ```dp[i][j]```. Or ```dp[i+1][j+1] = dp[i][j]```.\\n2. Otherwise, we need to determine which of \"delete\", \"insert\", \"replace\" produces the lowest edit distance. Since each operation cost 1 distance, \"delete\"\\'s cost is 1 extra distance plus edit distance between ```word1[:i]``` and ```word2[:j+1]``` as we delete ```word1[i]```. Or ```dp[i+1][j+1] = dp[i][j+1]+1```. Similiarly, \"insert\" produces ```dp[i+1][j+1] = dp[i+1][j]+1``` and \"replace\" produces ```dp[i+1][j+1] = dp[i][j]+1```. And we just pick the minimum from these three.\\n\\nThus, our recurrsion equation is \\n```\\ndp[i+1][j+1] = dp[i][j] if word1[i]==word2[j] else min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1\\n```\\nOne head row and left column are inserted in dp array for base. We can viewed it as each word has an empty string at the begining and empty string is not equal to any character. So initially, ```dp[0][j] = j``` and ```dp[i][0] = i```\\n```\\ndef minDistance(word1, word2):\\n\\tm, n = len(word1), len(word2)\\n\\tdp = [list(range(n+1))]+[[r+1]+[0]*n for r in range(m)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tdp[i+1][j+1] = dp[i][j] if word1[i]==word2[j] else min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1\\n\\treturn dp[m][n]\\n```\\nBoth time and space complexity is O(mn). m, n stands for length of word1 and word2.\\nAnd we can implement a rolling1D DP since only two rows of DP table are actually used. So space complexity could be reduced to O(min(m,n)):\\n```\\ndef minDistance(word1, word2):\\n\\tm, n = len(word1), len(word2)  # switch word1 and word2 if m < n to ensure n \\u2264 m\\n\\tcurr = list(range(n+1))\\n\\tfor i in range(m):\\n\\t\\tprev, curr = curr, [i+1] + [0] * n\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcurr[j+1] = prev[j] if word1[i] == word2[j] else min(curr[j], prev[j], prev[j+1]) + 1\\n\\treturn curr[n]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dp[i][j]```\n```word1[:i]```\n```word2[:j]```\n```word1[i]```\n```word2[j]```\n```word1[:i+1]```\n```word2[:j+1]```\n```dp[i][j]```\n```dp[i+1][j+1] = dp[i][j]```\n```word1[:i]```\n```word2[:j+1]```\n```word1[i]```\n```dp[i+1][j+1] = dp[i][j+1]+1```\n```dp[i+1][j+1] = dp[i+1][j]+1```\n```dp[i+1][j+1] = dp[i][j]+1```\n```\\ndp[i+1][j+1] = dp[i][j] if word1[i]==word2[j] else min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1\\n```\n```dp[0][j] = j```\n```dp[i][0] = i```\n```\\ndef minDistance(word1, word2):\\n\\tm, n = len(word1), len(word2)\\n\\tdp = [list(range(n+1))]+[[r+1]+[0]*n for r in range(m)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tdp[i+1][j+1] = dp[i][j] if word1[i]==word2[j] else min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1\\n\\treturn dp[m][n]\\n```\n```\\ndef minDistance(word1, word2):\\n\\tm, n = len(word1), len(word2)  # switch word1 and word2 if m < n to ensure n \\u2264 m\\n\\tcurr = list(range(n+1))\\n\\tfor i in range(m):\\n\\t\\tprev, curr = curr, [i+1] + [0] * n\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcurr[j+1] = prev[j] if word1[i] == word2[j] else min(curr[j], prev[j], prev[j+1]) + 1\\n\\treturn curr[n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 25959,
                "title": "my-accepted-java-solution",
                "content": "Hi: \\n\\nThis is a very interesting question and I found a [youtube video][1] that helps a lot.\\nBasically the idea is to build up the solution step by step and keep track of the previous optimal solution in a 2D array. In this 2D array dp, dp[i][j] means the operation needed to transform word1(0, i) to word2(0,j). \\n\\nThere can be three conditions:\\n\\n1, word1[i] == word2[j] : then no operation needed. dp[i][j] == dp[i-1][j-1]\\n\\n2, Do one operation on word1[i-1][j]. dp[i][j] = dp[i-1][j] + 1\\n\\n3, Do one operation on word2[i][j-1]. dp[i][j] = dp[i][j-1] + 1\\n\\nfor 2 and 3, the reason it works is that we know the optimal ways to transfrom word1(0,i) to word2(0,j-1) and word1(0,i-1) to word(0,j) ( Delete (\"abc\" to \"ab\") or Insert (\"ab\" to \"abc\") ). Now all we need to one more operation.\\n\\nThe code will be:\\n\\n    public int minDistance(String word1, String word2) {\\n        if (word1.equals(word2)) {\\n            return 0;\\n        }\\n        if (word1.length() == 0 || word2.length() == 0) {\\n            return Math.abs(word1.length() - word2.length());\\n        }\\n        int[][] dp = new int[word1.length() + 1][word2.length() + 1];\\n        for (int i = 0; i <= word1.length(); i++) {\\n            dp[i][0] = i;\\n        }\\n        for (int i = 0; i <= word2.length(); i++) {\\n            dp[0][i] = i;\\n        }\\n        for (int i = 1; i <= word1.length(); i++) {\\n            for (int j = 1; j <= word2.length(); j++) {\\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        return dp[word1.length()][word2.length()];\\n    }\\n\\n Remeber that we start from dp[0][0], which is an empty string to an empty string. \\n\\n\\n  [1]: https://www.youtube.com/watch?v=z_CB7Gih_Mg",
                "solutionTags": [],
                "code": "Hi: \\n\\nThis is a very interesting question and I found a [youtube video][1] that helps a lot.\\nBasically the idea is to build up the solution step by step and keep track of the previous optimal solution in a 2D array. In this 2D array dp, dp[i][j] means the operation needed to transform word1(0, i) to word2(0,j). \\n\\nThere can be three conditions:\\n\\n1, word1[i] == word2[j] : then no operation needed. dp[i][j] == dp[i-1][j-1]\\n\\n2, Do one operation on word1[i-1][j]. dp[i][j] = dp[i-1][j] + 1\\n\\n3, Do one operation on word2[i][j-1]. dp[i][j] = dp[i][j-1] + 1\\n\\nfor 2 and 3, the reason it works is that we know the optimal ways to transfrom word1(0,i) to word2(0,j-1) and word1(0,i-1) to word(0,j) ( Delete (\"abc\" to \"ab\") or Insert (\"ab\" to \"abc\") ). Now all we need to one more operation.\\n\\nThe code will be:\\n\\n    public int minDistance(String word1, String word2) {\\n        if (word1.equals(word2)) {\\n            return 0;\\n        }\\n        if (word1.length() == 0 || word2.length() == 0) {\\n            return Math.abs(word1.length() - word2.length());\\n        }\\n        int[][] dp = new int[word1.length() + 1][word2.length() + 1];\\n        for (int i = 0; i <= word1.length(); i++) {\\n            dp[i][0] = i;\\n        }\\n        for (int i = 0; i <= word2.length(); i++) {\\n            dp[0][i] = i;\\n        }\\n        for (int i = 1; i <= word1.length(); i++) {\\n            for (int j = 1; j <= word2.length(); j++) {\\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        return dp[word1.length()][word2.length()];\\n    }\\n\\n Remeber that we start from dp[0][0], which is an empty string to an empty string. \\n\\n\\n  [1]: https://www.youtube.com/watch?v=z_CB7Gih_Mg",
                "codeTag": "Unknown"
            },
            {
                "id": 1596206,
                "title": "java-dp-detailed-explanation-easy-to-understand",
                "content": "### Explanation:\\n\\n![image](https://assets.leetcode.com/users/images/70ee0a89-9a54-44b2-8106-70ef5054f543_1637868770.0880988.jpeg)\\n![image](https://assets.leetcode.com/users/images/89dc90b2-7c8e-4aee-82c8-b4988e78ed06_1637868770.3484263.jpeg)\\n![image](https://assets.leetcode.com/users/images/676e42a2-e7bd-4df2-9010-524be2f91a36_1637868769.804625.jpeg)\\n\\n<br/>\\n\\n### Code:\\n\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        // Base cases\\n        // Initializing First row\\n        for(int i=0; i <= l2; i++)\\n            dp[0][i] = i;        \\n        // Initializing First col\\n        for(int i=0; i <= l1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int i=1; i <= l1; i++){\\n            for(int j=1; j <= l2; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], // replace\\n                                            Math.min(dp[i-1][j], // delete\\n                                                     dp[i][j-1]) // insert\\n                                           ); \\n            }\\n        }\\n        \\n        return dp[l1][l2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        // Base cases\\n        // Initializing First row\\n        for(int i=0; i <= l2; i++)\\n            dp[0][i] = i;        \\n        // Initializing First col\\n        for(int i=0; i <= l1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int i=1; i <= l1; i++){\\n            for(int j=1; j <= l2; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], // replace\\n                                            Math.min(dp[i-1][j], // delete\\n                                                     dp[i][j-1]) // insert\\n                                           ); \\n            }\\n        }\\n        \\n        return dp[l1][l2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25951,
                "title": "standard-dp-solution",
                "content": "    int minDistance(string word1, string word2) {\\n        int  m = word1.length(), n = word2.length();\\n        if (m == 0) return n;\\n        if (n == 0) return m;\\n        \\n        // table[i][j]: distance from words1.substr(0, i) to words2.substr(0, j) \\n        int table[m+1][n+1];\\n        for (int i = 0; i <= m; ++i) table[i][0] = i;\\n        for (int j = 0; j <= n; ++j) table[0][j] = j;\\n        // table[i][j] is the min distance between the next three values\\n        // from table[i-1][j], table[i][j-1], or table[i-1][j-1] to table[i][j]\\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                int cost = (word1[i-1] == word2[j-1] ? 0 : 1);\\n                table[i][j] = min(min(table[i-1][j] + 1, table[i][j-1] + 1), table[i-1][j-1] + cost);\\n            }\\n        }\\n        \\n        return table[m][n];\\n    }",
                "solutionTags": [],
                "code": "    int minDistance(string word1, string word2) {\\n        int  m = word1.length(), n = word2.length();\\n        if (m == 0) return n;\\n        if (n == 0) return m;\\n        \\n        // table[i][j]: distance from words1.substr(0, i) to words2.substr(0, j) \\n        int table[m+1][n+1];\\n        for (int i = 0; i <= m; ++i) table[i][0] = i;\\n        for (int j = 0; j <= n; ++j) table[0][j] = j;\\n        // table[i][j] is the min distance between the next three values\\n        // from table[i-1][j], table[i][j-1], or table[i-1][j-1] to table[i][j]\\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                int cost = (word1[i-1] == word2[j-1] ? 0 : 1);\\n                table[i][j] = min(min(table[i-1][j] + 1, table[i][j-1] + 1), table[i-1][j-1] + cost);\\n            }\\n        }\\n        \\n        return table[m][n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25896,
                "title": "easy-to-understand-recursive-dp-solution-beats-99-6",
                "content": "```\\npublic class Solution {\\n    int[][] dp;\\n    \\n    public int minDistance(String word1, String word2) {\\n\\tdp = new int[word1.length()][word2.length()];\\n\\t    \\n        return minDistanceHelper(word1, word2, 0, 0);\\n    }\\n    \\n    private int minDistanceHelper(String word1, String word2, int index1, int index2) {\\n        if (index1 == word1.length()) return word2.length() - index2;\\n        if (index2 == word2.length()) return word1.length() - index1;\\n\\t    \\n\\tif (dp[index1][index2] > 0) return dp[index1][index2];\\n        \\n        int result;\\n        if (word1.charAt(index1) == word2.charAt(index2)) {\\n            result = minDistanceHelper(word1, word2, index1+1, index2+1);\\n        } else {\\n            // replace char\\n            result = 1 + minDistanceHelper(word1, word2, index1+1, index2+1);\\n            \\n            // delete char from word1\\n            result = Math.min(result, 1 + minDistanceHelper(word1, word2, index1+1, index2));\\n            \\n            // delete char from word2\\n            result = Math.min(result, 1 + minDistanceHelper(word1, word2, index1, index2+1));\\n        }\\n        \\n\\tdp[index1][index2] = result;\\n\\treturn result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int[][] dp;\\n    \\n    public int minDistance(String word1, String word2) {\\n\\tdp = new int[word1.length()][word2.length()];\\n\\t    \\n        return minDistanceHelper(word1, word2, 0, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2992667,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    int solve(int i, int j, string &s, string &t){\\n        if(i<0 && j<0)\\n            return 0;\\n        \\n        if(i < 0 && j>=0){\\n            return j+1;\\n        }\\n        \\n        if(i>=0 && j<0){\\n            return i+1;\\n        }\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int l = 1000, r = 1000, z = 1000, p = 1000;\\n        if(s[i] == t[j]){\\n            l = solve(i-1,j-1,s,t);\\n        }\\n        else{\\n            r = 1 + solve(i-1,j,s,t);\\n            z = 1 + solve(i-1,j-1,s,t);\\n            p = 1 + solve(i,j-1,s,t);\\n        }\\n        \\n        return dp[i][j] = min(l,min(r,min(z,p)));\\n    }\\n    \\n    \\n    int minDistance(string s, string t) {\\n        dp.resize(s.size()+1,vector<int>(t.size()+1,-1));\\n        return solve(s.size(),t.size(),s,t);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n = len(word1)\\n        m = len(word2)\\n        \\n        to_visit = [(0, 0)]\\n        visited = set()\\n        dist = 0\\n        while to_visit:\\n            nxt_lvl = []\\n            while to_visit:\\n                i, j = to_visit.pop()\\n                if (i, j) in visited:\\n                    continue\\n                while i < n and j < m and word1[i] == word2[j]:\\n                    i += 1\\n                    j += 1\\n                if i == n and j == m:\\n                    return dist\\n                if (i, j + 1) not in visited:\\n                    nxt_lvl.append((i, j + 1))\\n                if (i + 1, j) not in visited:\\n                    nxt_lvl.append((i + 1, j))\\n                if (i + 1, j + 1) not in visited:\\n                    nxt_lvl.append((i + 1, j + 1))\\n                visited.add((i, j))\\n            dist += 1\\n            to_visit = nxt_lvl\\n```\\n\\n```Java []\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        if (word1.length() < word2.length()) {\\n            return minDistance(word2, word1);\\n        }\\n        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();\\n        int[] dp = new int[w2.length];\\n        int last = 0;\\n        int diag = 0;\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = dp.length - i;\\n        }\\n        for (int i = w1.length - 1; i > -1; i--) {\\n            last = w1.length - i;\\n            diag = w1.length - 1 - i;\\n            for (int j = w2.length - 1; j > -1; j--) {\\n                int tmp = dp[j];\\n                if (w1[i] == w2[j]) {\\n                    last = dp[j] = diag;\\n                } else {\\n                    last = dp[j] = Math.min(diag, Math.min(dp[j], last)) + 1;\\n                }\\n                diag = tmp;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    int solve(int i, int j, string &s, string &t){\\n        if(i<0 && j<0)\\n            return 0;\\n        \\n        if(i < 0 && j>=0){\\n            return j+1;\\n        }\\n        \\n        if(i>=0 && j<0){\\n            return i+1;\\n        }\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int l = 1000, r = 1000, z = 1000, p = 1000;\\n        if(s[i] == t[j]){\\n            l = solve(i-1,j-1,s,t);\\n        }\\n        else{\\n            r = 1 + solve(i-1,j,s,t);\\n            z = 1 + solve(i-1,j-1,s,t);\\n            p = 1 + solve(i,j-1,s,t);\\n        }\\n        \\n        return dp[i][j] = min(l,min(r,min(z,p)));\\n    }\\n    \\n    \\n    int minDistance(string s, string t) {\\n        dp.resize(s.size()+1,vector<int>(t.size()+1,-1));\\n        return solve(s.size(),t.size(),s,t);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n = len(word1)\\n        m = len(word2)\\n        \\n        to_visit = [(0, 0)]\\n        visited = set()\\n        dist = 0\\n        while to_visit:\\n            nxt_lvl = []\\n            while to_visit:\\n                i, j = to_visit.pop()\\n                if (i, j) in visited:\\n                    continue\\n                while i < n and j < m and word1[i] == word2[j]:\\n                    i += 1\\n                    j += 1\\n                if i == n and j == m:\\n                    return dist\\n                if (i, j + 1) not in visited:\\n                    nxt_lvl.append((i, j + 1))\\n                if (i + 1, j) not in visited:\\n                    nxt_lvl.append((i + 1, j))\\n                if (i + 1, j + 1) not in visited:\\n                    nxt_lvl.append((i + 1, j + 1))\\n                visited.add((i, j))\\n            dist += 1\\n            to_visit = nxt_lvl\\n```\n```Java []\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        if (word1.length() < word2.length()) {\\n            return minDistance(word2, word1);\\n        }\\n        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();\\n        int[] dp = new int[w2.length];\\n        int last = 0;\\n        int diag = 0;\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = dp.length - i;\\n        }\\n        for (int i = w1.length - 1; i > -1; i--) {\\n            last = w1.length - i;\\n            diag = w1.length - 1 - i;\\n            for (int j = w2.length - 1; j > -1; j--) {\\n                int tmp = dp[j];\\n                if (w1[i] == w2[j]) {\\n                    last = dp[j] = diag;\\n                } else {\\n                    last = dp[j] = Math.min(diag, Math.min(dp[j], last)) + 1;\\n                }\\n                diag = tmp;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25879,
                "title": "python-easy-to-understand-dp-solutions-o-m-n-o-n-space",
                "content": "```\\nclass Solution(object):\\n    # O(n) space\\n    def minDistance(self, word1, word2):\\n        h, w = len(word1)+1, len(word2)+1\\n        pre = [i for i in range(w)]\\n        for i in range(1, h):\\n            cur = [i for _ in range(w)]\\n            for j in range(1, w):\\n                cur[j] = min(pre[j-1]+(word1[i-1] != word2[j-1]), pre[j]+1, cur[j-1]+1)\\n            pre = cur\\n        return pre[-1]\\n    \\n    # O(m*n) space\\n    def minDistance1(self, word1, word2):\\n        h, w = len(word1)+1, len(word2)+1\\n        dp = [[0 for _ in range(w)] for _ in range(h)]\\n        for i in range(h):\\n            dp[i][0] = i\\n        for j in range(w):\\n            dp[0][j] = j\\n        for i in range(1, h):\\n            for j in range(1, w):\\n                dp[i][j] = min(dp[i-1][j-1]+(word1[i-1]!=word2[j-1]), dp[i-1][j]+1, dp[i][j-1]+1)\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    # O(n) space\\n    def minDistance(self, word1, word2):\\n        h, w = len(word1)+1, len(word2)+1\\n        pre = [i for i in range(w)]\\n        for i in range(1, h):\\n            cur = [i for _ in range(w)]\\n            for j in range(1, w):\\n                cur[j] = min(pre[j-1]+(word1[i-1] != word2[j-1]), pre[j]+1, cur[j-1]+1)\\n            pre = cur\\n        return pre[-1]\\n    \\n    # O(m*n) space\\n    def minDistance1(self, word1, word2):\\n        h, w = len(word1)+1, len(word2)+1\\n        dp = [[0 for _ in range(w)] for _ in range(h)]\\n        for i in range(h):\\n            dp[i][0] = i\\n        for j in range(w):\\n            dp[0][j] = j\\n        for i in range(1, h):\\n            for j in range(1, w):\\n                dp[i][j] = min(dp[i-1][j-1]+(word1[i-1]!=word2[j-1]), dp[i-1][j]+1, dp[i][j-1]+1)\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25914,
                "title": "concise-java-dp-solution-with-comments",
                "content": "    public int minDistance(String word1, String word2) {\\n    \\t// dp[i][j] : minimum steps to convert i long word1 and j long word2\\n    \\tint dp[][] = new int[word1.length() + 1][word2.length() + 1];\\n    \\n    \\tfor (int i = 0; i <= word1.length(); i++) dp[i][0] = i;    \\t\\n    \\tfor (int j = 0; j <= word2.length(); j++) dp[0][j] = j; \\n    \\t \\n    \\tfor (int i = 1;i <= word1.length(); i++) {\\n    \\t\\tfor (int j = 1; j<= word2.length(); j++) {\\n    \\t\\t\\tif (word1.charAt(i-1) == word2.charAt(j-1))// <--\\n    \\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n    \\t\\t\\telse \\n                    // dp[i-1][j-1] : replace word1(i) with word2(j), because word1(0, i-1) == word2(0, j-1);\\n                    // dp[i  ][j-1] : delete word(j)\\n                    // dp[i-1][j  ] : delete word(i), because word1(0, i-1) == word2(0, j)\\n    \\t\\t\\t\\tdp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j])) + 1; \\n    \\t\\t}\\n    \\t}\\n    \\treturn dp[word1.length()][word2.length()];\\n    }",
                "solutionTags": [],
                "code": "    public int minDistance(String word1, String word2) {\\n    \\t// dp[i][j] : minimum steps to convert i long word1 and j long word2\\n    \\tint dp[][] = new int[word1.length() + 1][word2.length() + 1];\\n    \\n    \\tfor (int i = 0; i <= word1.length(); i++) dp[i][0] = i;    \\t\\n    \\tfor (int j = 0; j <= word2.length(); j++) dp[0][j] = j; \\n    \\t \\n    \\tfor (int i = 1;i <= word1.length(); i++) {\\n    \\t\\tfor (int j = 1; j<= word2.length(); j++) {\\n    \\t\\t\\tif (word1.charAt(i-1) == word2.charAt(j-1))// <--\\n    \\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n    \\t\\t\\telse \\n                    // dp[i-1][j-1] : replace word1(i) with word2(j), because word1(0, i-1) == word2(0, j-1);\\n                    // dp[i  ][j-1] : delete word(j)\\n                    // dp[i-1][j  ] : delete word(i), because word1(0, i-1) == word2(0, j)\\n    \\t\\t\\t\\tdp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j])) + 1; \\n    \\t\\t}\\n    \\t}\\n    \\treturn dp[word1.length()][word2.length()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3230707,
                "title": "memoization-tabulation-space-optimization-dp-c-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n# Intuition\\n    In this question we have to find the **Minimum Operations** to convert `word1` to `word2`.\\n    So, what are the posibilities : \\n        If both letters are equal then simply decrease index\\n        Otherwise there are three posibilities:\\n            We can `Insert` a letter\\n            We can `Delete` a letter\\n            We can `Replace` a letter\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Space Optimization**\\n```\\nclass Solution {\\npublic:\\n    // Space Optimization - TC: O(n * m), SC: O(m)\\n    int minDistance(string word1, string word2) {\\n    int n = word1.size(), m = word2.size();\\n    // We make dp array 1 indexed\\n    // Initialize two vectors to store the values of the previous and current rows of the dp array\\n    vector<int> prev(m+1, 0), curr(m+1, 0);\\n    // Initialize the first row of the dp array to the numbers 0, 1, 2, ..., m\\n    for(int j=0;j<=m;j++) prev[j] = j;\\n    // Iterate through each row of the dp array\\n    for(int i=1;i<=n;i++){\\n        // Set the first element of the current row to i\\n        curr[0] = i;\\n        // Iterate through each column of the dp array\\n        for(int j=1;j<=m;j++){\\n            // If the two characters are equal, no operation is needed\\n            if(word1[i-1] == word2[j-1])\\n                curr[j] = prev[j-1];\\n            else {\\n                // If the two characters are different, consider three possible operations:\\n                // Insertion: add 1 to the minimum value among prev[j], curr[j-1], and prev[j-1]\\n                curr[j] = 1 + min(prev[j], min(curr[j-1], prev[j-1]));\\n            }\\n        }\\n        // Update the previous row to be equal to the current row\\n        prev = curr;\\n    }\\n    // Return the value of the last element of the dp array, which represents the minimum edit distance\\n    return prev[m];\\n}\\n};\\n```\\n**Tabulation**\\n```\\n// Tabulation - TC: O(n * m), SC: O(n * m)\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        // We make dp array 1 indexed\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        for(int i=0;i<=n;i++) dp[i][0] = i;\\n        for(int j=0;j<=m;j++) dp[0][j] = j;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else\\n// Delete - dp[i-1][j], Insert - dp[i][j-1], Replace - dp[i-1][j-1]\\n                    dp[i][j] = 1 + min(dp[i-1][j], \\n        min(dp[i][j-1], dp[i-1][j-1]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\\n**Memoization** \\n```\\n//Memoization - TC: O(n * m), SC: O(n * m) + O(n + m)\\n    int find(string word1, string word2, int i, int j, vector<vector<int>>& dp){\\n        if(j < 0) return i+1;\\n        if(i < 0) return j+1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(word1[i] == word2[j]) return find(word1, word2, i-1, j-1, dp);\\n        return dp[i][j] = 1 + min(find(word1, word2, i-1, j, dp), \\n        min(find(word1, word2, i, j-1, dp), find(word1, word2, i-1, j-1, dp)));\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        return find(word1, word2, n-1, m-1, dp);\\n    }\\n```\\n```\\n            Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```\\nclass Solution {\\npublic:\\n    // Space Optimization - TC: O(n * m), SC: O(m)\\n    int minDistance(string word1, string word2) {\\n    int n = word1.size(), m = word2.size();\\n    // We make dp array 1 indexed\\n    // Initialize two vectors to store the values of the previous and current rows of the dp array\\n    vector<int> prev(m+1, 0), curr(m+1, 0);\\n    // Initialize the first row of the dp array to the numbers 0, 1, 2, ..., m\\n    for(int j=0;j<=m;j++) prev[j] = j;\\n    // Iterate through each row of the dp array\\n    for(int i=1;i<=n;i++){\\n        // Set the first element of the current row to i\\n        curr[0] = i;\\n        // Iterate through each column of the dp array\\n        for(int j=1;j<=m;j++){\\n            // If the two characters are equal, no operation is needed\\n            if(word1[i-1] == word2[j-1])\\n                curr[j] = prev[j-1];\\n            else {\\n                // If the two characters are different, consider three possible operations:\\n                // Insertion: add 1 to the minimum value among prev[j], curr[j-1], and prev[j-1]\\n                curr[j] = 1 + min(prev[j], min(curr[j-1], prev[j-1]));\\n            }\\n        }\\n        // Update the previous row to be equal to the current row\\n        prev = curr;\\n    }\\n    // Return the value of the last element of the dp array, which represents the minimum edit distance\\n    return prev[m];\\n}\\n};\\n```\n```\\n// Tabulation - TC: O(n * m), SC: O(n * m)\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        // We make dp array 1 indexed\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        for(int i=0;i<=n;i++) dp[i][0] = i;\\n        for(int j=0;j<=m;j++) dp[0][j] = j;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else\\n// Delete - dp[i-1][j], Insert - dp[i][j-1], Replace - dp[i-1][j-1]\\n                    dp[i][j] = 1 + min(dp[i-1][j], \\n        min(dp[i][j-1], dp[i-1][j-1]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\n```\\n//Memoization - TC: O(n * m), SC: O(n * m) + O(n + m)\\n    int find(string word1, string word2, int i, int j, vector<vector<int>>& dp){\\n        if(j < 0) return i+1;\\n        if(i < 0) return j+1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(word1[i] == word2[j]) return find(word1, word2, i-1, j-1, dp);\\n        return dp[i][j] = 1 + min(find(word1, word2, i-1, j, dp), \\n        min(find(word1, word2, i, j-1, dp), find(word1, word2, i-1, j-1, dp)));\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        return find(word1, word2, n-1, m-1, dp);\\n    }\\n```\n```\\n            Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428527,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. Use lavenshtein distance algorithm and dynamic programming implementation\\n2. Build a matrix from word1 and word2, each cell represents the minimum difference between the words up the current character\\n3. Each cell is trying to become the locally minimum difference, so we have 3 options, 1 + left cell, 1 + top cell, 1 + diagonal (two characters aren\\'t the same) or 0 + diagonal (two characters are the same)\\n``` javascript\\nvar minDistance = function(word1, word2) {\\n    let dp = Array(word1.length+1).fill(null).map(()=>(Array(word2.length+1).fill(0)));\\n\\n    for (let i=0;i<dp.length;i++) {\\n        dp[i][0] = i\\n    }\\n\\n    for (let i=0;i<dp[0].length;i++) {\\n        dp[0][i] = i\\n    }\\n\\n    for (let i = 1;i<dp.length;i++) {\\n        for (let j=1;j<dp[0].length;j++) {\\n            dp[i][j] = Math.min(\\n                            dp[i-1][j]+1, // left\\n                            dp[i][j-1]+1, // right\\n                            dp[i-1][j-1] + (word1[i-1]!=word2[j-1]?1:0) // diagonal\\n                        );\\n        }\\n    }\\n    return dp[dp.length-1][dp[0].length-1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar minDistance = function(word1, word2) {\\n    let dp = Array(word1.length+1).fill(null).map(()=>(Array(word2.length+1).fill(0)));\\n\\n    for (let i=0;i<dp.length;i++) {\\n        dp[i][0] = i\\n    }\\n\\n    for (let i=0;i<dp[0].length;i++) {\\n        dp[0][i] = i\\n    }\\n\\n    for (let i = 1;i<dp.length;i++) {\\n        for (let j=1;j<dp[0].length;j++) {\\n            dp[i][j] = Math.min(\\n                            dp[i-1][j]+1, // left\\n                            dp[i][j-1]+1, // right\\n                            dp[i-1][j-1] + (word1[i-1]!=word2[j-1]?1:0) // diagonal\\n                        );\\n        }\\n    }\\n    return dp[dp.length-1][dp[0].length-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231367,
                "title": "python-3-8-lines-w-comments-t-m-100-78",
                "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        w1, w2 = len(word1), len(word2)\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n\\n            if i >= w1             : return w2-j                # word1 used up, so all inserts\\n            if j >= w2             : return w1-i                # word2 used up, so all deletes\\n            if word1[i] == word2[j]: return dp(i+1, j+1)        # letters match, so no operation\\n\\n            return min(dp(i,j+1), dp(i+1,j), dp(i+1,j+1)) + 1   # insert, delete, replace\\n\\n        return dp(0,0)\\n```\\n[https://leetcode.com/problems/edit-distance/submissions/905093377/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is *O*(*MN*), in which *M, N* ~ `len(word1),len(word2)`.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        w1, w2 = len(word1), len(word2)\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n\\n            if i >= w1             : return w2-j                # word1 used up, so all inserts\\n            if j >= w2             : return w1-i                # word2 used up, so all deletes\\n            if word1[i] == word2[j]: return dp(i+1, j+1)        # letters match, so no operation\\n\\n            return min(dp(i,j+1), dp(i+1,j), dp(i+1,j+1)) + 1   # insert, delete, replace\\n\\n        return dp(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980878,
                "title": "java-c-python-javascript-kotlin-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/kMGrBJeX/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/kMGrBJeX/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "codeTag": "Unknown"
            },
            {
                "id": 25987,
                "title": "dynamic-programming-solution-in-c-with-algorithm-description",
                "content": "**Algorithm Description**  \\n\\n\\n----------\\n\\n - Step 1:\\n\\nSet  n to be the length of *word1*;\\nSet m to be the length of *word2*.  \\nIf n = 0, return m and exit.  \\nIf m = 0, return n  and exit.  \\nConstruct a matrix containing 0...n rows and 0...m columns.  \\n  \\n\\n - Step 2:\\n\\nInitialize the first row       to 0...n.  \\nInitialize the first column to 0...m.  \\n  \\n\\n - Step 3:\\n\\nExamine each character of *word1* (i from 1 to  n).\\n\\n - Step 4:\\n\\nExamine each character of *word2*  (j from 1 to m).\\n\\n - Step 5:\\n\\nIf word1[i] == word2[j], the cost = 0.  \\nIf word1[i] !=  word2[j], the cost = 1.  \\n  \\n\\n - Step 6:\\n\\n   \\nSet cell A [i, j] of the matrix equal to the minimum of:  \\na) The cell immediately **above** plus 1:                               A[i - 1, j]    + 1.  \\nb) The cell immediately **to the left** plus 1:                          A[i,  j - 1]    + 1.  \\nc) The cell diagonally **above and to the left** plus the cost: A[i - 1, j - 1] + cost.  \\n  \\n\\n - Step 7:\\n\\n   \\nAfter the iteration steps (3, 4, 5, 6) are complete, the distance is found in cell A[n, m]. \\n\\n\\n----------\\n\\n\\nHere is the code:\\n\\n    int minDistance(string word1, string word2) {\\n        // Step 1\\n        int n = word1.size(), m = word2.size();\\n        if (n == 0)  return m;\\n        if (m == 0)  return n;\\n        int A[n + 1][m + 1];\\n\\n        // Step 2\\n        for (int i = 0; i <= n; ++i)  A[i][0] = i;\\n        for (int j = 0; j <= m; ++j)  A[0][j] = j;\\n        \\n        for (int i = 1; i <= n; ++i) {  // Step 3\\n            char word1_i = word1[i-1];\\n            for (int j = 1; j <= m; ++j) {  // Step 4\\n                char word2_j = word2[j-1];\\n                int cost = (word1_i == word2_j) ? 0 : 1;  // Step 5\\n                A[i][j] = min(min(A[i-1][j]+1, A[i][j-1]+1), A[i-1][j-1]+cost);// Step 6\\n            }\\n        }\\n        return A[n][m];  // Step 7\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "**Algorithm Description**  \\n\\n\\n----------\\n\\n - Step 1:\\n\\nSet  n to be the length of *word1*;\\nSet m to be the length of *word2*.  \\nIf n = 0, return m and exit.  \\nIf m = 0, return n  and exit.  \\nConstruct a matrix containing 0...n rows and 0...m columns.  \\n  \\n\\n - Step 2:\\n\\nInitialize the first row       to 0...n.  \\nInitialize the first column to 0...m.  \\n  \\n\\n - Step 3:\\n\\nExamine each character of *word1* (i from 1 to  n).\\n\\n - Step 4:\\n\\nExamine each character of *word2*  (j from 1 to m).\\n\\n - Step 5:\\n\\nIf word1[i] == word2[j], the cost = 0.  \\nIf word1[i] !=  word2[j], the cost = 1.  \\n  \\n\\n - Step 6:\\n\\n   \\nSet cell A [i, j] of the matrix equal to the minimum of:  \\na) The cell immediately **above** plus 1:                               A[i - 1, j]    + 1.  \\nb) The cell immediately **to the left** plus 1:                          A[i,  j - 1]    + 1.  \\nc) The cell diagonally **above and to the left** plus the cost: A[i - 1, j - 1] + cost.  \\n  \\n\\n - Step 7:\\n\\n   \\nAfter the iteration steps (3, 4, 5, 6) are complete, the distance is found in cell A[n, m]. \\n\\n\\n----------\\n\\n\\nHere is the code:\\n\\n    int minDistance(string word1, string word2) {\\n        // Step 1\\n        int n = word1.size(), m = word2.size();\\n        if (n == 0)  return m;\\n        if (m == 0)  return n;\\n        int A[n + 1][m + 1];\\n\\n        // Step 2\\n        for (int i = 0; i <= n; ++i)  A[i][0] = i;\\n        for (int j = 0; j <= m; ++j)  A[0][j] = j;\\n        \\n        for (int i = 1; i <= n; ++i) {  // Step 3\\n            char word1_i = word1[i-1];\\n            for (int j = 1; j <= m; ++j) {  // Step 4\\n                char word2_j = word2[j-1];\\n                int cost = (word1_i == word2_j) ? 0 : 1;  // Step 5\\n                A[i][j] = min(min(A[i-1][j]+1, A[i][j-1]+1), A[i-1][j-1]+cost);// Step 6\\n            }\\n        }\\n        return A[n][m];  // Step 7\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1519242,
                "title": "java-tc-o-mn-sc-o-min-m-n-space-optimized-dp-solution",
                "content": "```java\\n/**\\n * Space Optimized Dynamic Programming solution\\n *\\n * dp[i][j] = the minimum number of operations to convert word1[0 .. i-1] to word2[0 .. j-1]\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(min(M, N)).\\n *\\n * M = Length string word1. N = Length of string word2.\\n */\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) {\\n            throw new IllegalArgumentException(\"Input strings are null\");\\n        }\\n\\n        int insertCost = 1;\\n        int deleteCost = 1;\\n        int replaceCost = 1;\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n\\n        if (l1 == 0) {\\n            return l2 * insertCost;\\n        }\\n        if (l2 == 0) {\\n            return l1 * deleteCost;\\n        }\\n        // Bellow condition can be used only if all three costs are same.\\n        if (l1 > l2) {\\n            return minDistance(word2, word1);\\n        }\\n\\n        int[] dp = new int[l1 + 1];\\n        // Setting DP array for 0th column of 2D DP array. Here l2 is blank, thus we\\n        // have to delete everything in l1.\\n        for (int i = 1; i <= l1; i++) {\\n            dp[i] = dp[i - 1] + deleteCost;\\n        }\\n\\n        for (int j = 1; j <= l2; j++) {\\n            int prev = dp[0];\\n            dp[0] += insertCost; // l1 is blank, Inserting l2 chars in l1.\\n            char c2 = word2.charAt(j - 1);\\n            for (int i = 1; i <= l1; i++) {\\n                char c1 = word1.charAt(i - 1);\\n                int temp = dp[i];\\n                // Both chars are same, so the distance will also remain same as dp[i-1][j-1]\\n                if (c1 == c2) {\\n                    dp[i] = prev;\\n                } else {\\n                    // Replace l1[i - 1] by l2[j - 1] ==> dp[i][j] = dp[i - 1][j - 1] + 1\\n                    // Delete l1[i-1] from l1[0..i-1] ==> dp[i-1][j] + 1\\n                    // Insert l2[j-1] into l1[0..i-1] ==> dp[i][j-1] + 1\\n                    dp[i] = Math.min(prev + replaceCost, Math.min(dp[i - 1] + deleteCost, dp[i] + insertCost));\\n                }\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[l1];\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other similar questions on LeetCode:\\n- [221. Maximal Square](https://leetcode.com/problems/maximal-square/discuss/1519235/Java-or-TC:-O(MN)-or-SC:-O(min(MN))-or-Space-optimized-DP-solution)\\n- [161. One Edit Distance](https://leetcode.com/problems/one-edit-distance/discuss/1519249/Java-or-TC:-O(min(ST))-or-SC:-O(min(ST))-or-Optimal-One-Pass-solution)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```java\\n/**\\n * Space Optimized Dynamic Programming solution\\n *\\n * dp[i][j] = the minimum number of operations to convert word1[0 .. i-1] to word2[0 .. j-1]\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(min(M, N)).\\n *\\n * M = Length string word1. N = Length of string word2.\\n */\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) {\\n            throw new IllegalArgumentException(\"Input strings are null\");\\n        }\\n\\n        int insertCost = 1;\\n        int deleteCost = 1;\\n        int replaceCost = 1;\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n\\n        if (l1 == 0) {\\n            return l2 * insertCost;\\n        }\\n        if (l2 == 0) {\\n            return l1 * deleteCost;\\n        }\\n        // Bellow condition can be used only if all three costs are same.\\n        if (l1 > l2) {\\n            return minDistance(word2, word1);\\n        }\\n\\n        int[] dp = new int[l1 + 1];\\n        // Setting DP array for 0th column of 2D DP array. Here l2 is blank, thus we\\n        // have to delete everything in l1.\\n        for (int i = 1; i <= l1; i++) {\\n            dp[i] = dp[i - 1] + deleteCost;\\n        }\\n\\n        for (int j = 1; j <= l2; j++) {\\n            int prev = dp[0];\\n            dp[0] += insertCost; // l1 is blank, Inserting l2 chars in l1.\\n            char c2 = word2.charAt(j - 1);\\n            for (int i = 1; i <= l1; i++) {\\n                char c1 = word1.charAt(i - 1);\\n                int temp = dp[i];\\n                // Both chars are same, so the distance will also remain same as dp[i-1][j-1]\\n                if (c1 == c2) {\\n                    dp[i] = prev;\\n                } else {\\n                    // Replace l1[i - 1] by l2[j - 1] ==> dp[i][j] = dp[i - 1][j - 1] + 1\\n                    // Delete l1[i-1] from l1[0..i-1] ==> dp[i-1][j] + 1\\n                    // Insert l2[j-1] into l1[0..i-1] ==> dp[i][j-1] + 1\\n                    dp[i] = Math.min(prev + replaceCost, Math.min(dp[i - 1] + deleteCost, dp[i] + insertCost));\\n                }\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[l1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25878,
                "title": "evolve-from-brute-force-to-dp",
                "content": "We only need to edit one word because insert a char to word1 is equivalent to delete a char in word2 and vise versa. Replace a char in word1 is equivalent to replace a char in word2.\\n1. O(3^max(n1,n2)) We edit word 1 only and there are 3 operations\\n* c++\\n```\\n    int minDistance(string word1, string word2) {\\n        return minDistance(0,0,word1,word2);\\n    }\\n    int minDistance(int p1, int p2, string &word1, string &word2) {\\n        if(p1==word1.size()) return word2.size()-p2; //dist between a string and an empty string\\n        if(p2==word2.size()) return word1.size()-p1;\\n        if(word1[p1]==word2[p2]) return minDistance(p1+1,p2+1,word1,word2);\\n        int ins = minDistance(p1,p2+1,word1,word2);\\n        int del = minDistance(p1+1,p2,word1,word2);\\n        int rpl = minDistance(p1+1,p2+1,word1,word2);\\n        return min(ins,min(del,rpl))+1;\\n    }\\n```\\n* java\\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        return minDist(0,0,word1,word2);  \\n    }\\n    private int minDist(int p1, int p2, String word1, String word2) {\\n        int s1=word1.length(),s2=word2.length();\\n        if(p1==s1) return s2-p2; //We only edit word1, but since both insert and delete are allowed, word1 may not finish first\\n        if(p2==s2) return s1-p1; //The two ternimation checks make sure both indexes are valid\\n        if(word1.charAt(p1)==word2.charAt(p2)) \\n            return minDist(p1+1,p2+1,word1,word2);\\n        int ins = minDist(p1,p2+1,word1,word2);\\n        int del = minDist(p1+1,p2,word1,word2);\\n        int rep = minDist(p1+1,p2+1,word1,word2);\\n        return Math.min(ins, Math.min(del, rep))+1;\\n    }\\n}\\n```\\n2. O(n1n2) memorization\\n* c++\\n```\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>> mem(word1.size(),vector<int>(word2.size(),-1));\\n        return minDistance(0,0,word1,word2,mem);\\n    }\\n    int minDistance(int p1, int p2, string &word1, string &word2,vector<vector<int>>& mem) {\\n        if(p1==word1.size()) return word2.size()-p2;\\n        if(p2==word2.size()) return word1.size()-p1;\\n        if(mem[p1][p2]>=0) return mem[p1][p2];\\n        if(word1[p1]==word2[p2]) return mem[p1][p2]=minDistance(p1+1,p2+1,word1,word2,mem);\\n        int ins = minDistance(p1,p2+1,word1,word2,mem);\\n        int del = minDistance(p1+1,p2,word1,word2,mem);\\n        int rpl = minDistance(p1+1,p2+1,word1,word2,mem);\\n        return mem[p1][p2] = min(ins,min(del,rpl))+1;\\n    }\\n```\\n* java\\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        Integer[][] mem=new Integer[word1.length()][word2.length()];\\n        return minDist(0,0,word1,word2,mem);  \\n    }\\n    private int minDist(int p1, int p2, String word1, String word2, Integer[][] mem) {\\n        int s1=word1.length(),s2=word2.length();\\n        if(p1==s1) return s2-p2; //We only edit word1, but since both insert and delete are allowed, word1 may not finish first\\n        if(p2==s2) return s1-p1; //The two ternimation checks make sure both indexes are valid\\n        if(mem[p1][p2]!=null) return mem[p1][p2];\\n        if(word1.charAt(p1)==word2.charAt(p2)) \\n            return mem[p1][p2]=minDist(p1+1,p2+1,word1,word2,mem);\\n        int ins = minDist(p1,p2+1,word1,word2,mem);\\n        int del = minDist(p1+1,p2,word1,word2,mem);\\n        int rep = minDist(p1+1,p2+1,word1,word2,mem);\\n        return mem[p1][p2]=Math.min(ins, Math.min(del, rep))+1;\\n    }\\n```\\n3. O(n1n2) dp\\n* c++\\n```\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size(),n2=word2.size();\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1));\\n        for(int i=0;i<n1;i++) dp[i][n2] = n1-i;\\n        for(int j=0;j<n2;j++) dp[n1][j] = n2-j;\\n        for(int i=n1-1;i>=0;i--)\\n            for(int j=n2-1;j>=0;j--) \\n                dp[i][j] = word1[i]==word2[j]? dp[i+1][j+1] : min(min(dp[i][j+1],dp[i+1][j]),dp[i+1][j+1])+1;\\n        return dp[0][0];\\n    }\\n```\\n* java\\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        int n1=word1.length(), n2=word2.length();\\n        int[][] dp=new int[n1+1][n2+1];\\n        for(int i=0;i<n1;i++) dp[i][n2]=n1-i;\\n        for(int i=0;i<n2;i++) dp[n1][i]=n2-i;\\n        for(int i=n1-1;i>=0;i--)\\n            for(int j=n2-1;j>=0;j--) {\\n                if(word1.charAt(i)==word2.charAt(j))\\n                    dp[i][j]=dp[i+1][j+1];\\n                else {\\n                    dp[i][j]=Math.min(dp[i][j+1],Math.min(dp[i+1][j],dp[i+1][j+1]))+1;\\n                }\\n            }\\n        return dp[0][0];  \\n    }\\n```\\n4. linear space dp\\n```\\n    int minDistance(string word1, string word2) {\\n        int s1=word1.size(),s2=word2.size();\\n        vector<int> dp(s1+1);\\n        iota(dp.rbegin(),dp.rend(),0);\\n        for(int i=s2-1;i>=0;i--) {\\n            int i1j1 = dp[s1];\\n            dp[s1] = s2-i;\\n            for(int j=s1-1;j>=0;j--) {\\n                int temp=dp[j];\\n                dp[j]=min(dp[j+1]+1,min(dp[j]+1,i1j1+(word2[i]!=word1[j])));\\n                i1j1=temp;\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n    int minDistance(string word1, string word2) {\\n        return minDistance(0,0,word1,word2);\\n    }\\n    int minDistance(int p1, int p2, string &word1, string &word2) {\\n        if(p1==word1.size()) return word2.size()-p2; //dist between a string and an empty string\\n        if(p2==word2.size()) return word1.size()-p1;\\n        if(word1[p1]==word2[p2]) return minDistance(p1+1,p2+1,word1,word2);\\n        int ins = minDistance(p1,p2+1,word1,word2);\\n        int del = minDistance(p1+1,p2,word1,word2);\\n        int rpl = minDistance(p1+1,p2+1,word1,word2);\\n        return min(ins,min(del,rpl))+1;\\n    }\\n```\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        return minDist(0,0,word1,word2);  \\n    }\\n    private int minDist(int p1, int p2, String word1, String word2) {\\n        int s1=word1.length(),s2=word2.length();\\n        if(p1==s1) return s2-p2; //We only edit word1, but since both insert and delete are allowed, word1 may not finish first\\n        if(p2==s2) return s1-p1; //The two ternimation checks make sure both indexes are valid\\n        if(word1.charAt(p1)==word2.charAt(p2)) \\n            return minDist(p1+1,p2+1,word1,word2);\\n        int ins = minDist(p1,p2+1,word1,word2);\\n        int del = minDist(p1+1,p2,word1,word2);\\n        int rep = minDist(p1+1,p2+1,word1,word2);\\n        return Math.min(ins, Math.min(del, rep))+1;\\n    }\\n}\\n```\n```\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>> mem(word1.size(),vector<int>(word2.size(),-1));\\n        return minDistance(0,0,word1,word2,mem);\\n    }\\n    int minDistance(int p1, int p2, string &word1, string &word2,vector<vector<int>>& mem) {\\n        if(p1==word1.size()) return word2.size()-p2;\\n        if(p2==word2.size()) return word1.size()-p1;\\n        if(mem[p1][p2]>=0) return mem[p1][p2];\\n        if(word1[p1]==word2[p2]) return mem[p1][p2]=minDistance(p1+1,p2+1,word1,word2,mem);\\n        int ins = minDistance(p1,p2+1,word1,word2,mem);\\n        int del = minDistance(p1+1,p2,word1,word2,mem);\\n        int rpl = minDistance(p1+1,p2+1,word1,word2,mem);\\n        return mem[p1][p2] = min(ins,min(del,rpl))+1;\\n    }\\n```\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        Integer[][] mem=new Integer[word1.length()][word2.length()];\\n        return minDist(0,0,word1,word2,mem);  \\n    }\\n    private int minDist(int p1, int p2, String word1, String word2, Integer[][] mem) {\\n        int s1=word1.length(),s2=word2.length();\\n        if(p1==s1) return s2-p2; //We only edit word1, but since both insert and delete are allowed, word1 may not finish first\\n        if(p2==s2) return s1-p1; //The two ternimation checks make sure both indexes are valid\\n        if(mem[p1][p2]!=null) return mem[p1][p2];\\n        if(word1.charAt(p1)==word2.charAt(p2)) \\n            return mem[p1][p2]=minDist(p1+1,p2+1,word1,word2,mem);\\n        int ins = minDist(p1,p2+1,word1,word2,mem);\\n        int del = minDist(p1+1,p2,word1,word2,mem);\\n        int rep = minDist(p1+1,p2+1,word1,word2,mem);\\n        return mem[p1][p2]=Math.min(ins, Math.min(del, rep))+1;\\n    }\\n```\n```\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size(),n2=word2.size();\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1));\\n        for(int i=0;i<n1;i++) dp[i][n2] = n1-i;\\n        for(int j=0;j<n2;j++) dp[n1][j] = n2-j;\\n        for(int i=n1-1;i>=0;i--)\\n            for(int j=n2-1;j>=0;j--) \\n                dp[i][j] = word1[i]==word2[j]? dp[i+1][j+1] : min(min(dp[i][j+1],dp[i+1][j]),dp[i+1][j+1])+1;\\n        return dp[0][0];\\n    }\\n```\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        int n1=word1.length(), n2=word2.length();\\n        int[][] dp=new int[n1+1][n2+1];\\n        for(int i=0;i<n1;i++) dp[i][n2]=n1-i;\\n        for(int i=0;i<n2;i++) dp[n1][i]=n2-i;\\n        for(int i=n1-1;i>=0;i--)\\n            for(int j=n2-1;j>=0;j--) {\\n                if(word1.charAt(i)==word2.charAt(j))\\n                    dp[i][j]=dp[i+1][j+1];\\n                else {\\n                    dp[i][j]=Math.min(dp[i][j+1],Math.min(dp[i+1][j],dp[i+1][j+1]))+1;\\n                }\\n            }\\n        return dp[0][0];  \\n    }\\n```\n```\\n    int minDistance(string word1, string word2) {\\n        int s1=word1.size(),s2=word2.size();\\n        vector<int> dp(s1+1);\\n        iota(dp.rbegin(),dp.rend(),0);\\n        for(int i=s2-1;i>=0;i--) {\\n            int i1j1 = dp[s1];\\n            dp[s1] = s2-i;\\n            for(int j=s1-1;j>=0;j--) {\\n                int temp=dp[j];\\n                dp[j]=min(dp[j+1]+1,min(dp[j]+1,i1j1+(word2[i]!=word1[j])));\\n                i1j1=temp;\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25989,
                "title": "my-dp-solution-in-c-with-comments",
                "content": "   \\n\\n    int minDistance(string word1, string word2) {\\n        // DP talbe, i is the position in word1, and j is the position in word2\\n        vector<vector<int>> distance(word1.length()+1, vector<int>(word2.length()+1, 0));\\n        \\n        // when i or j=0 means empty string, the distance is the length of another string\\n        for(int i=0; i<distance.size(); i++)\\n            for(int j=0; j< distance[0].size();j++){\\n                if(i == 0)\\n                    distance[i][j] = j;\\n                else if(j == 0)\\n                    distance[i][j] = i;\\n            }\\n        \\n        // if word1[i]==word2[j], then the distance of i and j is the previous i and j\\n        // otherwise we either replace, insert or delete a char\\n        // when insert a char to word1 it means we are trying to match word1 at i-1 to word2 at j\\n        // when delete a char from word1 it equals to insert a char to word2, which\\n        // means we are trying to match word1 at i to word2 at j-1\\n        // when replace a char to word1, then we add one step to previous i and j\\n        for(int i=1; i< distance.size(); i++)\\n            for(int j=1; j<distance[0].size(); j++){\\n                if(word1[i-1] == word2[j-1])\\n                    distance[i][j] = distance[i-1][j-1];\\n                else\\n                    distance[i][j] = 1+ min(distance[i-1][j-1], min(distance[i-1][j], distance[i][j-1]));\\n            }\\n            \\n        return distance[word1.length()][word2.length()];\\n    }",
                "solutionTags": [],
                "code": "   \\n\\n    int minDistance(string word1, string word2) {\\n        // DP talbe, i is the position in word1, and j is the position in word2\\n        vector<vector<int>> distance(word1.length()+1, vector<int>(word2.length()+1, 0));\\n        \\n        // when i or j=0 means empty string, the distance is the length of another string\\n        for(int i=0; i<distance.size(); i++)\\n            for(int j=0; j< distance[0].size();j++){\\n                if(i == 0)\\n                    distance[i][j] = j;\\n                else if(j == 0)\\n                    distance[i][j] = i;\\n            }\\n        \\n        // if word1[i]==word2[j], then the distance of i and j is the previous i and j\\n        // otherwise we either replace, insert or delete a char\\n        // when insert a char to word1 it means we are trying to match word1 at i-1 to word2 at j\\n        // when delete a char from word1 it equals to insert a char to word2, which\\n        // means we are trying to match word1 at i to word2 at j-1\\n        // when replace a char to word1, then we add one step to previous i and j\\n        for(int i=1; i< distance.size(); i++)\\n            for(int j=1; j<distance[0].size(); j++){\\n                if(word1[i-1] == word2[j-1])\\n                    distance[i][j] = distance[i-1][j-1];\\n                else\\n                    distance[i][j] = 1+ min(distance[i-1][j-1], min(distance[i-1][j], distance[i][j-1]));\\n            }\\n            \\n        return distance[word1.length()][word2.length()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1915729,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func minDistance(_ word1: String, _ word2: String) -> Int {\\n        let row = word1.count + 1\\n        let col = word2.count + 1\\n        let chs1  = Array(word1)\\n        let chs2  = Array(word2)\\n        var dp: [[Int]] = Array(repeating: Array(repeating: 0, count: col), count: row)\\n        \\n        for i in 0..<row { \\n            for j in 0..<col {\\n                if i == 0 {\\n                    dp[i][j] = j\\n                \\n                } else if j == 0 {\\n                    dp[i][j] = i\\n                \\n                } else if chs1[i - 1] == chs2[j - 1] {\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                \\n                } else {\\n                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\\n                }\\n            }\\n        }\\n        \\n        return dp[row - 1][col - 1]\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minDistance(_ word1: String, _ word2: String) -> Int {\\n        let row = word1.count + 1\\n        let col = word2.count + 1\\n        let chs1  = Array(word1)\\n        let chs2  = Array(word2)\\n        var dp: [[Int]] = Array(repeating: Array(repeating: 0, count: col), count: row)\\n        \\n        for i in 0..<row { \\n            for j in 0..<col {\\n                if i == 0 {\\n                    dp[i][j] = j\\n                \\n                } else if j == 0 {\\n                    dp[i][j] = i\\n                \\n                } else if chs1[i - 1] == chs2[j - 1] {\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                \\n                } else {\\n                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\\n                }\\n            }\\n        }\\n        \\n        return dp[row - 1][col - 1]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359663,
                "title": "java-recursion-memoization-easy",
                "content": "Memoization Code is much better than recursion, yes DP is more fast than memoization. I put this because lots of students get confused while doing memoization\\n To do any Dp question, follow these three steps :-\\n1. Try to make solution via recursion\\n2. Try to make solution via memoization\\n3. then move to Dp\\n```    \\n    //Memoization Code\\n     public int minDistance(String word1, String word2) {\\n         int m = word1.length();\\n         int n = word2.length();\\n         int storage[][] = new int[m+1][n+1];\\n         for(int i=0;i<=m;i++){\\n             for(int j=0;j<=n;j++){\\n             storage[i][j] = -1;\\n             }\\n         }\\n         \\n         return editMemo(word1,word2,storage);\\n     }\\n    \\n    public int editMemo(String word1, String word2, int storage[][]){\\n        int m = word1.length();\\n         int n = word2.length();\\n        if(storage[m][n] != -1){\\n            return storage[m][n];\\n        }\\n        if(m==0) return storage[m][n] = n;\\n        if(n==0) return storage[m][n] = m;\\n         if(word1.charAt(0) == word2.charAt(0)){\\n            return storage[m][n] = editMemo(word1.substring(1),word2.substring(1),storage);\\n         }else{\\n               //insert\\n            int insert = editMemo(word1,word2.substring(1),storage);\\n             //delete\\n            int delete = editMemo(word1.substring(1),word2,storage);\\n             //replace \\n            int replace = editMemo(word1.substring(1),word2.substring(1),storage);\\n              storage[m][n] = 1 + Math.min(insert,Math.min(delete,replace));\\n         }\\n        return storage[m][n];\\n    }\\n    \\n```    \\n    \\n\\t\\n   It gives us TLE, because strings present in test cases can be so long\\n   ```\\n   // Recursion Solution\\n    public int minDistance(String word1, String word2) {\\n         if(word1.length() == 0){\\n             return word2.length();\\n         }\\n         if(word2.length() == 0){\\n             return word1.length();\\n         }\\n        \\n         if(word1.charAt(0) == word2.charAt(0)){\\n             return minDistance(word1.substring(1),word2.substring(1));\\n        }else{\\n             //insert\\n             int insert = minDistance(word1,word2.substring(1));\\n              //delete\\n             int delete = minDistance(word1.substring(1),word2);\\n              //replace \\n             int replace = minDistance(word1.substring(1),word2.substring(1));\\n               return 1 + Math.min(insert,Math.min(delete,replace));\\n         }\\n     }\\n\\t ```\\n**If you like this, please upvote and like this**",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```    \\n    //Memoization Code\\n     public int minDistance(String word1, String word2) {\\n         int m = word1.length();\\n         int n = word2.length();\\n         int storage[][] = new int[m+1][n+1];\\n         for(int i=0;i<=m;i++){\\n             for(int j=0;j<=n;j++){\\n             storage[i][j] = -1;\\n             }\\n         }\\n         \\n         return editMemo(word1,word2,storage);\\n     }\\n    \\n    public int editMemo(String word1, String word2, int storage[][]){\\n        int m = word1.length();\\n         int n = word2.length();\\n        if(storage[m][n] != -1){\\n            return storage[m][n];\\n        }\\n        if(m==0) return storage[m][n] = n;\\n        if(n==0) return storage[m][n] = m;\\n         if(word1.charAt(0) == word2.charAt(0)){\\n            return storage[m][n] = editMemo(word1.substring(1),word2.substring(1),storage);\\n         }else{\\n               //insert\\n            int insert = editMemo(word1,word2.substring(1),storage);\\n             //delete\\n            int delete = editMemo(word1.substring(1),word2,storage);\\n             //replace \\n            int replace = editMemo(word1.substring(1),word2.substring(1),storage);\\n              storage[m][n] = 1 + Math.min(insert,Math.min(delete,replace));\\n         }\\n        return storage[m][n];\\n    }\\n    \\n```\n```\\n   // Recursion Solution\\n    public int minDistance(String word1, String word2) {\\n         if(word1.length() == 0){\\n             return word2.length();\\n         }\\n         if(word2.length() == 0){\\n             return word1.length();\\n         }\\n        \\n         if(word1.charAt(0) == word2.charAt(0)){\\n             return minDistance(word1.substring(1),word2.substring(1));\\n        }else{\\n             //insert\\n             int insert = minDistance(word1,word2.substring(1));\\n              //delete\\n             int delete = minDistance(word1.substring(1),word2);\\n              //replace \\n             int replace = minDistance(word1.substring(1),word2.substring(1));\\n               return 1 + Math.min(insert,Math.min(delete,replace));\\n         }\\n     }\\n\\t ```",
                "codeTag": "Unknown"
            },
            {
                "id": 662992,
                "title": "javascript-dynamic-programming-concise-code-with-explanation",
                "content": "This is one of the problems taken directly from a farily well known algorithm.\\n\\nMinimum edit distance / Levenshtein Distance\\nWhat are the minimal # of edits (change, add, delete char) to convert 1 string to another\\nIt\\'s a DP problem, looking at a character at a time.  \\n\\nFor each chacter, you either don\\'t need to change it, you need to delete it, or you need to change it.\\nKeep doing that character after character for each possibility and since we are interested in the minimum number of changes, just keep track of the lowest #.\\n\\nTake a look at this great visual explanation:\\nhttps://www.youtube.com/watch?v=We3YDTzNXEk\\n\\n```\\nvar minDistance = function(word1, word2) {\\n  let dp = Array(word1.length+1).fill().map(()=>Array(word2.length+1)); // Get our DP matrix setup, no need for default values since we\\'ll be filling each each of them\\n  \\n  for (let r=0; r<=word1.length; r++) {\\n    for (let c=0; c<=word2.length; c++) {\\n      if (r==0) dp[0][c] = c; // here we setup the initial row\\n      else if (c==0) dp[r][0] = r; // here the initial column\\n      else if (word1[r-1] == word2[c-1]) //now, if the letter is the same, cost is the same as the upper left cost\\n        dp[r][c] = dp[r-1][c-1];\\n      else //letters are different, so we will either need to change or delete one of the letters so prev cost +1 operation\\n        dp[r][c] = Math.min(dp[r][c-1],dp[r-1][c-1], dp[r-1][c]) +1;\\n    }\\n  }\\n  return dp[word1.length][word2.length]; //return the cost at the end of the string\\n};\\n```\\n\\nIf this explanation helped, please upvote this post so others can notice it.  Cheers!",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minDistance = function(word1, word2) {\\n  let dp = Array(word1.length+1).fill().map(()=>Array(word2.length+1)); // Get our DP matrix setup, no need for default values since we\\'ll be filling each each of them\\n  \\n  for (let r=0; r<=word1.length; r++) {\\n    for (let c=0; c<=word2.length; c++) {\\n      if (r==0) dp[0][c] = c; // here we setup the initial row\\n      else if (c==0) dp[r][0] = r; // here the initial column\\n      else if (word1[r-1] == word2[c-1]) //now, if the letter is the same, cost is the same as the upper left cost\\n        dp[r][c] = dp[r-1][c-1];\\n      else //letters are different, so we will either need to change or delete one of the letters so prev cost +1 operation\\n        dp[r][c] = Math.min(dp[r][c-1],dp[r-1][c-1], dp[r-1][c]) +1;\\n    }\\n  }\\n  return dp[word1.length][word2.length]; //return the cost at the end of the string\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662497,
                "title": "java-c-python3-with-detailed-explanation",
                "content": "```\\nEXPLANATION:-\\n\\nIn this problem, we need to convert w1 to w2 with minimum number of operations\\n\\nLet\\'s see how to solve this problem.\\n\\nCase 1:-\\n   w1 = ab,  w2 = \"\"\\n   result = 2.\\n   we can convert w1 to w2 by \\n   deleting all the characters in w1.\\n   So, result is 2.\\nCase 2:-\\n   w1 = \"\", w2 = ab\\n   we can convert w1 to w2, \\n   by inserting a and b it w1.\\n   So, result is 2.\\nCase 3:-\\n   w1 = a,  w2 = a\\n   w1 and w2 are equal.\\n   So, result is 0.\\n   \\nCase 4:-\\n    w1 = a,  w2 = b\\n\\tHere, w1 and w2 are not equal.\\n\\tSo, What to do now.\\n\\tWe have three operations\\n\\t1. insert\\n\\t2. delete\\n\\t3. replace\\n\\tperform three operations on w1.\\n\\tand take minimum result.\\n\\t\\n\\tw1 = a,  w2 = b.\\n\\tindex1 = 0\\n\\tindex2 = 0\\n\\toperations = 0\\n\\t\\n\\t1.insert \\n\\t\\n\\tinsert b to w1.\\n\\tSo, w1 = ba, w2 = b\\n\\toperations is increased by since we have inserted a character.\\n\\toperations = 1\\n\\tNow, w1[index1] == w2[index2],\\n\\tSo, ignore those characters and check remaining characters.\\n    So, w1 = a, w2 = \"\" (after ignoring first characters as they are same)\\n\\tThis is same as case 1.\\n\\twe can w2 from w1 by deleting \\'a\\'.\\n\\tSo, delete \\'a\\'\\n\\t- >  operations = 2.\\n\\n\\t 2. Delete:-\\n\\n\\t w1 = a, w2 = b, operations = 0\\n\\t delete a character from w1\\n\\t So, operations = 1\\n\\t w1 = \"\", w2 = b\\n\\t this is same as case 2.\\n\\t we can w2 from w1 by inserting \\'b\\' to w1.\\n\\t So, insert \\'b\\'.\\n\\t - > operations = 2.\\n\\n\\t 3. replace:\\n\\t \\n\\t  w1 = a, w2 = b, operations = 0\\n\\t  replace a with b.\\n\\t  operations = 1.\\n\\t  w1 = w2\\n\\t  So, operations = 1.\\n  \\n\\t  Now, choose minimum of (insert, delete, replace) = min(2, 2, 1)\\n  \\n\\t  So, result = 1 to convert a to b.\\n  \\n  This is the idea behind this.\\n  \\n  IF YOU HAVE ANY DOUBTS, FEEL FREE TO ASK.\\n \\xA0IF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE.\\n```\\n```\\n\\nJava : -\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n\\t\\tint M = word1.length();\\n\\t\\tint N = word2.length();\\n\\t\\tint dp[][] = new int[M + 1][N + 1];\\n\\t\\tif (M * N == 0)\\n\\t\\t\\treturn M + N;\\n\\n\\t\\tfor (int i = 0; i <= M; i++) {\\n\\t\\t\\tdp[i][0] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= N; i++) {\\n\\t\\t\\tdp[0][i] = i;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= M; i++) {\\n\\t\\t\\tfor (int j = 1; j <= N; j++) {\\n\\t\\t\\t\\tif (word1.charAt(i - 1) == word2.charAt(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[M][N];\\n\\n\\t}\\n}\\n\\nC++:-\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n\\t\\tint M = word1.size();\\n\\t\\tint N = word2.size();\\n\\t\\tvector<vector<int>> dp(M + 1, vector<int>(N + 1, 0));\\n\\t\\tif (M * N == 0)\\n\\t\\t\\treturn M + N;\\n\\n\\t\\tfor (int i = 0; i <= M; i++) {\\n\\t\\t\\tdp[i][0] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= N; i++) {\\n\\t\\t\\tdp[0][i] = i;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= M; i++) {\\n\\t\\t\\tfor (int j = 1; j <= N; j++) {\\n\\t\\t\\t\\tif (word1.at(i - 1) == word2.at(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[M][N];\\n    }\\n};\\n\\nPython3:-\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        M, N = len(word1), len(word2)\\n        if M * N == 0:\\n            return M + N\\n        dp = [[0] * (N + 1) for i in range(M + 1)]\\n\\n        for i in range(M + 1):\\n            dp[i][0] = i\\n        for i in range(N + 1):\\n            dp[0][i] = i\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1]))\\n        return dp[M][N]\\n```",
                "solutionTags": [],
                "code": "```\\nEXPLANATION:-\\n\\nIn this problem, we need to convert w1 to w2 with minimum number of operations\\n\\nLet\\'s see how to solve this problem.\\n\\nCase 1:-\\n   w1 = ab,  w2 = \"\"\\n   result = 2.\\n   we can convert w1 to w2 by \\n   deleting all the characters in w1.\\n   So, result is 2.\\nCase 2:-\\n   w1 = \"\", w2 = ab\\n   we can convert w1 to w2, \\n   by inserting a and b it w1.\\n   So, result is 2.\\nCase 3:-\\n   w1 = a,  w2 = a\\n   w1 and w2 are equal.\\n   So, result is 0.\\n   \\nCase 4:-\\n    w1 = a,  w2 = b\\n\\tHere, w1 and w2 are not equal.\\n\\tSo, What to do now.\\n\\tWe have three operations\\n\\t1. insert\\n\\t2. delete\\n\\t3. replace\\n\\tperform three operations on w1.\\n\\tand take minimum result.\\n\\t\\n\\tw1 = a,  w2 = b.\\n\\tindex1 = 0\\n\\tindex2 = 0\\n\\toperations = 0\\n\\t\\n\\t1.insert \\n\\t\\n\\tinsert b to w1.\\n\\tSo, w1 = ba, w2 = b\\n\\toperations is increased by since we have inserted a character.\\n\\toperations = 1\\n\\tNow, w1[index1] == w2[index2],\\n\\tSo, ignore those characters and check remaining characters.\\n    So, w1 = a, w2 = \"\" (after ignoring first characters as they are same)\\n\\tThis is same as case 1.\\n\\twe can w2 from w1 by deleting \\'a\\'.\\n\\tSo, delete \\'a\\'\\n\\t- >  operations = 2.\\n\\n\\t 2. Delete:-\\n\\n\\t w1 = a, w2 = b, operations = 0\\n\\t delete a character from w1\\n\\t So, operations = 1\\n\\t w1 = \"\", w2 = b\\n\\t this is same as case 2.\\n\\t we can w2 from w1 by inserting \\'b\\' to w1.\\n\\t So, insert \\'b\\'.\\n\\t - > operations = 2.\\n\\n\\t 3. replace:\\n\\t \\n\\t  w1 = a, w2 = b, operations = 0\\n\\t  replace a with b.\\n\\t  operations = 1.\\n\\t  w1 = w2\\n\\t  So, operations = 1.\\n  \\n\\t  Now, choose minimum of (insert, delete, replace) = min(2, 2, 1)\\n  \\n\\t  So, result = 1 to convert a to b.\\n  \\n  This is the idea behind this.\\n  \\n  IF YOU HAVE ANY DOUBTS, FEEL FREE TO ASK.\\n \\xA0IF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE.\\n```\n```\\n\\nJava : -\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n\\t\\tint M = word1.length();\\n\\t\\tint N = word2.length();\\n\\t\\tint dp[][] = new int[M + 1][N + 1];\\n\\t\\tif (M * N == 0)\\n\\t\\t\\treturn M + N;\\n\\n\\t\\tfor (int i = 0; i <= M; i++) {\\n\\t\\t\\tdp[i][0] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= N; i++) {\\n\\t\\t\\tdp[0][i] = i;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= M; i++) {\\n\\t\\t\\tfor (int j = 1; j <= N; j++) {\\n\\t\\t\\t\\tif (word1.charAt(i - 1) == word2.charAt(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[M][N];\\n\\n\\t}\\n}\\n\\nC++:-\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n\\t\\tint M = word1.size();\\n\\t\\tint N = word2.size();\\n\\t\\tvector<vector<int>> dp(M + 1, vector<int>(N + 1, 0));\\n\\t\\tif (M * N == 0)\\n\\t\\t\\treturn M + N;\\n\\n\\t\\tfor (int i = 0; i <= M; i++) {\\n\\t\\t\\tdp[i][0] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= N; i++) {\\n\\t\\t\\tdp[0][i] = i;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= M; i++) {\\n\\t\\t\\tfor (int j = 1; j <= N; j++) {\\n\\t\\t\\t\\tif (word1.at(i - 1) == word2.at(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[M][N];\\n    }\\n};\\n\\nPython3:-\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        M, N = len(word1), len(word2)\\n        if M * N == 0:\\n            return M + N\\n        dp = [[0] * (N + 1) for i in range(M + 1)]\\n\\n        for i in range(M + 1):\\n            dp[i][0] = i\\n        for i in range(N + 1):\\n            dp[0][i] = i\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1]))\\n        return dp[M][N]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162330,
                "title": "very-detailed-explanation-recursive-dp-in-java",
                "content": "The first step towards solving a DP problem is to build up the recursion tree. Once you have done it, it could be optimized using memoization, or a bottoms-up. Memoization is no brainer but bottoms-up takes a bit to get it right. I will try to outline how to build up the recursive solution and then move to DP from there. \\n\\nThis algorithm is based on standard L-distance, where would you do something of this sort:\\n```\\nif two characters are not equal:\\n\\t//cost to replace\\n\\tint replaceCount = 1 + function(s1, i+1, s2, j+1); // add 1 to the cost of replacing a character and go to the next set of characters.\\n\\t//cost to delete.\\n\\tint deleteCount = 1 + function(s1, i+1, s2, j); //add 1 to the cost of deleting the current char from string 1 and move to the next character from the first string assuming the current character won\\'t be considered anymore.\\n\\t//cost to add.\\n\\tint addCount = 1 + function(s1, i, s2, j+1);//add 1 to the cost of adding a new character to the second string and compare it with the current character from string 1. \\n```\\n\\nBased on the fact above, you could come up with the following recursive code:\\n```\\nprivate int helper(String s1,  int i, String s2, int j) {\\n        if (i == s1.length()) {\\n            //the first word came to an end.\\n            return s2.length()-j;\\n        } else if (j == s2.length()) {\\n            return s1.length() - i;\\n        } else if (s1.charAt(i) == s2.charAt(j)) {\\n            return helper(s1, i+1, s2, j+1);            \\n        }\\n        else {\\n            //replace.\\n            int replaceCount = 1 + helper(s1, i+1, s2, j+1);\\n            //delete.\\n            int deleteCount = 1 + helper(s1, i+1, s2, j);\\n            //add.\\n            int addCount = 1 + helper(s1, i, s2, j+1);\\n            return Math.min(replaceCount,Math.min(deleteCount, addCount));\\n        }\\n    }\\n\\t\\t\\nAnd, call it with helper(word1,0,word2,0).\\n```\\n\\nThe above does exhaustive traversal causing an exponential time complexity. You could fix it to make O(m*n) by doing memoization and I won\\'t discuss it here.\\n\\nDoing a bottoms-up DP requires us to think differently. You solve the first problem and then use that to solve the next problem. If you look at our recursive solution above, we are doing exactly the oppostive. We can\\'t use the recursive equation as it is since our solution of the current stack depends on the next stack and DP requires us to think it in the opposite way. So we will rewrite our recursive equation to suit this need. Here is the code for that:\\n\\n```\\n    private int helper_rec(String s1,  int i, String s2, int j) {\\n        if (i < 0) {\\n            //the first word came to an end.\\n            return j+1;\\n        } else if (j < 0) {\\n            return i+1;\\n        } else if (s1.charAt(i) == s2.charAt(j)) {\\n            return helper_rec(s1, i-1, s2, j-1);            \\n        }\\n        else {\\n            //replace.\\n            int replaceCount = 1 + helper_rec(s1, i-1, s2, j-1);\\n            //delete.\\n            int deleteCount = 1 + helper_rec(s1, i-1, s2, j);\\n            //add.\\n            int addCount = 1 + helper_rec(s1, i, s2, j-1);\\n            return Math.min(replaceCount,Math.min(deleteCount, addCount));\\n        }\\n    }\\n```\\n\\nWe are now good. We are building the solution from the previous solution and this is what the DP requires. Now to use the DP, here is what we need to consider:\\n1. Creating a 2-d array that may represent both words.\\n2. Thinking about an index \"0\" that is always initialized with some value for both i and j.\\n3. How to use the recursive condition from the above.\\n\\n```\\n1. For the first part, just create an array with the size of those words.\\nint[][] arr = new int[word1.length()+1][word2.length()+1];\\n\\n2. Initialization is a bit tricky but we could assume that the index \\'0\\' is basically an empty  string and how could we convert a string  to an empty string. Here is how we initialize that part:\\n        //set the boundary conditions.\\n        for (int i = 0; i<arr.length; i++) {\\n            arr[i][0] = i; \\n        }\\n        \\n        for (int j = 0; j<arr[0].length; j++) {\\n            arr[0][j] = j; \\n        }\\n\\t\\t\\t\\t\\n3. Using recursive condition: it is pretty much straight-foward:\\n //replace.\\n                    int replaceCount = 1 + arr[i-1][j-1];\\n                    //delete.\\n                    int deleteCount = 1 + arr[i-1][j]; \\n                    //add.\\n                    int addCount = 1 + arr[i][j-1];\\n                    arr[i][j] =  Math.min(replaceCount,Math.min(deleteCount, addCount));\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tThe above is an equivalent of our recursive equation where the position of the index is actually a subscript of an  array.\\n\\t\\t\\t\\n\\t\\t\\t\\nThe only other thing to remember is when the characters match, we want to reuse the last known cost. That\\'s if the characters match at arr[i][j], the new cost will be arr[i-1][j-1] since that will still apply to our next set of iterations.\\n```\\n\\nHere is the working code for the above:\\n```\\n    public int minDistance(String word1, String word2) {\\n        //return helper_rec(word1, word1.length()-1, word2, word2.length()-1);        \\n        int[][] arr = new int[word1.length()+1][word2.length()+1];\\n        //set the boundary conditions.\\n        for (int i = 0; i<arr.length; i++) {\\n            arr[i][0] = i; \\n        }\\n        \\n        for (int j = 0; j<arr[0].length; j++) {\\n            arr[0][j] = j; \\n        }\\n        \\n         for (int i=1; i<=word1.length();i++){\\n             for (int j=1; j<=word2.length() ;j++) {\\n                 if (word1.charAt(i-1) != word2.charAt(j-1)) {\\n                     //replace.\\n                    int replaceCount = 1 + arr[i-1][j-1];\\n                    //delete.\\n                    int deleteCount = 1 + arr[i-1][j]; \\n                    //add.\\n                    int addCount = 1 + arr[i][j-1];\\n                    arr[i][j] =  Math.min(replaceCount,Math.min(deleteCount, addCount));\\n                 } else {\\n                     arr[i][j] = arr[i-1][j-1];\\n                 }\\n             }\\n         }   \\n        \\n        return arr[word1.length()][word2.length()];\\n    }\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nif two characters are not equal:\\n\\t//cost to replace\\n\\tint replaceCount = 1 + function(s1, i+1, s2, j+1); // add 1 to the cost of replacing a character and go to the next set of characters.\\n\\t//cost to delete.\\n\\tint deleteCount = 1 + function(s1, i+1, s2, j); //add 1 to the cost of deleting the current char from string 1 and move to the next character from the first string assuming the current character won\\'t be considered anymore.\\n\\t//cost to add.\\n\\tint addCount = 1 + function(s1, i, s2, j+1);//add 1 to the cost of adding a new character to the second string and compare it with the current character from string 1. \\n```\n```\\nprivate int helper(String s1,  int i, String s2, int j) {\\n        if (i == s1.length()) {\\n            //the first word came to an end.\\n            return s2.length()-j;\\n        } else if (j == s2.length()) {\\n            return s1.length() - i;\\n        } else if (s1.charAt(i) == s2.charAt(j)) {\\n            return helper(s1, i+1, s2, j+1);            \\n        }\\n        else {\\n            //replace.\\n            int replaceCount = 1 + helper(s1, i+1, s2, j+1);\\n            //delete.\\n            int deleteCount = 1 + helper(s1, i+1, s2, j);\\n            //add.\\n            int addCount = 1 + helper(s1, i, s2, j+1);\\n            return Math.min(replaceCount,Math.min(deleteCount, addCount));\\n        }\\n    }\\n\\t\\t\\nAnd, call it with helper(word1,0,word2,0).\\n```\n```\\n    private int helper_rec(String s1,  int i, String s2, int j) {\\n        if (i < 0) {\\n            //the first word came to an end.\\n            return j+1;\\n        } else if (j < 0) {\\n            return i+1;\\n        } else if (s1.charAt(i) == s2.charAt(j)) {\\n            return helper_rec(s1, i-1, s2, j-1);            \\n        }\\n        else {\\n            //replace.\\n            int replaceCount = 1 + helper_rec(s1, i-1, s2, j-1);\\n            //delete.\\n            int deleteCount = 1 + helper_rec(s1, i-1, s2, j);\\n            //add.\\n            int addCount = 1 + helper_rec(s1, i, s2, j-1);\\n            return Math.min(replaceCount,Math.min(deleteCount, addCount));\\n        }\\n    }\\n```\n```\\n1. For the first part, just create an array with the size of those words.\\nint[][] arr = new int[word1.length()+1][word2.length()+1];\\n\\n2. Initialization is a bit tricky but we could assume that the index \\'0\\' is basically an empty  string and how could we convert a string  to an empty string. Here is how we initialize that part:\\n        //set the boundary conditions.\\n        for (int i = 0; i<arr.length; i++) {\\n            arr[i][0] = i; \\n        }\\n        \\n        for (int j = 0; j<arr[0].length; j++) {\\n            arr[0][j] = j; \\n        }\\n\\t\\t\\t\\t\\n3. Using recursive condition: it is pretty much straight-foward:\\n //replace.\\n                    int replaceCount = 1 + arr[i-1][j-1];\\n                    //delete.\\n                    int deleteCount = 1 + arr[i-1][j]; \\n                    //add.\\n                    int addCount = 1 + arr[i][j-1];\\n                    arr[i][j] =  Math.min(replaceCount,Math.min(deleteCount, addCount));\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tThe above is an equivalent of our recursive equation where the position of the index is actually a subscript of an  array.\\n\\t\\t\\t\\n\\t\\t\\t\\nThe only other thing to remember is when the characters match, we want to reuse the last known cost. That\\'s if the characters match at arr[i][j], the new cost will be arr[i-1][j-1] since that will still apply to our next set of iterations.\\n```\n```\\n    public int minDistance(String word1, String word2) {\\n        //return helper_rec(word1, word1.length()-1, word2, word2.length()-1);        \\n        int[][] arr = new int[word1.length()+1][word2.length()+1];\\n        //set the boundary conditions.\\n        for (int i = 0; i<arr.length; i++) {\\n            arr[i][0] = i; \\n        }\\n        \\n        for (int j = 0; j<arr[0].length; j++) {\\n            arr[0][j] = j; \\n        }\\n        \\n         for (int i=1; i<=word1.length();i++){\\n             for (int j=1; j<=word2.length() ;j++) {\\n                 if (word1.charAt(i-1) != word2.charAt(j-1)) {\\n                     //replace.\\n                    int replaceCount = 1 + arr[i-1][j-1];\\n                    //delete.\\n                    int deleteCount = 1 + arr[i-1][j]; \\n                    //add.\\n                    int addCount = 1 + arr[i][j-1];\\n                    arr[i][j] =  Math.min(replaceCount,Math.min(deleteCount, addCount));\\n                 } else {\\n                     arr[i][j] = arr[i-1][j-1];\\n                 }\\n             }\\n         }   \\n        \\n        return arr[word1.length()][word2.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25969,
                "title": "my-clean-java-solution-with-o-n-space-in-17-lines",
                "content": "    public class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int[] d = new int[word2.length() + 1];\\n            for (int i = 0; i <= word2.length(); ++i) d[i] = i;\\n            for (int i = 1; i <= word1.length(); ++i) {\\n                int prev = d[0];\\n                d[0] = i;\\n                for (int j = 1; j <= word2.length(); ++j) {\\n                    int tmp = d[j];\\n                    d[j] = Math.min(d[j - 1], d[j]) + 1;\\n                    d[j] = Math.min(d[j], prev + (word1.charAt(i -1) == word2.charAt(j - 1) ? 0: 1));\\n                    prev = tmp;\\n                }\\n            }\\n            return d[word2.length()];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int[] d = new int[word2.length() + 1];\\n            for (int i = 0; i <= word2.length(); ++i) d[i] = i;\\n            for (int i = 1; i <= word1.length(); ++i) {\\n                int prev = d[0];\\n                d[0] = i;\\n                for (int j = 1; j <= word2.length(); ++j) {\\n                    int tmp = d[j];\\n                    d[j] = Math.min(d[j - 1], d[j]) + 1;\\n                    d[j] = Math.min(d[j], prev + (word1.charAt(i -1) == word2.charAt(j - 1) ? 0: 1));\\n                    prev = tmp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3230647,
                "title": "look-at-once-solutions-in-java-python-and-c-with-video-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use dynamic programming. We will create a 2D array to store the minimum number of operations required to convert a substring of word1 to a substring of word2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet dp[i][j] be the minimum number of operations required to convert the first i characters of word1 to the first j characters of word2. We will fill up this 2D array from top to bottom and from left to right.\\n\\nIf `word1[i-1] == word2[j-1]`, then no operation is required to convert `word1[0:i-1]` to `word2[0:j-1]`. Therefore, `dp[i][j] = dp[i-1][j-1]`.\\n\\nIf `word1[i-1] != word2[j-1]`, then we have three options:\\n\\n1. Replace: Replace the i-th character of word1 with the j-th character of word2. `dp[i][j] = dp[i-1][j-1] + 1`.\\n\\n2. Delete: Delete the i-th character of word1.` dp[i][j] = dp[i-1][j] + 1`.\\n\\n3. Insert: Insert the j-th character of word2 into word1. `dp[i][j] = dp[i][j-1] + 1`.\\n\\nThe final answer will be stored in `dp[word1.length()][word2.length()]`.\\n\\n# Video reference\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZkgBinDx9Kg\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n![image.png](https://assets.leetcode.com/users/images/2b37d2cc-3ca9-4b0c-866d-48abc59d8fa5_1677216789.1769023.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the dynamic programming solution is $$O(mn)$$, where m and n are the lengths of word1 and word2, respectively. This is because we fill up a 2D array of size (m+1) x (n+1) using nested loops.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nThe space complexity of the dynamic programming solution is $$O(mn)$$, where m and n are the lengths of word1 and word2, respectively. This is because we use a 2D array of size (m+1) x (n+1) to store the minimum number of operations required to convert substrings of word1 to substrings of word2.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int[][] dp = new int[word1.length()+1][word2.length()+1];\\n        \\n        for (int i = 0; i <= word1.length(); i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= word2.length(); j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= word1.length(); i++) {\\n            for (int j = 1; j <= word2.length(); j++) {\\n                if (word1.charAt(i-1) == word2.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[word1.length()][word2.length()];\\n    }\\n}\\n\\n```\\n```javascript []\\nvar minDistance = function(word1, word2) {\\n    const m = word1.length;\\n    const n = word2.length;\\n    const dp = new Array(m+1).fill(null).map(() => new Array(n+1).fill(null));\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i][0] = i;\\n    }\\n    \\n    for (let j = 0; j <= n; j++) {\\n        dp[0][j] = j;\\n    }\\n    \\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            if (word1[i-1] === word2[j-1]) {\\n                dp[i][j] = dp[i-1][j-1];\\n            } else {\\n                dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n];\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        \\n        for i in range(m+1):\\n            dp[i][0] = i\\n        \\n        for j in range(n+1):\\n            dp[0][j] = j\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\\n        \\n        return dp[m][n]\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i-1] == word2[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n`````\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int[][] dp = new int[word1.length()+1][word2.length()+1];\\n        \\n        for (int i = 0; i <= word1.length(); i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= word2.length(); j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= word1.length(); i++) {\\n            for (int j = 1; j <= word2.length(); j++) {\\n                if (word1.charAt(i-1) == word2.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[word1.length()][word2.length()];\\n    }\\n}\\n\\n```\n```javascript []\\nvar minDistance = function(word1, word2) {\\n    const m = word1.length;\\n    const n = word2.length;\\n    const dp = new Array(m+1).fill(null).map(() => new Array(n+1).fill(null));\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i][0] = i;\\n    }\\n    \\n    for (let j = 0; j <= n; j++) {\\n        dp[0][j] = j;\\n    }\\n    \\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            if (word1[i-1] === word2[j-1]) {\\n                dp[i][j] = dp[i-1][j-1];\\n            } else {\\n                dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n];\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        \\n        for i in range(m+1):\\n            dp[i][0] = i\\n        \\n        for j in range(n+1):\\n            dp[0][j] = j\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\\n        \\n        return dp[m][n]\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i-1] == word2[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707160,
                "title": "leetcode-the-hard-way-0072-edit-distance-hard",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=5by6g9bxPW8&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=26) if you are interested.\\n\\n---\\n\\nEdit distance is a classic DP problem. It is used to quantify the dissimilarity of two given strings by counting the minimum possible number of operations required to transform one string into the other. \\n\\nGiven that the constraints, we assume that a O(m * n) solution would pass. \\n\\nLet\\'s define ``dp[i][j]`` as the minimum edit distance between the first i character of ``word1`` and the first ``j`` characters of ``word2``. In example 1, ``dp[3][2]``would be the edit distance between ``word1[1..3]`` (HOR) and ``word2[1..2]``(RO). \\n\\nIf the last character is the same, then ``dp[i][j]`` would be ``dp[i - 1][j - 1]`` because we don\\'t need to perform any operation. Otherwise, we need to perform either one. There are three possible ways to do the transformation.\\n\\n- We can transform ``word1[1..i]`` to ``word2[1..j-1]`` by adding ``word2[j]`` afterwards to get ``word2[1..j]``.\\n- We can transform ``word1[1..i-1]`` to ``word2[1..j]`` by deleting ``word1[i]``.\\n- We can transform ``word1[1..i-1]`` to ``word2[1..j-1]`` by exchanging the original ``word1[i]`` for ``word2[j]``.\\n\\nTherefore, the transition would be ``dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])`` if ``word1[i]`` is not equal to ``word2[j]``.\\n\\nWhat is the base case then? The base case is simply an edit distance between the empty string and non-empty string, i.e. ``dp[i][0] = i`` and ``dp[0][j] = j``. The answer would be ``dp[m][n]``. This algorithm is also known as Wagner\\u2013Fischer algorithm.\\n\\n![image](https://assets.leetcode.com/users/images/00774ca9-da4e-4873-a6c5-9d7596b60b19_1642775600.173192.png)\\n\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = (int) word1.size();\\n        int n = (int) word2.size();\\n        int dp[m + 1][n + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for (int i = 1; i <= m; i++) dp[i][0] = i;\\n        for (int j = 1; j <= n; j++) dp[0][j] = j;\\n        for (int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(word1[i - 1] == word2[j - 1]) { // a = b\\n                    dp[i][j] = dp[i - 1][j - 1]; \\n                } else {\\n                    // find out the min cost for all three actions\\n                    dp[i][j] = 1 + min({\\n                        dp[i - 1][j - 1], // replace a with b\\n                        dp[i - 1][j],     // delete a\\n                        dp[i][j - 1]      // insert b after a\\n                    });\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1): dp[i][0] = i\\n        for j in range(1, n + 1): dp[0][j] = j\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    # a == b\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    # find out the min cost for all three actions\\n                    # dp[i - 1][j - 1]: replace a with b\\n                    # dp[i - 1][j]: delete a\\n                    # dp[i - 1][j]: insert b after a\\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\\n        return dp[m][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = (int) word1.size();\\n        int n = (int) word2.size();\\n        int dp[m + 1][n + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for (int i = 1; i <= m; i++) dp[i][0] = i;\\n        for (int j = 1; j <= n; j++) dp[0][j] = j;\\n        for (int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(word1[i - 1] == word2[j - 1]) { // a = b\\n                    dp[i][j] = dp[i - 1][j - 1]; \\n                } else {\\n                    // find out the min cost for all three actions\\n                    dp[i][j] = 1 + min({\\n                        dp[i - 1][j - 1], // replace a with b\\n                        dp[i - 1][j],     // delete a\\n                        dp[i][j - 1]      // insert b after a\\n                    });\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1): dp[i][0] = i\\n        for j in range(1, n + 1): dp[0][j] = j\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    # a == b\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    # find out the min cost for all three actions\\n                    # dp[i - 1][j - 1]: replace a with b\\n                    # dp[i - 1][j]: delete a\\n                    # dp[i - 1][j]: insert b after a\\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402780,
                "title": "begineerfriendly-java-c",
                "content": "**\\nFirstly go and read the code this is further explaination to my code you will get the explaination better after reading the code once\\nand this explaination is also covering the aswer to the comment .\\n\\ni m just checking at every index whether that character is equal or not, if equal I just have to move further  , but in case characters are not equal we can have 3 operations, ins, del, replace. and we are storing the minimum out of these three in the DP array.\\n\\nlet\\'s say s1 as \"abc\" and s2 as \"abd\" ,and we are at index 2, always if found both characters are different \\n\\n// Insertion (dp[i][j-1])\\nI m always inserting at the right of the current char\\n\\ns1 - \"abc\" s2 - \"abd\"\\ni is at c in s1 \\nj is at d in s2.\\n\\nafter insertion\\ns1 become \"abcd\", s2 remain the same \"abd\" ,\\ni is currently at c in s1 \\nand j  is currently at d in s2 , but as we have inserted a \\'d\\' in s1 we have to decrement j , i remains the same \\ni = I;    j = j-1;\\n\\n// deletion   ( dp[i-1][j] )\\n\\n if I chooses to delete c , instead of inserting d  , in this case if I m deleting c then I have to decrement i , but j remains the same.\\ns1 - \"abc\" s2 - \"abd\"\\n          i is at c in s1\\n\\t\\t  j is at d in s2\\n\\t\\t  \\nafter deletion s1 - \"ab\" s2 - \"abd\"\\n          as we have deleted c from s1 we should decrement i , but we will only decrement j once we found character equal to d in s1\\n         I = i-1 , j = j;\\n\\n// replace (dp[i-1][j-1])\\n\\nif I choose to replace i m making the current characters equal then I need to decrement both indices , I, j , because current characters are equal \\nnow we only have to check for remaining string\\n\\nex ----- s1 - \"abc\" s2 - \"abd\"\\nif I choose to replace  \\'c\\'  by  \\'d\\'   then both the strings become\\ns1 ---- \"abd\" s2 ---- \"abd\"\\n              as i is at d in s1 \\n\\t\\t\\t  and also j is at d in s2 , and both the characters are equal we just have to decrement both.\\n   I = i-1 , j = j-1;\\t\\n   \\n   \\n\\t\\nNote we are decrementing j only when both the character matches**\\n\\t\\n\\t//\\tif character matches then just decrement both the index , but if they don\\'t matches then store the minimum possibl;e value by applying\\n\\t\\t// each operation at that particular index.\\n\\t\\t\\n\\t\\tJava code\\n\\t\\t\\t\\n\\t\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic int minDistance(String s1, String s2) {\\n\\t\\t\\t\\t\\tint n = s1.length();\\n\\t\\t\\t\\t\\tint m = s2.length();\\n\\t\\t\\t\\t\\tint[][] dp = new int[n+1][m+1];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// base cases will contain the length of string which is not empty\\n\\t\\t\\t\\t\\t//because to convert empty string to another string we need no of operations = length of string\\n\\t\\t\\t\\t\\tfor(int i=0;i<=n;i++){\\n\\t\\t\\t\\t\\t\\tdp[i][0] = i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor(int i=0;i<=m;i++){\\n\\t\\t\\t\\t\\t\\tdp[0][i] = i;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\t\\t\\tif(s1.charAt(i-1) == s2.charAt(j-1)){\\n\\t\\t\\t\\t\\t\\t\\t//as characters are the same we are just decreasing the index\\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\t//chars are not the same now we have to put the minimum ans out of ans obtained by  insertion,deletion,replace  \\n\\t\\t\\t\\t\\t\\t\\t\\t//\\tminimum answer              min(insertion , deletion )          min(deletion,replace)             \\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][j] = 1 + Math.min( Math.min(dp[i][j-1] ,dp[i-1][j]) , Math.min(dp[i-1][j] ,dp[i-1][j-1]) );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn dp[n][m];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t//If the post was helpful please upvote , any query can be asked in the comments\\n\\t\\t\\t//thankyou for your upvote\\n\\t\\t\\t\\n\\t\\t\\t\\nC++ Code --------- Logic is same in both only difference is in syntax............\\n\\n\\t//\\tif character matches then just decrement both the index , but if they don\\'t matches then store the minimum possibl;e value by applying\\n\\t\\t// each operation at that particular index.\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\t\\tint n = s1.length();\\n\\t\\t\\t\\tint m = s2.length();\\n\\t\\t\\t\\tint dp[n+1][m+1];\\n\\n\\t\\t\\t\\t\\t// base cases will contain the length of string which is not empty\\n\\t\\t\\t\\t\\t//because to convert empty string to another string we need no of operations = length of string\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tfor(int i=0;i<=n;i++){\\n\\t\\t\\t\\t\\tdp[i][0] = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=0;i<=m;i++){\\n\\t\\t\\t\\t\\tdp[0][i] = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\t\\tfor(int j =1;j<=m;j++){\\n\\t\\t\\t\\t\\t//as characters are the same we are just decreasing the index\\n\\t\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1]){\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t\\t\\t}else{\\n\\t//chars are not the same now we have to put the minimum ans out of ans obtained by  insertion,deletion,replace \\n\\t//\\tminimum answer    =          min(  min(insertion , deletion )  ,  min(deletion,replace)   )          \\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = 1+ min(min(dp[i][j-1] , dp[i-1][j]) , min(dp[i-1][j-1] , dp[i-1][j-1]));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn dp[n][m];\\n\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t//If the post was helpful please upvote , any query can be asked in the comments\\n\\t\\t\\t//thankyou for your upvote\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\tpublic int minDistance(String s1, String s2) {\\n\\t\\t\\t\\t\\tint n = s1.length();\\n\\t\\t\\t\\t\\tint m = s2.length();\\n\\t\\t\\t\\t\\tint[][] dp = new int[n+1][m+1];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// base cases will contain the length of string which is not empty\\n\\t\\t\\t\\t\\t//because to convert empty string to another string we need no of operations = length of string\\n\\t\\t\\t\\t\\tfor(int i=0;i<=n;i++){\\n\\t\\t\\t\\t\\t\\tdp[i][0] = i;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1391563,
                "title": "c-3-steps-solution-easy-concise-explanation-complexities",
                "content": "* ###  **THIS PROBLEM IS A VERY CLASSICAL PROBLEM OF DP**\\n**EXPLANATION:**\\n1. **`THE IDEA IS VERY VERY SIMPLE, IF YOU UNDERSTAND THE RECURSIVE CODE LOGIC THEN, CONVERT IT INTO DP IS CAKEWALK !!! :)`**\\n\\n1. **`IN THIS PROBLEM WE\\'RE GIVEN A TWO STRINGS \"Word1\" && \"Word2\". WE NEED TO CONVERT FIRST STRING TO SECOND, WITH THE HELP OF THREE OPERATIONS (INSERT, DELETE, REPLACE)..`**\\n\\n1. **`STEP 1: WHEN BOTH CHARACTERS OF STRING MATCHES WE DO NOT HAVE TO DO ANYTHING (ANY OPERATIONS). JUST SIMPLY RECURR FOR NEXT ELEMENTS IN BOTH STRINGS`!**\\n1. **`STEP 2: WHEN CHARACTERS DOESN\\'T MATCH, WE NEED TO DO THREE OPERATIONS THAT IS`:**\\n        **`a) INSERT :  editDist(w1, w2, n, m - 1) :- Decrement second string size, cuz we have to insert character according to second string`** \\n        **`b) DELETE :  editDist(w1, w2, n - 1, m) :- Decrement first string size, cuz we to convert first string to second string =, by deleting characters`** \\n        **`c) REPLACE : editDist(w1, w2, n - 1, m - 1) :- Again, decrement Both string size, cuz let assume we replaced the character of second string with the character                                                    of first string. Hence, both characters are same again.`**  \\n1. **`STEP 3: TAKE THE MINIMUM OF THREE SUB-RESULTS.`**\\n### **RECURSIVE SOLUTION :- T.L.E. (Not Accepted)**\\n```\\n// Recursive Code\\nclass Solution {\\npublic:\\n    int editDist(string &w1, string &w2, int n, int m){\\n        if(n == 0)                          // Base Case 1 : If first string is empty, simply return second string len. Because, we need atleast second\\n            return m;                       //               string size or len to convert first into second\\n        else if(m == 0)\\n                return n;                   // Base Case2 2: Vice-Versa of above base case\\n        else if(w1[n - 1] == w2[m - 1])\\n               return editDist(w1, w2, n - 1, m - 1); //  when both characters are matched don\\'t need to do any operations \\n        else               \\n            return 1 + min({editDist(w1, w2, n, m - 1), editDist(w1, w2, n - 1, m), editDist(w1, w2, n - 1, m - 1)});  // When characters Doesn\\'t match \\n    }                                                                                                          // we need to do Three Operations as \\n    int minDistance(string word1, string word2) {                                                          // Mentioned Above & Take the minimum of them\\n        int n = word1.size(), m = word2.size();\\n        return editDist(word1, word2, n, m);\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(3^N)`, Where, `N = (m + n)`, n : size of word1 & m  : size of word2** \\n**SPACE COMPLEXITY : `O(constant)`, ignoring recusrion stack**\\n```\\n```\\n### **DP SOLUTION: TOP-DOWN OR MEMOIZATION (Accepted)**\\n* **Runtime : 10ms**\\n```\\n// Memoized Code (Top-Down)\\nclass Solution {\\npublic:\\n    int editDist(string &w1, string &w2, int n, int m, vector<vector<int>>& memo){\\n        if(n == 0)\\n            return m;\\n        if(m == 0)\\n                return n;\\n        if(memo[n][m] != -1)\\n            return memo[n][m];\\n        if(w1[n - 1] == w2[m - 1]){\\n            memo[n][m] = editDist(w1, w2, n - 1, m - 1, memo); //  when both characters are matched don\\'t need to do any operations\\n            return memo[n][m];\\n        }\\n        else{               // When characters Doesn\\'t match we need to do Three Operations as Mentioned Above & Take the minimum of them\\n            memo[n][m] = 1 + min({editDist(w1, w2, n, m - 1, memo), editDist(w1, w2, n - 1, m, memo), editDist(w1, w2, n - 1, m - 1, memo)});\\n            return memo[n][m];\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> memo(n + 1, vector<int> (m + 1, -1));\\n        return editDist(word1, word2, n, m, memo);\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(n * m)`, Where, n : size of word1 & m  : size of word2** \\n**SPACE COMPLEXITY : `O(n * m)`, For using 2D array Aux space & Again, ignoring recusrion stack**\\n```\\n```\\n### **DP SOLUTION: BOTTOM-UP OR TABULATION (Accepted)**\\n* **Runtime : 4ms**\\n```\\n// Tabulation Code (Bottom-Up)\\nclass Solution {\\npublic:\\n    int minDistance(string w1, string w2) {\\n        int n = w1.size(), m = w2.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n        for(int i = 0; i <= n; ++i)     // Base Case 1:\\n            dp[i][0] = i;\\n        \\n        for(int j = 0; j <=m; ++j)      // Base Case 2: \\n            dp[0][j] = j;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                if(w1[i - 1] == w2[j - 1])          //  when both characters are matched don\\'t need to do any operations\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                else                               // When characters Doesn\\'t match we need to do Three Operations as Mentioned Above & Take the minimum of them\\n                    dp[i][j] = 1 + min({dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]});\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(n * m)`, Where, n : size of word1 & m  : size of word2** \\n**SPACE COMPLEXITY :  `O(n * m)`, For using 2D array Aux space**\\n\\nif you find any mistakes pls, drop a comment\\nif it makes any sense **Pls Upvote :)**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n// Recursive Code\\nclass Solution {\\npublic:\\n    int editDist(string &w1, string &w2, int n, int m){\\n        if(n == 0)                          // Base Case 1 : If first string is empty, simply return second string len. Because, we need atleast second\\n            return m;                       //               string size or len to convert first into second\\n        else if(m == 0)\\n                return n;                   // Base Case2 2: Vice-Versa of above base case\\n        else if(w1[n - 1] == w2[m - 1])\\n               return editDist(w1, w2, n - 1, m - 1); //  when both characters are matched don\\'t need to do any operations \\n        else               \\n            return 1 + min({editDist(w1, w2, n, m - 1), editDist(w1, w2, n - 1, m), editDist(w1, w2, n - 1, m - 1)});  // When characters Doesn\\'t match \\n    }                                                                                                          // we need to do Three Operations as \\n    int minDistance(string word1, string word2) {                                                          // Mentioned Above & Take the minimum of them\\n        int n = word1.size(), m = word2.size();\\n        return editDist(word1, word2, n, m);\\n    }\\n};\\n```\n```\\n```\n```\\n// Memoized Code (Top-Down)\\nclass Solution {\\npublic:\\n    int editDist(string &w1, string &w2, int n, int m, vector<vector<int>>& memo){\\n        if(n == 0)\\n            return m;\\n        if(m == 0)\\n                return n;\\n        if(memo[n][m] != -1)\\n            return memo[n][m];\\n        if(w1[n - 1] == w2[m - 1]){\\n            memo[n][m] = editDist(w1, w2, n - 1, m - 1, memo); //  when both characters are matched don\\'t need to do any operations\\n            return memo[n][m];\\n        }\\n        else{               // When characters Doesn\\'t match we need to do Three Operations as Mentioned Above & Take the minimum of them\\n            memo[n][m] = 1 + min({editDist(w1, w2, n, m - 1, memo), editDist(w1, w2, n - 1, m, memo), editDist(w1, w2, n - 1, m - 1, memo)});\\n            return memo[n][m];\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> memo(n + 1, vector<int> (m + 1, -1));\\n        return editDist(word1, word2, n, m, memo);\\n    }\\n};\\n```\n```\\n```\n```\\n// Tabulation Code (Bottom-Up)\\nclass Solution {\\npublic:\\n    int minDistance(string w1, string w2) {\\n        int n = w1.size(), m = w2.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n        for(int i = 0; i <= n; ++i)     // Base Case 1:\\n            dp[i][0] = i;\\n        \\n        for(int j = 0; j <=m; ++j)      // Base Case 2: \\n            dp[0][j] = j;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                if(w1[i - 1] == w2[j - 1])          //  when both characters are matched don\\'t need to do any operations\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                else                               // When characters Doesn\\'t match we need to do Three Operations as Mentioned Above & Take the minimum of them\\n                    dp[i][j] = 1 + min({dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]});\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006113,
                "title": "recursion-and-memoization-aditya-verma-approach",
                "content": "Do upvote, if found helpful.\\n\\nRecursive - \\n\\n```\\nclass Solution {\\npublic:\\n\\n    int fun(string a, string b, int i, int j)\\n    {\\n        if(i<0)\\n        return j+1; \\n\\n        if(j<0)\\n        return i+1;\\n\\n        if(a[i]==b[j])\\n        return fun(a,b,i-1,j-1);\\n\\n        else\\n        return 1 + min(fun(a,b,i-1,j), min(fun(a,b,i,j-1),fun(a,b,i-1,j-1))); \\n    }\\n\\n    \\n    int minDistance(string a, string b) \\n    {\\n        int n = a.size();\\n        int m = b.size();\\n\\n        return fun(a,b,n-1,m-1);   \\n    }\\n};\\n```\\n\\nMemoization - \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n\\n    int fun(string a, string b, int i, int j)\\n    {\\n        if(i<0)\\n        return j+1; \\n\\n        if(j<0)\\n        return i+1;\\n\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n\\n        if(a[i]==b[j])\\n        return dp[i][j] = fun(a,b,i-1,j-1);\\n\\n        else\\n        return dp[i][j] = 1 + min(fun(a,b,i-1,j), min(fun(a,b,i,j-1),fun(a,b,i-1,j-1))); \\n    }\\n\\n    \\n    int minDistance(string a, string b) \\n    {\\n        int n = a.size();\\n        int m = b.size();\\n\\n        dp.clear();\\n        dp.resize(n+1,vector<int> (m+1,-1));\\n        return fun(a,b,n-1,m-1);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int fun(string a, string b, int i, int j)\\n    {\\n        if(i<0)\\n        return j+1; \\n\\n        if(j<0)\\n        return i+1;\\n\\n        if(a[i]==b[j])\\n        return fun(a,b,i-1,j-1);\\n\\n        else\\n        return 1 + min(fun(a,b,i-1,j), min(fun(a,b,i,j-1),fun(a,b,i-1,j-1))); \\n    }\\n\\n    \\n    int minDistance(string a, string b) \\n    {\\n        int n = a.size();\\n        int m = b.size();\\n\\n        return fun(a,b,n-1,m-1);   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n\\n    int fun(string a, string b, int i, int j)\\n    {\\n        if(i<0)\\n        return j+1; \\n\\n        if(j<0)\\n        return i+1;\\n\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n\\n        if(a[i]==b[j])\\n        return dp[i][j] = fun(a,b,i-1,j-1);\\n\\n        else\\n        return dp[i][j] = 1 + min(fun(a,b,i-1,j), min(fun(a,b,i,j-1),fun(a,b,i-1,j-1))); \\n    }\\n\\n    \\n    int minDistance(string a, string b) \\n    {\\n        int n = a.size();\\n        int m = b.size();\\n\\n        dp.clear();\\n        dp.resize(n+1,vector<int> (m+1,-1));\\n        return fun(a,b,n-1,m-1);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273352,
                "title": "java-7m-dp-solution-with-detailed-explanation",
                "content": "we use a array ```dist``` to save the minimum distance of substring of ```word1``` and ```word2```, i.e., ```dist[i][j]``` denotes the minimum distance of ```word1.substring(0, i)``` and ```word2.substring(0, j)```.\\nApparently, ```dist[0][j] = j``` and ```dist[i][0] = i```.\\nWhen we calculate ```dist[i][j]```, we first compare ```word1[i]``` and ```word2[j]```, if ```word1[i]``` equals ```word2[j]```, then ```dist[i][j]``` equals ```dist[i - 1][j - 1]```. If ```word1[i] != word2[j]```, then we have three operations:\\n1. replace word1[i] with word2[j] (```dist[i - 1][j - 1] + 1```)\\n2. delete word1[i] (```dist[i - 1][j] + 1```)\\n3. delete word2[j] (```dist[i][j - 1] + 1```)\\n\\nNote that insert and delete are symmetric operations, so we choice 2 is equal to insert character to word2 and choice 3 is equal to insert character to word1.\\n```\\npublic int minDistance(String word1, String word2) {\\n\\tint dist[][] = new int[word1.length() + 1][word2.length() + 1];\\n\\tfor(int i = 0; i < word1.length(); i++) \\n\\t\\tdist[i + 1][0] = i + 1;\\n\\tfor(int i = 0; i < word2.length(); i++)\\n\\t\\tdist[0][i + 1] = i + 1;\\n\\tfor(int i = 0; i < word1.length(); i++) {\\n\\t\\tfor(int j = 0; j < word2.length(); j++) {\\n\\t\\t\\tif( word1.charAt(i) == word2.charAt(j) )\\n\\t\\t\\t\\tdist[i + 1][j + 1] = dist[i][j];\\n\\t\\t\\telse\\n\\t\\t\\t\\tdist[i + 1][j + 1] = Math.min(Math.min(dist[i][j + 1], dist[i + 1][j]) + 1, dist[i][j] + 1);\\n\\t\\t}\\n\\t}\\n\\treturn dist[word1.length()][word2.length()];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```dist```\n```word1```\n```word2```\n```dist[i][j]```\n```word1.substring(0, i)```\n```word2.substring(0, j)```\n```dist[0][j] = j```\n```dist[i][0] = i```\n```dist[i][j]```\n```word1[i]```\n```word2[j]```\n```word1[i]```\n```word2[j]```\n```dist[i][j]```\n```dist[i - 1][j - 1]```\n```word1[i] != word2[j]```\n```dist[i - 1][j - 1] + 1```\n```dist[i - 1][j] + 1```\n```dist[i][j - 1] + 1```\n```\\npublic int minDistance(String word1, String word2) {\\n\\tint dist[][] = new int[word1.length() + 1][word2.length() + 1];\\n\\tfor(int i = 0; i < word1.length(); i++) \\n\\t\\tdist[i + 1][0] = i + 1;\\n\\tfor(int i = 0; i < word2.length(); i++)\\n\\t\\tdist[0][i + 1] = i + 1;\\n\\tfor(int i = 0; i < word1.length(); i++) {\\n\\t\\tfor(int j = 0; j < word2.length(); j++) {\\n\\t\\t\\tif( word1.charAt(i) == word2.charAt(j) )\\n\\t\\t\\t\\tdist[i + 1][j + 1] = dist[i][j];\\n\\t\\t\\telse\\n\\t\\t\\t\\tdist[i + 1][j + 1] = Math.min(Math.min(dist[i][j + 1], dist[i + 1][j]) + 1, dist[i][j] + 1);\\n\\t\\t}\\n\\t}\\n\\treturn dist[word1.length()][word2.length()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3230529,
                "title": "c-easiest-approach-with-best-explanation-beats-100-using-dp",
                "content": "# Intuition\\nThe problem requires finding the minimum number of operations required to convert one string to another. We can perform three types of operations: insert a character, delete a character, or replace a character.\\n\\nTo solve this problem, we can use dynamic programming. We can create a matrix where the rows represent the characters in the first string and the columns represent the characters in the second string. We can fill the matrix using a bottom-up approach.\\n\\nThe base case is when one of the strings is empty. In this case, the minimum number of operations required is equal to the length of the non-empty string.\\n\\nFor the general case, we can use the following recurrence relation: if the current characters in the two strings match, the minimum number of operations required is the same as the minimum number of operations required to convert the first i-1 characters in the first string to the first j-1 characters in the second string. Otherwise, we can either insert a character, delete a character, or replace a character. We can take the minimum of these three options and add one to get the minimum number of operations required to convert the first i characters in the first string to the first j characters in the second string.\\n\\nThe final answer is stored in the bottom-right corner of the matrix.<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere\\'s the step-by-step approach:\\n\\n1. Initialize a matrix dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2, respectively.\\n2. Fill in the base cases:\\ndp[i][0] = i for i from 0 to m.\\ndp[0][j] = j for j from 0 to n.\\n3. For each i from 1 to m and each j from 1 to n, compute the value of dp[i][j] as follows:\\n4. If word1[i-1] is equal to word2[j-1], then dp[i][j] = dp[i-1][j-1]. Otherwise, dp[i][j] is the minimum of the following three values plus 1:\\na) dp[i][j-1], which represents inserting a character in word1.\\nb) dp[i-1][j], which represents deleting a character in word1.\\nc) dp[i-1][j-1], which represents replacing a character in word1.\\n5. Return dp[m][n], which is the minimum number of operations required to convert word1 to word2.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is O(mn), where m and n are the lengths of the input strings. This is because we need to fill in an (m+1) x (n+1) matrix, and each cell takes constant time to fill.\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i-1] == word2[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = 1 + min({dp[i][j-1], dp[i-1][j], dp[i-1][j-1]});\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n//\\uD83D\\uDC47please upvote if you liked my approach and explanation\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i-1] == word2[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = 1 + min({dp[i][j-1], dp[i-1][j], dp[i-1][j-1]});\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n//\\uD83D\\uDC47please upvote if you liked my approach and explanation\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176745,
                "title": "python-recursive-memoization-tabular-dp-with-detailed-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/ebd26aeb-c4c8-45bd-90cb-1d01670b37b9_1655779370.086117.jpeg)\\n![image](https://assets.leetcode.com/users/images/8114c2a7-9765-4868-a01c-76eccc8d6c0f_1655779380.6150026.jpeg)\\n![image](https://assets.leetcode.com/users/images/fbf87ad1-e78e-4e9c-9c5f-d4b95385bf98_1655779388.4014256.jpeg)\\n\\n\\n\\n**Recursive**:\\n```\\nclass Solution:\\n    def minDistance(self, w1: str, w2: str) -> int:\\n        def solve(w1, w2, n, m): \\n            # Base Case if any one of w1 or w2 is empty \\n            if n == 0 or m == 0: return m or n\\n            \\n            elif w1[n-1] == w2[m-1]:\\n                return solve(w1, w2, n-1, m-1)\\n            \\n            else:\\n                return 1 + min(\\n                                solve(w1, w2, n-1, m-1),  # Replace\\n                                solve(w1, w2, n-1, m),    # Delete\\n                                solve(w1, w2, n, m-1)     # Insert\\n                                )\\n        \\n        return solve(w1, w2, len(w1), len(w2))\\n    \\n\\n# Time Limit Exceeded\\n# We need to use Memoization in this Solution to avoid repetative same calculation of sub-problems\\n```\\n\\n**Memoization**:\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        memo = {}\\n        \\n        def dfs(i, j):\\n            if i == 0 or j == 0: return j or i\\n                        \\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n            \\n            if word1[i-1] == word2[j-1]:\\n                ans = dfs(i-1, j-1)\\n            else: \\n                ans = 1 + min(dfs(i, j-1), dfs(i-1, j), dfs(i-1, j-1))\\n                \\n            memo[(i,j)] = ans\\n            return memo[(i,j)]\\n        \\n        return dfs(len(word1), len(word2))\\n\\t\\t\\n# Time: O(N^2)\\n# Space: O(N^2)\\n```\\n\\n\\n**Tabular DP**:\\n```\\nclass Solution:\\n    def minDistance(self, w1: str, w2: str) -> int:\\n        n = len(w1); m = len(w2)\\n        \\n        dp = [[0]*(m+1) for i in range(n+1)]\\n        \\n        for j in range(m+1): # Base Case 0th row where len(w1) = 0\\n            dp[0][j] = j\\n        \\n        for i in range(n+1): # Base Case 0th column where len(w2) = 0\\n            dp[i][0] = i\\n        \\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if w1[i-1] == w2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(\\n                                        dp[i-1][j-1],  # Replace \\n                                        dp[i-1][j],    # Delete\\n                                        dp[i][j-1]     # Insert\\n                                        )\\n        \\n        return dp[-1][-1]\\n\\t\\t\\n# Time: O(N^2)\\n# Space: O(N^2)\\n```\\n\\nAll Concepts of DP: **https://github.com/SamirPaul1/DSAlgo/tree/main/02_Dynamic-Programming**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, w1: str, w2: str) -> int:\\n        def solve(w1, w2, n, m): \\n            # Base Case if any one of w1 or w2 is empty \\n            if n == 0 or m == 0: return m or n\\n            \\n            elif w1[n-1] == w2[m-1]:\\n                return solve(w1, w2, n-1, m-1)\\n            \\n            else:\\n                return 1 + min(\\n                                solve(w1, w2, n-1, m-1),  # Replace\\n                                solve(w1, w2, n-1, m),    # Delete\\n                                solve(w1, w2, n, m-1)     # Insert\\n                                )\\n        \\n        return solve(w1, w2, len(w1), len(w2))\\n    \\n\\n# Time Limit Exceeded\\n# We need to use Memoization in this Solution to avoid repetative same calculation of sub-problems\\n```\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        memo = {}\\n        \\n        def dfs(i, j):\\n            if i == 0 or j == 0: return j or i\\n                        \\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n            \\n            if word1[i-1] == word2[j-1]:\\n                ans = dfs(i-1, j-1)\\n            else: \\n                ans = 1 + min(dfs(i, j-1), dfs(i-1, j), dfs(i-1, j-1))\\n                \\n            memo[(i,j)] = ans\\n            return memo[(i,j)]\\n        \\n        return dfs(len(word1), len(word2))\\n\\t\\t\\n# Time: O(N^2)\\n# Space: O(N^2)\\n```\n```\\nclass Solution:\\n    def minDistance(self, w1: str, w2: str) -> int:\\n        n = len(w1); m = len(w2)\\n        \\n        dp = [[0]*(m+1) for i in range(n+1)]\\n        \\n        for j in range(m+1): # Base Case 0th row where len(w1) = 0\\n            dp[0][j] = j\\n        \\n        for i in range(n+1): # Base Case 0th column where len(w2) = 0\\n            dp[i][0] = i\\n        \\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if w1[i-1] == w2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(\\n                                        dp[i-1][j-1],  # Replace \\n                                        dp[i-1][j],    # Delete\\n                                        dp[i][j-1]     # Insert\\n                                        )\\n        \\n        return dp[-1][-1]\\n\\t\\t\\n# Time: O(N^2)\\n# Space: O(N^2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695493,
                "title": "dp-solution-easy-fast",
                "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        #dp[i][j] will be the least distance from word1[:i] to word2[:j]\\n        dp = [[0 for _ in range(len(word2)+1)] for _ in range(len(word1)+1)]\\n        for i in range(len(word1)+1):\\n            dp[i][0] = i\\n            for j in range(1,len(word2)+1):\\n                if i == 0:\\n                    dp[0][j] = j\\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1\\n        return dp[-1][-1]  \\n                                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        #dp[i][j] will be the least distance from word1[:i] to word2[:j]\\n        dp = [[0 for _ in range(len(word2)+1)] for _ in range(len(word1)+1)]\\n        for i in range(len(word1)+1):\\n            dp[i][0] = i\\n            for j in range(1,len(word2)+1):\\n                if i == 0:\\n                    dp[0][j] = j\\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1\\n        return dp[-1][-1]  \\n                                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232992,
                "title": "3-best-approaches-recursion-memorization-tabulation",
                "content": "# Please upvote if you like these solutions\\n\\n# Approach\\n**Recursive Approach**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(3^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n class Solution {\\n     public int minDistance(String word1, String word2) {\\n         int n = word1.length();\\n         int m = word2.length();\\n\\n         return minDistanceRec(word1, word2, n, m);\\n     }\\n\\n     public int minDistanceRec(String word1,  String word2, int n, int m) {\\n         if(n == 0 || m == 0){\\n             return n == 0 ? m : n;\\n         }\\n\\n         if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n             return minDistanceRec(word1, word2, n - 1, m - 1);\\n         }\\n         else{\\n             int replace = minDistanceRec(word1, word2, n - 1, m - 1);\\n             int delete = minDistanceRec(word1, word2, n - 1, m);\\n             int insert = minDistanceRec(word1, word2, n, m - 1);\\n             return Math.min(replace, Math.min(delete, insert)) + 1;\\n         }\\n     }\\n }\\n\\n```\\n\\n\\n---\\n\\n\\n# Approach\\n**Memorization Approach**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n class Solution {\\n     public int minDistance(String word1, String word2) {\\n         int n = word1.length();\\n         int m = word2.length();\\n\\n         int [][] memo = new int [n + 1][m + 1];\\n         for(int [] d : memo)\\n             Arrays.fill(d, -1);\\n\\n         return minDistanceMemo(word1, word2, n, m, memo);\\n     }\\n\\n     public int minDistanceMemo(String word1,  String word2, int n, int m, int [][] memo) {\\n         if(n == 0 || m == 0){\\n             return memo[n][m] = n == 0 ? m : n;\\n         }\\n\\n         if(memo[n][m] != -1)\\n             return memo[n][m];\\n\\n         if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n             memo[n][m] = minDistanceMemo(word1, word2, n - 1, m - 1, memo);\\n         }\\n         else{\\n             int replace = minDistanceMemo(word1, word2, n - 1, m - 1, memo);\\n             int delete = minDistanceMemo(word1, word2, n - 1, m, memo);\\n             int insert = minDistanceMemo(word1, word2, n, m - 1, memo);\\n             memo[n][m] = Math.min(replace, Math.min(delete, insert)) + 1;\\n         }\\n         return memo[n][m];\\n     }\\n }\\n\\n```\\n\\n\\n---\\n\\n\\n# Approach\\n**Tabulation Approach**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n\\n        int [][] dp = new int [n + 1][m + 1];\\n        for(int [] d : dp)\\n            Arrays.fill(d, -1);\\n\\n        return minDistanceTab(word1, word2, n, m, dp);\\n    }\\n\\n    public int minDistanceTab(String word1,  String word2, int N, int M, int [][] dp) {\\n        for(int n = 0; n <= N; n++){\\n            for(int m = 0; m <= M; m++){\\n                if(n == 0 || m == 0){\\n                    dp[n][m] = n == 0 ? m : n;\\n                    continue;\\n                }\\n\\n                if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n                    dp[n][m] = dp[n - 1][m - 1];\\n                }\\n                else{\\n                    int replace = dp[n - 1][m - 1];;\\n                    int delete = dp[n - 1][m];;\\n                    int insert = dp[n][m - 1];;\\n                    dp[n][m] = Math.min(replace, Math.min(delete, insert)) + 1;\\n                }\\n            }\\n        }\\n        return dp[N][M];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n class Solution {\\n     public int minDistance(String word1, String word2) {\\n         int n = word1.length();\\n         int m = word2.length();\\n\\n         return minDistanceRec(word1, word2, n, m);\\n     }\\n\\n     public int minDistanceRec(String word1,  String word2, int n, int m) {\\n         if(n == 0 || m == 0){\\n             return n == 0 ? m : n;\\n         }\\n\\n         if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n             return minDistanceRec(word1, word2, n - 1, m - 1);\\n         }\\n         else{\\n             int replace = minDistanceRec(word1, word2, n - 1, m - 1);\\n             int delete = minDistanceRec(word1, word2, n - 1, m);\\n             int insert = minDistanceRec(word1, word2, n, m - 1);\\n             return Math.min(replace, Math.min(delete, insert)) + 1;\\n         }\\n     }\\n }\\n\\n```\n```\\n class Solution {\\n     public int minDistance(String word1, String word2) {\\n         int n = word1.length();\\n         int m = word2.length();\\n\\n         int [][] memo = new int [n + 1][m + 1];\\n         for(int [] d : memo)\\n             Arrays.fill(d, -1);\\n\\n         return minDistanceMemo(word1, word2, n, m, memo);\\n     }\\n\\n     public int minDistanceMemo(String word1,  String word2, int n, int m, int [][] memo) {\\n         if(n == 0 || m == 0){\\n             return memo[n][m] = n == 0 ? m : n;\\n         }\\n\\n         if(memo[n][m] != -1)\\n             return memo[n][m];\\n\\n         if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n             memo[n][m] = minDistanceMemo(word1, word2, n - 1, m - 1, memo);\\n         }\\n         else{\\n             int replace = minDistanceMemo(word1, word2, n - 1, m - 1, memo);\\n             int delete = minDistanceMemo(word1, word2, n - 1, m, memo);\\n             int insert = minDistanceMemo(word1, word2, n, m - 1, memo);\\n             memo[n][m] = Math.min(replace, Math.min(delete, insert)) + 1;\\n         }\\n         return memo[n][m];\\n     }\\n }\\n\\n```\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n\\n        int [][] dp = new int [n + 1][m + 1];\\n        for(int [] d : dp)\\n            Arrays.fill(d, -1);\\n\\n        return minDistanceTab(word1, word2, n, m, dp);\\n    }\\n\\n    public int minDistanceTab(String word1,  String word2, int N, int M, int [][] dp) {\\n        for(int n = 0; n <= N; n++){\\n            for(int m = 0; m <= M; m++){\\n                if(n == 0 || m == 0){\\n                    dp[n][m] = n == 0 ? m : n;\\n                    continue;\\n                }\\n\\n                if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n                    dp[n][m] = dp[n - 1][m - 1];\\n                }\\n                else{\\n                    int replace = dp[n - 1][m - 1];;\\n                    int delete = dp[n - 1][m];;\\n                    int insert = dp[n][m - 1];;\\n                    dp[n][m] = Math.min(replace, Math.min(delete, insert)) + 1;\\n                }\\n            }\\n        }\\n        return dp[N][M];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230538,
                "title": "python3-easy-solution",
                "content": "**Python3 Solution**\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        # base case - i steps away\\n        for i in range(1, m + 1):\\n            dp[i][0] = i\\n        for j in range(1, n + 1):\\n            dp[0][j] = j\\n        # each step has four possibilities\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                # same character, i and j move ahead together\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                # find min of insert, replace, remove a character\\n                else:\\n                    dp[i][j] = min(\\n                        dp[i - 1][j] + 1,\\n                        dp[i][j - 1] + 1,\\n                        dp[i - 1][j - 1] + 1\\n                    )\\n        \\n        return dp[m][n]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        # base case - i steps away\\n        for i in range(1, m + 1):\\n            dp[i][0] = i\\n        for j in range(1, n + 1):\\n            dp[0][j] = j\\n        # each step has four possibilities\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                # same character, i and j move ahead together\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                # find min of insert, replace, remove a character\\n                else:\\n                    dp[i][j] = min(\\n                        dp[i - 1][j] + 1,\\n                        dp[i][j - 1] + 1,\\n                        dp[i - 1][j - 1] + 1\\n                    )\\n        \\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736119,
                "title": "dp-4-approaches-recursion-memoization-tabulation-and-space-optimization",
                "content": "**Approach 1 : Recursion**\\n\\n```\\nint solve(int i, int j, string &str1, string &str2){     \\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(str1[i]==str2[j]){\\n            return solve(i-1,j-1,str1,str2);\\n        }\\n        else{\\n            int insert = 1 + solve(i,j-1,str1,str2);\\n            int deleted = 1 + solve(i-1,j,str1,str2);\\n            int replace = 1 + solve(i-1,j-1,str1,str2);\\n            return min(min(insert,deleted),replace);\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        return solve(n-1,m-1,word1,word2);\\n    }\\n```\\n\\nTime : exponential\\nSpace : O(m+n) for stack space     => m = word1.size() and n = word2.size()\\n\\n**Approach 2 : Memoization**\\n\\n```\\nint solve(int i, int j, string &str1, string &str2, vector<vector<int>>&dp){     \\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(str1[i]==str2[j]){\\n            return dp[i][j] = solve(i-1,j-1,str1,str2,dp);\\n        }\\n        else{\\n            int insert = 1 + solve(i,j-1,str1,str2,dp);\\n            int deleted = 1 + solve(i-1,j,str1,str2,dp);\\n            int replace = 1 + solve(i-1,j-1,str1,str2,dp);\\n            return dp[i][j] = min(min(insert,deleted),replace);\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(n-1,m-1,word1,word2,dp);\\n    }\\n```\\n\\nTime : O(m.n)   => m = word1.size() and n = word2.size()\\nSpace : O(m+n) stack space and O(m.n)  for dp space\\n\\n**Approach 3 : Tabulation**\\n\\n```\\n       int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n       \\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=1;j<m+1;j++){\\n            dp[0][j]=j;\\n        }\\n       \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int insert = 1 + dp[i][j-1];\\n                    int deleted = 1 + dp[i-1][j];\\n                    int replace = 1 + dp[i-1][j-1];\\n                    dp[i][j] = min(min(insert,deleted),replace);                    \\n                }        \\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\\n\\nTime : O(m.n)   => m = word1.size() and n = word2.size()\\nSpace : O(m.n)  for dp space\\n\\n**Approach 4 : Space optimized to O(m) **\\n\\n```\\n     int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<int>prev(m+1,0),curr(m+1,0);\\n        \\n        for(int i=0;i<m+1;i++){\\n            prev[i]=i;\\n        }\\n        for(int i=1;i<n+1;i++){\\n            curr[0] = i;\\n            for(int j=1;j<m+1;j++){\\n                if(word1[i-1]==word2[j-1])\\n                    curr[j] = prev[j-1];\\n                else{\\n                    int insert = 1 + curr[j-1];\\n                    int deleted = 1 + prev[j];\\n                    int replace = 1 + prev[j-1];\\n                    curr[j] = min(min(insert,deleted),replace);                    \\n                }        \\n            }\\n            prev = curr;\\n        }\\n        \\n        return prev[m];\\n    }\\n```\\n\\nTime : O(m.n)   => m = word1.size() and n = word2.size()\\nSpace : O(m)  for dp \\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(int i, int j, string &str1, string &str2){     \\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(str1[i]==str2[j]){\\n            return solve(i-1,j-1,str1,str2);\\n        }\\n        else{\\n            int insert = 1 + solve(i,j-1,str1,str2);\\n            int deleted = 1 + solve(i-1,j,str1,str2);\\n            int replace = 1 + solve(i-1,j-1,str1,str2);\\n            return min(min(insert,deleted),replace);\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        return solve(n-1,m-1,word1,word2);\\n    }\\n```\n```\\nint solve(int i, int j, string &str1, string &str2, vector<vector<int>>&dp){     \\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(str1[i]==str2[j]){\\n            return dp[i][j] = solve(i-1,j-1,str1,str2,dp);\\n        }\\n        else{\\n            int insert = 1 + solve(i,j-1,str1,str2,dp);\\n            int deleted = 1 + solve(i-1,j,str1,str2,dp);\\n            int replace = 1 + solve(i-1,j-1,str1,str2,dp);\\n            return dp[i][j] = min(min(insert,deleted),replace);\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(n-1,m-1,word1,word2,dp);\\n    }\\n```\n```\\n       int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n       \\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=1;j<m+1;j++){\\n            dp[0][j]=j;\\n        }\\n       \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int insert = 1 + dp[i][j-1];\\n                    int deleted = 1 + dp[i-1][j];\\n                    int replace = 1 + dp[i-1][j-1];\\n                    dp[i][j] = min(min(insert,deleted),replace);                    \\n                }        \\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\n```\\n     int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<int>prev(m+1,0),curr(m+1,0);\\n        \\n        for(int i=0;i<m+1;i++){\\n            prev[i]=i;\\n        }\\n        for(int i=1;i<n+1;i++){\\n            curr[0] = i;\\n            for(int j=1;j<m+1;j++){\\n                if(word1[i-1]==word2[j-1])\\n                    curr[j] = prev[j-1];\\n                else{\\n                    int insert = 1 + curr[j-1];\\n                    int deleted = 1 + prev[j];\\n                    int replace = 1 + prev[j-1];\\n                    curr[j] = min(min(insert,deleted),replace);                    \\n                }        \\n            }\\n            prev = curr;\\n        }\\n        \\n        return prev[m];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2605989,
                "title": "lcs-explained-python-c-javascript",
                "content": "* We can use **longest common subsequence** method with little bit modification.\\n* In **LCS** we only check that the corresponding letter is equal or not and according to it we fill out the matrix cell.\\n* Here in this problem we have to perform **three types** of operations so every cell of the dp matrix will be filled out with the operation that has **minimum step**.\\n* `if  word1[i-1] == word2[j-1]:`\\n\\t* ` dp[i][j] = dp[i][j] = dp[i-1][j-1]` means both letters are same so we don\\'t need to perform any operation so number of steps will remain same as previous step.\\n* `if word1[i-1] != word2[j-1]:`\\n\\t* case 1: we will replace the current letter of word1 with current letter of word2 --> `dp[i-1][j-1] + 1` steps.\\n\\t* case 2: we have reached at the end of word2 but in word1 there is an extra letter that we have to delete from word1 -->` dp[i-1][j] + 1` steps.\\n\\t* case 3: we have reached at the end of the word1 but there is an extra letter in word2 that we have to insert in word1 --> `dp[i][j-1] + 1` steps.\\n\\t* `dp[i][j] = min(case1, case2, case3)`\\n--------------------\\n<iframe src=\"https://leetcode.com/playground/XwdC88g8/shared\" frameBorder=\"0\" width=\"800\" height=\"520\"></iframe>\\n\\n-----------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "* We can use **longest common subsequence** method with little bit modification.\\n* In **LCS** we only check that the corresponding letter is equal or not and according to it we fill out the matrix cell.\\n* Here in this problem we have to perform **three types** of operations so every cell of the dp matrix will be filled out with the operation that has **minimum step**.\\n* `if  word1[i-1] == word2[j-1]:`\\n\\t* ` dp[i][j] = dp[i][j] = dp[i-1][j-1]` means both letters are same so we don\\'t need to perform any operation so number of steps will remain same as previous step.\\n* `if word1[i-1] != word2[j-1]:`\\n\\t* case 1: we will replace the current letter of word1 with current letter of word2 --> `dp[i-1][j-1] + 1` steps.\\n\\t* case 2: we have reached at the end of word2 but in word1 there is an extra letter that we have to delete from word1 -->` dp[i-1][j] + 1` steps.\\n\\t* case 3: we have reached at the end of the word1 but there is an extra letter in word2 that we have to insert in word1 --> `dp[i][j-1] + 1` steps.\\n\\t* `dp[i][j] = min(case1, case2, case3)`\\n--------------------\\n<iframe src=\"https://leetcode.com/playground/XwdC88g8/shared\" frameBorder=\"0\" width=\"800\" height=\"520\"></iframe>\\n\\n-----------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "codeTag": "Unknown"
            },
            {
                "id": 1821599,
                "title": "easy-solution-dp-based-c-95-fast-solution",
                "content": "```\\n  int minDistance(string word1, string word2) {\\n        \\n        int m=word1.length(),n=word2.length();\\n        \\n        int dp[m+1][n+1];\\n        \\n        for(int i=0;i<=m;i++)\\n            dp[i][0]=i;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[0][i]=i;\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else{\\n                    dp[i][j] = 1+ min(dp[i][j - 1], min(dp[i - 1][j], dp[i - 1][j - 1]));\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n  int minDistance(string word1, string word2) {\\n        \\n        int m=word1.length(),n=word2.length();\\n        \\n        int dp[m+1][n+1];\\n        \\n        for(int i=0;i<=m;i++)\\n            dp[i][0]=i;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[0][i]=i;\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else{\\n                    dp[i][j] = 1+ min(dp[i][j - 1], min(dp[i - 1][j], dp[i - 1][j - 1]));\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262290,
                "title": "maybe-better-than-o-mn-heap-solution-python-beats-99-o-m-n-log-m-n-not-sure",
                "content": "![image](https://assets.leetcode.com/users/images/1e61e11a-f3e8-4d0a-92c3-f2565c7360b0_1623299142.487367.png)\\n\\n\\nKeep a minheap and chop off 1 character at a time. To avoid using too much space with substring splicing, we can move pointers `i` and `j` instead.\\n\\nKeep a minheap with items in there form `(distance, i, j)`\\nWhere `word1[:i]` and `word[:j]` have an edit distance of `distance`\\n\\n1. Pop from the heap to give current lowest edit distance and string index pair\\n2. If word1 and word2 from pointers  `i` and `j`  are **both exactly exact same**:\\n\\t=>  return the `distance` , don\\'t need to increment the distance anymore\\n\\t\\n3. Do the following if `i` and `j` are unvisited (if we are visiting the same `i` and `j` again, that means the distance is not lower than previously seen, so we should ignore it)\\n\\t4.  if the characters at `i` and `j` match, **no change needed** , increment both word pointers but keep distance the same\\n\\t5.  Otherwise, increment distance and:\\n\\t\\t6. Add **delete from word1** case (`i+1`)\\n\\t\\t7. Add **delete from word2** case (`j+1`)\\n\\t\\t8. Add **replace current character** case (`i+1`) and (`j+1`)\\n\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        heap = [(0, 0, 0)]\\n        seen = set()\\n        \\n        while heap:\\n            distance, i, j = heappop(heap)\\n            if word1[i:] == word2[j:]:\\n                return distance\\n\\t\\t\\n            if ((i, j) not in seen):\\n                seen.add((i, j))\\n                if (i < m and j < n and word1[i] == word2[j]):\\n                    heappush(heap, (distance, i+1, j+1))\\n                else:\\n                    for di, dj in (1,0), (0,1), (1,1):\\n                        next_i, next_j = i+di, j+dj\\n                        if (next_i <= m and next_j <= n):\\n                            heappush(heap, (distance+1, next_i, next_j))\\n```\\n\\n\\n**Time complexity**\\n\\nAssuming length of `word1` is `m` and length of `word2` is `n`\\nFor each of the `m` characters and `n` that modify the heap at most 3 times. Thus the heap size can be at most `(m+n)*3` = `m+n`\\n\\nThus all heap operations are  `O(log(m+n))`\\nWhich is done for all `m+n` items thus `O((m+n)log(m+n))`\\nIf this is true, than this is better than the typical `O(mn)` DP solution.\\nThough it might just be `O(mn*log(mn))` with a good average case...\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        heap = [(0, 0, 0)]\\n        seen = set()\\n        \\n        while heap:\\n            distance, i, j = heappop(heap)\\n            if word1[i:] == word2[j:]:\\n                return distance\\n\\t\\t\\n            if ((i, j) not in seen):\\n                seen.add((i, j))\\n                if (i < m and j < n and word1[i] == word2[j]):\\n                    heappush(heap, (distance, i+1, j+1))\\n                else:\\n                    for di, dj in (1,0), (0,1), (1,1):\\n                        next_i, next_j = i+di, j+dj\\n                        if (next_i <= m and next_j <= n):\\n                            heappush(heap, (distance+1, next_i, next_j))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854887,
                "title": "diagram-explanation-recursion-memoization-dp-o-3-n-to-o-n-m",
                "content": "# Recursive Solution (Naive Approach)\\n## How ?\\n\\n1. Pure Recursive Approach (`PureRecursive` function):\\nThe `PureRecursive` function calculates the minimum edit distance between two strings `word1` and `word2` using a purely recursive approach. It tries to find the minimum number of operations (insert, delete, or replace) required to convert `word1` into `word2`. The function starts from the last characters of both strings and recursively checks if the characters are the same or different. If they are the same, it moves to the previous characters and continues the comparison. If they are different, it explores all three possible operations (insert, delete, replace) and calculates the minimum distance for each case. The function returns the minimum distance obtained.\\n\\nTime complexity: Exponential. Since for each character in `word1`, the function has three recursive calls (insert, delete, replace), the time complexity grows exponentially with the length of the strings.\\n\\nSpace complexity: O(m+n), where \\'m\\' is the length of `word1` and \\'n\\' is the length of `word2`. The space complexity is determined by the depth of the recursive calls and the maximum size of the function call stack.\\n\\n```\\nint PureRecursive(string &word1, string &word2,int m, int n){\\n        if(m == 0) return n;\\n        if(n == 0) return m;\\n        if(word1[m-1] == word2[n-1]){\\n            return PureRecursive(word1,word2,m-1,n-1);\\n        }\\n        else{\\n            return 1 + min(PureRecursive(word1,word2,m-1,n-1),min(PureRecursive(word1,word2,m-1,n),PureRecursive(word1,word2,m,n-1)));\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>> dp(word1.size() + 1, std::vector<int>(word2.size() + 1, -1));\\n        return bottomUpDp(word1,word2,word1.size(),word2.size(),dp);\\n    }\\n};\\n\\n```\\n\\n# Memoization Approach\\n\\n## How?\\nThe given function `recur` is a recursive solution to the Minimum Edit Distance problem with memoization  (also known as memoization). It calculates the minimum edit distance between two strings `word1` and `word2`.\\n\\nThe function takes the following parameters:\\n- `word1`: A reference to the first string.\\n- `word2`: A reference to the second string.\\n- `m`: The current index in `word1` (0-based).\\n- `n`: The current index in `word2` (0-based).\\n- `dp`: A 2D vector representing the memoization table to store intermediate results.\\n\\nThe idea behind the memoization approach is to store the results of subproblems in the `dp` table to avoid redundant computations. This way, if we encounter the same subproblem during the recursion, we can directly use the precomputed value from the `dp` table instead of recalculating it.\\n\\nHere\\'s how the function works:\\n1. Base cases:\\n   - If `m` (index in `word1`) becomes 0, it means we have processed all characters in `word1`, so we return the remaining length of `word2` (`n`). This is because, at this point, we would need to insert `n` characters from `word2` into `word1` to match them.\\n   - If `n` (index in `word2`) becomes 0, it means we have processed all characters in `word2`, so we return the remaining length of `word1` (`m`). This is because, at this point, we would need to delete `m` characters from `word1` to match them with the empty string.\\n\\n2. Check if the result for the current subproblem exists in the `dp` table (`dp[m - 1][n - 1]`). If it does, we directly return the precomputed value, avoiding redundant computation.\\n\\n3. If the characters at the current indices (`word1[m - 1]` and `word2[n - 1]`) are equal, it means no edit is required, and we can move on to the previous characters (index `m - 1` and `n - 1`) to find the solution for the subproblem. We recursively call `recur(word1, word2, m - 1, n - 1, dp)` to compute the minimum edit distance for this case.\\n\\n4. If the characters at the current indices are different, it means we have three options: insert, delete, or replace a character to make the strings similar. We recursively call `recur` for each option and compute the minimum edit distance among them. The result is stored in the `dp` table (`dp[m - 1][n - 1]`) for future reference.\\n\\n5. Finally, we return the computed value for the current subproblem.\\n\\nOverall, the memoization approach reduces the time complexity by avoiding redundant calculations of the same subproblems and improves the performance compared to the pure recursive solution.\\n\\nPlease note that before calling the `recur` function, you need to initialize the `dp` table with `-1` to indicate that the results for subproblems are not yet computed. The `minDistance` function takes care of this initialization and calls the `recur` function with the appropriate arguments.\\n\\nMemoizationn Table:\\n\\n\\n|     | e | x | e | c | u | t | i | o | n |\\n|-----|---|---|---|---|---|---|---|---|---|\\n| i   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| n   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| t   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| e   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| n   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| t   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| i   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| o   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| n   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n\\nIn this table, the headers for both rows and columns represent the characters from \"intention\" and \"execution.\" The cells are filled with -1, indicating that the minimum edit distance has not been computed for any of the substrings yet.\\n\\nConverts to :\\n<body>\\n    <table>\\n        <tr>\\n            <td></td>\\n            <td>e</td>\\n            <td>x</td>\\n            <td>e</td>\\n            <td>c</td>\\n            <td>u</td>\\n            <td>t</td>\\n            <td>i</td>\\n            <td>o</td>\\n            <td>n</td>\\n            <td>-</td>\\n        </tr>\\n        <tr>\\n            <td>i</td>\\n            <td>1</td>\\n            <td>2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>n</td>\\n            <td>2</td>\\n            <td>2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>t</td>\\n            <td>3</td>\\n            <td>3</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>e</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>n</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td style=\"background-color: grey\">4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>t</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>i</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>o</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>n</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: skyblue; color : black;\">5<sup>(m-1,n-1)</sup></td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>-</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n    </table>\\n</body>\\n</html>\\n\\nMemoization Solution\\n\\n```\\nint Memoization(string &word1, string &word2,int m, int n,vector<vector<int>>&mem){\\n            if (m == 0)\\n                return n; //If the word1 length becomes zero, obvious that we are left with the cost of n\\n            if (n == 0)\\n                return m; //If the word2 length becomes zero, obvious that we are left with the cost of m\\n\\n            if (mem[m - 1][n - 1] != -1)\\n                return mem[m - 1][n - 1];\\n\\n            if (word1[m - 1] == word2[n - 1])\\n            {\\n                mem[m - 1][n - 1] = Memoization(word1, word2, m - 1, n - 1, mem);\\n                return mem[m - 1][n - 1];\\n            }\\n            else\\n            {\\n                mem[m - 1][n - 1] = 1 + min(Memoization(word1, word2, m - 1, n - 1, mem), min(Memoization(word1, word2, m - 1, n, mem), Memoization(word1, word2, m, n - 1, mem)));\\n                return mem[m - 1][n - 1];\\n            }\\n        }\\n\\n```\\n\\n# DP Solution :\\n## How ?\\n1. Bottom-Up Dynamic Programming Approach (`minDistance` function):\\nThe `minDistance` function calculates the minimum edit distance between two strings `word1` and `word2` using the Bottom-Up Dynamic Programming approach. It creates a DP table (2D array) of size `(m+1) x (n+1)` to store the minimum edit distance values for all subproblems.\\n\\nThe idea behind the Bottom-Up DP approach is to fill the DP table from smaller subproblems to the larger ones iteratively, avoiding redundant computations. The DP table `dp[i][j]` represents the minimum edit distance between the first `i` characters of `word1` and the first `j` characters of `word2`.\\n\\nThe DP table is filled in a bottom-up manner as follows:\\n- For `i = 0` or `j = 0`, `dp[i][j]` is initialized to `i` or `j`, respectively. This is because the minimum edit distance between an empty string and a string of length \\'x\\' is \\'x\\' (number of insertions or deletions needed).\\n- For `i > 0` and `j > 0`, if `word1[i-1]` is equal to `word2[j-1]`, then there is no edit needed, and `dp[i][j]` is set to `dp[i-1][j-1]`.\\n- If `word1[i-1]` is not equal to `word2[j-1]`, then `dp[i][j]` is calculated as the minimum of three cases: \\n    1. Replace: `1 + dp[i-1][j-1]`\\n    2. Insert: `1 + dp[i][j-1]`\\n    3. Delete: `1 + dp[i-1][j]`\\n\\nThe final answer is stored in `dp[m][n]`, which represents the minimum edit distance between the entire `word1` and `word2`.\\n\\nTime complexity: O(m * n), where \\'m\\' is the length of `word1` and \\'n\\' is the length of `word2`. The DP table is filled iteratively in a bottom-up manner, so each cell takes constant time to compute.\\n\\nSpace complexity: O(m * n), where \\'m\\' is the length of `word1` and \\'n\\' is the length of `word2`. The DP table of size `(m+1) x (n+1)` is used to store the intermediate results.\\nTable will look like this after the Complete assignment\\n<body>\\n    <table>\\n        <tr>\\n            <th> </th>\\n            <th>0</th>\\n            <th>1</th>\\n            <th>2</th>\\n            <th>3</th>\\n            <th>4</th>\\n            <th>5</th>\\n            <th>6</th>\\n            <th>7</th>\\n            <th>8</th>\\n            <th>9</th>\\n        </tr>\\n        <tr>\\n            <th>0</th>\\n            <td>0</td>\\n            <td>1</td>\\n            <td>2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>8</td>\\n            <td>9</td>\\n        </tr>\\n        <tr>\\n            <th>1</th>\\n            <td>1</td>\\n            <td style=\"background-color: gray; color: black;\">1</td>\\n            <td>2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>8</td>\\n        </tr>\\n        <tr>\\n            <th>2</th>\\n            <td>2</td>\\n            <td>2</td>\\n            <td style=\"background-color: gray; color: black;\">2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n        </tr>\\n        <tr>\\n            <th>3</th>\\n            <td>3</td>\\n            <td>3</td>\\n            <td>3</td>\\n            <td style=\"background-color: gray; color: black;\">3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>8</td>\\n        </tr>\\n        <tr>\\n            <th>4</th>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td style=\"background-color: gray; color: black;\">4</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>8</td>\\n        </tr>\\n        <tr>\\n            <th>5</th>\\n            <td>4</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td style=\"background-color: gray; color: black;\">5</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n        </tr>\\n        <tr>\\n            <th>6</th>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td style=\"background-color: gray; color: black;\">6</td>\\n            <td>7</td>\\n            <td>8</td>\\n            <td>8</td>\\n        </tr>\\n        <tr>\\n            <th>7</th>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td style=\"background-color: gray; color: black;\">5</td>\\n            <td>6</td>\\n            <td>7</td>\\n        </tr>\\n        <tr>\\n            <th>8</th>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>6</td>\\n            <td style=\"background-color: gray; color: black;\">5</td>\\n            <td>6</td>\\n        </tr>\\n        <tr>\\n            <th>9</th>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>7</td>\\n            <td>6</td>\\n            <td style=\"background-color: skyblue; color : black;\">5<sup>(m,n)</sup></td>\\n        </tr>\\n    </table>\\n</body>\\n</html>\\n\\n## Code :\\n\\n```\\nclass Solution {\\npublic:\\n    int bottomUpDp(string &word1, string &word2, int m, int n, vector<vector<int>>& dp){\\n        // Initialize base cases\\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;   //rows\\n        }\\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;   //columns\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]));\\n                // Carefully observe the recursive code is converted to iterative approach which tries to find the solution in dp table instead of recursive calls\\n                }\\n            }\\n\\n        }\\n\\n        return dp[m][n];\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint PureRecursive(string &word1, string &word2,int m, int n){\\n        if(m == 0) return n;\\n        if(n == 0) return m;\\n        if(word1[m-1] == word2[n-1]){\\n            return PureRecursive(word1,word2,m-1,n-1);\\n        }\\n        else{\\n            return 1 + min(PureRecursive(word1,word2,m-1,n-1),min(PureRecursive(word1,word2,m-1,n),PureRecursive(word1,word2,m,n-1)));\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>> dp(word1.size() + 1, std::vector<int>(word2.size() + 1, -1));\\n        return bottomUpDp(word1,word2,word1.size(),word2.size(),dp);\\n    }\\n};\\n\\n```\n```\\nint Memoization(string &word1, string &word2,int m, int n,vector<vector<int>>&mem){\\n            if (m == 0)\\n                return n; //If the word1 length becomes zero, obvious that we are left with the cost of n\\n            if (n == 0)\\n                return m; //If the word2 length becomes zero, obvious that we are left with the cost of m\\n\\n            if (mem[m - 1][n - 1] != -1)\\n                return mem[m - 1][n - 1];\\n\\n            if (word1[m - 1] == word2[n - 1])\\n            {\\n                mem[m - 1][n - 1] = Memoization(word1, word2, m - 1, n - 1, mem);\\n                return mem[m - 1][n - 1];\\n            }\\n            else\\n            {\\n                mem[m - 1][n - 1] = 1 + min(Memoization(word1, word2, m - 1, n - 1, mem), min(Memoization(word1, word2, m - 1, n, mem), Memoization(word1, word2, m, n - 1, mem)));\\n                return mem[m - 1][n - 1];\\n            }\\n        }\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int bottomUpDp(string &word1, string &word2, int m, int n, vector<vector<int>>& dp){\\n        // Initialize base cases\\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;   //rows\\n        }\\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;   //columns\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]));\\n                // Carefully observe the recursive code is converted to iterative approach which tries to find the solution in dp table instead of recursive calls\\n                }\\n            }\\n\\n        }\\n\\n        return dp[m][n];\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027225,
                "title": "c-dp-solution-recursive-memorization-tabulation-space-optimized-to-single-1d-array",
                "content": "### Recursive\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string &s1, string &s2){\\n        //Base Case\\n        if(i<0) return j + 1;\\n        if(j<0) return i + 1;\\n        if(s1[i]==s2[j]) return solve(i-1,j-1,s1,s2);\\n        \\n        //Insert the matching character so reduce the j no effect on i due to insertion\\n        int ins = solve(i,j-1,s1,s2); \\n        \\n        // Delete the character so reduce the i but no effect on j\\n        int del = solve(i-1,j,s1,s2); \\n        \\n        // Replace with matching character so reduce i and j both\\n        int rep = solve(i-1,j-1,s1,s2);\\n        \\n        return 1 + min({ins, del, rep});\\n    }\\n    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        return solve(m,n,s1,s2);\\n    }\\n};\\n```\\n\\n### Memorization\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        //Base Case\\n        if(i<0) return j + 1;\\n        if(j<0) return i + 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i]==s2[j]) return dp[i][j] = solve(i-1,j-1,s1,s2, dp);\\n        \\n        //Insert the matching character so reduce the j no effect on i due to insertion\\n        int ins = solve(i,j-1,s1,s2, dp); \\n        \\n        // Delete the character so reduce the i but no effect on j\\n        int del = solve(i-1,j,s1,s2, dp); \\n        \\n        // Replace with matching character so reduce i and j both\\n        int rep = solve(i-1,j-1,s1,s2, dp);\\n        \\n        return dp[i][j] = 1 + min({ins, del, rep});\\n    }\\n    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        return solve(m-1,n-1,s1,s2,dp);\\n    }\\n};\\n```\\n\\n### Tabulation\\n```\\n// Used 1-Based Indexing\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        //Base Case\\n        for(int j=0;j<=n;j++) dp[0][j] = j;\\n        for(int i=0;i<=m;i++) dp[i][0] = i;\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s1[i-1]==s2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int ins = dp[i][j-1];\\n                    int del = dp[i-1][j];\\n                    int rep = dp[i-1][j-1];\\n                    dp[i][j] = 1 + min({ins, del, rep});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n### Space-Optimized\\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        vector<int> prev(n+1), cur(n+1);\\n        \\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0) cur[j] = j;\\n                else if(j==0) cur[j] = i;\\n                else if(s1[i-1]==s2[j-1]) cur[j] = prev[j-1];\\n                else{\\n                    int ins = cur[j-1];\\n                    int del = prev[j];\\n                    int rep = prev[j-1];\\n                    cur[j] = 1 + min({ins, del, rep});\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[n];\\n    }\\n};\\n```\\n\\n### Further Optimized\\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        vector<int> prev(n+1);\\n        int topLeft, top, left;\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0) left = j;\\n                else if(j==0) left = i;\\n                else{\\n                    top = prev[j];\\n                    if(s1[i-1]==s2[j-1]) left = topLeft;\\n                    else left = 1 + min({topLeft, top, left});   \\n                }\\n                topLeft = prev[j];\\n                prev[j] = left;\\n            }\\n        }\\n        return prev[n];\\n    }\\n};\\n```\\n#### Please Upvote if you like the solution and comment your queries",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string &s1, string &s2){\\n        //Base Case\\n        if(i<0) return j + 1;\\n        if(j<0) return i + 1;\\n        if(s1[i]==s2[j]) return solve(i-1,j-1,s1,s2);\\n        \\n        //Insert the matching character so reduce the j no effect on i due to insertion\\n        int ins = solve(i,j-1,s1,s2); \\n        \\n        // Delete the character so reduce the i but no effect on j\\n        int del = solve(i-1,j,s1,s2); \\n        \\n        // Replace with matching character so reduce i and j both\\n        int rep = solve(i-1,j-1,s1,s2);\\n        \\n        return 1 + min({ins, del, rep});\\n    }\\n    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        return solve(m,n,s1,s2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        //Base Case\\n        if(i<0) return j + 1;\\n        if(j<0) return i + 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i]==s2[j]) return dp[i][j] = solve(i-1,j-1,s1,s2, dp);\\n        \\n        //Insert the matching character so reduce the j no effect on i due to insertion\\n        int ins = solve(i,j-1,s1,s2, dp); \\n        \\n        // Delete the character so reduce the i but no effect on j\\n        int del = solve(i-1,j,s1,s2, dp); \\n        \\n        // Replace with matching character so reduce i and j both\\n        int rep = solve(i-1,j-1,s1,s2, dp);\\n        \\n        return dp[i][j] = 1 + min({ins, del, rep});\\n    }\\n    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        return solve(m-1,n-1,s1,s2,dp);\\n    }\\n};\\n```\n```\\n// Used 1-Based Indexing\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        //Base Case\\n        for(int j=0;j<=n;j++) dp[0][j] = j;\\n        for(int i=0;i<=m;i++) dp[i][0] = i;\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s1[i-1]==s2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int ins = dp[i][j-1];\\n                    int del = dp[i-1][j];\\n                    int rep = dp[i-1][j-1];\\n                    dp[i][j] = 1 + min({ins, del, rep});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        vector<int> prev(n+1), cur(n+1);\\n        \\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0) cur[j] = j;\\n                else if(j==0) cur[j] = i;\\n                else if(s1[i-1]==s2[j-1]) cur[j] = prev[j-1];\\n                else{\\n                    int ins = cur[j-1];\\n                    int del = prev[j];\\n                    int rep = prev[j-1];\\n                    cur[j] = 1 + min({ins, del, rep});\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        vector<int> prev(n+1);\\n        int topLeft, top, left;\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0) left = j;\\n                else if(j==0) left = i;\\n                else{\\n                    top = prev[j];\\n                    if(s1[i-1]==s2[j-1]) left = topLeft;\\n                    else left = 1 + min({topLeft, top, left});   \\n                }\\n                topLeft = prev[j];\\n                prev[j] = left;\\n            }\\n        }\\n        return prev[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817536,
                "title": "c-recursive-memoization-and-dp",
                "content": "**Recursive:**\\n```\\nint editDistance(string s, string t)\\n{\\n    if (s.size() == 0 || t.size() == 0)\\n        return max(s.size(), t.size());\\n    if (s[0] == t[0])\\n        return editDistance(s.substr(1), t.substr(1));\\n    else\\n    {\\n        // insert\\n        int a = 1 + editDistance(s.substr(1), t);\\n        // delete\\n        int b = 1 + editDistance(s, t.substr(1));\\n        // replace\\n        int c = 1 + editDistance(s.substr(1), t.substr(1));\\n        return min(a, min(b, c));\\n    }\\n}\\n\\nint minDistance(string s, string t) {\\n\\treturn editDistance(s,t)\\n}\\n```\\n\\n**Memoization:**\\n```\\nint editDistance2(string s, string t, vector<vector<int>> ans)\\n{\\n    int m = s.size();\\n    int n = t.size();\\n    if (s.size() == 0 || t.size() == 0)\\n        return max(s.size(), t.size());\\n    if (ans[m][n] != -1)\\n        return ans[m][n];\\n    if (s[0] == t[0])\\n    {\\n        ans[m][n] = editDistance2(s.substr(1), t.substr(1), ans);\\n        return ans[m][n];\\n    }\\n    else\\n    {\\n        // insert\\n        int a = 1 + editDistance2(s.substr(1), t, ans);\\n        // delete\\n        int b = 1 + editDistance2(s, t.substr(1), ans);\\n        // replace\\n        int c = 1 + editDistance2(s.substr(1), t.substr(1), ans);\\n        ans[m][n] = min(a, min(b, c));\\n        return ans[m][n];\\n    }\\n}\\nint minDistance(string s, string t) {\\n    vector<vector<int>> ans(s.size() + 1, vector<int>(t.size() + 1, -1));\\n\\treturn editDistance2(s,t)\\n}\\n```\\n\\n**DP:**\\n```\\nint minDistance(string s, string t) {\\n        int m = s.size();\\n    int n = t.size();\\n\\n    int **ans = new int *[m + 1];\\n    for (int i = 0; i <= m; i++)\\n    {\\n        ans[i] = new int[n + 1];\\n    }\\n\\n    // Fill the 0th row with 0\\n    for (int j = 0; j <= n; j++)\\n    {\\n        ans[0][j] = j;\\n    }\\n    // Fill the 0th row with 0\\n    for (int i = 0; i <= m; i++)\\n    {\\n        ans[i][0] = i;\\n    }\\n    // Fill the remaining row with shortest Distances\\n    for (int i = 1; i <= m; i++)\\n    {\\n        for (int j = 1; j <= n; j++)\\n        {\\n            if (s[m - i] == t[n - j])\\n                ans[i][j] = ans[i - 1][j - 1];\\n            else\\n            {\\n                int a = 1 + ans[i - 1][j];\\n                int b = 1 + ans[i][j - 1];\\n                int c = 1 + ans[i - 1][j - 1];\\n                ans[i][j] = min(a, min(b, c));\\n            }\\n        }\\n    }\\n    return ans[m][n];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint editDistance(string s, string t)\\n{\\n    if (s.size() == 0 || t.size() == 0)\\n        return max(s.size(), t.size());\\n    if (s[0] == t[0])\\n        return editDistance(s.substr(1), t.substr(1));\\n    else\\n    {\\n        // insert\\n        int a = 1 + editDistance(s.substr(1), t);\\n        // delete\\n        int b = 1 + editDistance(s, t.substr(1));\\n        // replace\\n        int c = 1 + editDistance(s.substr(1), t.substr(1));\\n        return min(a, min(b, c));\\n    }\\n}\\n\\nint minDistance(string s, string t) {\\n\\treturn editDistance(s,t)\\n}\\n```\n```\\nint editDistance2(string s, string t, vector<vector<int>> ans)\\n{\\n    int m = s.size();\\n    int n = t.size();\\n    if (s.size() == 0 || t.size() == 0)\\n        return max(s.size(), t.size());\\n    if (ans[m][n] != -1)\\n        return ans[m][n];\\n    if (s[0] == t[0])\\n    {\\n        ans[m][n] = editDistance2(s.substr(1), t.substr(1), ans);\\n        return ans[m][n];\\n    }\\n    else\\n    {\\n        // insert\\n        int a = 1 + editDistance2(s.substr(1), t, ans);\\n        // delete\\n        int b = 1 + editDistance2(s, t.substr(1), ans);\\n        // replace\\n        int c = 1 + editDistance2(s.substr(1), t.substr(1), ans);\\n        ans[m][n] = min(a, min(b, c));\\n        return ans[m][n];\\n    }\\n}\\nint minDistance(string s, string t) {\\n    vector<vector<int>> ans(s.size() + 1, vector<int>(t.size() + 1, -1));\\n\\treturn editDistance2(s,t)\\n}\\n```\n```\\nint minDistance(string s, string t) {\\n        int m = s.size();\\n    int n = t.size();\\n\\n    int **ans = new int *[m + 1];\\n    for (int i = 0; i <= m; i++)\\n    {\\n        ans[i] = new int[n + 1];\\n    }\\n\\n    // Fill the 0th row with 0\\n    for (int j = 0; j <= n; j++)\\n    {\\n        ans[0][j] = j;\\n    }\\n    // Fill the 0th row with 0\\n    for (int i = 0; i <= m; i++)\\n    {\\n        ans[i][0] = i;\\n    }\\n    // Fill the remaining row with shortest Distances\\n    for (int i = 1; i <= m; i++)\\n    {\\n        for (int j = 1; j <= n; j++)\\n        {\\n            if (s[m - i] == t[n - j])\\n                ans[i][j] = ans[i - 1][j - 1];\\n            else\\n            {\\n                int a = 1 + ans[i - 1][j];\\n                int b = 1 + ans[i][j - 1];\\n                int c = 1 + ans[i - 1][j - 1];\\n                ans[i][j] = min(a, min(b, c));\\n            }\\n        }\\n    }\\n    return ans[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662522,
                "title": "java-dp-easy-solution-with-explanation-well-commented",
                "content": "```\\nclass Solution {\\n    public int minDistance(String str1, String str2) {\\n        int m = str1.length();\\n        int n = str2.length();\\n        int dp[][] = new int[m + 1][n + 1]; \\n        // Fill d[][] in bottom up manner \\n        for (int i = 0; i <= m; i++) { \\n            for (int j = 0; j <= n; j++) { \\n                // If first string is empty, only option is to \\n                // insert all characters of second string \\n                \\n                if (i == 0) dp[i][j] = j; // Min. operations = j \\n                \\n                // If second string is empty, only option is to \\n                // remove all characters of second string \\n                \\n                else if (j == 0) \\n                    dp[i][j] = i; // Min. operations = i \\n                \\n                // If last characters are same, ignore last char \\n                // and recur for remaining string \\n                \\n                else if (str1.charAt(i - 1) == str2.charAt(j - 1)) \\n                    dp[i][j] = dp[i - 1][j - 1]; \\n  \\n                // If the last character is different, consider all \\n                // possibilities and find the minimum \\n                else\\n                    dp[i][j] = 1 + Math.min(Math.min(dp[i][j - 1], // Insert \\n                                       dp[i - 1][j]), // Remove \\n                                       dp[i - 1][j - 1]); // Replace \\n            } \\n        } \\n  \\n        return dp[m][n]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String str1, String str2) {\\n        int m = str1.length();\\n        int n = str2.length();\\n        int dp[][] = new int[m + 1][n + 1]; \\n        // Fill d[][] in bottom up manner \\n        for (int i = 0; i <= m; i++) { \\n            for (int j = 0; j <= n; j++) { \\n                // If first string is empty, only option is to \\n                // insert all characters of second string \\n                \\n                if (i == 0) dp[i][j] = j; // Min. operations = j \\n                \\n                // If second string is empty, only option is to \\n                // remove all characters of second string \\n                \\n                else if (j == 0) \\n                    dp[i][j] = i; // Min. operations = i \\n                \\n                // If last characters are same, ignore last char \\n                // and recur for remaining string \\n                \\n                else if (str1.charAt(i - 1) == str2.charAt(j - 1)) \\n                    dp[i][j] = dp[i - 1][j - 1]; \\n  \\n                // If the last character is different, consider all \\n                // possibilities and find the minimum \\n                else\\n                    dp[i][j] = 1 + Math.min(Math.min(dp[i][j - 1], // Insert \\n                                       dp[i - 1][j]), // Remove \\n                                       dp[i - 1][j - 1]); // Replace \\n            } \\n        } \\n  \\n        return dp[m][n]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662340,
                "title": "c-dp",
                "content": "**Case 1 :**\\nIf first string is empty, only option is to insert all characters of second string\\n**Case 2 :**\\nIf second string is empty, only option is to remove all characters of second string\\n**Options :**\\n* dp [i-1][j - 1] -> If we replace the character.\\n* dp [i][j - 1] -> If we delete the character.\\n* dp [i - 1][j] -> If we insert the character.\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n\\t\\t\\n        for(int i = 1; i <= n; i++){ \\n            dp[i][0] = 1 + dp[i - 1][0];\\n        }\\n        for(int i = 1; i <= m; i++){\\n            dp[0][i] = 1 + dp[0][i - 1];\\n        }\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n              \\n                if(word2[i - 1] == word1[j - 1]){\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n                else{\\n                    dp[i][j] = 1 + min({dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]});\\n                }\\n               \\n            } \\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n\\t\\t\\n        for(int i = 1; i <= n; i++){ \\n            dp[i][0] = 1 + dp[i - 1][0];\\n        }\\n        for(int i = 1; i <= m; i++){\\n            dp[0][i] = 1 + dp[0][i - 1];\\n        }\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n              \\n                if(word2[i - 1] == word1[j - 1]){\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n                else{\\n                    dp[i][j] = 1 + min({dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]});\\n                }\\n               \\n            } \\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234043,
                "title": "c-well-commented-solution-with-explanation-dp",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int minDistance(string word1, string word2);\\n};\\n\\n/* Returns the minimum edit distance between the 2 strings */\\nint Solution :: minDistance(string str_1, string str_2)\\n{\\n    // Store the length of the two strings\\n    int lenFirst = str_1.length();\\n    int lenSecond = str_2.length();\\n    \\n    // Make a 2d vector of (len_first+1)*(len_second+1), since we are going to access the [len_first][len_second] element\\n    vector<vector<int>> dp;\\n    \\n    // Resize the vector to appropriate dimensions and initialise it with zero\\n    dp.resize(lenFirst+1);\\n    for(auto &row_vec : dp)\\n        row_vec.resize(lenSecond+1);\\n    \\n    /* DP definitions */\\n    /* dp[i][j] returns the edit distance of the first i elements of str_1 and first j elements of str_2 */\\n    \\n    \\n    /* dp[0][0] = 0\\n     * dp[0][j] = j First string is empty,  only insertions can happen\\n     * dp[i][0] = i Second string is empty, only deletions can happen\\n     * Compactly, dp[i][j] = max(i,j) if one of them is zero\\n     */\\n    \\n    // Fill the rest of the matrix \\n    for(int i=0; i<=(lenFirst); i++)\\n    {\\n        for(int j=0; j<=(lenSecond); j++)\\n        {\\n            // Base case, as discussed above\\n            if(i==0 || j==0)\\n                dp[i][j] = max(i,j);\\n                \\n            // If the last characters match, just remove them and calclulate for the left half\\n            else if(str_1[i-1] == str_2[j-1]) dp[i][j] = dp[i-1][j-1];\\n            \\n            // Else, the last character doesn\\'t match\\n            else\\n            {\\n                // Insert a new matching character at the end of first string. The last character matches now. \\n                int insert = 1 + dp[i][j-1];\\n                \\n                // Delete the last character of the first string\\n                int _delete = 1 + dp[i-1][j];\\n                \\n                // Replace the last character of the first string. Now, the last character matches. \\n                int replace = 1 + dp[i-1][j-1];\\n                \\n                // Take the best possible of all outcomes\\n                dp[i][j] = min({insert, _delete, replace});\\n            }\\n        }\\n    }\\n    \\n    // Return the edit distance of str_1 and str_2\\n    return dp[lenFirst][lenSecond];\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minDistance(string word1, string word2);\\n};\\n\\n/* Returns the minimum edit distance between the 2 strings */\\nint Solution :: minDistance(string str_1, string str_2)\\n{\\n    // Store the length of the two strings\\n    int lenFirst = str_1.length();\\n    int lenSecond = str_2.length();\\n    \\n    // Make a 2d vector of (len_first+1)*(len_second+1), since we are going to access the [len_first][len_second] element\\n    vector<vector<int>> dp;\\n    \\n    // Resize the vector to appropriate dimensions and initialise it with zero\\n    dp.resize(lenFirst+1);\\n    for(auto &row_vec : dp)\\n        row_vec.resize(lenSecond+1);\\n    \\n    /* DP definitions */\\n    /* dp[i][j] returns the edit distance of the first i elements of str_1 and first j elements of str_2 */\\n    \\n    \\n    /* dp[0][0] = 0\\n     * dp[0][j] = j First string is empty,  only insertions can happen\\n     * dp[i][0] = i Second string is empty, only deletions can happen\\n     * Compactly, dp[i][j] = max(i,j) if one of them is zero\\n     */\\n    \\n    // Fill the rest of the matrix \\n    for(int i=0; i<=(lenFirst); i++)\\n    {\\n        for(int j=0; j<=(lenSecond); j++)\\n        {\\n            // Base case, as discussed above\\n            if(i==0 || j==0)\\n                dp[i][j] = max(i,j);\\n                \\n            // If the last characters match, just remove them and calclulate for the left half\\n            else if(str_1[i-1] == str_2[j-1]) dp[i][j] = dp[i-1][j-1];\\n            \\n            // Else, the last character doesn\\'t match\\n            else\\n            {\\n                // Insert a new matching character at the end of first string. The last character matches now. \\n                int insert = 1 + dp[i][j-1];\\n                \\n                // Delete the last character of the first string\\n                int _delete = 1 + dp[i-1][j];\\n                \\n                // Replace the last character of the first string. Now, the last character matches. \\n                int replace = 1 + dp[i-1][j-1];\\n                \\n                // Take the best possible of all outcomes\\n                dp[i][j] = min({insert, _delete, replace});\\n            }\\n        }\\n    }\\n    \\n    // Return the edit distance of str_1 and str_2\\n    return dp[lenFirst][lenSecond];\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933524,
                "title": "step-by-step-explanation-from-brute-force-to-optimised-dp",
                "content": "\\n***It took a lot of time and efforts to make this post please upvote if you like it and found helpful !*** \\n\\n**Step By Step Explanation :-**\\n\\n For each poisition, check three subproblem:\\n      1. insert\\n      2. delete\\n      3. replace\\n\\nI was having trouble with this and figuring out the recurrences for the edit operations. i and j basically keep track of the current characters that are getting compared, each operation shifts them differently. **The important thing to note is that we are simulating the edit operations by moving i and j around**, not actually changing the input strings.\\n\\n**EXAMPLE**\\nc1 = sample, c2 = example\\ni = 0 (s), j = 0 (e)\\n**Replace** is simplest for me to understand, we replace the cur char with the char we need from word2. We then increment i and j to look at the next char.\\n*Replace -> match(c1,c2, i+1, j+1)*\\nc1 = eample, c2 = example\\ni = 1 (a), j = 1 (x)\\n\\n**Delete** removes the first character, shifting word 1 character to left. Since we do not actually delete the char, incrementing i simulates skipping this char.\\n*Delete -> match(c1, c2, i+1, j)*\\nc1 = sample, c2 = example\\ni = 1 (a) , j = 0 (e)\\n\\n**Insert** is the opposite of delete, we insert the char we need, shifting word 1 to the right. Since we do not actually add a char, leave i alone. It\\'s the similar as doing:\\n\\n  c1 = \"e\" + c1;\\n  match(c1,c2,i+1,j+1) //Since we added \"e\", i+1 would point to \"s\"\\n*Insert -> match(c1, c2, i, j+1)*\\nc1 = esample, c2 = example\\ni = 0 (s), j = 1 (x)\\n\\nHopefully I made sense, let me know if I can try to clarify more. I only recently was able to understand. Now lets jump to the Code part !\\n\\n***Method 1 : Recursion \\nTime Complexity : O(3^(min(len1,len2))  \\nSpace Complexity : O(n)***\\n\\n```\\nclass Solution {\\npublic:\\n    int editDistance(int i , int j , string& s1 , string& s2)\\n    {\\n        if (i == word1.size()) return word2.size() - j;\\n        if (j == word2.size()) return word1.size() - i;\\n        if( s1[i] == s2[j] ) return editDistance(i+1 , j+1, s1, s2);\\n        return 1 + min( editDistance(i , j+1, s1, s2), min( editDistance(i+1 , j, s1, s2),  editDistance(i+1 , j+1, s1, s2)));  // Didn\\'t Got it , No issue again go through the explanation !\\n    }\\n   \\n    int minDistance(string word1, string word2) {\\n    return editDistance(0, 0, word1 , word2);\\n    }\\n};\\n```\\nOfcourse It will give TLE , so for it we will precompute sub - problem and will store it in bottom - up and top - down manner using Dynamic Programming!\\n\\n\\n***Method 2 : Recursion + Memorisation ( Top - Down Approach )***\\n Time Complexity   :  O(len1 x len2) \\n Space Complexity : O(len1 x len2) \\n\\n```\\nclass Solution {\\npublic:\\n    int editDistance(int i , int j , string& s1 , string& s2, vector<vector<int>>&dp)\\n    {\\n        if(i == size(s1) ) return size(s2) - j;\\n        if(j == size(s2) ) return size(s1) - i;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if( s1[i] == s2[j] ) return dp[i][j] = editDistance(i+1 , j+1, s1, s2, dp);\\n        return dp[i][j] = 1 + min( editDistance(i , j+1, s1, s2, dp), min( editDistance(i+1 , j, s1, s2, dp),  editDistance(i+1 , j+1, s1, s2, dp)));\\n    }\\n   \\n    int minDistance(string word1, string word2) {\\n    vector<vector<int>>dp(size(word1), vector<int>(size(word2), -1));\\n    return editDistance(0, 0, word1 , word2, dp);\\n    }\\n};\\n```\\n\\n\\n***Method 3 : Tabulation ( Bottom - Up Approach)*** \\n***Time Complexity   : O(len1 x len2)\\nSpace Complexity : O(len1 x len2)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n    int n = size(word1); int m = size(word2);\\n    vector<vector<int>>dp(n+1, vector<int>(m+1,0));\\n    for(int i = 0 ; i <= n; i++) dp[i][0] = i;\\n    for(int j = 0 ; j <= m; j++) dp[0][j] = j;\\n    \\n    for(int i = 0 ; i < n; i++)\\n    {\\n        for(int j = 0 ; j < m; j++)\\n        {\\n           if( word1[i] == word2[j] ) \\n           dp[i+1][j+1] = dp[i][j];\\n           else\\n           dp[i + 1][j + 1] = min({dp[i][j + 1], dp[i + 1][j], dp[i][j]}) + 1;\\n\\t\\t   //Since it is bottom up, we are considering in the ascending order of indexes.\\n           //Insert means plus 1 to j, delete means plus 1 to i, replace means plus 1 to both i and j. \\n           //above sequence is delete, insert and replace. \\n        }\\n    }\\n    \\n    return dp[n][m];\\n    }\\n};\\n```\\n\\n***It took a lot of time and efforts to make this post please upvote if you like it and found helpful !***",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int editDistance(int i , int j , string& s1 , string& s2)\\n    {\\n        if (i == word1.size()) return word2.size() - j;\\n        if (j == word2.size()) return word1.size() - i;\\n        if( s1[i] == s2[j] ) return editDistance(i+1 , j+1, s1, s2);\\n        return 1 + min( editDistance(i , j+1, s1, s2), min( editDistance(i+1 , j, s1, s2),  editDistance(i+1 , j+1, s1, s2)));  // Didn\\'t Got it , No issue again go through the explanation !\\n    }\\n   \\n    int minDistance(string word1, string word2) {\\n    return editDistance(0, 0, word1 , word2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int editDistance(int i , int j , string& s1 , string& s2, vector<vector<int>>&dp)\\n    {\\n        if(i == size(s1) ) return size(s2) - j;\\n        if(j == size(s2) ) return size(s1) - i;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if( s1[i] == s2[j] ) return dp[i][j] = editDistance(i+1 , j+1, s1, s2, dp);\\n        return dp[i][j] = 1 + min( editDistance(i , j+1, s1, s2, dp), min( editDistance(i+1 , j, s1, s2, dp),  editDistance(i+1 , j+1, s1, s2, dp)));\\n    }\\n   \\n    int minDistance(string word1, string word2) {\\n    vector<vector<int>>dp(size(word1), vector<int>(size(word2), -1));\\n    return editDistance(0, 0, word1 , word2, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n    int n = size(word1); int m = size(word2);\\n    vector<vector<int>>dp(n+1, vector<int>(m+1,0));\\n    for(int i = 0 ; i <= n; i++) dp[i][0] = i;\\n    for(int j = 0 ; j <= m; j++) dp[0][j] = j;\\n    \\n    for(int i = 0 ; i < n; i++)\\n    {\\n        for(int j = 0 ; j < m; j++)\\n        {\\n           if( word1[i] == word2[j] ) \\n           dp[i+1][j+1] = dp[i][j];\\n           else\\n           dp[i + 1][j + 1] = min({dp[i][j + 1], dp[i + 1][j], dp[i][j]}) + 1;\\n\\t\\t   //Since it is bottom up, we are considering in the ascending order of indexes.\\n           //Insert means plus 1 to j, delete means plus 1 to i, replace means plus 1 to both i and j. \\n           //above sequence is delete, insert and replace. \\n        }\\n    }\\n    \\n    return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928349,
                "title": "java-top-down-memo",
                "content": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        final int m = word1.length();\\n        final int n = word2.length();\\n        final int[][] memo = new int[m][n];\\n        \\n        return minDistHelper(word1, word2, m, n, memo);\\n    }\\n    \\n    private int minDistHelper(String word1, String word2, int m, int n, int[][] memo) {\\n        \\n        if(m == 0) {\\n            return n;\\n        }\\n        \\n        if(n == 0) {\\n            return m;\\n        }\\n        \\n        if(memo[m - 1][n - 1] != 0) {\\n            return memo[m - 1][n - 1];\\n        }\\n        \\n        if(word1.charAt(m - 1) == word2.charAt(n - 1)) {\\n            return minDistHelper(word1, word2, m - 1, n - 1, memo);\\n        }\\n        \\n        int insert = minDistHelper(word1, word2, m, n - 1, memo);\\n        int remove = minDistHelper(word1, word2, m - 1, n, memo);\\n        int replace = minDistHelper(word1, word2, m - 1, n - 1, memo);\\n        \\n        memo[m - 1][n - 1] = 1 + Math.min(insert, Math.min(remove, replace));\\n        return memo[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        final int m = word1.length();\\n        final int n = word2.length();\\n        final int[][] memo = new int[m][n];\\n        \\n        return minDistHelper(word1, word2, m, n, memo);\\n    }\\n    \\n    private int minDistHelper(String word1, String word2, int m, int n, int[][] memo) {\\n        \\n        if(m == 0) {\\n            return n;\\n        }\\n        \\n        if(n == 0) {\\n            return m;\\n        }\\n        \\n        if(memo[m - 1][n - 1] != 0) {\\n            return memo[m - 1][n - 1];\\n        }\\n        \\n        if(word1.charAt(m - 1) == word2.charAt(n - 1)) {\\n            return minDistHelper(word1, word2, m - 1, n - 1, memo);\\n        }\\n        \\n        int insert = minDistHelper(word1, word2, m, n - 1, memo);\\n        int remove = minDistHelper(word1, word2, m - 1, n, memo);\\n        int replace = minDistHelper(word1, word2, m - 1, n - 1, memo);\\n        \\n        memo[m - 1][n - 1] = 1 + Math.min(insert, Math.min(remove, replace));\\n        return memo[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894150,
                "title": "a-straightforward-solution-python-faster-than-98-6",
                "content": "The idea is to find the recursive relation. \\n\\nIf `s1[i] == s2[j]`, then `f(i, j) = f(i - 1, j - 1)`\\nOtherwise, \\n    `f(i, j) = min(1 + f(i, j - 1), 1 + f(i - 1, j), 1 + f(i - 1, j - 1))`\\nwhich corresponds to insert, delete and replace.\\n\\n```\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n\\n        @lru_cache(maxsize=None)\\n        def f(i, j):\\n            if i == 0 and j == 0: return 0\\n            if i == 0 or j == 0: return i or j\\n            if s1[i - 1] == s2[j - 1]:\\n                return f(i - 1, j - 1)\\n            return min(1 + f(i, j - 1), 1 + f(i - 1, j), 1 + f(i - 1, j - 1))\\n\\n        m, n = len(s1), len(s2)\\n        return f(m, n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n\\n        @lru_cache(maxsize=None)\\n        def f(i, j):\\n            if i == 0 and j == 0: return 0\\n            if i == 0 or j == 0: return i or j\\n            if s1[i - 1] == s2[j - 1]:\\n                return f(i - 1, j - 1)\\n            return min(1 + f(i, j - 1), 1 + f(i - 1, j), 1 + f(i - 1, j - 1))\\n\\n        m, n = len(s1), len(s2)\\n        return f(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662356,
                "title": "easiest-solution-dp-w-explanation",
                "content": "This is also considered as levenshtein distance algorithm. \\nTime = O(mn)\\nSpace = O(mn)\\nHere, we can improve this method by using only 2 rows instead of the entire 2d array.\\n\\nHere, we have to find the minimum no of operations to convert one string to another. \\nAlso, this will get harder with longer strings so our best friend here will be dynamic programming.\\nWe can construct a 2d array/matrix to store all the possible least no. operations to convert one string to another.\\n\\n\\t0 1 2 3 4\\n0\\n1\\n2\\n3\\n4\\n5\\nWe have to initialize our matrix like this^ to add values into it. \\nHere these two axis represent two strings.\\nWe have taken 0 in the beginning which acts as our base case. So it will look something like this:\\n       \\n\\t0 1 2 3 4\\n0  0 0 0 0 0 \\n1  0\\n2  0\\n3  0\\n4  0\\n5  0\\nThis is our base case and now we\\'ll just use dp to find all the values. \\nOur formula will be \\nif string2[i] == string1[j] # means if two letters are equal:\\nmatrix[i][j] = matrix[i - 1][j - 1] because it will give us min no of operations\\n\\nelse:(if the letters that we\\'re comparing are not equal, then well check all the values, above it, to the left if it and to the left diagonal) find min of these and add 1 to it.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\nCode:\\n\\n\\tclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        edits = [[x for x in range(len(word1) + 1)] for y in range(len(word2) + 1)] #initialize 2d\\n        for i in range(1, len(word2) + 1): #initailize first column(012345)\\n            edits[i][0] = edits[i - 1][0] + 1\\n        for i in range(1, len(word2) + 1):\\n            for j in range(1, len(word1) + 1):\\n                if word2[i - 1] == word1[j - 1]: #if same just check diaginal\\n                    edits[i][j] = edits[i - 1][j - 1]\\n                else:\\n                    edits[i][j] = 1 + min(edits[i - 1][j - 1], edits[i][j - 1], edits[i - 1][j]) #check all three vals, find min and add 1\\n        return edits[-1][-1] #return final val of our 2d matrix(last row last col)\\n\\t\\t\\nIf you have any questions, feel free to comment down below. I\\'m also gonna implement this using only two rows which will save some space. \\n                        \\n            \\n        \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "This is also considered as levenshtein distance algorithm. \\nTime = O(mn)\\nSpace = O(mn)\\nHere, we can improve this method by using only 2 rows instead of the entire 2d array.\\n\\nHere, we have to find the minimum no of operations to convert one string to another. \\nAlso, this will get harder with longer strings so our best friend here will be dynamic programming.\\nWe can construct a 2d array/matrix to store all the possible least no. operations to convert one string to another.\\n\\n\\t0 1 2 3 4\\n0\\n1\\n2\\n3\\n4\\n5\\nWe have to initialize our matrix like this^ to add values into it. \\nHere these two axis represent two strings.\\nWe have taken 0 in the beginning which acts as our base case. So it will look something like this:\\n       \\n\\t0 1 2 3 4\\n0  0 0 0 0 0 \\n1  0\\n2  0\\n3  0\\n4  0\\n5  0\\nThis is our base case and now we\\'ll just use dp to find all the values. \\nOur formula will be \\nif string2[i] == string1[j] # means if two letters are equal:\\nmatrix[i][j] = matrix[i - 1][j - 1] because it will give us min no of operations\\n\\nelse:(if the letters that we\\'re comparing are not equal, then well check all the values, above it, to the left if it and to the left diagonal) find min of these and add 1 to it.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\nCode:\\n\\n\\tclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        edits = [[x for x in range(len(word1) + 1)] for y in range(len(word2) + 1)] #initialize 2d\\n        for i in range(1, len(word2) + 1): #initailize first column(012345)\\n            edits[i][0] = edits[i - 1][0] + 1\\n        for i in range(1, len(word2) + 1):\\n            for j in range(1, len(word1) + 1):\\n                if word2[i - 1] == word1[j - 1]: #if same just check diaginal\\n                    edits[i][j] = edits[i - 1][j - 1]\\n                else:\\n                    edits[i][j] = 1 + min(edits[i - 1][j - 1], edits[i][j - 1], edits[i - 1][j]) #check all three vals, find min and add 1\\n        return edits[-1][-1] #return final val of our 2d matrix(last row last col)\\n\\t\\t\\nIf you have any questions, feel free to comment down below. I\\'m also gonna implement this using only two rows which will save some space. \\n                        \\n            \\n        \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 479377,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The **ART** of dynamic programming](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/)\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return M - i + N - j\\n            var a = (if (s[i] != t[j]) 1 else 0) + go(i + 1, j + 1)\\n            var b = 1 + go(i + 1, j)\\n            var c = 1 + go(i, j + 1)\\n            return listOf(a, b, c).min()!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return M - i + N - j\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var a = (if (s[i] != t[j]) 1 else 0) + go(i + 1, j + 1)\\n                var b = 1 + go(i + 1, j)\\n                var c = 1 + go(i, j + 1)\\n                m[k] = listOf(a, b, c).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var dp = Array(M + 1) { IntArray(N + 1) { 0 } }\\n        for (i in 1..M) dp[i][0] = 1 + dp[i - 1][0]\\n        for (j in 1..N) dp[0][j] = 1 + dp[0][j - 1]\\n        for (i in 1..M) {\\n            for (j in 1..N) {\\n                var a = (if (s[i - 1] != t[j - 1]) 1 else 0) + dp[i - 1][j - 1]\\n                var b = 1 + dp[i - 1][j]\\n                var c = 1 + dp[i][j - 1]\\n                dp[i][j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return dp[M][N]\\n    }\\n}\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var cur = IntArray(N + 1) { 0 }\\n        for (j in 1..N) cur[j] = 1 + cur[j - 1]\\n        for (i in 1..M) {\\n            var pre = cur.copyOf()\\n            ++cur[0]\\n            for (j in 1..N) {\\n                var a = (if (s[i - 1] != t[j - 1]) 1 else 0) + pre[j - 1]\\n                var b = 1 + pre[j]\\n                var c = 1 + cur[j - 1]\\n                cur[j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return cur[N]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nlet minDistance = (s, t) => {\\n    let [M, N] = [s.length, t.length];\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return M - i + N - j;\\n        let a = Number(s[i] != t[j]) + go(i + 1, j + 1),\\n            b = 1 + go(i + 1, j),\\n            c = 1 + go(i, j + 1);\\n        return Math.min(a, b, c);\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return M - i + N - j;\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let a = Number(s[i] != t[j]) + go(i + 1, j + 1),\\n                b = 1 + go(i + 1, j),\\n                c = 1 + go(i, j + 1);\\n            m.set(k, Math.min(a, b, c));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let dp = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n    for (let i = 1; i <= M; ++i) dp[i][0] = 1 + dp[i - 1][0];\\n    for (let j = 1; j <= N; ++j) dp[0][j] = 1 + dp[0][j - 1];\\n    for (let i = 1; i <= M; ++i) {\\n        for (let j = 1; j <= N; ++j) {\\n            let a = Number(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1],\\n                b = 1 + dp[i - 1][j],\\n                c = 1 + dp[i][j - 1];\\n            dp[i][j] = Math.min(a, b, c);\\n        }\\n    }\\n    return dp[M][N];\\n};\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let cur = Array(N + 1).fill(0);\\n    for (let j = 1; j <= N; ++j) cur[j] = 1 + cur[j - 1];\\n    for (let i = 1; i <= M; ++i) {\\n        let pre = [...cur];\\n        ++cur[0];\\n        for (let j = 1; j <= N; ++j) {\\n            let a = Number(s[i - 1] != t[j - 1]) + pre[j - 1],\\n                b = 1 + pre[j],\\n                c = 1 + cur[j - 1];\\n            cur[j] = Math.min(a, b, c);\\n        }\\n    }\\n    return cur[N];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return M - i + N - j\\n            a = int(s[i] != t[j]) + go(i + 1, j + 1)\\n            b = 1 + go(i + 1, j)\\n            c = 1 + go(i, j + 1)\\n            return min(a, b, c)\\n        return go()\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return M - i + N - j\\n            a = int(s[i] != t[j]) + go(i + 1, j + 1)\\n            b = 1 + go(i + 1, j)\\n            c = 1 + go(i, j + 1)\\n            return min(a, b, c)\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        dp = [[0] * (N + 1) for _ in range(M + 1)]\\n        for i in range(1, M + 1): dp[i][0] = 1 + dp[i - 1][0]\\n        for j in range(1, N + 1): dp[0][j] = 1 + dp[0][j - 1]\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                a = int(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1]\\n                b = 1 + dp[i - 1][j]\\n                c = 1 + dp[i][j - 1]\\n                dp[i][j] = min(a, b, c)\\n        return dp[M][N]\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        cur = [0] * (N + 1)\\n        for j in range(1, N + 1): cur[j] = 1 + cur[j - 1]\\n        for i in range(1, M + 1):\\n            pre = cur[:]\\n            cur[0] += 1\\n            for j in range(1, N + 1):\\n                a = int(s[i - 1] != t[j - 1]) + pre[j - 1]\\n                b = 1 + pre[j]\\n                c = 1 + cur[j - 1]\\n                cur[j] = min(a, b, c)\\n        return cur[N]\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return M - i + N - j;\\n            auto a = int(s[i] != t[j]) + go(i + 1, j + 1),\\n                 b = 1 + go(i + 1, j),\\n                 c = 1 + go(i, j + 1);\\n            return min({ a, b, c });\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minDistance(string s, string t, Map m = {}) {\\n        int M = s.size(),\\n            N = t.size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return M - i + N - j;\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto a = int(s[i] != t[j]) + go(i + 1, j + 1),\\n                     b = 1 + go(i + 1, j),\\n                     c = 1 + go(i, j + 1);\\n                m[k] = min({ a, b, c });\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        VVI dp(M + 1, VI(N + 1));\\n        for (auto i{ 1 }; i <= M; ++i) dp[i][0] = 1 + dp[i - 1][0];\\n        for (auto j{ 1 }; j <= N; ++j) dp[0][j] = 1 + dp[0][j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = int(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1],\\n                     b = 1 + dp[i - 1][j],\\n                     c = 1 + dp[i][j - 1];\\n                dp[i][j] = min({ a, b, c });\\n            }\\n        }\\n        return dp[M][N];\\n    }\\n};\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        VI cur(N + 1);\\n        for (auto j{ 1 }; j <= N; ++j) cur[j] = 1 + cur[j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            auto pre{ cur };\\n            ++cur[0];\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = int(s[i - 1] != t[j - 1]) + pre[j - 1],\\n                     b = 1 + pre[j],\\n                     c = 1 + cur[j - 1];\\n                cur[j] = min({ a, b, c });\\n            }\\n        }\\n        return cur[N];\\n    }\\n};\\n```\\n\\n---\\n\\n**Legacy Solutions from October 2, 2020:**\\n\\nLet `i` and `j` be non-inclusive indexes of strings `A` and `B` which denote each corresponding substring of `A[0..i)` and `B[0..j)`.  Let `M` and `N` be the length of `A` and `B`.  Thus initially `i = M` and `j = N` (ie. `A == A[0..i=M)` and `B == B[0..j=N)`).  Recursively consider the last character of `A` and `B`, ie. `A[i - 1]` and `B[j - 1]`, there are 4 use cases:\\n\\n1. If the last characters match, then there is no penalty, move onto the sub-problems without the last characters\\n2. If the last characters mismatch, then the last character in `A` can be replaced with the last character in `B` xor the last character in `B` can be replaced with the last character in `A` to make these characters match.  This replacement is an arbitrary choice with penalty of `1`\\n3. If the last characters mismatch, then we can insert a character in `A` xor we can delete a character from `B`.  The insertion/deletion is an arbitrary choice with penalty of `1`\\n4. If the last characters mismatch, then we can insert a character in `B` xor we can delete a character from `A`.  The insertion/deletion is an arbitrary choice with penalty of `1`\\n\\n---\\n\\n**Example use case 1:** the last character `x` is a match.  There is no penalty.\\n```\\nA = ...x\\nB = ...x\\n```\\n\\n**Example use case 2:** the last character `x` is a mismatch.  Regardless of the arbitrary \"fix\" choosen, there is a penalty of `1` for this replacement.\\n```\\nA = ...x\\nB = ...y\\n```\\n\\n* If we replace `x` with `y` in `A`, then this use case 2 mismatch is \"fixed\" as follows:\\n```\\nA = ...y\\nB = ...y\\n```\\n\\n* If we replace `y` with `x` in `B`, then this use case 2 mismatch is \"fixed\" as follows:\\n```\\nA = ...x\\nB = ...x\\n```\\n\\n**Example use case 3:** the last character `z` is a mismatch.  Regardless of the arbitrary \"fix\" choosen, there is a penalty of `1` for this insertion/deletion.\\n```\\nA = xy\\nB = xyz\\n```\\n\\n* If we insert `z` in `A`, then this use case 3 mismatch is \"fixed\" as follows:\\n```\\nA = xyz\\nB = xyz\\n```\\n\\n* If we delete `z` from `B`, then this use case 3 mismatch is \"fixed\" as follows:\\n```\\nA = xy\\nB = xy\\n```\\n\\n**Example use case 4:** the last character `z` is a mismatch.  Regardless of the arbitrary \"fix\" choosen, there is a penalty of `1` for this insertion/deletion.\\n```\\nA = xyz\\nB = xy\\n```\\n\\n* If we insert `z` in `B`, then this use case 3 mismatch is \"fixed\" as follows:\\n```\\nA = xyz\\nB = xyz\\n```\\n\\n* If we delete `z` from `A`, then this use case 3 mismatch is \"fixed\" as follows:\\n```\\nA = xy\\nB = xy\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n*Javascript: Top-Down TLE without Memo*\\n```\\nlet minDistance = (A, B) => {\\n    let go = (A, B, i, j) => {\\n        if (!i || !j)\\n            return i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return Math.min(\\n            go(A, B, i - 1, j - 1) + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1) + 1  // \\u274C deletion\\n        );\\n    };\\n    return go(A, B, A.length, B.length);\\n};\\n```\\n\\n*Javascript: Top-Down with Memo*\\n```\\nlet minDistance = (A, B) => {\\n    let go = (A, B, i, j, memo = {}) => {\\n        let key = `${i},${j}`; // \\uD83D\\uDD11 \\n        if (memo[key])\\n            return memo[key]; // \\uD83E\\uDD14 memo\\n        if (!i || !j)\\n            return memo[key] = i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return memo[key] = Math.min(\\n            go(A, B, i - 1, j - 1, memo) + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j, memo) + 1, // \\u274C insertion \\n            go(A, B, i, j - 1, memo) + 1  // \\u274C deletion\\n        );\\n    };\\n    return go(A, B, A.length, B.length);\\n};\\n```\\n\\n*Javascript: Bottom-Up with full DP matrix*\\n```\\nlet minDistance = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let dp = [...Array(M + 1)].map(row => Array(N + 1).fill(0)); // \\uD83E\\uDD14 memo\\n    for (let i = 0; i <= M; ++i) dp[i][0] = i; // \\uD83D\\uDED1 base case: we have exhausted B, return \"leftover\" distance\\n    for (let j = 0; j <= N; ++j) dp[0][j] = j; // \\uD83D\\uDED1 base case: we have exhausted A, return \"leftover\" distance\\n    for (let i = 1; i <= M; ++i)\\n        for (let j = 1; j <= N; ++j)\\n            dp[i][j] = Math.min(\\n                dp[i - 1][j - 1] + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                dp[i - 1][j] + 1, // \\u274C insertion \\n                dp[i][j - 1] + 1, // \\u274C deletion\\n            );\\n    return dp[M][N];\\n};\\n```\\n\\n*Javascript: Bottom-Up with memory optimization to only store previous and current rows of the DP matrix*\\n```\\nlet minDistance = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let pre = [...Array(N + 1)].map((_, i) => i); // \\uD83E\\uDD14 memo \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n    for (let i = 1; i <= M; ++i) {\\n        let cur = [...pre]; // \\uD83E\\uDD14 generate current from previous\\n        cur[0] = i; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        for (let j = 1; j <= N; ++j) {\\n            cur[j] = Math.min(\\n                pre[j - 1] + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                pre[j] + 1,     // \\u274C insertion \\n                cur[j - 1] + 1, // \\u274C deletion\\n            );\\n        }\\n        [pre, cur] = [cur, pre]; // swap\\n    }\\n    return pre[N];\\n};\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n*C++: Top-Down TLE without Memo*\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string A, string B) {\\n        return go(A, B, A.size(), B.size());\\n    }\\nprivate:\\n    int go(string& A, string& B, int i, int j) {\\n        if (!i || !j)\\n            return i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return min({\\n            go(A, B, i - 1, j - 1) + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1) + 1  // \\u274C deletion\\n        });\\n    }\\n};\\n```\\n\\n*C++: Top-Down with Memo*\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string A, string B) {\\n        return go(A, B, A.size(), B.size());\\n    }\\nprivate:\\n    using Memo = unordered_map<string, int>;\\n    int go(string& A, string& B, int i, int j, Memo&& memo = {}) {\\n        stringstream ss; ss << i << \",\" << j;\\n        auto key = ss.str(); // \\uD83D\\uDD11\\n        if (memo.find(key) != memo.end())\\n            return memo[key]; // \\uD83E\\uDD14 memo\\n        if (!i || !j)\\n            return memo[key] = i + j;\\n        return memo[key] = min({\\n            go(A, B, i - 1, j - 1, move(memo)) + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j, move(memo)) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1, move(memo)) + 1  // \\u274C deletion\\n        });\\n    }\\n};\\n```\\n\\n*C++: Bottom-Up with full DP matrix*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string A, string B) {\\n        auto [M, N] = make_tuple(A.size(), B.size());\\n        VVI dp(M + 1, VI(N + 1)); // \\uD83E\\uDD14 memo\\n        for (auto i = 0; i <= M; ++i) dp[i][0] = i; // \\uD83D\\uDED1 base case: we have exhausted B, return \"leftover\" distance\\n        for (auto j = 0; j <= N; ++j) dp[0][j] = j; // \\uD83D\\uDED1 base case: we have exhausted A, return \"leftover\" distance\\n        for (auto i = 1; i <= M; ++i)\\n            for (auto j = 1; j <= N; ++j)\\n                dp[i][j] = min({\\n                    dp[i - 1][j - 1] + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                    dp[i - 1][j] + 1, // \\u274C insertion \\n                    dp[i][j - 1] + 1, // \\u274C deletion\\n                });\\n        return dp[M][N];\\n    }\\n};\\n```\\n\\n*C++: Bottom-Up with memory optimization to only store previous and current rows of the DP matrix*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string A, string B) {\\n        auto [M, N] = make_tuple(A.size(), B.size());\\n        VI pre(N + 1); // \\uD83E\\uDD14 memo\\n        iota(pre.begin(), pre.end(), 0); // \\uD83D\\uDED1 base case: we have exhausted A or B, i is the \"leftover\" distance\\n        for (auto i = 1; i <= M; ++i) {\\n            auto cur{ pre }; // \\uD83E\\uDD14 generate current from previous\\n            cur[0] = i; // \\uD83D\\uDED1 base case: we have exhausted A or B, i is the \"leftover\" distance\\n            for (auto j = 1; j <= N; ++j) {\\n                cur[j] = min({\\n                    pre[j - 1] + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                    pre[j] + 1,     // \\u274C insertion \\n                    cur[j - 1] + 1, // \\u274C deletion\\n                });\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return M - i + N - j\\n            var a = (if (s[i] != t[j]) 1 else 0) + go(i + 1, j + 1)\\n            var b = 1 + go(i + 1, j)\\n            var c = 1 + go(i, j + 1)\\n            return listOf(a, b, c).min()!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return M - i + N - j\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var a = (if (s[i] != t[j]) 1 else 0) + go(i + 1, j + 1)\\n                var b = 1 + go(i + 1, j)\\n                var c = 1 + go(i, j + 1)\\n                m[k] = listOf(a, b, c).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var dp = Array(M + 1) { IntArray(N + 1) { 0 } }\\n        for (i in 1..M) dp[i][0] = 1 + dp[i - 1][0]\\n        for (j in 1..N) dp[0][j] = 1 + dp[0][j - 1]\\n        for (i in 1..M) {\\n            for (j in 1..N) {\\n                var a = (if (s[i - 1] != t[j - 1]) 1 else 0) + dp[i - 1][j - 1]\\n                var b = 1 + dp[i - 1][j]\\n                var c = 1 + dp[i][j - 1]\\n                dp[i][j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return dp[M][N]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var cur = IntArray(N + 1) { 0 }\\n        for (j in 1..N) cur[j] = 1 + cur[j - 1]\\n        for (i in 1..M) {\\n            var pre = cur.copyOf()\\n            ++cur[0]\\n            for (j in 1..N) {\\n                var a = (if (s[i - 1] != t[j - 1]) 1 else 0) + pre[j - 1]\\n                var b = 1 + pre[j]\\n                var c = 1 + cur[j - 1]\\n                cur[j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return cur[N]\\n    }\\n}\\n```\n```\\nlet minDistance = (s, t) => {\\n    let [M, N] = [s.length, t.length];\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return M - i + N - j;\\n        let a = Number(s[i] != t[j]) + go(i + 1, j + 1),\\n            b = 1 + go(i + 1, j),\\n            c = 1 + go(i, j + 1);\\n        return Math.min(a, b, c);\\n    };\\n    return go();\\n};\\n```\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return M - i + N - j;\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let a = Number(s[i] != t[j]) + go(i + 1, j + 1),\\n                b = 1 + go(i + 1, j),\\n                c = 1 + go(i, j + 1);\\n            m.set(k, Math.min(a, b, c));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let dp = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n    for (let i = 1; i <= M; ++i) dp[i][0] = 1 + dp[i - 1][0];\\n    for (let j = 1; j <= N; ++j) dp[0][j] = 1 + dp[0][j - 1];\\n    for (let i = 1; i <= M; ++i) {\\n        for (let j = 1; j <= N; ++j) {\\n            let a = Number(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1],\\n                b = 1 + dp[i - 1][j],\\n                c = 1 + dp[i][j - 1];\\n            dp[i][j] = Math.min(a, b, c);\\n        }\\n    }\\n    return dp[M][N];\\n};\\n```\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let cur = Array(N + 1).fill(0);\\n    for (let j = 1; j <= N; ++j) cur[j] = 1 + cur[j - 1];\\n    for (let i = 1; i <= M; ++i) {\\n        let pre = [...cur];\\n        ++cur[0];\\n        for (let j = 1; j <= N; ++j) {\\n            let a = Number(s[i - 1] != t[j - 1]) + pre[j - 1],\\n                b = 1 + pre[j],\\n                c = 1 + cur[j - 1];\\n            cur[j] = Math.min(a, b, c);\\n        }\\n    }\\n    return cur[N];\\n};\\n```\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return M - i + N - j\\n            a = int(s[i] != t[j]) + go(i + 1, j + 1)\\n            b = 1 + go(i + 1, j)\\n            c = 1 + go(i, j + 1)\\n            return min(a, b, c)\\n        return go()\\n```\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return M - i + N - j\\n            a = int(s[i] != t[j]) + go(i + 1, j + 1)\\n            b = 1 + go(i + 1, j)\\n            c = 1 + go(i, j + 1)\\n            return min(a, b, c)\\n        return go()\\n```\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        dp = [[0] * (N + 1) for _ in range(M + 1)]\\n        for i in range(1, M + 1): dp[i][0] = 1 + dp[i - 1][0]\\n        for j in range(1, N + 1): dp[0][j] = 1 + dp[0][j - 1]\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                a = int(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1]\\n                b = 1 + dp[i - 1][j]\\n                c = 1 + dp[i][j - 1]\\n                dp[i][j] = min(a, b, c)\\n        return dp[M][N]\\n```\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        cur = [0] * (N + 1)\\n        for j in range(1, N + 1): cur[j] = 1 + cur[j - 1]\\n        for i in range(1, M + 1):\\n            pre = cur[:]\\n            cur[0] += 1\\n            for j in range(1, N + 1):\\n                a = int(s[i - 1] != t[j - 1]) + pre[j - 1]\\n                b = 1 + pre[j]\\n                c = 1 + cur[j - 1]\\n                cur[j] = min(a, b, c)\\n        return cur[N]\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return M - i + N - j;\\n            auto a = int(s[i] != t[j]) + go(i + 1, j + 1),\\n                 b = 1 + go(i + 1, j),\\n                 c = 1 + go(i, j + 1);\\n            return min({ a, b, c });\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minDistance(string s, string t, Map m = {}) {\\n        int M = s.size(),\\n            N = t.size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return M - i + N - j;\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto a = int(s[i] != t[j]) + go(i + 1, j + 1),\\n                     b = 1 + go(i + 1, j),\\n                     c = 1 + go(i, j + 1);\\n                m[k] = min({ a, b, c });\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        VVI dp(M + 1, VI(N + 1));\\n        for (auto i{ 1 }; i <= M; ++i) dp[i][0] = 1 + dp[i - 1][0];\\n        for (auto j{ 1 }; j <= N; ++j) dp[0][j] = 1 + dp[0][j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = int(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1],\\n                     b = 1 + dp[i - 1][j],\\n                     c = 1 + dp[i][j - 1];\\n                dp[i][j] = min({ a, b, c });\\n            }\\n        }\\n        return dp[M][N];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        VI cur(N + 1);\\n        for (auto j{ 1 }; j <= N; ++j) cur[j] = 1 + cur[j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            auto pre{ cur };\\n            ++cur[0];\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = int(s[i - 1] != t[j - 1]) + pre[j - 1],\\n                     b = 1 + pre[j],\\n                     c = 1 + cur[j - 1];\\n                cur[j] = min({ a, b, c });\\n            }\\n        }\\n        return cur[N];\\n    }\\n};\\n```\n```\\nA = ...x\\nB = ...x\\n```\n```\\nA = ...x\\nB = ...y\\n```\n```\\nA = ...y\\nB = ...y\\n```\n```\\nA = ...x\\nB = ...x\\n```\n```\\nA = xy\\nB = xyz\\n```\n```\\nA = xyz\\nB = xyz\\n```\n```\\nA = xy\\nB = xy\\n```\n```\\nA = xyz\\nB = xy\\n```\n```\\nA = xyz\\nB = xyz\\n```\n```\\nA = xy\\nB = xy\\n```\n```\\nlet minDistance = (A, B) => {\\n    let go = (A, B, i, j) => {\\n        if (!i || !j)\\n            return i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return Math.min(\\n            go(A, B, i - 1, j - 1) + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1) + 1  // \\u274C deletion\\n        );\\n    };\\n    return go(A, B, A.length, B.length);\\n};\\n```\n```\\nlet minDistance = (A, B) => {\\n    let go = (A, B, i, j, memo = {}) => {\\n        let key = `${i},${j}`; // \\uD83D\\uDD11 \\n        if (memo[key])\\n            return memo[key]; // \\uD83E\\uDD14 memo\\n        if (!i || !j)\\n            return memo[key] = i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return memo[key] = Math.min(\\n            go(A, B, i - 1, j - 1, memo) + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j, memo) + 1, // \\u274C insertion \\n            go(A, B, i, j - 1, memo) + 1  // \\u274C deletion\\n        );\\n    };\\n    return go(A, B, A.length, B.length);\\n};\\n```\n```\\nlet minDistance = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let dp = [...Array(M + 1)].map(row => Array(N + 1).fill(0)); // \\uD83E\\uDD14 memo\\n    for (let i = 0; i <= M; ++i) dp[i][0] = i; // \\uD83D\\uDED1 base case: we have exhausted B, return \"leftover\" distance\\n    for (let j = 0; j <= N; ++j) dp[0][j] = j; // \\uD83D\\uDED1 base case: we have exhausted A, return \"leftover\" distance\\n    for (let i = 1; i <= M; ++i)\\n        for (let j = 1; j <= N; ++j)\\n            dp[i][j] = Math.min(\\n                dp[i - 1][j - 1] + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                dp[i - 1][j] + 1, // \\u274C insertion \\n                dp[i][j - 1] + 1, // \\u274C deletion\\n            );\\n    return dp[M][N];\\n};\\n```\n```\\nlet minDistance = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let pre = [...Array(N + 1)].map((_, i) => i); // \\uD83E\\uDD14 memo \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n    for (let i = 1; i <= M; ++i) {\\n        let cur = [...pre]; // \\uD83E\\uDD14 generate current from previous\\n        cur[0] = i; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        for (let j = 1; j <= N; ++j) {\\n            cur[j] = Math.min(\\n                pre[j - 1] + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                pre[j] + 1,     // \\u274C insertion \\n                cur[j - 1] + 1, // \\u274C deletion\\n            );\\n        }\\n        [pre, cur] = [cur, pre]; // swap\\n    }\\n    return pre[N];\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string A, string B) {\\n        return go(A, B, A.size(), B.size());\\n    }\\nprivate:\\n    int go(string& A, string& B, int i, int j) {\\n        if (!i || !j)\\n            return i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return min({\\n            go(A, B, i - 1, j - 1) + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1) + 1  // \\u274C deletion\\n        });\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string A, string B) {\\n        return go(A, B, A.size(), B.size());\\n    }\\nprivate:\\n    using Memo = unordered_map<string, int>;\\n    int go(string& A, string& B, int i, int j, Memo&& memo = {}) {\\n        stringstream ss; ss << i << \",\" << j;\\n        auto key = ss.str(); // \\uD83D\\uDD11\\n        if (memo.find(key) != memo.end())\\n            return memo[key]; // \\uD83E\\uDD14 memo\\n        if (!i || !j)\\n            return memo[key] = i + j;\\n        return memo[key] = min({\\n            go(A, B, i - 1, j - 1, move(memo)) + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j, move(memo)) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1, move(memo)) + 1  // \\u274C deletion\\n        });\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string A, string B) {\\n        auto [M, N] = make_tuple(A.size(), B.size());\\n        VVI dp(M + 1, VI(N + 1)); // \\uD83E\\uDD14 memo\\n        for (auto i = 0; i <= M; ++i) dp[i][0] = i; // \\uD83D\\uDED1 base case: we have exhausted B, return \"leftover\" distance\\n        for (auto j = 0; j <= N; ++j) dp[0][j] = j; // \\uD83D\\uDED1 base case: we have exhausted A, return \"leftover\" distance\\n        for (auto i = 1; i <= M; ++i)\\n            for (auto j = 1; j <= N; ++j)\\n                dp[i][j] = min({\\n                    dp[i - 1][j - 1] + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                    dp[i - 1][j] + 1, // \\u274C insertion \\n                    dp[i][j - 1] + 1, // \\u274C deletion\\n                });\\n        return dp[M][N];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string A, string B) {\\n        auto [M, N] = make_tuple(A.size(), B.size());\\n        VI pre(N + 1); // \\uD83E\\uDD14 memo\\n        iota(pre.begin(), pre.end(), 0); // \\uD83D\\uDED1 base case: we have exhausted A or B, i is the \"leftover\" distance\\n        for (auto i = 1; i <= M; ++i) {\\n            auto cur{ pre }; // \\uD83E\\uDD14 generate current from previous\\n            cur[0] = i; // \\uD83D\\uDED1 base case: we have exhausted A or B, i is the \"leftover\" distance\\n            for (auto j = 1; j <= N; ++j) {\\n                cur[j] = min({\\n                    pre[j - 1] + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                    pre[j] + 1,     // \\u274C insertion \\n                    cur[j - 1] + 1, // \\u274C deletion\\n                });\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151449,
                "title": "python-dp-solution",
                "content": "```\\ndef minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        m = len(word1)\\n        n = len(word2)\\n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i== 0:\\n                    dp[i][j] = j\\n                elif j == 0:\\n                    dp[i][j] = i\\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])\\n        return dp[m][n]   \\n```",
                "solutionTags": [],
                "code": "```\\ndef minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        m = len(word1)\\n        n = len(word2)\\n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i== 0:\\n                    dp[i][j] = j\\n                elif j == 0:\\n                    dp[i][j] = i\\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])\\n        return dp[m][n]   \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 133086,
                "title": "from-brute-force-to-dp",
                "content": "### Brute Force\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        return minDistanceFrom(word1, word2, 0, 0);\\n    }\\n    private int minDistanceFrom(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length()) // Inserts all the remaining characters of s2\\n            return s2.length() - i2;\\n\\n        if (i2 == s2.length()) // Deletes all the remaining characters of s1\\n            return s1.length() - i1;\\n\\n        if (s1.charAt(i1) == s2.charAt(i2)) {\\n            return minDistanceFrom(s1, s2, i1 + 1, i2 + 1);\\n        } else {\\n            int dist1 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2); // Deletes s1[i1] from s1\\n            int dist2 = 1 + minDistanceFrom(s1, s2, i1, i2 + 1); // Inserts s2[i2] to s1\\n            int dist3 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2 + 1); // Replaces s1[i1] with s2[i2]\\n\\n            return Math.min(dist1, Math.min(dist2, dist3));\\n        }\\n    }\\n}\\n```\\n### Top-down DP\\nA two-dimensional array might be used to store results of all subproblems, in order to overcome overlapping subproblems.\\n```\\nclass Solution {\\n    private Integer[][] dp;\\n    public int minDistance(String word1, String word2) {\\n        dp = new Integer[word1.length() + 1][word2.length() + 1];\\n        return minDistanceFrom(word1, word2, 0, 0);\\n    }\\n    private int minDistanceFrom(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length()) // Inserts all the remaining characters of s2\\n            return s2.length() - i2;\\n\\n        if (i2 == s2.length()) // Deletes all the remaining characters of s1\\n            return s1.length() - i1;\\n        \\n        if (dp[i1][i2] != null)\\n            return dp[i1][i2];\\n        \\n        if (s1.charAt(i1) == s2.charAt(i2)) {\\n            return dp[i1][i2] = minDistanceFrom(s1, s2, i1 + 1, i2 + 1);\\n        } else {\\n            int dist1 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2); // Deletes s1[i1] from s1\\n            int dist2 = 1 + minDistanceFrom(s1, s2, i1, i2 + 1); // Inserts s2[i2] to s1\\n            int dist3 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2 + 1); // Replaces s1[i1] with s2[i2]\\n\\n            return dp[i1][i2] = Math.min(dist1, Math.min(dist2, dist3));\\n        }\\n    }\\n}\\n```\\n### Bottom-up DP\\n```\\n    public int minDistance(String s1, String s2) {\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n\\n        for (int i1 = 0; i1 <= s1.length(); i1++)\\n            dp[i1][0] = i1;\\n\\n        for (int i2 = 0; i2 <= s2.length(); i2++)\\n            dp[0][i2] = i2;\\n\\n        for (int i1 = 1; i1 <= s1.length(); i1++) {\\n            for (int i2 = 1; i2 <= s2.length(); i2++) {\\n                if (s1.charAt(i1 - 1) == s2.charAt(i2 - 1)) {\\n                    dp[i1][i2] = dp[i1 - 1][i2 - 1];\\n                } else {\\n                    int dist1 = 1 + dp[i1 - 1][i2]; // Deletes s1[i1] from s1\\n                    int dist2 = 1 + dp[i1][i2 - 1]; // Inserts s2[i2] to s1\\n                    int dist3 = 1 + dp[i1 - 1][i2 - 1]; // Replaces s1[i1] with s2[i2]\\n                    \\n                    dp[i1][i2] = Math.min(dist1, Math.min(dist2, dist3));\\n                }\\n            }\\n        }\\n\\n        return dp[s1.length()][s2.length()];\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        return minDistanceFrom(word1, word2, 0, 0);\\n    }\\n    private int minDistanceFrom(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length()) // Inserts all the remaining characters of s2\\n            return s2.length() - i2;\\n\\n        if (i2 == s2.length()) // Deletes all the remaining characters of s1\\n            return s1.length() - i1;\\n\\n        if (s1.charAt(i1) == s2.charAt(i2)) {\\n            return minDistanceFrom(s1, s2, i1 + 1, i2 + 1);\\n        } else {\\n            int dist1 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2); // Deletes s1[i1] from s1\\n            int dist2 = 1 + minDistanceFrom(s1, s2, i1, i2 + 1); // Inserts s2[i2] to s1\\n            int dist3 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2 + 1); // Replaces s1[i1] with s2[i2]\\n\\n            return Math.min(dist1, Math.min(dist2, dist3));\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Integer[][] dp;\\n    public int minDistance(String word1, String word2) {\\n        dp = new Integer[word1.length() + 1][word2.length() + 1];\\n        return minDistanceFrom(word1, word2, 0, 0);\\n    }\\n    private int minDistanceFrom(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length()) // Inserts all the remaining characters of s2\\n            return s2.length() - i2;\\n\\n        if (i2 == s2.length()) // Deletes all the remaining characters of s1\\n            return s1.length() - i1;\\n        \\n        if (dp[i1][i2] != null)\\n            return dp[i1][i2];\\n        \\n        if (s1.charAt(i1) == s2.charAt(i2)) {\\n            return dp[i1][i2] = minDistanceFrom(s1, s2, i1 + 1, i2 + 1);\\n        } else {\\n            int dist1 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2); // Deletes s1[i1] from s1\\n            int dist2 = 1 + minDistanceFrom(s1, s2, i1, i2 + 1); // Inserts s2[i2] to s1\\n            int dist3 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2 + 1); // Replaces s1[i1] with s2[i2]\\n\\n            return dp[i1][i2] = Math.min(dist1, Math.min(dist2, dist3));\\n        }\\n    }\\n}\\n```\n```\\n    public int minDistance(String s1, String s2) {\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n\\n        for (int i1 = 0; i1 <= s1.length(); i1++)\\n            dp[i1][0] = i1;\\n\\n        for (int i2 = 0; i2 <= s2.length(); i2++)\\n            dp[0][i2] = i2;\\n\\n        for (int i1 = 1; i1 <= s1.length(); i1++) {\\n            for (int i2 = 1; i2 <= s2.length(); i2++) {\\n                if (s1.charAt(i1 - 1) == s2.charAt(i2 - 1)) {\\n                    dp[i1][i2] = dp[i1 - 1][i2 - 1];\\n                } else {\\n                    int dist1 = 1 + dp[i1 - 1][i2]; // Deletes s1[i1] from s1\\n                    int dist2 = 1 + dp[i1][i2 - 1]; // Inserts s2[i2] to s1\\n                    int dist3 = 1 + dp[i1 - 1][i2 - 1]; // Replaces s1[i1] with s2[i2]\\n                    \\n                    dp[i1][i2] = Math.min(dist1, Math.min(dist2, dist3));\\n                }\\n            }\\n        }\\n\\n        return dp[s1.length()][s2.length()];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25902,
                "title": "c-recursive-dfs-8ms",
                "content": "Scan from the start while backtracking and exploring insert, delete and replace options, of course only when characters mismatch. As you can see below, memoization helps to short-circuit numerous paths.\\nMore details at [link](https://msreekan.com/2016/08/13/edit-distance/)\\n![alt text](https://tekrants.files.wordpress.com/2016/08/editdistance.jpg)\\n\\n```\\nvoid ml(char* w1, int o1, int l1, char* w2, int o2, int l2,\\n        unsigned char *dp)\\n{\\n    int offst = o1 * (l2 + 1) + o2, od = (o1 + 1) * (l2 + 1) + o2;\\n    int oi = o1 * (l2 + 1) + o2 + 1, r = 0;\\n\\n    if (o1 == l1 || o2 == l2) // end of string, return remaining bytes\\n        dp[offst] = (o1 == l1) ? l2 - o2 : l1 - o1;\\n\\n    /* If the minimum distance for strings at [o1..l1] & [o2..l2] is\\n       not already calculated, then figure out the same */\\n    else if (dp[offst] == MAX_CHAR)\\n    {\\n        if (w1[o1] != w2[o2]) // unequal characters\\n        {\\n            ml(w1, o1 + 1, l1, w2, o2, l2, dp); // delete\\n            ml(w1, o1, l1, w2, o2 + 1, l2, dp); // insert\\n            r++;\\n        }\\n\\n        ml(w1, o1 + 1, l1, w2, o2 + 1, l2, dp); // replace/chars equal\\n        dp[offst] = (r > 0) ? (MIN_INT(dp[od + 1] + r, dp[od] + r,\\n                    dp[oi] + r)) : dp[od + 1]; // pick minimum\\n    }\\n}\\n\\nint minDistance(char *word1, char * word2)\\n{\\n    int l1 = strlen(word1), l2 = strlen(word2), md = 0;\\n    unsigned char *dp = malloc((l1 + 1) * (l2 + 1) * sizeof(unsigned char));\\n\\n    /* Validate */\\n    if (!dp) return 0;\\n\\n    /* Initialize buffer */\\n    memset(dp, MAX_CHAR, (l1 + 1) * (l2 + 1));\\n\\n    /* Get the minimum distance */\\n    ml(word1, 0, l1, word2, 0, l2, dp);\\n    md = dp[0];\\n    free(dp);\\n    return md;\\n}\\n```\\n\\nEDIT : Just posted more details at the blog [link](https://msreekan.com/2016/08/13/edit-distance/)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid ml(char* w1, int o1, int l1, char* w2, int o2, int l2,\\n        unsigned char *dp)\\n{\\n    int offst = o1 * (l2 + 1) + o2, od = (o1 + 1) * (l2 + 1) + o2;\\n    int oi = o1 * (l2 + 1) + o2 + 1, r = 0;\\n\\n    if (o1 == l1 || o2 == l2) // end of string, return remaining bytes\\n        dp[offst] = (o1 == l1) ? l2 - o2 : l1 - o1;\\n\\n    /* If the minimum distance for strings at [o1..l1] & [o2..l2] is\\n       not already calculated, then figure out the same */\\n    else if (dp[offst] == MAX_CHAR)\\n    {\\n        if (w1[o1] != w2[o2]) // unequal characters\\n        {\\n            ml(w1, o1 + 1, l1, w2, o2, l2, dp); // delete\\n            ml(w1, o1, l1, w2, o2 + 1, l2, dp); // insert\\n            r++;\\n        }\\n\\n        ml(w1, o1 + 1, l1, w2, o2 + 1, l2, dp); // replace/chars equal\\n        dp[offst] = (r > 0) ? (MIN_INT(dp[od + 1] + r, dp[od] + r,\\n                    dp[oi] + r)) : dp[od + 1]; // pick minimum\\n    }\\n}\\n\\nint minDistance(char *word1, char * word2)\\n{\\n    int l1 = strlen(word1), l2 = strlen(word2), md = 0;\\n    unsigned char *dp = malloc((l1 + 1) * (l2 + 1) * sizeof(unsigned char));\\n\\n    /* Validate */\\n    if (!dp) return 0;\\n\\n    /* Initialize buffer */\\n    memset(dp, MAX_CHAR, (l1 + 1) * (l2 + 1));\\n\\n    /* Get the minimum distance */\\n    ml(word1, 0, l1, word2, 0, l2, dp);\\n    md = dp[0];\\n    free(dp);\\n    return md;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3527933,
                "title": "dynamic-programming-logic-bottom-to-up",
                "content": "# Dynamic programming:\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        dp=[[0]*(len(t)+1) for i in range(len(s)+1)]\\n        for k in range(len(s)+1):\\n            dp[k][len(t)]=len(s)-k\\n        for k in range(len(t)+1):\\n            dp[len(s)][k]=len(t)-k\\n        for i in range(len(s)-1,-1,-1):\\n            for j in range(len(t)-1,-1,-1):\\n                if s[i]==t[j]:\\n                    dp[i][j]=dp[i+1][j+1]\\n                else:\\n                    dp[i][j]=1+min(dp[i+1][j+1],dp[i+1][j],dp[i][j+1])\\n        return dp[0][0]        \\t\\t\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        dp=[[0]*(len(t)+1) for i in range(len(s)+1)]\\n        for k in range(len(s)+1):\\n            dp[k][len(t)]=len(s)-k\\n        for k in range(len(t)+1):\\n            dp[len(s)][k]=len(t)-k\\n        for i in range(len(s)-1,-1,-1):\\n            for j in range(len(t)-1,-1,-1):\\n                if s[i]==t[j]:\\n                    dp[i][j]=dp[i+1][j+1]\\n                else:\\n                    dp[i][j]=1+min(dp[i+1][j+1],dp[i+1][j],dp[i][j+1])\\n        return dp[0][0]        \\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232410,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size(); \\n        vector<vector<int>> dp(n1, vector<int>(n2, -1));\\n        return helper(n1-1, n2-1, word1, word2, dp);\\n    }\\n\\n    int helper(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        if(i < 0){\\n            return j+1;\\n        }\\n        if(j < 0){\\n            return i+1;\\n        }\\n        if(s1[i] ==  s2[j]){\\n            return dp[i][j] = helper(i-1, j-1, s1, s2, dp);\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int min1 = helper(i-1, j, s1, s2, dp);\\n        int min2 = helper(i, j-1, s1, s2, dp);\\n        int min3 = helper(i-1, j-1, s1, s2, dp);\\n        return dp[i][j] = 1 + min(min(min1, min2), min3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size(); \\n        vector<vector<int>> dp(n1, vector<int>(n2, -1));\\n        return helper(n1-1, n2-1, word1, word2, dp);\\n    }\\n\\n    int helper(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        if(i < 0){\\n            return j+1;\\n        }\\n        if(j < 0){\\n            return i+1;\\n        }\\n        if(s1[i] ==  s2[j]){\\n            return dp[i][j] = helper(i-1, j-1, s1, s2, dp);\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int min1 = helper(i-1, j, s1, s2, dp);\\n        int min2 = helper(i, j-1, s1, s2, dp);\\n        int min3 = helper(i-1, j-1, s1, s2, dp);\\n        return dp[i][j] = 1 + min(min(min1, min2), min3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231996,
                "title": "c-bottom-top-dp-o-n-space",
                "content": "\\n# Code with O(nm) space\\n```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        var m = word1.Length;\\n        var n = word2.Length;\\n        var dp = new int[m+1, n+1];\\n\\n        for(var i = 0; i <= m; i++)\\n        {\\n            dp[i, 0] = i;\\n        }\\n\\n        for(var j = 0; j <= n; j++)\\n        {\\n            dp[0, j] = j;    \\n        }\\n\\n        for(var i = 0; i < m; i++)\\n        {\\n            for(var j = 0; j < n; j++)\\n            {\\n                if(word1[i] == word2[j])\\n                {\\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\\n                }\\n                else\\n                {\\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\\n                }\\n            }\\n        }\\n\\n        return dp[m, n];\\n\\n        int Min(params int[] arr)\\n        {\\n            return arr.Min();\\n        }\\n    }\\n}\\n```\\n\\n# Optimized Code with O(n) space\\n```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        var m = word1.Length;\\n        var n = word2.Length;\\n        // var dp = new int[m+1, n+1];\\n        var prevRow = new int[n+1];\\n\\n        // for(var i = 0; i <= m; i++)\\n        // {\\n        //     dp[i, 0] = i;\\n        // }\\n\\n        for(var j = 0; j <= n; j++)\\n        {\\n            // dp[0, j] = j;    \\n            prevRow[j] = j;\\n        }\\n\\n        for(var i = 0; i < m; i++)\\n        {\\n            var curRow = new int[n+1];\\n            curRow[0] = i + 1;\\n\\n            for(var j = 0; j < n; j++)\\n            {\\n                if(word1[i] == word2[j])\\n                {\\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1] + 1, curRow[j] + 1);\\n                }\\n                else\\n                {\\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1], curRow[j]) + 1;\\n                }\\n            }\\n            prevRow = curRow;\\n        }\\n\\n        // return dp[m, n];\\n        return prevRow[n];\\n\\n        int Min(params int[] arr)\\n        {\\n            return arr.Min();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        var m = word1.Length;\\n        var n = word2.Length;\\n        var dp = new int[m+1, n+1];\\n\\n        for(var i = 0; i <= m; i++)\\n        {\\n            dp[i, 0] = i;\\n        }\\n\\n        for(var j = 0; j <= n; j++)\\n        {\\n            dp[0, j] = j;    \\n        }\\n\\n        for(var i = 0; i < m; i++)\\n        {\\n            for(var j = 0; j < n; j++)\\n            {\\n                if(word1[i] == word2[j])\\n                {\\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\\n                }\\n                else\\n                {\\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\\n                }\\n            }\\n        }\\n\\n        return dp[m, n];\\n\\n        int Min(params int[] arr)\\n        {\\n            return arr.Min();\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        var m = word1.Length;\\n        var n = word2.Length;\\n        // var dp = new int[m+1, n+1];\\n        var prevRow = new int[n+1];\\n\\n        // for(var i = 0; i <= m; i++)\\n        // {\\n        //     dp[i, 0] = i;\\n        // }\\n\\n        for(var j = 0; j <= n; j++)\\n        {\\n            // dp[0, j] = j;    \\n            prevRow[j] = j;\\n        }\\n\\n        for(var i = 0; i < m; i++)\\n        {\\n            var curRow = new int[n+1];\\n            curRow[0] = i + 1;\\n\\n            for(var j = 0; j < n; j++)\\n            {\\n                if(word1[i] == word2[j])\\n                {\\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1] + 1, curRow[j] + 1);\\n                }\\n                else\\n                {\\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1], curRow[j]) + 1;\\n                }\\n            }\\n            prevRow = curRow;\\n        }\\n\\n        // return dp[m, n];\\n        return prevRow[n];\\n\\n        int Min(params int[] arr)\\n        {\\n            return arr.Min();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231533,
                "title": "golang-dynamic-programming-with-explanation",
                "content": "# Intuition\\nWe will have to draw a table to help understand how DP works in this solution:\\n\\n||empty str|r|o|s|\\n|:-:|:-:|:-:|:-:|:-:|\\n|empty str|0|1|2|3|\\n|h|1|1|2|3|\\n|o|2|2|1|2|\\n|r|3|2|2|2|\\n|s|4|3|3|2|\\n|e|5|4|4|**3**|\\n\\nIn this table, the number in the cells stands for **the minimum operation times** needed to transform from `word1` to `word2`. Note we only care about the first `n` chars when we fill the `nth` row or cols!\\n\\nFor example, we only care about `hor` when we are dealing with `row \\'r\\'`.\\n\\nMore specifically:\\n1. In `row \\'h\\'`, `col \\'r\\'`, we only care about how to transform from \\'h\\' to \\'r\\'.\\n2. In `row \\'o\\'`, `col \\'r\\'`, we only care about how to transform from \\'ho\\' to \\'r\\'.\\n3.  In `row \\'r\\'`, `col \\'o\\'`, we only care about how to transform from \\'hor\\' to \\'ro\\'.\\n4. ... I believe you get the point! \\uD83D\\uDE0A\\n\\nWhat we will do is to find a way to quickly fill the table! The number in the bottom-right of the table will be our answer.\\n\\nWhen you mannually fill this table, I believe you can find some certain rules:\\n+ the number in the first col (i.e. `col \\'empty str\\'`) always equals to the **row index**. This is because we need to remove every char in `word2` to get a empty `word1`!\\n+ If the last char of `word2` is identical to the last char of `word1`, the operation number should be the same as `table[i-1][j-1]` (just imagine we are dealing with `table[i][j]`)! This is because **if the last char of the two words are the same, we need no more extra operation**!\\n+ If the last char of `word2` is different from the last char of `word1`, we will have to look at these 3 cells: `table[i][j - 1]`, `table[i - 1][j - 1]` and `table[i - 1][j]`. We will fill `table[i][j]` with the minimum number plus 1. This is because **we have to deal with this char difference (plus 1), and we will choose the optimal way to conduct the former transformation**!\\n\\n# Code\\n```\\nfunc minDistance(word1 string, word2 string) int {\\n    pre := make([]int, len(word2) + 1)\\n    cur := make([]int, len(word2) + 1)\\n    for i := 0; i < len(pre); i++ {\\n        pre[i] = i\\n    }\\n    for i := 1; i <= len(word1); i++ {\\n        cur[0] = i\\n        for j := 1; j < len(pre); j++ {\\n            if word1[i - 1] != word2[j - 1] {\\n                cur[j] = min(cur[j - 1], pre[j - 1], pre[j]) + 1\\n            } else {\\n                cur[j] = pre[j - 1]\\n            }\\n        }\\n        tmp := make([]int, len(cur))\\n        copy(tmp, cur)\\n        pre = tmp\\n    }\\n    return pre[len(word2)]\\n}\\n\\nfunc min(nums ...int) int {\\n    ans := nums[0]\\n    for _, v := range nums {\\n        if v < ans {\\n            ans = v\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc minDistance(word1 string, word2 string) int {\\n    pre := make([]int, len(word2) + 1)\\n    cur := make([]int, len(word2) + 1)\\n    for i := 0; i < len(pre); i++ {\\n        pre[i] = i\\n    }\\n    for i := 1; i <= len(word1); i++ {\\n        cur[0] = i\\n        for j := 1; j < len(pre); j++ {\\n            if word1[i - 1] != word2[j - 1] {\\n                cur[j] = min(cur[j - 1], pre[j - 1], pre[j]) + 1\\n            } else {\\n                cur[j] = pre[j - 1]\\n            }\\n        }\\n        tmp := make([]int, len(cur))\\n        copy(tmp, cur)\\n        pre = tmp\\n    }\\n    return pre[len(word2)]\\n}\\n\\nfunc min(nums ...int) int {\\n    ans := nums[0]\\n    for _, v := range nums {\\n        if v < ans {\\n            ans = v\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3230623,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//Memoisation\\nclass Solution {\\npublic:\\n    int fun(int i,int j,string& word1,string& word2,vector<vector<int>> &dp)\\n    {\\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=fun(i-1,j-1,word1,word2,dp);\\n        }\\n        int ins=1+fun(i,j-1,word1,word2,dp);\\n        int del=1+fun(i-1,j,word1,word2,dp);\\n        int rep=1+fun(i-1,j-1,word1,word2,dp);\\n        return dp[i][j]=min(ins,min(del,rep));\\n    }\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return fun(m-1,n-1,word1,word2,dp);\\n    }\\n};\\n```\\n```\\n//Tabulation\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(int j=0;j<=n;j++){\\n            dp[0][j]=j;\\n        }\\n        for(int i=0;i<=m;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++){\\n                if(word1[i-1]==word2[j-1]){\\n                    dp[i][j]=dp[i-1][j-1];\\n                    continue;\\n                }\\n                int ins=1+dp[i][j-1];\\n                int del=1+dp[i-1][j];\\n                int rep=1+dp[i-1][j-1];\\n                dp[i][j]=min(ins,min(del,rep));        \\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//Memoisation\\nclass Solution {\\npublic:\\n    int fun(int i,int j,string& word1,string& word2,vector<vector<int>> &dp)\\n    {\\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=fun(i-1,j-1,word1,word2,dp);\\n        }\\n        int ins=1+fun(i,j-1,word1,word2,dp);\\n        int del=1+fun(i-1,j,word1,word2,dp);\\n        int rep=1+fun(i-1,j-1,word1,word2,dp);\\n        return dp[i][j]=min(ins,min(del,rep));\\n    }\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return fun(m-1,n-1,word1,word2,dp);\\n    }\\n};\\n```\n```\\n//Tabulation\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(int j=0;j<=n;j++){\\n            dp[0][j]=j;\\n        }\\n        for(int i=0;i<=m;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++){\\n                if(word1[i-1]==word2[j-1]){\\n                    dp[i][j]=dp[i-1][j-1];\\n                    continue;\\n                }\\n                int ins=1+dp[i][j-1];\\n                int del=1+dp[i-1][j];\\n                int rep=1+dp[i-1][j-1];\\n                dp[i][j]=min(ins,min(del,rep));        \\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063353,
                "title": "optimized-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each index in string S1, there are three options for matching that index with string S2. Replace a character, delete a character, or insert a character at its index. So you can think in terms of string match paths. With no consistent data, there\\'s no way to find out other than trying all possible methods. To do this, you have to use recursion.\\n\\n**Step 1: Index the problem**:\\n\\n>  We need two indices for iterating over both the strings.\\n\\n\\n**Step 2: Try all possible options given the index.**\\n\\n> We have the cases of MATCH and MISMATCH\\n\\n1. MATCH: If the i and the j characters of word1 and word2 match, then we must reduce both the indices and calculate the solution for f(i-1,j-1)\\n2. MISMATCH : If the i and the j characters of word1 and word2 mismatch, then we  have three possiblities: \\n      - **Insert**: We insert word2[j] in word1 at position i and thus call the function f(i, j-1).\\n      - **Delete**: We delete the word1[i] character and thus call the function f(i-1,j).\\n      - **Replace**: We simply replace the word1[i] with word2[j], thus we should call f(i-1,j-1).\\n\\n**Step 3: Return the minimum value of all choices.**\\n1. MATCH: return f(i-1,j-1)\\n2. MISMATCH: return 1 + min({f(i-1,j), f(i,j-1), f(i-1,j-1)})\\n\\n#### BASE CASES\\n\\n1. if i<0 then return j;\\n2. if j<0 then return i;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can memoize the above recursive formula, but we will use Tabulation to avoid extra recursive stack space and Recursion Overhead.\\n\\n> In order to implement the Tabulation, we need to take care of the negative indices. Thus we shift ourselves to 1-based indexing.\\n\\nPROCEDURE:\\n\\n1. We initialise a 2D vector with the first col filled with the row numbers and the first row filled with row numbers.\\n2. Fill the matrix using the recursive formulation.\\n3. Return dp[n][m] as the answer.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &word1, string &word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n        for(int row = 1;row<=n;row++)\\n            dp[row][0] = row;\\n        for(int col = 1;col<=m;col++)\\n            dp[0][col] = col;\\n        for(int i = 1;i<=n;i++){\\n            for(int j = 1;j<=m;j++){\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + min({dp[i-1][j], dp[i-1][j-1], dp[i][j-1]});\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string &word1, string &word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n        for(int row = 1;row<=n;row++)\\n            dp[row][0] = row;\\n        for(int col = 1;col<=m;col++)\\n            dp[0][col] = col;\\n        for(int i = 1;i<=n;i++){\\n            for(int j = 1;j<=m;j++){\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + min({dp[i-1][j], dp[i-1][j-1], dp[i][j-1]});\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818044,
                "title": "java-dp-tabulation",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n\\n        int[][] dp = new int[m + 1][n + 1];\\n        int ans;\\n\\n        for(int i = 0; i <= m; i++){\\n            dp[i][0] = i;\\n        }\\n        for(int i = 0; i <= n; i++){\\n            dp[0][i] = i;\\n        }\\n\\n        for(int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                ans = dp[i - 1][j - 1];\\n\\n                if(word1.charAt(m - i) != word2.charAt(n - j)){\\n                    ans = 1 + Math.min(ans, Math.min(dp[i][j - 1], dp[i - 1][j]));\\n                }\\n\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n\\n        int[][] dp = new int[m + 1][n + 1];\\n        int ans;\\n\\n        for(int i = 0; i <= m; i++){\\n            dp[i][0] = i;\\n        }\\n        for(int i = 0; i <= n; i++){\\n            dp[0][i] = i;\\n        }\\n\\n        for(int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                ans = dp[i - 1][j - 1];\\n\\n                if(word1.charAt(m - i) != word2.charAt(n - j)){\\n                    ans = 1 + Math.min(ans, Math.min(dp[i][j - 1], dp[i - 1][j]));\\n                }\\n\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579271,
                "title": "c-most-detailed-from-recursive-to-space-optmisation",
                "content": "## Approach:\\n\\n--> Here we can follow string matching method where we will match every character using 2 variables `i and j where i will traverse s1 and j will traverse s2` and then we will have 2 conditions:\\n\\n1. If they are matching:\\n\\t- then we will simply decrease both i and j \\n\\t- we are not applying any step here\\n2. If they are not matching:\\n\\t- Then we have 3 possibilities here:\\n\\t\\t- Insert s[j] character at that place\\n\\t\\t- Delete this character and decrease i\\n\\t\\t- Replace ith character with s[j]\\n\\t\\t- we are applying any one of the step here so we will add 1 to total steps.\\n\\t\\t\\n--> Let\\'s see all these conditions in bit detail:\\n\\n### If they are not matching:\\n\\n**1. If we insert s[j] character at that place:**\\n\\nTake a look at this example:\\n\\n![image](https://assets.leetcode.com/users/images/92c6e07c-3694-4fa5-8efc-5bbb83e3243c_1663240869.4235468.png)\\n\\nHere we will just decrease `j` because we have added jth character so they are matched.\\n```cpp\\n1 + solve(i,j-1);\\n```\\n\\n**2. If we delete the ith character:**\\n\\nThen we will simply decrease `i`.\\n```cpp\\n1 + solve(i-1,j);\\n```\\n\\n**3. If we replace the ith character:**\\n\\nHere we will ofcourse replace the ith character with s[j] and then they both will match and we will decrease both `i and j`.\\n```cpp\\n1 + solve(i-1,j-1);\\n```\\n\\nAt last take the `minimum` of these 3 steps:\\n\\n### If they are matching:\\n\\njust decrease both i and j but don\\'t add 1 in steps because we haven\\'t performed any step here.\\n\\n```cpp\\nsolve(i-1,j-1);\\n```\\n\\n## Base case:\\n\\nHere we will have 2 conditions:\\n\\n1. If we have traversed all s1 string means i is negative and j is still have some value.\\n\\t- For example we have to make `ros` from `horse` and we have traversed whole horse string and j is at character `o` then we will have to make `ro` from empty string, so here we will perform `2 insert operations`.\\n\\t- so if i becomes negative then we will return `j+1`.\\n2. If we have traversed all s2 string means j is negative and i is still have some value.\\n\\t- For example in `ros and horse` we have traversed whole `ros` and i is at `r` character so that means we have to make empty string from `hor` so we will have to perform `3 deletion operation to make it empty string`. \\n\\t- So if j becomes negative then we will return `i+1`.\\n\\n```cpp\\nif(i < 0){\\n\\treturn j+1;\\n}\\nif(j < 0){\\n\\treturn i+1;\\n}\\n```\\n\\n## Recursive code:\\n\\n```cpp\\nint solve(int i,int j,string &s1,string &s2){\\n\\tif(i < 0){\\n\\t\\treturn j+1;\\n\\t}\\n\\tif(j < 0){\\n\\t\\treturn i+1;\\n\\t}\\n\\tif(s1[i] == s2[j]){\\n\\t\\treturn solve(i-1,j-1,s1,s2);\\n\\t}\\n\\telse{\\n\\t\\treturn 1 + min(min(solve(i,j-1,s1,s2),solve(i-1,j,s1,s2)), solve(i-1,j-1,s1,s2));\\n\\t}\\n}\\n```\\n\\n## Memoization Code:\\n\\n```cpp\\nint solve(int i,int j,string &s1,string &s2,vector<vector<int>>&dp){\\n\\tif(i < 0){\\n\\t\\treturn j+1;\\n\\t}\\n\\tif(j < 0){\\n\\t\\treturn i+1;\\n\\t}\\n\\tif(dp[i][j] != -1){\\n\\t\\treturn dp[i][j];\\n\\t}\\n\\tif(s1[i] == s2[j]){\\n\\t\\treturn dp[i][j] = solve(i-1,j-1,s1,s2,dp);\\n\\t}\\n\\telse{\\n\\t\\treturn dp[i][j] =  1 + min(min(solve(i,j-1,s1,s2,dp),solve(i-1,j,s1,s2,dp)), solve(i-1,j-1,s1,s2,dp));\\n\\t}\\n}\\nint main(){\\n\\t// n is size of s1 and m is size of s2\\n\\tvector<vector<int>>dp(n,vector<int>(m,-1));\\n\\treturn solve(n-1,m-1,s1,s2,dp);\\n}\\n```\\n\\n```\\nTime complexity: O(NxM)\\nSpace complexity: O(NxM) + stack space of O(N+M)\\n```\\n\\n## Tabulation Code:\\n\\n--> Let\\'s use tabulation to remove the stack space.\\n\\nSo in tabulation we just have to do one smaller change which will be `we will use 1 based indexing here` because in base case we are checking if i or j becomes negative but it\\'s not possible here so that\\'s why we will use 1 based indexing and our dp array size will be `N+1xM+1`\\n\\nAlso during checking the characters we will have to check like this:\\n```cpp\\nif(s1[i-1] == s2[j-1]);\\n```\\n\\nAlso in base case if `i` is 0 then we will add `j` for it instead of j+1 because we are following 1 based indexing and same for j also.\\n\\n```cpp\\nint minDistance(string s1, string s2) {\\n        int n = s1.size(),m = s2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        // if j is 0\\n        for(int i=0;i<=n;i++){\\n            dp[i][0] = i;\\n        }\\n        // if i is 0\\n\\t\\t// starting from 1 because we have already considered dp[0][0] in above loop\\n        for(int j=1;j<=m;j++){\\n            dp[0][j] = j;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1] == s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = 1 + min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\\n\\n## Space optimisation:\\n\\n--> Here we can see that we are only required previous row(dp[i-1]) and current row (dp[i]) to find answer for current row.\\n\\nSo we will make 2 separate arrays `prev and curr` which will act as rows and after each inner iteration, we will swap them.\\n\\nNow here we can see for every `i=0` we have to put `0,1,2,3..` as j so we will initialise prev as `0,1,2,3...` and also for every `j=0` we have to put `0,1,2,3...` i.e every row\\'s first element will be current index so after each inner iteration we will do `curr[0] = i`.\\n\\nSo let\\'s optimise the space complexity:\\n\\n```cpp\\nint minDistance(string s1, string s2) {\\n\\tint n = s1.size(),m = s2.size();\\n\\tvector<int>prev(m+1,0),curr(m+1,0);\\n\\tfor(int j=1;j<=m;j++){\\n\\t\\tprev[j] = j;\\n\\t}\\n\\tfor(int i=1;i<=n;i++){\\n\\t// Initialising first element after each iteration\\n\\t\\tcurr[0] = i;\\n\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\tif(s1[i-1] == s2[j-1]){\\n\\t\\t\\t\\tcurr[j] = prev[j-1];\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tcurr[j] = 1 + min(min(curr[j-1],prev[j]),prev[j-1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// swapping prev and curr\\n\\t\\tprev = curr;\\n\\t}\\n\\treturn prev[m];\\n}\\n```\\n\\n```\\nTime complexity: O(NxM)\\nSpace complexity: O(M)\\n```\\n\\n----\\n\\nIf you want to see more solutions like this find it [here](https://github.com/shivam1317/DSA-Notes)\\nThanks for reading.\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n1 + solve(i,j-1);\\n```\n```cpp\\n1 + solve(i-1,j);\\n```\n```cpp\\n1 + solve(i-1,j-1);\\n```\n```cpp\\nsolve(i-1,j-1);\\n```\n```cpp\\nif(i < 0){\\n\\treturn j+1;\\n}\\nif(j < 0){\\n\\treturn i+1;\\n}\\n```\n```cpp\\nint solve(int i,int j,string &s1,string &s2){\\n\\tif(i < 0){\\n\\t\\treturn j+1;\\n\\t}\\n\\tif(j < 0){\\n\\t\\treturn i+1;\\n\\t}\\n\\tif(s1[i] == s2[j]){\\n\\t\\treturn solve(i-1,j-1,s1,s2);\\n\\t}\\n\\telse{\\n\\t\\treturn 1 + min(min(solve(i,j-1,s1,s2),solve(i-1,j,s1,s2)), solve(i-1,j-1,s1,s2));\\n\\t}\\n}\\n```\n```cpp\\nint solve(int i,int j,string &s1,string &s2,vector<vector<int>>&dp){\\n\\tif(i < 0){\\n\\t\\treturn j+1;\\n\\t}\\n\\tif(j < 0){\\n\\t\\treturn i+1;\\n\\t}\\n\\tif(dp[i][j] != -1){\\n\\t\\treturn dp[i][j];\\n\\t}\\n\\tif(s1[i] == s2[j]){\\n\\t\\treturn dp[i][j] = solve(i-1,j-1,s1,s2,dp);\\n\\t}\\n\\telse{\\n\\t\\treturn dp[i][j] =  1 + min(min(solve(i,j-1,s1,s2,dp),solve(i-1,j,s1,s2,dp)), solve(i-1,j-1,s1,s2,dp));\\n\\t}\\n}\\nint main(){\\n\\t// n is size of s1 and m is size of s2\\n\\tvector<vector<int>>dp(n,vector<int>(m,-1));\\n\\treturn solve(n-1,m-1,s1,s2,dp);\\n}\\n```\n```\\nTime complexity: O(NxM)\\nSpace complexity: O(NxM) + stack space of O(N+M)\\n```\n```cpp\\nif(s1[i-1] == s2[j-1]);\\n```\n```cpp\\nint minDistance(string s1, string s2) {\\n        int n = s1.size(),m = s2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        // if j is 0\\n        for(int i=0;i<=n;i++){\\n            dp[i][0] = i;\\n        }\\n        // if i is 0\\n\\t\\t// starting from 1 because we have already considered dp[0][0] in above loop\\n        for(int j=1;j<=m;j++){\\n            dp[0][j] = j;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1] == s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = 1 + min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\n```cpp\\nint minDistance(string s1, string s2) {\\n\\tint n = s1.size(),m = s2.size();\\n\\tvector<int>prev(m+1,0),curr(m+1,0);\\n\\tfor(int j=1;j<=m;j++){\\n\\t\\tprev[j] = j;\\n\\t}\\n\\tfor(int i=1;i<=n;i++){\\n\\t// Initialising first element after each iteration\\n\\t\\tcurr[0] = i;\\n\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\tif(s1[i-1] == s2[j-1]){\\n\\t\\t\\t\\tcurr[j] = prev[j-1];\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tcurr[j] = 1 + min(min(curr[j-1],prev[j]),prev[j-1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// swapping prev and curr\\n\\t\\tprev = curr;\\n\\t}\\n\\treturn prev[m];\\n}\\n```\n```\\nTime complexity: O(NxM)\\nSpace complexity: O(M)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2268259,
                "title": "java-solution-memoization-tabulation-dp",
                "content": "Both Memoization And Tabulation solutions are given below, you can choose any.\\nIf you like the approach, then UPVOTE :) please\\n\\nMemoization Solution:\\ndist(s1 , s2 , i , j-1 , dp) => It implies insertion at end (I have not said replacing) hypothetically\\ndist(s1 , s2 , i-1 , j , dp) => It implies deletion\\ndist(s1 , s2 , i-1 , j-1 , dp) => It implies replacing\\n```\\nclass Solution {\\n    public int minDistance(String w1, String w2) {\\n        int l1 = w1.length();\\n        int l2 = w2.length();\\n        \\n        int[][] dp = new int[l1][l2];\\n        for(int i = 0 ; i < l1 ; i++)\\n            for(int j = 0 ; j < l2 ; j++)\\n                dp[i][j] = -1;\\n        return dist(w1 , w2 , l1-1, l2-1 , dp);    \\n    }\\n    \\n    public int dist(String s1, String s2 , int i , int j , int[][] dp){\\n        if(i < 0)   return j+1;\\n        if(j < 0) return i+1;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(s1.charAt(i) == s2.charAt(j))    return dp[i][j] = dist(s1 , s2 , i-1 , j-1 , dp);\\n        \\n        return dp[i][j] = 1+Math.min(dist(s1 , s2 , i , j-1 , dp) , Math.min(dist(s1 , s2 , i-1 , j , dp) , dist(s1 , s2 , i-1 , j-1 , dp)));\\n    }\\n}\\n```\\n\\nTabulation Solution:\\n```\\nclass Solution {\\n    public int minDistance(String w1, String w2) {\\n        int l1 = w1.length();\\n        int l2 = w2.length();\\n        \\n        int[][] dp = new int[l1+1][l2+1];\\n        for(int i = 0 ; i <= l1 ; i++)\\n            dp[i][0] = i;\\n        \\n        for(int j = 0 ; j <= l2 ; j++)\\n            dp[0][j] = j;\\n        \\n        for(int i = 1 ; i <= l1 ; i++)\\n            for(int j = 1 ; j <= l2 ; j++){\\n                if(w1.charAt(i-1) == w2.charAt(j-1))   dp[i][j] = dp[i-1][j-1];\\n        \\n                else    dp[i][j] = 1 + Math.min(dp[i][j-1] , Math.min(dp[i-1][j] , dp[i-1][j-1]));\\n            }\\n        \\n        return dp[l1][l2];\\n    }\\n} \\n```\\nHaven\\'t UPVOTED yet, can do it now :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String w1, String w2) {\\n        int l1 = w1.length();\\n        int l2 = w2.length();\\n        \\n        int[][] dp = new int[l1][l2];\\n        for(int i = 0 ; i < l1 ; i++)\\n            for(int j = 0 ; j < l2 ; j++)\\n                dp[i][j] = -1;\\n        return dist(w1 , w2 , l1-1, l2-1 , dp);    \\n    }\\n    \\n    public int dist(String s1, String s2 , int i , int j , int[][] dp){\\n        if(i < 0)   return j+1;\\n        if(j < 0) return i+1;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(s1.charAt(i) == s2.charAt(j))    return dp[i][j] = dist(s1 , s2 , i-1 , j-1 , dp);\\n        \\n        return dp[i][j] = 1+Math.min(dist(s1 , s2 , i , j-1 , dp) , Math.min(dist(s1 , s2 , i-1 , j , dp) , dist(s1 , s2 , i-1 , j-1 , dp)));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minDistance(String w1, String w2) {\\n        int l1 = w1.length();\\n        int l2 = w2.length();\\n        \\n        int[][] dp = new int[l1+1][l2+1];\\n        for(int i = 0 ; i <= l1 ; i++)\\n            dp[i][0] = i;\\n        \\n        for(int j = 0 ; j <= l2 ; j++)\\n            dp[0][j] = j;\\n        \\n        for(int i = 1 ; i <= l1 ; i++)\\n            for(int j = 1 ; j <= l2 ; j++){\\n                if(w1.charAt(i-1) == w2.charAt(j-1))   dp[i][j] = dp[i-1][j-1];\\n        \\n                else    dp[i][j] = 1 + Math.min(dp[i][j-1] , Math.min(dp[i-1][j] , dp[i-1][j-1]));\\n            }\\n        \\n        return dp[l1][l2];\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180656,
                "title": "python3-solution-using-dp-top-down-approach",
                "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        dp = {}\\n        \\n        def getResult(i,j):\\n            if i == len(word1) and j == len(word2):\\n                return 0\\n            if i == len(word1):\\n                return len(word2) - j\\n            if j == len(word2):\\n                return len(word1) - i\\n\\n            if (i, j) not in dp:\\n                if word1[i] == word2[j]:\\n                    ans = getResult(i + 1, j + 1)\\n                else: \\n                    insert = 1 + getResult(i, j + 1)\\n                    delete = 1 + getResult(i + 1, j)\\n                    replace = 1 + getResult(i + 1, j + 1)\\n                    ans = min(insert, delete, replace)\\n                dp[(i, j)] = ans\\n            return dp[(i, j)]\\n        \\n        return getResult(0,0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        dp = {}\\n        \\n        def getResult(i,j):\\n            if i == len(word1) and j == len(word2):\\n                return 0\\n            if i == len(word1):\\n                return len(word2) - j\\n            if j == len(word2):\\n                return len(word1) - i\\n\\n            if (i, j) not in dp:\\n                if word1[i] == word2[j]:\\n                    ans = getResult(i + 1, j + 1)\\n                else: \\n                    insert = 1 + getResult(i, j + 1)\\n                    delete = 1 + getResult(i + 1, j)\\n                    replace = 1 + getResult(i + 1, j + 1)\\n                    ans = min(insert, delete, replace)\\n                dp[(i, j)] = ans\\n            return dp[(i, j)]\\n        \\n        return getResult(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204823,
                "title": "c-three-solutions-recursion-top-down-bottom-up-dp",
                "content": "**Recursive Solution\\nTime Complexity - O (3 ^ max(a, b))\\nSpace Complexity - O (1)**\\n\\n```\\nint minDist(string a, string b, int i, int j) {\\n        if (i == -1) {\\n            return j + 1;\\n        }\\n        if (j == -1) {\\n            return i + 1;\\n        }\\n        if (a[i] == b[j]) {\\n            return minDist(a, b, i - 1, j - 1);\\n        }\\n        else {\\n            int add = minDist(a, b, i, j - 1);\\n            int replace = minDist(a, b, i - 1, j - 1);\\n            int remove = minDist(a, b, i - 1, j);\\n            \\n            return 1 + min(min(add, replace), remove);\\n        }\\n    }\\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Top Down DP Solution**\\n\\n```\\nint minDist(string a, string b, int i, int j, vector <vector <int>> dp) {\\n        if (i == -1) {\\n            return j + 1;\\n        }\\n        if (j == -1) {\\n            return i + 1;\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        if (a[i] == b[j]) {\\n            dp[i][j] =  minDist(a, b, i - 1, j - 1, dp);\\n            return dp[i][j];\\n        }\\n        else {\\n            int add = minDist(a, b, i, j - 1, dp);\\n            int replace = minDist(a, b, i - 1, j - 1, dp);\\n            int remove = minDist(a, b, i - 1, j, dp);\\n            \\n            dp[i][j] =  1 + min(min(add, replace), remove);\\n            return dp[i][j];\\n        }\\n    }\\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Bottom Up DP Solution\\nTime Complexity - O (a * b)\\nSpace Complexity - O (a * b)**\\n\\n```\\nint minDist(string a, string b) {\\n        vector <vector <int>> dp(a.length() + 1, vector <int>(b.length() + 1, -1));\\n        \\n        for (int i = 0; i < a.length() + 1; i++) {\\n            for (int j = 0; j < b.length() + 1; j++) {\\n                if (i == 0) {\\n                    dp[i][j] = j;\\n                }\\n                else if (j == 0) {\\n                    dp[i][j] = i;\\n                }\\n                else {\\n                    if (a[i - 1] == b[j - 1]) {\\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    }\\n                    else {\\n                        int add = dp[i][j - 1];\\n                        int replace = dp[i- 1][j - 1];\\n                        int remove = dp[i - 1][j];\\n                        \\n                        dp[i][j] = 1 + min(min(add, replace), remove);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[a.length()][b.length()];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint minDist(string a, string b, int i, int j) {\\n        if (i == -1) {\\n            return j + 1;\\n        }\\n        if (j == -1) {\\n            return i + 1;\\n        }\\n        if (a[i] == b[j]) {\\n            return minDist(a, b, i - 1, j - 1);\\n        }\\n        else {\\n            int add = minDist(a, b, i, j - 1);\\n            int replace = minDist(a, b, i - 1, j - 1);\\n            int remove = minDist(a, b, i - 1, j);\\n            \\n            return 1 + min(min(add, replace), remove);\\n        }\\n    }\\n```\n```\\nint minDist(string a, string b, int i, int j, vector <vector <int>> dp) {\\n        if (i == -1) {\\n            return j + 1;\\n        }\\n        if (j == -1) {\\n            return i + 1;\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        if (a[i] == b[j]) {\\n            dp[i][j] =  minDist(a, b, i - 1, j - 1, dp);\\n            return dp[i][j];\\n        }\\n        else {\\n            int add = minDist(a, b, i, j - 1, dp);\\n            int replace = minDist(a, b, i - 1, j - 1, dp);\\n            int remove = minDist(a, b, i - 1, j, dp);\\n            \\n            dp[i][j] =  1 + min(min(add, replace), remove);\\n            return dp[i][j];\\n        }\\n    }\\n```\n```\\nint minDist(string a, string b) {\\n        vector <vector <int>> dp(a.length() + 1, vector <int>(b.length() + 1, -1));\\n        \\n        for (int i = 0; i < a.length() + 1; i++) {\\n            for (int j = 0; j < b.length() + 1; j++) {\\n                if (i == 0) {\\n                    dp[i][j] = j;\\n                }\\n                else if (j == 0) {\\n                    dp[i][j] = i;\\n                }\\n                else {\\n                    if (a[i - 1] == b[j - 1]) {\\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    }\\n                    else {\\n                        int add = dp[i][j - 1];\\n                        int replace = dp[i- 1][j - 1];\\n                        int remove = dp[i - 1][j];\\n                        \\n                        dp[i][j] = 1 + min(min(add, replace), remove);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[a.length()][b.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 776867,
                "title": "javascript-clean-recursive-dp",
                "content": "```javascript\\nvar minDistance = function(word1, word2) {\\n    const memo = new Map();\\n    \\n    function run(w1, w2) {\\n        if(memo.has(`${w1}-${w2}`)) return memo.get(`${w1}-${w2}`)\\n        if(w1 >= word1.length && w2 >= word2.length) return 0;\\n        \\n        // if it\\'s a match\\n        if(word1[w1] === word2[w2]) return run(w1+1, w2+1);\\n        \\n        let insert = Infinity, del = Infinity, replace = Infinity;\\n        \\n        // insert\\n        if(w2 < word2.length) insert = run(w1, w2+1);\\n        \\n        // delete\\n        if(w1 < word1.length) del = run(w1+1, w2);\\n        \\n        // replace\\n        if(w1 < word1.length && w2 < word2.length) replace = run(w1+1, w2+1);\\n        \\n        const res = Math.min(insert, del, replace) + 1;\\n        memo.set(`${w1}-${w2}`, res);\\n        return res;\\n    }\\n    return run(0, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```javascript\\nvar minDistance = function(word1, word2) {\\n    const memo = new Map();\\n    \\n    function run(w1, w2) {\\n        if(memo.has(`${w1}-${w2}`)) return memo.get(`${w1}-${w2}`)\\n        if(w1 >= word1.length && w2 >= word2.length) return 0;\\n        \\n        // if it\\'s a match\\n        if(word1[w1] === word2[w2]) return run(w1+1, w2+1);\\n        \\n        let insert = Infinity, del = Infinity, replace = Infinity;\\n        \\n        // insert\\n        if(w2 < word2.length) insert = run(w1, w2+1);\\n        \\n        // delete\\n        if(w1 < word1.length) del = run(w1+1, w2);\\n        \\n        // replace\\n        if(w1 < word1.length && w2 < word2.length) replace = run(w1+1, w2+1);\\n        \\n        const res = Math.min(insert, del, replace) + 1;\\n        memo.set(`${w1}-${w2}`, res);\\n        return res;\\n    }\\n    return run(0, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662438,
                "title": "recursion-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string s1, string s2, vector<vector<int>> &dp)\\n    {\\n        if(i == s1.length() && j == s2.length()) return 0;\\n        if(i == s1.length()) return s2.length()-j;\\n        if(j == s2.length()) return s1.length()-i;\\n        int &ans = dp[i][j];\\n        if(ans != -1) return ans;\\n        ans = INT_MAX;\\n        if(s1[i] == s2[j])\\n        {\\n            ans = solve(i+1, j+1, s1, s2, dp);\\n        }\\n        else\\n        {\\n            ans = min(ans, solve(i, j+1, s1, s2, dp));\\n            ans = min(ans, solve(i+1, j+1, s1, s2, dp));\\n            ans = min(ans, solve(i+1, j, s1, s2, dp));\\n            ans = ans + 1;\\n        }\\n        return ans;\\n    }\\n    int minDistance(string s1, string s2) {\\n        vector<vector<int>> dp(1001, vector<int>(1001, -1));\\n        return solve(0, 0, s1, s2, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string s1, string s2, vector<vector<int>> &dp)\\n    {\\n        if(i == s1.length() && j == s2.length()) return 0;\\n        if(i == s1.length()) return s2.length()-j;\\n        if(j == s2.length()) return s1.length()-i;\\n        int &ans = dp[i][j];\\n        if(ans != -1) return ans;\\n        ans = INT_MAX;\\n        if(s1[i] == s2[j])\\n        {\\n            ans = solve(i+1, j+1, s1, s2, dp);\\n        }\\n        else\\n        {\\n            ans = min(ans, solve(i, j+1, s1, s2, dp));\\n            ans = min(ans, solve(i+1, j+1, s1, s2, dp));\\n            ans = min(ans, solve(i+1, j, s1, s2, dp));\\n            ans = ans + 1;\\n        }\\n        return ans;\\n    }\\n    int minDistance(string s1, string s2) {\\n        vector<vector<int>> dp(1001, vector<int>(1001, -1));\\n        return solve(0, 0, s1, s2, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662428,
                "title": "rust-bottom-up-dp-with-explanations-o-m-n-time-o-n-space-0-ms-faster-than-100",
                "content": "#### Solution\\n\\n```rust\\nimpl Solution {\\n    pub fn min_distance(word1: String, word2: String) -> i32 {\\n        // Treat characters as raw bytes, as it allows us to directly access the underlying arrays:\\n        let (word1, word2) = (word1.as_bytes(), word2.as_bytes());\\n\\n        // Allocate memory in one-go, as it is typically faster:\\n        let mut dist = Vec::with_capacity(word2.len() + 1);\\n\\n        // Base case: we need to delete j characters in word2 in order to match the empty string word1:\\n        for j in 0..=word2.len() {\\n            dist.push(j)\\n        }\\n\\n        // Use a second vector to store distances for i - 1.\\n\\t\\t// This uses less memory than having a matrix of size (m, n), \\n\\t\\t// and we always just use the previous row in the matrix anyway:\\n        let mut prev_dist = dist.clone();\\n\\n        for i in 1..=word1.len() {\\n            for j in 0..=word2.len() {\\n                if j == 0 {\\n                    dist[j] += 1; // Base case: we need to insert a character in order to match word1.\\n                } else if word1[i - 1] == word2[j - 1] {\\n                    // No difference, don\\'t increment the edit distance:\\n                    dist[j] = prev_dist[j - 1];\\n                } else {\\n                    // Either insert, delete or replace a character: increment the edit distance by one:\\n                    dist[j] = dist[j].min(dist[j - 1]).min(prev_dist[j - 1]) + 1;\\n                }\\n            }\\n            prev_dist.copy_from_slice(&dist); // Backup the distances for this row using memcpy.\\n        }\\n        dist[word2.len()] as i32\\n    }\\n}\\n```\\n\\nThis algorithm gradually calculates the edit distance by iterating over the characters of the two provided words. `dist` and `prev_dist` represent two consecutive rows in the following distances matrix:\\n\\n<img src=\"https://assets.leetcode.com/users/marccarre/image_1590915262.png\" width=\"180px\" />\\n\\n#### Performance\\n\\n> Runtime: 0 ms, faster than 100.00% of Rust online submissions for Edit Distance.\\n> Memory Usage: 2.1 MB, less than 100.00% of Rust online submissions for Edit Distance.\\n",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_distance(word1: String, word2: String) -> i32 {\\n        // Treat characters as raw bytes, as it allows us to directly access the underlying arrays:\\n        let (word1, word2) = (word1.as_bytes(), word2.as_bytes());\\n\\n        // Allocate memory in one-go, as it is typically faster:\\n        let mut dist = Vec::with_capacity(word2.len() + 1);\\n\\n        // Base case: we need to delete j characters in word2 in order to match the empty string word1:\\n        for j in 0..=word2.len() {\\n            dist.push(j)\\n        }\\n\\n        // Use a second vector to store distances for i - 1.\\n\\t\\t// This uses less memory than having a matrix of size (m, n), \\n\\t\\t// and we always just use the previous row in the matrix anyway:\\n        let mut prev_dist = dist.clone();\\n\\n        for i in 1..=word1.len() {\\n            for j in 0..=word2.len() {\\n                if j == 0 {\\n                    dist[j] += 1; // Base case: we need to insert a character in order to match word1.\\n                } else if word1[i - 1] == word2[j - 1] {\\n                    // No difference, don\\'t increment the edit distance:\\n                    dist[j] = prev_dist[j - 1];\\n                } else {\\n                    // Either insert, delete or replace a character: increment the edit distance by one:\\n                    dist[j] = dist[j].min(dist[j - 1]).min(prev_dist[j - 1]) + 1;\\n                }\\n            }\\n            prev_dist.copy_from_slice(&dist); // Backup the distances for this row using memcpy.\\n        }\\n        dist[word2.len()] as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313925,
                "title": "swift-85-beat-using-dynamic-programming-solution-o-n-m-quadratic-speed-eazy-breezy",
                "content": "```\\nclass Solution {\\n    func minDistance(_ word1: String, _ word2: String) -> Int {\\n        \\n        if word1.count == 0 { return word2.count }\\n        if word2.count == 0 { return word1.count }\\n        \\n        var grid = [[Int]](repeating: [Int](repeating: 0, count: word2.count + 1), count: word1.count + 1)\\n        \\n        for x in 0...word1.count { grid[x][0] = x }\\n        for y in 0...word2.count { grid[0][y] = y }\\n        \\n        var word1 = Array(word1)\\n        var word2 = Array(word2)\\n        \\n        for x in 1...word1.count {\\n            for y in 1...word2.count {\\n                if word1[x - 1] == word2[y - 1] {\\n                    grid[x][y] = grid[x-1][y-1]\\n                } else {   \\n                    grid[x][y] = min(grid[x-1][y], min(grid[x-1][y-1], grid[x][y-1])) + 1\\n                }       \\n            }\\n        }\\n        return grid[word1.count][word2.count]\\n    }\\n}\\n```\\n\\nBoom, you\\'re on the payroll now. Winner winner, chicken dinner. I guess that\\'s why they call it the blues.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minDistance(_ word1: String, _ word2: String) -> Int {\\n        \\n        if word1.count == 0 { return word2.count }\\n        if word2.count == 0 { return word1.count }\\n        \\n        var grid = [[Int]](repeating: [Int](repeating: 0, count: word2.count + 1), count: word1.count + 1)\\n        \\n        for x in 0...word1.count { grid[x][0] = x }\\n        for y in 0...word2.count { grid[0][y] = y }\\n        \\n        var word1 = Array(word1)\\n        var word2 = Array(word2)\\n        \\n        for x in 1...word1.count {\\n            for y in 1...word2.count {\\n                if word1[x - 1] == word2[y - 1] {\\n                    grid[x][y] = grid[x-1][y-1]\\n                } else {   \\n                    grid[x][y] = min(grid[x-1][y], min(grid[x-1][y-1], grid[x][y-1])) + 1\\n                }       \\n            }\\n        }\\n        return grid[word1.count][word2.count]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261880,
                "title": "java-dp-solution-beats-99-81-on-runtime-bottonup-space-o-n",
                "content": "\\n__Recursive Approach__(TLE) : In this Approach for Word1 we have 3 Operations which are Insert, Delete or Replace.\\n\\nIf the First character of both of the Words are same then we need not to perform any of the Operation but if the Character is not same then we need to check which of the Operation among the insert, delete or replace will give the minimum answer.\\n\\nSo to find the minimum answer we need to check all of the 3 Possible Operations and then we will check among them which is minimum and then simply return the answer.\\n\\n**In Case the Character of both of the Word is Matching**\\nSimply Skip the similar character and hunt for the dissimilar One in the Word1.\\n\\n**In Case the Character we are Checking is not matching with the Character of Word1**\\n1. __Insert__ : In this Case we will Insert in Word1 the same Character as that of the Word2 so that we can make the Word1 to match Word2.\\n2. __Delete__ : In this Case we will Delete the Character from the Word1 as the character was not matching with the Word2.\\n3. __Replace__ : We will replace the dissimilar Character of the Word1 with Word2.\\n\\nNote : After calculating the Minimum of all of the Possible 3 Operations then we need to Add 1 to the answer as We have not included the cost of current Operation. \\nFor e.g.,\\nword1 = \"horse\"\\nword2 = \"ros\"\\n\\n```\\n                          (horse, ros)\\n// First Character of both the Words are Different then 3 Operations will be Performed\\n\\t\\t\\t      /             |            \\\\\\n\\t\\t     (Insert)        (Delete)       (Replace)\\n\\t\\t\\t   |                |                |\\n\\t\\t(rhorse, ros)       (orse,ros)       (rorse,ros) \\n// It is to be noted that the first Character of Word1 will surely become same as that of the Word2. In order to get minimun answer we need to perfrom such Operations Otherwise we will not get the Optimized answer.\\n               |                |                |  // We can directly write this stage in next Operations\\n          (horse, os)      (orse, ros)        (orse, os) \\n\\t\\t /     |     \\\\          .                  |  //Simply Skip the Character\\n(horse, s) (orse, ros) (orse, s).               (rse, s)\\n    .           .          .    .                   .\\n    .           .          .                        .\\n    .           .          .                        .\\n\\tSo on.\\n```\\n**Base Case** : Base Condition should be if any of the Word is consumed completely then we need to stop working as not we cannot check if the characters are same or not.\\n\\nIn the Base case, 3 Cases are Possible :\\n1. **Both of the Word are Consumed** : Then ans is zero as the empty Strings are also equal.\\n2. **Word1 is Consumed** : In this case Word2 is available and now our work is to convert the empty String into the Word1, So we need to perform Insertions Equal to length of the Word2. Hence we can return the Length of the Word2.\\n3.  **Word2 is Consumed** : In this case Word1 is available and now our work is to convert the this String into the Empty, So we need to perform deletions Equal to length of the Word1. Hence we can return the Length of the Word1.\\n\\nSo we will return Math.max(Word1.length(), Word1.length());\\n```\\npublic static int helper(String s1, String s2){\\n\\t\\tif(s1.length() == 0 || s2.length() == 0){ // If length any of the Length is Consumed completely\\n\\t\\t\\treturn Math.max(s1.length(), s2.length()); // Discussed Above\\n\\t\\t}\\n\\n\\t\\tif(s1.charAt(0) == s2.charAt(0)){ // If the Character matches\\n\\t\\t\\treturn helper(s1.substring(1),s2.substring(1)); // Skip both of the Characters\\n\\t\\t}else{\\n\\t\\t\\tint insert = helper(s1, s2.substring(1)); // In case of Insertion Consume the S2 character\\n\\t\\t\\tint delete = helper(s1.substring(1), s2); // In case of Deletion Consume the S1 character\\n\\t\\t\\tint replace = helper(s1.substring(1), s2.substring(1)); // In case of Replace Consume the characters from both of the Strings\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\treturn Math.min(insert, Math.min(delete, replace)) + 1; //Return the minimum Operations among the 3 Operations + 1.\\n\\t\\t}\\n\\t}\\n```\\n\\n**TopDown Approach** : This Approach is Similar as discussed Above but In this Approach we will create and Save the calculated answer in an Array called as Storage.\\n```\\npublic static int helperTD(String s1, String s2, int[][] strg){\\n\\t\\tif(s1.length() == 0 || s2.length() == 0){\\n\\t\\t\\treturn Math.max(s1.length(), s2.length());\\n\\t\\t}\\n\\t\\tint n = s1.length();\\n\\t\\tint m = s2.length();\\n\\t\\tif(strg[n][m] != 0){  //If we have Already Calculated the Answer\\n\\t\\t\\treturn strg[n][m]; // return the Saved Answer\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(s1.charAt(0) == s2.charAt(0)){\\n\\t\\t\\tstrg[n][m] = helperTD(s1.substring(1),s2.substring(1), strg); // Saving Answer\\n\\t\\t\\treturn strg[n][m];\\n\\t\\t}else{\\n\\t\\t\\tint insert = helperTD(s1, s2.substring(1), strg);\\n\\t\\t\\tint delete = helperTD(s1.substring(1), s2, strg);\\n\\t\\t\\tint replace = helperTD(s1.substring(1), s2.substring(1), strg);\\n\\t\\t\\tstrg[n][m] = Math.min(insert, Math.min(delete, replace)) + 1; // Storing the calculated answer\\n\\t\\t\\treturn strg[n][m]; // return the Calculated Answer\\n\\t\\t}\\n\\t}\\n```\\n\\n**BottomUp Approach** : \\n```\\npublic static int helperBU(String s1, String s2){\\n\\t\\tint[][] strg = new int[s1.length() + 1][s2.length() + 1];\\n\\t\\tfor(int i = s1.length();i >= 0;i--){\\n\\t\\t\\tfor(int j = s2.length();j >= 0;j--){\\n\\t\\t\\t\\tif(i == s1.length()){\\n\\t\\t\\t\\t\\tstrg[i][j] = s2.length() - j;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == s2.length()){\\n\\t\\t\\t\\t\\tstrg[i][j] = s1.length() - i;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s1.charAt(i) == s2.charAt(j)){\\n\\t\\t\\t\\t\\tstrg[i][j] = strg[i + 1][j + 1];\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tint insert = strg[i][j + 1];\\n\\t\\t\\t\\t\\tint delete = strg[i + 1][j];\\n\\t\\t\\t\\t\\tint replace = strg[i + 1][j + 1];\\n\\t\\t\\t\\t\\tstrg[i][j] = Math.min(insert, Math.min(delete, replace)) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn strg[0][0];\\n\\t}\\n```\\n\\n**BottomUp Efficient(Beats 99.81 % on Runtime)**\\n\\n```\\npublic static int helperBU_Eff(String s1, String s2){\\n\\t\\tint[] strg = new int[s2.length() + 1];\\n\\t\\tfor(int i = s1.length();i >= 0;i--){\\n\\t\\t\\tint save = 0;\\n\\t\\t\\tfor(int j = s2.length();j >= 0;j--){\\n\\t\\t\\t\\tif(i == s1.length()){\\n\\t\\t\\t\\t\\tstrg[j] = s2.length() - j;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == s2.length()){\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = s1.length() - i;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s1.charAt(i) == s2.charAt(j)){\\n\\t\\t\\t\\t\\tint temp = save;\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = temp;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tint insert = strg[j + 1];\\n\\t\\t\\t\\t\\tint delete = strg[j];\\n\\t\\t\\t\\t\\tint replace = save;\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = Math.min(insert, Math.min(delete, replace)) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn strg[0];\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n                          (horse, ros)\\n// First Character of both the Words are Different then 3 Operations will be Performed\\n\\t\\t\\t      /             |            \\\\\\n\\t\\t     (Insert)        (Delete)       (Replace)\\n\\t\\t\\t   |                |                |\\n\\t\\t(rhorse, ros)       (orse,ros)       (rorse,ros) \\n// It is to be noted that the first Character of Word1 will surely become same as that of the Word2. In order to get minimun answer we need to perfrom such Operations Otherwise we will not get the Optimized answer.\\n               |                |                |  // We can directly write this stage in next Operations\\n          (horse, os)      (orse, ros)        (orse, os) \\n\\t\\t /     |     \\\\          .                  |  //Simply Skip the Character\\n(horse, s) (orse, ros) (orse, s).               (rse, s)\\n    .           .          .    .                   .\\n    .           .          .                        .\\n    .           .          .                        .\\n\\tSo on.\\n```\n```\\npublic static int helper(String s1, String s2){\\n\\t\\tif(s1.length() == 0 || s2.length() == 0){ // If length any of the Length is Consumed completely\\n\\t\\t\\treturn Math.max(s1.length(), s2.length()); // Discussed Above\\n\\t\\t}\\n\\n\\t\\tif(s1.charAt(0) == s2.charAt(0)){ // If the Character matches\\n\\t\\t\\treturn helper(s1.substring(1),s2.substring(1)); // Skip both of the Characters\\n\\t\\t}else{\\n\\t\\t\\tint insert = helper(s1, s2.substring(1)); // In case of Insertion Consume the S2 character\\n\\t\\t\\tint delete = helper(s1.substring(1), s2); // In case of Deletion Consume the S1 character\\n\\t\\t\\tint replace = helper(s1.substring(1), s2.substring(1)); // In case of Replace Consume the characters from both of the Strings\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\treturn Math.min(insert, Math.min(delete, replace)) + 1; //Return the minimum Operations among the 3 Operations + 1.\\n\\t\\t}\\n\\t}\\n```\n```\\npublic static int helperTD(String s1, String s2, int[][] strg){\\n\\t\\tif(s1.length() == 0 || s2.length() == 0){\\n\\t\\t\\treturn Math.max(s1.length(), s2.length());\\n\\t\\t}\\n\\t\\tint n = s1.length();\\n\\t\\tint m = s2.length();\\n\\t\\tif(strg[n][m] != 0){  //If we have Already Calculated the Answer\\n\\t\\t\\treturn strg[n][m]; // return the Saved Answer\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(s1.charAt(0) == s2.charAt(0)){\\n\\t\\t\\tstrg[n][m] = helperTD(s1.substring(1),s2.substring(1), strg); // Saving Answer\\n\\t\\t\\treturn strg[n][m];\\n\\t\\t}else{\\n\\t\\t\\tint insert = helperTD(s1, s2.substring(1), strg);\\n\\t\\t\\tint delete = helperTD(s1.substring(1), s2, strg);\\n\\t\\t\\tint replace = helperTD(s1.substring(1), s2.substring(1), strg);\\n\\t\\t\\tstrg[n][m] = Math.min(insert, Math.min(delete, replace)) + 1; // Storing the calculated answer\\n\\t\\t\\treturn strg[n][m]; // return the Calculated Answer\\n\\t\\t}\\n\\t}\\n```\n```\\npublic static int helperBU(String s1, String s2){\\n\\t\\tint[][] strg = new int[s1.length() + 1][s2.length() + 1];\\n\\t\\tfor(int i = s1.length();i >= 0;i--){\\n\\t\\t\\tfor(int j = s2.length();j >= 0;j--){\\n\\t\\t\\t\\tif(i == s1.length()){\\n\\t\\t\\t\\t\\tstrg[i][j] = s2.length() - j;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == s2.length()){\\n\\t\\t\\t\\t\\tstrg[i][j] = s1.length() - i;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s1.charAt(i) == s2.charAt(j)){\\n\\t\\t\\t\\t\\tstrg[i][j] = strg[i + 1][j + 1];\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tint insert = strg[i][j + 1];\\n\\t\\t\\t\\t\\tint delete = strg[i + 1][j];\\n\\t\\t\\t\\t\\tint replace = strg[i + 1][j + 1];\\n\\t\\t\\t\\t\\tstrg[i][j] = Math.min(insert, Math.min(delete, replace)) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn strg[0][0];\\n\\t}\\n```\n```\\npublic static int helperBU_Eff(String s1, String s2){\\n\\t\\tint[] strg = new int[s2.length() + 1];\\n\\t\\tfor(int i = s1.length();i >= 0;i--){\\n\\t\\t\\tint save = 0;\\n\\t\\t\\tfor(int j = s2.length();j >= 0;j--){\\n\\t\\t\\t\\tif(i == s1.length()){\\n\\t\\t\\t\\t\\tstrg[j] = s2.length() - j;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == s2.length()){\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = s1.length() - i;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s1.charAt(i) == s2.charAt(j)){\\n\\t\\t\\t\\t\\tint temp = save;\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = temp;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tint insert = strg[j + 1];\\n\\t\\t\\t\\t\\tint delete = strg[j];\\n\\t\\t\\t\\t\\tint replace = save;\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = Math.min(insert, Math.min(delete, replace)) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn strg[0];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25921,
                "title": "easy-understanding-java-solution-using-dp-with-memorization-beats-about-99-solutions",
                "content": "\\n    public int minDistance(String word1, String word2) {\\n        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();\\n        int[][] memo = new int[w1.length+1][w2.length+1];\\n        return minDistanceHelper(w1, w2, 0, 0, memo);\\n    }\\n    \\n    public int minDistanceHelper(char[] w1, char[] w2, int w1Index, int w2Index, int[][] memo) {\\n        if(w1Index == w1.length) return w2.length - w2Index;\\n        if(w2Index == w2.length) return w1.length - w1Index;\\n\\n        if(memo[w1Index][w2Index] != 0) return memo[w1Index][w2Index];\\n\\n        if(w1[w1Index] == w2[w2Index]) {\\n            memo[w1Index][w2Index] = minDistanceHelper(w1, w2, w1Index+1, w2Index+1, memo);\\n        } else {\\n            int opt1 = minDistanceHelper(w1, w2, w1Index+1, w2Index, memo);\\n            int opt2 = minDistanceHelper(w1, w2, w1Index, w2Index+1, memo);\\n            int opt3 = minDistanceHelper(w1, w2, w1Index+1, w2Index+1, memo);\\n            memo[w1Index][w2Index] = Math.min(opt1, Math.min(opt2, opt3)) + 1;\\n        }\\n        return memo[w1Index][w2Index];\\n    }",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "\\n    public int minDistance(String word1, String word2) {\\n        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();\\n        int[][] memo = new int[w1.length+1][w2.length+1];\\n        return minDistanceHelper(w1, w2, 0, 0, memo);\\n    }\\n    \\n    public int minDistanceHelper(char[] w1, char[] w2, int w1Index, int w2Index, int[][] memo) {\\n        if(w1Index == w1.length) return w2.length - w2Index;\\n        if(w2Index == w2.length) return w1.length - w1Index;\\n\\n        if(memo[w1Index][w2Index] != 0) return memo[w1Index][w2Index];\\n\\n        if(w1[w1Index] == w2[w2Index]) {\\n            memo[w1Index][w2Index] = minDistanceHelper(w1, w2, w1Index+1, w2Index+1, memo);\\n        } else {\\n            int opt1 = minDistanceHelper(w1, w2, w1Index+1, w2Index, memo);\\n            int opt2 = minDistanceHelper(w1, w2, w1Index, w2Index+1, memo);\\n            int opt3 = minDistanceHelper(w1, w2, w1Index+1, w2Index+1, memo);\\n            memo[w1Index][w2Index] = Math.min(opt1, Math.min(opt2, opt3)) + 1;\\n        }\\n        return memo[w1Index][w2Index];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25939,
                "title": "ac-python-212-ms-dp-solution-o-mn-time-o-n-space",
                "content": "This is similar to the longest common subsequence problem. Dynamic programming is intuitive.\\n\\n    def minDistance(self, word1, word2):\\n        if len(word1) == 0 or len(word2) == 0:\\n            return max(len(word1), len(word2))\\n        dist = range(len(word2) + 1)\\n        for i in xrange(len(word1)):\\n            dist_ij, dist[0] = i, i + 1\\n            for j in xrange(len(word2)):\\n                if word1[i] == word2[j]:\\n                    dist_ij, dist[j + 1] = dist[j + 1], dist_ij\\n                else:\\n                    dist_ij, dist[j + 1] = dist[j + 1], min(dist[j], dist[j + 1], dist_ij) + 1\\n        return dist[-1]\\n\\n\\n    # 1146 / 1146 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 212 ms\\n    # 96.23%\\n\\n\\nThe relations of DP are\\n\\n    # keep the last char:      dist(i + 1, j + 1) = dist(i, j)\\n    # insert the last char:    dist(i + 1, j + 1) = dist(i + 1, j) + 1\\n    # replace the last char:   dist(i + 1, j + 1) = dist(i, j)     + 1\\n    # remove the last char:    dist(i + 1, j + 1) = dist(i, j + 1) + 1",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "This is similar to the longest common subsequence problem. Dynamic programming is intuitive.\\n\\n    def minDistance(self, word1, word2):\\n        if len(word1) == 0 or len(word2) == 0:\\n            return max(len(word1), len(word2))\\n        dist = range(len(word2) + 1)\\n        for i in xrange(len(word1)):\\n            dist_ij, dist[0] = i, i + 1\\n            for j in xrange(len(word2)):\\n                if word1[i] == word2[j]:\\n                    dist_ij, dist[j + 1] = dist[j + 1], dist_ij\\n                else:\\n                    dist_ij, dist[j + 1] = dist[j + 1], min(dist[j], dist[j + 1], dist_ij) + 1\\n        return dist[-1]\\n\\n\\n    # 1146 / 1146 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 212 ms\\n    # 96.23%\\n\\n\\nThe relations of DP are\\n\\n    # keep the last char:      dist(i + 1, j + 1) = dist(i, j)\\n    # insert the last char:    dist(i + 1, j + 1) = dist(i + 1, j) + 1\\n    # replace the last char:   dist(i + 1, j + 1) = dist(i, j)     + 1\\n    # remove the last char:    dist(i + 1, j + 1) = dist(i, j + 1) + 1",
                "codeTag": "Python3"
            },
            {
                "id": 25870,
                "title": "my-none-recursive-solution",
                "content": "Hello, I've finish this problem without recursion. Any comment on how i can improve on the code?   Thanks. \\nIs there a reason why people are doing recursive builds? (Space vs time?)\\n\\n\\n    public class Solution {\\n            public int minDistance(String word1, String word2) {\\n                int [][] result = new int[word1.length()+1][word2.length()+1];\\n                //set up deletion into null string;\\n                for(int i=0;i<=word1.length();i++) result[i][0]=i;\\n                for(int j=0;j<=word2.length();j++) result[0][j]=j;\\n                for(int i=1;i<=word1.length();i++)\\n                {\\n                    for(int j=1;j<=word2.length();j++)\\n                    {\\n                        int del = result[i-1][j] +1;\\n                        int ins = result[i][j-1] +1;\\n                        int rep = result[i-1][j-1];\\n                        if(word1.charAt(i-1)!=word2.charAt(j-1)) \\n                        {\\n                            rep+=1;\\n                        }\\n                        int min = Math.min(del,ins);\\n                        min = Math.min(min,rep);\\n                        result[i][j]=min;\\n                    }\\n                }\\n                return result[word1.length()][word2.length()];\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public int minDistance(String word1, String word2) {\\n                int [][] result = new int[word1.length()+1][word2.length()+1];\\n                //set up deletion into null string;\\n                for(int i=0;i<=word1.length();i++) result[i][0]=i;\\n                for(int j=0;j<=word2.length();j++) result[0][j]=j;\\n                for(int i=1;i<=word1.length();i++)\\n                {\\n                    for(int j=1;j<=word2.length();j++)\\n                    {\\n                        int del = result[i-1][j] +1;\\n                        int ins = result[i][j-1] +1;\\n                        int rep = result[i-1][j-1];\\n                        if(word1.charAt(i-1)!=word2.charAt(j-1)) \\n                        {\\n                            rep+=1;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3817915,
                "title": "0-n-space-solution",
                "content": "# PLS UPVOTE MY SOLUTION IF YOPU LIKE AND COMMENT FOR ANY DISCUSSION\\n# Dynamic Programming (Tabulation) with Space Optimization:\\n# Approach\\nThe function spacopti is used to find the minimum edit distance using dynamic programming (tabulation) with space optimization.\\nIt initializes two vectors curr and next to store intermediate results during the computation.\\nThe next vector is pre-filled with values representing the minimum number of operations needed to transform the suffix of string b into an empty string (i.e., characters are deleted).\\nTabulation Loop:\\n\\nThe tabulation loop iterates over the indices of a and b from the end to the beginning.\\nIt computes the minimum edit distance for each pair of substrings a[i:] and b[j:], storing the result in the curr vector.\\nThe curr vector is updated iteratively as the loop progresses.\\nMatching Characters:\\n\\nIf the characters at a[i] and b[j] are the same, the function updates the ans variable with the value from next[j+1]. This represents the minimum edit distance for the remaining substrings a[i+1:] and b[j+1:].\\nMismatching Characters:\\n\\nIf the characters at a[i] and b[j] are different, the function calculates three possible operations (insertion, deletion, and replacement) and updates the ans variable with the minimum value among them.\\nSpace Optimization:\\n\\nInstead of using two separate vectors for curr and next, the function uses only curr for tabulation. The next vector is effectively replaced by curr in each iteration, updating the values accordingly.\\nOutput:\\n\\nThe minDistance function returns the result of the dynamic programming (tabulation) function spacopti(word1, word2), which represents the minimum number of operations required to transform word1 into word2.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# CODE\\n```\\nclass Solution {\\npublic:\\n\\nint spacopti(string& a, string& b)\\n{\\n    vector<int>curr(b.length()+11,0);\\n    vector<int>next(b.length()+111,0);\\n    for(int j =0;j<b.length();j++)\\n    {\\n        next[j]=b.length()-j;\\n    }\\n\\n\\n    for(int i=a.length();i>=0;i--)\\n    {\\n        for(int j = b.length();j>=0;j--)\\n        {\\n            int ans=0;\\n            curr[b.length()]=a.length()-i;\\n            if(a[i]==b[j])\\n            {\\n                ans= next[j+1];\\n            }\\n            else\\n            {\\n                int insert= 1 + curr[j+1];\\n                int deleteans= 1 + next[j];\\n                int replace= 1 + next[j+1];\\n                ans = min(insert , min(deleteans , replace));\\n            }\\n            curr[j]=ans;\\n        }\\n        next=curr;\\n    }\\n    return next[0];\\n}\\n\\n    int minDistance(string word1, string word2) {\\n        return spacopti(word1,word2);\\n\\n    }\\n};\\n```\\n# Recursive Function with Memoization:\\n# Approach\\n\\n\\nThe function solve is a recursive function that takes two strings a and b, along with two indices i and j, representing the current position in a and b.\\nThe function calculates the minimum distance (number of operations) required to transform the substring a[i:] into the substring b[j:].\\nThe function uses memoization to store the results of subproblems in a 2D dp array. The dp array is used to avoid redundant calculations for overlapping subproblems.\\nBase Cases:\\n\\nIf the index i reaches the end of string a, the remaining characters in b need to be inserted to match a, so the function returns b.length() - j.\\nIf the index j reaches the end of string b, the remaining characters in a need to be deleted to match b, so the function returns a.length() - i.\\nMemoization:\\n\\nThe function checks if the result for the current subproblem (i.e., solve(a, b, i, j, dp)) is already calculated and stored in the dp array. If so, it returns the stored result, avoiding redundant calculations.\\nMatching Characters:\\n\\nIf the characters at a[i] and b[j] are the same, no operation is required, so the function calls itself with i+1 and j+1.\\nMismatching Characters:\\n\\nIf the characters at a[i] and b[j] are different, the function considers three possible operations (insertion, deletion, and replacement) and calculates the minimum distance by recursively calling itself with different indices and adding one for the operation performed.\\nMain Function:\\n\\nThe minDistance function initializes the dp array with -1 and calls the recursive function solve with the two strings word1 and word2, along with initial indices 0 and 0.\\nOutput:\\n\\nThe minDistance function returns the minimum number of operations required to transform word1 into word2.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(string& a, string& b,int i,int j ,vector<vector<int>>& dp)\\n{\\n      int ans=0;\\n    if(a.length()==i)\\n    {\\n        return b.length()-j;\\n    }\\n    if(b.length()==j)\\n    {\\n        return a.length()-i;\\n    }\\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    if(a[i]==b[j])\\n    {\\n        return solve(a,b,i+1,j+1,dp);\\n    }\\n  \\n    else\\n    {\\n        int insert= 1 + solve(a,b,i,j+1,dp);\\n\\n        int deleteans= 1 + solve(a,b,i+1,j,dp);\\n\\n        int replace= 1 + solve(a,b,i+1,j+1,dp);\\n        ans = min(insert , min(deleteans , replace));\\n    }\\n    return dp[i][j]=ans;\\n\\n}\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>>dp(word1.length()+11,vector<int>(word2.length()+11,-1));\\n        return solve(word1,word2,0,0,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint spacopti(string& a, string& b)\\n{\\n    vector<int>curr(b.length()+11,0);\\n    vector<int>next(b.length()+111,0);\\n    for(int j =0;j<b.length();j++)\\n    {\\n        next[j]=b.length()-j;\\n    }\\n\\n\\n    for(int i=a.length();i>=0;i--)\\n    {\\n        for(int j = b.length();j>=0;j--)\\n        {\\n            int ans=0;\\n            curr[b.length()]=a.length()-i;\\n            if(a[i]==b[j])\\n            {\\n                ans= next[j+1];\\n            }\\n            else\\n            {\\n                int insert= 1 + curr[j+1];\\n                int deleteans= 1 + next[j];\\n                int replace= 1 + next[j+1];\\n                ans = min(insert , min(deleteans , replace));\\n            }\\n            curr[j]=ans;\\n        }\\n        next=curr;\\n    }\\n    return next[0];\\n}\\n\\n    int minDistance(string word1, string word2) {\\n        return spacopti(word1,word2);\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint solve(string& a, string& b,int i,int j ,vector<vector<int>>& dp)\\n{\\n      int ans=0;\\n    if(a.length()==i)\\n    {\\n        return b.length()-j;\\n    }\\n    if(b.length()==j)\\n    {\\n        return a.length()-i;\\n    }\\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    if(a[i]==b[j])\\n    {\\n        return solve(a,b,i+1,j+1,dp);\\n    }\\n  \\n    else\\n    {\\n        int insert= 1 + solve(a,b,i,j+1,dp);\\n\\n        int deleteans= 1 + solve(a,b,i+1,j,dp);\\n\\n        int replace= 1 + solve(a,b,i+1,j+1,dp);\\n        ans = min(insert , min(deleteans , replace));\\n    }\\n    return dp[i][j]=ans;\\n\\n}\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>>dp(word1.length()+11,vector<int>(word2.length()+11,-1));\\n        return solve(word1,word2,0,0,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592016,
                "title": "dp-c-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int i,int j,int &n,int &m,string &a,string &b,vector<vector<int>> &dp){\\n    if(i==n)return m-j;\\n    if(j==m)return n-i;\\n    if(dp[i][j] != -1)return dp[i][j];\\n    if(a[i]==b[j]){\\n        dp[i][j] = solve(i+1,j+1,n,m,a,b,dp);\\n    }else{\\n        dp[i][j] = min({solve(i+1,j,n,m,a,b,dp),solve(i,j+1,n,m,a,b,dp),solve(i+1,j+1,n,m,a,b,dp)})+1;\\n    }\\n    return dp[i][j];\\n}\\n    int minDistance(string a, string b) {\\n        int n = a.length(),m=b.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,n,m,a,b,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int i,int j,int &n,int &m,string &a,string &b,vector<vector<int>> &dp){\\n    if(i==n)return m-j;\\n    if(j==m)return n-i;\\n    if(dp[i][j] != -1)return dp[i][j];\\n    if(a[i]==b[j]){\\n        dp[i][j] = solve(i+1,j+1,n,m,a,b,dp);\\n    }else{\\n        dp[i][j] = min({solve(i+1,j,n,m,a,b,dp),solve(i,j+1,n,m,a,b,dp),solve(i+1,j+1,n,m,a,b,dp)})+1;\\n    }\\n    return dp[i][j];\\n}\\n    int minDistance(string a, string b) {\\n        int n = a.length(),m=b.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,n,m,a,b,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281006,
                "title": "easy-python-solution-using-dp-75-runtime",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        l1=len(word1)\\n        l2=len(word2)\\n        dp=[[0]*(l2+1) for i in range(l1+1)]\\n        cnt=0\\n        for i in range(l1+1):\\n            for j in range(l2+1):\\n                if i==0:\\n                    dp[i][j]=j\\n                elif j==0:\\n                    dp[i][j]=i\\n                elif word1[i-1]==word2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        l1=len(word1)\\n        l2=len(word2)\\n        dp=[[0]*(l2+1) for i in range(l1+1)]\\n        cnt=0\\n        for i in range(l1+1):\\n            for j in range(l2+1):\\n                if i==0:\\n                    dp[i][j]=j\\n                elif j==0:\\n                    dp[i][j]=i\\n                elif word1[i-1]==word2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231326,
                "title": "python-short-and-clean-2-solutions-recursive-dp-optimised-iterative-dp",
                "content": "# Approach: Recursive DP\\n1. Let `min_dist` be a function which takes indices `i1` and `i2` from `word1` and `word2` respectively, and returns the minimum operations needed to make `word1[:i1] == word2[:i2]`.\\n\\n2. Notice that if `word1[i1] == word2[i2]`, then no operations, i.e\\n    `min_dist(i1, i2) = min_dist(i1 - 1, i2 - 1)`\\n\\n3. And if `word1[i1] != word2[i2]`, then check all 3 operations, i.e\\n    `a = min_dist(i1 - 1, i2 - 1)` (Replace `word1[i1]` with `word2[i2]`)\\n    `b = min_dist(i1, i2 - 1)` (Insert `word2[i2]` in `word1`)\\n    `c = min_dist(i1 - 1, i2)` (Delete `word1[i1]`)\\n    `min_dist(i1, i2) = min(a, b, c)` (Best of all)\\n\\n4. This can be implemented by recursively calling the `min_dist` function.\\n\\n5. Since the problem has overlapping sub-problems and optimal sub-structure we can memoize the calls to `min_dist` to optimize the complexity.\\n\\n# Complexity\\n- Time complexity: $$O(n1 * n2)$$\\n\\n- Space complexity: $$O(n1 * n2)$$\\n\\nwhere,\\n`n1 is length of word1`,\\n`n2 is length of word2`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        @cache\\n        def min_distance(i1: int, i2: int) -> int:\\n            if not i1 or not i2: return max(i1, i2)\\n            \\n            return (\\n                min_distance(i1 - 1, i2 - 1)\\n                if word1[i1 - 1] == word2[i2 - 1] \\n                else 1 + min(\\n                    min_distance(i1 - 1, i2 - 1),\\n                    min_distance(i1, i2 - 1),\\n                    min_distance(i1 - 1, i2),\\n                )\\n            )\\n        \\n        return min_distance(len(word1), len(word2))\\n\\n\\n```\\n\\n---\\n# Approach: Iterative Space Optimized DP\\n1. Same as the recursive approach, but notice that at any given time we are only interesting in 3 previous states `min_dist(i, j) = min(a, b, c)`.\\n\\n2. We can optimise the space complexity by reducing the memoization from 2D space of `i and j` into 1D space of `i or j`.\\n\\n# Complexity\\n- Time complexity: $$O(n1 * n2)$$\\n\\n- Space complexity: $$O(min(n1, n2))$$\\n\\nwhere,\\n`n1 is length of word1`,\\n`n2 is length of word2`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        w1, w2 = (word1, word2) if len(word1) < len(word2) else (word2, word1)\\n        n1, n2 = len(w1), len(w2)\\n\\n        dp = list(range(n1 + 1))\\n        for i in range(n2):\\n            prev, dp[0] = dp[0], dp[0] + 1\\n            for j in range(n1):\\n                k = j + 1\\n                prev, dp[k] = dp[k], prev if w1[j] == w2[i] else min(prev, dp[k - 1], dp[k]) + 1\\n        \\n        return dp[-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        @cache\\n        def min_distance(i1: int, i2: int) -> int:\\n            if not i1 or not i2: return max(i1, i2)\\n            \\n            return (\\n                min_distance(i1 - 1, i2 - 1)\\n                if word1[i1 - 1] == word2[i2 - 1] \\n                else 1 + min(\\n                    min_distance(i1 - 1, i2 - 1),\\n                    min_distance(i1, i2 - 1),\\n                    min_distance(i1 - 1, i2),\\n                )\\n            )\\n        \\n        return min_distance(len(word1), len(word2))\\n\\n\\n```\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        w1, w2 = (word1, word2) if len(word1) < len(word2) else (word2, word1)\\n        n1, n2 = len(w1), len(w2)\\n\\n        dp = list(range(n1 + 1))\\n        for i in range(n2):\\n            prev, dp[0] = dp[0], dp[0] + 1\\n            for j in range(n1):\\n                k = j + 1\\n                prev, dp[k] = dp[k], prev if w1[j] == w2[i] else min(prev, dp[k - 1], dp[k]) + 1\\n        \\n        return dp[-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230679,
                "title": "python-easy-to-understand-bottom-up-dp-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code Upvote Please\\uD83D\\uDE09\\uD83D\\uDC4D and Help Me \\uD83D\\uDE4C\\uD83E\\uDD1E\\u2764\\n```\\nclass Solution(object):\\n    def minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        len1 = len(word1)\\n        len2 = len(word2)\\n        dp = [[-1] * (len2+1) for _ in range(len1+1)]\\n        \\n        for i in range(len1+1):\\n            for j in range(len2+1):\\n                if i == 0:\\n                    dp[i][j] = j  \\n                elif j == 0:\\n                    dp[i][j] = i  \\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[len1][len2]\\n        \\n        \\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        len1 = len(word1)\\n        len2 = len(word2)\\n        dp = [[-1] * (len2+1) for _ in range(len1+1)]\\n        \\n        for i in range(len1+1):\\n            for j in range(len2+1):\\n                if i == 0:\\n                    dp[i][j] = j  \\n                elif j == 0:\\n                    dp[i][j] = i  \\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[len1][len2]\\n        \\n        \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230499,
                "title": "daily-leetcoding-challenge-february-day-26",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/edit-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/edit-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2656519,
                "title": "memoization-tabulation-space-optimisation-c-beginner-friendly",
                "content": "```\\n// MEMOIZATION\\n// class Solution {\\n// public:\\n//     int f(int i, int j, string word1, string word2,vector<vector<int>> &dp){\\n//         if(i == 0) return j;\\n//         if(j == 0) return i;\\n//         if(dp[i][j] != -1) return dp[i][j];\\n//         if(word1[i-1] == word2[j-1]){\\n//             return dp[i][j] = f(i-1,j-1,word1,word2,dp);\\n//         }\\n//         return dp[i][j] = 1 + min(f(i-1,j-1,word1,word2,dp),min(f(i,j-1,word1,word2,dp),f(i-1,j,word1,word2,dp)));     \\n//     }\\n//     int minDistance(string word1, string word2) {\\n//         int n = word1.length();\\n//         int m = word2.length();\\n//         vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n//         return f(n,m,word1,word2,dp);\\n//     }\\n// };\\n// TABULATION\\n// class Solution {\\n// public:\\n//     int minDistance(string w1, string w2) {\\n//         int n = w1.length();\\n//         int m = w2.length();\\n//         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        \\n//         for(int j=0;j<=m;j++) dp[0][j] = j;\\n//         for(int i=0;i<=n;i++) dp[i][0] = i;\\n        \\n//         for(int i=1;i<=n;i++){\\n//             for(int j=1;j<=m;j++){\\n//                 if(w1[i-1] == w2[j-1]){\\n//                     dp[i][j] = dp[i-1][j-1];    \\n//                 }else{\\n//                     dp[i][j] = 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n//                 }\\n                \\n//             }\\n//         }\\n//         return dp[n][m];\\n//     }\\n// };\\n// SPACE OPTIMISATION\\nclass Solution {\\npublic:\\n    int minDistance(string w1, string w2) {\\n        int n = w1.length();\\n        int m = w2.length();\\n        vector<int> curr(m+1,0),prev(m+1,0);\\n        \\n        for(int j=0;j<=m;j++) prev[j] = j;\\n        \\n        for(int i=1;i<=n;i++){\\n            curr[0] = i;\\n            for(int j=1;j<=m;j++){\\n                if(w1[i-1] == w2[j-1]){\\n                    curr[j] = prev[j-1];    \\n                }else{\\n                    curr[j] = 1 + min(prev[j-1],min(prev[j],curr[j-1]));\\n                }\\n                \\n            }\\n            prev = curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// MEMOIZATION\\n// class Solution {\\n// public:\\n//     int f(int i, int j, string word1, string word2,vector<vector<int>> &dp){\\n//         if(i == 0) return j;\\n//         if(j == 0) return i;\\n//         if(dp[i][j] != -1) return dp[i][j];\\n//         if(word1[i-1] == word2[j-1]){\\n//             return dp[i][j] = f(i-1,j-1,word1,word2,dp);\\n//         }\\n//         return dp[i][j] = 1 + min(f(i-1,j-1,word1,word2,dp),min(f(i,j-1,word1,word2,dp),f(i-1,j,word1,word2,dp)));     \\n//     }\\n//     int minDistance(string word1, string word2) {\\n//         int n = word1.length();\\n//         int m = word2.length();\\n//         vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n//         return f(n,m,word1,word2,dp);\\n//     }\\n// };\\n// TABULATION\\n// class Solution {\\n// public:\\n//     int minDistance(string w1, string w2) {\\n//         int n = w1.length();\\n//         int m = w2.length();\\n//         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        \\n//         for(int j=0;j<=m;j++) dp[0][j] = j;\\n//         for(int i=0;i<=n;i++) dp[i][0] = i;\\n        \\n//         for(int i=1;i<=n;i++){\\n//             for(int j=1;j<=m;j++){\\n//                 if(w1[i-1] == w2[j-1]){\\n//                     dp[i][j] = dp[i-1][j-1];    \\n//                 }else{\\n//                     dp[i][j] = 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n//                 }\\n                \\n//             }\\n//         }\\n//         return dp[n][m];\\n//     }\\n// };\\n// SPACE OPTIMISATION\\nclass Solution {\\npublic:\\n    int minDistance(string w1, string w2) {\\n        int n = w1.length();\\n        int m = w2.length();\\n        vector<int> curr(m+1,0),prev(m+1,0);\\n        \\n        for(int j=0;j<=m;j++) prev[j] = j;\\n        \\n        for(int i=1;i<=n;i++){\\n            curr[0] = i;\\n            for(int j=1;j<=m;j++){\\n                if(w1[i-1] == w2[j-1]){\\n                    curr[j] = prev[j-1];    \\n                }else{\\n                    curr[j] = 1 + min(prev[j-1],min(prev[j],curr[j-1]));\\n                }\\n                \\n            }\\n            prev = curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571257,
                "title": "simple-python-solution-recursive-and-dp-both-solutions",
                "content": "\\nRecursive (with memoization - lrucache)\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        n = len(word1)\\n        m = len(word2)\\n\\n        @cache\\n        def mdistance(i, j):\\n\\n            if i == n or j == m:\\n                return (m - j) + (n - i) #if i is n, we will need m-j insert operations\\n\\n            operations = min(\\n                mdistance(i + 1, j) + 1, #deletion\\n                mdistance(i, j + 1) + 1, # insertion\\n                mdistance(i + 1, j + 1) + (0 if word1[i] == word2[j] else 1), # if char is not same replace\\n            )\\n            return operations\\n\\n        return mdistance(0, 0)\\n\\n```\\n\\nDP (tabular)\\n\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        n = len(word1)\\n        m = len(word2)\\n\\n        mem = [([0] * (n + 1)) for _ in range(m + 1)]\\n\\n        for i in range(1, m + 1):\\n            mem[i][0] = i\\n        for j in range(1, n + 1):\\n            mem[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                mem[i][j] = min(\\n                    mem[i - 1][j] + 1,\\n                    mem[i][j - 1] + 1,\\n                    mem[i - 1][j - 1] + (0 if word1[j - 1] == word2[i - 1] else 1),\\n                )\\n\\n        return mem[m][n]\\n```\\n\\nTime complexity: `O(n*m)` for both\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        n = len(word1)\\n        m = len(word2)\\n\\n        @cache\\n        def mdistance(i, j):\\n\\n            if i == n or j == m:\\n                return (m - j) + (n - i) #if i is n, we will need m-j insert operations\\n\\n            operations = min(\\n                mdistance(i + 1, j) + 1, #deletion\\n                mdistance(i, j + 1) + 1, # insertion\\n                mdistance(i + 1, j + 1) + (0 if word1[i] == word2[j] else 1), # if char is not same replace\\n            )\\n            return operations\\n\\n        return mdistance(0, 0)\\n\\n```\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        n = len(word1)\\n        m = len(word2)\\n\\n        mem = [([0] * (n + 1)) for _ in range(m + 1)]\\n\\n        for i in range(1, m + 1):\\n            mem[i][0] = i\\n        for j in range(1, n + 1):\\n            mem[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                mem[i][j] = min(\\n                    mem[i - 1][j] + 1,\\n                    mem[i][j - 1] + 1,\\n                    mem[i - 1][j - 1] + (0 if word1[j - 1] == word2[i - 1] else 1),\\n                )\\n\\n        return mem[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344318,
                "title": "reach-form-recursion-to-dp-in-simple-change-in-code",
                "content": "**Recursive Function - **\\n```\\n   int fun(string &s1, string &s2, int n, int m){\\n        if(n == 0)                          // Base Case 1 : If first string is empty return second string len. Because, we need to put all the characters from scratch\\n            return m;                       //               string size convert first into second\\n        else if(m == 0)\\n                return n;                   // Base Case2 2: Vice-Versa of above base case\\n        else if(s1[n - 1] == s2[m - 1])\\n               return fun(s1, s2, n - 1, m - 1); //  when both characters are matched call the function for smaller input by reducing the size of both the strings\\n        else               \\n            return 1 + min({fun(s1,s2, n, m - 1), fun(s1, s2, n - 1, m), fun(s1, s2, n - 1, m - 1)});  // When characters Doesn\\'t match we will perform all the 3 operations insert , delete , replace and give the minimum one.\\n    } \\n```\\nNow let us try to convert the recursive code in dp - In Aditya Verma\\'s style\\uD83D\\uDE0E\\nreplace n with i and m with j in bottom-up dp. In initialization put the values of i and j.\\n```\\n    int minDistance(string str1, string str2) {\\n        int n = str1.size();\\n        int m = str2.size();\\n        \\n        int dp[n+1][m+1];                       //Initialization based on our base condition of recursion.\\n        for(int i = 0 ; i<=n ; i++)\\n            dp[i][0] = i;\\n        for(int j = 0 ; j<=m ; j++)\\n            dp[0][j] = j;\\n\\t\\t\\t\\n\\t\\t\\t//Inserting values in dp table- same as recursion condition.\\n        \\n        for(int i = 1 ; i<=n ; i++){\\n            for(int j = 1 ; j<=m ; j++){\\n                if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + min({dp[i-1][j] , dp[i][j-1] , dp[i-1][j-1]});\\n            }\\n        }\\n        \\n        return dp[n][m];\\n         }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n   int fun(string &s1, string &s2, int n, int m){\\n        if(n == 0)                          // Base Case 1 : If first string is empty return second string len. Because, we need to put all the characters from scratch\\n            return m;                       //               string size convert first into second\\n        else if(m == 0)\\n                return n;                   // Base Case2 2: Vice-Versa of above base case\\n        else if(s1[n - 1] == s2[m - 1])\\n               return fun(s1, s2, n - 1, m - 1); //  when both characters are matched call the function for smaller input by reducing the size of both the strings\\n        else               \\n            return 1 + min({fun(s1,s2, n, m - 1), fun(s1, s2, n - 1, m), fun(s1, s2, n - 1, m - 1)});  // When characters Doesn\\'t match we will perform all the 3 operations insert , delete , replace and give the minimum one.\\n    } \\n```\n```\\n    int minDistance(string str1, string str2) {\\n        int n = str1.size();\\n        int m = str2.size();\\n        \\n        int dp[n+1][m+1];                       //Initialization based on our base condition of recursion.\\n        for(int i = 0 ; i<=n ; i++)\\n            dp[i][0] = i;\\n        for(int j = 0 ; j<=m ; j++)\\n            dp[0][j] = j;\\n\\t\\t\\t\\n\\t\\t\\t//Inserting values in dp table- same as recursion condition.\\n        \\n        for(int i = 1 ; i<=n ; i++){\\n            for(int j = 1 ; j<=m ; j++){\\n                if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + min({dp[i-1][j] , dp[i][j-1] , dp[i-1][j-1]});\\n            }\\n        }\\n        \\n        return dp[n][m];\\n         }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1608072,
                "title": "c-clean-recursive-dp-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dp;\\n    \\n    int recurs(string& word1, string& word2,int i,int j)\\n    {\\n        if(i>=word1.size()&&j>=word2.size())\\n             return 0;\\n        \\n        if(i>=word1.size())\\n             return word2.size()-j; // all remaining need to be added\\n        \\n        if(j>=word2.size())\\n             return word1.size()-i; // all remaining need to be removed\\n        \\n        if(dp[i][j]!=-1)\\n              return dp[i][j];\\n        \\n        if(word1[i]==word2[j])\\n             return dp[i][j]=recurs(word1,word2,i+1,j+1);\\n        else\\n        {\\n            int a=recurs(word1,word2,i+1,j+1)+1;//replace\\n            int b=recurs(word1,word2,i+1,j)+1;//delete\\n            int c=recurs(word1,word2,i,j+1)+1;//insert\\n            c=min(b,c);\\n            return dp[i][j]=min(a,c);\\n        }\\n        \\n       \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    int minDistance(string word1, string word2) {\\n        dp.resize(word1.size(),vector<int>(word2.size(),-1));\\n        \\n        return recurs(word1,word2,0,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dp;\\n    \\n    int recurs(string& word1, string& word2,int i,int j)\\n    {\\n        if(i>=word1.size()&&j>=word2.size())\\n             return 0;\\n        \\n        if(i>=word1.size())\\n             return word2.size()-j; // all remaining need to be added\\n        \\n        if(j>=word2.size())\\n             return word1.size()-i; // all remaining need to be removed\\n        \\n        if(dp[i][j]!=-1)\\n              return dp[i][j];\\n        \\n        if(word1[i]==word2[j])\\n             return dp[i][j]=recurs(word1,word2,i+1,j+1);\\n        else\\n        {\\n            int a=recurs(word1,word2,i+1,j+1)+1;//replace\\n            int b=recurs(word1,word2,i+1,j)+1;//delete\\n            int c=recurs(word1,word2,i,j+1)+1;//insert\\n            c=min(b,c);\\n            return dp[i][j]=min(a,c);\\n        }\\n        \\n       \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    int minDistance(string word1, string word2) {\\n        dp.resize(word1.size(),vector<int>(word2.size(),-1));\\n        \\n        return recurs(word1,word2,0,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603750,
                "title": "memoized-commented-solution",
                "content": "class Solution {\\npublic:\\n    \\n    string w1, w2;\\n    \\n    int dp[505][505];\\n    \\n    int solve(int i, int j){\\n        int ans = INT_MAX;\\n        \\n        if(i==w1.length() && j<w2.length()){\\n            //use insert op\\n            return dp[i][j]= min(ans,1+solve(i,j+1));\\n        }\\n        \\n        if(j==w2.length() && i<w1.length()){\\n            //use delete op\\n            return dp[i][j]= min(ans,1+solve(i+1,j));\\n        }\\n        \\n        if(i==w1.length() && j==w2.length()){\\n            return dp[i][j]=0;\\n        }\\n        \\n        if(dp[i][j]!=INT_MAX){\\n            return dp[i][j];\\n        }\\n        \\n        if(w1[i]==w2[j]){\\n            ans = min(ans,solve(i+1,j+1));\\n        }\\n        else{\\n            //insert\\n            ans = min(ans,1+solve(i,j+1));\\n            //delete\\n            ans = min(ans,1+solve(i+1,j));\\n            //replace\\n            ans = min(ans,1+solve(i+1,j+1));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        //O(N^2)\\n        w1 = word1;\\n        w2 = word2;\\n        for(int i=0;i<505;i++){\\n            for(int j=0;j<505;j++){\\n                dp[i][j]=INT_MAX;\\n            }\\n        }\\n        return solve(0,0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    string w1, w2;\\n    \\n    int dp[505][505];\\n    \\n    int solve(int i, int j){\\n        int ans = INT_MAX;\\n        \\n        if(i==w1.length() && j<w2.length()){\\n            //use insert op\\n            return dp[i][j]= min(ans,1+solve(i,j+1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1413460,
                "title": "c-o-n-n-time-o-n-n-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        // Code here\\n        // This is a dp arroach :\\n        int n = s.size();\\n        int m = t.size();\\n        int dp[n+1][m+1];\\n        // dp[i][j] => edit distance for the string s[0...i-1] && t[0...j-1];\\n        for(int i=0;i<n+1;i++)\\n        {\\n            dp[i][0] = i;\\n        }\\n        for(int j=0;j<m+1;j++)\\n        {\\n            dp[0][j] = j;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1] == t[j-1])\\n                dp[i][j] = dp[i-1][j-1];\\n                else\\n                {\\n                    dp[i][j] = 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n        \\n    \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        // Code here\\n        // This is a dp arroach :\\n        int n = s.size();\\n        int m = t.size();\\n        int dp[n+1][m+1];\\n        // dp[i][j] => edit distance for the string s[0...i-1] && t[0...j-1];\\n        for(int i=0;i<n+1;i++)\\n        {\\n            dp[i][0] = i;\\n        }\\n        for(int j=0;j<m+1;j++)\\n        {\\n            dp[0][j] = j;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1] == t[j-1])\\n                dp[i][j] = dp[i-1][j-1];\\n                else\\n                {\\n                    dp[i][j] = 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368674,
                "title": "java-using-dp-simple-and-clean",
                "content": "```\\nclass Solution {\\n    public int minDistance(String s, String t) {\\n\\t\\tif (s.isEmpty() || t.isEmpty())\\n\\t\\t\\treturn Math.max(s.length(), t.length());\\n\\t\\tint[][] dp = new int[s.length() + 1][t.length() + 1];\\n\\t\\tfor (int i = 0; i < t.length() + 1; i++) dp[0][i] = i;\\n\\t\\tfor (int i = 0; i < s.length() + 1; i++) dp[i][0] = i;\\n\\t\\tfor (int i = 1; i < s.length() + 1; i++) {\\n\\t\\t\\tfor (int j = 1; j < t.length() + 1; j++) {\\n\\t\\t\\t\\tif (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\telse dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[s.length()][t.length()];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String s, String t) {\\n\\t\\tif (s.isEmpty() || t.isEmpty())\\n\\t\\t\\treturn Math.max(s.length(), t.length());\\n\\t\\tint[][] dp = new int[s.length() + 1][t.length() + 1];\\n\\t\\tfor (int i = 0; i < t.length() + 1; i++) dp[0][i] = i;\\n\\t\\tfor (int i = 0; i < s.length() + 1; i++) dp[i][0] = i;\\n\\t\\tfor (int i = 1; i < s.length() + 1; i++) {\\n\\t\\t\\tfor (int j = 1; j < t.length() + 1; j++) {\\n\\t\\t\\t\\tif (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\telse dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[s.length()][t.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077256,
                "title": "recursion-dp",
                "content": "recursion, exponential\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        return recur(word1,word2,0,0);\\n    }\\n    \\n    int recur(String word1, String word2, int index1, int index2) {\\n        int n1 = word1.length(), n2 = word2.length();\\n        if(n2==index2) return n1-index1;\\n        if(n1==index1) return n2-index2;\\n        \\n        if(word1.charAt(index1)== word2.charAt(index2)) {\\n            return recur(word1,word2,index1+1,index2+1);\\n        } else {\\n            int c1 = 1+recur(word1, word2,index1,index2+1); //insert\\n            int c2 = 1+recur(word1, word2,index1+1,index2); //delete\\n            int c3 = 1+recur(word1, word2,index1+1,index2+1); //replace\\n            return Math.min(c1,Math.min(c2,c3));\\n        }\\n    }\\n}\\n```\\ndp, time = O(mn), space = O(mn)\\n```\\nclass Solution {\\n\\n    public int minDistance(String word1, String word2) {\\n        \\n        int n1= word1.length(), n2=word2.length();\\n        if(n1==0) return n2;\\n        if(n2==0) return n1;\\n        int[][] dp = new int[n1+1][n2+1];\\n        //base\\n         for(int i =0;i<n1+1;i++)  {    \\n            dp[i][0] = i; //delete \\n         }\\n\\n         for(int j =0;j<n2+1;j++)  {    \\n            dp[0][j] = j; //add \\n         }\\n         \\n        for(int i = 1;i<n1+1; i++) {\\n            for(int j = 1;j<n2+1; j++) {\\n            \\n                if(word1.charAt(i-1) ==word2.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    int c1 = dp[i-1][j]; //insert \\n                    int c2 = dp[i][j-1]; //delete\\n                    int c3 = dp[i-1][j-1]; //replace            \\n                    dp[i][j] =1+ Math.min(Math.min(c1,c2),c3);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        return recur(word1,word2,0,0);\\n    }\\n    \\n    int recur(String word1, String word2, int index1, int index2) {\\n        int n1 = word1.length(), n2 = word2.length();\\n        if(n2==index2) return n1-index1;\\n        if(n1==index1) return n2-index2;\\n        \\n        if(word1.charAt(index1)== word2.charAt(index2)) {\\n            return recur(word1,word2,index1+1,index2+1);\\n        } else {\\n            int c1 = 1+recur(word1, word2,index1,index2+1); //insert\\n            int c2 = 1+recur(word1, word2,index1+1,index2); //delete\\n            int c3 = 1+recur(word1, word2,index1+1,index2+1); //replace\\n            return Math.min(c1,Math.min(c2,c3));\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public int minDistance(String word1, String word2) {\\n        \\n        int n1= word1.length(), n2=word2.length();\\n        if(n1==0) return n2;\\n        if(n2==0) return n1;\\n        int[][] dp = new int[n1+1][n2+1];\\n        //base\\n         for(int i =0;i<n1+1;i++)  {    \\n            dp[i][0] = i; //delete \\n         }\\n\\n         for(int j =0;j<n2+1;j++)  {    \\n            dp[0][j] = j; //add \\n         }\\n         \\n        for(int i = 1;i<n1+1; i++) {\\n            for(int j = 1;j<n2+1; j++) {\\n            \\n                if(word1.charAt(i-1) ==word2.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    int c1 = dp[i-1][j]; //insert \\n                    int c2 = dp[i][j-1]; //delete\\n                    int c3 = dp[i-1][j-1]; //replace            \\n                    dp[i][j] =1+ Math.min(Math.min(c1,c2),c3);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043703,
                "title": "java-recursion-memoization-explanation",
                "content": "## For any DP question there are 2 parts: \\n1) Base case: Always think of what the smallest possible input could be. In our case, lengths of string word1 and word2 (let M = length of word1 & N = length of word2).\\nSo, base case is if(M==0 || N==0). \\nIf M==0, we simply insert all n characters of word2 into it and return N.\\nIf N==0, we simply delete all m characters in word2 and return M.\\nBasically we return Max(M,N). If both are 0, it returns 0.\\n\\n2) Choice tree\\nLet\\'s say at an instant we have the first m characters of word1 and the first n characters of word2. How do we solve the question for this instance? ```minDist(word1, word2, m, n)  ```\\nOur strategy is to keep on reducing the input step-by-step and check the last characters of both the inputs. For the last characters, we have 2 possibilities.\\n* Both characters are same ( word1.charAt(m) == word2.charAt(n) )\\nWe don\\'t need any operation because both characters are same.\\nSimply reduce the input length and return ```minDist(word1, word2, m-1, n-1) ```\\n* Characters are different  ( word1.charAt(m-1) != word2.charAt(n-1) )\\nNow we have 3 possibilities:\\n\\t1.  Insert the character word2.charAt(n) after the current index \\'m\\' of word1 \\n\\tSince we inserted a new character in word1 to match word2.charAt(n). keep m same and reduce n by 1. ```return 1 + minDist(word1, word2, m, n-1)``` (1 is the cost of the insertion operation).\\n\\t2.  Delete the character word1.charAt(m). \\n\\tSince we deleted a character from word1 because it didn\\'t match with word2.charAt(n).\\n\\tDecrease m by 1 and keep n the same. ```return 1 + minDist(word1, word2, m-1, n)``` (1 is the cost of the deletion operation). \\n\\t3.  Substitute the character word1.charAt(m) with word2.charAt(n). Decrease m and n both by 1. ```return 1 + minDist(word1, word2, m-1, n-1)``` (1 is the cost of the substitution operation). \\n\\n\\tNow, simply take the minimum of what these 3 possibilities and return it as the answer for this instance of the function call ```minDist(word1, word2, m, n)```\\n\\tThen just use a 2D matrix(dp) to store the solution for memoization.\\n\\tTime complexity: O(MN)\\n```\\n\\tpublic int minDist(String x, String y, int m, int n, int dp[][]){\\n        if(m==0 || n==0)\\n            return Math.max(m,n);\\n        if(x.charAt(m-1)==y.charAt(n-1))\\n            return minDist(x,y,m-1,n-1, dp);\\n    \\n        if(dp[m][n-1]==-1) dp[m][n-1] = 1+minDist(x, y, m, n-1, dp);\\n        if(dp[m-1][n]==-1) dp[m-1][n] = 1+minDist(x, y, m-1, n, dp);\\n        if(dp[m-1][n-1]==-1) dp[m-1][n-1] = 1+minDist(x, y, m-1, n-1, dp);\\n        \\n        return dp[m][n] = Math.min(Math.min(dp[m-1][n-1],dp[m-1][n]), dp[m][n-1]);\\n        \\n    }\\n    public int minDistance(String word1, String word2) {\\n        int m=word1.length(), n=word2.length();\\n        int t[][]=new int[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n            for(int j=0;j<=n;j++)\\n                t[i][j]=-1;\\n        return minDist(word1, word2, m, n, t);\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```minDist(word1, word2, m, n)  ```\n```minDist(word1, word2, m-1, n-1) ```\n```return 1 + minDist(word1, word2, m, n-1)```\n```return 1 + minDist(word1, word2, m-1, n)```\n```return 1 + minDist(word1, word2, m-1, n-1)```\n```minDist(word1, word2, m, n)```\n```\\n\\tpublic int minDist(String x, String y, int m, int n, int dp[][]){\\n        if(m==0 || n==0)\\n            return Math.max(m,n);\\n        if(x.charAt(m-1)==y.charAt(n-1))\\n            return minDist(x,y,m-1,n-1, dp);\\n    \\n        if(dp[m][n-1]==-1) dp[m][n-1] = 1+minDist(x, y, m, n-1, dp);\\n        if(dp[m-1][n]==-1) dp[m-1][n] = 1+minDist(x, y, m-1, n, dp);\\n        if(dp[m-1][n-1]==-1) dp[m-1][n-1] = 1+minDist(x, y, m-1, n-1, dp);\\n        \\n        return dp[m][n] = Math.min(Math.min(dp[m-1][n-1],dp[m-1][n]), dp[m][n-1]);\\n        \\n    }\\n    public int minDistance(String word1, String word2) {\\n        int m=word1.length(), n=word2.length();\\n        int t[][]=new int[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n            for(int j=0;j<=n;j++)\\n                t[i][j]=-1;\\n        return minDist(word1, word2, m, n, t);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313920,
                "title": "c-96-beaten-using-dp-o-n-m-quadratic-speed-using-smart-lawz-kaboom",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        \\n        int aGrid[word1.size() + 1][word2.size() + 1];\\n        memset(aGrid, 0, sizeof(aGrid));\\n        \\n        aGrid[0][0] = 0;\\n        for (int x=1;x<=word1.size();x++) { aGrid[x][0] = x; }\\n        for (int y=1;y<=word2.size();y++) { aGrid[0][y] = y; }\\n        \\n        for (int x=1;x<=word1.size();x++) {\\n            for (int y=1;y<=word2.size();y++) {\\n                if (word1[x-1] == word2[y-1]) {\\n                    aGrid[x][y] = aGrid[x-1][y-1];\\n                } else {   \\n                    aGrid[x][y] = 1 + min(aGrid[x-1][y-1], min(aGrid[x-1][y], aGrid[x][y-1]));\\n                }\\n            }\\n        }\\n        \\n        return aGrid[word1.size()][word2.size()];\\n    }\\n};\\n```\\n\\nShip it in, ship it out. Now you\\'re on the payroll, living large. Boom, baby.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        \\n        int aGrid[word1.size() + 1][word2.size() + 1];\\n        memset(aGrid, 0, sizeof(aGrid));\\n        \\n        aGrid[0][0] = 0;\\n        for (int x=1;x<=word1.size();x++) { aGrid[x][0] = x; }\\n        for (int y=1;y<=word2.size();y++) { aGrid[0][y] = y; }\\n        \\n        for (int x=1;x<=word1.size();x++) {\\n            for (int y=1;y<=word2.size();y++) {\\n                if (word1[x-1] == word2[y-1]) {\\n                    aGrid[x][y] = aGrid[x-1][y-1];\\n                } else {   \\n                    aGrid[x][y] = 1 + min(aGrid[x-1][y-1], min(aGrid[x-1][y], aGrid[x][y-1]));\\n                }\\n            }\\n        }\\n        \\n        return aGrid[word1.size()][word2.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301791,
                "title": "wrong-test-case",
                "content": "Hi guys, I think this case is wrong. \\n```\\nInput:\\n\"zoologicoarchaeologist\"\\n\"zoogeologist\"\\nOutput:\\n9\\nExpected:\\n10\\n```\\nThe expected response should be 9. I confirmed it with different methods:\\n* Online Levenshtein calculator: https://planetcalc.com/1721/\\n* Manual:\\n![image](https://assets.leetcode.com/users/no6thing/image_1559170315.png)\\n\\nWhat you think?\\n\\n",
                "solutionTags": [],
                "code": "```\\nInput:\\n\"zoologicoarchaeologist\"\\n\"zoogeologist\"\\nOutput:\\n9\\nExpected:\\n10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227181,
                "title": "javascript-solution",
                "content": "```\\nvar minDistance = function(word1, word2) {\\n    const dp = initializeDp(word1, word2)\\n    constructDp(dp, word1, word2)\\n    return dp[word1.length][word2.length]\\n}\\n\\nconst initializeDp = (word1, word2) => {\\n    const dp = Array(word1.length + 1).fill().map(() => Array(word2.length + 1).fill())\\n    const rows = dp.length\\n    const cols = dp[0].length\\n    for (let i = 0; i < rows; i++) {\\n        dp[i][0] = i\\n    }\\n    for (let i = 1; i < cols; i++) {\\n        dp[0][i] = i\\n    }\\n    return dp\\n}\\n\\nconst constructDp = (dp, word1, word2) => {\\n    const rows = dp.length\\n    const cols = dp[0].length\\n    for (let i = 1; i < rows; i++) {\\n        for (let j = 1; j < cols; j++) {\\n            if (word1[i - 1] === word2[j - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1]\\n            } else {\\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDistance = function(word1, word2) {\\n    const dp = initializeDp(word1, word2)\\n    constructDp(dp, word1, word2)\\n    return dp[word1.length][word2.length]\\n}\\n\\nconst initializeDp = (word1, word2) => {\\n    const dp = Array(word1.length + 1).fill().map(() => Array(word2.length + 1).fill())\\n    const rows = dp.length\\n    const cols = dp[0].length\\n    for (let i = 0; i < rows; i++) {\\n        dp[i][0] = i\\n    }\\n    for (let i = 1; i < cols; i++) {\\n        dp[0][i] = i\\n    }\\n    return dp\\n}\\n\\nconst constructDp = (dp, word1, word2) => {\\n    const rows = dp.length\\n    const cols = dp[0].length\\n    for (let i = 1; i < rows; i++) {\\n        for (let j = 1; j < cols; j++) {\\n            if (word1[i - 1] === word2[j - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1]\\n            } else {\\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25954,
                "title": "uses-longest-increasing-subsequence-subset-enumeration-dfs",
                "content": "My solution finds the longest matching pattern of string 1 in  string 2. \\nSo for word1 = \"adbac\" and word2 = \"abc\" , the longest matching pattern (not necessarily continuous) is \"abc\" \\nHow ? we can remove 'd' & second 'a' from \"adbac\" to get \"abc\". \\nThe way I find the longest matching pattern is through longest increasing subsequence . (standard dp)          \\nAfter than, the minimum can be found using simple math.\\n\\n\\n    public class Solution {\\n    \\n    List<List<Integer>> sequences = new ArrayList<List<Integer>>();\\n    void printer(List<Integer> seq){\\n        for(int i=0;i<seq.size();i++)\\n            System.out.print(seq.get(i) + \" \");\\n        System.out.println();\\n    }\\n    void form(int cur,List<Integer> sequence,List<List<Integer>>array){\\n        if(cur == array.size()){\\n            List<Integer> copy = new ArrayList<Integer>();\\n            for(int i=0; i<sequence.size();i++)\\n                copy.add(sequence.get(i));\\n            sequences.add(copy);\\n            return;\\n        }\\n        List<Integer> options = array.get(cur);\\n        for(int i=0;i<options.size();i++){\\n            sequence.add(options.get(i));\\n            form(cur+1,sequence,array);\\n            sequence.remove(sequence.size()-1);\\n        }\\n    }\\n    \\n    # find longest increasing subsequence for a given sequence\\n    List<Integer> get_lis (List<Integer> sequence){\\n        List<Integer> dp = new ArrayList<Integer>();\\n        Map<Integer,Integer> path = new HashMap<Integer,Integer>();\\n        List<Integer> lis = new ArrayList<Integer>();\\n        dp.add(1);\\n        path.put(0,-1);\\n        int maxpos = 0;\\n        for(int i=1;i<sequence.size();i++){\\n            if(sequence.get(i) == -1){\\n                dp.add(-1);\\n                continue;\\n            }\\n            dp.add(1);\\n            path.put(i,-1);\\n            for(int j=0;j<i;j++){\\n                if(sequence.get(j) < sequence.get(i) && dp.get(j) >= dp.get(i)){\\n                    dp.set(i,dp.get(j)+1);\\n                    path.put(i,j);\\n                }\\n            }\\n            if(dp.get(i)>dp.get(maxpos))\\n                maxpos = i;\\n        }\\n        Set<Integer> in_lis = new HashSet<Integer>();\\n        int pos = maxpos;\\n        while(true){\\n            if(pos == -1)\\n                break;\\n            in_lis.add(pos);\\n            pos = path.get(pos);\\n        }\\n        int count = 0;\\n        for(int i=0;i<sequence.size();i++){\\n            if(in_lis.contains(i)){\\n                lis.add(sequence.get(i));\\n                count++;\\n            }\\n            else\\n                lis.add(-1);\\n        }\\n        lis.add(count);\\n        return lis;\\n    }\\n    \\n    public int minDistance(String word1, String word2) {\\n        \\n       # form a map from characters that appear in word2 to a list of indices they appear in\\n        \\n        HashMap<Character,List<Integer>> map = new HashMap<Character,List<Integer>>();\\n        for(int i=0;i<word2.length();i++){\\n            char c = word2.charAt(i);\\n            if(!map.containsKey(c)){\\n                ArrayList<Integer> l = new ArrayList<Integer>();\\n                l.add(i);\\n                map.put(c,l);\\n            }\\n            else{\\n                List<Integer> l = map.get(c);\\n                l.add(i);\\n            }\\n        }\\n        \\n        # form a map from each index in word1 to the possible positions of that character in word2\\n        List<List<Integer>> array = new ArrayList<List<Integer>>();\\n        for(int i=0;i<word1.length();i++){\\n            char c = word1.charAt(i);\\n            List<Integer> l;\\n            if(!map.containsKey(c)){\\n               l = new ArrayList<Integer>();\\n               l.add(-1);\\n            }\\n            else\\n                l = map.get(c);\\n            array.add(l);\\n        }\\n        \\n        \\n        List<Integer> sequence = new ArrayList<Integer>();      #empty sequence just for the purpose of DFS\\n        \\n        # from the above map, each index in word1 can have multiple values. For example, for word1 = \"abc\"\\n        and word2 = \"aad\" , the values for index 0 ('a') for word1 are 0 and 1, because  'a' appears at\\n        indices 0 and 1 in word2. So we form all sequences for all possible values of each index of word1.\\n        \\n        form(0,sequence,array);                 # form all possible sequences\\n        \\n        \\n        # the following part gets the maximum longest possible subsequence from all possible sequences\\n        List<Integer> final_lis = new ArrayList<Integer>();\\n        int maxlen=0;\\n        for(int i=0; i<sequences.size();i++){\\n            sequence = sequences.get(i);\\n            List<Integer> lis = get_lis(sequence);\\n            int lislen = lis.get(lis.size()-1);\\n            if(lislen>maxlen){\\n                maxlen = lislen;\\n                lis.remove(lis.size()-1);\\n                final_lis = lis;\\n            }\\n        }\\n        \\n        #simple math to get the final answer\\n        int answer = 0;\\n        int i=0;\\n        int previ=0;\\n        int prevval=0;\\n        while(i<final_lis.size()){\\n            if(final_lis.get(i) == -1){\\n                i++;\\n                continue;\\n            }\\n            \\n            int diff1 = final_lis.get(i) - prevval -1;\\n            int diff2 = i - previ -1;\\n            answer += Math.max(diff1,diff2);\\n            previ = i;\\n            prevval = final_lis.get(i);\\n            i++;\\n        }\\n        \\n        int diff1 = word1.length() - previ;\\n        int diff2 = word2.length() - prevval;\\n        answer += Math.max(diff1,diff2);\\n        return answer;\\n    }\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    List<List<Integer>> sequences = new ArrayList<List<Integer>>();\\n    void printer(List<Integer> seq){\\n        for(int i=0;i<seq.size();i++)\\n            System.out.print(seq.get(i) + \" \");\\n        System.out.println();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3926498,
                "title": "python-91-89-faster-dp-memoization-tabulation",
                "content": "```\\n\\'\\'\\'\\nExample: s1: \\'horse\\'\\n         s2: \\'ros\\'\\n\\nCase1: Inserting a Character\\n\\nNow if we have to match the strings by insertions, what would we do?: \\n\\nWe would have placed an \\u2018s\\u2019 at index 5 of S1.\\nSuppose i now point to s at index 5 of S1 and j points are already pointing to s at index j of S2.\\nNow, we hit the condition, where characters do match. (as mentioned in case 1).\\nTherefore, we will decrement i and j by 1. They will now point to index 4 and 1 respectively.\\n\\nNow, the number of operations we did were only 1 (inserting s at index 5) but do we need to really insert the \\u2018s\\u2019 at index 5 and modify the string? The answer is simply NO. As we see that inserting a character (here \\u2018s\\u2019 at index 5), we will eventually get to the third step. So we can just return 1+ f(i,j-1) as i remains there only after insertion and j decrements by 1. We can say that we have hypothetically inserted character s.\\n\\nCase 2: Deleting a character \\n\\nConsider the same example,\\n\\nWe can simply delete the character at index 4 and check from the next index.\\n\\nNow, j remains at its original index and we decrement i by 1. We perform 1 operation, therefore we will recursively call 1+f(i-1,j).\\n\\nCase3: Replacing a character \\n\\nConsider the same example,\\n\\n\\nIf we replace the character \\u2018e\\u2019 at index 4 of S1 with \\u2018s\\u2019, we have matched both the characters ourselves. We again hit the case of character matching, therefore we decrement both i and j by 1. As the number of operations performed is 1, we will return 1+f(i-1,j-1).\\n\\nTo summarise, these are the three choices we have in case characters don\\u2019t match:\\n\\nreturn 1+f(i-1,j) // Insertion of character.\\nreturn 1+f(i,j-1) // Deletion of character.\\nreturn 1+f(i-1,j-1) // Replacement of character.\\n\\'\\'\\'\\n\\n#Recursion \\n#Time Complexity: O(2^(m+n))\\n#Space Complexity: O(m+n)\\nclass Solution1:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def solve(i,j):\\n            if i==0:\\n                return j\\n            if j==0:\\n                return i\\n            if word1[i-1]==word2[j-1]:\\n                return solve(i-1,j-1)\\n            else:\\n                return 1 + min(solve(i,j-1),solve(i-1,j),solve(i-1,j-1))\\n        m,n=len(word1),len(word2)\\n        return solve(m,n)\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(m*n)\\n#Space Complexity: O(m+n) + O(m*n)\\nclass Solution2:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def solve(i,j):\\n            if i==0:\\n                return j\\n            if j==0:\\n                return i\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            if word1[i-1]==word2[j-1]:\\n                dp[i][j]=solve(i-1,j-1)\\n                return dp[i][j]\\n            else:\\n                dp[i][j]=1 + min(solve(i,j-1),solve(i-1,j),solve(i-1,j-1))\\n                return dp[i][j]\\n        m,n=len(word1),len(word2)\\n        dp=[[-1 for j in range(n+1)] for i in range(m+1)]\\n        return solve(m,n)\\n    \\nclass Solution3:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m,n = len(word1),len(word2)\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        for i in range(m+1):\\n            dp[i][0] = i\\n        for j in range(n+1):\\n            dp[0][j] = j\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\\n        return dp[m][n]\\n    \\n#Space Optimization\\n#Time Complexity: O(m*n)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m,n = len(word1),len(word2)\\n        prev=[0]*(n+1)\\n        curr=[0]*(n+1)\\n        for j in range(n+1):\\n            prev[j]=j\\n        for i in range(1,m+1):\\n            curr[0]=i\\n            for j in range(1,n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    curr[j] = prev[j-1]\\n                else:\\n                    curr[j] = 1 + min(prev[j-1], prev[j], curr[j-1])\\n            prev=curr[:]\\n        return prev[n]\\n```\\n**An upovte will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\'\\'\\'\\nExample: s1: \\'horse\\'\\n         s2: \\'ros\\'\\n\\nCase1: Inserting a Character\\n\\nNow if we have to match the strings by insertions, what would we do?: \\n\\nWe would have placed an \\u2018s\\u2019 at index 5 of S1.\\nSuppose i now point to s at index 5 of S1 and j points are already pointing to s at index j of S2.\\nNow, we hit the condition, where characters do match. (as mentioned in case 1).\\nTherefore, we will decrement i and j by 1. They will now point to index 4 and 1 respectively.\\n\\nNow, the number of operations we did were only 1 (inserting s at index 5) but do we need to really insert the \\u2018s\\u2019 at index 5 and modify the string? The answer is simply NO. As we see that inserting a character (here \\u2018s\\u2019 at index 5), we will eventually get to the third step. So we can just return 1+ f(i,j-1) as i remains there only after insertion and j decrements by 1. We can say that we have hypothetically inserted character s.\\n\\nCase 2: Deleting a character \\n\\nConsider the same example,\\n\\nWe can simply delete the character at index 4 and check from the next index.\\n\\nNow, j remains at its original index and we decrement i by 1. We perform 1 operation, therefore we will recursively call 1+f(i-1,j).\\n\\nCase3: Replacing a character \\n\\nConsider the same example,\\n\\n\\nIf we replace the character \\u2018e\\u2019 at index 4 of S1 with \\u2018s\\u2019, we have matched both the characters ourselves. We again hit the case of character matching, therefore we decrement both i and j by 1. As the number of operations performed is 1, we will return 1+f(i-1,j-1).\\n\\nTo summarise, these are the three choices we have in case characters don\\u2019t match:\\n\\nreturn 1+f(i-1,j) // Insertion of character.\\nreturn 1+f(i,j-1) // Deletion of character.\\nreturn 1+f(i-1,j-1) // Replacement of character.\\n\\'\\'\\'\\n\\n#Recursion \\n#Time Complexity: O(2^(m+n))\\n#Space Complexity: O(m+n)\\nclass Solution1:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def solve(i,j):\\n            if i==0:\\n                return j\\n            if j==0:\\n                return i\\n            if word1[i-1]==word2[j-1]:\\n                return solve(i-1,j-1)\\n            else:\\n                return 1 + min(solve(i,j-1),solve(i-1,j),solve(i-1,j-1))\\n        m,n=len(word1),len(word2)\\n        return solve(m,n)\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(m*n)\\n#Space Complexity: O(m+n) + O(m*n)\\nclass Solution2:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def solve(i,j):\\n            if i==0:\\n                return j\\n            if j==0:\\n                return i\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            if word1[i-1]==word2[j-1]:\\n                dp[i][j]=solve(i-1,j-1)\\n                return dp[i][j]\\n            else:\\n                dp[i][j]=1 + min(solve(i,j-1),solve(i-1,j),solve(i-1,j-1))\\n                return dp[i][j]\\n        m,n=len(word1),len(word2)\\n        dp=[[-1 for j in range(n+1)] for i in range(m+1)]\\n        return solve(m,n)\\n    \\nclass Solution3:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m,n = len(word1),len(word2)\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        for i in range(m+1):\\n            dp[i][0] = i\\n        for j in range(n+1):\\n            dp[0][j] = j\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\\n        return dp[m][n]\\n    \\n#Space Optimization\\n#Time Complexity: O(m*n)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m,n = len(word1),len(word2)\\n        prev=[0]*(n+1)\\n        curr=[0]*(n+1)\\n        for j in range(n+1):\\n            prev[j]=j\\n        for i in range(1,m+1):\\n            curr[0]=i\\n            for j in range(1,n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    curr[j] = prev[j-1]\\n                else:\\n                    curr[j] = 1 + min(prev[j-1], prev[j], curr[j-1])\\n            prev=curr[:]\\n        return prev[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759099,
                "title": "c-solution-using-memoization-with-explaination",
                "content": "# Approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Perameters**\\nHere we are maintaining 2 indexes.i1 is for s1 and i2 is for s2.\\nn1 is size of s1 and n2 is size of s2.\\n\\n- **All possiblities**\\n\\nwe have 2 possiblites for each of the indexes.\\n1.first is if both indexes contains smae character if it is then we increase both of the indexes.\\n2.If it is not then\\nwe can do one of 3 operations.\\n1)insert 2)replace 3)delete\\n-->for insertion : When performing an insertion operation, we assume that we have added the character s2[i2] at the position s1[i1] in s1. At this point, both s1[i1] and s2[i2] contain the same character.\\nIdeally, since both indexes should cover the same characters, we would increase both i1 and i2. However, in this case, we are considering the modified s1, which hypothetically has one additional character. But since we are not actually changing s1, we do not increment i1. Instead, we only increment i2 to move to the next character in s2.\\n\\n-->for deletion we assume we have deleted s1[i1] so we increment by 1.\\n\\n-->for replacement we assume we replace s1[i1] is replaced by s2[i2] so we increment both i1 and i2.\\n\\n- **Base cases**\\n\\ni1>=n1 : we can understand this base cases by one example\\n\\ns1 : horse\\ns2 : ros\\n\\nsuppose we delete all the element of s1 so now our i1 is pointing to n1 and i2 is pointing to 0.as we have delete all the element of s1 now we have to insert all the element of s2. so number of operation should be size of s2 this base case will cover all of these scenario.\\n so it will return n2-0 which is n2. which is our answer.\\n\\ni2>=n2 : for same example \\n\\nsuppose we insert all the element of s2 into s1 but we haven\\'t deleted any of the element of s2.so now we have to delete all the old characters of n2 . this base cases will cover all of these kind of scenario. so it will return n1-0 which is n1. which is our answer.\\n\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n1 * n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n1 * n2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int i1,int i2,string s1,string s2,int n1,int n2,vector<vector<int>>& dp)\\n    {\\n        if(i1>=n1)\\n            return n2-i2;\\n        if(i2>=n2)\\n            return n1-i1;\\n        if(dp[i1][i2]!=-1)\\n            return dp[i1][i2];\\n        if(s1[i1]==s2[i2])\\n            return helper(i1+1,i2+1,s1,s2,n1,n2,dp);\\n        int insert=helper(i1,i2+1,s1,s2,n1,n2,dp);\\n        int del=helper(i1+1,i2,s1,s2,n1,n2,dp);\\n        int rep=helper(i1+1,i2+1,s1,s2,n1,n2,dp);\\n        return dp[i1][i2]=1+min(insert,min(del,rep));\\n    }\\n    int minDistance(string word1, string word2) {\\n        \\n        int n1=word1.size();\\n        int n2=word2.size();\\n        vector<vector<int>> dp(n1,vector<int>(n2,-1));\\n        return helper(0,0,word1,word2,n1,n2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i1,int i2,string s1,string s2,int n1,int n2,vector<vector<int>>& dp)\\n    {\\n        if(i1>=n1)\\n            return n2-i2;\\n        if(i2>=n2)\\n            return n1-i1;\\n        if(dp[i1][i2]!=-1)\\n            return dp[i1][i2];\\n        if(s1[i1]==s2[i2])\\n            return helper(i1+1,i2+1,s1,s2,n1,n2,dp);\\n        int insert=helper(i1,i2+1,s1,s2,n1,n2,dp);\\n        int del=helper(i1+1,i2,s1,s2,n1,n2,dp);\\n        int rep=helper(i1+1,i2+1,s1,s2,n1,n2,dp);\\n        return dp[i1][i2]=1+min(insert,min(del,rep));\\n    }\\n    int minDistance(string word1, string word2) {\\n        \\n        int n1=word1.size();\\n        int n2=word2.size();\\n        vector<vector<int>> dp(n1,vector<int>(n2,-1));\\n        return helper(0,0,word1,word2,n1,n2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753229,
                "title": "tabulation-dp-c-easy-to-understand",
                "content": "### Please upvote if you found it useful!\\n\\n```\\n    int minDistance(string word1, string word2) {\\n        const int l1 = word1.size();\\n        const int l2 = word2.size();\\n        vector<vector<int>> dp(l1+1,vector<int>(l2+1,0));\\n        for(int i=0;i<=l1;++i){\\n            dp[i][0] = i;\\n        }\\n        for(int i=0;i<=l2;++i){\\n            dp[0][i] = i;\\n        }\\n        dp[0][0] = 0;\\n        for(int i=1;i<=l1;++i){\\n            for(int j=1;j<=l2;++j){\\n                if(word1[i-1]==word2[j-1]){dp[i][j] = dp[i-1][j-1];}\\n                else{dp[i][j] = 1+min({dp[i-1][j-1],dp[i-1][j],dp[i][j-1]});}\\n            }\\n        }\\n        return dp[l1][l2];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int minDistance(string word1, string word2) {\\n        const int l1 = word1.size();\\n        const int l2 = word2.size();\\n        vector<vector<int>> dp(l1+1,vector<int>(l2+1,0));\\n        for(int i=0;i<=l1;++i){\\n            dp[i][0] = i;\\n        }\\n        for(int i=0;i<=l2;++i){\\n            dp[0][i] = i;\\n        }\\n        dp[0][0] = 0;\\n        for(int i=1;i<=l1;++i){\\n            for(int j=1;j<=l2;++j){\\n                if(word1[i-1]==word2[j-1]){dp[i][j] = dp[i-1][j-1];}\\n                else{dp[i][j] = 1+min({dp[i-1][j-1],dp[i-1][j],dp[i][j-1]});}\\n            }\\n        }\\n        return dp[l1][l2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3296233,
                "title": "iterative-short-sweet-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string s1, string s2) {\\n        int m = s1.length(),n=s2.length(),i,j;\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(i = 0; i <= m; i++){\\n            for(j = 0; j <= n; j++){\\n                if(i==0&&j==0){\\n                    dp[i][j] = 0;\\n                }else if(i==0){\\n                    dp[i][j] = j;\\n                }else if(j==0){\\n                    dp[i][j] = i;\\n                }\\n                else if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]})+1;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string s1, string s2) {\\n        int m = s1.length(),n=s2.length(),i,j;\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(i = 0; i <= m; i++){\\n            for(j = 0; j <= n; j++){\\n                if(i==0&&j==0){\\n                    dp[i][j] = 0;\\n                }else if(i==0){\\n                    dp[i][j] = j;\\n                }else if(j==0){\\n                    dp[i][j] = i;\\n                }\\n                else if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]})+1;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235589,
                "title": "beginner-friendly-step-by-step-elaboration-with-video-solution-java",
                "content": "# Intuition\\nThe solution below is self explanatory. \\nIf you understand **Bangla**, you can see this video for step by step clear explanation:\\n\\nhttps://youtu.be/lWocPDgqFIo\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nRecursion With Memorization. Bottom Up Approach.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code [Java]\\n```\\nclass Solution {\\n    Integer memo[][];\\n    int w1Len, w2Len;\\n    public int minDistance(String word1, String word2) {\\n        memo = new Integer[word1.length() + 1][word2.length() + 1];\\n        w1Len = word1.length();\\n        w2Len = word2.length();\\n        return minDistanceRecur(word1, word2, 0, 0);\\n    }\\n\\n    int minDistanceRecur(String word1, String word2, int word1Index, int word2Index) {\\n        if (word1Index == w1Len) {\\n            // return how many remaining for word2\\n            return w2Len-word2Index;\\n        }\\n        if (word2Index == w2Len) {\\n            // return how many remaining for word1\\n            return w1Len-word1Index;\\n        }\\n        if (memo[word1Index][word2Index] != null) {\\n            return memo[word1Index][word2Index];\\n        }\\n        int minEditDistance = 0;\\n        if (word1.charAt(word1Index) == word2.charAt(word2Index)) {\\n            minEditDistance = minDistanceRecur(word1, word2, word1Index + 1, word2Index + 1);\\n        }\\n        else {\\n            // insert in word1 or, delete from word1\\n            int insertOperation = minDistanceRecur(word1, word2, word1Index + 1, word2Index);\\n            // delete from word2 or, insert in word2\\n            int deleteOperation = minDistanceRecur(word1, word2, word1Index, word2Index+1);\\n            // replace so, the i\\'th index of both word1 and word2 becomes equal. Now we move to i+1 th index for both.\\n            int replaceOperation = minDistanceRecur(word1, word2, word1Index + 1, word2Index + 1);\\n            minEditDistance = Math.min(insertOperation, Math.min(deleteOperation, replaceOperation)) + 1;\\n        }\\n        memo[word1Index][word2Index] = minEditDistance;\\n        return minEditDistance;\\n    }\\n}\\n```\\n\\n![3549-pepepopcorn.png](https://assets.leetcode.com/users/images/3ec73dd1-878d-4bc2-bf53-1096d00472ab_1677485929.702025.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer memo[][];\\n    int w1Len, w2Len;\\n    public int minDistance(String word1, String word2) {\\n        memo = new Integer[word1.length() + 1][word2.length() + 1];\\n        w1Len = word1.length();\\n        w2Len = word2.length();\\n        return minDistanceRecur(word1, word2, 0, 0);\\n    }\\n\\n    int minDistanceRecur(String word1, String word2, int word1Index, int word2Index) {\\n        if (word1Index == w1Len) {\\n            // return how many remaining for word2\\n            return w2Len-word2Index;\\n        }\\n        if (word2Index == w2Len) {\\n            // return how many remaining for word1\\n            return w1Len-word1Index;\\n        }\\n        if (memo[word1Index][word2Index] != null) {\\n            return memo[word1Index][word2Index];\\n        }\\n        int minEditDistance = 0;\\n        if (word1.charAt(word1Index) == word2.charAt(word2Index)) {\\n            minEditDistance = minDistanceRecur(word1, word2, word1Index + 1, word2Index + 1);\\n        }\\n        else {\\n            // insert in word1 or, delete from word1\\n            int insertOperation = minDistanceRecur(word1, word2, word1Index + 1, word2Index);\\n            // delete from word2 or, insert in word2\\n            int deleteOperation = minDistanceRecur(word1, word2, word1Index, word2Index+1);\\n            // replace so, the i\\'th index of both word1 and word2 becomes equal. Now we move to i+1 th index for both.\\n            int replaceOperation = minDistanceRecur(word1, word2, word1Index + 1, word2Index + 1);\\n            minEditDistance = Math.min(insertOperation, Math.min(deleteOperation, replaceOperation)) + 1;\\n        }\\n        memo[word1Index][word2Index] = minEditDistance;\\n        return minEditDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233545,
                "title": "python3-56-ms-faster-than-99-95-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/222526f8-ed70-43bf-a0c4-72c76ed4f424_1677429728.1260953.png)\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        if word1 == word2:\\n            return 0\\n        if len(word1) == 0 or len(word2) == 0:\\n            return max(len(word1), len(word2))            \\n        w1 = list(word1)\\n        w2 = list(word2)        \\n        num = 0\\n        queue = deque()\\n        queue.append((0, 0))\\n        visited = set()\\n        while len(queue) > 0:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if (i, j) in visited:\\n                    continue\\n                visited.add((i, j))\\n                while i < len(w1) and j < len(w2) and w1[i] == w2[j]:\\n                    i += 1\\n                    j += 1\\n                if i == len(w1) and j == len(w2):\\n                    return num\\n                queue.append((i, j + 1))\\n                queue.append((i + 1, j + 1))\\n                queue.append((i + 1, j))\\n            num += 1\\n```\\nThis code is an implementation of a Breadth-First Search (BFS) algorithm to solve the minimum edit distance problem between two words. The minimum edit distance is defined as the minimum number of operations (insertions, deletions, substitutions) needed to transform one string into another.\\n\\nHere\\'s a step-by-step breakdown of the code:\\n1. The function minDistance takes two string arguments word1 and word2 and returns an integer representing the minimum edit distance between the two strings.\\n1. The function first checks if the two input strings are the same. If they are, the minimum edit distance is zero, and the function returns immediately.\\n1. If either of the input strings is empty, the minimum edit distance is the length of the non-empty string. Therefore, the function returns the maximum length between the two strings.\\n1. Next, the input strings are converted into lists of characters w1 and w2.\\n1. A variable num is initialized to zero. This variable will be used to keep track of the number of operations needed to transform word1 into word2.\\n1. A deque object queue is created to hold the coordinates of the current position in the matrix. The initial position is (0, 0), which corresponds to the first character of both strings.\\n1. A set visited is created to keep track of visited positions.\\n1. A while loop runs until the queue is empty. Within the loop, a for loop is used to process all the elements currently in the queue.\\n1. The i and j indices of the current position are obtained from the leftmost element of the queue, and the leftmost element is removed from the queue.\\n1. If the position (i, j) has been visited before, it is skipped.\\n1. The loop moves the i and j indices until the characters at positions w1[i] and w2[j] are different. This means that there is an operation needed at this position.\\n1. If both i and j have reached the end of their respective strings, the minimum edit distance has been found, and the function returns the current value of num.\\n1. The three possible edit operations (insertion, deletion, and substitution) are added to the queue.\\n1. The num variable is incremented at the end of each iteration of the while loop.\\n1. If the end of the function is reached without finding a solution, the function returns num, which represents the minimum number of operations needed to transform word1 into word2.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        if word1 == word2:\\n            return 0\\n        if len(word1) == 0 or len(word2) == 0:\\n            return max(len(word1), len(word2))            \\n        w1 = list(word1)\\n        w2 = list(word2)        \\n        num = 0\\n        queue = deque()\\n        queue.append((0, 0))\\n        visited = set()\\n        while len(queue) > 0:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if (i, j) in visited:\\n                    continue\\n                visited.add((i, j))\\n                while i < len(w1) and j < len(w2) and w1[i] == w2[j]:\\n                    i += 1\\n                    j += 1\\n                if i == len(w1) and j == len(w2):\\n                    return num\\n                queue.append((i, j + 1))\\n                queue.append((i + 1, j + 1))\\n                queue.append((i + 1, j))\\n            num += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232618,
                "title": "c-code-dp-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nApplication of DP\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n        {\\n            dp[i][0]=i;\\n        }\\n        for(int j=0;j<=n;j++)\\n        {\\n            dp[0][j]=j;\\n\\n        }\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                {\\n                    dp[i][j]=dp[i-1][j-1];\\n                    \\n                }\\n                else \\n                {   int mini=min(dp[i-1][j],dp[i][j-1]);\\n                    dp[i][j]=1+ min(dp[i-1][j-1],mini);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n        {\\n            dp[i][0]=i;\\n        }\\n        for(int j=0;j<=n;j++)\\n        {\\n            dp[0][j]=j;\\n\\n        }\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                {\\n                    dp[i][j]=dp[i-1][j-1];\\n                    \\n                }\\n                else \\n                {   int mini=min(dp[i-1][j],dp[i][j-1]);\\n                    dp[i][j]=1+ min(dp[i-1][j-1],mini);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231952,
                "title": "dynamic-programming",
                "content": "# Intuition & Approach\\nhttps://youtu.be/rOHeIwyAO9g\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for (int i = 0; i <= n; ++i) {\\n            for (int j = 0; j <= m; ++j) {\\n                if (!i || !j)\\n                    dp[i][j] = i + j;\\n                else if (word1[i - 1] == word2[j - 1])\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                else\\n                    dp[i][j] = 1 + min({\\n                        dp[i][j - 1],    // insert\\n                        dp[i - 1][j],    // delete\\n                        dp[i - 1][j - 1] // replace\\n                    });\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> dp;\\n    \\n    int minDistance(string word1, string word2) {\\n        n = word1.size(), m = word2.size();\\n        dp = vector<vector<int>>(n + 1, vector<int>(m + 1, -1));\\n        \\n        return solve(n, m, word1, word2);\\n    }\\n    \\n    int solve(int i, int j, string &str1, string &str2) {\\n        if (!i || !j) return i + j;\\n        \\n        int &ret = dp[i][j];\\n        if (~ret) return ret;\\n        \\n        if (str1[i - 1] == str2[j - 1])\\n            return ret = solve(i - 1, j - 1, str1, str2);\\n\\n        return ret = 1 + min({\\n            solve(i, j - 1, str1, str2),    // insert\\n            solve(i - 1, j, str1, str2),    // delete\\n            solve(i - 1, j - 1, str1, str2) // replace\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for (int i = 0; i <= n; ++i) {\\n            for (int j = 0; j <= m; ++j) {\\n                if (!i || !j)\\n                    dp[i][j] = i + j;\\n                else if (word1[i - 1] == word2[j - 1])\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                else\\n                    dp[i][j] = 1 + min({\\n                        dp[i][j - 1],    // insert\\n                        dp[i - 1][j],    // delete\\n                        dp[i - 1][j - 1] // replace\\n                    });\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> dp;\\n    \\n    int minDistance(string word1, string word2) {\\n        n = word1.size(), m = word2.size();\\n        dp = vector<vector<int>>(n + 1, vector<int>(m + 1, -1));\\n        \\n        return solve(n, m, word1, word2);\\n    }\\n    \\n    int solve(int i, int j, string &str1, string &str2) {\\n        if (!i || !j) return i + j;\\n        \\n        int &ret = dp[i][j];\\n        if (~ret) return ret;\\n        \\n        if (str1[i - 1] == str2[j - 1])\\n            return ret = solve(i - 1, j - 1, str1, str2);\\n\\n        return ret = 1 + min({\\n            solve(i, j - 1, str1, str2),    // insert\\n            solve(i - 1, j, str1, str2),    // delete\\n            solve(i - 1, j - 1, str1, str2) // replace\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231173,
                "title": "c-solution-with-explanation-let-s-code-it",
                "content": "# Upvote if you found this solution helpful\\uD83D\\uDD25\\n\\n# Approach\\nTo solve this question the first approach which comes to my mind is to explore all the paths and return the path with minimum number of steps.\\nTo solve these kind of questions try to first solve them using recursion and then use memoization to reduce the complexity.\\nWe can start comparing the strings from back, one character at a time.\\nThere are three main cases which we need to keep in mind:-\\n1. Replace the character\\n2. Insert a character\\n3. Remove a character\\n\\nBase condition:-\\n1. String 1 -> empty\\n2. String 2 -> empty\\n3. Both the characters are same\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size(); \\n        //initialize a dp vector\\n        vector<vector<int>> dp(n1, vector<int>(n2, -1));\\n\\n        //start comparing the strings from end\\n        return helper(n1-1, n2-1, word1, word2, dp);\\n    }\\n\\n    int helper(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        //if string 1 is empty\\n        if(i < 0){\\n            return j+1;\\n        }\\n        //if string 2 is empty\\n        if(j < 0){\\n            return i+1;\\n        }\\n        //if both the characters are same\\n        if(s1[i] ==  s2[j]){\\n            return dp[i][j] = helper(i-1, j-1, s1, s2, dp);\\n        }\\n\\n        //if we have already calculate the result for corresponding i and j\\n        //there is no need to solve further and return the ans\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n\\n        //if we remove an element\\n        int min1 = helper(i-1, j, s1, s2, dp);\\n        //if we insert an element\\n        int min2 = helper(i, j-1, s1, s2, dp);\\n        //if we replace an element\\n        int min3 = helper(i-1, j-1, s1, s2, dp);\\n\\n        return dp[i][j] = 1 + min(min(min1, min2), min3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size(); \\n        //initialize a dp vector\\n        vector<vector<int>> dp(n1, vector<int>(n2, -1));\\n\\n        //start comparing the strings from end\\n        return helper(n1-1, n2-1, word1, word2, dp);\\n    }\\n\\n    int helper(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        //if string 1 is empty\\n        if(i < 0){\\n            return j+1;\\n        }\\n        //if string 2 is empty\\n        if(j < 0){\\n            return i+1;\\n        }\\n        //if both the characters are same\\n        if(s1[i] ==  s2[j]){\\n            return dp[i][j] = helper(i-1, j-1, s1, s2, dp);\\n        }\\n\\n        //if we have already calculate the result for corresponding i and j\\n        //there is no need to solve further and return the ans\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n\\n        //if we remove an element\\n        int min1 = helper(i-1, j, s1, s2, dp);\\n        //if we insert an element\\n        int min2 = helper(i, j-1, s1, s2, dp);\\n        //if we replace an element\\n        int min3 = helper(i-1, j-1, s1, s2, dp);\\n\\n        return dp[i][j] = 1 + min(min(min1, min2), min3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230771,
                "title": "simple-tabulation-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) \\n    {\\n        int n=word1.size();\\n        int m=word2.size();\\n        int h[n+1][m+1];\\n        for(int i=0;i<m+1;i++)\\n        {\\n           h[0][i]=i;\\n        }\\n        for(int i=0;i<n+1;i++)\\n        {\\n           h[i][0]=i;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n           for(int j=1;j<m+1;j++)\\n           {\\n              if(word1[i-1]==word2[j-1])\\n              {\\n                 h[i][j]=h[i-1][j-1];\\n              }\\n              else\\n              {\\n                 h[i][j]=min(1+h[i-1][j-1],min(1+h[i-1][j],1+h[i][j-1]));\\n              }\\n           }\\n        }\\n        return h[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) \\n    {\\n        int n=word1.size();\\n        int m=word2.size();\\n        int h[n+1][m+1];\\n        for(int i=0;i<m+1;i++)\\n        {\\n           h[0][i]=i;\\n        }\\n        for(int i=0;i<n+1;i++)\\n        {\\n           h[i][0]=i;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n           for(int j=1;j<m+1;j++)\\n           {\\n              if(word1[i-1]==word2[j-1])\\n              {\\n                 h[i][j]=h[i-1][j-1];\\n              }\\n              else\\n              {\\n                 h[i][j]=min(1+h[i-1][j-1],min(1+h[i-1][j],1+h[i][j-1]));\\n              }\\n           }\\n        }\\n        return h[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181609,
                "title": "72-edit-distance-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We use a 2D dp array dp with dimensions (m+1) x (n+1), where m and n are the lengths of word1 and word2, respectively.\\n- dp[i][j] represents the minimum number of operations required to convert the first i characters of word1 to the first j characters of word2.\\n- Initially, if one of the strings is empty, the min number of operations is inserting all characters from the other string, so we fill the first row and first column with i and j, respectively.\\n- For each i and j, we compare the characters word1[i-1] and word2[j-1]. If they are the same, we don\\'t need to perform any operation, so dp[i][j] takes the value of dp[i-1][j-1]. If they are different, we find the minimum of three operations: replace, insert, delete, and update dp[i][j] accordingly.\\n- Finally, the minimum number of operations required is stored in dp[m][n].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        \\n        # if one of the strings is empty, the min number of operations is inserting all characters from the other string\\n        for i in range(1, m+1):\\n            dp[i][0] = i\\n        for j in range(1, n+1):\\n            dp[0][j] = j\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                # if the characters are the same, we don\\'t need to perform any operation\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    # find the minimum of three operations: replace, insert, delete\\n                    dp[i][j] = min(dp[i-1][j-1]+1, dp[i-1][j]+1, dp[i][j-1]+1)\\n        \\n        return dp[m][n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        \\n        # if one of the strings is empty, the min number of operations is inserting all characters from the other string\\n        for i in range(1, m+1):\\n            dp[i][0] = i\\n        for j in range(1, n+1):\\n            dp[0][j] = j\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                # if the characters are the same, we don\\'t need to perform any operation\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    # find the minimum of three operations: replace, insert, delete\\n                    dp[i][j] = min(dp[i-1][j-1]+1, dp[i-1][j]+1, dp[i][j-1]+1)\\n        \\n        return dp[m][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076353,
                "title": "c-easy-solution-tabulation-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:  \\n    int f(int i,int j,string w1, string w2,vector<vector<int>>&dp){\\n        if(i==0) return j;\\n        if(j==0) return i;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(w1[i-1]==w2[j-1]) return 0+f(i-1,j-1,w1,w2,dp);\\n        else return dp[i][j]= 1+min(f(i-1,j-1,w1,w2,dp),min(f(i,j-1,w1,w2,dp),f(i-1,j,w1,w2,dp)));\\n        \\n    }\\n    int minDistance(string w1, string w2) {\\n        int n=w1.size();\\n        int m=w2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1));\\n        for(int i=0;i<=n;i++) dp[i][0]=i;\\n        for(int j=0;j<=m;j++) dp[0][j]=j;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(w1[i-1]==w2[j-1]) dp[i][j]=dp[i-1][j-1];\\n                else  dp[i][j]= 1+min(dp[i-1][j-1],min(dp[i][j-1],dp[i-1][j]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    int f(int i,int j,string w1, string w2,vector<vector<int>>&dp){\\n        if(i==0) return j;\\n        if(j==0) return i;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(w1[i-1]==w2[j-1]) return 0+f(i-1,j-1,w1,w2,dp);\\n        else return dp[i][j]= 1+min(f(i-1,j-1,w1,w2,dp),min(f(i,j-1,w1,w2,dp),f(i-1,j,w1,w2,dp)));\\n        \\n    }\\n    int minDistance(string w1, string w2) {\\n        int n=w1.size();\\n        int m=w2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1));\\n        for(int i=0;i<=n;i++) dp[i][0]=i;\\n        for(int j=0;j<=m;j++) dp[0][j]=j;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(w1[i-1]==w2[j-1]) dp[i][j]=dp[i-1][j-1];\\n                else  dp[i][j]= 1+min(dp[i-1][j-1],min(dp[i][j-1],dp[i-1][j]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050516,
                "title": "memoization-tabulation-space-optimization-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int j, string &s, string &t, vector<vector<int>> &dp) {\\n        if(j == 0) return i;\\n        if(i == 0) return j;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        if(s[i - 1] == t[j - 1]) return dp[i][j] = dfs(i - 1, j - 1, s, t, dp);\\n        return dp[i][j] = 1 + min(dfs(i - 1, j - 1, s, t, dp), min(dfs(i, j - 1, s, t, dp), dfs(i - 1, j, s, t, dp)));\\n    }\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n\\n        return dfs(n, m, s, t, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for(int i=0; i<=n; i++) dp[i][0] = i;\\n        for(int j=0; j<=m; j++) dp[0][j] = j;\\n\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1];\\n                else dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n\\n# Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<int> dp(m + 1), temp(m + 1);\\n\\n        for(int j=0; j<=m; j++) dp[j] = j;\\n\\n        for(int i=1; i<=n; i++) {\\n            temp[0] = i;\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) temp[j] = dp[j - 1];\\n                else temp[j] = 1 + min(dp[j - 1], min(temp[j - 1], dp[j]));\\n            }\\n            dp = temp;\\n        }\\n        return dp[m];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, string &s, string &t, vector<vector<int>> &dp) {\\n        if(j == 0) return i;\\n        if(i == 0) return j;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        if(s[i - 1] == t[j - 1]) return dp[i][j] = dfs(i - 1, j - 1, s, t, dp);\\n        return dp[i][j] = 1 + min(dfs(i - 1, j - 1, s, t, dp), min(dfs(i, j - 1, s, t, dp), dfs(i - 1, j, s, t, dp)));\\n    }\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n\\n        return dfs(n, m, s, t, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for(int i=0; i<=n; i++) dp[i][0] = i;\\n        for(int j=0; j<=m; j++) dp[0][j] = j;\\n\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1];\\n                else dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<int> dp(m + 1), temp(m + 1);\\n\\n        for(int j=0; j<=m; j++) dp[j] = j;\\n\\n        for(int i=1; i<=n; i++) {\\n            temp[0] = i;\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) temp[j] = dp[j - 1];\\n                else temp[j] = 1 + min(dp[j - 1], min(temp[j - 1], dp[j]));\\n            }\\n            dp = temp;\\n        }\\n        return dp[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015013,
                "title": "3-java-solution-from-brute-force-to-top-down-to-bottom-up",
                "content": "It is quite similar to below leetcode problem ->\\nhttps://leetcode.com/problems/delete-operation-for-two-strings/solutions/3014824/3-java-solution-from-brute-force-to-top-down-to-bottomup/?orderBy=most_votes\\n\\nThe only addition here is that instead of two operations we have third also.\\n# Brute force (TLE)\\n```\\npublic int minDistance(String word1, String word2) {\\n    int n = word1.length();\\n    int m = word2.length();\\n    return helper(word1,word2,n-1,m-1);\\n}\\nprivate int helper(String s,String t,int i,int j) {\\n    if(i<0) {\\n        return j+1;\\n    }\\n    if(j<0) {\\n        return i+1;\\n    }\\n    if(s.charAt(i)==t.charAt(j)) {\\n        return helper(s,t,i-1,j-1);\\n    }\\n    return Math.min(helper(s,t,i-1,j),Math.min(helper(s,t,i-1,j-1),helper(s,t,i,j-1)))+1;\\n}\\n```\\n# TOP Down DP\\n```\\npublic int minDistance(String word1, String word2) {\\n    int n = word1.length();\\n    int m = word2.length();\\n    return helper(word1,word2,n-1,m-1,new Integer[n][m]);\\n}\\nprivate int helper(String s,String t,int i,int j,Integer[][] memo) {\\n    if(i<0) {\\n        return j+1;\\n    }\\n    if(j<0) {\\n        return i+1;\\n    }\\n    if(memo[i][j]!=null) {\\n        return memo[i][j];\\n    }\\n    if(s.charAt(i)==t.charAt(j)) {\\n        return memo[i][j]=helper(s,t,i-1,j-1,memo);\\n    }\\n    return memo[i][j]=Math.min(helper(s,t,i-1,j,memo),Math.min(helper(s,t,i-1,j-1,memo),helper(s,t,i,j-1,memo)))+1;\\n}\\n```\\n\\n# Bottom Up DP\\n```\\npublic int minDistance(String s, String t) {\\n    int n = s.length();\\n    int m = t.length();\\n    int[][] memo = new int[n+1][m+1];\\n    for(int i=0;i<=n;i++) {\\n        for(int j=0;j<=m;j++) {\\n            if(i==0||j==0) {\\n                memo[i][j]=i==0?j:i;\\n            }\\n            else if(s.charAt(i-1)==t.charAt(j-1)) {\\n                memo[i][j]=memo[i-1][j-1];\\n            } else {\\n                memo[i][j]=Math.min(memo[i][j-1],Math.min(memo[i-1][j],memo[i-1][j-1]))+1;\\n            }\\n        }\\n    }\\n    return memo[n][m];\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minDistance(String word1, String word2) {\\n    int n = word1.length();\\n    int m = word2.length();\\n    return helper(word1,word2,n-1,m-1);\\n}\\nprivate int helper(String s,String t,int i,int j) {\\n    if(i<0) {\\n        return j+1;\\n    }\\n    if(j<0) {\\n        return i+1;\\n    }\\n    if(s.charAt(i)==t.charAt(j)) {\\n        return helper(s,t,i-1,j-1);\\n    }\\n    return Math.min(helper(s,t,i-1,j),Math.min(helper(s,t,i-1,j-1),helper(s,t,i,j-1)))+1;\\n}\\n```\n```\\npublic int minDistance(String word1, String word2) {\\n    int n = word1.length();\\n    int m = word2.length();\\n    return helper(word1,word2,n-1,m-1,new Integer[n][m]);\\n}\\nprivate int helper(String s,String t,int i,int j,Integer[][] memo) {\\n    if(i<0) {\\n        return j+1;\\n    }\\n    if(j<0) {\\n        return i+1;\\n    }\\n    if(memo[i][j]!=null) {\\n        return memo[i][j];\\n    }\\n    if(s.charAt(i)==t.charAt(j)) {\\n        return memo[i][j]=helper(s,t,i-1,j-1,memo);\\n    }\\n    return memo[i][j]=Math.min(helper(s,t,i-1,j,memo),Math.min(helper(s,t,i-1,j-1,memo),helper(s,t,i,j-1,memo)))+1;\\n}\\n```\n```\\npublic int minDistance(String s, String t) {\\n    int n = s.length();\\n    int m = t.length();\\n    int[][] memo = new int[n+1][m+1];\\n    for(int i=0;i<=n;i++) {\\n        for(int j=0;j<=m;j++) {\\n            if(i==0||j==0) {\\n                memo[i][j]=i==0?j:i;\\n            }\\n            else if(s.charAt(i-1)==t.charAt(j-1)) {\\n                memo[i][j]=memo[i-1][j-1];\\n            } else {\\n                memo[i][j]=Math.min(memo[i][j-1],Math.min(memo[i-1][j],memo[i-1][j-1]))+1;\\n            }\\n        }\\n    }\\n    return memo[n][m];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2966079,
                "title": "c-clean-and-easy-solution-dp-recursive-top-down-bottom-up-space-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string &a, string &b, int i, int j){\\n        if(i >= a.size()){\\n            return (b.size()-j);\\n        }\\n        if(j >= b.size()){\\n            return (a.size()-i);\\n        }\\n\\n        int ans;\\n        if(a[i] == b[j]){\\n            ans = solve(a, b, i+1, j+1);\\n        }\\n        else{\\n            int ins = 1 + solve(a, b, i, j+1);\\n            int dlt = 1 + solve(a, b, i+1, j);\\n            int rep = 1 + solve(a, b, i+1, j+1);\\n\\n            ans = min(ins, min(dlt, rep));\\n        }\\n\\n        return ans;\\n    }\\n\\n    int solveMem(string &a, string &b, int i, int j, vector<vector<int>> &dp){\\n        if(i >= a.size()){\\n            return (b.size()-j);\\n        }\\n        if(j >= b.size()){\\n            return (a.size()-i);\\n        }\\n\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n\\n        int ans;\\n        if(a[i] == b[j]){\\n            ans = solveMem(a, b, i+1, j+1, dp);\\n        }\\n        else{\\n            int ins = 1 + solveMem(a, b, i, j+1, dp);\\n            int dlt = 1 + solveMem(a, b, i+1, j, dp);\\n            int rep = 1 + solveMem(a, b, i+1, j+1, dp);\\n\\n            ans = min(ins, min(dlt, rep));\\n        }\\n\\n        return dp[i][j] = ans;\\n    }\\n\\n    int solveTab(string &a, string &b){\\n        vector<vector<int>> dp(a.size()+1, vector<int>(b.size()+1, 0));\\n\\n        for(int j = 0; j <= b.size(); j++){\\n            dp[a.size()][j] = b.size() - j; \\n        }\\n\\n        for(int i = 0; i <= a.size(); i++){\\n            dp[i][b.size()] = a.size() - i;\\n        }\\n\\n        for(int i = a.size()-1; i >= 0; i--){\\n            for(int j = b.size()-1; j >= 0; j--){\\n\\n                int ans;\\n                if(a[i] == b[j]){\\n                    ans = dp[i+1][j+1];\\n                }\\n                else{\\n                    int ins = 1 + dp[i][j+1];\\n                    int dlt = 1 + dp[i+1][j];\\n                    int rep = 1 + dp[i+1][j+1];\\n\\n                    ans = min(ins, min(dlt, rep));\\n                }\\n\\n                dp[i][j] = ans;\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n\\n    int solveSO(string a, string b){\\n\\n        vector<int> curr(b.size() + 1, 0);\\n        vector<int> next(b.size() + 1, 0);\\n\\n        for(int j = 0; j <= b.size(); j++){\\n            next[j] = b.size() - j;\\n        }\\n\\n        for(int i = a.size()-1; i >= 0; i--){\\n\\n            // Very Imp, This came from base case\\n            curr[b.size()] = a.size() - i;\\n\\n            for(int j = b.size()-1; j >= 0; j--){\\n\\n                int ans;\\n                if(a[i] == b[j]){\\n                    ans = next[j+1];\\n                }\\n                else{\\n                    int ins = 1 + curr[j+1];\\n                    int dlt = 1 + next[j];\\n                    int rep = 1 + next[j+1];\\n\\n                    ans = min(ins, min(dlt, rep));\\n                }\\n\\n                curr[j] = ans;\\n            }\\n\\n            next = curr;\\n        }\\n\\n        return curr[0];\\n    }\\n\\n    int minDistance(string a, string b) {\\n\\n        // vector<vector<int>> dp(a.size(), vector<int>(b.size(), -1));\\n        // return solveMem(a, b, 0, 0);\\n\\n        if(a.size() == 0) return b.size();\\n        if(b.size() == 0) return a.size();\\n\\n        return solveSO(a, b);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(string &a, string &b, int i, int j){\\n        if(i >= a.size()){\\n            return (b.size()-j);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2798723,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    string s, t;\\n\\n    int solve(int i, int j) {     \\n        if(i == s.size()) return t.size()-j;\\n        if(j == t.size()) return s.size()-i;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans;\\n        if(s[i] == t[j]) ans = solve(i+1, j+1);\\n        else {\\n            int deleted = 1 + solve(i+1, j);\\n            int inserted = 1 + solve(i, j+1);\\n            int replaced = 1 + solve(i+1, j+1);\\n            ans = min({deleted, inserted, replaced});\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        memset(dp, -1, sizeof(dp));\\n        s = word1;\\n        t = word2;\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    string s, t;\\n\\n    int solve(int i, int j) {     \\n        if(i == s.size()) return t.size()-j;\\n        if(j == t.size()) return s.size()-i;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans;\\n        if(s[i] == t[j]) ans = solve(i+1, j+1);\\n        else {\\n            int deleted = 1 + solve(i+1, j);\\n            int inserted = 1 + solve(i, j+1);\\n            int replaced = 1 + solve(i+1, j+1);\\n            ans = min({deleted, inserted, replaced});\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        memset(dp, -1, sizeof(dp));\\n        s = word1;\\n        t = word2;\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793686,
                "title": "linear-python-solution-top-down-and-bottom-up",
                "content": "# Intuition\\nStep 1: Express the problem in terms of indexes.\\nStep 2: Explore all possibilities at a given index\\nStep 3: Return the minimum of the choices\\n\\n\\n# Approach\\n\\nAs we see there are overlapping subproblems in the recursive tree, \\n1.\\tCreate a dp array of size [N][M] where N and M are lengths of S1 and S2    respectively.\\n2.\\tWe initialize the dp array to -1.\\n3.\\tWhenever we want to find the answer of particular parameters (say f(ind1, ind2)), we first check whether the answer is  already calculated using the dp array (i.e. dp[ind][ind2]!= -1 ). If yes, simply return the value from the dp array\\n4.\\tIf not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[ind][ind2] to the solution we get.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n\\n- Space complexity: O(n*M)\\n\\n\\n**Dp( Tabulation)**\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        l1=len(word1)\\n        l2=len(word2)\\n        dp=[[-1]*(l1+1) for i in range(l2+1)]\\n        for i in range(l1+1):\\n            (dp[0])[i]=i\\n        for i in range(l2+1):\\n            (dp[i])[0]=i\\n\\n        for j in range(1,l2+1):\\n            for i in range(1,l1+1):\\n                if word1[i-1]==word2[j-1]:\\n                    (dp[j])[i]=(dp[j-1])[i-1]\\n                else:\\n                    insert=(dp[j-1])[i]\\n                    delete=(dp[j])[i-1]\\n                    replace=(dp[j-1])[i-1]\\n                    (dp[j])[i]=1+ min(insert,delete,replace)\\n                    \\n  \\n  \\n\\n\\n        return (dp[l2])[l1]\\n        \\n\\n\\n\\n\\n```\\n# Dp Memoization  Method\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def fun(word1,word2,i,j,dp):\\n            if i<0:\\n                return j+1\\n            if j<0:\\n                return i+1\\n            if (dp[j])[i]!=-1:\\n                return (dp[j])[i]\\n            elif word1[i]==word2[j]:\\n\\n                (dp[j])[i]=fun(word1,word2,i-1,j-1,dp)\\n                return (dp[j])[i]\\n            insert=fun(word1,word2,i,j-1,dp)\\n            delete=fun(word1,word2,i-1,j,dp)\\n            replace=fun(word1,word2,i-1,j-1,dp)\\n            (dp[j])[i]=1+ min(insert,delete,replace)\\n            return (dp[j])[i]\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        l1=len(word1)\\n        l2=len(word2)\\n        dp=[[-1]*(l1+1) for i in range(l2+1)]\\n        for i in range(l1+1):\\n            (dp[0])[i]=i\\n        for i in range(l2+1):\\n            (dp[i])[0]=i\\n\\n        for j in range(1,l2+1):\\n            for i in range(1,l1+1):\\n                if word1[i-1]==word2[j-1]:\\n                    (dp[j])[i]=(dp[j-1])[i-1]\\n                else:\\n                    insert=(dp[j-1])[i]\\n                    delete=(dp[j])[i-1]\\n                    replace=(dp[j-1])[i-1]\\n                    (dp[j])[i]=1+ min(insert,delete,replace)\\n                    \\n  \\n  \\n\\n\\n        return (dp[l2])[l1]\\n        \\n\\n\\n\\n\\n```\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def fun(word1,word2,i,j,dp):\\n            if i<0:\\n                return j+1\\n            if j<0:\\n                return i+1\\n            if (dp[j])[i]!=-1:\\n                return (dp[j])[i]\\n            elif word1[i]==word2[j]:\\n\\n                (dp[j])[i]=fun(word1,word2,i-1,j-1,dp)\\n                return (dp[j])[i]\\n            insert=fun(word1,word2,i,j-1,dp)\\n            delete=fun(word1,word2,i-1,j,dp)\\n            replace=fun(word1,word2,i-1,j-1,dp)\\n            (dp[j])[i]=1+ min(insert,delete,replace)\\n            return (dp[j])[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769402,
                "title": "java-solutions",
                "content": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        // Base cases\\n        // Initializing First row\\n        for(int i=0; i <= l2; i++)\\n            dp[0][i] = i;        \\n        // Initializing First col\\n        for(int i=0; i <= l1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int i=1; i <= l1; i++){\\n            for(int j=1; j <= l2; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], // replace\\n                                            Math.min(dp[i-1][j], // delete\\n                                                     dp[i][j-1]) // insert\\n                                           ); \\n            }\\n        }\\n        \\n        return dp[l1][l2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        // Base cases\\n        // Initializing First row\\n        for(int i=0; i <= l2; i++)\\n            dp[0][i] = i;        \\n        // Initializing First col\\n        for(int i=0; i <= l1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int i=1; i <= l1; i++){\\n            for(int j=1; j <= l2; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], // replace\\n                                            Math.min(dp[i-1][j], // delete\\n                                                     dp[i][j-1]) // insert\\n                                           ); \\n            }\\n        }\\n        \\n        return dp[l1][l2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766502,
                "title": "i-tried-to-give-a-proper-explaination-of-both-dp-and-recursive-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string s1,string s2,int m,int n,vector<vector<int>> & dp){\\n        if(m==0) return n;\\n        if(n==0) return m;\\n\\t\\t\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\t\\t\\n        if(s1[m-1]==s2[n-1])\\n            return dp[m-1][n-1]=solve(s1,s2,m-1,n-1,dp);\\n\\t\\t\\t\\n        if(s1[m-1]!=s2[n-1]){ \\n            dp[m-1][n-1]=solve(s1,s2,m-1,n-1,dp);\\n            dp[m][n-1]=solve(s1,s2,m,n-1,dp);\\n            dp[m-1][n]=solve(s1,s2,m-1,n,dp);\\n            return 1+min(dp[m-1][n],min(dp[m-1][n-1],dp[m][n-1]));}\\n\\t\\t\\t\\n        return 0;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n         vector<vector<int>> vec(word1.size() +1 , vector<int> (word2.size()+1, -1));\\n        return solve(word1,word2,word1.size(),word2.size(),vec);\\n    }\\n};\\n\\n\\nclass Solution1 {//Recursive solution TLE\\npublic:\\n    int solve(string s1,string s2,int m,int n){\\n        if(m==0) return n;\\n        if(n==0) return m;\\n        if(s1[m-1]==s2[n-1]) return solve(s1,s2,m-1,n-1);\\n        if(s1[m-1]!=s2[n-1]) return 1+min(solve(s1,s2,m-1,n),min(solve(s1,s2,m-1,n-1),solve(s1,s2,m,n-1)));\\n        return 0;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n        return solve(word1,word2,word1.size(),word2.size());\\n    }\\n};\\n```\\n\\n\\nA.) So to understand this solution you gotta know the recursive solution of this so lets see some cases here :\\n1.  what if we have any of the strings empty what would be the number of operation here obviously that would be      length of the other non empty array yepp it would be :                                                                                                                                                                       ` if(m==0) return n;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  if(n==0) return m;`\\n2. well now case 2 what if both of the last charectors are same obviously it would require no operations so yeah we move to the next charectors of the string without any count to the charectors : \\n                                              ` if(s1[m-1]==s2[n-1]) return solve(s1,s2,m-1,n-1);`\\n3. now now lets see the three operation : \\n\\t\\t\\t\\t\\t\\t\\tlets take first operation that would be delete :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\twhat if the 2 strings are : \"execun\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"execu\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tyeah you would delete that g so you would move to the                                                                                               left by one in 1st word : solve(s1,s2,m-1,n)\\n\\t\\t\\t\\t\\t\\t\\tlets take second operation that would be replace :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\twhat if the 2 strings are : \"execg\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"execu\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tyeah you would replace that g so you would move to the                                                                                             left by one in 1st word  and 2nd word: solve(s1,s2,m-1,n)\\n\\t\\t\\t\\t\\t\\t\\tlets take second operation that would be insert :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\twhat if the 2 strings are : \"exec\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"execu\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tyeah you would replace that g so you would move to the                                                                                             left by one in 1st word  and 2nd word: solve(s1,s2,m-1,n-1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t    now that min is there cuz obviously we need to return that min operation value (just think it as the                           division of to sub problems )\\n\\t\\t\\t\\t\\t\\t\\nB.) and that code with dp vector we actually used that one to reduce the number of recursive calll\\nnote -  sorry if couldnt explain it that well any suggestions from you guys are really appreciable Thankyou!\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string s1,string s2,int m,int n,vector<vector<int>> & dp){\\n        if(m==0) return n;\\n        if(n==0) return m;\\n\\t\\t\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\t\\t\\n        if(s1[m-1]==s2[n-1])\\n            return dp[m-1][n-1]=solve(s1,s2,m-1,n-1,dp);\\n\\t\\t\\t\\n        if(s1[m-1]!=s2[n-1]){ \\n            dp[m-1][n-1]=solve(s1,s2,m-1,n-1,dp);\\n            dp[m][n-1]=solve(s1,s2,m,n-1,dp);\\n            dp[m-1][n]=solve(s1,s2,m-1,n,dp);\\n            return 1+min(dp[m-1][n],min(dp[m-1][n-1],dp[m][n-1]));}\\n\\t\\t\\t\\n        return 0;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n         vector<vector<int>> vec(word1.size() +1 , vector<int> (word2.size()+1, -1));\\n        return solve(word1,word2,word1.size(),word2.size(),vec);\\n    }\\n};\\n\\n\\nclass Solution1 {//Recursive solution TLE\\npublic:\\n    int solve(string s1,string s2,int m,int n){\\n        if(m==0) return n;\\n        if(n==0) return m;\\n        if(s1[m-1]==s2[n-1]) return solve(s1,s2,m-1,n-1);\\n        if(s1[m-1]!=s2[n-1]) return 1+min(solve(s1,s2,m-1,n),min(solve(s1,s2,m-1,n-1),solve(s1,s2,m,n-1)));\\n        return 0;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n        return solve(word1,word2,word1.size(),word2.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721083,
                "title": "o-n-space-dp-100-working-c-striver",
                "content": "These were the mistake done by mean while coding and I was trying to compare it with longest common subsequence \\uD83E\\uDD79. It take my lot of time.\\nEdit Distance\\n\\n*     1. no idea of basic case \\n         recursion code of 0 based indexing\\n*     2. if(i < 0 or j < 0) <- 0 => if(i < 0) <- j+1 , if(j < 0) <- i+1\\n*     3. <- 1 + common(i-1,j-1,s1,s2), min(common(i-1,j,s1,s2),common(i,j-1,s1,s2)) => min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) })\\n         recursion code of 1 based indexing\\n*     4. base conditon\\n         if(i == 0) <- j+1 , if(j == 0) <- i+1 => if(i == 0) <- j , if(j == 0) <- i\\n*     5. writing base condtion of optimize \\n          curr[0] = 1 => curr[0] = i;\\n\\n**Brute 0 Index : TLE**\\n\\n```\\n    // brute 0 index : TLE\\n        class Solution {\\n        public:\\n            int common(int i,int j,string &s1,string &s2){\\n                if(i < 0) return j+1;  // \\u2B50\\n                if(j < 0) return i+1;  // \\u2B50\\n                \\n                if(s1[i] == s2[j])\\n                    return 0 + common(i-1,j-1,s1,s2);  // \\u2B50\\n                else return min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) }); // \\u2B50\\n                        //              delete              insert                        replace\\n            }\\n            int minDistance(string s1, string s2) {\\n                int n = s1.size(),m = s2.size();\\n                return common(n-1,m-1,s1,s2);\\n            }\\n        };\\n```\\n    \\n**Brute 1 Index : TLE**\\n\\n```\\n// brute 1 indexing : TLE\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint common(int i,int j,string &s1,string &s2){\\n\\t\\t\\tif(i == 0) return j;  // \\u2B50\\n\\t\\t\\tif(j == 0) return i;  // \\u2B50\\n\\n\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\treturn 0 + common(i-1,j-1,s1,s2);\\n\\t\\t\\telse return min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) });\\n\\t\\t\\t\\t\\t//              delete              insert                        replace\\n\\t\\t}\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\treturn common(n,m,s1,s2);\\n\\t\\t}\\n\\t};\\n```\\n\\n**Memorization**\\n\\n```\\n// memo\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint common(int i,int j,string &s1,string &s2,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == 0) return j;\\n\\t\\t\\tif(j == 0) return i;\\n\\n\\t\\t\\tif(dp[i][j] != -1) return dp[i][j];\\n\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\treturn dp[i][j] = 0 + common(i-1,j-1,s1,s2,dp);\\n\\t\\t\\telse return dp[i][j] = min({ 1 + common(i-1,j,s1,s2,dp) , 1 + common(i,j-1,s1,s2,dp) , 1 + common(i-1,j-1,s1,s2,dp) });\\n\\n\\t\\t}\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n\\t\\t\\treturn common(n,m,s1,s2,dp);\\n\\t\\t}\\n\\t};\\n```\\n\\n**Tabulation**\\n\\n```\\n// tab\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n\\n\\t\\t\\tfor(int i=0;i<=n;i++) dp[i][0] = i;\\n\\t\\t\\tfor(int j=0;j<=m;j++) dp[0][j] = j;\\n\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tdp[i][j] = min({1 + dp[i-1][j],1 + dp[i][j-1], 1 + dp[i-1][j-1]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn dp[n][m];\\n\\t\\t}\\n\\t};\\n```\\n\\n**Optimize**\\n\\n```\\n// optimize\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<int> dp(m+1,0),curr(m+1,0);\\n\\n\\t\\t\\t// curr[0] = 1; \\u2B50\\n\\t\\t\\tfor(int j=0;j<=m;j++) dp[j] = j;\\n\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tcurr[0] = i; // \\u2B50\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\t\\t\\tcurr[j] = dp[j-1];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcurr[j] = min({1 + dp[j],1 + curr[j-1], 1 + dp[j-1]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp = curr;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn dp[m];\\n\\t\\t}\\n\\t};\\n```\\n\\nHappy coding , please do upvote this post.\\n![image](https://assets.leetcode.com/users/images/749bbd83-b0bc-4cc8-8e29-916a9e8b4478_1666164359.9013052.gif)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    // brute 0 index : TLE\\n        class Solution {\\n        public:\\n            int common(int i,int j,string &s1,string &s2){\\n                if(i < 0) return j+1;  // \\u2B50\\n                if(j < 0) return i+1;  // \\u2B50\\n                \\n                if(s1[i] == s2[j])\\n                    return 0 + common(i-1,j-1,s1,s2);  // \\u2B50\\n                else return min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) }); // \\u2B50\\n                        //              delete              insert                        replace\\n            }\\n            int minDistance(string s1, string s2) {\\n                int n = s1.size(),m = s2.size();\\n                return common(n-1,m-1,s1,s2);\\n            }\\n        };\\n```\n```\\n// brute 1 indexing : TLE\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint common(int i,int j,string &s1,string &s2){\\n\\t\\t\\tif(i == 0) return j;  // \\u2B50\\n\\t\\t\\tif(j == 0) return i;  // \\u2B50\\n\\n\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\treturn 0 + common(i-1,j-1,s1,s2);\\n\\t\\t\\telse return min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) });\\n\\t\\t\\t\\t\\t//              delete              insert                        replace\\n\\t\\t}\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\treturn common(n,m,s1,s2);\\n\\t\\t}\\n\\t};\\n```\n```\\n// memo\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint common(int i,int j,string &s1,string &s2,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == 0) return j;\\n\\t\\t\\tif(j == 0) return i;\\n\\n\\t\\t\\tif(dp[i][j] != -1) return dp[i][j];\\n\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\treturn dp[i][j] = 0 + common(i-1,j-1,s1,s2,dp);\\n\\t\\t\\telse return dp[i][j] = min({ 1 + common(i-1,j,s1,s2,dp) , 1 + common(i,j-1,s1,s2,dp) , 1 + common(i-1,j-1,s1,s2,dp) });\\n\\n\\t\\t}\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n\\t\\t\\treturn common(n,m,s1,s2,dp);\\n\\t\\t}\\n\\t};\\n```\n```\\n// tab\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n\\n\\t\\t\\tfor(int i=0;i<=n;i++) dp[i][0] = i;\\n\\t\\t\\tfor(int j=0;j<=m;j++) dp[0][j] = j;\\n\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tdp[i][j] = min({1 + dp[i-1][j],1 + dp[i][j-1], 1 + dp[i-1][j-1]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn dp[n][m];\\n\\t\\t}\\n\\t};\\n```\n```\\n// optimize\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<int> dp(m+1,0),curr(m+1,0);\\n\\n\\t\\t\\t// curr[0] = 1; \\u2B50\\n\\t\\t\\tfor(int j=0;j<=m;j++) dp[j] = j;\\n\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tcurr[0] = i; // \\u2B50\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\t\\t\\tcurr[j] = dp[j-1];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcurr[j] = min({1 + dp[j],1 + curr[j-1], 1 + dp[j-1]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp = curr;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn dp[m];\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469726,
                "title": "striver-code-python-solution-easy-explained",
                "content": "```\\n# Recursive \\nclass Solution:\\n    def f(self,i,j,s,t):\\n        if i<0:\\n            return j+1\\n        if j<0:\\n            return i+1\\n        if s[i]==t[j]:\\n            return 0 + self.f(i-1,j-1,s,t)\\n        else:\\n            return min((1+self.f(i-1,j,s,t)),(1+self.f(i,j-1,s,t)),(1+self.f(i-1,j-1,s,t)))\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        return self.f(m-1,n-1,word1,word2)\\n\\n     \\n#Memoisation \\n\\nclass Solution:\\n    def f(self,i,j,s,t,dp):\\n        if i<0:\\n            return j+1\\n        if j<0:\\n            return i+1\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        if s[i]==t[j]:\\n            dp[i][j]= 0 + self.f(i-1,j-1,s,t,dp)\\n        else:\\n            dp[i][j]= min((1+self.f(i-1,j,s,t,dp)),(1+self.f(i,j-1,s,t,dp)),(1+self.f(i-1,j-1,s,t,dp)))\\n        return dp[i][j]\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[-1 for i in range(n)]for j in range(m)]\\n        return self.f(m-1,n-1,word1,word2,dp)\\n      \\n                         OR \\nclass Solution:\\n    def f(self,i,j,s,t,dp):\\n        if i==0:\\n            return j\\n        if j==0:\\n            return i\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        if s[i-1]==t[j-1]:\\n            dp[i][j]= 0 + self.f(i-1,j-1,s,t,dp)\\n        else:\\n            dp[i][j]= min((1+self.f(i-1,j,s,t,dp)),(1+self.f(i,j-1,s,t,dp)),(1+self.f(i-1,j-1,s,t,dp)))\\n        return dp[i][j]\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[-1 for i in range(n+1)]for j in range(m+1)]\\n        return self.f(m,n,word1,word2,dp)\\n      \\n      \\n# Tabulation :\\n\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[0 for i in range(n+1)]for j in range(m+1)]\\n        \\n        for j in range(n+1):\\n            dp[0][j]=j\\n        for i in range(m+1):\\n            dp[i][0]=i\\n        \\n            \\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]= 0 + dp[i-1][j-1]\\n                else:\\n                    dp[i][j]= 1 + min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])\\n        return dp[m][n]\\n\\n# Space Optimised :\\ndef editDistance(word1, word2) :\\n        m=len(word1)\\n        n=len(word2)\\n        prev=[0]*(n+1)\\n        for j in range(n+1):\\n            prev[j]=j\\n        for i in range(1,m+1):\\n            curr=[0]*(n+1)\\n            curr[0]=i\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    curr[j]=prev[j-1]\\n                else:\\n                    curr[j]= 1 + min(prev[j],min(curr[j-1],prev[j-1]))\\n            prev=curr\\n        return curr[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Combinatorics"
                ],
                "code": "```\\n# Recursive \\nclass Solution:\\n    def f(self,i,j,s,t):\\n        if i<0:\\n            return j+1\\n        if j<0:\\n            return i+1\\n        if s[i]==t[j]:\\n            return 0 + self.f(i-1,j-1,s,t)\\n        else:\\n            return min((1+self.f(i-1,j,s,t)),(1+self.f(i,j-1,s,t)),(1+self.f(i-1,j-1,s,t)))\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        return self.f(m-1,n-1,word1,word2)\\n\\n     \\n#Memoisation \\n\\nclass Solution:\\n    def f(self,i,j,s,t,dp):\\n        if i<0:\\n            return j+1\\n        if j<0:\\n            return i+1\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        if s[i]==t[j]:\\n            dp[i][j]= 0 + self.f(i-1,j-1,s,t,dp)\\n        else:\\n            dp[i][j]= min((1+self.f(i-1,j,s,t,dp)),(1+self.f(i,j-1,s,t,dp)),(1+self.f(i-1,j-1,s,t,dp)))\\n        return dp[i][j]\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[-1 for i in range(n)]for j in range(m)]\\n        return self.f(m-1,n-1,word1,word2,dp)\\n      \\n                         OR \\nclass Solution:\\n    def f(self,i,j,s,t,dp):\\n        if i==0:\\n            return j\\n        if j==0:\\n            return i\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        if s[i-1]==t[j-1]:\\n            dp[i][j]= 0 + self.f(i-1,j-1,s,t,dp)\\n        else:\\n            dp[i][j]= min((1+self.f(i-1,j,s,t,dp)),(1+self.f(i,j-1,s,t,dp)),(1+self.f(i-1,j-1,s,t,dp)))\\n        return dp[i][j]\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[-1 for i in range(n+1)]for j in range(m+1)]\\n        return self.f(m,n,word1,word2,dp)\\n      \\n      \\n# Tabulation :\\n\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[0 for i in range(n+1)]for j in range(m+1)]\\n        \\n        for j in range(n+1):\\n            dp[0][j]=j\\n        for i in range(m+1):\\n            dp[i][0]=i\\n        \\n            \\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]= 0 + dp[i-1][j-1]\\n                else:\\n                    dp[i][j]= 1 + min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])\\n        return dp[m][n]\\n\\n# Space Optimised :\\ndef editDistance(word1, word2) :\\n        m=len(word1)\\n        n=len(word2)\\n        prev=[0]*(n+1)\\n        for j in range(n+1):\\n            prev[j]=j\\n        for i in range(1,m+1):\\n            curr=[0]*(n+1)\\n            curr[0]=i\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    curr[j]=prev[j-1]\\n                else:\\n                    curr[j]= 1 + min(prev[j],min(curr[j-1],prev[j-1]))\\n            prev=curr\\n        return curr[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448115,
                "title": "easy-c-recursion-memoization-tabulation-space-optimization",
                "content": "Recursion : (gives TLE)\\nTC: Exponential\\nSC : O(n+m) ; where n = length of str1 and m=length of str2\\n\\nMemoization code: \\n```\\nclass Solution {\\npublic:\\n    int func(int i, int j, string s, string t, vector<vector<int>> &dp){\\n        //base cases\\n        if(i<0){\\n            //str1 exhausted\\n            return j+1;\\n        }\\n        if(j<0){\\n            //str2 exhausted\\n            return i+1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(s[i]==t[j]){\\n            //if string chars match, do nothing, just shrink strings and continue checking\\n            return dp[i][j]=0+func(i-1, j-1, s, t, dp);\\n        }\\n        else{\\n            //if there\\'s no string matching\\n            //we can perform 3 operations -> insert, delete, replace\\n            int ins=1+func(i, j-1, s, t, dp);\\n            int del=1+func(i-1, j, s, t, dp);\\n            int repl=1+func(i-1, j-1, s, t, dp);\\n            return dp[i][j]=min(ins, min(del, repl));\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n        return func(n-1, m-1, word1, word2, dp);\\n    }\\n};\\n```\\nTC : O(n * m)\\nSC : O(n+m) + O(n * m) \\n\\nTo avoid the Auxiliary Stack Space(ASS), we further perform tabulation.\\n\\nTabulation code :\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &s, string &t) {\\n        int n=s.length();\\n        int m=t.length();\\n        \\n        vector<vector<int>> dp(n+1, vector<int> (m+1, 0));\\n        for(int i=0; i<=n; i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=0; j<=m; j++){\\n            dp[0][j]=j;\\n        }\\n        \\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1]==t[j-1]){\\n                    dp[i][j] = 0+dp[i-1][j-1];\\n                }\\n                else {\\n                    int ins=1+dp[i][j-1];\\n                    int del=1+dp[i-1][j];\\n                    int repl=1+dp[i-1][j-1];\\n                    dp[i][j] = min(ins, min(del, repl));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\nTC : O(n * m)\\nSC : O(n * m) [eliminated extra auxiliary stack space]\\n\\nTo eliminate this extra auxiliary space, we carry out space optimization.\\n\\nSpace Optimization code :\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &s, string &t) {\\n        int n=s.length();\\n        int m=t.length();\\n        \\n        vector<int> prev(m+1, 0), curr(m+1, 0);\\n        \\n        for(int j=0; j<=m; j++){\\n            prev[j]=j;\\n        }\\n        \\n        for(int i=1; i<n+1; i++){\\n            curr[0]=i;\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1]==t[j-1]){\\n                    curr[j] = 0+prev[j-1];\\n                }\\n                else {\\n                    int ins=1+curr[j-1];\\n                    int del=1+prev[j];\\n                    int repl=1+prev[j-1];\\n                    curr[j] = min(ins, min(del, repl));\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```\\nTC : O(n * m) [2 nested for loops]\\nSC : O(m)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(int i, int j, string s, string t, vector<vector<int>> &dp){\\n        //base cases\\n        if(i<0){\\n            //str1 exhausted\\n            return j+1;\\n        }\\n        if(j<0){\\n            //str2 exhausted\\n            return i+1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(s[i]==t[j]){\\n            //if string chars match, do nothing, just shrink strings and continue checking\\n            return dp[i][j]=0+func(i-1, j-1, s, t, dp);\\n        }\\n        else{\\n            //if there\\'s no string matching\\n            //we can perform 3 operations -> insert, delete, replace\\n            int ins=1+func(i, j-1, s, t, dp);\\n            int del=1+func(i-1, j, s, t, dp);\\n            int repl=1+func(i-1, j-1, s, t, dp);\\n            return dp[i][j]=min(ins, min(del, repl));\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n        return func(n-1, m-1, word1, word2, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &s, string &t) {\\n        int n=s.length();\\n        int m=t.length();\\n        \\n        vector<vector<int>> dp(n+1, vector<int> (m+1, 0));\\n        for(int i=0; i<=n; i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=0; j<=m; j++){\\n            dp[0][j]=j;\\n        }\\n        \\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1]==t[j-1]){\\n                    dp[i][j] = 0+dp[i-1][j-1];\\n                }\\n                else {\\n                    int ins=1+dp[i][j-1];\\n                    int del=1+dp[i-1][j];\\n                    int repl=1+dp[i-1][j-1];\\n                    dp[i][j] = min(ins, min(del, repl));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &s, string &t) {\\n        int n=s.length();\\n        int m=t.length();\\n        \\n        vector<int> prev(m+1, 0), curr(m+1, 0);\\n        \\n        for(int j=0; j<=m; j++){\\n            prev[j]=j;\\n        }\\n        \\n        for(int i=1; i<n+1; i++){\\n            curr[0]=i;\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1]==t[j-1]){\\n                    curr[j] = 0+prev[j-1];\\n                }\\n                else {\\n                    int ins=1+curr[j-1];\\n                    int del=1+prev[j];\\n                    int repl=1+prev[j-1];\\n                    curr[j] = min(ins, min(del, repl));\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420042,
                "title": "c-memoization-tabulation",
                "content": "**Memoization**\\n```\\nint memoization(string& s,string& d,int sin,\\n                   int din,vector<vector<int>>& memory)\\n    {\\n        if(din==0)\\n            return sin;\\n        if(sin==0)\\n            return din;\\n        if(memory[sin][din]!=-1)\\n            return memory[sin][din];\\n        if(s[sin-1]==d[din-1])\\n            return memory[sin][din]=\\n            memoization(s,d,sin-1,din-1,memory);\\n        return memory[sin][din]=\\n            1+min(memoization(s,d,sin-1,din,memory),\\n                  min(\\n                 memoization(s,d,sin-1,din-1,memory),\\n                 memoization(s,d,sin,din-1,memory)));\\n    }\\n```\\n**Tabulation**\\n```\\n int tabulation(string& s,string& d,\\n                   vector<vector<int>>& dp)\\n    {\\n        int sin=s.length(),din=d.length();\\n        for(int i=0;i<=sin;i++)\\n            dp[i][0]=i;\\n        for(int j=0;j<=din;j++)\\n            dp[0][j]=j;\\n        for(int i=1;i<=sin;i++)\\n            for(int j=1;j<=din;j++)\\n            {\\n                if(s[i-1]==d[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else\\n                    dp[i][j]=1+min(dp[i-1][j-1],\\n                                  min(dp[i][j-1],\\n                                     dp[i-1][j]));\\n            }\\n        return dp[sin][din];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint memoization(string& s,string& d,int sin,\\n                   int din,vector<vector<int>>& memory)\\n    {\\n        if(din==0)\\n            return sin;\\n        if(sin==0)\\n            return din;\\n        if(memory[sin][din]!=-1)\\n            return memory[sin][din];\\n        if(s[sin-1]==d[din-1])\\n            return memory[sin][din]=\\n            memoization(s,d,sin-1,din-1,memory);\\n        return memory[sin][din]=\\n            1+min(memoization(s,d,sin-1,din,memory),\\n                  min(\\n                 memoization(s,d,sin-1,din-1,memory),\\n                 memoization(s,d,sin,din-1,memory)));\\n    }\\n```\n```\\n int tabulation(string& s,string& d,\\n                   vector<vector<int>>& dp)\\n    {\\n        int sin=s.length(),din=d.length();\\n        for(int i=0;i<=sin;i++)\\n            dp[i][0]=i;\\n        for(int j=0;j<=din;j++)\\n            dp[0][j]=j;\\n        for(int i=1;i<=sin;i++)\\n            for(int j=1;j<=din;j++)\\n            {\\n                if(s[i-1]==d[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else\\n                    dp[i][j]=1+min(dp[i-1][j-1],\\n                                  min(dp[i][j-1],\\n                                     dp[i-1][j]));\\n            }\\n        return dp[sin][din];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2350419,
                "title": "cpp-dp-memorization-inline-comments-simple",
                "content": "Please upvote if you understood !\\n\\n\\tint count(string &word1,string &word2,int i,int j,vector<vector<int>> &dp){\\n\\t\\t// if second string exhausted , return length of first string as min number of operatons.\\n        if(j<0) return i+1;\\n\\t\\t// if first string exhausted , return length of second string as min number of operatons.\\n        if(i<0) return j+1;\\n        \\n        if(dp[i][j]!= -1) return dp[i][j];\\n        \\n\\t\\t// if match found of characters just shift to previous index.\\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=count(word1,word2,i-1,j-1,dp);\\n        }\\n        else{\\n\\t\\t\\t// insert operation\\n            int insert=1+count(word1,word2,i,j-1,dp);\\n\\t\\t\\t// delete operation\\n            int del=1+count(word1,word2,i-1,j,dp);\\n\\t\\t\\t// replace operation\\n            int replace=1+count(word1,word2,i-1,j-1,dp);\\n\\t\\t\\t// return minimum of the three operations.\\n            return dp[i][j]=min(insert,min(del,replace));\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n\\t\\t// start from end of strings\\n        return count(word1,word2,n-1,m-1,dp);\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "Please upvote if you understood !\\n\\n\\tint count(string &word1,string &word2,int i,int j,vector<vector<int>> &dp){\\n\\t\\t// if second string exhausted , return length of first string as min number of operatons.\\n        if(j<0) return i+1;\\n\\t\\t// if first string exhausted , return length of second string as min number of operatons.\\n        if(i<0) return j+1;\\n        \\n        if(dp[i][j]!= -1) return dp[i][j];\\n        \\n\\t\\t// if match found of characters just shift to previous index.\\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=count(word1,word2,i-1,j-1,dp);\\n        }\\n        else{\\n\\t\\t\\t// insert operation\\n            int insert=1+count(word1,word2,i,j-1,dp);\\n\\t\\t\\t// delete operation\\n            int del=1+count(word1,word2,i-1,j,dp);\\n\\t\\t\\t// replace operation\\n            int replace=1+count(word1,word2,i-1,j-1,dp);\\n\\t\\t\\t// return minimum of the three operations.\\n            return dp[i][j]=min(insert,min(del,replace));\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n\\t\\t// start from end of strings\\n        return count(word1,word2,n-1,m-1,dp);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2227245,
                "title": "c-dp-with-memoization-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        /* dp formulation\\n         *\\n         * dp[i][j] shall represent the minimum number of edits\\n         * required to get word1[:i] to match word2[:j].\\n         *\\n         * propagation:\\n         * if word1[i-1] == word2[j-1] then no extra edits are necessary,\\n         *     then dp[i][j] = dp[i-1][j-1]\\n         *\\n         * otherwise,\\n         * dp[i][j] = min(dp[i-1][j-1] + 1 // replacement\\n         *               ,dp[i][j-1] + 1 // insertion\\n         *               ,dp[i-1][j] + 1 // deletion\\n         *               )\\n         */\\n        int m = word1.size(); int n = word2.size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        for (int i = 0; i <= m; i++)\\n        {\\n            for (int j = 0; j <= n; j++)\\n            {\\n                if (i == 0)\\n                {\\n                    dp[i][j] = j;\\n                }\\n                else if (j == 0)\\n                {\\n                    dp[i][j] = i;\\n                }\\n                else\\n                {\\n                    if (word1[i-1] == word2[j-1])\\n                    {\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = min(dp[i-1][j-1] + 1 // replacement\\n                                      ,min(dp[i][j-1] + 1 // insertion\\n                                          ,dp[i-1][j] + 1 // deletion\\n                                          )\\n                                      );\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp.back().back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        /* dp formulation\\n         *\\n         * dp[i][j] shall represent the minimum number of edits\\n         * required to get word1[:i] to match word2[:j].\\n         *\\n         * propagation:\\n         * if word1[i-1] == word2[j-1] then no extra edits are necessary,\\n         *     then dp[i][j] = dp[i-1][j-1]\\n         *\\n         * otherwise,\\n         * dp[i][j] = min(dp[i-1][j-1] + 1 // replacement\\n         *               ,dp[i][j-1] + 1 // insertion\\n         *               ,dp[i-1][j] + 1 // deletion\\n         *               )\\n         */\\n        int m = word1.size(); int n = word2.size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        for (int i = 0; i <= m; i++)\\n        {\\n            for (int j = 0; j <= n; j++)\\n            {\\n                if (i == 0)\\n                {\\n                    dp[i][j] = j;\\n                }\\n                else if (j == 0)\\n                {\\n                    dp[i][j] = i;\\n                }\\n                else\\n                {\\n                    if (word1[i-1] == word2[j-1])\\n                    {\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = min(dp[i-1][j-1] + 1 // replacement\\n                                      ,min(dp[i][j-1] + 1 // insertion\\n                                          ,dp[i-1][j] + 1 // deletion\\n                                          )\\n                                      );\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp.back().back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223204,
                "title": "top-down-bottom-up-and-optimized-dynamic-programming",
                "content": "We can either inesrt, delete or replace a character in word1.\\n\\nOur goal is to get to word2 in minimum moves.\\n\\nWe don\\'t have to actually perform this operations, but logically trace the result by manipulating the pointers. Let\\'s have a pointer starting at 0 for word1, and starting at 0 for word2 (for bottom-up, it will be in reverse)\\n\\n* Replace - to replace we move both points and add 1\\n* Delete - to delete we move word1_pointer and don\\'t touch word2_pointer\\n* Insert - we move word2_pointer and don\\'t touch word1_pointer\\n\\nReturn the minimum out of these 3 options to solve each sub-problem.\\n\\n# Top-down memoized\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        return self.find_distance(word1, 0, word2, 0, {})\\n\\n    def find_distance(self, word1, word1_pointer, word2, word2_pointer, memo):\\n        if word1_pointer == len(word1) and word2_pointer == len(word2):\\n            return 0\\n        \\n        if word1_pointer == len(word1) or word2_pointer == len(word2):\\n            return max(len(word1) - word1_pointer, len(word2) - word2_pointer)\\n        \\n        key = (word1_pointer, word2_pointer)\\n        if key in memo: return memo[key]\\n        \\n        word1_len = len(word1) - word1_pointer\\n        word2_len = len(word2) - word2_pointer\\n        \\n        if word1[word1_pointer] == word2[word2_pointer]:\\n            memo[key] = self.find_distance(word1, word1_pointer + 1, word2, word2_pointer + 1, memo)\\n        else:\\n            memo[key] =  1 + self.make_move(word1, word1_pointer, word2, word2_pointer, memo)\\n            \\n        return memo[key]\\n    \\n    \\n    def make_move(self, word1, word1_pointer, word2, word2_pointer, memo):\\n        return min(\\n                self.find_distance(word1, word1_pointer + 1, word2, word2_pointer + 1, memo), # update\\n                self.find_distance(word1, word1_pointer, word2, word2_pointer + 1, memo), # insert\\n                self.find_distance(word1, word1_pointer + 1, word2, word2_pointer, memo) # delete\\n            )\\n        \\n        \\n```\\n\\n\\n# Bottom-up DP\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        word1_len = len(word1)\\n        word2_len = len(word2)\\n        \\n        dp = [[0 for _ in range(word1_len + 1)] for _ in range(word2_len + 1)]\\n        \\n        # Base cases\\n        \\n        # When no words = 0 moves needed\\n        dp[word2_len][word1_len] = 0\\n        \\n        # When one of the strings is missing. the other one\\'s length is required (either delete or insert)\\n        for r in range(word2_len - 1, -1, -1):\\n            dp[r][word1_len] = word2_len - r\\n            \\n        for c in range(word1_len - 1, -1, -1):\\n            dp[word2_len][c] = word1_len - c\\n        \\n        # Transitions\\n        for word2_p in range(word2_len - 1, -1, -1):\\n            for word1_p in range(word1_len -1, -1, -1):\\n                if word1[word1_p] == word2[word2_p]:\\n                    dp[word2_p][word1_p] = dp[word2_p+1][word1_p+1]\\n                else:\\n                    dp[word2_p][word1_p] = 1 + min(\\n                        dp[word2_p][word1_p+1], # delete\\n                        dp[word2_p+1][word1_p], # insert\\n                        dp[word2_p+1][word1_p+1] # replace\\n                    )\\n\\n        return dp[0][0]\\n```\\n\\n\\n# Optimized DP\\nSince we only need the last row in each iteration, we can trim to O(n) space complexity by only saving the last row result.\\n\\n\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        word1_len = len(word1)\\n        word2_len = len(word2)\\n        \\n        \\n        # When one of the strings is missing. the other one\\'s length is required (either delete or insert)\\n        last_row = [0] * (word1_len+1)\\n            \\n        for c in range(word1_len - 1, -1, -1):\\n            last_row[c] = word1_len - c\\n        \\n        # Transitions\\n        for word2_p in range(word2_len - 1, -1, -1):\\n            cur_row = [0] * (word1_len+1)\\n            cur_row[word1_len] = word2_len - word2_p\\n            \\n            for word1_p in range(word1_len -1, -1, -1):\\n                if word1[word1_p] == word2[word2_p]:\\n                    cur_row[word1_p] = last_row[word1_p+1]\\n                else:\\n                    cur_row[word1_p] = 1 + min(\\n                        cur_row[word1_p+1], # delete\\n                        last_row[word1_p], # insert\\n                        last_row[word1_p+1] # replace\\n                    )\\n            \\n            last_row = cur_row\\n\\n        return last_row[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        return self.find_distance(word1, 0, word2, 0, {})\\n\\n    def find_distance(self, word1, word1_pointer, word2, word2_pointer, memo):\\n        if word1_pointer == len(word1) and word2_pointer == len(word2):\\n            return 0\\n        \\n        if word1_pointer == len(word1) or word2_pointer == len(word2):\\n            return max(len(word1) - word1_pointer, len(word2) - word2_pointer)\\n        \\n        key = (word1_pointer, word2_pointer)\\n        if key in memo: return memo[key]\\n        \\n        word1_len = len(word1) - word1_pointer\\n        word2_len = len(word2) - word2_pointer\\n        \\n        if word1[word1_pointer] == word2[word2_pointer]:\\n            memo[key] = self.find_distance(word1, word1_pointer + 1, word2, word2_pointer + 1, memo)\\n        else:\\n            memo[key] =  1 + self.make_move(word1, word1_pointer, word2, word2_pointer, memo)\\n            \\n        return memo[key]\\n    \\n    \\n    def make_move(self, word1, word1_pointer, word2, word2_pointer, memo):\\n        return min(\\n                self.find_distance(word1, word1_pointer + 1, word2, word2_pointer + 1, memo), # update\\n                self.find_distance(word1, word1_pointer, word2, word2_pointer + 1, memo), # insert\\n                self.find_distance(word1, word1_pointer + 1, word2, word2_pointer, memo) # delete\\n            )\\n        \\n        \\n```\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        word1_len = len(word1)\\n        word2_len = len(word2)\\n        \\n        dp = [[0 for _ in range(word1_len + 1)] for _ in range(word2_len + 1)]\\n        \\n        # Base cases\\n        \\n        # When no words = 0 moves needed\\n        dp[word2_len][word1_len] = 0\\n        \\n        # When one of the strings is missing. the other one\\'s length is required (either delete or insert)\\n        for r in range(word2_len - 1, -1, -1):\\n            dp[r][word1_len] = word2_len - r\\n            \\n        for c in range(word1_len - 1, -1, -1):\\n            dp[word2_len][c] = word1_len - c\\n        \\n        # Transitions\\n        for word2_p in range(word2_len - 1, -1, -1):\\n            for word1_p in range(word1_len -1, -1, -1):\\n                if word1[word1_p] == word2[word2_p]:\\n                    dp[word2_p][word1_p] = dp[word2_p+1][word1_p+1]\\n                else:\\n                    dp[word2_p][word1_p] = 1 + min(\\n                        dp[word2_p][word1_p+1], # delete\\n                        dp[word2_p+1][word1_p], # insert\\n                        dp[word2_p+1][word1_p+1] # replace\\n                    )\\n\\n        return dp[0][0]\\n```\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        word1_len = len(word1)\\n        word2_len = len(word2)\\n        \\n        \\n        # When one of the strings is missing. the other one\\'s length is required (either delete or insert)\\n        last_row = [0] * (word1_len+1)\\n            \\n        for c in range(word1_len - 1, -1, -1):\\n            last_row[c] = word1_len - c\\n        \\n        # Transitions\\n        for word2_p in range(word2_len - 1, -1, -1):\\n            cur_row = [0] * (word1_len+1)\\n            cur_row[word1_len] = word2_len - word2_p\\n            \\n            for word1_p in range(word1_len -1, -1, -1):\\n                if word1[word1_p] == word2[word2_p]:\\n                    cur_row[word1_p] = last_row[word1_p+1]\\n                else:\\n                    cur_row[word1_p] = 1 + min(\\n                        cur_row[word1_p+1], # delete\\n                        last_row[word1_p], # insert\\n                        last_row[word1_p+1] # replace\\n                    )\\n            \\n            last_row = cur_row\\n\\n        return last_row[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179297,
                "title": "recursive-memoized-easy-to-understand-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        return helper(word1, word2, m, n, dp);\\n    }\\n    int helper(string word1, string word2, int m, int n, vector<vector<int>> &dp) {\\n        if (m == 0) {\\n            return n; // need to remove n characters from word2\\n        }\\n        if (n == 0) {\\n            return m; // need to add m characters to word1\\n        }\\n        if (dp[m][n] != -1) {\\n            return dp[m][n]; // memoization\\n        }\\n        if (word1[m-1] == word2[n-1]) { // same character so do nothing\\n            return dp[m][n] = helper(word1, word2, m-1, n-1, dp);\\n        }\\n        // check min value from all cases\\n        int ans = INT_MAX;\\n        ans = min(ans, helper(word1, word2, m-1, n-1, dp)); // replace\\n        ans = min(ans, helper(word1, word2, m-1, n, dp)); // delete \\n        ans = min(ans, helper(word1, word2, m, n-1, dp)); // addition\\n        return dp[m][n] = 1 + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        return helper(word1, word2, m, n, dp);\\n    }\\n    int helper(string word1, string word2, int m, int n, vector<vector<int>> &dp) {\\n        if (m == 0) {\\n            return n; // need to remove n characters from word2\\n        }\\n        if (n == 0) {\\n            return m; // need to add m characters to word1\\n        }\\n        if (dp[m][n] != -1) {\\n            return dp[m][n]; // memoization\\n        }\\n        if (word1[m-1] == word2[n-1]) { // same character so do nothing\\n            return dp[m][n] = helper(word1, word2, m-1, n-1, dp);\\n        }\\n        // check min value from all cases\\n        int ans = INT_MAX;\\n        ans = min(ans, helper(word1, word2, m-1, n-1, dp)); // replace\\n        ans = min(ans, helper(word1, word2, m-1, n, dp)); // delete \\n        ans = min(ans, helper(word1, word2, m, n-1, dp)); // addition\\n        return dp[m][n] = 1 + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170099,
                "title": "c-easy-tabulation-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n        \\n        int dp[n+1][m+1]; \\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0){\\n                    dp[i][j] = max(i,j);\\n                }\\n                else if(word1[i-1]==word2[j-1]){\\n                    dp[i][j]= dp[i-1][j-1];\\n                }\\n            else if(word1[i-1]!=word2[j-1]){\\n                dp[i][j]=min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1])) +1;\\n              }\\n            }\\n        }\\n     return dp[n][m];  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n        \\n        int dp[n+1][m+1]; \\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0){\\n                    dp[i][j] = max(i,j);\\n                }\\n                else if(word1[i-1]==word2[j-1]){\\n                    dp[i][j]= dp[i-1][j-1];\\n                }\\n            else if(word1[i-1]!=word2[j-1]){\\n                dp[i][j]=min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1])) +1;\\n              }\\n            }\\n        }\\n     return dp[n][m];  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110592,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n\\tint ans[502][502];\\n\\tint dp(string s1, string s2, int n, int m)\\n\\t{\\n\\t\\tif (ans[n][m] != -1)\\n\\t\\t\\treturn ans[n][m];\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn ans[n][m] = m;\\n\\t\\tif (m == 0)\\n\\t\\t\\treturn ans[n][m] = n;\\n\\t\\tif (s1[n - 1] == s2[m - 1])\\n\\t\\t\\treturn ans[n][m] = dp(s1, s2, n - 1, m - 1);\\n\\t\\telse\\n\\t\\t\\treturn ans[n][m] = 1 + min(dp(s1, s2, n - 1, m), min(dp(s1, s2, n, m - 1), dp(s1, s2, n - 1, m - 1)));\\n\\t}\\n\\tint minDistance(string s1, string s2)\\n\\t{\\n\\t\\tmemset(ans, -1, sizeof(ans));\\n\\t\\treturn dp(s1, s2, s1.length(), s2.length());\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint ans[502][502];\\n\\tint dp(string s1, string s2, int n, int m)\\n\\t{\\n\\t\\tif (ans[n][m] != -1)\\n\\t\\t\\treturn ans[n][m];\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn ans[n][m] = m;\\n\\t\\tif (m == 0)\\n\\t\\t\\treturn ans[n][m] = n;\\n\\t\\tif (s1[n - 1] == s2[m - 1])\\n\\t\\t\\treturn ans[n][m] = dp(s1, s2, n - 1, m - 1);\\n\\t\\telse\\n\\t\\t\\treturn ans[n][m] = 1 + min(dp(s1, s2, n - 1, m), min(dp(s1, s2, n, m - 1), dp(s1, s2, n - 1, m - 1)));\\n\\t}\\n\\tint minDistance(string s1, string s2)\\n\\t{\\n\\t\\tmemset(ans, -1, sizeof(ans));\\n\\t\\treturn dp(s1, s2, s1.length(), s2.length());\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025208,
                "title": "c-5-line-super-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(string &a,string &b,int i,int j,int n,int m)\\n    {\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(i==n)return m-j;//if a string is traversed return whats left in b string\\n        if(j==m)return n-i;// and vice verse\\n        if(a[i]==b[j])return dp[i][j]=solve(a,b,i+1,j+1,n,m);//if a and b char are same do i++ and j++\\n        return dp[i][j]=1+min(solve(a,b,i+1,j,n,m),min(solve(a,b,i,j+1,n,m),solve(a,b,i+1,j+1,n,m)));\\n\\t\\t//else check for 3 conditions \\n\\t\\t1.del the character\\n\\t\\t2.insert the character\\n\\t\\t3.replace the character\\n\\t\\t//dry run these 3 conditions and u will get this one\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(word1,word2,0,0,word1.size(),word2.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(string &a,string &b,int i,int j,int n,int m)\\n    {\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(i==n)return m-j;//if a string is traversed return whats left in b string\\n        if(j==m)return n-i;// and vice verse\\n        if(a[i]==b[j])return dp[i][j]=solve(a,b,i+1,j+1,n,m);//if a and b char are same do i++ and j++\\n        return dp[i][j]=1+min(solve(a,b,i+1,j,n,m),min(solve(a,b,i,j+1,n,m),solve(a,b,i+1,j+1,n,m)));\\n\\t\\t//else check for 3 conditions \\n\\t\\t1.del the character\\n\\t\\t2.insert the character\\n\\t\\t3.replace the character\\n\\t\\t//dry run these 3 conditions and u will get this one\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(word1,word2,0,0,word1.size(),word2.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005424,
                "title": "c-dp-o-m-n-easiest-explanation-so-far",
                "content": "\\n\\n \\xA0  int minDistance(string word1, string word2) {\\n        int m= word1.length(), n= word2.length();\\n        vector<vector<int>>tab(m+1, vector<int>(n+1));\\n        \\n        //if word1 is empty, then we have to add all n chars of word2\\n        if(m== 0)\\n            return n;\\n        //if word2 is empty, then we have to delete all m chars of word1\\n        if(n== 0)\\n            return m;\\n        \\n        for(int i =0;i<=m;i++){\\n            for(int j = 0;j<=n;j++){\\n                \\n                /*       g e s e k\\n                     g   0 1 2 3 4\\n                     e   1\\n                     e   2\\n                     k   3\\n                     */\\n                //you can see from dp table, word1 = g(i= 0), (and word2 = g(j ==0))\\n                //so g== g, we need 0 operation, as j== 1 word1 = g & word2 =ge\\n                //g--> ge need 1 operations(addition of e)\\n                //0th row = 0 1 2 3...j\\n                if(i== 0)\\n                    tab[i][j] = j;\\n                else if(j == 0)\\n                    tab[i][j] = i;\\n                //chars are same no operation required\\n                else if(word1[i-1] == word2[j-1])\\n                    tab[i][j] = tab[i-1][j-1];\\n                else{\\n    \\t                tab[i][j] = 1+min(tab[i][j-1], min(tab[i-1][j], tab[i-1][j-1]));\\n                    \\n                        /*insert: word1 = geek, word2 = gesek\\n                        at i = 1 & j= 2, we are ignoring s (by j-1) of word2 and adding\\n                        1 as insret operation, we are not actually adding, we are assuming\\n                        these operations only, remove and replace can be assumed */\\n                }\\n            }\\n            \\n        }\\n        return tab[m][n];\\n    }\\n};",
                "solutionTags": [],
                "code": "\\n\\n \\xA0  int minDistance(string word1, string word2) {\\n        int m= word1.length(), n= word2.length();\\n        vector<vector<int>>tab(m+1, vector<int>(n+1));\\n        \\n        //if word1 is empty, then we have to add all n chars of word2\\n        if(m== 0)\\n            return n;\\n        //if word2 is empty, then we have to delete all m chars of word1\\n        if(n== 0)\\n            return m;\\n        \\n        for(int i =0;i<=m;i++){\\n            for(int j = 0;j<=n;j++){\\n                \\n                /*       g e s e k\\n                     g   0 1 2 3 4\\n                     e   1\\n                     e   2\\n                     k   3\\n                     */\\n                //you can see from dp table, word1 = g(i= 0), (and word2 = g(j ==0))\\n                //so g== g, we need 0 operation, as j== 1 word1 = g & word2 =ge\\n                //g--> ge need 1 operations(addition of e)\\n                //0th row = 0 1 2 3...j\\n                if(i== 0)\\n                    tab[i][j] = j;\\n                else if(j == 0)\\n                    tab[i][j] = i;\\n                //chars are same no operation required\\n                else if(word1[i-1] == word2[j-1])\\n                    tab[i][j] = tab[i-1][j-1];\\n                else{\\n    \\t                tab[i][j] = 1+min(tab[i][j-1], min(tab[i-1][j], tab[i-1][j-1]));\\n                    \\n                        /*insert: word1 = geek, word2 = gesek\\n                        at i = 1 & j= 2, we are ignoring s (by j-1) of word2 and adding\\n                        1 as insret operation, we are not actually adding, we are assuming\\n                        these operations only, remove and replace can be assumed */\\n                }\\n            }\\n            \\n        }\\n        return tab[m][n];\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1945530,
                "title": "c-100-faster-all-approach-included",
                "content": "Suggestion : \\nTrust me if you were able to write the recurrence then the problem is just a cake for you. So now Try yourself and find the recurrence to solve this problem. If you were not able to figure out then no worries please read the full editorial. I will try to make it super easy for you. \\nLets dive deep what the problem is all about ? and note the imp points:\\n1. convert string S1 to string S2 \\n2. operation allowed are:\\n  a. insertion \\n  b. deletion \\n  c. replace \\n3. return min number of operations \\n\\nNow lets observe the worst case : \\nif s1 = \"horse\" and s2= \"ros\" then what my mind says is that delete every character of s1 and then insert every character of s2. so max number of operations are : N(length of s1) + M (length of s2). \\nnow optimized this; \\n**One observation i can deduce is that if only insertion and deletion is allowed then this question will be similar to \"min number of insertion/deletion to convert s1 to s2\"** which is solved using the concept of lcs. \\nbut till now we have not consider the importance of replace operation. \\n\\nNow lets try to form the solution together. \\n\\nif you observe there can be only 2 cases formed (like every sting dp question)\\n**case 1:**\\nif s1[i]==s2[j] then no operation is require hence **F(i,j) = F(i-1,j-1)**\\n**case 2:**\\nif s1[i]!=s2[j] so there are 3 possibilites as given in question now if you were able to write the recurrence for each condition and take the min out of them . Hurrah!! you are done with the solution. Congrats!! . \\n1. replace \\n**F(i,j) = F(i-1,j-1)**\\n2. delete \\n**F(i,j) = F(i-1,j)**\\n3. insert\\n**F(i,j)= F(i,j-1)**\\nans = min (replace , delete, insert)\\n\\nI hope you understand the approach. Lets see code of all approaches\\n**1. Memoization**\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(n-1,m-1,word1,word2,dp);\\n    }\\n    int solve(int i,int j,string word1,string word2,vector<vector<int>> &dp){\\n        \\n        if(i<0) return j+1;\\n        if(j<0) return i+1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=solve(i-1,j-1,word1,word2,dp);\\n        }\\n        \\n            char c= word1[i];\\n            word1[i]=word2[j];\\n            int rep= 1 + solve(i-1,j-1,word1,word2,dp);\\n            word1[i]=c;\\n            int del= 1+ solve(i-1,j,word1,word2,dp);\\n            int ins= 1+ solve(i,j-1,word1,word2,dp);\\n        return dp[i][j]=min(rep,min(del,ins));;\\n    }\\n};\\n```\\n**Time Complexity: O(n*m)\\nSpace Complexity: O(stack space) + O(n*m)**\\n\\n**2. Tabulation**\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=m;i++){\\n            dp[0][i]= i;\\n        }\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(word1[i-1]==word2[j-1]) dp[i][j]= dp[i-1][j-1];\\n                else {\\n                    dp[i][j]= 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n```\\n**Time Complexity: O(n*m)\\nSpace Complexity: O(n*m)\\nRuntime : 0ms (100% faster)**\\n\\n**3. Space Optimization**\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        int prev[m+1],temp[m+1];\\n        for(int i=0;i<=m;i++){\\n            prev[i]= i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            temp[0]=i;\\n            for(int j=1;j<=m;j++){\\n           \\n                if(word1[i-1]==word2[j-1]) temp[j]= prev[j-1];\\n                else {\\n                    temp[j]= 1 + min(prev[j-1],min(prev[j],temp[j-1]));\\n                }\\n            }\\n            for(int i=0;i<=m;i++) prev[i]= temp[i];\\n        }\\n        return prev[m];\\n    }\\n \\n};\\n```\\n**Time Complexity: O(n*m)\\nSpace Complexity: O(m)**\\n\\n**Upvote If you like my approach.**\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(n-1,m-1,word1,word2,dp);\\n    }\\n    int solve(int i,int j,string word1,string word2,vector<vector<int>> &dp){\\n        \\n        if(i<0) return j+1;\\n        if(j<0) return i+1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=solve(i-1,j-1,word1,word2,dp);\\n        }\\n        \\n            char c= word1[i];\\n            word1[i]=word2[j];\\n            int rep= 1 + solve(i-1,j-1,word1,word2,dp);\\n            word1[i]=c;\\n            int del= 1+ solve(i-1,j,word1,word2,dp);\\n            int ins= 1+ solve(i,j-1,word1,word2,dp);\\n        return dp[i][j]=min(rep,min(del,ins));;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=m;i++){\\n            dp[0][i]= i;\\n        }\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(word1[i-1]==word2[j-1]) dp[i][j]= dp[i-1][j-1];\\n                else {\\n                    dp[i][j]= 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        int prev[m+1],temp[m+1];\\n        for(int i=0;i<=m;i++){\\n            prev[i]= i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            temp[0]=i;\\n            for(int j=1;j<=m;j++){\\n           \\n                if(word1[i-1]==word2[j-1]) temp[j]= prev[j-1];\\n                else {\\n                    temp[j]= 1 + min(prev[j-1],min(prev[j],temp[j-1]));\\n                }\\n            }\\n            for(int i=0;i<=m;i++) prev[i]= temp[i];\\n        }\\n        return prev[m];\\n    }\\n \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929959,
                "title": "c-memoization-recursion-with-explanation",
                "content": "In this question you just have 3 options for non matching character and no need to do any operation for matching character.\\n\\nthe main key point of this question is base case.\\n\\nthere are 3 base case\\'s \\n1. when we have reached the end of both the strings, return 0.\\n2. when we have reached end of any of the string just return the diff of i and j plus one that it.\\n\\nhope understand.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int rec(string word1,string word2,int i,int j)\\n    {\\n        if(i<0 && j<0)\\n        {\\n            return 0;\\n        }\\n        if(i<0 && j>=0)\\n        {\\n            return j+1;\\n        }\\n        if(i>=0 && j<0)\\n        {\\n            return i+1;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int ans=0;\\n        if(word1[i]!=word2[j])\\n        {\\n            int a=1+rec(word1,word2,i,j-1);\\n            int b=1+rec(word1,word2,i-1,j);\\n            int c=1+rec(word1,word2,i-1,j-1);\\n            ans=min(a,min(b,c));\\n        }else\\n        {\\n            ans=rec(word1,word2,i-1,j-1);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof dp);\\n        int n=word1.size();\\n        int m=word2.size();\\n        if(n==0 || m==0)\\n        {\\n            return abs(m-n);\\n        }\\n        return rec(word1,word2,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int rec(string word1,string word2,int i,int j)\\n    {\\n        if(i<0 && j<0)\\n        {\\n            return 0;\\n        }\\n        if(i<0 && j>=0)\\n        {\\n            return j+1;\\n        }\\n        if(i>=0 && j<0)\\n        {\\n            return i+1;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int ans=0;\\n        if(word1[i]!=word2[j])\\n        {\\n            int a=1+rec(word1,word2,i,j-1);\\n            int b=1+rec(word1,word2,i-1,j);\\n            int c=1+rec(word1,word2,i-1,j-1);\\n            ans=min(a,min(b,c));\\n        }else\\n        {\\n            ans=rec(word1,word2,i-1,j-1);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof dp);\\n        int n=word1.size();\\n        int m=word2.size();\\n        if(n==0 || m==0)\\n        {\\n            return abs(m-n);\\n        }\\n        return rec(word1,word2,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888200,
                "title": "explained-step-by-step-description-and-solution-easy-to-understand-answering-the-why",
                "content": "\\nThe post will follow the flow: Choices -> Examples -> Recurrence Relation -> Filling out table -> Solution\\n\\n*Sorry if there are any typos but comment and I\\'ll try to make edits*\\n\\n# Edit Distance\\nTo begin working on really any dynamic programming problem you want to think about those sub problems and about what decisions we can make throughout the process of solving the problem. The decisions we are able to make at any given letter are in this problem explicitly given to us as the following three:\\n\\n1. We can **delete** a letter\\n2. We can **insert** a letter\\n3. We can **replace** a letter\\n\\nLets look at some examples to get a better grasp of what exactly those decisions look like\\n\\n```\\nInput: word1 = \"java\", word2 = \"swift\"\\n```\\nThroughout these decisions our focus will be on the last letters of each string. Our larger goal is to get the two words to be the same but we will focus on letter by letter starting from the end. \\n\\n**Decision 1: We can delete a letter**\\n![image](https://assets.leetcode.com/users/images/fa4261a8-fff4-410a-88f9-7dd78f25b838_1648371955.8076708.png)\\nWe are trying to get \"java\" to become \"swift.\" If we can delete a letter from \"java\" and our goal is to get the last letter to equal the last of \"swift\" then we will remove the letter \\'a\\'. If we delete the last letter in \"java\" it now becomes \"jav\" but \"jav\" still isn\\'t equal to swift. So our subproblem now is to get \"jav\" to become \"swift.\" Notice how we chose to make a decision and now we have a sub problem.\\n\\n\\n**Decision 2: We can insert a letter**\\n![image](https://assets.leetcode.com/users/images/af9d5024-5ef7-4d17-b378-96d727f90816_1648372005.563788.png)\\nWe are trying to get \"java\" to become \"swift.\" If we can insert a letter into \"java\" and our goal is to get the last letter to equal the last letter of \"swift\" then the letter we will insert will be a \\'t\\'. If we insert a \\'t\\' then we get \\'javat\\' and now the last letters are equal but the rest of the word isn\\'t. So our subproblem is now to look at the remaining letters in the words (\\'java\\', \\'swif\\')\\n\\n**Decision 3: We can replace a letter**\\n![image](https://assets.leetcode.com/users/images/1619d600-6085-4c83-ac18-94eacbffc7fc_1648372049.465201.png)\\n\\nAs before we are trying to get \"java\" to become \"swift.\" If we can replace a letter in \"java\" so that the last letter equals the last letter of \"swift\" then we will replace the \\'a\\' to a \\'t\\'. This will result in \"javt\" and \"swift\" and now the last letters are equal but the rest of the word isn\\'t equal. Our new subproblem becomes to get \"jav\" to equal \"swif\"\\n\\n**Important Note**\\nWe talked about the 3 explicitly named decisions for this problem but there is a subtle 4th decision, we can do nothing. This decision would be the decision we choose if the last letter is already the same because there\\'s no need to delete, insert, or replace that last letter. So in this case we will just do nothing to that last letter and continue looking at the rest of the word\\n\\n# Table setup\\n![image](https://assets.leetcode.com/users/images/dfd5f9fe-ffc2-40ab-b76d-6c8b1704e9aa_1648372147.6479256.png)\\nLets explain these cells and the logic being used to fill them so far. The columns represent letters of the word we currently have and the rows represent letters of the word we want. \\n\\nSo table[0][0] can be read as \"Whats the minimum number of steps to turn an empty string into an empty string?\"\\nWell 0 steps are needed to do that. \\n\\nTable[0][4] can be read as \"Whats the minimum number of steps to turn an empty string into java?\" You would need 4 steps to do that, more specifically 4 inserts to do that. You would need to insert \\'j\\' then \\'a\\' then \\'v\\' and then \\'a\\'.\\n\\n**Relating our decisions to a recurrence relation** \\n\\n**1. Decision 1: We can delete a letter**\\n![image](https://assets.leetcode.com/users/images/62eddf11-6b28-4283-8cf6-da3f08a4f8ea_1648372248.910796.png)\\n\\n **2. Decision 2: We can insert a letter**\\n ![image](https://assets.leetcode.com/users/images/31a79fa2-969a-4aca-8b3c-af10336c1029_1648372279.6259208.png)\\n \\n **3. Decision 3: We can replace a letter**\\n ![image](https://assets.leetcode.com/users/images/c6c837d0-ceeb-4d2e-806d-52953582a16e_1648372350.494664.png)\\n\\nThe problem asks for the **minimum** steps to turn our start string to the goal string. So we need to take the minimum of these decisions\\n\\n![image](https://assets.leetcode.com/users/images/d7f858ef-290d-47e8-b4a5-7ac57757d989_1648372386.15309.png)\\n\\nThe +1 is because when we choose which decision to make we then have to execute it and all decisions have a +1 step cost. \\n\\n![image](https://assets.leetcode.com/users/images/71dba42d-84cf-495e-a336-2a0dd14b35b0_1648372415.5852163.png)\\n\\nIf these recurrence relations are a little confusing make sure to go back up to where we explained our decisions\\n\\n# Using our recurrence relations on our visual 2D table\\nBased on our recurrence relation this is a key we can use to quickly find our delete, insert, and replace values.\\n\\n![image](https://assets.leetcode.com/users/images/539cf57d-4dad-4cad-aa91-5edb57d9f053_1648372481.8830466.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a9b606a-1220-4b90-941f-0d09a03491a6_1648372563.230859.png)\\n\\n![image](https://assets.leetcode.com/users/images/5e6b917e-fd16-4493-b627-5bc7c85f821f_1648372584.0092237.png)\\n\\n![image](https://assets.leetcode.com/users/images/02184174-5af2-4da0-a113-017cfacd96e0_1648372593.0742426.png)\\n\\n![image](https://assets.leetcode.com/users/images/2d51b865-5edb-4100-8e0c-1a4b6beba8fe_1648372599.10186.png)\\n\\n![image](https://assets.leetcode.com/users/images/79a88905-8f72-4396-8538-c66996288639_1648372605.4986908.png)\\n\\nIt would take 5 steps to turn \"java\" into \"swift.\" This makes sense because they don\\'t have any of the same letters so we would have to replace all 4 letters in \"java\" and then insert another one because \"swift\" is 5 letters\\n\\nIn case it would be helpful this is the table at the end of filling out the table for the \"horse\" and \"ros\" example\\n\\n![image](https://assets.leetcode.com/users/images/c6820cb4-29db-4bfc-9b26-ff53930a6f64_1648372673.2579377.png)\\n\\n# Solution\\n**Time Complexity: O(nm)**\\n**Space Complexity: O(nm)**\\n\\n```\\nfunc minDistance(_ word1: String, _ word2: String) -> Int {\\n\\tvar table = Array(repeating: Array(repeating: 0, count: word1.count + 1), count: word2.count + 1)\\n\\t\\n\\t// adding the empty string state\\n\\tlet word1Arr = Array(\" \" + word1)\\n\\tlet word2Arr = Array(\" \" + word2)\\n\\t\\n\\t// Table setup for the empty string state\\n\\tfor row in 0..<table.count {\\n\\t\\ttable[row][0] = row\\n\\t}\\n\\tfor col in 0..<table[0].count {\\n\\t\\ttable[0][col] = col\\n\\t}\\n\\t\\n\\t// Begin iterating at index 1 to word2.count - this is the first letter of word2\\n\\tfor i in 1..<table.count {\\n\\t\\n\\t\\tfor j in 1..<table[i].count {\\n\\t\\t\\t\\n\\t\\t\\tlet insert: Int = table[i-1][j]\\n\\t\\t\\tlet remove: Int = table[i][j-1]\\n\\t\\t\\tlet replace: Int = table[i-1][j-1]\\n\\t\\t\\t\\n\\t\\t\\tif word2Arr[i] == word1Arr[j] {\\n\\t\\t\\t\\ttable[i][j] = replace\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttable[i][j] = min(insert, remove, replace) + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// Return the value at the bottom right\\n\\treturn table[word2.count][word1.count]\\n}\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nInput: word1 = \"java\", word2 = \"swift\"\\n```\n```\\nfunc minDistance(_ word1: String, _ word2: String) -> Int {\\n\\tvar table = Array(repeating: Array(repeating: 0, count: word1.count + 1), count: word2.count + 1)\\n\\t\\n\\t// adding the empty string state\\n\\tlet word1Arr = Array(\" \" + word1)\\n\\tlet word2Arr = Array(\" \" + word2)\\n\\t\\n\\t// Table setup for the empty string state\\n\\tfor row in 0..<table.count {\\n\\t\\ttable[row][0] = row\\n\\t}\\n\\tfor col in 0..<table[0].count {\\n\\t\\ttable[0][col] = col\\n\\t}\\n\\t\\n\\t// Begin iterating at index 1 to word2.count - this is the first letter of word2\\n\\tfor i in 1..<table.count {\\n\\t\\n\\t\\tfor j in 1..<table[i].count {\\n\\t\\t\\t\\n\\t\\t\\tlet insert: Int = table[i-1][j]\\n\\t\\t\\tlet remove: Int = table[i][j-1]\\n\\t\\t\\tlet replace: Int = table[i-1][j-1]\\n\\t\\t\\t\\n\\t\\t\\tif word2Arr[i] == word1Arr[j] {\\n\\t\\t\\t\\ttable[i][j] = replace\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttable[i][j] = min(insert, remove, replace) + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// Return the value at the bottom right\\n\\treturn table[word2.count][word1.count]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796988,
                "title": "lcs-variation-dp-solution-cpp",
                "content": "DP matrix initialization and Dry run for the sample case\\n![image](https://assets.leetcode.com/users/images/2c43a3fa-d3b3-442b-bf09-fb1332a2a765_1659076991.6366894.jpeg)\\n\\nMechanism\\nIf after comaparing we are finding the same character we will copy the value from the diagonal cell\\notherwise the value will be 1+ the minimum value of updation deletion and insertion\\n![image](https://assets.leetcode.com/users/images/cc3eb444-ea30-414a-8b07-6320539fa79e_1659077075.7195187.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n     int LCS(string x,string y, int n, int m){\\n        int dp[n+1][m+1];\\n        for(int i =0;i<n+1;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=0;j<m+1;j++){\\n            dp[0][j]=j;\\n        }\\n        \\n                \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(x[i-1]== y[j-1]){\\n                    dp[i][j]= dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];   \\n        \\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        \\n        return LCS(word1,word2,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int LCS(string x,string y, int n, int m){\\n        int dp[n+1][m+1];\\n        for(int i =0;i<n+1;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=0;j<m+1;j++){\\n            dp[0][j]=j;\\n        }\\n        \\n                \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(x[i-1]== y[j-1]){\\n                    dp[i][j]= dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];   \\n        \\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        \\n        return LCS(word1,word2,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770392,
                "title": "python-simple-recursive-dp-with-memorization-o-mn-84ms-beats-99",
                "content": "Here is a simple recursive python solution:\\n\\nuse two pointers to track which index of word1 and word2 I\\'m evaluating in the function call, at each call:\\n- if one or both the pointers have reached the end return the remaining chars to insert / delete\\n- if the two pointers point to the same value no operation required: p1 + 1, p2 + 1\\n- otherwise keep the minimum distance between insert (p1, p2 + 1), delete (p1 + 1, p2) and replace (p1 + 1, p2 + 1)\\n\\nwith memorization each combination of letters in word1 and word2 is evaluated only once:\\n- time complexity: O(m*n)\\n- space complexity: O(m*n)\\n```\\ndef minDistance(self, word1: str, word2: str) -> int:\\n\\n\\t@lru_cache(None)\\n\\tdef min_dist(p1, p2):\\n\\n\\t\\tif p1 == len(word1) or p2 == len(word2):\\n\\t\\t\\treturn len(word1) - p1 + len(word2) - p2\\n\\n\\t\\t# no change required\\n\\t\\tif word1[p1] == word2[p2]:\\n\\t\\t\\treturn min_dist(p1 + 1, p2 + 1)\\n\\n\\t\\treturn 1 + min(\\n\\t\\t\\tmin_dist(p1, p2 + 1),      # insert character\\n\\t\\t\\tmin_dist(p1 + 1, p2),      # delete character\\n\\t\\t\\tmin_dist(p1 + 1, p2 + 1),  # replace character\\n\\t\\t)\\n\\n\\treturn min_dist(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ndef minDistance(self, word1: str, word2: str) -> int:\\n\\n\\t@lru_cache(None)\\n\\tdef min_dist(p1, p2):\\n\\n\\t\\tif p1 == len(word1) or p2 == len(word2):\\n\\t\\t\\treturn len(word1) - p1 + len(word2) - p2\\n\\n\\t\\t# no change required\\n\\t\\tif word1[p1] == word2[p2]:\\n\\t\\t\\treturn min_dist(p1 + 1, p2 + 1)\\n\\n\\t\\treturn 1 + min(\\n\\t\\t\\tmin_dist(p1, p2 + 1),      # insert character\\n\\t\\t\\tmin_dist(p1 + 1, p2),      # delete character\\n\\t\\t\\tmin_dist(p1 + 1, p2 + 1),  # replace character\\n\\t\\t)\\n\\n\\treturn min_dist(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1710466,
                "title": "simple-c-top-down-approach",
                "content": "```  int dp[501][501];\\n    int solve(string &s1,string &s2,int m,int n){\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];//if any string become zero then minimum insertion required is  second string length\\n        if(m==0)\\n            return dp[m][n]= n;\\n        if(n==0)\\n            return dp[m][n]= m;\\n        if(s1[m-1]==s2[n-1]){\\n            return dp[m][n]=solve(s1,s2,m-1,n-1);//both  last character match then call by removing last character from both string\\n        }\\n        else\\n        {\\n\\t\\t//we are doing 1 operation so adding 1 to result and taking minimum of insert,delete and replace.\\n            return dp[m][n]= 1+min(solve(s1,s2,m,n-1),min(solve(s1,s2,m-1,n),solve(s1,s2,m-1,n-1)));//when both last character not match then\\n\\t\\t\\t//insert the charcter in string one so 1st string remain same  and string 2 reduces by 1 (after inserting both matches);\\n\\t\\t\\t//delete the last character in string 1 and  second string remain same (after deleting both matches)\\n\\t\\t\\t//replace the  last character in string 1 so both both character match so both string reduces by 1 (after replacing both matches)\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof(dp));\\n       return solve(word1,word2,word1.length(),word2.length());\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```  int dp[501][501];\\n    int solve(string &s1,string &s2,int m,int n){\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];//if any string become zero then minimum insertion required is  second string length\\n        if(m==0)\\n            return dp[m][n]= n;\\n        if(n==0)\\n            return dp[m][n]= m;\\n        if(s1[m-1]==s2[n-1]){\\n            return dp[m][n]=solve(s1,s2,m-1,n-1);//both  last character match then call by removing last character from both string\\n        }\\n        else\\n        {\\n\\t\\t//we are doing 1 operation so adding 1 to result and taking minimum of insert,delete and replace.\\n            return dp[m][n]= 1+min(solve(s1,s2,m,n-1),min(solve(s1,s2,m-1,n),solve(s1,s2,m-1,n-1)));//when both last character not match then\\n\\t\\t\\t//insert the charcter in string one so 1st string remain same  and string 2 reduces by 1 (after inserting both matches);\\n\\t\\t\\t//delete the last character in string 1 and  second string remain same (after deleting both matches)\\n\\t\\t\\t//replace the  last character in string 1 so both both character match so both string reduces by 1 (after replacing both matches)\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof(dp));\\n       return solve(word1,word2,word1.length(),word2.length());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1517075,
                "title": "c-solution-with-explanation",
                "content": "```\\n    int minDistance(string word1, string word2) {\\n        int size1 = word1.size();\\n        int size2 = word2.size();\\n        int row = size1 + 1;\\n        int column = size2 + 1;\\n        vector<vector<int>> lm(row, vector<int>(column, 0));\\n        // the distance between \"\" and \"\" is zero\\n        lm[0][0] = 0;\\n        // the operations of converting \"\" to a length i word\\n        for (int i = 1; i < column; i++) {\\n            lm[0][i] = i;\\n        }\\n        // the operations of converting a length i word to \"\"\\n        for (int i = 1; i < row; i++) {\\n            lm[i][0] = i;\\n        }\\n        \\n        for (int r = 1; r < row; r++) {\\n            for (int c = 1; c < column; c++) {\\n                // if the last character of two strings are the same, then the distance is the same as lm[r-1][c-1]\\n                if (word1[r - 1] == word2[c - 1]) {\\n                    lm[r][c] = lm[r - 1][c - 1];\\n                } else {\\n                    // if we have known the min distance between s1[1...r-1] and s2[1...c-1]\\n                    // then we can replace s1[r] with s2[c] first then convert s1[1...r-1] to s2[1...c-1]\\n                    int replace = lm[r - 1][c - 1] + 1;\\n                    // if we have known the min distance bwtween s1[1...r-1] and s2[1...c]\\n\\t\\t\\t\\t\\t// we can  delete s1[r] first then convert s1[1...r-1] to s2[1...c]\\n                    int del = lm[r - 1][c] + 1;\\n                    // if we have known the min distance between s1[1...r] and s2[1...c-1]\\n\\t\\t\\t\\t\\t// we can convert s1[1...r] to s2[1...c-1] then insert s2[c] to the end of s1\\n                    int insert = lm[r][c - 1] + 1;\\n                    // find the min value among the above operation steps\\n                    int result = min(replace, del);\\n                    result = min(result, insert);\\n                    lm[r][c] = result;\\n                }\\n            }\\n        }\\n        return lm[size1][size2];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minDistance(string word1, string word2) {\\n        int size1 = word1.size();\\n        int size2 = word2.size();\\n        int row = size1 + 1;\\n        int column = size2 + 1;\\n        vector<vector<int>> lm(row, vector<int>(column, 0));\\n        // the distance between \"\" and \"\" is zero\\n        lm[0][0] = 0;\\n        // the operations of converting \"\" to a length i word\\n        for (int i = 1; i < column; i++) {\\n            lm[0][i] = i;\\n        }\\n        // the operations of converting a length i word to \"\"\\n        for (int i = 1; i < row; i++) {\\n            lm[i][0] = i;\\n        }\\n        \\n        for (int r = 1; r < row; r++) {\\n            for (int c = 1; c < column; c++) {\\n                // if the last character of two strings are the same, then the distance is the same as lm[r-1][c-1]\\n                if (word1[r - 1] == word2[c - 1]) {\\n                    lm[r][c] = lm[r - 1][c - 1];\\n                } else {\\n                    // if we have known the min distance between s1[1...r-1] and s2[1...c-1]\\n                    // then we can replace s1[r] with s2[c] first then convert s1[1...r-1] to s2[1...c-1]\\n                    int replace = lm[r - 1][c - 1] + 1;\\n                    // if we have known the min distance bwtween s1[1...r-1] and s2[1...c]\\n\\t\\t\\t\\t\\t// we can  delete s1[r] first then convert s1[1...r-1] to s2[1...c]\\n                    int del = lm[r - 1][c] + 1;\\n                    // if we have known the min distance between s1[1...r] and s2[1...c-1]\\n\\t\\t\\t\\t\\t// we can convert s1[1...r] to s2[1...c-1] then insert s2[c] to the end of s1\\n                    int insert = lm[r][c - 1] + 1;\\n                    // find the min value among the above operation steps\\n                    int result = min(replace, del);\\n                    result = min(result, insert);\\n                    lm[r][c] = result;\\n                }\\n            }\\n        }\\n        return lm[size1][size2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1475926,
                "title": "c-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(const string& s1, const string& s2, int m, int n,int i, int j,vector<vector<int>>& dp){\\n        if(s1[i] == \\'\\\\0\\'){\\n            return n;\\n        }\\n        if(s2[j] == \\'\\\\0\\'){\\n            return m;\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int ans;\\n        if(s1[i] == s2[j]){\\n            ans = helper(s1,s2,m-1,n-1,i+1,j+1,dp);\\n        }\\n        else{\\n            ans = 1 + min(helper(s1,s2,m-1,n,i+1,j,dp),min(helper(s1,s2,m,n-                        1,i,j+1,dp),helper(s1,s2,m-1,n-1,i+1,j+1,dp)));\\n        }\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n    int minDistance(string s1, string s2) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return helper(s1,s2,m,n,0,0,dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int helper(const string& s1, const string& s2, int m, int n,int i, int j,vector<vector<int>>& dp){\\n        if(s1[i] == \\'\\\\0\\'){\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1458851,
                "title": "java-memorization-3-ms-faster-than-99-35-submission",
                "content": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        \\n        int n = word1.length();\\n        int m = word2.length();\\n        \\n        int[][] memo = new int[n+1][m+1];\\n        for(int[] mem : memo){\\n            Arrays.fill(mem, -1);\\n        }\\n        return Helper(word1, word2, n, m, memo);       \\n        \\n    }\\n    \\n    public static int Helper(String word1, String word2, int n, int m, int[][] memo){\\n        \\n        if(memo[n][m] != -1){\\n            return memo[n][m];\\n        }\\n        \\n        if(n == 0){\\n            return m;\\n        }\\n        if(m == 0){\\n            return n;\\n        }\\n        \\n        if(word1.charAt(n-1) == word2.charAt(m-1)){\\n            return memo[n][m] = Helper(word1, word2, n-1, m-1, memo);\\n        }\\n        else{\\n            int delete = 1 + Helper(word1, word2, n-1, m, memo);  // delete operation\\n            int replace = 1 + Helper(word1, word2, n-1, m-1, memo);  // replace operation\\n            int insert = 1 + Helper(word1, word2, n, m-1, memo); // insert operation\\n            \\n            return memo[n][m] = Math.min(delete, Math.min(replace, insert));\\n        }        \\n        \\n    }\\n    \\n}\\n```\\n\\nPlease help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\nLOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        \\n        int n = word1.length();\\n        int m = word2.length();\\n        \\n        int[][] memo = new int[n+1][m+1];\\n        for(int[] mem : memo){\\n            Arrays.fill(mem, -1);\\n        }\\n        return Helper(word1, word2, n, m, memo);       \\n        \\n    }\\n    \\n    public static int Helper(String word1, String word2, int n, int m, int[][] memo){\\n        \\n        if(memo[n][m] != -1){\\n            return memo[n][m];\\n        }\\n        \\n        if(n == 0){\\n            return m;\\n        }\\n        if(m == 0){\\n            return n;\\n        }\\n        \\n        if(word1.charAt(n-1) == word2.charAt(m-1)){\\n            return memo[n][m] = Helper(word1, word2, n-1, m-1, memo);\\n        }\\n        else{\\n            int delete = 1 + Helper(word1, word2, n-1, m, memo);  // delete operation\\n            int replace = 1 + Helper(word1, word2, n-1, m-1, memo);  // replace operation\\n            int insert = 1 + Helper(word1, word2, n, m-1, memo); // insert operation\\n            \\n            return memo[n][m] = Math.min(delete, Math.min(replace, insert));\\n        }        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434648,
                "title": "c-dp-solution-by-kushalatolia",
                "content": "![image](https://assets.leetcode.com/users/images/2bf44bc5-6c1d-4369-9e84-3a7ff50a4ba5_1630319139.576023.jpeg)\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n=word1.size();\\n        int m=word2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=i;\\n        for(int i=0;i<=m;i++)\\n            dp[0][i]=i;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else \\n                    dp[i][j]=min(dp[i][j-1]+1,min(dp[i-1][j]+1,dp[i-1][j-1]+1));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n=word1.size();\\n        int m=word2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=i;\\n        for(int i=0;i<=m;i++)\\n            dp[0][i]=i;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else \\n                    dp[i][j]=min(dp[i][j-1]+1,min(dp[i-1][j]+1,dp[i-1][j-1]+1));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417454,
                "title": "python-dp-memoized-bottom-up-and-recursive-solution",
                "content": "Refer [this](https://en.wikipedia.org/wiki/Levenshtein_distance) article for the algorithm used in this solution.\\n\\n```\\n# DP (top-down) solution\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n = len(word1)\\n        m = len(word2)\\n        \\n        t = [[0 for p in range(0,m+1)]\\n            for q in range(0,n+1)]\\n        \\n        for a in range(0,n+1):\\n            t[a][0] = a\\n        for b in range(1,m+1):\\n            t[0][b] = b\\n            \\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                \\n                if word1[i-1] == word2[j-1]:\\n                    t[i][j] = t[i-1][j-1]\\n                    \\n                else:\\n                    t[i][j] = 1 + min(t[i][j-1], t[i-1][j], t[i-1][j-1])\\n                    \\n        return t[n][m]\\n\\t\\t\\n\\t\\t\\n# Recursive code\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        return self.edit(word1,word2,len(word1), len(word2))\\n    \\n    def edit(self,x,y,n,m):\\n        if n == 0 or m == 0:\\n            if n == 0:\\n                return m\\n            else:\\n                return n\\n            \\n        if x[n-1] == y[m-1]:\\n            return self.edit(x,y,n-1,m-1)\\n        else:\\n            return 1 + min(self.edit(x,y,n,m-1), self.edit(x,y,n-1,m), self.edit(x,y,n-1,m-1))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# DP (top-down) solution\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n = len(word1)\\n        m = len(word2)\\n        \\n        t = [[0 for p in range(0,m+1)]\\n            for q in range(0,n+1)]\\n        \\n        for a in range(0,n+1):\\n            t[a][0] = a\\n        for b in range(1,m+1):\\n            t[0][b] = b\\n            \\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                \\n                if word1[i-1] == word2[j-1]:\\n                    t[i][j] = t[i-1][j-1]\\n                    \\n                else:\\n                    t[i][j] = 1 + min(t[i][j-1], t[i-1][j], t[i-1][j-1])\\n                    \\n        return t[n][m]\\n\\t\\t\\n\\t\\t\\n# Recursive code\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        return self.edit(word1,word2,len(word1), len(word2))\\n    \\n    def edit(self,x,y,n,m):\\n        if n == 0 or m == 0:\\n            if n == 0:\\n                return m\\n            else:\\n                return n\\n            \\n        if x[n-1] == y[m-1]:\\n            return self.edit(x,y,n-1,m-1)\\n        else:\\n            return 1 + min(self.edit(x,y,n,m-1), self.edit(x,y,n-1,m), self.edit(x,y,n-1,m-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180587,
                "title": "memoized-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.length();\\n        int m = word2.length();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n        \\n        return solve(n,m,word1,word2,dp);\\n    }\\n    int solve(int n, int m, string word1, string word2, vector<vector<int>> &dp){\\n        if(n==0 || m==0) return max(n,m);\\n        if(dp[n][m]!=-1) return dp[n][m];\\n        if(word1[n-1]==word2[m-1]) return solve(n-1,m-1,word1,word2,dp);\\n        else{\\n            dp[n][m] = min(solve(n-1,m,word1,word2,dp),\\n                           min(solve(n-1,m-1,word1,word2,dp),\\n                               solve(n,m-1,word1,word2,dp))) +1;\\n            return dp[n][m];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.length();\\n        int m = word2.length();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n        \\n        return solve(n,m,word1,word2,dp);\\n    }\\n    int solve(int n, int m, string word1, string word2, vector<vector<int>> &dp){\\n        if(n==0 || m==0) return max(n,m);\\n        if(dp[n][m]!=-1) return dp[n][m];\\n        if(word1[n-1]==word2[m-1]) return solve(n-1,m-1,word1,word2,dp);\\n        else{\\n            dp[n][m] = min(solve(n-1,m,word1,word2,dp),\\n                           min(solve(n-1,m-1,word1,word2,dp),\\n                               solve(n,m-1,word1,word2,dp))) +1;\\n            return dp[n][m];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119169,
                "title": "c-dp-4-ways-to-solve-memory-utilization-99-lesser",
                "content": "\\n**Approach 1**  \\nSo the code for this recursive solution would be  \\nBase Case:  \\n- if **i** reached till the end , in that case we have to see how many characters still left(**word2.size()-j**) in word2 and return that.  \\n- similary we do for j if it reached till the end.  \\n\\nMemoization: Use the index i and j.  \\nTime Complexity: O(M*N)\\nSpace Complexity: O(M*N) plus recursion stack which will also be same.\\n```\\nint dp[505][505];\\nclass Solution {\\n    string s;\\n    string t;\\n    int solve(int i, int j)\\n    {\\n        // If we have exhausted the first string\\n        // We have to take number of chars left in second string\\n        // which will be t.size()-current_index_t\\n        // Same logic goes if we have exhausted second string\\n        if(i==s.size())\\n            return t.size()-j;\\n        if(j==t.size())\\n            return s.size()-i;\\n        // Check if we have already evaluated?\\n        int& ret = dp[i][j];\\n        if(ret !=-1)\\n            return ret;\\n        ret =0;\\n        // Mismatch\\n        if(s[i]!=t[j])\\n        {\\n            // If we replace that means i,j now match lets go to next\\n            int rep = 1 + solve(i+1, j+1);\\n            // if delete that means , we go to next j, i remain same.\\n            int del = 1 + solve(i, j+1);\\n            // if insert same char , that mean i now matches \\n            // but we dont know abt j , so keep j same\\n            int ins = 1 + solve(i+1, j);\\n            // Take minimum of all 3 operation\\n            ret = min({rep, del, ins});\\n        }\\n        else\\n            // i and j match, so lets goto next \\n            ret = solve(i+1, j+1);\\n        return ret;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n        t = word1;\\n        s = word2;\\n        memset(&dp, -1, sizeof dp);\\n        return solve(0, 0);\\n    }\\n};\\n```\\n**Approach 2**  \\nLets convert this memoization based recursive approach to tabulation based iterative approach.  \\nf(i, j) = 1 + min { f(i+1, j+1) , f(i+1, j), f(i, j+1) }  \\n**Step 1**  \\nTable constrction: create a dp table of size dp[1+m][1+n].  \\nExtra 1 size to handle case of string completely exhaausted.  \\nBase case value to initialized in table, remember in recursive solution whenever i==m we return word2.size()-j and vice versa.  \\nSo here in tabulation approach when i==m-> dp[i][j] = word2.size() -j and when j==n -> dp[i][j] = word1.size()-i  \\n\\n\\n**Step 2**   \\nHow to start the loops:  Notice that our recursive function is dependent on future values, hence we cant start from i=0 or j=0  \\nwe have to start backward, when working backward future value would have been already calculated.  \\n\\n```\\n\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        // Iterative version of recursive approach\\n        // Since recursive approach rely on future value\\n        // we should start backward i.e. i=m j=n\\n        int m = word1.size();\\n        int n = word2.size();\\n        vector<vector<int>> dp(1+m, vector<int>(1+n, 0));\\n        for(int i = m ; i >=0; --i)\\n        {\\n            for(int j = n ; j >=0; --j)\\n            {\\n                if(i==m) // that means word1 is exhausted\\n                    dp[i][j] = n - j;\\n                else if(j==n)\\n                    dp[i][j] = m - i;\\n                else if(word1[i]!=word2[j])\\n                {\\n                    dp[i][j] = 1 + min({dp[i+1][j], dp[i][j+1], dp[i+1][j+1]});\\n                }\\n                else\\n                    dp[i][j] = dp[i+1][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n**Approach 3**  \\nGenerally we are more familiar with starting the loop with 0 to n.   \\nThis problem can be solve using this way as well, only the base case change i.e. when i=0 , that mean we are left with entire j length of word2 so dp[i][j]= j;  \\nSimilar when j==0 , dp[i][j]=i  \\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size();\\n        int n = word2.size();\\n        vector<vector<int>> dp(1+m, vector<int>(1+n, 0));\\n        for(int i=0; i <= m; ++i)\\n        {\\n            for(int j=0; j<=n; ++j)\\n            {\\n                if(i==0)\\n                    dp[i][j] = j;\\n                else if(j==0)\\n                    dp[i][j] = i;\\n                else if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                {\\n                    dp[i][j] = 1 + min({dp[i-1][j-1], dp[i][j-1], dp[i-1][j]});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\nLet me show you that Approach 2 and 3 are exactly opposite of each other.\\nWe will show with example word1=\"abc\", word2=\"bcd\"\\n\\n![image](https://user-images.githubusercontent.com/20656683/111882251-a63fb180-89da-11eb-88bb-7fbbbd107757.png)\\n\\n\\n\\n**Approach 4 : Space Optimized DP**  \\nAbove tabluation based DP approach consume space of O( M* N ), we can further reduce this to 1-D DP. \\nNotice that as per DP recursive statement we are only dependent on 1-future row or 1-previous  (Approach 2 vs Approach 3) to compute the current row.  \\nOne easy way is to maintain 2 row, one which we will fill in the value of current row and 1 row which has values from previous row operation and then toggle between this row. There is even a smarter way where 2nd row itself is also not required, lets discuss that.  \\nI am going to discuss 1-D verion of Approach 2 but it is also applicable for Approach 3 as well.  \\n\\nStep 1: Always create 1-D DP array for smaller string , for our problem, I will always make word2 as smaller, if its not smaller , call the function by reversing argument.  \\nStep 2: Recall our recusrive function\\n          f(i, j) = 1 + min { f(i+1, j+1) , f(i+1, j), f(i, j+1) }  \\n\\n![image](https://user-images.githubusercontent.com/20656683/111882720-13ecdd00-89dd-11eb-9c38-9f2f25c94621.png)\\n\\nStep 3: Base case value remain same, just that now its 1-D.\\nStep 4: Make sure everywhere dp[i+1][j+1] is replaced by **prev**, dp[i+1][j] is dp[j] itself and dp[i][j+1] is dp[j+1].  \\nprev is a way to store previous value of the cell , so that the same can be reused in next iteration\\n\\nCode for this looks somehing like this.\\n```\\n\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        // Iterative version of recursive approach\\n        // Since recursive approach rely on future value\\n        // we should start backward i.e. i=m j=n\\n        \\n        int m = word1.size();\\n        int n = word2.size();\\n        if(m < n)\\n            return minDistance(word2, word1);\\n        \\n        // Space optimized 1-D DP version\\n        vector<int> dp(1+n, 0);\\n        dp[n] = 0;\\n        int prev;\\n        for(int i = m; i >=0; --i)\\n        {\\n            prev = dp[n];\\n            for(int j = n ; j >=0; --j)\\n            {\\n                int oldDP = dp[j];\\n                if(i==m)\\n                    dp[j] = n-j;\\n                else if(j==n)\\n                    dp[j] = m-i;\\n                else if(word1[i]!=word2[j])\\n                {\\n                    dp[j] = 1 + min({dp[j], dp[j+1], prev});\\n                }\\n                else\\n                    dp[j] = prev;\\n                prev = oldDP;\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\nConculsion:\\nApproach 4 when submitted reported 99% lesser memory usage.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint dp[505][505];\\nclass Solution {\\n    string s;\\n    string t;\\n    int solve(int i, int j)\\n    {\\n        // If we have exhausted the first string\\n        // We have to take number of chars left in second string\\n        // which will be t.size()-current_index_t\\n        // Same logic goes if we have exhausted second string\\n        if(i==s.size())\\n            return t.size()-j;\\n        if(j==t.size())\\n            return s.size()-i;\\n        // Check if we have already evaluated?\\n        int& ret = dp[i][j];\\n        if(ret !=-1)\\n            return ret;\\n        ret =0;\\n        // Mismatch\\n        if(s[i]!=t[j])\\n        {\\n            // If we replace that means i,j now match lets go to next\\n            int rep = 1 + solve(i+1, j+1);\\n            // if delete that means , we go to next j, i remain same.\\n            int del = 1 + solve(i, j+1);\\n            // if insert same char , that mean i now matches \\n            // but we dont know abt j , so keep j same\\n            int ins = 1 + solve(i+1, j);\\n            // Take minimum of all 3 operation\\n            ret = min({rep, del, ins});\\n        }\\n        else\\n            // i and j match, so lets goto next \\n            ret = solve(i+1, j+1);\\n        return ret;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n        t = word1;\\n        s = word2;\\n        memset(&dp, -1, sizeof dp);\\n        return solve(0, 0);\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        // Iterative version of recursive approach\\n        // Since recursive approach rely on future value\\n        // we should start backward i.e. i=m j=n\\n        int m = word1.size();\\n        int n = word2.size();\\n        vector<vector<int>> dp(1+m, vector<int>(1+n, 0));\\n        for(int i = m ; i >=0; --i)\\n        {\\n            for(int j = n ; j >=0; --j)\\n            {\\n                if(i==m) // that means word1 is exhausted\\n                    dp[i][j] = n - j;\\n                else if(j==n)\\n                    dp[i][j] = m - i;\\n                else if(word1[i]!=word2[j])\\n                {\\n                    dp[i][j] = 1 + min({dp[i+1][j], dp[i][j+1], dp[i+1][j+1]});\\n                }\\n                else\\n                    dp[i][j] = dp[i+1][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size();\\n        int n = word2.size();\\n        vector<vector<int>> dp(1+m, vector<int>(1+n, 0));\\n        for(int i=0; i <= m; ++i)\\n        {\\n            for(int j=0; j<=n; ++j)\\n            {\\n                if(i==0)\\n                    dp[i][j] = j;\\n                else if(j==0)\\n                    dp[i][j] = i;\\n                else if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                {\\n                    dp[i][j] = 1 + min({dp[i-1][j-1], dp[i][j-1], dp[i-1][j]});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        // Iterative version of recursive approach\\n        // Since recursive approach rely on future value\\n        // we should start backward i.e. i=m j=n\\n        \\n        int m = word1.size();\\n        int n = word2.size();\\n        if(m < n)\\n            return minDistance(word2, word1);\\n        \\n        // Space optimized 1-D DP version\\n        vector<int> dp(1+n, 0);\\n        dp[n] = 0;\\n        int prev;\\n        for(int i = m; i >=0; --i)\\n        {\\n            prev = dp[n];\\n            for(int j = n ; j >=0; --j)\\n            {\\n                int oldDP = dp[j];\\n                if(i==m)\\n                    dp[j] = n-j;\\n                else if(j==n)\\n                    dp[j] = m-i;\\n                else if(word1[i]!=word2[j])\\n                {\\n                    dp[j] = 1 + min({dp[j], dp[j+1], prev});\\n                }\\n                else\\n                    dp[j] = prev;\\n                prev = oldDP;\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028828,
                "title": "python-easy-understanding-beats-95-in-time",
                "content": "\\tfrom functools import cache\\n\\tclass Solution:\\n\\t\\tdef minDistance(self, word1: str, word2: str) -> int:\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dp(i, j):\\n\\t\\t\\t\\tif i == -1:\\n\\t\\t\\t\\t\\treturn j+1\\n\\t\\t\\t\\tif j == -1:\\n\\t\\t\\t\\t\\treturn i+1\\n\\n\\t\\t\\t\\tif word1[i] == word2[j]:\\n\\t\\t\\t\\t\\treturn dp(i-1,j-1)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn min(\\n\\t\\t\\t\\t\\t\\tdp(i,j-1)+1,\\n\\t\\t\\t\\t\\t\\tdp(i-1,j)+1,\\n\\t\\t\\t\\t\\t\\tdp(i-1,j-1)+1\\n\\t\\t\\t\\t\\t)\\n\\n\\t\\t\\treturn dp(len(word1)-1, len(word2)-1)",
                "solutionTags": [],
                "code": "\\tfrom functools import cache\\n\\tclass Solution:\\n\\t\\tdef minDistance(self, word1: str, word2: str) -> int:\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dp(i, j):\\n\\t\\t\\t\\tif i == -1:\\n\\t\\t\\t\\t\\treturn j+1\\n\\t\\t\\t\\tif j == -1:\\n\\t\\t\\t\\t\\treturn i+1\\n\\n\\t\\t\\t\\tif word1[i] == word2[j]:\\n\\t\\t\\t\\t\\treturn dp(i-1,j-1)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn min(\\n\\t\\t\\t\\t\\t\\tdp(i,j-1)+1,\\n\\t\\t\\t\\t\\t\\tdp(i-1,j)+1,\\n\\t\\t\\t\\t\\t\\tdp(i-1,j-1)+1\\n\\t\\t\\t\\t\\t)\\n\\n\\t\\t\\treturn dp(len(word1)-1, len(word2)-1)",
                "codeTag": "Java"
            },
            {
                "id": 1011449,
                "title": "c-bottom-up-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.length();\\n        int n=word2.length();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++) {\\n            for(int j=0;j<=n;j++)  {\\n                if(i==0) \\n                    dp[i][j]=j;\\n                else if(j==0) \\n                    dp[i][j]=i;\\n                else if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else \\n                    dp[i][j] = 1+min(dp[i][j-1],min(dp[i-1][j],dp[i-1][j-1]));\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.length();\\n        int n=word2.length();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++) {\\n            for(int j=0;j<=n;j++)  {\\n                if(i==0) \\n                    dp[i][j]=j;\\n                else if(j==0) \\n                    dp[i][j]=i;\\n                else if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else \\n                    dp[i][j] = 1+min(dp[i][j-1],min(dp[i-1][j],dp[i-1][j-1]));\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746823,
                "title": "python3-dynamic-programming-solution-faster-than-94-less-than-85",
                "content": "```\\n\\'\\'\\'\\nsolution 1\\n\\'\\'\\'\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        # base case\\n        i = len(word1) - 1\\n        j = len(word2) - 1\\n        \\n        # recording repeating sub-questions\\n        memo = dict()  \\n        \\n        def dp(i, j) -> int:\\n            if i == -1: return j + 1\\n            if j == -1: return i + 1\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            if word1[i] == word2[j]:\\n                memo[(i, j)] = dp(i-1, j-1)\\n            else:\\n                memo[(i, j)] = min(\\n                    dp(i-1, j) + 1,\\n                    dp(i, j-1) + 1,\\n                    dp(i-1, j-1) + 1\\n                )\\n            return memo[(i, j)]\\n        \\n        return dp(i, j)\\n```\\nIf you want to get how it work and understand Chinese, please refer to: [\\u7F16\\u8F91\\u8DDD\\u79BB-\\u52A8\\u6001\\u89C4\\u5212](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/bian-ji-ju-li).",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nsolution 1\\n\\'\\'\\'\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        # base case\\n        i = len(word1) - 1\\n        j = len(word2) - 1\\n        \\n        # recording repeating sub-questions\\n        memo = dict()  \\n        \\n        def dp(i, j) -> int:\\n            if i == -1: return j + 1\\n            if j == -1: return i + 1\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            if word1[i] == word2[j]:\\n                memo[(i, j)] = dp(i-1, j-1)\\n            else:\\n                memo[(i, j)] = min(\\n                    dp(i-1, j) + 1,\\n                    dp(i, j-1) + 1,\\n                    dp(i-1, j-1) + 1\\n                )\\n            return memo[(i, j)]\\n        \\n        return dp(i, j)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717692,
                "title": "c",
                "content": "reference: https://www.youtube.com/watch?v=We3YDTzNXEk&t=0s&list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr&index=8\\n\\n```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        if (word1 == string.Empty)\\n            return word2.Length;\\n        else if (word2 == string.Empty)\\n            return word1.Length;\\n        \\n        int [,] res = new int[word1.Length + 1, word2.Length + 1];\\n        \\n        for (int i = 0; i <= word1.Length; i++)\\n            res[i, 0] = i;\\n        \\n        for (int i = 1; i <= word2.Length; i++)\\n            res[0, i] = i;\\n        \\n        for (int i = 1; i <= word1.Length; i++)\\n            for (int j = 1; j <= word2.Length; j++)\\n                if (word1[i - 1] == word2[j - 1])\\n                    res[i, j] = res[i - 1, j - 1];\\n                else\\n                    res[i, j] = Math.Min(res[i - 1, j -1], Math.Min(res[i - 1, j], res[i, j - 1])) + 1;\\n                \\n        return res[word1.Length, word2.Length];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        if (word1 == string.Empty)\\n            return word2.Length;\\n        else if (word2 == string.Empty)\\n            return word1.Length;\\n        \\n        int [,] res = new int[word1.Length + 1, word2.Length + 1];\\n        \\n        for (int i = 0; i <= word1.Length; i++)\\n            res[i, 0] = i;\\n        \\n        for (int i = 1; i <= word2.Length; i++)\\n            res[0, i] = i;\\n        \\n        for (int i = 1; i <= word1.Length; i++)\\n            for (int j = 1; j <= word2.Length; j++)\\n                if (word1[i - 1] == word2[j - 1])\\n                    res[i, j] = res[i - 1, j - 1];\\n                else\\n                    res[i, j] = Math.Min(res[i - 1, j -1], Math.Min(res[i - 1, j], res[i, j - 1])) + 1;\\n                \\n        return res[word1.Length, word2.Length];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 662931,
                "title": "edit-distance-cpp-c-pictorial-representation-easy-to-understand",
                "content": "This is the one of the very common dp question:\\n**Basic Intution**: to conver a character how many operations are needed. with this intution we can solve this question\\n_________________________________________________________________________________________________\\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590934817.png)\\n\\nFigure 1\\n_________________________________________________________________________________________________\\n\\nreference from the above image we will try to consturct the dp matrix for the solution, later we will try to find the recurrence for this solution.\\n_________________________________________________________________________________________________\\n\\n\\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590935332.png)\\n\\nFigure 2\\n_________________________________________________________________________________________________\\n\\n\\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590935730.png)\\n\\nFigure 3\\n_________________________________________________________________________________________________\\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590936072.png)\\n\\nFigure 4\\n_________________________________________________________________________________________________\\n\\n\\nFinally...: The DP Matrix looks like \\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590943224.png)\\n\\nFigure 5\\n_________________________________________________________________________________________________\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int _firstStrng = word1.size();\\n        int _secondString = word2. size();\\n        \\n        vector<vector<int>> dp(_firstStrng+1,vector<int>(_secondString+1,0));\\n        \\n        for(int row =0; row<= _firstStrng ; row++){\\n            for(int col=0; col<=_secondString; col++){\\n                if(row == 0 ) dp[row][col] = col;\\n                else if( col== 0 ) dp[row][col] = row;\\n                \\n                else if (word1 [row-1] == word2[col-1]) dp[row][col] = dp[row-1][col-1];\\n                else\\n                    dp[row][col] = 1+ min(min(dp[row][col-1], dp[row-1][col]), dp[row-1][col-1]);\\n            }\\n        }\\n        return dp[_firstStrng][_secondString];\\n    }\\n};\\n```\\n\\nNote: Please let me know in the comments.. if you require any other help, or edits in the post.\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int _firstStrng = word1.size();\\n        int _secondString = word2. size();\\n        \\n        vector<vector<int>> dp(_firstStrng+1,vector<int>(_secondString+1,0));\\n        \\n        for(int row =0; row<= _firstStrng ; row++){\\n            for(int col=0; col<=_secondString; col++){\\n                if(row == 0 ) dp[row][col] = col;\\n                else if( col== 0 ) dp[row][col] = row;\\n                \\n                else if (word1 [row-1] == word2[col-1]) dp[row][col] = dp[row-1][col-1];\\n                else\\n                    dp[row][col] = 1+ min(min(dp[row][col-1], dp[row-1][col]), dp[row-1][col-1]);\\n            }\\n        }\\n        return dp[_firstStrng][_secondString];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662426,
                "title": "c-dp-bottom-up-simple-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size();\\n        int n = word2.size();\\n        int **output = new int*[m+1];\\n        for(int i=0; i<=m; i++)\\n        {\\n            output[i]=new int[n+1];\\n        }\\n        //fill first row\\n        for(int j=0; j<=n; j++)\\n        {\\n            output[0][j]=j;\\n        }\\n        //fill first col\\n        for(int i=0; i<=m; i++)\\n        {\\n            output[i][0]=i;\\n        }\\n\\n        for(int i=1; i<=m; i++)\\n        {\\n            for(int j=1; j<=n; j++)\\n            {\\n                if(word1[m-i]==word2[n-j])\\n                {\\n                    output[i][j]= output[i-1][j-1];\\n                }\\n                else\\n                {\\n                     output[i][j]= min(output[i][j-1],min(output[i-1][j],output[i-1][j-1])) + 1;\\n                }\\n            }\\n        }\\n        return output[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size();\\n        int n = word2.size();\\n        int **output = new int*[m+1];\\n        for(int i=0; i<=m; i++)\\n        {\\n            output[i]=new int[n+1];\\n        }\\n        //fill first row\\n        for(int j=0; j<=n; j++)\\n        {\\n            output[0][j]=j;\\n        }\\n        //fill first col\\n        for(int i=0; i<=m; i++)\\n        {\\n            output[i][0]=i;\\n        }\\n\\n        for(int i=1; i<=m; i++)\\n        {\\n            for(int j=1; j<=n; j++)\\n            {\\n                if(word1[m-i]==word2[n-j])\\n                {\\n                    output[i][j]= output[i-1][j-1];\\n                }\\n                else\\n                {\\n                     output[i][j]= min(output[i][j-1],min(output[i-1][j],output[i-1][j-1])) + 1;\\n                }\\n            }\\n        }\\n        return output[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655602,
                "title": "python3-memoization-solution-98-95-faster",
                "content": "```\\nclass Solution:\\n    def dp(self,A,B,i,j,aux):\\n        global ans\\n        if aux[i][j]:\\n            return aux[i][j]\\n        if i==0:\\n            return j\\n        if j==0:\\n            return i\\n        if A[i-1] == B[j-1]:\\n            ans = self.dp(A,B,i-1,j-1,aux)\\n        else:\\n            ans = 1 + min(self.dp(A,B,i-1,j-1,aux), self.dp(A,B,i-1,j,aux), self.dp(A,B,i,j-1,aux))\\n        aux[i][j] = ans\\n        return ans\\n    \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[0]*(n+1) for _ in range(m+1)]\\n        b=self.dp(word1,word2,m,n,dp)\\n        return b if m < 1 or n < 1 else dp[m][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def dp(self,A,B,i,j,aux):\\n        global ans\\n        if aux[i][j]:\\n            return aux[i][j]\\n        if i==0:\\n            return j\\n        if j==0:\\n            return i\\n        if A[i-1] == B[j-1]:\\n            ans = self.dp(A,B,i-1,j-1,aux)\\n        else:\\n            ans = 1 + min(self.dp(A,B,i-1,j-1,aux), self.dp(A,B,i-1,j,aux), self.dp(A,B,i,j-1,aux))\\n        aux[i][j] = ans\\n        return ans\\n    \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[0]*(n+1) for _ in range(m+1)]\\n        b=self.dp(word1,word2,m,n,dp)\\n        return b if m < 1 or n < 1 else dp[m][n]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1720630,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1564737,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815300,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1920807,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815477,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1566473,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815034,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1570128,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1569955,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1568243,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1720630,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1564737,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815300,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1920807,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815477,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1566473,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815034,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1570128,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1569955,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1568243,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 2025451,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1816568,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1814605,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1572780,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1568893,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1571170,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 2071330,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1986248,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1933173,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1815135,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1814571,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 1798109,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 1574248,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 1573850,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2068551,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2053497,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2052528,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2046986,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2034681,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2028500,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2018671,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 2007725,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 2001869,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1921440,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1919830,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1816391,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1815338,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1815308,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1815230,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1815225,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            }
        ]
    },
    {
        "title": "Factorial Trailing Zeroes",
        "question_content": "<p>Given an integer <code>n</code>, return <em>the number of trailing zeroes in </em><code>n!</code>.</p>\n\n<p>Note that <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> 3! = 6, no trailing zero.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 5! = 120, one trailing zero.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you write a solution that works in logarithmic time complexity?</p>\n",
        "solutions": [
            {
                "id": 52371,
                "title": "my-one-line-solutions-in-3-languages",
                "content": "This question is pretty straightforward.\\n\\nBecause all trailing 0 is from factors 5 * 2. \\n\\nBut sometimes one number may have several 5 factors, for example, 25 have two 5 factors, 125 have three 5 factors. In the n! operation, factors 2 is always ample.  So we just count how many 5 factors in all number from 1 to n. \\n\\nOne line code:\\n\\nJava:\\n\\n        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n\\nC++:\\n\\n        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n\\nPython:\\n\\n        return 0 if n == 0 else n / 5 + self.trailingZeroes(n / 5)",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "This question is pretty straightforward.\\n\\nBecause all trailing 0 is from factors 5 * 2. \\n\\nBut sometimes one number may have several 5 factors, for example, 25 have two 5 factors, 125 have three 5 factors. In the n! operation, factors 2 is always ample.  So we just count how many 5 factors in all number from 1 to n. \\n\\nOne line code:\\n\\nJava:\\n\\n        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n\\nC++:\\n\\n        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n\\nPython:\\n\\n        return 0 if n == 0 else n / 5 + self.trailingZeroes(n / 5)",
                "codeTag": "Unknown"
            },
            {
                "id": 52373,
                "title": "simple-c-c-solution-with-detailed-explaination",
                "content": "The idea is: \\n\\n 1. The ZERO comes from 10.  \\n 2. The 10 comes from 2 x 5 \\n 3. And we need to account for all the products of 5 and 2. likes 4\\xd75 = 20 ...\\n 4. So, if we take all the numbers with 5 as a factor, we'll have way  more than enough even numbers to pair with them to get factors of 10\\n\\n**Example One**\\n\\nHow many multiples of 5 are between 1 and 23? There is 5, 10, 15, and 20, for four multiples of 5. Paired with 2's from the even factors, this makes for four factors of 10, so: **23! has 4 zeros**.\\n\\n\\n**Example Two**\\n\\nHow many multiples of 5 are there in the numbers from 1 to 100? \\n\\nbecause   100 \\xf7 5 = 20, so, there are twenty multiples of 5 between 1 and 100.\\n\\nbut wait, actually 25 is 5\\xd75, so each multiple of 25 has an extra factor of 5, e.g. 25 \\xd7 4 = 100\\uff0cwhich introduces extra of zero.\\n\\nSo, we need know how many multiples of 25 are between 1 and 100? Since 100 \\xf7 25 = 4, there are four multiples of 25 between 1 and 100.\\n\\nFinally, we get 20 + 4 = 24 trailing zeroes in 100!\\n\\n\\nThe above example tell us, we need care about 5, 5\\xd75, 5\\xd75\\xd75, 5\\xd75\\xd75\\xd75 ....\\n\\n**Example Three**\\n\\nBy given number 4617.\\n\\n5^1 :  4617 \\xf7 5 = 923.4, so we get 923 factors of 5\\n\\n5^2 :  4617 \\xf7 25 = 184.68, so we get 184 additional factors of 5\\n\\n5^3 :  4617 \\xf7 125 = 36.936, so we get 36 additional factors of 5\\n\\n5^4 :  4617 \\xf7 625 = 7.3872, so we get 7 additional factors of 5\\n\\n5^5 :  4617 \\xf7 3125 = 1.47744, so we get 1 more factor of 5\\n\\n5^6 :  4617 \\xf7 15625 = 0.295488, which is less than 1, so stop here.\\n\\nThen 4617! has 923 + 184 + 36 + 7 + 1 = 1151 trailing zeroes.\\n\\nC/C++ code \\n\\n    int trailingZeroes(int n) {\\n        int result = 0;\\n        for(long long i=5; n/i>0; i*=5){\\n            result += (n/i);\\n        }\\n        return result;\\n    }\\n\\n\\n---------update-----------\\n\\nTo avoid the integer overflow as **@localvar** mentioned below(in case of 'n >=1808548329' ), the expression \" i <= INT_MAX/5\" is not a good way to prevent overflow, because 5^13 is > INT_MAX/5 and it's valid. \\n\\nSo, if you want to use \"multiply\", consider define the 'i' as 'long long' type.\\n\\nOr, take the solution **@codingryan** mentioned in below answer!",
                "solutionTags": [],
                "code": "The idea is: \\n\\n 1. The ZERO comes from 10.  \\n 2. The 10 comes from 2 x 5 \\n 3. And we need to account for all the products of 5 and 2. likes 4\\xd75 = 20 ...\\n 4. So, if we take all the numbers with 5 as a factor, we'll have way  more than enough even numbers to pair with them to get factors of 10\\n\\n**Example One**\\n\\nHow many multiples of 5 are between 1 and 23? There is 5, 10, 15, and 20, for four multiples of 5. Paired with 2's from the even factors, this makes for four factors of 10, so: **23! has 4 zeros**.\\n\\n\\n**Example Two**\\n\\nHow many multiples of 5 are there in the numbers from 1 to 100? \\n\\nbecause   100 \\xf7 5 = 20, so, there are twenty multiples of 5 between 1 and 100.\\n\\nbut wait, actually 25 is 5\\xd75, so each multiple of 25 has an extra factor of 5, e.g. 25 \\xd7 4 = 100\\uff0cwhich introduces extra of zero.\\n\\nSo, we need know how many multiples of 25 are between 1 and 100? Since 100 \\xf7 25 = 4, there are four multiples of 25 between 1 and 100.\\n\\nFinally, we get 20 + 4 = 24 trailing zeroes in 100!\\n\\n\\nThe above example tell us, we need care about 5, 5\\xd75, 5\\xd75\\xd75, 5\\xd75\\xd75\\xd75 ....\\n\\n**Example Three**\\n\\nBy given number 4617.\\n\\n5^1 :  4617 \\xf7 5 = 923.4, so we get 923 factors of 5\\n\\n5^2 :  4617 \\xf7 25 = 184.68, so we get 184 additional factors of 5\\n\\n5^3 :  4617 \\xf7 125 = 36.936, so we get 36 additional factors of 5\\n\\n5^4 :  4617 \\xf7 625 = 7.3872, so we get 7 additional factors of 5\\n\\n5^5 :  4617 \\xf7 3125 = 1.47744, so we get 1 more factor of 5\\n\\n5^6 :  4617 \\xf7 15625 = 0.295488, which is less than 1, so stop here.\\n\\nThen 4617! has 923 + 184 + 36 + 7 + 1 = 1151 trailing zeroes.\\n\\nC/C++ code \\n\\n    int trailingZeroes(int n) {\\n        int result = 0;\\n        for(long long i=5; n/i>0; i*=5){\\n            result += (n/i);\\n        }\\n        return result;\\n    }\\n\\n\\n---------update-----------\\n\\nTo avoid the integer overflow as **@localvar** mentioned below(in case of 'n >=1808548329' ), the expression \" i <= INT_MAX/5\" is not a good way to prevent overflow, because 5^13 is > INT_MAX/5 and it's valid. \\n\\nSo, if you want to use \"multiply\", consider define the 'i' as 'long long' type.\\n\\nOr, take the solution **@codingryan** mentioned in below answer!",
                "codeTag": "Unknown"
            },
            {
                "id": 52367,
                "title": "my-explanation-of-the-log-n-solution",
                "content": "10 is the product of 2 and 5. In n!, we need to know how many 2 and 5, and the number of zeros is the minimum of the number of 2 and the number of 5.\\n\\nSince multiple of 2 is more than multiple of 5, the number of zeros is dominant by the number of 5.\\n\\nHere we expand  \\n\\n      2147483647!\\n    =2 * 3 * ...* 5 ... *10 ... 15* ... * 25 ... * 50 ... * 125 ... * 250...\\n    =2 * 3 * ...* 5 ... * (5^1*2)...(5^1*3)...*(5^2*1)...*(5^2*2)...*(5^3*1)...*(5^3*2)... (Equation 1)\\n\\nWe just count the number of 5 in Equation 1.\\n\\nMultiple of 5 provides one 5, multiple of 25 provides two 5 and so on.\\n\\nNote the duplication: multiple of 25 is also multiple of 5, so multiple of 25 only provides one extra 5.\\n\\nHere is the basic solution:\\n\\n    return n/5 + n/25 + n/125 + n/625 + n/3125+...;\\n\\nYou can easily rewrite it to a loop.",
                "solutionTags": [],
                "code": "10 is the product of 2 and 5. In n!, we need to know how many 2 and 5, and the number of zeros is the minimum of the number of 2 and the number of 5.\\n\\nSince multiple of 2 is more than multiple of 5, the number of zeros is dominant by the number of 5.\\n\\nHere we expand  \\n\\n      2147483647!\\n    =2 * 3 * ...* 5 ... *10 ... 15* ... * 25 ... * 50 ... * 125 ... * 250...\\n    =2 * 3 * ...* 5 ... * (5^1*2)...(5^1*3)...*(5^2*1)...*(5^2*2)...*(5^3*1)...*(5^3*2)... (Equation 1)\\n\\nWe just count the number of 5 in Equation 1.\\n\\nMultiple of 5 provides one 5, multiple of 25 provides two 5 and so on.\\n\\nNote the duplication: multiple of 25 is also multiple of 5, so multiple of 25 only provides one extra 5.\\n\\nHere is the basic solution:\\n\\n    return n/5 + n/25 + n/125 + n/625 + n/3125+...;\\n\\nYou can easily rewrite it to a loop.",
                "codeTag": "Unknown"
            },
            {
                "id": 52470,
                "title": "4-lines-4ms-c-solution-with-explanations",
                "content": "Well, to compute the number of trailing zeros, we need to first think clear about what will generate a trailing `0`? Obviously, a number multiplied by `10` will have a trailing `0` added to it. So we only need to find out how many `10`'s will appear in the expression of the factorial. Since `10 = 2 * 5` and there are a bunch more `2`'s (each even number will contribute at least one `2`), we only need to count the number of `5`'s.\\n\\nNow let's see what numbers will contribute a `5`. Well, simply the multiples of `5`, like `5, 10, 15, 20, 25, 35, ...`. So is the result simply `n / 5`? Well, not that easy. Notice that some numbers may contribute more than one `5`, like `25 = 5 * 5`. Well, what numbers will contribute more than one `5`? Ok, you may notice that only multiples of the power of `5` will contribute more than one `5`. For example, multiples of `25` will contribute at least two `5`'s.\\n\\nWell, how to count them all? If you try some examples, you may finally get the result, which is `n / 5 + n / 25 + n / 125 + ...`. The idea behind this expression is: all the multiples of `5` will contribute one `5`, the multiples of `25` will contribute one more `5` and the multiples of `125` will contribute another one more `5`... and so on. Now, we can write down the following code, which is pretty short.\\n\\n    class Solution {\\n    public:\\n        int trailingZeroes(int n) { \\n            int count = 0;\\n            for (long long i = 5; n / i; i *= 5)\\n                count += n / i;\\n            return count;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\n    public:\\n        int trailingZeroes(int n) { \\n            int count = 0;\\n            for (long long i = 5; n / i; i *= 5)\\n                count += n / i;\\n            return count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52506,
                "title": "o-log-5-n-solution-java",
                "content": "O(log_5(N)) (base 5!) is faster than any polynomial. You need no more than 14 iterations to get the result. You just need to count how many times 5 appears in n! during multiplication in different forms: 5, 25, 125, 625, ... . when any 5 is multiplied by 2 (we have many of them) then we get 0 at the end. That's it.\\n\\n    public class Solution {\\n        public int trailingZeroes(int n) {\\n            int r = 0;\\n            while (n > 0) {\\n                n /= 5;\\n                r += n;\\n            }\\n            return r;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int trailingZeroes(int n) {\\n            int r = 0;\\n            while (n > 0) {\\n                n /= 5;\\n                r += n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 355808,
                "title": "javascript-solution-with-explanation",
                "content": "First, let\\'s think about in what situation will we get a trailing zero. We get a trailing zero whenever we multiply a non zero number by 10.\\n\\nExample: 1 * 10 = 10\\n\\nSince 10 is made up of multiplying 2 by 5, another way to get a trailing zero is to multiply a non zero number by 2 and 5.\\n\\nExample: 1 * 2 * 5 = 10\\n\\nSo, to count the number of trailing zeroes we just need to figure out how many times we multiply 2 by 5.\\n\\nExample: \\n1 * (2 * 5) = 10 // one trailing zero\\n1 * (2 * 5) * (2 * 5) = 100 // two trailing zeroes\\n\\nNow let\\'s look at factorial.\\n\\nThe factorial of 5 is:\\n1 * **2** * 3 * 4 * **5** = 120\\nSince we have multiplied 2 and 5 once, there is one trailing zero.\\n\\nThe factorial of 10 is:\\n1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 = 3628800\\nAnother way to write this is:\\n1 * **2** * 3 * 4 * **5** * 6 * 7 * 8 * 9 * **2** * **5** = 3628800\\nAs you can see, we have multiplied 2 and 5 twice, so there are two trailing zeroes.\\n\\nInstead of keeping track of the number of 2s and 5s, we really just need to keep track of the number of 5s. This is because in any factorial calculation there are always going to be more multiples of 2 than 5. \\n\\nExample: From the numbers 1 to 10, there are five multiples of 2 but only two multiples of 5. \\n\\nQuestion: How many 5s are there in the factorial of 25?\\nYou may guess the answer is 25 / 5 = 5, however there are actually 6.\\n\\nHere are all the multiples of 5 in the factorial of 25: \\n5, 10, 15, 20, 25\\nAnother way to write this is:\\n(5 * 1), (5 * 2), (5 * 3), (5 * 4), (5 * 5)\\nAs you can see, 5 is actually multiplied 6 times.\\n\\nWe can simplify the answer to the Factorial Trailing Zeroes question to the following:\\n(n / 5) + (n / 5^2) + (n / 5^3)... (n / 5^x)\\nWe continue until 5^x is greater than n.\\n\\n```\\nvar trailingZeroes = function(n) {\\n    let numZeroes = 0;\\n    for (let i = 5; i <= n; i *= 5) {\\n        numZeroes += Math.floor(n / i);\\n    }\\n    return numZeroes;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar trailingZeroes = function(n) {\\n    let numZeroes = 0;\\n    for (let i = 5; i <= n; i *= 5) {\\n        numZeroes += Math.floor(n / i);\\n    }\\n    return numZeroes;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52510,
                "title": "o-log5-n-solution-python",
                "content": "1. meet the number that can be dived by 5, the Trailing will have 1 more zero.\\n\\n2 .meet the number that can be dived by 5*5, the Trailing will have 2 more zero.\\n..\\n\\n..\\n\\n..\\n\\nand so on.\\n\\n\\nso we just find how many number can be dived by 5, can be dived by 5*5 ...  and sum up.\\n\\n\\n        def trailingZeroes(self, n):\\n            r = 0\\n            while n > 0:\\n                n /= 5\\n                r += n\\n            return r",
                "solutionTags": [
                    "Python"
                ],
                "code": "1. meet the number that can be dived by 5, the Trailing will have 1 more zero.\\n\\n2 .meet the number that can be dived by 5*5, the Trailing will have 2 more zero.\\n..\\n\\n..\\n\\n..\\n\\nand so on.\\n\\n\\nso we just find how many number can be dived by 5, can be dived by 5*5 ...  and sum up.\\n\\n\\n        def trailingZeroes(self, n):\\n            r = 0\\n            while n > 0:\\n                n /= 5\\n                r += n\\n            return r",
                "codeTag": "Python3"
            },
            {
                "id": 52424,
                "title": "iterative-python-solution-with-explanation",
                "content": "We add a trailing zero every time we multiply by 10 (5 * 2). Since we will have always more 2s than 5s, the problem is to find the number of 5s in the numbers from 1 to n.\\nLet's consider 10! as example:\\n\\n10! = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1\\n\\nIn this case, we have two 5s (in 10 and 5), so the result is 2. How can we efficiently compute this number for a given n? Well, we could compute the multiple of 5 contained in n, but this is not enough: for example, 25 accounts for 2 5s, 50 accounts also for 2 5s, and so on.\\n\\nSo, we do the following: we start from 5, and we see how many multiples of 5 we have in n. Then, we multiply 5 by 5 (25) and we add how many multiples of 25 we have in n. In this case we will not have duplicates, as at in each step we will add only one 5 to the result.\\n\\n    class Solution(object):\\n        def trailingZeroes(self, n):\\n            k, tot = 5, 0\\n            while k <= n:\\n                tot += n // k\\n                k = k * 5\\n            return tot",
                "solutionTags": [
                    "Python"
                ],
                "code": "We add a trailing zero every time we multiply by 10 (5 * 2). Since we will have always more 2s than 5s, the problem is to find the number of 5s in the numbers from 1 to n.\\nLet's consider 10! as example:\\n\\n10! = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1\\n\\nIn this case, we have two 5s (in 10 and 5), so the result is 2. How can we efficiently compute this number for a given n? Well, we could compute the multiple of 5 contained in n, but this is not enough: for example, 25 accounts for 2 5s, 50 accounts also for 2 5s, and so on.\\n\\nSo, we do the following: we start from 5, and we see how many multiples of 5 we have in n. Then, we multiply 5 by 5 (25) and we add how many multiples of 25 we have in n. In this case we will not have duplicates, as at in each step we will add only one 5 to the result.\\n\\n    class Solution(object):\\n        def trailingZeroes(self, n):\\n            k, tot = 5, 0\\n            while k <= n:\\n                tot += n // k\\n                k = k * 5\\n            return tot",
                "codeTag": "Java"
            },
            {
                "id": 755572,
                "title": "python-log-n-loop-100-speed",
                "content": "**Python Log(n) Loop | 100% Speed**\\n\\nThe code below presents an Easy Python solution with clear syntax. The algorithm works as follows:\\n\\n1. The numbers of \"zeros\" in \"n!\" can be traced by decomposing the multiplication \"n * (n-1) * ...\" into a prime factorization with the format:\\n * n! = 2^a * 3^b * 5^c, ...\\n\\n2. In this factorization, the number of \"zeros\" in \"n!\" would correspond to the highest number of \"10\\'s\" that we can form. Since  \"10 = 5 * 2\", the number of zeros would be \"10\\'s = min(a,c) \". \\n\\n3. While we should consider tracking 2^a and 5^c separately, we can note that 50% of integer numbers are even (multiples of 2), whereas only 20% are multiples of 5.\\n\\n4. As a result, we can conclude that we add a zero to our factorial every time we multiply by 5...\\n\\n5. Some numbers can multiply by 5 more than once, such as 5^2 = 25 or 5^3 = 125. We can consider these cases by adding a loop to account for all multiples of 5^x. Since 5^x grows exponentially, we achieve an algorithm with Log(n) time complexity.\\n\\nI hope the explanation was helpful. This is a very interesting problem.\\n\\nCheers,\\n\\n```\\nclass Solution:\\n    def trailingZeroes(self, n):\\n        x   = 5\\n        res = 0\\n        while x <= n:\\n            res += n//x\\n            x   *= 5\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n):\\n        x   = 5\\n        res = 0\\n        while x <= n:\\n            res += n//x\\n            x   *= 5\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52493,
                "title": "simple-c-solution",
                "content": "Because from 1 to n, the number of 2 factors is always bigger than the number of 5 factors. So we only need to find the number of 5 factors among 1...n.\\n\\n1st loop: 5, 10, 15, 20, 25, 30, ....\\n\\n2nd loop:                      25              50         ......\\n.....\\n\\ncode:\\n\\n    class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int res=0;\\n            while(n){\\n                n/=5;\\n                res+=n;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int res=0;\\n            while(n){\\n                n/=5;\\n                res+=n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 522315,
                "title": "clear-explanation-of-the-solution-since-i-didn-t-find-an-adequate-one",
                "content": "This problem is difficult mainly because you must reach the insight that __it is a multiple of 5 and an even number that leads to a trailing zero__ and since there are on average 4 times as many even numbers as 5s (from 1-9 for example 2,4,6,8), the limiting factor for the number of trailing zeros are the number of 5s that will be multiplied. Hence, you count them and you\\'re good.\\n\\nTake for example 5! (5 factorial). It is `5 x 4 x 3 x 2 x 1`. It can be written either as `20 x 6` or `10 x 12` in both cases the mutiplication of 5 either with 4 or 2 being the factor that causes the single trailing zero in the final answer 120.\\n\\nSo for n = 25, the factorial:\\n`25 x 24 x 23 x 22 x 21 x 20 x 19 x 18 x 17 x 16 x 15 x 14 x 13 x 12 x 11 x 10 x 9 x 8 x 7 x 6 x 5 x 4 x 3 x 2 x 1`\\n\\nSo the number of 5s here are 5, 10 (5 x 2), 15 (5 x 3), 20 (5 x 4), and two 5s in 25 (5 x 5). So in total 6 fives. So we should expect 6 trailing zeros.\\n\\nAnd indeed it is the case: 15511210043330985984**000000**\\n\\nHow to get them? Do integer division!\\n\\nFirst `25 // 5 -> 5`. Then `5 // 5 -> 1` (stopping here since `1 // 5 -> 0` so ignoring that). So we would expect 5 + 1 trailing zeros.\\n\\nThe code below is from another post. Purpose of the post was to give the intuition of what\\'s happening below.\\n```python\\ndef trailingZeroes(n: int) -> int:\\n    cnt = 0\\n    while n != 0:\\n        n = n // 5\\n        cnt = cnt + n  # NOT incremented by 1. Incremented by n.\\n    return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef trailingZeroes(n: int) -> int:\\n    cnt = 0\\n    while n != 0:\\n        n = n // 5\\n        cnt = cnt + n  # NOT incremented by 1. Incremented by n.\\n    return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 52399,
                "title": "my-python-solution-in-o-1-space-o-logn-time",
                "content": "**Concept:**\\n\\nSince 0 only company with 5*2\\nSo only need to count the volume of 5 factor. (because 2 always enough)\\n\\nSo..\\n100! \\'s  zero has => floor(100/5) + floor(100/25) =  floor(100/5) + floor((100/5)/5) \\n\\n**Code:**\\n\\n    class Solution(object):\\n        def trailingZeroes(self, n):\\n            zeroCnt = 0\\n            while n > 0:\\n                n = n//5; zeroCnt += n\\n            \\n            return zeroCnt",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Concept:**\\n\\nSince 0 only company with 5*2\\nSo only need to count the volume of 5 factor. (because 2 always enough)\\n\\nSo..\\n100! \\'s  zero has => floor(100/5) + floor(100/25) =  floor(100/5) + floor((100/5)/5) \\n\\n**Code:**\\n\\n    class Solution(object):\\n        def trailingZeroes(self, n):\\n            zeroCnt = 0\\n            while n > 0:\\n                n = n//5; zeroCnt += n\\n            \\n            return zeroCnt",
                "codeTag": "Java"
            },
            {
                "id": 817709,
                "title": "solution-using-prime-factorization-with-easy-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        long int i=0;\\n        for(i=5; n/i >=1 ;i*=5){\\n            ans+= n/i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nA number has trailing zeroes if it is divisible by 10 which has prime factors 2 and 5.\\nLet a number be 95000. \\nHow many trailing zeroes are in this number?   Ans: 3\\nWhat is the highest power of 10 the number is divisible by? Ans: 10^3. So, 3 is the ans.\\nHence, we can say, if an integer is divisible by 10^k, then it has k trailing zeroes.\\n\\nNow let a number be 2^5 * 5^4. Here  2^4 * 5^4 is the highest power of 10 which is 10^4. So, The number has 4 trailing powers.\\nAnother example, 2^3 * 3^1 * 5^4 * 7^2 gives us 2^3 * 5^3 to make the max power of 10 hence 3 trailing zeroes.\\nSo, we can see that the number of trailing zeroes comes from the power of 2 and power of 5, whichever is smaller. Then we also see that total power of 2 is always less than or equal to total power of 5. So, it is absolutely fine if we calculate only power of 5.\\n\\nSo, from the explanation above, let\\'s calculate 30! 30! has 30/5 = 6 multiples of 5 that are less or equal than 30.\\n\\t\\t\\t30! = 30* 25* 20 * 15 * 10 * 5 * k\\nEach term here contributes 5^1 factor except 25 which contributes 5^2 factor (which gives extra 1 trailing zero). So, the number of trailing zeroes in 30! is 7.\\n\\nThus each multiple of 25 will contribute an additional 1 trailing zero.\\nLet\\'s find the number of trailing zeroes in 500!\\n500/5 + 500/25 + 500/125 = 100+20+4 = 124 trailing zeroes (Ans). Here 25 gives extra 4, 125 gives extra 4 trailing zeroes.\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        long int i=0;\\n        for(i=5; n/i >=1 ;i*=5){\\n            ans+= n/i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52428,
                "title": "sharing-my-java-solution-in-1ms-runtime",
                "content": "    public int trailingZeroes(int n) {\\n        int count = 0;\\n \\n        while(n > 0) {\\n            n /= 5;\\n            count += n;\\n        }\\n \\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int trailingZeroes(int n) {\\n        int count = 0;\\n \\n        while(n > 0) {\\n            n /= 5;\\n            count += n;\\n        }\\n \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52432,
                "title": "3-lines-of-java-o-logn-time-o-1-space",
                "content": "    public class Solution {\\n        public int trailingZeroes(int n) {\\n            int s = 0;\\n            while (n>4) s += (n/=5);\\n            return s;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int trailingZeroes(int n) {\\n            int s = 0;\\n            while (n>4) s += (n/=5);\\n            return s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52480,
                "title": "share-my-3ms-solution-in-c",
                "content": "int trailingZeroes(int n) {\\n    int res = 0;\\n\\n    do\\n    {\\n        res += n/5;\\n    }while(n /= 5);\\n    \\n    return res;\\n}",
                "solutionTags": [],
                "code": "int trailingZeroes(int n) {\\n    int res = 0;\\n\\n    do\\n    {\\n        res += n/5;\\n    }while(n /= 5);\\n    \\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2835993,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int res=0;\\n        while(n){\\n            n/=5;\\n            res+=n;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int res=0;\\n        while(n){\\n            n/=5;\\n            res+=n;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52472,
                "title": "one-liners-in-c-java-python-ruby-c-c",
                "content": "All of these got accepted, but some **might** be unsafe in general because of evaluation order. I didn't check the specifications.\\n\\n    Ruby          (1..13).map{|e| n/5**e}.reduce(:+)\\n                  z=0; (1..13).each{|e| z+=n/5**e}; z\\n                  n > 0 ? trailing_zeroes(n/=5) + n : 0              Maybe unsafe\\n                  n > 0 ? n/5 + trailing_zeroes(n/5) : 0\\n                  (n/=5) > 0 ? n + trailing_zeroes(n) : 0\\n                  n > 0 ? (n/=5) + trailing_zeroes(n) : 0            Maybe unsafe\\n\\n    Python        return sum(n/5**e for e in range(1,14))\\n                  return n and n/5 + self.trailingZeroes(n/5)\\n\\n    C++ and C     int z=0; while(n) z+=n/=5; return z;\\n                  return n ? n + trailingZeroes(n/=5) : 0;           Maybe unsafe\\n                  return n ? n/5 + trailingZeroes(n/5) : 0;\\n                  return (n/=5) ? n + trailingZeroes(n) : 0;\\n                  return n ? (n/=5) + trailingZeroes(n) : 0;         Maybe unsafe\\n\\n    Java and C\\u266f   int z=0; while(n>0) z+=n/=5; return z;\\n                  return n > 0 ? trailingZeroes(n/=5) + n : 0;       Maybe unsafe\\n                  return n > 0 ? n/5 + trailingZeroes(n/5) : 0;\\n                  return (n/=5) > 0 ? n + trailingZeroes(n) : 0;\\n                  return n > 0 ? (n/=5) + trailingZeroes(n) : 0;     Maybe unsafe\\n\\nI didn't write JavaScript solutions because of the absence of integer division and because I don't know it well. And they'd probably look like ugly versions of the Java or C++ solutions anyway.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Ruby"
                ],
                "code": "All of these got accepted, but some **might** be unsafe in general because of evaluation order. I didn't check the specifications.\\n\\n    Ruby          (1..13).map{|e| n/5**e}.reduce(:+)\\n                  z=0; (1..13).each{|e| z+=n/5**e}; z\\n                  n > 0 ? trailing_zeroes(n/=5) + n : 0              Maybe unsafe\\n                  n > 0 ? n/5 + trailing_zeroes(n/5) : 0\\n                  (n/=5) > 0 ? n + trailing_zeroes(n) : 0\\n                  n > 0 ? (n/=5) + trailing_zeroes(n) : 0            Maybe unsafe\\n\\n    Python        return sum(n/5**e for e in range(1,14))\\n                  return n and n/5 + self.trailingZeroes(n/5)\\n\\n    C++ and C     int z=0; while(n) z+=n/=5; return z;\\n                  return n ? n + trailingZeroes(n/=5) : 0;           Maybe unsafe\\n                  return n ? n/5 + trailingZeroes(n/5) : 0;\\n                  return (n/=5) ? n + trailingZeroes(n) : 0;\\n                  return n ? (n/=5) + trailingZeroes(n) : 0;         Maybe unsafe\\n\\n    Java and C\\u266f   int z=0; while(n>0) z+=n/=5; return z;\\n                  return n > 0 ? trailingZeroes(n/=5) + n : 0;       Maybe unsafe\\n                  return n > 0 ? n/5 + trailingZeroes(n/5) : 0;\\n                  return (n/=5) > 0 ? n + trailingZeroes(n) : 0;\\n                  return n > 0 ? (n/=5) + trailingZeroes(n) : 0;     Maybe unsafe\\n\\nI didn't write JavaScript solutions because of the absence of integer division and because I don't know it well. And they'd probably look like ugly versions of the Java or C++ solutions anyway.",
                "codeTag": "Unknown"
            },
            {
                "id": 52490,
                "title": "c-3-lines-implementation",
                "content": "class Solution {\\n\\npublic:\\n\\n    int trailingZeroes(int n) {\\n\\n        int sum=0;\\n\\n        for (int i = n/5; i>0; i/=5) sum += i;\\n\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    int trailingZeroes(int n) {\\n\\n        int sum=0;\\n\\n        for (int i = n/5; i>0; i/=5) sum += i;\\n\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 52497,
                "title": "python-one-liner",
                "content": "    def trailingZeroes(self, n):\\n        return 0 if n < 5 else n/5 + self.trailingZeroes(n/5)",
                "solutionTags": [],
                "code": "    def trailingZeroes(self, n):\\n        return 0 if n < 5 else n/5 + self.trailingZeroes(n/5)",
                "codeTag": "Python3"
            },
            {
                "id": 1152167,
                "title": "python3-o-log-n-time-o-1-space-explanation",
                "content": "To help this intution stick let\\'s work with an example, say 60! I can tell you that 60! has 14 trailing zeros.\\n\\nLet\\'s begin by understanding how a trailing zero is created. The simplest way to create a trailing zero is to multiply a given number by 10. Now, every number has at least two factors, namely itself and 1, however these are the trivial factors that every number has. Excluding these trivial factors 10 can be factored as 2 x 5. We can therefore deduce that the number of trailing zeros will be dictated by the smaller of the count of factor 2 and the count of factor 5 in 60!\\n\\n60! can be divided by 2, 52 times and divided by 5, 14 times. As multiples of 2 occur more frequently than multiples of 5 in the natural numbers, the number of trailing zeros will be dictated by the number of times 60! can be divided by 5.\\n\\nWhich of the natural numbers up to 60 have at least one factor of 5?\\nThere are 12, (5, 10, 15, 20, 35, 30, 35, 40, 45, 50, 55, 60), which can be found by 60 / 5\\n\\nSo we\\'ve found the number of natural numbers up to 60 that have at least a factor of 5 but you may notice that 25 and 50 can be factored as 5x5 and 5x5x2 and so we\\'ll have to account for the fact that there are some numbers that will have more than one factor of 5.\\n\\n60 // 5 + 60 // 25 = 12 + 2 which gives us our answer.\\n\\nTo find the general solution to this problem we can factor our previous equation as follows:\\nquotient = 60 // 5\\nans = quotient + quotient // 5\\n\\nThis can be applied in a recursive way to account for increasingly many numbers with increasing factors of 5.\\n\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        quotient = n // 5\\n        return quotient + self.trailingZeroes(quotient) if quotient >= 5 else quotient\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        quotient = n // 5\\n        return quotient + self.trailingZeroes(quotient) if quotient >= 5 else quotient\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52440,
                "title": "1ms-1-line-java-solution",
                "content": "Another way to deal \\n    \\n    public int trailingZeroes(int n) {\\n        return n>=5 ? n/5 + trailingZeroes(n/5): 0;\\n    }",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "Another way to deal \\n    \\n    public int trailingZeroes(int n) {\\n        return n>=5 ? n/5 + trailingZeroes(n/5): 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1151659,
                "title": "c-from-worst-to-best-all-solutions-with-expalanation-comments",
                "content": "**First Approach**\\nMany of us probably though in order to find trailing zeros in factorial number first we need to generate 10\\'s to get some zeros. To generate 10\\'s we need to find 5\\'s and 2\\'s because\\n`10 = 2 x 5` meaning that we only need to find all 2 and 5 pairs together, other numbers because don\\'t help generating 10\\'s. Besides, we will have enough (at least as many as 5\\'s) 2\\'s because of even numbers so we don\\'t need to worry about number of 2\\'s. That\\'s why we will focus on the number of 5\\'s which will lead us towards the result.\\n\\nSee this example;\\n5! = **5**.4.3.**2**.1 -> **(5.2)**.4.3.1 ->**(10)**.4.3.1\\nHere the numbers that gives us 10 are only 2 and 5.\\n\\nSecondly, in some numbers like 25, 125, we may have many 5\\'s we should also take care this.\\n\\n**O(N) Solution**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n        // Since we have enought 2\\'s because of even numbers\\n        // It is enough to count only 5\\'s\\n        for (int i = 1; i <= n; i++) {\\n            if (i % 5 == 0) {\\n                // Check for power of 5\\n                int pow5 = i;\\n                while ((pow5 % 5) == 0) {\\n                    pow5 /= 5;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\n**Optimization**\\nNow, since we proved that we just need to count 5\\'s only in the above section, Why would not we just count how many 5\\'s we have directly right? So we just got rid of the for loop where we incremented i one by one in linear time. Instead, we will use `/` operator which will give us logarithmic time.\\n\\n**O(logn) Solution**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n        while (n > 0) {\\n            count += n / 5;\\n            n /= 5;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n        // Since we have enought 2\\'s because of even numbers\\n        // It is enough to count only 5\\'s\\n        for (int i = 1; i <= n; i++) {\\n            if (i % 5 == 0) {\\n                // Check for power of 5\\n                int pow5 = i;\\n                while ((pow5 % 5) == 0) {\\n                    pow5 /= 5;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n        while (n > 0) {\\n            count += n / 5;\\n            n /= 5;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 223702,
                "title": "java-solutions",
                "content": "- The **brute-force algorithm** is to count trailing zeros is first find factorial of number and then count the zeros in the factorial one by one. It is fine for smaller number like `10`. Since `10! = 3628800` and so, trailing zeros = `2`. But what about big numbers like `100`. The factorial of `100` has `24` zeros in the end and almost `160` digits. Its really hard to store that big number and then count the zeros one by one.\\n- The **better idea** is to count the number of `5` factors in all numbers from `1` to `n`. Since all trailing `0` is from factors `2 * 5`. In `n!` operation, factors `2` will always be more than factors `5`. So we just count the number of 5 factors in all numbers from `1` to `n`.\\n\\n**Example 1:**\\n- There are four multiples of `5` between `1` and `23`. i.e. `5, 10, 15, and 20`,  So `23!` has `4` zeros.\\n\\n**Example 2:**\\n- There are `20` multiples of `5` from `1` to `100`, since `100 / 5 = 20`. But actually `25` is `5 * 5`, so each multiple of `25` has an extra factor of `5` which should also be counted. Since `100 / 25 = 4`, there are four multiples of `25` between `1` and `100`. Finally, we get `20 + 4 = 24` trailing zeros in `100!`. Therefore, we need care about `5` powers as well, to consider additional `5` factors.\\n\\n- So it can be computed as:\\n`count = (n / 5) + (n / 25) + (n / 125) + ... + 0`. Iteration will be terminated when `5^k` becomes greater than `n`.\\n\\n**Solution 1: Iterative**\\n\\nTime complexity: `O(log n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public int trailingZeroes(int n) \\n    {\\n        int count = 0;\\n        \\n        while(n >= 5)\\n            count += (n /= 5);\\n        \\n        return count;\\n    }\\n}\\n```\\n\\n**OR**\\n\\n```\\nclass Solution \\n{\\n    public int trailingZeroes(int n) \\n    {\\n        int count = 0;\\n        \\n        for(long i = 5; n / i > 0; i *= 5)\\n            count += (n / i);\\n        \\n        return count;\\n    }\\n}\\n```\\n\\n**Solution 2: Recursive**\\n\\nTime complexity: `O(log n)`\\nSpace complexity: `O(log n)` - space required for the recursive function call stack.\\n\\n```\\nclass Solution \\n{\\n    public int trailingZeroes(int n) \\n    {\\n        if(n < 5)\\n\\t\\t\\treturn 0;\\n\\t\\telse\\n\\t\\t\\treturn (n / 5) + trailingZeroes(n / 5);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int trailingZeroes(int n) \\n    {\\n        int count = 0;\\n        \\n        while(n >= 5)\\n            count += (n /= 5);\\n        \\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public int trailingZeroes(int n) \\n    {\\n        int count = 0;\\n        \\n        for(long i = 5; n / i > 0; i *= 5)\\n            count += (n / i);\\n        \\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public int trailingZeroes(int n) \\n    {\\n        if(n < 5)\\n\\t\\t\\treturn 0;\\n\\t\\telse\\n\\t\\t\\treturn (n / 5) + trailingZeroes(n / 5);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52474,
                "title": "4ms-c-solution-and-short-explanation",
                "content": "There are lots of explanations of this online. Briefly, pairs of factors of 2 and 5 in the prime factorization of n! generate trailing zeros. So for every 5 in the prime factorization, we can pair it with a 2 to generate a trailing zero. There are more than enough 2s to go around, the limiting \"factor\" is the 5s. Clearly there are at least n / 5 factors of 5 in n!. But in addition to being divisible by 5, n! may be divisible by 5^2, 5^3 and so on, which introduce more factors of 5 that pair up with factors of 2 to get more trailing zeros. So at each step of the algorithm we just divide by 5 and add the quotient to our total zero count, until the number isn't divisible by a power of 5. \\n\\n    class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int zeros = 0;\\n            while (n) {\\n                zeros += n / 5;\\n                n /= 5;\\n            }\\n            return zeros;   \\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int zeros = 0;\\n            while (n) {\\n                zeros += n / 5;\\n                n /= 5;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 52460,
                "title": "a-4ms-c-solution-using-method-in-wikipedia",
                "content": "    class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int count = 0;\\n            while(n /= 5) count += n;\\n            return count;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int count = 0;\\n            while(n /= 5) count += n;\\n            return count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3579829,
                "title": "100-faster-c-solution-o-log-n-time-complexity-with-easy-explanation",
                "content": "# Observation\\nIf you read the question carefully, you will find a follow-up section below sample testcases which gives a hint on how to approach this problem.\\nIf you analyse the problem properly and check the expected output for the input number, you will observe a pattern that the answer increases by 1 at an interval of 5. Also for larger inputs their actual answer is slightly above the quotient of number divided by 5.\\nThis is where the follow up helps. \\n```\\nInput/Output\\n100 -> 24 (100/5 = 20, then 20/5 = 4; 20+4)\\n10 -> 2 (10/2 = 2, then 2/5 = 0; 2+0)\\n24 -> 4 (24/5 = 4, then 4/5 = 0; 4+0)\\n25 -> 6 (25/5 = 5, then 5/5 = 1; 5+1)\\n200 -> 49 (200/5 = 40, 40/5 = 8, 8/5 = 1; 40+8+1)\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize the variable ans with 0.\\nIterate over input n until n>0.\\nInside the loop, increase ans with the value of \"n/5\". And the, modify n such that now n is equal to n/5.\\nReturn the answer (ans).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log n) ; base = 5\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans = 0;\\n        while (n>0){\\n            ans += n/5;\\n            n = n/5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nInput/Output\\n100 -> 24 (100/5 = 20, then 20/5 = 4; 20+4)\\n10 -> 2 (10/2 = 2, then 2/5 = 0; 2+0)\\n24 -> 4 (24/5 = 4, then 4/5 = 0; 4+0)\\n25 -> 6 (25/5 = 5, then 5/5 = 1; 5+1)\\n200 -> 49 (200/5 = 40, 40/5 = 8, 8/5 = 1; 40+8+1)\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans = 0;\\n        while (n>0){\\n            ans += n/5;\\n            n = n/5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136108,
                "title": "easy-one-line-solution-and-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDetermine how 0 will be formed\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nzero can be formed by combination of (5,2) count the number of 5 in given n! basically do n/5 will give the number of 5 but there is a catch 25 has (5,5) that means we have to calculate it one more time\\nfor that just divide the n in multiple of 5(5,25,125,625,3125) for 2,3,4 digits number\\n# Complexity\\n- Time complexity: o(1) 0ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n/5+n/25+n/125+n/625+n/3125;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n/5+n/25+n/125+n/625+n/3125;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971559,
                "title": "java-o-log-n-solution-with-detailed-explanation-0ms",
                "content": "Explanation:\\n\\nTo get a 0 at trail, there should be a pair of 2 and 5 in factors below n. We can observe that number of 2s as a factor is always greater than or equal to number of 5s as a factor.  This means, number of pair of 2 and 5 really depends on number of 5s as a factor and thus all computation depends on 5 and not 2.\\n\\nWe basically have to count how many 5s as a factor, are there below the given number. For numbers < 25, We can find out how many 5s are there by simple doing n/5. For 25 (5^2)  number of 0s are: 25/ 5 = 5 + 1. This one is added because 25 has 2 fives and not just one. Thus, an extra pair of 5 and 2 leading to an extra 0. This explanation continues for all the exponentiation of 5 lesser than the number itself. \\n\\nCode:\\n\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n    \\n        int sol = 0;\\n        int expOfFive = 5;\\n        while(n >= expOfFive){\\n            sol += n / expOfFive;\\n            expOfFive = 5 * expOfFive;\\n        }\\n        return sol;\\n        \\n    }\\n}\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int trailingZeroes(int n) {\\n    \\n        int sol = 0;\\n        int expOfFive = 5;\\n        while(n >= expOfFive){\\n            sol += n / expOfFive;\\n            expOfFive = 5 * expOfFive;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 778503,
                "title": "python-3-3-levels-of-implementation-with-explanation-for-each",
                "content": "Someone\\'s first attempt might look something like this:\\n```\\n        fact = math.factorial(n) #use the math class to calculate the factorial\\n\\n        string = [i for i in str(fact)] #Turn the into a string list\\n        \\n        string.reverse() #reverse it so all 0\\'s are in front\\n        count = 0\\n        \\n        #continue counting up until you hit a number that is not 0, then return the counter\\n        for number in string:\\n            if number != \\'0\\':\\n                return count\\n            count += 1\\n```\\n\\nHowever, you will notice that this method only works for values of \\'n\\' that are relatively small. In order to  account for any value of \\'n\\' we need to look into how trailing 0\\'s occur within factorials.\\n\\nLet\\'s take a look at a few factorial results:\\n\\n4! = 1 * 2 * 3 * 4 = 24\\n5! = 24 * 5 = 120\\n6! = 120 * 6 = 720\\n7! = 720 * 7 = 4320\\n8! = 4320 * 8 = 34,560\\n9! = 34560 * 9 = 311,040\\n10! = 311,040 * 10 = 3,110,400\\n\\nAs you can see, the number of trailing 0\\'s is equal to the number of times the given n can be divided by 5, or to put it more bluntly:\\n\\n4/5 = 0 -> 0 trailing 0\\'s\\n5/5 = 1 -> 1 trailing 0\\n9/5 = 1 -> 1 trailing 0\\n10/5 = 2 -> 2 trailing 0\\'s.\\n\\nWith this in mind, we can count the number of trailing 0\\'s by counting how many times 5 can go into n\\n\\nHowever, we also need to consider the case in which \\'n\\' is very large. For example, if n = 200, our logic would look like this: 200/5 = 40. So 40 trailing 0\\'s right? Well, we also have to consider that 40 is *also* a multiple of 5, so we need to continue dividing by 5 until we reach a number below 5. So the full logic should be:\\n\\n200/5 = 40 -> 40 trailing 0\\'s\\n40/5 = 8 -> 48 trailing 0\\'s\\n8/5 = 1 -> 49 trailing 0\\'s\\n\\nWith this logic in hand, we can create a while loop that implements our method\\n```\\n\\t\\tcount = 0\\n\\t\\t\\n        if n < 5:\\n            return 0\\n        \\n        while n >= 5 :\\n            count += int(n/5) \\n            n = int(n/5) \\n\\n        return count\\n```\\n\\nFinally, you will notice that we have all the elements we need to implement this solution recursively:\\n```\\n        if n < 5: #base case\\n            return 0\\n        else: #add the current factor of 5 to the next smallest factor of n/5\\n            return int(n/5) + self.trailingZeroes(int(n/5))\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\n        fact = math.factorial(n) #use the math class to calculate the factorial\\n\\n        string = [i for i in str(fact)] #Turn the into a string list\\n        \\n        string.reverse() #reverse it so all 0\\'s are in front\\n        count = 0\\n        \\n        #continue counting up until you hit a number that is not 0, then return the counter\\n        for number in string:\\n            if number != \\'0\\':\\n                return count\\n            count += 1\\n```\n```\\n\\t\\tcount = 0\\n\\t\\t\\n        if n < 5:\\n            return 0\\n        \\n        while n >= 5 :\\n            count += int(n/5) \\n            n = int(n/5) \\n\\n        return count\\n```\n```\\n        if n < 5: #base case\\n            return 0\\n        else: #add the current factor of 5 to the next smallest factor of n/5\\n            return int(n/5) + self.trailingZeroes(int(n/5))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52485,
                "title": "2-lines-java-solution-any-better-code",
                "content": "    public int trailingZeroes(int n) {\\n        if(n < 5) return 0;\\n        else return n/5 + trailingZeroes(n/5);\\n    }",
                "solutionTags": [],
                "code": "    public int trailingZeroes(int n) {\\n        if(n < 5) return 0;\\n        else return n/5 + trailingZeroes(n/5);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1377295,
                "title": "c-100-faster-easy-to-understand-2-methods",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Method 1**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) \\n    {\\n        int count5=0,num;\\n        for(int i=5;i<=n;i+=5)\\n        {\\n           num=i;\\n           while(num%5==0)\\n           {\\n               count5++;\\n               num/=5;\\n           } \\n        }   \\n        return count5;\\n    } \\n};\\n```\\n**Method 2(100% faster):**\\nlogic: https://www.purplemath.com/modules/factzero.htm\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) \\n    {\\n        int count=0;\\n        while(n/5>=1)\\n        {\\n          count+=(n/5);\\n          n=n/5;  \\n        }    \\n        return count;\\n    } \\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) \\n    {\\n        int count5=0,num;\\n        for(int i=5;i<=n;i+=5)\\n        {\\n           num=i;\\n           while(num%5==0)\\n           {\\n               count5++;\\n               num/=5;\\n           } \\n        }   \\n        return count5;\\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) \\n    {\\n        int count=0;\\n        while(n/5>=1)\\n        {\\n          count+=(n/5);\\n          n=n/5;  \\n        }    \\n        return count;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855400,
                "title": "java-solution-explanation-thought-process",
                "content": "**TL;DR**\\nThis took me a while to figure out, I suggest watching this [K5 video](https://www.youtube.com/watch?v=GokjSyb-Z_c) explaining the theory behind this approach.\\n\\n**Base Case** - `21! = 51,090,942,171,709,440,000`\\n\\n**Explanation**\\nIf a number has trailing zeros it is divisible by `10` without a remainder (i.e. `n % 10 == 0`) - therefore if `n` has trailing zeros then `10` will be a factor of `n`. \\n\\nThe theoretical brute-force solution is to divide the factorial by `10` until no zeros remain while maintaining a count. Consider the base case above - notice that the factorial of `21` is greater than both `Integer.MAX_VALUE` and `Long.MAX_VALUE`, therefore you will need to use a `BigInteger` to get around this issue.\\n\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n\\t\\n        BigInteger factorial = BigInteger.ONE; // factors start with 1\\n        for (int i = 2; i <= n; i++) // start computing from 2 onwards\\n            factorial = factorial.multiply(BigInteger.valueOf(i));\\n        \\n        int count = 0;\\n\\t\\t// remember, you can\\'t use normal arithmetic operators with BigInteger\\n        while (factorial.mod(BigInteger.TEN) == BigInteger.ZERO) {\\n            factorial = factorial.divide(BigInteger.TEN);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\nHowever, when I tried to submit the above code as my solution the execution time limit exceeded when trying to compute the factorials of large numbers like `9000`. Back to the drawing board - we need an approach which can be executed within the given time limit - and preferably with a single loop.\\n\\nLet\\'s consider the base case again - instead of computing the factorial and dividing it by `10`, we can consider it\\'s building blocks i.e. the preceding numbers themselves.\\n\\n`21! = 1 x 2 x 3 x 4 x 5 x 6 x 7 x 8 x 9 x 10 x 11 x 12 x 13 x 14 x 15 x 16 x 17 x 18 x 19 x 20 x 21`\\n\\nThe only elements divisible by `10` without a remainder are `10` and `20` - however we know for a fact that `21!` has `4` trailing zeros, so we need to dig deeper, so let\\'s consider the factors of `10` and `20`.\\n\\n`10 = 2 x 5`\\n`20 = 2 x 10 = 2 x 2 x 5` \\n\\nBoth `10` and `20` are in turn divisible by `2` and `5` without a remainder (i.e. `10 % 2 = 0`, `10 % 5 = 0`, `20 % 2 = 0`, `20 % 5 = 0`) since both `2` and `5` are factors of `10` which is in turn a factor of `20`. Let\\'s consider the occurrence of the common factors of both `10` and `20` (i.e. `2` and `5`) in our base case.\\n\\nBase Case - `21! = 1 x 2 x 3 x 4 x 5 x 6 x 7 x 8 x 9 x 10 x 11 x 12 x 13 x 14 x 15 x 16 x 17 x 18 x 19 x 20 x 21`\\nCommon Factors - `21! = 1 x 2 x 3 x (2 x 2) x 5 x (2 x 3) x 7 x (2 x 2 x 2) x 9 x (5 x 2) x 11 x (3 x 2 x 2) x 13 x (7 x 2) x (5 x 3) x (2 x 2 x 2 x 2) x 17 x (2 x 9) x 19 x (5 x 2 x 2) x (7 x 3)`\\n\\nAfter we break down the elements themselves with the common factors of `10` we can see that `2` occurs `17` times while `5` occurs only  `4` times. The reason why `2` occurs more than `5` is because it is the smallest common factor of every even number, causing it to repeat one or more times in every even number of the base cases\\'s sequence - however `5` is the only odd prime factor of `10` guaranteeing it to occur only in multiples of `5` in any sequence.\\n\\nAn efficient way to identify the occurences of `5` as a multiplier in the preceding numbers of the sequence is by dividing `n` by `5` and then dividing it\\'s result by `5` again until you get a result smaller than `5`  (watch video linked above). The addition of these results will be the occurence of zeros in the factorial of `n`.\\n\\n![image](https://assets.leetcode.com/users/images/88b8f91b-1d88-4e64-bd26-085aa5096eeb_1600581164.411297.png)\\n\\nIn the above examples `21!`, `75!` and `100!` will have `4`, `18` and `31` trailing zeros respectively. The coded solution would look like the following.\\n\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int result = 0;\\n        while (n >= 5) { // stop dividing when you get a result less than 5\\n            result += n/5; // add the result of n/5 to the counter - since we\\'re using integers we don\\'t need to worry about decimals\\n            n = n/5; // replace n with n/5 so that we can divide it by 5 in the next iteration\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nCheers!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n\\t\\n        BigInteger factorial = BigInteger.ONE; // factors start with 1\\n        for (int i = 2; i <= n; i++) // start computing from 2 onwards\\n            factorial = factorial.multiply(BigInteger.valueOf(i));\\n        \\n        int count = 0;\\n\\t\\t// remember, you can\\'t use normal arithmetic operators with BigInteger\\n        while (factorial.mod(BigInteger.TEN) == BigInteger.ZERO) {\\n            factorial = factorial.divide(BigInteger.TEN);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int result = 0;\\n        while (n >= 5) { // stop dividing when you get a result less than 5\\n            result += n/5; // add the result of n/5 to the counter - since we\\'re using integers we don\\'t need to worry about decimals\\n            n = n/5; // replace n with n/5 so that we can divide it by 5 in the next iteration\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52452,
                "title": "my-java-solution-2m",
                "content": "    public class Solution {\\n    public int trailingZeroes(int n) {\\n        if(n < 5) return 0;\\n        return n / 5 + trailingZeroes(n / 5);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int trailingZeroes(int n) {\\n        if(n < 5) return 0;\\n        return n / 5 + trailingZeroes(n / 5);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 52461,
                "title": "my-0ms-c-solution",
                "content": "` \\n int trailingZeroes(int n) {\\n\\n    if (n == 0)\\n        return 0;\\n    return n/5 + trailingZeroes(n/5);\\n}\\n`",
                "solutionTags": [],
                "code": "` \\n int trailingZeroes(int n) {\\n\\n    if (n == 0)\\n        return 0;\\n    return n/5 + trailingZeroes(n/5);\\n}\\n`",
                "codeTag": "Unknown"
            },
            {
                "id": 3583732,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor getting no. of zeros we must se how many times the number is multiplied by 10. In order to check that. I checked how many faactors of 5 are present in n!.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs to check for multiple of 10 the number must be multiple of 2 and 5. Here multiples of 2 will be more than multiples of 5 so I checked for multiple of 5.\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        if(n==0 || n==1){\\n            return 0;\\n        }\\n        int n5=0;\\n        while(n>=5){\\n            n/=5;\\n            n5+=n;\\n        }\\n        return n5;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        if(n==0 || n==1){\\n            return 0;\\n        }\\n        int n5=0;\\n        while(n>=5){\\n            n/=5;\\n            n5+=n;\\n        }\\n        return n5;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212798,
                "title": "172-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo compute the number of trailing zeroes in n!, we need to count the number of factors of 10 in n!. Notice that 10 can only be formed by multiplying 2 and 5, and we can always find more factors of 2 than factors of 5 in n!. Therefore, it suffices to count the number of factors of 5 in n! to determine the number of trailing zeroes.\\n\\nLet count = 0 be the variable that keeps track of the number of factors of 5. We can count the factors of 5 in n! by computing n/5 + n/25 + n/125 + ... until the quotient becomes 0. Each term in the sum corresponds to the number of multiples of 5, 25, 125, ..., that are less than or equal to n.\\n\\nThe final value of count will be the number of trailing zeroes in n!.\\n# Complexity\\n- Time complexity:\\nO(log n) - we keep dividing n by 5 in each iteration until n becomes 0.\\n\\n- Space complexity:\\nO(1) - we only use a constant amount of extra space to store the variable count.\\n\\n# Code\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        while n > 0:\\n            count += n // 5\\n            n //= 5\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        while n > 0:\\n            count += n // 5\\n            n //= 5\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516201,
                "title": "factorial-trailing-zeroes-mathematical-o-logn-o-1-time",
                "content": "**Idea**: A trailing 0 will be formed only if a number has both 2 and 5 as prime factors. \\nIf there are x number of 2 and y number of 5 then number of trailing zeros is `min(x,y)`\\n\\n**Observation**: Practically `count of 2 >= count of 5` always. So we just need to find count of 5.\\n\\n**How to count 5**: Since we are finding factorial of n, so we need to count the number of 5 in `1, 2 ,3 ,...,n`. We can observe that after every five numbers a 5 occurs:\\n1, 2, 3, 4, **5 (5x1)**\\n6, 7, 8, 9, **10 (5x2)**\\n11, 12, 13, 14, **15 (5x3)**\\n16, 17, 18, 19, **20 (5x2x2)**\\nBut numbers like 25, 125 (i.e 5^k) there will be extra 5s\\n25 (5x5)\\n125 (5x5x5)\\n...\\n\\nSo we need to count amount of numbers divisible by- \\n5 -> Containing one 5,\\n25 -> Containing two 5,\\n125 -> Containing three 5 ...\\n```python\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        i = 1\\n        while True:\\n            cur_div = n//(5**i)\\n            if cur_div == 0:\\n                break\\n            count += cur_div\\n            i += 1\\n        return count\\n```\\n\\nBut we can further improve the solution!\\nInstead of counting amount of numbers divisible by 5, 25, 125, 625...\\nWe can just reduce our `n` to `n//5` after each iteration and just count amount of numbers divisible by 5 at each iteration\\n```python\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        while n >= 5:\\n            n //= 5\\n            count += n\\n        return count\\n```\\n\\nTime Complexity: O(log5(n))\\nSpace complexity: O(1)\\n\\n# **BUT....**\\nOur constraints say that `0 <= n <= 10000`\\n So we can do it in **O(1) time** \\uD83D\\uDE43\\n Because we know that only power of 5 that lies in [0, 10000] are: 5, 25, 125, 625, 3125:\\n ```python\\n class Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        return n//5 + n//25 + n//125 + n//625 + n//3125\\n ```\\n \\n Bonus: One liner using [Walrus operator](https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions)\\n```python\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        return sum([n:=n//5 for i in range(5)])\\n```\\n\\nHope it helps :)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        i = 1\\n        while True:\\n            cur_div = n//(5**i)\\n            if cur_div == 0:\\n                break\\n            count += cur_div\\n            i += 1\\n        return count\\n```\n```python\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        while n >= 5:\\n            n //= 5\\n            count += n\\n        return count\\n```\n```python\\n class Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        return n//5 + n//25 + n//125 + n//625 + n//3125\\n ```\n```python\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        return sum([n:=n//5 for i in range(5)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324416,
                "title": "c-3-sols-beginner-friendly-well-explained",
                "content": "**Approah 1 :**\\nJust count the total power of 2 and 5 from n to 1  and return the minimum of it as 10 is made only by 2 and 5.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void count(int n, int &c2, int &c5){\\n        for(int i=n; i>0 && i%2==0; i/=2) c2++;\\n        for(int i=n; i>0 && i%5==0; i/=5) c5++;\\n    }\\n    \\n    int trailingZeroes(int n) {\\n        int m, c2=0, c5=0;\\n        for(int i=2; i<=n;i++){\\n            count(i,c2,c5);\\n        }\\n        return min(c2,c5);\\n    }\\n};\\n```\\n**Appraoch 2:**\\nWe don\\'t need to calculate power of 2 as we are returning min(c2,c5) and in every case 2\\'s power would be less than or equal to 5\\'s power\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void count(int n, int &c5){\\n        for(int i=n; i>0 && i%5==0; i/=5) c5++;\\n    }\\n    \\n    int trailingZeroes(int n) {\\n        int c5=0;\\n        for(int i=2; i<=n;i++){\\n            count(i, c5);\\n        }\\n        return c5;\\n    }\\n};\\n```\\n**Approach 3:**\\nBoth above approach are of type O(NlogN)... so here is the O(logN) sol. Just an another way of calculating total power of 5\\n\\nBasic Maths: Total power of a number(say a) in the range [n , n/a) is = n/a;\\nex:-\\nfor n=10;\\nthen from 10 to 2 (10/5) total power of 5 is 2 (10/5).\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int trailingZeroes(int n) {\\n        int c5=0;\\n        for(n=n/5; n>0;n/=5) c5 +=n;\\n        return c5;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void count(int n, int &c2, int &c5){\\n        for(int i=n; i>0 && i%2==0; i/=2) c2++;\\n        for(int i=n; i>0 && i%5==0; i/=5) c5++;\\n    }\\n    \\n    int trailingZeroes(int n) {\\n        int m, c2=0, c5=0;\\n        for(int i=2; i<=n;i++){\\n            count(i,c2,c5);\\n        }\\n        return min(c2,c5);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void count(int n, int &c5){\\n        for(int i=n; i>0 && i%5==0; i/=5) c5++;\\n    }\\n    \\n    int trailingZeroes(int n) {\\n        int c5=0;\\n        for(int i=2; i<=n;i++){\\n            count(i, c5);\\n        }\\n        return c5;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517279,
                "title": "one-line-solution",
                "content": "TrailingZeroes is basically counting the number of factor 10.\\n10 = 2 times 5\\nBecause n is factorial, there are definitely much more 2 than 5. So we only need to count the number of 5 in given factorial n.\\nn = 5 -> 5 * 4 * 3 * 2 * 1 count = 5/5 + 0 = 1\\nn = 10 -> 10 * 9 * 8 * 7 * 6 * 5* 4 * 3 * 2 * 1. count = 10/5 + 0 = 2\\nn = 50 count = 50/5 + trailingZeroes(10) = 10 + 2 = 12\\n50(two fives) 45 40 35 30 25(two fives) 20 15 10 5 -> 12 fives\\nn = 100 count = 100/5 + trailingZeroes(20) = 20 + 4 = 24\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        return n == 0 ? 0 : n/5 + trailingZeroes(n/5);        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        return n == 0 ? 0 : n/5 + trailingZeroes(n/5);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452895,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Factorial Trailing Zeroes.\\n\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        // Negative Number Edge Case...\\n        if (n < 0)\\n\\t\\t    return -1;\\n        // Initialize the output result i.e., the number of trailing zeroes...\\n\\t    int output = 0;\\n        // Count number of 5s in prime factors of n!\\n\\t    for (long idx = 5; n/idx >= 1; idx *= 5) {\\n\\t\\t    output += n/idx;\\n\\t    }\\n        // Return the number of trailing zeroes...\\n        return output;\\n    }\\n}\\n/**\\n**The following example helps you to understand the code...**\\nLet, n = 25\\nInitialize the output as 0...\\n\\nAfter first pass,\\n\\t\\t\\t\\tloop for idx = 5; n / idx >= 1\\n\\t\\t\\t\\t25 / 5 >= 1 or, 5 >= 1... It\\'s true...\\n\\t\\t\\t\\toutput = output + n / idx  =  0 + 25/5  =  0 + 5  =  5\\n\\t\\t\\t\\tand, idx *= 5  i.e.,  idx = 5 * 5  =  25\\n\\nAfter second pass,\\n\\t\\t\\t\\tn / idx >= 1  or,  25 / 25 >= 1  or,  1 >= 1... It\\'s true...\\n\\t\\t\\t\\toutput = output + n / idx  =  5 + 25/25  =  5 + 1  =  6\\n\\t\\t\\t\\tnow, idx *= 5  i.e.,  idx = 25 * 5  =  125\\n\\t\\t\\t\\t\\nAgain,\\n\\t\\t\\t\\tn / idx >= 1\\n\\t\\t\\t\\t28 / 125 >= 1  or,  0 >= 1... It\\'s false\\n\\t\\t\\t\\t\\n**So we return the output as 6...**\\n**/\\n```\\n\\n\\n# **C++ / C Solution:**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int output = 0;\\n        for(int idx = 5; idx <= n; idx += 5) {\\n            int x = idx;\\n            while(x > 0 && x % 5 == 0) {\\n                ++output;\\n                x /= 5;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n/**\\nTotal number of trailing zeroes will be equal to count of how many times 10 is factor of that number.\\nAnd every 10 is formed of the product of two prime numbers 2 and 5.\\nSo if we find out how many factors of 2\\u2019s are there in the number. Similarly how many factors of 5\\u2019s are there. Then we can say that each of these will combine to make product equal to 10.\\nTherefore total number of trailing zeroes will be equal to minimum( count of 2\\u2019s , count of 5\\u2019s).\\n**/\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        # Negative Number Edge Case\\n        if(n < 0):\\n            return -1\\n        # Initialize output...\\n        output = 0\\n        # Keep dividing n by 5 & update output...\\n        while(n >= 5):\\n            n //= 5\\n            output += n\\n        return output    # Return the output...\\n```\\n                \\n# **JavaScript Solution:**\\n```\\nvar trailingZeroes = function(n) {\\n    // Negative Number Edge Case...\\n    if (n < 0) return -1;\\n    // Initialize the output result i.e., the number of trailing zeroes...\\n\\tlet output = 0;\\n    // Count number of 5s in prime factors of n!\\n\\tfor (let idx = 5; n/idx >= 1; idx *= 5) {\\n\\t\\toutput += Math.floor(n/idx);\\n\\t}\\n    // Return the number of trailing zeroes...\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        // Negative Number Edge Case...\\n        if (n < 0)\\n\\t\\t    return -1;\\n        // Initialize the output result i.e., the number of trailing zeroes...\\n\\t    int output = 0;\\n        // Count number of 5s in prime factors of n!\\n\\t    for (long idx = 5; n/idx >= 1; idx *= 5) {\\n\\t\\t    output += n/idx;\\n\\t    }\\n        // Return the number of trailing zeroes...\\n        return output;\\n    }\\n}\\n/**\\n**The following example helps you to understand the code...**\\nLet, n = 25\\nInitialize the output as 0...\\n\\nAfter first pass,\\n\\t\\t\\t\\tloop for idx = 5; n / idx >= 1\\n\\t\\t\\t\\t25 / 5 >= 1 or, 5 >= 1... It\\'s true...\\n\\t\\t\\t\\toutput = output + n / idx  =  0 + 25/5  =  0 + 5  =  5\\n\\t\\t\\t\\tand, idx *= 5  i.e.,  idx = 5 * 5  =  25\\n\\nAfter second pass,\\n\\t\\t\\t\\tn / idx >= 1  or,  25 / 25 >= 1  or,  1 >= 1... It\\'s true...\\n\\t\\t\\t\\toutput = output + n / idx  =  5 + 25/25  =  5 + 1  =  6\\n\\t\\t\\t\\tnow, idx *= 5  i.e.,  idx = 25 * 5  =  125\\n\\t\\t\\t\\t\\nAgain,\\n\\t\\t\\t\\tn / idx >= 1\\n\\t\\t\\t\\t28 / 125 >= 1  or,  0 >= 1... It\\'s false\\n\\t\\t\\t\\t\\n**So we return the output as 6...**\\n**/\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int output = 0;\\n        for(int idx = 5; idx <= n; idx += 5) {\\n            int x = idx;\\n            while(x > 0 && x % 5 == 0) {\\n                ++output;\\n                x /= 5;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n/**\\nTotal number of trailing zeroes will be equal to count of how many times 10 is factor of that number.\\nAnd every 10 is formed of the product of two prime numbers 2 and 5.\\nSo if we find out how many factors of 2\\u2019s are there in the number. Similarly how many factors of 5\\u2019s are there. Then we can say that each of these will combine to make product equal to 10.\\nTherefore total number of trailing zeroes will be equal to minimum( count of 2\\u2019s , count of 5\\u2019s).\\n**/\\n```\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        # Negative Number Edge Case\\n        if(n < 0):\\n            return -1\\n        # Initialize output...\\n        output = 0\\n        # Keep dividing n by 5 & update output...\\n        while(n >= 5):\\n            n //= 5\\n            output += n\\n        return output    # Return the output...\\n```\n```\\nvar trailingZeroes = function(n) {\\n    // Negative Number Edge Case...\\n    if (n < 0) return -1;\\n    // Initialize the output result i.e., the number of trailing zeroes...\\n\\tlet output = 0;\\n    // Count number of 5s in prime factors of n!\\n\\tfor (let idx = 5; n/idx >= 1; idx *= 5) {\\n\\t\\toutput += Math.floor(n/idx);\\n\\t}\\n    // Return the number of trailing zeroes...\\n    return output;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746127,
                "title": "c-single-line-solution",
                "content": "If a number has zero as trailing then it means it means there is atleast one 5* 2 or generally its primefactorisation contains 2^n* 3^m* 5^p * 7^q.....\\n\\nFor a number to contain trailing zeros it has to be 2^n * 5^m where the deciding power will be of 5 (for a given range number multiples of 2 (i.e, even) is greater than 5 multiples) so we need to find the number of 5 multiples less than given number.\\n\\nA simple observation is that no of 5 in prime factorisation of the n! would give no of zero in it.\\n\\nA simple observation would give us :\\nIf a number **x** less than or equal to **n** is a power of 5 then we need to account for their extra **5** it brings.\\n\\n(Here i have taken till 3125 since given **n** range is 1 <= **n** <= 10^4\\n\\n\\n```\\nint trailingZeroes(int n) {\\n        if(n<=4)return 0;\\n        \\n        int temp=n/5+ n/25 + n/125 +n/625 +n/3125;\\n        return temp;\\n\\n    }\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nint trailingZeroes(int n) {\\n        if(n<=4)return 0;\\n        \\n        int temp=n/5+ n/25 + n/125 +n/625 +n/3125;\\n        return temp;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 913696,
                "title": "python-divide-by-powers-of-5-98-faster",
                "content": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        count = 0\\n        i = 5\\n        while n//i >= 1:\\n            count += n//i\\n            i *=5\\n        return int(count)  \\n```\\n**LOGIC**\\nTrailing 0s in n! = Count of 5s in prime factors of n!\\n                  = floor(n/5) + floor(n/25) + floor(n/125) + ....\\n\\t\\t\\t\\t  \\n**If it helped please upvote**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        count = 0\\n        i = 5\\n        while n//i >= 1:\\n            count += n//i\\n            i *=5\\n        return int(count)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 852183,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public int trailingZeroes(int n) {\\n        return n>=5 ? n/5 + trailingZeroes(n/5): 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int trailingZeroes(int n) {\\n        return n>=5 ? n/5 + trailingZeroes(n/5): 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 534764,
                "title": "python-3-iterative-solution-beats-97-31-with-explanation",
                "content": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n\\t# iteration -- since all zeros come from 2*5, so we count how many 2 and 5 in given n. since we have enough 2, so we only need to count how many 5 we have in n.\\n        res = 0\\n        while n > 0:\\n            n //= 5\\n            res += n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n\\t# iteration -- since all zeros come from 2*5, so we count how many 2 and 5 in given n. since we have enough 2, so we only need to count how many 5 we have in n.\\n        res = 0\\n        while n > 0:\\n            n //= 5\\n            res += n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187696,
                "title": "60ms-beats-96-of-javascript-submissions",
                "content": "Find the number of trailing zeros in 500!.\n\nThe number of multiples of 5 that are less than or equal to 500 is  500/5=100\nThen, the number of multiples of 25 is  500/25=20\nThen, the number of multiples of 125 is  500/125=4\nThe next power of 5 is 625, which is greater than 500\nTherefore, the number of trailing zeros of  is  = 100+20+4=124\n refer this link https://brilliant.org/wiki/trailing-number-of-zeros/ for more\n\n```\nvar trailingZeroes = function(n) {\n    let count=0,x=5\n    while(x<=n){\n        count += Math.floor(n/x)\n        x*=5\n    }\n    return count\n\n};\n```",
                "solutionTags": [],
                "code": "```\nvar trailingZeroes = function(n) {\n    let count=0,x=5\n    while(x<=n){\n        count += Math.floor(n/x)\n        x*=5\n    }\n    return count\n\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52443,
                "title": "c-concise-solution",
                "content": "    int trailingZeroes(int n) {\\n        // 5 is always less than 2, so, one 5, one trailing 0\\n        int sum = 0;\\n        while (n > 0) {\\n            n /= 5;\\n            sum += n;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int trailingZeroes(int n) {\\n        // 5 is always less than 2, so, one 5, one trailing 0\\n        int sum = 0;\\n        while (n > 0) {\\n            n /= 5;\\n            sum += n;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52498,
                "title": "my-simplest-method-by-python-only-5-lines",
                "content": "def trailingZeroes(self,n):\\n\\t\\tret = 0\\n\\t\\twhile n/5:\\n\\t\\t\\tret+=n/5\\n\\t\\t\\tn/=5\\n\\t\\treturn ret",
                "solutionTags": [],
                "code": "def trailingZeroes(self,n):\\n\\t\\tret = 0\\n\\t\\twhile n/5:\\n\\t\\t\\tret+=n/5\\n\\t\\t\\tn/=5\\n\\t\\treturn ret",
                "codeTag": "Python3"
            },
            {
                "id": 52512,
                "title": "two-solutions-c-code-with-explanation-and-extension",
                "content": "We know that one pair of 2*5 makes one zero. \\n\\nThus the problem can be converted to \"In decomposition of prime factors of n! (n! = 2^x * 3^y * 5^z * ...), figure out the min(x, z).\" \\n\\nObviously that x > z. Then the problem is to find z (power time of 5). \\n\\nSolution 1: Accumulate multiplier 5 one-by-one from 1 to n\\n\\n    class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int ret = 0;\\n            for(int i = 1; i <= n; i ++)\\n            {\\n                int tmp = i;\\n                while(tmp%5 == 0)\\n                {\\n                    ret ++;\\n                    tmp /= 5;\\n                }\\n            }\\n            return ret;\\n        }\\n    };\\n\\nIn previous analysis, we can see the numbers contributes to 5 are those dividible by 5. (mod 5 == 0)\\n\\nThere is a mathematical law that [n/k] equals to how many numbers from 1~n that are divisible by k.\\nIn this case, z = [n/5] + [n/5^2] + ... \\n\\nSolution 2: \\n\\n    class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int ret = 0;\\n            while(n)\\n            {\\n                ret += n/5;\\n                n /= 5;\\n            }\\n            return ret;\\n        }\\n    };\\n\\n\\nThe problem can be further extended to \"In binary representation of n!, locate the rightmost 1\". \\n\\nIn this case, since each 2 contributes one zero in the binary representation, the problem is to find x (power time of 2). \\n\\nx = [n/2] + [n/2^2] + ...",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int ret = 0;\\n            for(int i = 1; i <= n; i ++)\\n            {\\n                int tmp = i;\\n                while(tmp%5 == 0)\\n                {\\n                    ret ++;\\n                    tmp /= 5;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3765226,
                "title": "python-simplest-solution",
                "content": "\\n\\n\\n\\n# Time complexity:\\nThe time complexity of this approach is O(log n) because the while loop runs until \\'5^a\\' is less than or equal to \\'n\\'. As we multiply \\'b\\' by 5 in each iteration, the loop will run approximately log base 5 of \\'n\\' times.\\n\\n# Space complexity:\\nThe space complexity of this approach is O(1) because we are using only a constant amount of space to store the variables \\'a\\', \\'b\\', and \\'c\\'.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        a=1\\n        b=5\\n        c=0\\n        while (5**a)<=n:\\n            c+=n//b\\n            a+=1\\n            b=b*5\\n        return c\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        a=1\\n        b=5\\n        c=0\\n        while (5**a)<=n:\\n            c+=n//b\\n            a+=1\\n            b=b*5\\n        return c\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483592,
                "title": "beats-100-java-easy-solution-beginner-friendly-easy-to-understand-formula-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the program is based on the observation that trailing zeros in a factorial come from the product of the factors 2 and 5. Since the number of factors of 2 is always greater than the number of factors of 5 in any given number, counting the number of factors of 5 is enough to calculate the number of trailing zeros in a factorial. Therefore, the program counts the number of factors of 5 in n and its powers to calculate the number of trailing zeros in n!.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe program uses a while loop to iterate over n and its powers of 5. In each iteration, the program adds the number of factors of 5 in the current value of n to a counter c. The program then divides n by 5 to get the next smaller value to check. This process continues until n is less than 5.\\n\\n# Complexity\\nThe time complexity of this program is O(log n), as the loop iterates log_5(n) times, with each iteration taking constant time. The space complexity of the program is O(1), as it only requires a constant amount of extra space to store the counter c.\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n       int c=0;\\n       while(n>4){\\n           c+=(n/5);\\n           n/=5;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n       int c=0;\\n       while(n>4){\\n           c+=(n/5);\\n           n/=5;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618225,
                "title": "python-java-c-c-one-liner-o-logn-explained-in-detail",
                "content": "* The problem is how many 10 in the factorial factors. Because  the number of 2 is more than the number of 5, so the key is how many 5 in the factorial factors.\\n* n // 5 is how many numbers contain a factor of 5, but note 25 = 5 * 5 can provide two 5 and 125 =  5 * 5 * 5 can probide three 5 and so on. We need to count the total number of 5 in the factorial factors.\\n* for n <= 10000, the result is n // 5 + n // 25 + n // 125 + n // 625 + n // 3125\\n* we need to add log(n, 5) times, so the time complexity is O(logN)\\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        return n // 5 + n // 25 + n // 125 + n // 625 + n // 3125\\n```\\nan alternative codeing style\\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        return sum([n // 5 ** i for i in range(1, 6)])\\n```\\n**Java solution**\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        return n / 5 + n / 25 + n / 125 + n / 625 + n / 3125;\\n    }\\n}\\n```\\n**C solution**\\n```\\nint trailingZeroes(int n){\\n    return n / 5 + n / 25 + n / 125 + n / 625 + n / 3125;\\n}\\n```\\n**C++ solution**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n / 5 + n / 25 + n / 125 + n / 625 + n / 3125;\\n    }\\n};\\n```\\n\\n**Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        return n // 5 + n // 25 + n // 125 + n // 625 + n // 3125\\n```\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        return sum([n // 5 ** i for i in range(1, 6)])\\n```\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        return n / 5 + n / 25 + n / 125 + n / 625 + n / 3125;\\n    }\\n}\\n```\n```\\nint trailingZeroes(int n){\\n    return n / 5 + n / 25 + n / 125 + n / 625 + n / 3125;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n / 5 + n / 25 + n / 125 + n / 625 + n / 3125;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203100,
                "title": "java-in-depth-explanation-with-complete-thought-process-two-solutions",
                "content": "```\\n/*\\n    Q : It looks horrible that how we can store n! (if 0 <= n <= 10000).\\n        there is no such data that can store such a big big number.\\n        \\n    Q: Is that we need to calculate actual value of n!.\\n    A: Well, absolutely not. If anyhow we can store/calculate n! that \\n       would be too costly. It takes much more computation time.\\n       \\n    To solve this problem the sequence of following questions should\\n    come to our mind.\\n    \\n    Q:1 If we want trailing zeroes in n! then what are the digits/numbers\\n        are responsible to produce zeroes?\\n        \\n    A:1 If you observe carefully by writing few testcases you will find\\n        that only digit 2 & 5 are appropriate candidates to produce\\n        zeroes in n!.\\n        \\n    Q:2 How do we find how many 2\\'s and 5\\'s are there in n!. If calculating\\n        n! is too costly{assuming not possible to calculate}?\\n    A:2 Well, don\\'t need to calculate n! to counts of 2 and 5.\\n        We can can represent all the numbers(1x2x3x4...n) to its prime\\n        factorization, from there we can find how many 2\\'s and 5\\'s\\n        are exists in n!.\\n        \\n        For example:\\n        -----------\\n            n -> 10\\n            then how many 2\\'s and 5\\'s are there in 10!\\n            \\n            1x2x3x4x5x6x7x8x9x10\\n            \\n            Writing individual numbers in n! to its prime factorization\\n            \\n            1x2x3x(2x2)x5x(2x3)x7x(2x2x2)x(3x3)x(2x5)\\n            \\n            1x2^8x3^4x5^2x7\\n            \\n            so, we\\'ve 8(2\\'s) and 2(5\\'s).\\n            \\n            Number of trailing zeroes in n! is equal to:\\n            \\n            min(maximum_power_of_2, maximum_power_of_5)\\n            \\n            min(8, 2) -> 2\\n            \\n            There are two trailing zeroes at the end of 10!(3628800).\\n            \\n    Observation#1 If we observe carefully, maximum power of 2 in n! is always\\n                  greater than maximum power of 5.\\n                  \\n                  So therefore, number of trailing zeroes is always equal\\n                  to maximum power of 5 in prime factorization of n!.\\n                  \\n                  \\n    Observation#2 Maximum power of 5 in n! is always equal to\\n                  number of total multiples of 5 in [1x2x3x4x5x6x7x8x9x10]\\n                  \\n                  total multiples of 5 in [1-10] : equivalent to maximum power of 5 in n!\\n                  \\n                  for 10! -> we can see that there is only 2 multiples(5 & 10)\\n                  of 5 in between [1-10]\\n                  \\n                  But in case if numbers are power of 5 like, 25, 125, 625.. etc.\\n                  \\n                  we\\'ve to consider like\\n                               : 25/5 + 5/5 -> 6\\n                               : 125/5 + 25/5 + 5/5 -> 31 \\n                               : 625/5 + 125/5 + 25/5 + 5/5 -> 156\\n                               \\n                  Because when we divide n with 5 -> we missed some power of 5\\'s in n!.\\n                  \\n    Q:3 How do we know that how many multiples 5(any number) is there in [1-n]?\\n    A:3 n/5\\n*/\\n\\nclass Solution {\\n    public int trailingZeroes_(int n) {\\n        int cnt = 0;\\n        while(n / 5 > 0) {\\n            cnt += n / 5;\\n            n /= 5;\\n        }\\n        return cnt;\\n    }\\n    \\n    public int trailingZeroes(int n) {\\n        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Q : It looks horrible that how we can store n! (if 0 <= n <= 10000).\\n        there is no such data that can store such a big big number.\\n        \\n    Q: Is that we need to calculate actual value of n!.\\n    A: Well, absolutely not. If anyhow we can store/calculate n! that \\n       would be too costly. It takes much more computation time.\\n       \\n    To solve this problem the sequence of following questions should\\n    come to our mind.\\n    \\n    Q:1 If we want trailing zeroes in n! then what are the digits/numbers\\n        are responsible to produce zeroes?\\n        \\n    A:1 If you observe carefully by writing few testcases you will find\\n        that only digit 2 & 5 are appropriate candidates to produce\\n        zeroes in n!.\\n        \\n    Q:2 How do we find how many 2\\'s and 5\\'s are there in n!. If calculating\\n        n! is too costly{assuming not possible to calculate}?\\n    A:2 Well, don\\'t need to calculate n! to counts of 2 and 5.\\n        We can can represent all the numbers(1x2x3x4...n) to its prime\\n        factorization, from there we can find how many 2\\'s and 5\\'s\\n        are exists in n!.\\n        \\n        For example:\\n        -----------\\n            n -> 10\\n            then how many 2\\'s and 5\\'s are there in 10!\\n            \\n            1x2x3x4x5x6x7x8x9x10\\n            \\n            Writing individual numbers in n! to its prime factorization\\n            \\n            1x2x3x(2x2)x5x(2x3)x7x(2x2x2)x(3x3)x(2x5)\\n            \\n            1x2^8x3^4x5^2x7\\n            \\n            so, we\\'ve 8(2\\'s) and 2(5\\'s).\\n            \\n            Number of trailing zeroes in n! is equal to:\\n            \\n            min(maximum_power_of_2, maximum_power_of_5)\\n            \\n            min(8, 2) -> 2\\n            \\n            There are two trailing zeroes at the end of 10!(3628800).\\n            \\n    Observation#1 If we observe carefully, maximum power of 2 in n! is always\\n                  greater than maximum power of 5.\\n                  \\n                  So therefore, number of trailing zeroes is always equal\\n                  to maximum power of 5 in prime factorization of n!.\\n                  \\n                  \\n    Observation#2 Maximum power of 5 in n! is always equal to\\n                  number of total multiples of 5 in [1x2x3x4x5x6x7x8x9x10]\\n                  \\n                  total multiples of 5 in [1-10] : equivalent to maximum power of 5 in n!\\n                  \\n                  for 10! -> we can see that there is only 2 multiples(5 & 10)\\n                  of 5 in between [1-10]\\n                  \\n                  But in case if numbers are power of 5 like, 25, 125, 625.. etc.\\n                  \\n                  we\\'ve to consider like\\n                               : 25/5 + 5/5 -> 6\\n                               : 125/5 + 25/5 + 5/5 -> 31 \\n                               : 625/5 + 125/5 + 25/5 + 5/5 -> 156\\n                               \\n                  Because when we divide n with 5 -> we missed some power of 5\\'s in n!.\\n                  \\n    Q:3 How do we know that how many multiples 5(any number) is there in [1-n]?\\n    A:3 n/5\\n*/\\n\\nclass Solution {\\n    public int trailingZeroes_(int n) {\\n        int cnt = 0;\\n        while(n / 5 > 0) {\\n            cnt += n / 5;\\n            n /= 5;\\n        }\\n        return cnt;\\n    }\\n    \\n    public int trailingZeroes(int n) {\\n        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863663,
                "title": "0-ms-java-solution",
                "content": "**Approach:\\nfor counting the number of trailing zeroes\\n1.example if there is a number 1200 -this will be made of product of 12,10,10\\n **   so it consist of 2s 10 as these ten are contributing  and making two zeroes in the answer**\\n**2. so our main aim is to count number of times 10 occur in the system\\n3.for 10 to occcur -we need to count the factor of 10 which are 2 and 5\\n4.as in any number Occurences of 2 >Occurences of 5\\n5.so it is better to count   occurences of 5\\n6. for counting the occurence  of 5:**\\n  \\n**\\n**** eg Trailing 0s in n! = Count of 5s in prime factors of n!\\n                  **= floor(n/5) + floor(n/25) + floor(n/125) + ....**\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n    int ans=0;\\n       int p=5;  //5^1=5\\n        while((n/p)>0)\\n        {\\n            ans+=n/p; \\n            p=p*5; //increasing the power by 5\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\\n**please upvote the solution if you like it**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n    int ans=0;\\n       int p=5;  //5^1=5\\n        while((n/p)>0)\\n        {\\n            ans+=n/p; \\n            p=p*5; //increasing the power by 5\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448166,
                "title": "python-js-go-c-solution-with-o-log-n-w-hint",
                "content": "Hint:\\n\\n----\\n\\nn! = n x n-1 x n-2 ... x 1\\nThat means trailing zero is contributed by the number of (5, 2) pair in prime factor decomposition of n!\\n\\nWith the value growing on n, n can be re-written as n = **5**^**k** x **2**^**q** x  (other prime factors ...).\\n\\nThe **key-point** is the **k**, the exponent of 5, because k \\u2266 q always for every possible n! with trailing zero.\\n\\nObservation:\\n\\n5! = 5 x 4 x 3 x 2 x 1 = 5^1 x 2^1 x ( 4 x 3 ) = 5^**1** x 2^3 x other prime factors= 12**0**\\n\\n10! = 10 x 9 x ... 5 x ...x 2 x 1 = 5^**2** x 2^8 x other prime factors = 36288**00**\\n\\n15! = 15 x 14 x ... x 2 x1 = 5^**3** x 2^11 x other prime factors = 1307674368**000**\\n\\n---\\n\\nMethod_#1: Iterative implementation\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        exponent_of_5 = 0\\n        \\n        while n > 4 :\\n            \\n            quotient = n // 5\\n            \\n            exponent_of_5, n =  exponent_of_5+quotient, quotient\\n        \\n        return exponent_of_5\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar trailingZeroes = function(n) {\\n    \\n    let exp_of_5 = 0;\\n    \\n    while( n > 4 ){\\n        \\n        let quotient = Math.floor(n / 5);\\n        \\n        exp_of_5 = exp_of_5 + quotient;\\n        n = quotient;\\n    }\\n    \\n    return exp_of_5;\\n};\\n```\\n\\n---\\n\\nGo\\n\\n```\\nfunc trailingZeroes(n int) int {\\n    \\n    exp_of_5 := 0\\n    \\n    for n > 4 {\\n        \\n        quotient := n / 5\\n        \\n        exp_of_5 = exp_of_5 + quotient\\n        n = quotient\\n        \\n    }\\n    \\n    return exp_of_5\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        \\n        int exp_of_5 = 0;\\n        \\n        while( n > 4 ){\\n            \\n            int quotient = n / 5;\\n            exp_of_5 = exp_of_5 + quotient;\\n            n = quotient;\\n        }\\n        \\n        return exp_of_5;\\n    }\\n};\\n```\\n\\n---\\n\\nMethod_#2: Recursive implementation\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        if n == 0:\\n            # Base case\\n            return 0\\n        \\n        else:\\n            # Inductive step\\n            return ( n//5 + self.trailingZeroes(n//5) )\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar trailingZeroes = function(n) {\\n    \\n    if( n == 0 ){\\n        // base case\\n        return 0;\\n    }\\n    \\n    // General cases\\n    let quotient = Math.floor( n / 5 );\\n    return ( quotient + trailingZeroes(quotient) );\\n    \\n}\\n```\\n\\n---\\n\\nGo\\n\\n```\\nfunc trailingZeroes(n int) int {\\n    \\n    // Base case\\n    if( n == 0 ){\\n        \\n        return 0\\n    }\\n    \\n    \\n    // General cases\\n    \\n    quotient := n / 5\\n    \\n    return quotient + trailingZeroes( quotient )\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        \\n        // Base case:\\n        if( n == 0){\\n            return 0;\\n        }\\n        \\n        // General case\\n        int quotient = n / 5;\\n        return quotient + trailingZeroes( quotient );\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Math",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        exponent_of_5 = 0\\n        \\n        while n > 4 :\\n            \\n            quotient = n // 5\\n            \\n            exponent_of_5, n =  exponent_of_5+quotient, quotient\\n        \\n        return exponent_of_5\\n```\n```\\nvar trailingZeroes = function(n) {\\n    \\n    let exp_of_5 = 0;\\n    \\n    while( n > 4 ){\\n        \\n        let quotient = Math.floor(n / 5);\\n        \\n        exp_of_5 = exp_of_5 + quotient;\\n        n = quotient;\\n    }\\n    \\n    return exp_of_5;\\n};\\n```\n```\\nfunc trailingZeroes(n int) int {\\n    \\n    exp_of_5 := 0\\n    \\n    for n > 4 {\\n        \\n        quotient := n / 5\\n        \\n        exp_of_5 = exp_of_5 + quotient\\n        n = quotient\\n        \\n    }\\n    \\n    return exp_of_5\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        \\n        int exp_of_5 = 0;\\n        \\n        while( n > 4 ){\\n            \\n            int quotient = n / 5;\\n            exp_of_5 = exp_of_5 + quotient;\\n            n = quotient;\\n        }\\n        \\n        return exp_of_5;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        if n == 0:\\n            # Base case\\n            return 0\\n        \\n        else:\\n            # Inductive step\\n            return ( n//5 + self.trailingZeroes(n//5) )\\n```\n```\\nvar trailingZeroes = function(n) {\\n    \\n    if( n == 0 ){\\n        // base case\\n        return 0;\\n    }\\n    \\n    // General cases\\n    let quotient = Math.floor( n / 5 );\\n    return ( quotient + trailingZeroes(quotient) );\\n    \\n}\\n```\n```\\nfunc trailingZeroes(n int) int {\\n    \\n    // Base case\\n    if( n == 0 ){\\n        \\n        return 0\\n    }\\n    \\n    \\n    // General cases\\n    \\n    quotient := n / 5\\n    \\n    return quotient + trailingZeroes( quotient )\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        \\n        // Base case:\\n        if( n == 0){\\n            return 0;\\n        }\\n        \\n        // General case\\n        int quotient = n / 5;\\n        return quotient + trailingZeroes( quotient );\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428776,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. The # of trailing 0 eqauls to how many 5s we see if we break up the factorial\\n2. For example 5! = 1* 2 * 3 * (2 * 2) * 5 , we found one 5, so there is 1 zero.\\n3. Why 5? because only a pair of 2 * 5 can create 0, and since there are way more 2s than 5s, it\\'s more efficient to count 5s\\n4. Why recursion? To break up big numbers that were created by different 5s, such as 25 = 5 * 5.\\n```\\nvar trailingZeroes = function(n) {\\n    if (n<5) return 0;\\n    return Math.floor(n/5) + trailingZeroes(n/5);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar trailingZeroes = function(n) {\\n    if (n<5) return 0;\\n    return Math.floor(n/5) + trailingZeroes(n/5);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375272,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**  \\nTrailing zero is formed by multiplying 2\\'s multiple and 5\\'s multiple. By nature, # of 2\\'s multiple (2, 4, 6, ... `2-steps-jump`) are lot more than # of 5\\'s (5, 10, 15..`5-steps-jump`). So # of 5\\'s multiple should decide the trailing zeros which is `n/5`. But note that numbers like `25, 125..` are special as they have more than one 5\\'s in them and each 5 can contribute to one trailing zero with some 2\\'s multiple. Again, do not worry about running out of 2\\'s multiples for `25 or 125 etc` as they are far more abundantly available.\\n\\n```\\npublic int trailingZeroes(int n) {\\n        int count = 0;\\n        while(n > 0){\\n            count += n/5;\\n            n /= 5;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int trailingZeroes(int n) {\\n        int count = 0;\\n        while(n > 0){\\n            count += n/5;\\n            n /= 5;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 368620,
                "title": "c-0ms-elegant-solution-explained-using-no-extra-variable-beats-100-100",
                "content": "Thinking process:\\n1. tailling zeors means factor of 10 in the factorial\\n2. any occurance of the factor 5 must has another 2 as a factor in any factorial\\n3. thus, finding tailling zeros means `finding the number of factor of 5` for `the factorial of n`\\n4. we can do so by dividing `n` to get the additional number of factor of 5s\\n\\nThe last step is a little hard to explain even with an example, but I\\'ll try:\\n\\nFor instance, `25!` have factors of 5, 10, 15, 20, and 25 that we are interested in. 5, 10, 15, 20 all have only `1` factor of 5 in each of them while 25 have `2` of factor 5. We have 4 trailling zeros from `20!` to `24!`, and `25` brought 2 of 5s into`25!` making it has 6 of 5s. Thus, `25!` has 6 trailling zeros. \\n\\nWe can see that for every `n` seperated by 5, we have one more factor of 5 involved, so we should divide `n` to get the number of additional factors of 5.\\n\\nTrying out a few more examples might help you understand the transition from step 3 to step 4.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int res(0);\\n        while (n) {\\n            res += n /= 5;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int res(0);\\n        while (n) {\\n            res += n /= 5;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52455,
                "title": "0ms-6-line-solution-in-c-java",
                "content": "    int count = 0; \\n    while (n > 1) {\\n      count += n / 5;\\n      n = n / 5; \\n    }\\n    return count;",
                "solutionTags": [
                    "Java"
                ],
                "code": "    int count = 0; \\n    while (n > 1) {\\n      count += n / 5;\\n      n = n / 5; \\n    }\\n    return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 52466,
                "title": "java-simple-solution-5-line",
                "content": "Because the trailing zeros is only related to the number of 5 in n!, we can calculate this by the code below:\\n\\n    \\tpublic int trailingZeroes(int n) {\\n\\t\\tint rs = 0;\\n\\t\\twhile (n != 0) {\\n\\t\\t\\trs += (n / 5);\\n\\t\\t\\tn /= 5;\\n\\t\\t}\\n\\t\\treturn rs;\\n\\t}",
                "solutionTags": [],
                "code": "Because the trailing zeros is only related to the number of 5 in n!, we can calculate this by the code below:\\n\\n    \\tpublic int trailingZeroes(int n) {\\n\\t\\tint rs = 0;\\n\\t\\twhile (n != 0) {\\n\\t\\t\\trs += (n / 5);\\n\\t\\t\\tn /= 5;\\n\\t\\t}\\n\\t\\treturn rs;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 52501,
                "title": "accepted-python-submission-with-log5-n-time-complexity",
                "content": "5 multiply an even number will contribute one tailing zero. The factorial list never short of even number. Basically, how many '5' within the list determines the number of tailing zero. The code bellow count how many 5 in the list from 1 to n.\\n\\n       class Solution:\\n        # @return an integer\\n        def trailingZeroes(self, n):\\n            res=0\\n            while n>0:\\n                n=int(n/5) \\n                res+=n \\n            return res",
                "solutionTags": [],
                "code": "5 multiply an even number will contribute one tailing zero. The factorial list never short of even number. Basically, how many '5' within the list determines the number of tailing zero. The code bellow count how many 5 in the list from 1 to n.\\n\\n       class Solution:\\n        # @return an integer\\n        def trailingZeroes(self, n):\\n            res=0\\n            while n>0:\\n                n=int(n/5) \\n                res+=n \\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 3796013,
                "title": "java-2-easy-solutions-explained",
                "content": "**This question is pretty straightforward.\\nBecause all trailing 0 is from factors `5 * 2`.**\\n\\n# Complexity\\n- Time complexity: O(logn) to the base 5\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n      int count = 0;\\n      while(n > 0) {\\n          n /= 5;\\n          count += n;\\n      }  \\n      return count;\\n    }\\n}\\n```\\n**THE ONE LINER SOLUTION USING RECURSION**\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n    }\\n}\\n```\\n*Time complexity is same but recurion takes an extra `O(n)` space in the memory which is why the iterative approach is better*\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n      int count = 0;\\n      while(n > 0) {\\n          n /= 5;\\n          count += n;\\n      }  \\n      return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631514,
                "title": "java-easiest-solution-beginners-understandable-100-beats-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe trailingZeroes function takes an integer n as input and calculates the number of trailing zeros(ie zeros at the end of the factorial answer) in the factorial of n.\\n\\n# Approach\\nLet\\'s consider an example: n = 25.\\n\\nInitially, count = 0 and n = 25.\\n\\n1st iteration:\\n\\nDivide n by 5: n = 25 / 5 = 5\\nAdd n (5) to count: count = 0 + 5 = 5\\n\\n2nd iteration:\\n\\nDivide n by 5: n = 5 / 5 = 1\\nAdd n (1) to count: count = 5 + 1 = 6\\nThe loop ends because n becomes less than 5.\\n\\nThe final result is count = 6, indicating that the factorial of 25 has 6 trailing zeros.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n>0){\\n            n/=5;\\n            count+=n;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# **Guys please upvote my solution if you feel it worthy!!**",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n>0){\\n            n/=5;\\n            count+=n;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341834,
                "title": "easy-java-solution-t-c-logn",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        for(int i=5;i<=n;i*=5){\\n             count+=(n/i);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        for(int i=5;i<=n;i*=5){\\n             count+=(n/i);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308083,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n)\\n     {\\n        int res=0;\\n        while(n)\\n        {\\n            n/=5;\\n            res+=n;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n)\\n     {\\n        int res=0;\\n        while(n)\\n        {\\n            n/=5;\\n            res+=n;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224095,
                "title": "beats-100-c-soluton-with-explanation",
                "content": "# Intuitio\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.Approach/method\\n![no_of_zero.jpeg](https://assets.leetcode.com/users/images/10a29712-6e37-459c-8e89-b169652d79ca_1677217055.8167605.jpeg)\\n\\n2.Approach/method\\n1.In second approach we simply divide the n! number by 5\\n2.After that For every 5*5.....(or 5^m,m=2,3,4....)(less n) multiple we get extra zero of n!/5^m..\\n3.Add the both zero(step1+step2)\\n\\nexample \\n1.25!\\nnumber of zero=25/5 + 25/25\\n               5+1=6\\n2.50!\\nnumber of zero=50/5 + 50/25\\n               10 + 2= 12\\n4.150!\\nnumber of zero=  150/5 + 150/25 + 150/125 (125 is less then 150  and 5^3=125(5^m))  \\n           30+6+1=37\\n\\n5.1000!\\n1000/5 + 1000/25(5^2) + 1000/125(5^3) +1000/625(5^4)\\n200+40+8+1=249\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//1st method\\n\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        while(n>=5)\\n        {\\n         int quotient=n/5;\\n         n=quotient;\\n         count_zero=count_zero + quotient;\\n        }\\n     return count_zero;\\n    }\\n};\\n\\n//2nd methods\\n//1.In second approach we simply divide the n! number by 5\\n//2.For every 5^m... multiple we get extra zero of n!/5^m..(m=2,3,4...)\\n//3.Add the both zero(step1+step2)\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        int i = 5;\\n        while(i <= n) {\\n            count_zero += n / i;\\n            i =i*5;\\n        }\\n    return count_zero;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//1st method\\n\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        while(n>=5)\\n        {\\n         int quotient=n/5;\\n         n=quotient;\\n         count_zero=count_zero + quotient;\\n        }\\n     return count_zero;\\n    }\\n};\\n\\n//2nd methods\\n//1.In second approach we simply divide the n! number by 5\\n//2.For every 5^m... multiple we get extra zero of n!/5^m..(m=2,3,4...)\\n//3.Add the both zero(step1+step2)\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        int i = 5;\\n        while(i <= n) {\\n            count_zero += n / i;\\n            i =i*5;\\n        }\\n    return count_zero;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130161,
                "title": "explained-simple-code-in-java-mathematics",
                "content": "# Approach\\nThe logic is used to calculate the number of trailing zeros in the factorial of a number. In mathematics, a factorial is the product of all positive integers less than or equal to n. For example, the factorial of 5 is 5! = 5 x 4 x 3 x 2 x 1 = 120, and it contains one trailing zero, since 10 is a product of 2 and 5. By dividing n by 5, you are counting the number of multiples of 5 in the range from 1 to n. However, you need to also consider the multiples of 25 (which are also multiples of 5), so you divide n by 25 to count the number of multiples of 25. Finally, you add the results of both divisions to get the total number of trailing zeros in n!.\\n\\n# Time and Space Complexity\\n\\nThe time complexity of this code is O(log n), as the for loop performs logarithmic operations with respect to the value of n. Each iteration multiplies i by 5, reducing the number of operations performed in each subsequent iteration.\\n\\nThe space complexity of this code is O(1), as it only uses a few variables, regardless of the input size. The memory usage remains constant, regardless of the value of n.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int res = 0;\\n        for(int i=5;i<=n;i=5*i){\\n            res = res + (n/i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int res = 0;\\n        for(int i=5;i<=n;i=5*i){\\n            res = res + (n/i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019048,
                "title": "easiest-soln-goldman-sachs-well-explained",
                "content": "## If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n**ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ3. Factorial with Trailing Zeroes.**\\n\\n![3.trailing-zero1.jpg](https://assets.leetcode.com/users/images/45e4aa6b-379f-452c-bd1e-569340c75541_1673178151.6843765.jpeg)\\n![3.trialing-zeros2.jpg](https://assets.leetcode.com/users/images/72b66ceb-9feb-424e-b04a-e4aedcdc7333_1673178163.6625884.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to find the number of trailing zeros in the factorial of a given number n\\n    int trailingZeroes(int n) {\\n        // Initialize a variable to store the number of trailing zeros\\n        int num_zeros = 0;\\n\\n        // Iterate over the multiples of 5 from 5 to n\\n        for (int i = 5; i <= n; i += 5) {\\n            // Initialize a variable to store the current multiple of 5\\n            int num = i;\\n\\n            // Divide num by 5 and add the quotient to num_zeros until num is no longer divisible by 5\\n            while (num % 5 == 0) {\\n                num /= 5;\\n                num_zeros++;\\n            }\\n        }\\n\\n        // Return the number of trailing zeros\\n        return num_zeros;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to find the number of trailing zeros in the factorial of a given number n\\n    int trailingZeroes(int n) {\\n        // Initialize a variable to store the number of trailing zeros\\n        int num_zeros = 0;\\n\\n        // Iterate over the multiples of 5 from 5 to n\\n        for (int i = 5; i <= n; i += 5) {\\n            // Initialize a variable to store the current multiple of 5\\n            int num = i;\\n\\n            // Divide num by 5 and add the quotient to num_zeros until num is no longer divisible by 5\\n            while (num % 5 == 0) {\\n                num /= 5;\\n                num_zeros++;\\n            }\\n        }\\n\\n        // Return the number of trailing zeros\\n        return num_zeros;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846894,
                "title": "c-sol-with-100-faster",
                "content": "class Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int sum = 0, q = 0;\\n        while(n!=0){\\n        q= n/5;\\n        sum += q;\\n        n = n/5;\\n    }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int sum = 0, q = 0;\\n        while(n!=0){\\n        q= n/5;\\n        sum += q;\\n        n = n/5;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1547673,
                "title": "easy-java-solution-with-full-explaination-formula-too-with-diagram",
                "content": "Here let just change the Question instead and find out the no divisible by 15,\\nSo 15 is Comprising 2 prime factors 3 and 5.\\nLet supoose we have 10 here and try to find its Trying to ** Find How many times 15 is repeated**\\nso 10!=10* 9* 8* 7* 6* 5* 4* 3* 2* 1\\n    so here we\\'ll find 15 prime factors which are 3 and 5.\\n\\tHere we are only looking for prime factor because suppose we are looking for 3 first so in 6 we will get a factor of 3 and in 9 too.\\n\\tSince 3 is comprising in other values too we will look out for other prime factor of 15 i.e 5.\\n\\tSo the appearance of 15 we be decided on how many times 5 is repeated in 10!\\n\\tso we check on how many times 3 and 5 are repeated using a formula which is :-\\n\\t![image](https://assets.leetcode.com/users/images/fdd61997-4e6d-4a16-8230-1aab2fd7a056_1635573545.707294.png)\\n\\n\\nHere C is the  Count ,n is number whose factorial we are going to do and p is the prime no,and **these brackets are Greatest Integer Function**\\nso appyling this formula for 3 we will get 4 times (3=**3**x1,6=2x**3**,9=**3**x**3**) and \\nfor 5 it will be 2 (5=**5**x1,10=**5**x2)\\nso 3 -4 times and 5-2 times **we will consider the value which is least among prime factor** here it is 2 so final answer is 2.\\n\\n\\nSo similarly for 10 we will do the same we are going to use this concept and will take the least value of 5 because 2 is more repeated than 5 so we will choose 5 .\\n\\nHere is the code:-\\n\\n\\npublic class Solution {\\n\\n\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n>0){\\n            n=n/5;\\n            count+=n;\\n        }\\n        return count;\\n}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n>0){\\n            n=n/5;\\n            count+=n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1275893,
                "title": "java-100-time-iterative-and-recursive-solutions-explanation",
                "content": "**Intuition:**\\n\\nMultiplying 5 and 2 results in 10, which has one trailing zero. So any number that has the factor of 5 and 2 (i.e. 10) will definitely have a zero at the end. If there are more than one multiple of 10 *(i.e. multiple of 5 and 2)* in the number (eg - 100=10x10, 1000=10x10x10, etc), then there are more than one zero in the number.\\n\\nSo if we are able to count the number of 10s (5x2) in the number we should be able to find our result.\\n\\nNow if factorial of a number has 5, then it will definitely have a 2 (as 2 < 5). So if we are able to find the number of factors of 5 in a number we should be able to find the number of 10s as well.\\n\\nDividing the given number by 5 will give the factor of 5. If current factor is greater than equal to 5, then that also has additional factor of 5 which needs to be counted to get the final count. Hence that number also needs to be divided by 5 and added to the count. We would want to do this until the factor is less than 5, in which case the factor will be 0.\\n\\n\\n**Iterative:**\\n\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count = 0;\\n        while (n >= 5) { \\n\\t\\t\\tn /= 5;\\n            count += n;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n**Recursive:**\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        return n < 5 ? 0 : n / 5 + trailingZeroes(n/5);\\n\\t}\\n}\\t\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count = 0;\\n        while (n >= 5) { \\n\\t\\t\\tn /= 5;\\n            count += n;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        return n < 5 ? 0 : n / 5 + trailingZeroes(n/5);\\n\\t}\\n}\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889734,
                "title": "javascript-solution-with-short-hard-to-read-code",
                "content": "## Code\\n```javascript\\nvar trailingZeroes = function (n) {\\n  let c = 0\\n  while (n >= 5) {\\n    c += (n = (n / 5) | 0)\\n  }\\n  return c\\n}\\n```\\n\\n## Explain\\n\\nAs we know, `0` only apear when multiply has `5` and `5`\\'s multiple, and below every `5`\\'s multiple, there will always has an even which can multiply `5`\\'s multiple be a `0` end number.\\n\\nso I just need find out how many `5`\\'s multiple exsist in given number `N`\\n\\nLast! Also as all we know, `25` is double `5`, which can make a `two 0` end number, and so on\\n\\nSo, just count how many `5` in `N` and plus how many `5*5` in `N` and `5*5*5` in `N`\\u2026.\\n\\n*Note: `number | 0` is a shot way to get trunc `Int` number but it requires `number` less than `(2^31)-1`*",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar trailingZeroes = function (n) {\\n  let c = 0\\n  while (n >= 5) {\\n    c += (n = (n / 5) | 0)\\n  }\\n  return c\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764647,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int numberOfFives = 0;\\n        \\n        while(n >= 5){\\n            int temp = (int)Math.floor(n / 5);\\n            numberOfFives += temp;\\n            n = temp;\\n        }\\n        \\n        return numberOfFives;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int numberOfFives = 0;\\n        \\n        while(n >= 5){\\n            int temp = (int)Math.floor(n / 5);\\n            numberOfFives += temp;\\n            n = temp;\\n        }\\n        \\n        return numberOfFives;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683183,
                "title": "100-percent-faster-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n        while(n){\\n            count += n/5;\\n            n= n/5;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n        while(n){\\n            count += n/5;\\n            n= n/5;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 412134,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        z = 0\\n        \\n        while n > 0:\\n            n= n // 5 \\n            z+= n\\n        return z\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        z = 0\\n        \\n        while n > 0:\\n            n= n // 5 \\n            z+= n\\n        return z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356210,
                "title": "simple-python-solution",
                "content": "0 can only be generated by 2*5 bassicly\\nSince there are more 2 than 5, we can just count how many 5 factor.\\nCount 5, 5**2, 5**3, ... add them all.\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        ans = 0\\n        while n > 0:\\n            ans += n // 5\\n            n //= 5\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        ans = 0\\n        while n > 0:\\n            ans += n // 5\\n            n //= 5\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279485,
                "title": "python3-beats-100-36ms",
                "content": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        if n<5:\\n            return 0\\n        x=0\\n        while n != 0:\\n            x += n // 5\\n            n //= 5\\n            \\n        return x\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        if n<5:\\n            return 0\\n        x=0\\n        while n != 0:\\n            x += n // 5\\n            n //= 5\\n            \\n        return x\\n",
                "codeTag": "Java"
            },
            {
                "id": 244234,
                "title": "recursive-java-soltions-beats-100",
                "content": "This solution involves a little bit of math. We get a 0 at the end of multiplication, when we multiplying multiple of 2 & 5.\\neg: 2 * 5 = 10\\n4 * 5 =20\\n2 * 15 =30\\n4 * 10 =40\\nThis means we hae to figure out how many multiples  5\\'s and 2\\'s are there in the multiplication.\\nSuppose the number of multiples of 5\\'s is x and \\nthe number of multiples of 2\\'s is y.\\nSo the number of trailing 0\\'s would be min(x,y)\\nBut in case of a factorials the multiples of 5 will always be less than multiples of 2.\\neg n =12\\nmultiples of 2 (y) = [2,4,6,8,10,12] = 6\\nmultiples of 5 (y) = [5,10] = 2\\nSo we only need to find y.\\n\\nBelow is the recursive solution for that.\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        if (n/5 >= 5) {\\n            return n/5 + trailingZeroes(n/5);\\n        } else {\\n            return n/5;\\n        }  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        if (n/5 >= 5) {\\n            return n/5 + trailingZeroes(n/5);\\n        } else {\\n            return n/5;\\n        }  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202026,
                "title": "python-solution",
                "content": "\\u53C2\\u8003Wiki\\u4E0A\\u6587\\u7AE0https://en.wikipedia.org/wiki/Trailing_zero#Factorial\\ntips: \\u4E94\\u7684\\u500D\\u6570\\u7684\\u9644\\u8FD1\\u4E00\\u5B9A\\u5B58\\u5728\\u4E0E\\u4E4B\\u76F8\\u5339\\u914D\\u7684\\u5076\\u6570\\uFF0C\\u6240\\u4EE5\\u4E0D\\u5FC5\\u53EF\\u4EE5\\u641C\\u7D22\\uFF0C\\u53EA\\u8981\\u8003\\u8651\\u4E94\\u7684\\u6574\\u500D\\u6570\\u5373\\u53EF\\u3002\\n```\\nclass Solution(object):\\n    \\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        while n >= 5:\\n            n //= 5\\n            cnt += n\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        while n >= 5:\\n            n //= 5\\n            cnt += n\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200330,
                "title": "python-5-lines-iterative-solution-with-explanations",
                "content": "```python\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        c = 0\\n        while n > 0:\\n            n //= 5\\n            c += n\\n        return c\\n```\\nWe have one trailing zero for each pair of prime factors (2,5) in the prime factorization of n!.\\nThere are plenty of factors 2 in n! so let\\'s just count the factors 5 in all numbers lower than n (included).\\nTotal number of factors 5 is equal to the sum of those numbers :\\n- number of multiples of 5 below n (added in 1st iteration, after having divided n by 5 once) \\n- number of multiples of 5^2 below n (added in 2nd iteration, after having divided n by 5 twice) \\n- number of multiples of 5^3 below n (added in 3rd iteration, after having divided n by 5 three times) \\n...\\n- number of multiples of 5^k below n (added in last iteration, after having divided n by 5 k times)\\nk goes until log5(n) so the time complexity is O(log(n)).",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        c = 0\\n        while n > 0:\\n            n //= 5\\n            c += n\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185386,
                "title": "java-solution",
                "content": "Now let us think about how a trailing zero is added during factorial calculation.\n1) You decompose the multiplication chain in terms of each element's prime factors\n ex. 10! = 10x9x8x7x6x5x4x3x2x1 =(5x2)*(3x3)*(2x2x2)*7*(2x3)*5*(2x2)*3*2*1\n2) A trailing zero is added only if whenever there is a pair of one 5 and one 2 in the multiplication chain.\n3) This (5,2) pair production is fundamentally limited by the number of 5's in the multiplcation chain because there will be always more 2's than 5's.\n4) So the trick is to count how many factor 5's are in the multiplication chain.\n\nSo how do we count this ?\nFor n! \n!n = (5^(number of 5's))*(other prime factor multiplications)\n1) So simple way of counting the 5s is to keep dividing n by 5 and summing up number of times it divided evenly.. but this is slow\n\nIs there a better way ? \nEx. How many multiples of 5s are in 100! or 1 to 100?\n100 / 5 = 20.\nBut there are also mutiples of 5x5, 100/(5x5) = 4. (One extra 5's from 25, 50, 75 and 100)\nAre there multiples of 5x5x5 ? Nope because 100/(5x5x5) < 1; So this is our termination condition.\nSo the total number of trailing zeros are 20 + 4 = 24\nSo factors we care about are 5, 5x5, 5x5x5, 5x5x5x... and so on.\n\n2) Add up the quotients by dividing the number by 5, 5x5, 5x5x5, and so on (Works but, later this leads to overflow because divisor is exponentially increasing)\n3) Another way of approaching 2) is simply divide n by 5, to count multiples of 5.\nThen update n = n/5 to and divide it by 5 to count the multiples of 5x5's. \nThen update n = n/5 to and divide it by 5 count multiples of 5x5x5's and so on till n/5 < 1.\n```\nclass Solution {\n    public int trailingZeroes(int n) {\n        int numOfFives = 0;\n        while(true){\n            if(n/5<1){\n                break;\n            } else {\n                numOfFives += n/5;\n                n=n/5;\n            }\n        }\n        return numOfFives;\n    }\n}\n```\n\n",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int trailingZeroes(int n) {\n        int numOfFives = 0;\n        while(true){\n            if(n/5<1){\n                break;\n            } else {\n                numOfFives += n/5;\n                n=n/5;\n            }\n        }\n        return numOfFives;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 52444,
                "title": "3-lines-java-solution-1ms",
                "content": "\\n    public int trailingZeroes(int n) {\\n    \\tint num;\\n    \\tfor (num = 0; n != 0; n /= 5, num += n);\\n    \\treturn num;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int trailingZeroes(int n) {\\n    \\tint num;\\n    \\tfor (num = 0; n != 0; n /= 5, num += n);\\n    \\treturn num;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52442,
                "title": "1ms-java-solution",
                "content": "    public class Solution {\\n    public int trailingZeroes(int n) {\\n        int sum=0;\\n        while(n>=5){\\n            sum+=n/5;\\n            n=n/5;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int trailingZeroes(int n) {\\n        int sum=0;\\n        while(n>=5){\\n            sum+=n/5;\\n            n=n/5;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52458,
                "title": "c-4ms-simple-solution-by-counting-5-s",
                "content": "    class Solution {\\n    public:\\n    int trailingZeroes(int n) {\\n        int r = 0;\\n        while(n >= 5){\\n            n /= 5;\\n            r += n;\\n        }\\n        return r;\\n    }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    int trailingZeroes(int n) {\\n        int r = 0;\\n        while(n >= 5){\\n            n /= 5;\\n            r += n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52429,
                "title": "why-my-code-didn-t-pass-the-test",
                "content": "The code is quite simple and straight forward:\\n\\nint trailingZeroes(int n) {\\n        int num = 0;\\n\\n\\tfor(int test=5; test<=n; test*=5)\\n\\t{\\n\\t\\tnum += n/test;\\n\\t}\\n\\n\\treturn num;\\n}\\n\\n\\nHowever, system test returns:\\n\\nStatus: Time Limit Exceeded\\nLast executed input:\\t2147483647\\n\\n\\nMy questions are:\\n\\n1. This \"last input\" is obviously a long int, rather than int. Why does the system care about a long int type since the pre-set class uses an int function?\\n\\n2. Why did the recursive function passed system test? What's the difference with my function?\\n\\nint trailingZeroes(int n) {\\n        return n==0 ? 0 : n/5+trailingZeroes(n/5);\\n}\\n\\nThanks!",
                "solutionTags": [],
                "code": "The code is quite simple and straight forward:\\n\\nint trailingZeroes(int n) {\\n        int num = 0;\\n\\n\\tfor(int test=5; test<=n; test*=5)\\n\\t{\\n\\t\\tnum += n/test;\\n\\t}\\n\\n\\treturn num;\\n}\\n\\n\\nHowever, system test returns:\\n\\nStatus: Time Limit Exceeded\\nLast executed input:\\t2147483647\\n\\n\\nMy questions are:\\n\\n1. This \"last input\" is obviously a long int, rather than int. Why does the system care about a long int type since the pre-set class uses an int function?\\n\\n2. Why did the recursive function passed system test? What's the difference with my function?\\n\\nint trailingZeroes(int n) {\\n        return n==0 ? 0 : n/5+trailingZeroes(n/5);\\n}\\n\\nThanks!",
                "codeTag": "Java"
            },
            {
                "id": 3737418,
                "title": "simple-c-code-easiest-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity: Log N\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:Constant Space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        while(n>0){\\n            ans+=n/5;\\n            n/=5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        while(n>0){\\n            ans+=n/5;\\n            n/=5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717257,
                "title": "java-100-beats-easy-solution",
                "content": "# Intuition\\nWe have to find exponent of 5 in factorial of n.\\nThe exponent of 5 will be equal to the number of trailing zeros. \\n\\n# Approach\\nWe continuously divide n by 5 and add it to variable(initialised from zero) and n will become n/5,until n becomes zero.\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n       int c=0;\\n       while(n!=0){\\n           c+=n/5;\\n           n/=5;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n       int c=0;\\n       while(n!=0){\\n           c+=n/5;\\n           n/=5;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631503,
                "title": "5-lines-solution-java-log-n-100-beats",
                "content": "# Intuition\\nThe trailingZeroes function takes an integer n as input and calculates the number of trailing zeros(ie zeros at the end of the factorial answer) in the factorial of n.\\n\\n# Approach\\nLet\\'s consider an example: n = 25.\\n\\nInitially, count = 0 and n = 25.\\n\\n1st iteration:\\n\\nDivide n by 5: n = 25 / 5 = 5\\nAdd n (5) to count: count = 0 + 5 = 5\\n\\n2nd iteration:\\n\\nDivide n by 5: n = 5 / 5 = 1\\nAdd n (1) to count: count = 5 + 1 = 6\\nThe loop ends because n becomes less than 5.\\n\\nThe final result is count = 6, indicating that the factorial of 25 has 6 trailing zeros.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Please upvote guys if u like my solution!!\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n>0){\\n            n/=5;\\n            count+=n;\\n        }     \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n>0){\\n            n/=5;\\n            count+=n;\\n        }     \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616779,
                "title": "easy-c-solution-beats-100-4lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0 ;\\n        for (int i = 5; n / i >= 1; i *= 5){\\n            count += n / i;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0 ;\\n        for (int i = 5; n / i >= 1; i *= 5){\\n            count += n / i;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546309,
                "title": "easiest-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        co = 0\\n        while n > 0:\\n            co+= n // 5\\n            n //= 5\\n        return co\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        co = 0\\n        while n > 0:\\n            co+= n // 5\\n            n //= 5\\n        return co\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658530,
                "title": "python-easy-solution-in-5-lines",
                "content": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        i,c = 5,0\\n        while i<=n:\\n            c+=n//i\\n            i*=5\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        i,c = 5,0\\n        while i<=n:\\n            c+=n//i\\n            i*=5\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583050,
                "title": "java-fastest-solution",
                "content": "```\\nclass Solution {\\n    \\n    \\n    public int trailingZeroes(int n) {\\n        \\n        int ans=0;\\n       while(n>=5)\\n       {\\n           n/=5;\\n           ans+=n;\\n       }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nStay Hungry! Stay f00lish : )",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    public int trailingZeroes(int n) {\\n        \\n        int ans=0;\\n       while(n>=5)\\n       {\\n           n/=5;\\n           ans+=n;\\n       }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406341,
                "title": "c-0ms-faster-than-100-fastest-explained-with-comments-simple-easy-method",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {  \\n\\t\\n\\t//we just have to count number of 5\\'s as  (5*2) contributes to 1 zero, \\n\\t//as number of 2\\'s are always greater than number of 5\\'s, \\n\\t//count of 5\\'s are the limiting case for  trailing 0\\'s\\n\\n\\n      if(n <= 4){                   //if n is less than 4 then leading zeroes are 0\\n        return 0;\\n      }\\n                                         //considering powers of  5 as 25 contributes to 2 --> 5\\'s, \\n\\t                                     //125 contrinutes to 3 --> 5\\'s similarly 625 contributes 4  --> 5\\'s and so on ,\\n\\t                                     //and dividing then gives the count of 5\\'s for the value of n\\n\\t   int countof5 = 0;   \\n\\t   \\n      for(int i = 1; i<=5 ;++i){                   \\n        int temp_count=n/(pow(5,i));  \\n        \\n        if(temp_count==0){\\n          break;\\n        }\\n        \\n        else{\\n          countof5+=temp_count;\\n        }\\n        \\n      }\\n      \\n      return  countof5;\\n    }\\n};\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {  \\n\\t\\n\\t//we just have to count number of 5\\'s as  (5*2) contributes to 1 zero, \\n\\t//as number of 2\\'s are always greater than number of 5\\'s, \\n\\t//count of 5\\'s are the limiting case for  trailing 0\\'s\\n\\n\\n      if(n <= 4){                   //if n is less than 4 then leading zeroes are 0\\n        return 0;\\n      }\\n                                         //considering powers of  5 as 25 contributes to 2 --> 5\\'s, \\n\\t                                     //125 contrinutes to 3 --> 5\\'s similarly 625 contributes 4  --> 5\\'s and so on ,\\n\\t                                     //and dividing then gives the count of 5\\'s for the value of n\\n\\t   int countof5 = 0;   \\n\\t   \\n      for(int i = 1; i<=5 ;++i){                   \\n        int temp_count=n/(pow(5,i));  \\n        \\n        if(temp_count==0){\\n          break;\\n        }\\n        \\n        else{\\n          countof5+=temp_count;\\n        }\\n        \\n      }\\n      \\n      return  countof5;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395507,
                "title": "java-easy-4-lines-code",
                "content": "don\\'t forget to upvpte if you like the sol\\n\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int res =0;\\n        for(int i=5;i<=n;i*=5)\\n        {res = res + n/i;}\\n        return res;}  }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int trailingZeroes(int n) {\\n        int res =0;\\n        for(int i=5;i<=n;i*=5)\\n        {res = res + n/i;}",
                "codeTag": "Java"
            },
            {
                "id": 2076166,
                "title": "c-3-lines-solution-with-detailed-explanation-100-faster",
                "content": "**Explanation** :  We have to find power of 10 in n!.\\nWhich boils down to finding maximum power of 5 present in factorization of n! because maximum power of 2 will always be greater than maximum power of 5. \\n\\nApproach : \\nLet\\'s take 10! as an example.\\n`10! = 1*2*3*4*5*6*7*8*9*10`\\n\\nThere are 5 multiples of 2 present in 10! each containing atleast one power of 2. \\n`2 4 6 8 10  ` Count can be obtained by integral value of `10/2`   \\nAdd 5 to the answer. We have counted 5 powers of 2. \\n\\nThen there are 2 multiples of `2^2` present in 10! each containing atleast 2 power of 2. \\n`4 8`  can be obtained by integral value of ` 10/2^2.`\\nAdd 2 to the answer. \\n\\nNow one might think there are 2 factors of `2^2` so we should add 4 but first power of 2 in each no. is already added in previous iterations.\\nWhen we counted all the multiples of 2. \\n\\nSo in general there are `n/p^a ` ( where p is a prime no. Take floor of the value ) multiples of ` p^a `present in n! . Each containing atleast \\'a\\' power of 2. \\nAdd `[n/p^a] `to the answer.  \\nThis will count one power of 2 in each multiple of `p^a`. Rest of the powers are already counted in previous iterations. \\n\\nNow our answer is the sum of all such no. of multiples.\\n\\n`ans = [n/p] + [n/p^2] + [n/p^3] +.... [n/p^a] where p^a < = n`\\n\\n\\n```\\n   int trailingZeroes(int n) {\\n        int pow_of_5=0;\\n        \\n        while(n){\\n            n=n/5; \\n            pow_of_5+=n;\\n        }\\n        return pow_of_5;\\n    }\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n   int trailingZeroes(int n) {\\n        int pow_of_5=0;\\n        \\n        while(n){\\n            n=n/5; \\n            pow_of_5+=n;\\n        }\\n        return pow_of_5;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460040,
                "title": "js-o-nlogn-and-o-logn-solution-explained",
                "content": "The main idea - you need to figure out, how many 5\\'s you have on n! multipliers. For example: 10 is 5 * 2, so there is one 5. 250 is 5 * 5 * 5 * 2, so there is three 5\\'s. For every 5 you can find 2\\'s in n! multipliers, and 5*2 will give you 10 and one zero in final result. So you don\\'t need to find 2\\'s, only 5\\'s.\\n\\nSo, O(NlogN) solution solution first, it\\'s easier to understand\\n```\\nvar trailingZeroes = function(n) {\\n    let count = 0;\\n\\t// find 5\\'s in k\\n\\t// return 1 for 10 and 3 for 250 from example;\\n    function getMaxPov5(k) {\\n        let max = 0;\\n        while ((k / 5) % 1 === 0) {\\n            max++;\\n            k /= 5;\\n        }\\n        return max;\\n    }\\n\\t// check only multipliers we can divide by 5\\n    for (let i = 5; i <= n; i += 5) {\\n        count += getMaxPov5(i);\\n    }\\n    return count;\\n};\\n```\\nO(logN) solution\\n```\\nvar trailingZeroes = function(n) {\\n    let count = 0;\\n    \\n\\t// first iteration: find quantity of numbers divisible by 5\\n\\t// second iteration: find quantity of numbers divisible by 25. It is numbers from first iteration / 5. 25 = 5*5,\\n\\t// but we counted first 5 in first iteration, so we add only one 5 for every number divisible by 25.\\n\\t// etc for 125, 625 and so on\\n    while (n) {\\n        n = Math.floor(n / 5);\\n        count += n;\\n    }\\n    return count;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar trailingZeroes = function(n) {\\n    let count = 0;\\n\\t// find 5\\'s in k\\n\\t// return 1 for 10 and 3 for 250 from example;\\n    function getMaxPov5(k) {\\n        let max = 0;\\n        while ((k / 5) % 1 === 0) {\\n            max++;\\n            k /= 5;\\n        }\\n        return max;\\n    }\\n\\t// check only multipliers we can divide by 5\\n    for (let i = 5; i <= n; i += 5) {\\n        count += getMaxPov5(i);\\n    }\\n    return count;\\n};\\n```\n```\\nvar trailingZeroes = function(n) {\\n    let count = 0;\\n    \\n\\t// first iteration: find quantity of numbers divisible by 5\\n\\t// second iteration: find quantity of numbers divisible by 25. It is numbers from first iteration / 5. 25 = 5*5,\\n\\t// but we counted first 5 in first iteration, so we add only one 5 for every number divisible by 25.\\n\\t// etc for 125, 625 and so on\\n    while (n) {\\n        n = Math.floor(n / 5);\\n        count += n;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423005,
                "title": "super-easy-4-line-of-code-100-faster",
                "content": "**Please Upvote**\\n\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        while(n/5>=1){\\n            ans+=(n/5);\\n            n/=5;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        while(n/5>=1){\\n            ans+=(n/5);\\n            n/=5;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1290809,
                "title": "very-easy-python-solution",
                "content": "The solution is based on the following idea:\\nevery number 5k: 5k<=n give a zero. \\nHere we count all numbers less or equal n which are multiples of 5, then multiples of 25 (they give 00) etc.\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        #n < 10000\\n        res = 0\\n        while n > 0:\\n            res += n//5\\n            n = n//5\\n        return(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        #n < 10000\\n        res = 0\\n        while n > 0:\\n            res += n//5\\n            n = n//5\\n        return(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266799,
                "title": "one-line-c-solution-o-1-time-and-space-complexity",
                "content": "In this method we add ***[n/(powers of 5 less than given range of nos)].***\\nTherefore, here the range of n was 10000, thus as (5^6 > 10000) & (5^5 < 10000) thus we will divide n by powers of 5 until 5th power and add them to get the answer. \\n*This method clicked to me when I wrote different values of factorial together and saw the pattern in their trailing zeros.*\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n/5 + n/25 + n/125 + n/625 + n/3125; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n/5 + n/25 + n/125 + n/625 + n/3125; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258493,
                "title": "weeb-explains-python-math",
                "content": "\\tclass Solution:\\n\\t\\tdef trailingZeroes(self, n: int) -> int:\\n\\t\\t\\tcount = 0\\n\\n\\t\\t\\twhile(n >= 5):\\n\\t\\t\\t\\tn //= 5 # integer division, we don\\'t need decimal numbers\\n\\t\\t\\t\\tcount += n\\n\\n\\t\\t\\treturn count\\nA trailing zero is always produced by prime factors 2 and 5 because 2 * 5 = 10 and 10 has one trailing zero\\n**Example:**\\nn = 5: There is one 5 and 3 2s in prime factors of 5! (2 * 2 * 2 * 3 * 5). So a count of trailing 0s is 1.\\nn = 11: There are two 5s and eight 2s in prime factors of 11! (2^8 * 3^4 * 5^2 * 7). So the count of trailing 0s is 2.\\n\\nif u noticed, the number of 5s is always lower than the number of 2s. Thus, we just need to find the number of 5s by dividing the number with 5\\n\\nAnyways, its time for some anime recommendations\\nTry watching **Dagashi Kashi**\\n\\n# Episodes: 24 (2 seasons)\\n# Genres: Comedy, Shounen\\n\\nFun anime, if ur feeling down, just try out this anime.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef trailingZeroes(self, n: int) -> int:\\n\\t\\t\\tcount = 0\\n\\n\\t\\t\\twhile(n >= 5):\\n\\t\\t\\t\\tn //= 5 # integer division, we don\\'t need decimal numbers\\n\\t\\t\\t\\tcount += n\\n\\n\\t\\t\\treturn count\\nA trailing zero is always produced by prime factors 2 and 5 because 2 * 5 = 10 and 10 has one trailing zero\\n**Example:**\\nn = 5: There is one 5 and 3 2s in prime factors of 5! (2 * 2 * 2 * 3 * 5). So a count of trailing 0s is 1.\\nn = 11: There are two 5s and eight 2s in prime factors of 11! (2^8 * 3^4 * 5^2 * 7). So the count of trailing 0s is 2.\\n\\nif u noticed, the number of 5s is always lower than the number of 2s. Thus, we just need to find the number of 5s by dividing the number with 5\\n\\nAnyways, its time for some anime recommendations\\nTry watching **Dagashi Kashi**\\n\\n# Episodes: 24 (2 seasons)\\n# Genres: Comedy, Shounen\\n\\nFun anime, if ur feeling down, just try out this anime.\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1249892,
                "title": "java-math-based-approach-with-proper-explanation",
                "content": "*Attached the code below in case you just want that, and none of the BS written down*\\n\\nYou must know that every number can be broken down in a multiplication of prime numbers, called it\\'s prime factors.\\nSo, just assume we have this number 25 * 22. How many trailing zeros would it have?\\n\\nThe answer lies in it\\'s prime factors. \\n25 = 5 * 5\\n22 = 2 * 11\\n\\nA number will have a trailing zero, if and only if it has 10 as a factor, and for it to have 10 as a factor, it must have a pair of 2 and 5.\\nIn our above example, we see just one pair of 2 and 5, and hence 25 * 22 will have just one ttailing zero!\\n\\nHow does it apply to a factorial? Well, 5! = 5 * 4 * 3 * 2 * 1 = 5 * (2 * 2) * 3 * 2 * 1 => just one pair of 2 and 5 again, and so one trailing zero.\\n\\nNoticed something? The number of 5 will always be less than the number of 2. So if we can find our the number of 5 amongst the prime factors of a number, that would give us the amount of trailing zeros.\\n\\nThe big question though is how the hell do we find out all the prime factors of 1234! . I mean we can\\'t do that, right?\\nSo we have this formula. To find the highest power of a prime factor in a factorial.\\n\\nHighest power of X(a prime number) in N! = [N/X] + [N/(X.X)] + [N / (X.X.X)] + . . . . + 0\\n\\nHighest power of 5 in 1234! ? \\n\\n1234/5 = 246\\n246/5   = 49\\n49/5     = 9\\n9/5       = 1\\n1/5       = 0\\n\\n246 + 49 + 9 + 1 = 305. Thus 1234! have 305 trailing zeros!\\n\\nHope that helped you, and hope you learned something.  \\n\\nclass Solution {\\n\\n    public int trailingZeroes(int n) \\n    {\\n        int ans = 0;\\n        \\n        while (n/5 > 0) \\n        {\\n            ans += n/5;            \\n            n /= 5;\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int trailingZeroes(int n) \\n    {\\n        int ans = 0;\\n        \\n        while (n/5 > 0) \\n        {\\n            ans += n/5;            \\n            n /= 5;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 995003,
                "title": "fast-23ms-python3-in-o-log-n-time",
                "content": "For the reasoning behind this see: https://www.purplemath.com/modules/factzero.htm\\n```\\n        powers_of_five = 5\\n    \\n        trailing_zeros = 0\\n        while powers_of_five <= n:\\n            trailing_zeros += n // powers_of_five\\n            powers_of_five *= 5\\n\\n        return trailing_zeros \\n```",
                "solutionTags": [],
                "code": "```\\n        powers_of_five = 5\\n    \\n        trailing_zeros = 0\\n        while powers_of_five <= n:\\n            trailing_zeros += n // powers_of_five\\n            powers_of_five *= 5\\n\\n        return trailing_zeros \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 863845,
                "title": "20ms-o-log-5-n-python-solution-beats-99-1",
                "content": "trailing zeroes will occur when 5 multiply by 2. So after every 5 we get 1 more zero. \\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        count = 0\\n        while n:\\n            n //= 5\\n            count += n\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        count = 0\\n        while n:\\n            n //= 5\\n            count += n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499428,
                "title": "faster-than-97-100-better-memory",
                "content": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        if n<5:\\n            return 0\\n        \\n        ans=0\\n        while n!=0: \\n            n=n//5\\n            ans+= n\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        if n<5:\\n            return 0\\n        \\n        ans=0\\n        while n!=0: \\n            n=n//5\\n            ans+= n\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374912,
                "title": "python",
                "content": "Keep dividing the number by multiples of 5 and add that to the count\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count, i = 0, 5\\n        while (n/i) >= 1: \\n            count += int(n/i) \\n            i *= 5\\n        return count\\n```\\n\\nIt comes down to primes factors of a number. The number of 2s and 5s you can combine will give the number of trailing zeros. So for example, if you have 10000 as a number the prime factors will be 5^4 x 2^4 will give you 4. For 68750, the prime factors will be 2^1 x 5^5 x 11^1 will give you 1 since you can only combine 2^1 and 5^1.\\n\\nSources Below:\\nhttps://brilliant.org/wiki/trailing-number-of-zeros/\\nhttps://www.geeksforgeeks.org/count-trailing-zeroes-factorial-number/",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count, i = 0, 5\\n        while (n/i) >= 1: \\n            count += int(n/i) \\n            i *= 5\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304343,
                "title": "python-16ms-with-explaination-super-easy-to-understand",
                "content": "Zeros come from 10 which is 2*5, and 5>2, so we just need to count how many 5 this factorial has\\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        out = 0\\n        while n>=5**i:\\n            out+=n//5**i\\n            i+=1\\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        out = 0\\n        while n>=5**i:\\n            out+=n//5**i\\n            i+=1\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303095,
                "title": "java-solution-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        //You found yourself how many factors 5 the number n! has: The number of factors 5 is n/5 + n/25 + n/125...  The number of factors 2 is n/2 + n/4 + n/8 ..., then number of factors 103 is n/103 + n/103^2 + n/103^3 ... and so on. (Applied to all prime dividers)\\n        //And because the number of factors 2 is always >= # of factors 5, there are enough factor 2 to pair with the factor 5 in n!, and each factor 5 can thus form a trailing zero(\"10\"). Note that k \"10\"s multiplied together will have k trailing zeros.\\n        //Therefore the problem now becomes counting how many factors 5 are there in n!.(Which can be calculated by our formula above.)\\n        int cnt = 0;\\n        while(n > 0){\\n            n /= 5;\\n            cnt += n;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        //You found yourself how many factors 5 the number n! has: The number of factors 5 is n/5 + n/25 + n/125...  The number of factors 2 is n/2 + n/4 + n/8 ..., then number of factors 103 is n/103 + n/103^2 + n/103^3 ... and so on. (Applied to all prime dividers)\\n        //And because the number of factors 2 is always >= # of factors 5, there are enough factor 2 to pair with the factor 5 in n!, and each factor 5 can thus form a trailing zero(\"10\"). Note that k \"10\"s multiplied together will have k trailing zeros.\\n        //Therefore the problem now becomes counting how many factors 5 are there in n!.(Which can be calculated by our formula above.)\\n        int cnt = 0;\\n        while(n > 0){\\n            n /= 5;\\n            cnt += n;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206577,
                "title": "java-faster-than-99-82-minimalistic-solution",
                "content": "```\\npublic int trailingZeroes(int n) {\\n\\tint solution = 0;\\n\\twhile(n>0) {\\n\\t\\tsolution += n/5;\\n\\t\\tn/=5;\\n\\t}\\n\\treturn solution; }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int trailingZeroes(int n) {\\n\\tint solution = 0;\\n\\twhile(n>0) {\\n\\t\\tsolution += n/5;\\n\\t\\tn/=5;\\n\\t}\\n\\treturn solution; }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 153554,
                "title": "simplest-c-solution-100",
                "content": "```\\nint trailingZeroes(int n) \\n{\\n    int res = 0;\\n    while (n >= 5)\\n    {\\n        res += n / 5;\\n        n = n / 5;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint trailingZeroes(int n) \\n{\\n    int res = 0;\\n    while (n >= 5)\\n    {\\n        res += n / 5;\\n        n = n / 5;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152499,
                "title": "python3-100-24-ms",
                "content": "```\\n\\tdef trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n\\n        Brute force exceeded allowed run time.  To calculate \\n        number of trailing zeros w/o the need to first calculate \\n        the factorial, use this understanding: the number of \\n        trailing zeros can be derived by \"summing how many \\n        fives and powers of five are in the input \\'n\\'.  Ex.\\n        num_of_zeros = n//5 + n//5^2 + n//5^3 + n//5^N ... break when 5^N < n (the input)\\n        4! => 0 \\n        5! => 1 \\n        10! => 2\\n        24! => 4\\n        25! => 5 + 1\\n        50! => 10 + 2\\n        125! => 25 + 5 + 1\\n         ...\\n        \"\"\"\\n        if n < 1:\\n            return 0\\n\\t\\t\\t\\t\\t\\t\\n        num_zeros = 0\\n        pow_of_5 = 5\\n\\t\\t\\t\\t\\n        while pow_of_5 <= n:\\n            num_zeros += n // pow_of_5\\n            pow_of_5 *= 5 \\n\\t\\t\\t\\t\\t\\t\\n        return num_zeros\\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n\\n        Brute force exceeded allowed run time.  To calculate \\n        number of trailing zeros w/o the need to first calculate \\n        the factorial, use this understanding: the number of \\n        trailing zeros can be derived by \"summing how many \\n        fives and powers of five are in the input \\'n\\'.  Ex.\\n        num_of_zeros = n//5 + n//5^2 + n//5^3 + n//5^N ... break when 5^N < n (the input)\\n        4! => 0 \\n        5! => 1 \\n        10! => 2\\n        24! => 4\\n        25! => 5 + 1\\n        50! => 10 + 2\\n        125! => 25 + 5 + 1\\n         ...\\n        \"\"\"\\n        if n < 1:\\n            return 0\\n\\t\\t\\t\\t\\t\\t\\n        num_zeros = 0\\n        pow_of_5 = 5\\n\\t\\t\\t\\t\\n        while pow_of_5 <= n:\\n            num_zeros += n // pow_of_5\\n            pow_of_5 *= 5 \\n\\t\\t\\t\\t\\t\\t\\n        return num_zeros\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 52451,
                "title": "single-line-c-solution",
                "content": "    int trailingZeroes(int n) {\\n        return n==0? 0:n/5+trailingZeroes(n/5);\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "    int trailingZeroes(int n) {\\n        return n==0? 0:n/5+trailingZeroes(n/5);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52473,
                "title": "accepted-4ms-c-solution",
                "content": "    class Solution {  \\n    public:  \\n        int trailingZeroes(int n) {\\n            int zeros = 0;\\n            while (n) zeros += n /= 5;\\n            return zeros;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {  \\n    public:  \\n        int trailingZeroes(int n) {\\n            int zeros = 0;\\n            while (n) zeros += n /= 5;\\n            return zeros;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52505,
                "title": "this-is-an-accepted-java-solution-but-can-it-run-in-log-n-time",
                "content": "    public class Solution {\\n    public int trailingZeroes(int n) {\\n        int result = 0;\\n        while(n > 1)\\n        {\\n            n/=5;\\n            result += n;\\n            \\n        }\\n        return result;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int trailingZeroes(int n) {\\n        int result = 0;\\n        while(n > 1)\\n        {\\n            n/=5;\\n            result += n;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52507,
                "title": "more-test-cases-needed",
                "content": "when 'n >=1808548329' solutions using multiply like below will get overflow and output wrong answer.\\n(5^13 = 1220703125 < 2^31, but 5^14 = 6103515625 > 2^32 and 6103515625 % 2^32 = 1808548329 < 2 ^31)\\n\\n    for( int i = 5; n >= i; i *= 5 ) .....",
                "solutionTags": [],
                "code": "when 'n >=1808548329' solutions using multiply like below will get overflow and output wrong answer.\\n(5^13 = 1220703125 < 2^31, but 5^14 = 6103515625 > 2^32 and 6103515625 % 2^32 = 1808548329 < 2 ^31)\\n\\n    for( int i = 5; n >= i; i *= 5 ) .....",
                "codeTag": "Unknown"
            },
            {
                "id": 3976872,
                "title": "one-line-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is basic mathematical approach in which we count the number of 5\\'s in the given number as it contribute to zeros in the number.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n/5+n/25+n/125+n/3125+n/625+n/15625;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n/5+n/25+n/125+n/3125+n/625+n/15625;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769853,
                "title": "easy-java-solution-beats-100-notebook-explanation",
                "content": "# Intuition\\n![20230715_225642 (1).jpg](https://assets.leetcode.com/users/images/c791ea20-6c2a-42f1-8ea1-e5348786814a_1689442153.2552214.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n%5!=n){\\n            count+=(n/5);\\n            n=n/5;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n%5!=n){\\n            count+=(n/5);\\n            n=n/5;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737415,
                "title": "log-n-solution-beats-100-0ms-runtime",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n       int ans=0;\\n       while(n/5){\\n           ans+=n/5;\\n           n/=5;\\n       }\\n       return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n       int ans=0;\\n       while(n/5){\\n           ans+=n/5;\\n           n/=5;\\n       }\\n       return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641732,
                "title": "c-easy-two-line-code-recursion-100-faster",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        if(n==0)return 0;\\n        return (n/5) + trailingZeroes(n/5);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        if(n==0)return 0;\\n        return (n/5) + trailingZeroes(n/5);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635415,
                "title": "100-beats-and-easy-to-understand",
                "content": "# Intuition\\nto find the no of trailing zeros only need to find the no of 5\\'s in the given number and add their frequency that yous answeer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        while(n){\\n            ans+=n/5;\\n            n=n/5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        while(n){\\n            ans+=n/5;\\n            n=n/5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618594,
                "title": "easy-5-lines-beats-100-python-explained",
                "content": "# Intuition\\nIn the multiplication process, trailing zeroes are generated by the product of 5 or its multiples, such as 10, 15, 20, and so on. Initially, it seems like we can simply return num/5 to count the number of trailing zeroes.\\n\\nHowever, this approach fails when we encounter numbers like 25. For example, if we divide 25 by 5, we only consider one factor of 5, but the actual number of trailing zeroes is 6 (25 = 5 * 5). To account for this, we need to divide by 5 and then by 25.\\n\\nThis problem occurs with numbers like 125, 625, and so on. To handle this, we need to loop and divide the number by increasing powers of 5 until the division result is less than 5.\\n\\nThe updated solution can be summarized as follows:\\n\\nInitialize a variable, count, to 0.\\nIterate while num is greater than or equal to 5.\\nWithin the loop, divide num by 5 and add the quotient to count.\\nUpdate num to be the quotient.\\nFinally, return the value of count as the number of trailing zeroes.\\nI hope this clarifies the solution. Let me know if you have any further questions!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        c,i=0,5\\n        while i<=n:\\n            c+=n/i\\n            i*=5\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        c,i=0,5\\n        while i<=n:\\n            c+=n/i\\n            i*=5\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608509,
                "title": "2-methods-o-n-o-log5n",
                "content": "```\\n// method 1 : o(n)\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int dp[10010][4];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(int i=1; i<= n; i++){\\n            // dp[i][0]= i%2==0 ? dp[i/2][0]+1 : 0;  //num of 2 in i\\n            // dp[i][1]= dp[i-1][1] + dp[i][0];      // sum of 2 till i\\n            \\n            dp[i][2]= i%5==0 ? dp[i/5][2]+1 : 0;  //num of 5 in i\\n            dp[i][3]= dp[i-1][3] + dp[i][2];      // sum of 5 till i\\n        }\\n        \\n        // for(int i=0; i<1010; i++) printf(\"%d : %d, %d, %d, %d \\\\n\", i, dp[i][0],dp[i][1], dp[i][2], dp[i][3]);\\n        \\n        // return min(dp[n][1], dp[n][3]);\\n\\t\\t// we don\\'t need to count 2 coz 2 will always be bigger in count\\n        return dp[n][3];\\n\\n    }\\n};\\n```\\n\\n\\n```\\n// mothod 2: log5n , https://youtu.be/wkvVdggCSeo \\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        \\n        while(n){\\n            ans+= n/5;\\n            n/=5;  //or  5 = 5^2, then 5^3 tthen 5^4 ........... we devided n by 5 to remove overflow\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nNOTE this formula for future reference ( here n/x means float value of n/x )\\n![image](https://assets.leetcode.com/users/images/7c90499e-5692-4273-b408-aef8dd3fb063_1686129284.9588723.png)\\n",
                "solutionTags": [],
                "code": "```\\n// method 1 : o(n)\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int dp[10010][4];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(int i=1; i<= n; i++){\\n            // dp[i][0]= i%2==0 ? dp[i/2][0]+1 : 0;  //num of 2 in i\\n            // dp[i][1]= dp[i-1][1] + dp[i][0];      // sum of 2 till i\\n            \\n            dp[i][2]= i%5==0 ? dp[i/5][2]+1 : 0;  //num of 5 in i\\n            dp[i][3]= dp[i-1][3] + dp[i][2];      // sum of 5 till i\\n        }\\n        \\n        // for(int i=0; i<1010; i++) printf(\"%d : %d, %d, %d, %d \\\\n\", i, dp[i][0],dp[i][1], dp[i][2], dp[i][3]);\\n        \\n        // return min(dp[n][1], dp[n][3]);\\n\\t\\t// we don\\'t need to count 2 coz 2 will always be bigger in count\\n        return dp[n][3];\\n\\n    }\\n};\\n```\n```\\n// mothod 2: log5n , https://youtu.be/wkvVdggCSeo \\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        \\n        while(n){\\n            ans+= n/5;\\n            n/=5;  //or  5 = 5^2, then 5^3 tthen 5^4 ........... we devided n by 5 to remove overflow\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565150,
                "title": "0ms-beats-100-short-and-easy-c-solution",
                "content": "# Intuition\\n\\n- To get trailing zeroes we need to know how many times can the number be divided by 10.\\n- But doing it directly would lead to TLE. So what do we do now.\\n- We can simply count how many 5\\'s can be extracted from the given number.\\n\\n# Approach\\n- First divide the number by 5 and add it to $$sum$$.\\n- Now divide the number by 5.\\n- Repeat this process until the number is less than 5.\\n\\n# Complexity\\n- Time complexity: \\n$$O($$log$$5$$n$$)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int sum=0;\\n        while(n >= 5){\\n            sum += (n/5);\\n            n /= 5;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int sum=0;\\n        while(n >= 5){\\n            sum += (n/5);\\n            n /= 5;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353340,
                "title": "python-beats-99-43",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        log = 5\\n        while n >= log:\\n            count += n//log\\n            log *= 5\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        log = 5\\n        while n >= log:\\n            count += n//log\\n            log *= 5\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332578,
                "title": "0-ms-4-line-solution-very-simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int result = 0;\\n        //count all the 5\\'s and store that \\n        for(int i = 5 ; i<=n; i*=5)\\n            result += n / i;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int result = 0;\\n        //count all the 5\\'s and store that \\n        for(int i = 5 ; i<=n; i*=5)\\n            result += n / i;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268671,
                "title": "easy-python-solution-using-dp-it-takes-o-n-space-because-of-dp",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[1]*(n+1)\\n        for i in range(2,n+1):\\n            dp[i]=dp[i-1]*i\\n        st=str(dp[-1])\\n        val=st.rstrip(\"0\")\\n        return len(st)-len(val)\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[1]*(n+1)\\n        for i in range(2,n+1):\\n            dp[i]=dp[i-1]*i\\n        st=str(dp[-1])\\n        val=st.rstrip(\"0\")\\n        return len(st)-len(val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254786,
                "title": "simplest-and-easiest-approach-c",
                "content": "# Simplest Solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int trailingZeroes(int n) {\\n        int a=0;\\n        while(n){\\n            n/=5;\\n            a+=n;\\n        }\\n        return a;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int trailingZeroes(int n) {\\n        int a=0;\\n        while(n){\\n            n/=5;\\n            a+=n;\\n        }\\n        return a;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236149,
                "title": "beats-100-0ms-detailed-easy-explanation-java-python3-c-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe contributing factors to zero are two and five. For any number `n` the number of two appearing in `n!` will always be greater than the number of fives. Hence we need to count the number of fives.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![download (1).png](https://assets.leetcode.com/users/images/19c67836-61d4-4d10-b0fd-8f9d28ec2875_1677498523.377247.png)\\n\\n![download.png](https://assets.leetcode.com/users/images/5f8ad369-51de-46dc-8d45-8bbdca1ed1be_1677498463.9279845.png)\\n\\n# Explanation\\nHere is an explanation of how the function works:\\n\\n1. Initialize a variable called `zeros` to 0. This variable will be used to keep track of the number of trailing zeros in the factorial of `n`.\\n\\n1. Enter a while loop that will continue as long as `n` is greater than 0.\\n\\n1. In each iteration of the loop, calculate the number of factors of 5 in `n` by dividing `n` by 5 and adding the result to `zeros`. This is because each factor of 5 contributes to a trailing zero in the factorial of n.\\n\\n1. Divide n by 5 to remove all factors of 5 from n. This is because we have already counted them in step 3, and we only need to count each factor of 5 once.\\n\\n1. Repeat steps 3-4 until `n` is no longer greater than 0.\\n\\n1. Return the final value of `zeros`.\\n# Complexity\\n- Time complexity:  O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(log n), because we divide `n` by 5 in each iteration of the while loop, reducing its value by a factor of 5 each time. This means that the number of iterations required is proportional to the logarithm of `n`.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this function is O(1), because we only use a constant amount of extra space to store the `zeros` variable. Regardless of the input value of `n`, the amount of extra space used by the function remains the same. Therefore, the space complexity is constant, or O(1).\\n# Java\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int zeros = 0;\\n        while (n > 0) {\\n        zeros += n / 5;\\n        n /= 5;\\n        }\\n        return zeros;\\n    }\\n}\\n```\\n# C\\n```\\nint trailingZeroes(int n) {\\n    int zeros = 0;\\n    while (n > 0) {\\n        zeros += n / 5;\\n        n /= 5;\\n    }\\n    return zeros;\\n}\\n\\n```\\n# C++\\n```\\nint trailingZeroes(int n) {\\n    int zeros = 0;\\n    while (n > 0) {\\n        zeros += n / 5;\\n        n /= 5;\\n    }\\n    return zeros;\\n}\\n\\n```\\n# Python3\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        zeros = 0\\n        while n > 0:\\n            zeros += n // 5\\n            n //= 5\\n        return zeros\\n\\n```\\n---\\n# Connect\\nLinkedIn : www.linkedin.com/in/akashjana\\n---\\n#### Please consider upvoting if you find this helpful. Thank You :)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int zeros = 0;\\n        while (n > 0) {\\n        zeros += n / 5;\\n        n /= 5;\\n        }\\n        return zeros;\\n    }\\n}\\n```\n```\\nint trailingZeroes(int n) {\\n    int zeros = 0;\\n    while (n > 0) {\\n        zeros += n / 5;\\n        n /= 5;\\n    }\\n    return zeros;\\n}\\n\\n```\n```\\nint trailingZeroes(int n) {\\n    int zeros = 0;\\n    while (n > 0) {\\n        zeros += n / 5;\\n        n /= 5;\\n    }\\n    return zeros;\\n}\\n\\n```\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        zeros = 0\\n        while n > 0:\\n            zeros += n // 5\\n            n //= 5\\n        return zeros\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224151,
                "title": "beats-100-c-soluton-with-explanation",
                "content": "# Approach\\n1.Approach/method\\n![no_of_zero2.jpeg](https://assets.leetcode.com/users/images/4df19918-3e68-4f76-895d-e3100c83223b_1677219863.0379024.jpeg)\\n\\n\\n2.Approach/method\\n1.In second approach we simply divide the n! number by 5\\n2.After that For every 5*5.....(or 5^m,m=2,3,4....)(less n) multiple we get extra zero of n!/5^m..\\n3.Add the both zero(step1+step2)\\n\\nexample \\n1.25!\\nnumber of zero=25/5 + 25/25\\n               5+1=6\\n2.50!\\nnumber of zero=50/5 + 50/25\\n               10 + 2= 12\\n4.150!\\nnumber of zero=  150/5 + 150/25 + 150/125 (125 is less then 150  and 5^3=125(5^m))  \\n           30+6+1=37\\n\\n5.1000!\\n1000/5 + 1000/25(5^2) + 1000/125(5^3) +1000/625(5^4)\\n200+40+8+1=249\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//1st method\\n\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        while(n>=5)\\n        {\\n         int quotient=n/5;\\n         n=quotient;\\n         count_zero=count_zero + quotient;\\n        }\\n     return count_zero;\\n    }\\n};\\n\\n//2nd methods\\n//1.In second approach we simply divide the n! number by 5\\n//2.For every 5^m... multiple we get extra zero of n!/5^m..(m=2,3,4...)\\n//3.Add the both zero(step1+step2)\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        int i = 5;\\n        while(i <= n) {\\n            count_zero += n / i;\\n            i =i*5;\\n        }\\n    return count_zero;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//1st method\\n\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        while(n>=5)\\n        {\\n         int quotient=n/5;\\n         n=quotient;\\n         count_zero=count_zero + quotient;\\n        }\\n     return count_zero;\\n    }\\n};\\n\\n//2nd methods\\n//1.In second approach we simply divide the n! number by 5\\n//2.For every 5^m... multiple we get extra zero of n!/5^m..(m=2,3,4...)\\n//3.Add the both zero(step1+step2)\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        int i = 5;\\n        while(i <= n) {\\n            count_zero += n / i;\\n            i =i*5;\\n        }\\n    return count_zero;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128401,
                "title": "simple-intuition-python-3-solution-23ms-faster-than-98-99",
                "content": "# Intuition\\nThe ZERO comes from 10.\\nThe 10 comes from 2 x 5\\nAnd we need to account for all the products of 5 and 2, like 4\\xD75 = 20 \\u2026\\nSo, if we take all the numbers with 5 as a factor, we will have plenty of even numbers to pair with them to get factors of 10.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(logN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count=0\\n        while n>=5:\\n            n//=5\\n            count+=n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count=0\\n        while n>=5:\\n            n//=5\\n            count+=n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049596,
                "title": "c-easy-solution-0ms-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        if(n<5) return 0;\\n\\n        int value=5, count=1;\\n        while(value*5<=n){\\n            value=value*5;\\n            count++;\\n        }\\n\\n        int ans=0;\\n        int covered=0;\\n        while(count!=0){\\n            int multiples=n/value;\\n            int add=(multiples-covered)*count;\\n            covered=multiples;\\n            ans+=add;\\n            value/=5;\\n            count--;           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        if(n<5) return 0;\\n\\n        int value=5, count=1;\\n        while(value*5<=n){\\n            value=value*5;\\n            count++;\\n        }\\n\\n        int ans=0;\\n        int covered=0;\\n        while(count!=0){\\n            int multiples=n/value;\\n            int add=(multiples-covered)*count;\\n            covered=multiples;\\n            ans+=add;\\n            value/=5;\\n            count--;           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007098,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:Depends on the number of factors of 5 in n.\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int cnt=0;\\n        while(n){\\n            n/=5;\\n            cnt+=n;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int cnt=0;\\n        while(n){\\n            n/=5;\\n            cnt+=n;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006281,
                "title": "python-solution-o-2-n-for-beginner-understanding",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Disclaimer : This solution is not in Logarithmic Time. This is a beginners solution. I would highly suggest to do it in Logarithmic Time Complexity because it has a completely different approach.\\n* First, simply call the factorial function which calculates the factorial of an number.\\n* Arr is an array of integers of factorial.\\n* Then simply count the number of consecutive zeroes from last and return it.\\n\\n# Complexity\\n- Time complexity: O(2*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    \\n    def fact(self, n:int):\\n        if n == 1 or n == 0: \\n            return 1\\n        return n * self.fact(n-1)\\n\\n    def trailingZeroes(self, n: int) -> int:\\n        factorial = self.fact(n)\\n        arr = [int(x) for x in str(factorial)]\\n        count = 0\\n        for i in reversed(arr):\\n            if i==0:\\n                count += 1\\n            else:\\n                break\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def fact(self, n:int):\\n        if n == 1 or n == 0: \\n            return 1\\n        return n * self.fact(n-1)\\n\\n    def trailingZeroes(self, n: int) -> int:\\n        factorial = self.fact(n)\\n        arr = [int(x) for x in str(factorial)]\\n        count = 0\\n        for i in reversed(arr):\\n            if i==0:\\n                count += 1\\n            else:\\n                break\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921012,
                "title": "factorial-trailing-zeroes-beats-100-runtime-0-ms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        // if(n==0)\\n        //  return 0;\\n        // int sum=0;\\n        // while(n/5>0)\\n        // {\\n        //     sum=sum+(n/5);\\n        //     n=n/5;\\n        // }\\n        // return sum;\\n        int sum=0;\\n        while(n>0)\\n        {\\n            n=n/5;\\n            sum = sum + n;\\n         \\n        }\\n        return sum;\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        // if(n==0)\\n        //  return 0;\\n        // int sum=0;\\n        // while(n/5>0)\\n        // {\\n        //     sum=sum+(n/5);\\n        //     n=n/5;\\n        // }\\n        // return sum;\\n        int sum=0;\\n        while(n>0)\\n        {\\n            n=n/5;\\n            sum = sum + n;\\n         \\n        }\\n        return sum;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872358,
                "title": "simple-c-solution-o-log-n-must-check",
                "content": "\\n\\n**Solution:**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n\\n        for(int i = 5; i<=n;i=i*5)\\n        {\\n            count = count + n/i;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n----\\n\\n**Analysis:**\\n\\n**Time Complexity:** ```O(log n)```\\n\\nwe have the 5^k <=n\\n           \\u2234 5^k = n\\n               k = log n base 5\\n\\n**Space Complexity:** ```O(1)```\\n\\n---\\n\\nIf this solution help you then please ```UPVOTE```.\\nTill then **Keep Learning, Keep Exploring, Keep Growing!!**\\n\\n**Thank You !!**\\n\\n\\n----",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n\\n        for(int i = 5; i<=n;i=i*5)\\n        {\\n            count = count + n/i;\\n        }\\n        return count;\\n    }\\n};\\n```\n```O(log n)```\n```O(1)```\n```UPVOTE```",
                "codeTag": "Java"
            },
            {
                "id": 2789564,
                "title": "c-simple-math-method-to-find-number-of-trailing-zeroes",
                "content": "```\\nint trailingZeroes(int n) {\\n        \\n        int ans = 0, i = 1;\\n        //store [n/5^i] in sum till it becomes zeros\\n        while(pow(5,i) <= n) {\\n            ans += n/pow(5,i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nint trailingZeroes(int n) {\\n        \\n        int ans = 0, i = 1;\\n        //store [n/5^i] in sum till it becomes zeros\\n        while(pow(5,i) <= n) {\\n            ans += n/pow(5,i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2788540,
                "title": "1-line-code-0ms-solution-simple-approach",
                "content": "# Intuition\\nIt\\'s just to notice that on multiplying with which number we will get a trailing zero\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nEvery time we multiply with 5 or powers of 5(25,125,etc) we\\'ll get a trailing zero.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return (n/5)+(n/25)+(n/125)+(n/625)+(n/3125);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return (n/5)+(n/25)+(n/125)+(n/625)+(n/3125);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784206,
                "title": "c-solution-iterative-approach-faster-than-100-of-c-submissions",
                "content": "```\\nint trailingZeroes(int n){\\n    int div = 5, zeros = 0;\\n    while(n/div != 0){\\n        zeros += n/div;\\n        div *= 5;\\n    }\\n    return zeros;\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nint trailingZeroes(int n){\\n    int div = 5, zeros = 0;\\n    while(n/div != 0){\\n        zeros += n/div;\\n        div *= 5;\\n    }\\n    return zeros;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783986,
                "title": "c-solution-1-line-recursive-approach-faster-than-100-of-c-submissions",
                "content": "```\\nint trailingZeroes(int n){\\n    return (n != 0) ? n/5 + trailingZeroes(n/5) : 0;\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nint trailingZeroes(int n){\\n    return (n != 0) ? n/5 + trailingZeroes(n/5) : 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2751198,
                "title": "python3-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        f=1\\n        if n==0 and n==1:\\n            return 0\\n        for i in range(1,n+1):\\n            f*=i\\n        s=str(f)[::-1]\\n        count=0\\n        for i in s:\\n            if i==\"0\":\\n                count+=1\\n            else:\\n                break\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        f=1\\n        if n==0 and n==1:\\n            return 0\\n        for i in range(1,n+1):\\n            f*=i\\n        s=str(f)[::-1]\\n        count=0\\n        for i in s:\\n            if i==\"0\":\\n                count+=1\\n            else:\\n                break\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525213,
                "title": "o-1-time-complexity-one-liner-faster-than-100-easiest-solution-ace-solution",
                "content": "```\\n int trailingZeroes(int n) { \\n      return n/5+n/25+n/125+n/625+n/3125;\\n        }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int trailingZeroes(int n) { \\n      return n/5+n/25+n/125+n/625+n/3125;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2477605,
                "title": "fast-and-easy-solution-in-java-c",
                "content": "```\\npublic int trailingZeroes(int n) {\\n        int ans=0;\\n     \\n        ans+=n/5;\\n        ans+=n/25;\\n        ans+=n/125;\\n        ans+=n/625;\\n        ans+=n/3125;\\n        ans+=n/15625;\\n\\t\\t\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int trailingZeroes(int n) {\\n        int ans=0;\\n     \\n        ans+=n/5;\\n        ans+=n/25;\\n        ans+=n/125;\\n        ans+=n/625;\\n        ans+=n/3125;\\n        ans+=n/15625;\\n\\t\\t\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2453749,
                "title": "runtime-0-ms-faster-than-100-easy-c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/88ba6a0e-25fc-4500-9615-a38e5fdab180_1661003156.9793484.png)\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans = 0, i = 5;\\n        while(n >= i){\\n            ans += (n/i);\\n            i *= 5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans = 0, i = 5;\\n        while(n >= i){\\n            ans += (n/i);\\n            i *= 5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342451,
                "title": "c-power-of-5",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int x=5;\\n        int ans=0;\\n        while(x<=n){\\n            ans+=n/x;\\n            x*=5;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int x=5;\\n        int ans=0;\\n        while(x<=n){\\n            ans+=n/x;\\n            x*=5;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2317387,
                "title": "easy-3-line-sol-100-fast-o-logn",
                "content": "**if u find it useful and good for understanding plz upvote**\\u2B06\\n\\n# Logic :\\n\\n**trailing 0s** in n!= count of` 5s in prime factors of n!`\\n\\n**Ex.** 10!=3628800 it\\'s prime factors are 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 5, 5, 7 here **5 are 2 times means 2 trailing zero.**\\n\\n# Code:\\n\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        \\n    int count=0;\\n    for(int i=5; n/i>=1;i*=5){\\n       count+=n/i;\\n    }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        \\n    int count=0;\\n    for(int i=5; n/i>=1;i*=5){\\n       count+=n/i;\\n    }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312037,
                "title": "0-ms-solution-faster-than-100",
                "content": "int trailingZeroes(int num) {\\n        int denom = 5,  zeroes = 0;\\n        while(num>=denom)\\n        {  \\n            zeroes+=(num/denom);\\n            denom*=5; \\n        }\\n        return zeroes;\\n    }\\n\\t\\n\\t// Every time you divide the given number with denom by updating denom by denom*5 and store the num/denom in zeroes count and return that\\'s it :)\\n\\t\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "int trailingZeroes(int num) {\\n        int denom = 5,  zeroes = 0;\\n        while(num>=denom)\\n        {  \\n            zeroes+=(num/denom);\\n            denom*=5; \\n        }\\n        return zeroes;\\n    }\\n\\t\\n\\t// Every time you divide the given number with denom by updating denom by denom*5 and store the num/denom in zeroes count and return that\\'s it :)\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2195172,
                "title": "java-100-faster-and-92-less-memory",
                "content": "0 will only come in factorial result if there is any pair of 2 * 5 in the products of factorial.\\nFor example : 1 * 2 * 3 * 4 * 5 \\n\\nHere we have single pair of 2 and 5. Number of 2 * 5 pairs means the number times its getting multiplied by 10. Since we get lots of 2 in factorial of higher numbers thus we dont have to worry about 2 and we need to check only number of 5.\\n\\nTherefore number of 5 determines number of trailing zeroes.\\n\\n```\\n public int trailingZeroes(int n) {\\n        int count = 0;\\n        \\n        if(n < 5) {\\n            return 0;\\n        }\\n        \\n        while(n > 1) {\\n            n /= 5;\\n            count += n;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int trailingZeroes(int n) {\\n        int count = 0;\\n        \\n        if(n < 5) {\\n            return 0;\\n        }\\n        \\n        while(n > 1) {\\n            n /= 5;\\n            count += n;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2188758,
                "title": "c-faster-than-100-runtime-0-ms-most-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int res=0;\\n        for(int i=5;i<=n;i=i*5)\\n            res=res+n/i;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int res=0;\\n        for(int i=5;i<=n;i=i*5)\\n            res=res+n/i;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186940,
                "title": "c-python-easy-solution",
                "content": "**Python**\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        x=5\\n        zero=0\\n        while ((n//x)>0):\\n            zero+=(n//x)\\n            x*=5\\n        return(zero) \\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int x=5,zero=0;\\n        while((n/x)>0){\\n            zero+=(n/x);\\n            x*=5;\\n        }\\n        return(zero);\\n    }\\n};\\n```\\n**Space Complexity : O(1)\\nTime Complexity : O(logN)**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        x=5\\n        zero=0\\n        while ((n//x)>0):\\n            zero+=(n//x)\\n            x*=5\\n        return(zero) \\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int x=5,zero=0;\\n        while((n/x)>0){\\n            zero+=(n/x);\\n            x*=5;\\n        }\\n        return(zero);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166652,
                "title": "cpp-easy-code-log-n-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int cnt = 0;\\n        for ( int i = 1 ; i <= n ; i ++){\\n            if ( n / pow ( 5 , i ) <= 0 ) return cnt ;\\n            cnt += ( n / pow( 5 , i ));           \\n        } \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int cnt = 0;\\n        for ( int i = 1 ; i <= n ; i ++){\\n            if ( n / pow ( 5 , i ) <= 0 ) return cnt ;\\n            cnt += ( n / pow( 5 , i ));           \\n        } \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154528,
                "title": "count-the-number-of-trailing-zeros",
                "content": "Factorial of an integer (n) is obtained simply by multiplying of the numbers from 1 upto n (including n).\\n\\nIts obvious that trailing zeros in any number are because of multiplication by 10. \\n\\nSimilarly, While calculating a factorial, If the number gets multiplied by 10 or prime factors whose products is 10, then it will add a trailing zero at the end. \\n\\nEg: factorial of 6 is 720. (1 trailing zeros).\\n\\n*6! = 1 * 2 * 3 * 4 * 5 * 6\\n\\t= 1 * 2 * 3 * (2 * 2) * 5 * (2 * 3)*\\n\\nIn the above prime factors of numbers multiplied in the factorial, we can observe that there are 2s and 5s. Its clear that 2* 5 = 10.  So the combination of 2s and 5s are bringing in all the trailing zeros. \\n\\nHence, \\n    *number of trailing zeros \\n\\t\\t\\t= min (number of 2s in prime factors, number of 5s in prime factors)*\\n\\nNow, it is clear that all even numbers have a factor 2 but only multiples of 5 like 5, 10, 15, etc.. have a factor 5. So it is clear  that there are more number of 2 than 5 in any set of prime factors of factorial.\\n\\nSo the number of 5s will be the obvious minimum which is rather easy to count and may not require complete factorization as such.\\n\\nFor that, simply count the numbers divisible by 5 from 1 to n. There are some numbers which are multiples of higher powers of 5 and hence have more than one 5s in the prime factors. For that, we can count the numbers that are divisible by each higher powers of 5 upto  n. \\nIn summary,\\n\\n*Number of 5s in the prime factors \\n= Count of numbers divisible by 5 + Count of numbers divisible by 25 + Count of numbers divisible by 125 + ...\\n= floor(n/5) + floor(n/25) + floor(n/125) + floor(n/625) + ... until the number inside paranthesis gets to zero.*\\n\\n\\nIts simple Java Solution would be as follows: \\n\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        \\n        int countZeros=0;\\n        \\n        while(n>0)\\n        {\\n            countZeros += n/5;\\n            n/=5; \\n        }\\n\\n        return countZeros;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        \\n        int countZeros=0;\\n        \\n        while(n>0)\\n        {\\n            countZeros += n/5;\\n            n/=5; \\n        }\\n\\n        return countZeros;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568387,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1574696,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1570434,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1571376,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1571377,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 2007404,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1569593,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1975879,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1909361,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 2063628,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1568387,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1574696,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1570434,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1571376,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1571377,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 2007404,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1569593,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1975879,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1909361,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 2063628,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 2057187,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2027477,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2026105,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2026102,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2020202,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1999987,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1972625,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1970226,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1906271,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1879508,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Closest Binary Search Tree Value II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1720910,
                "content": [
                    {
                        "username": "gflanary",
                        "content": "Difficulty should be reexamined. This is a straightforward traversal + heap problem. :/"
                    },
                    {
                        "username": "mullachv",
                        "content": "Add statements to question that the entries in the BST (Node.val) are integers, and the target is a floating point number. Current test harness/solution fails for a BST containing floating point numbers. For e.g: \\n```[4,2,5,1,3,null,7,null,null,2.5,3.14,5.3,7.17],  k = 4```"
                    }
                ]
            },
            {
                "id": 1993769,
                "content": [
                    {
                        "username": "gflanary",
                        "content": "Difficulty should be reexamined. This is a straightforward traversal + heap problem. :/"
                    },
                    {
                        "username": "mullachv",
                        "content": "Add statements to question that the entries in the BST (Node.val) are integers, and the target is a floating point number. Current test harness/solution fails for a BST containing floating point numbers. For e.g: \\n```[4,2,5,1,3,null,7,null,null,2.5,3.14,5.3,7.17],  k = 4```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Super Pow",
        "question_content": "<p>Your task is to calculate <code>a<sup>b</sup></code> mod <code>1337</code> where <code>a</code> is a positive integer and <code>b</code> is an extremely large positive integer given in the form of an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = 2, b = [3]\n<strong>Output:</strong> 8\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = 2, b = [1,0]\n<strong>Output:</strong> 1024\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = 1, b = [4,3,3,8,5,2]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 &lt;= b.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= b[i] &lt;= 9</code></li>\n\t<li><code>b</code> does not contain leading zeros.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 84472,
                "title": "c-clean-and-short-solution",
                "content": "One knowledge:  ab % k = (a%k)(b%k)%k\\nSince the power here is an array, we'd better handle it digit by digit.\\nOne observation:\\na^1234567 % k = (a^1234560 % k) * (a^7 % k) % k = (a^123456 % k)^10 % k * (a^7 % k) % k\\nLooks complicated? Let me put it  other way:\\nSuppose f(a, b) calculates a^b % k; Then translate above formula to using f :\\nf(a,1234567) = f(a, 1234560) * f(a, 7) % k = f(f(a, 123456),10) * f(a,7)%k;\\nImplementation of this idea:\\n```\\nclass Solution {\\n    const int base = 1337;\\n    int powmod(int a, int k) //a^k mod 1337 where 0 <= k <= 10\\n    {\\n        a %= base;\\n        int result = 1;\\n        for (int i = 0; i < k; ++i)\\n            result = (result * a) % base;\\n        return result;\\n    }\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        if (b.empty()) return 1;\\n        int last_digit = b.back();\\n        b.pop_back();\\n        return powmod(superPow(a, b), 10) * powmod(a, last_digit) % base;\\n    }\\n};\\n```\\n**Note:** This approach is definitely not the fastest, but it is something one can quickly understand and write out when asked in an interview. \\nAnd this approach is not using any built-in \"pow\" functions, I think this is also what the interviewer would expect you to do.\\nHope it helps!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    const int base = 1337;\\n    int powmod(int a, int k) //a^k mod 1337 where 0 <= k <= 10\\n    {\\n        a %= base;\\n        int result = 1;\\n        for (int i = 0; i < k; ++i)\\n            result = (result * a) % base;\\n        return result;\\n    }\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        if (b.empty()) return 1;\\n        int last_digit = b.back();\\n        b.pop_back();\\n        return powmod(superPow(a, b), 10) * powmod(a, last_digit) % base;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84466,
                "title": "math-solusion-based-on-euler-s-theorem-power-called-only-once-c-java-1-line-python",
                "content": "1337 only has two divisors 7 and 191 exclusive 1 and itself, so judge if `a` has a divisor of 7 or 191, and note that 7 and 191 are prime numbers, `phi` of them is itself - 1, then we can use the Euler's theorem, see it on wiki https://en.wikipedia.org/wiki/Euler%27s_theorem, it's just [Fermat's little theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem) if the mod `n` is prime.\\n\\nsee how 1140 is calculated out:\\nphi(1337) = phi(7) * phi(191) = 6 * 190 = 1140\\n\\n\\n**optimized solution update at 2016-7-12**\\n--------------------------------\\nToday, seeing @myanonymos 's comments, and I find several days ago I AC it just by fortunate coincidence, it's not the best solution. now I get a better idea.\\n\\n(1)  Firstly,  if `a` has both divisor 7 and 191, that's `a % 1337 == 0`, answer is 0.\\n(2)  Then if `a` has neither divisor 7 nor 191, that's a and 1337 are coprime, so **a<sup>b</sup> % 1337 = a<sup>b % phi(1337) </sup> % 1337 = a<sup>b % 1140 </sup> % 1337**.\\n\\n(3)  Finally,  `a` could has either divisor 7 or 191, that's similar.\\nLet it be 7 for example.\\nLet **a =  7<sup>n</sup>x**\\nand let **b = 1140p + q**, where **0 < q <= 1140**\\nthen:\\n\\n**a<sup>b</sup> % 1337**\\n**= ((7<sup>n</sup>x)<sup>b</sup>) % 1337**\\n**= (7<sup>nb</sup>x<sup>b</sup>) % 1337**\\n**= ( (7<sup>nb</sup> % 1337) * (x<sup>b</sup> % 1337) ) % 1337**\\n**= ( (7<sup>1140np + nq</sup> % 1337) * (x<sup>1140p + q</sup> % 1337) ) % 1337**\\n\\nnow note x and 1337 are coprime, so\\n\\n**= ( (7<sup>1140np + nq</sup> % 1337) * (x<sup>q</sup> % 1337) ) % 1337**\\n**= ( 7 * (7<sup>1140np + nq - 1</sup> % 191) * (x<sup>q</sup> % 1337) ) % 1337**\\n\\nnote 7 and 191 are coprime too, and 1140 is a multiple of 190, where 190 = phi(191). What's more we should assure that q != 0, if b % 1140== 0, then let b = 1140. so\\n\\n**= ( 7 * (7<sup>nq - 1</sup> % 191) * (x<sup>q</sup> % 1337) ) % 1337**\\n**= ( (7<sup>nq</sup> % 1337) * (x<sup>q</sup> % 1337) ) % 1337**\\n**= (7<sup>nq</sup>x<sup>q</sup>) % 1337**\\n**= ((7<sup>n</sup>x)<sup>q</sup>) % 1337**\\n**= (a<sup>q</sup>) % 1337**\\n\\nnow you see condition (2) and (3) can be merged as one solution, if you take care of when `b % 1440 == 0`, and let `b += 1140`. Actually (1) can be merged too, but not efficient.\\n\\n\\nnew code:\\nC++:\\n\\n    int superPow(int a, vector<int>& b) {\\n        if (a % 1337 == 0) return 0; // this line could also be removed\\n        int p = 0;\\n        for (int i : b) p = (p * 10 + i) % 1140;\\n        if (p == 0) p += 1140;\\n        return power(a, p, 1337);\\n    }\\n    int power(int x, int n, int mod) {\\n        int ret = 1;\\n        for (x %= mod; n; x = x * x % mod, n >>= 1) if (n & 1) ret = ret * x % mod;\\n        return ret;\\n    }\\n\\njava:\\n\\n    public int superPow(int a, int[] b) {\\n        if (a % 1337 == 0) return 0;\\n        int p = 0;\\n        for (int i : b) p = (p * 10 + i) % 1140;\\n        if (p == 0) p += 1440;\\n        return power(a, p, 1337);\\n    }\\n    public int power(int a, int n, int mod) {\\n        a %= mod;\\n        int ret = 1;\\n        while (n != 0) {\\n            if ((n & 1) != 0) ret = ret * a % mod;\\n            a = a * a % mod;\\n            n >>= 1;\\n        }\\n        return ret;\\n    }\\n\\nActually, if p == 0 or not, we can always let p += 1140, it doesn't matter.\\none line python:\\n\\n    def superPow(self, a, b):\\n        return 0 if a % 1337 == 0 else pow(a, reduce(lambda x, y: (x * 10 + y) % 1140, b) + 1140, 1337)\\n\\n**will this be the best solution?**\\n\\np.s.\\nI have testcases that the system missed\\n574\\n[1,1,4,0]\\n\\n764\\n[1,1,4,0]\\nin this case if I remove this line of code `if (p == 0) p += 1140;`, it will get wrong answer, but also can get AC on OJ.\\n\\nand I found thar 574 * 574 % 1337 = 574, 764 * 764 % 1337 = 764, how interesting!",
                "solutionTags": [],
                "code": "1337 only has two divisors 7 and 191 exclusive 1 and itself, so judge if `a` has a divisor of 7 or 191, and note that 7 and 191 are prime numbers, `phi` of them is itself - 1, then we can use the Euler's theorem, see it on wiki https://en.wikipedia.org/wiki/Euler%27s_theorem, it's just [Fermat's little theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem) if the mod `n` is prime.\\n\\nsee how 1140 is calculated out:\\nphi(1337) = phi(7) * phi(191) = 6 * 190 = 1140\\n\\n\\n**optimized solution update at 2016-7-12**\\n--------------------------------\\nToday, seeing @myanonymos 's comments, and I find several days ago I AC it just by fortunate coincidence, it's not the best solution. now I get a better idea.\\n\\n(1)  Firstly,  if `a` has both divisor 7 and 191, that's `a % 1337 == 0`, answer is 0.\\n(2)  Then if `a` has neither divisor 7 nor 191, that's a and 1337 are coprime, so **a<sup>b</sup> % 1337 = a<sup>b % phi(1337) </sup> % 1337 = a<sup>b % 1140 </sup> % 1337**.\\n\\n(3)  Finally,  `a` could has either divisor 7 or 191, that's similar.\\nLet it be 7 for example.\\nLet **a =  7<sup>n</sup>x**\\nand let **b = 1140p + q**, where **0 < q <= 1140**\\nthen:\\n\\n**a<sup>b</sup> % 1337**\\n**= ((7<sup>n</sup>x)<sup>b</sup>) % 1337**\\n**= (7<sup>nb</sup>x<sup>b</sup>) % 1337**\\n**= ( (7<sup>nb</sup> % 1337) * (x<sup>b</sup> % 1337) ) % 1337**\\n**= ( (7<sup>1140np + nq</sup> % 1337) * (x<sup>1140p + q</sup> % 1337) ) % 1337**\\n\\nnow note x and 1337 are coprime, so\\n\\n**= ( (7<sup>1140np + nq</sup> % 1337) * (x<sup>q</sup> % 1337) ) % 1337**\\n**= ( 7 * (7<sup>1140np + nq - 1</sup> % 191) * (x<sup>q</sup> % 1337) ) % 1337**\\n\\nnote 7 and 191 are coprime too, and 1140 is a multiple of 190, where 190 = phi(191). What's more we should assure that q != 0, if b % 1140== 0, then let b = 1140. so\\n\\n**= ( 7 * (7<sup>nq - 1</sup> % 191) * (x<sup>q</sup> % 1337) ) % 1337**\\n**= ( (7<sup>nq</sup> % 1337) * (x<sup>q</sup> % 1337) ) % 1337**\\n**= (7<sup>nq</sup>x<sup>q</sup>) % 1337**\\n**= ((7<sup>n</sup>x)<sup>q</sup>) % 1337**\\n**= (a<sup>q</sup>) % 1337**\\n\\nnow you see condition (2) and (3) can be merged as one solution, if you take care of when `b % 1440 == 0`, and let `b += 1140`. Actually (1) can be merged too, but not efficient.\\n\\n\\nnew code:\\nC++:\\n\\n    int superPow(int a, vector<int>& b) {\\n        if (a % 1337 == 0) return 0; // this line could also be removed\\n        int p = 0;\\n        for (int i : b) p = (p * 10 + i) % 1140;\\n        if (p == 0) p += 1140;\\n        return power(a, p, 1337);\\n    }\\n    int power(int x, int n, int mod) {\\n        int ret = 1;\\n        for (x %= mod; n; x = x * x % mod, n >>= 1) if (n & 1) ret = ret * x % mod;\\n        return ret;\\n    }\\n\\njava:\\n\\n    public int superPow(int a, int[] b) {\\n        if (a % 1337 == 0) return 0;\\n        int p = 0;\\n        for (int i : b) p = (p * 10 + i) % 1140;\\n        if (p == 0) p += 1440;\\n        return power(a, p, 1337);\\n    }\\n    public int power(int a, int n, int mod) {\\n        a %= mod;\\n        int ret = 1;\\n        while (n != 0) {\\n            if ((n & 1) != 0) ret = ret * a % mod;\\n            a = a * a % mod;\\n            n >>= 1;\\n        }\\n        return ret;\\n    }\\n\\nActually, if p == 0 or not, we can always let p += 1140, it doesn't matter.\\none line python:\\n\\n    def superPow(self, a, b):\\n        return 0 if a % 1337 == 0 else pow(a, reduce(lambda x, y: (x * 10 + y) % 1140, b) + 1140, 1337)\\n\\n**will this be the best solution?**\\n\\np.s.\\nI have testcases that the system missed\\n574\\n[1,1,4,0]\\n\\n764\\n[1,1,4,0]\\nin this case if I remove this line of code `if (p == 0) p += 1140;`, it will get wrong answer, but also can get AC on OJ.\\n\\nand I found thar 574 * 574 % 1337 = 574, 764 * 764 % 1337 = 764, how interesting!",
                "codeTag": "Python3"
            },
            {
                "id": 84534,
                "title": "1-liners-other-with-explanations",
                "content": "## Solution 1: Using Python's big integers <sup>(accepted in 72 ms)</sup>\\n\\nTurn `b` into a Python integer object (they grow arbitrarily large) and just use the `pow` function (which supports a modulo paramenter).\\n\\n    def superPow(self, a, b):\\n        return pow(a, int(''.join(map(str, b))), 1337)\\n\\n<br>\\n## Solution 2: Using small ints <sup>(accepted in 80 ms)</sup>\\n\\nOriginally I went backwards (see solution 5) but then I saw other people go forwards and it's simpler. Sigh. Anyway... my version:\\n\\n    def superPow(self, a, b):\\n        result = 1\\n        for digit in b:\\n            result = pow(result, 10, 1337) * pow(a, digit, 1337) % 1337\\n        return result\\n\\nExplanation: For example for a<sup>5347</sup>, the above computes a<sup>5</sup>, then a<sup>53</sup>, then a<sup>534</sup>, and then finally a<sup>5347</sup>. And a step from one to the next can be done like a<sup>5347</sup> = (a<sup>534</sup>)<sup>10</sup> \\\\* a<sup>7</sup>.\\n\\n<br>\\n## Solution 3: Using recursion <sup>(accepted in 92 ms)</sup>\\n\\nObligatory recursive oneliner version of solution 2.\\n\\n    def superPow(self, a, b):\\n        return pow(a, b.pop(), 1337) * pow(self.superPow(a, b), 10, 1337) % 1337 if b else 1\\n\\n<br>\\n## Solution 4: Using `reduce` <sup>(accepted in 80 ms)</sup>\\n\\nObligatory `reduce`-oneliner version of solution 2.\\n\\n    def superPow(self, a, b):\\n        return reduce(lambda result, digit: pow(result, 10, 1337) * pow(a, digit, 1337) % 1337, b, 1)\\n\\n<br>\\n## Solution 5: omg was i stupid <sup>(accepted in 72 ms)\\n\\nMy original do-it-yourself before I saw other people's solutions and wrote solutions 2-4.\\n\\nUsing only small ints, also accepted in 72 ms:\\n\\n    def superPow(self, a, b):\\n        result = 1\\n        apower = a\\n        for digit in reversed(b):\\n            result = result * pow(apower, digit, 1337) % 1337\\n            apower = pow(apower, 10, 1337)\\n        return result\\n\\nExplanation by example:\\n\\na<sup>**5347**</sup>\\n= a<sup>5000</sup> * a<sup>300</sup> * a<sup>40</sup> * a<sup>7</sup>\\n= (a<sup>1000</sup>)<sup>5</sup> * (a<sup>100</sup>)<sup>3</sup> * (a<sup>10</sup>)<sup>4</sup> * a<sup>7</sup>\\n= (((a<sup>10</sup>)<sup>10</sup>)<sup>10</sup>)<sup>**5**</sup> * ((a<sup>10</sup>)<sup>10</sup>)<sup>**3**</sup> * (a<sup>10</sup>)<sup>**4**</sup> * a<sup>**7**</sup>\\n\\nComputing that from back to front is straightforward (or straightbackward?).",
                "solutionTags": [
                    "Python"
                ],
                "code": "## Solution 1: Using Python's big integers <sup>(accepted in 72 ms)</sup>\\n\\nTurn `b` into a Python integer object (they grow arbitrarily large) and just use the `pow` function (which supports a modulo paramenter).\\n\\n    def superPow(self, a, b):\\n        return pow(a, int(''.join(map(str, b))), 1337)\\n\\n<br>\\n## Solution 2: Using small ints <sup>(accepted in 80 ms)</sup>\\n\\nOriginally I went backwards (see solution 5) but then I saw other people go forwards and it's simpler. Sigh. Anyway... my version:\\n\\n    def superPow(self, a, b):\\n        result = 1\\n        for digit in b:\\n            result = pow(result, 10, 1337) * pow(a, digit, 1337) % 1337\\n        return result\\n\\nExplanation: For example for a<sup>5347</sup>, the above computes a<sup>5</sup>, then a<sup>53</sup>, then a<sup>534</sup>, and then finally a<sup>5347</sup>. And a step from one to the next can be done like a<sup>5347</sup> = (a<sup>534</sup>)<sup>10</sup> \\\\* a<sup>7</sup>.\\n\\n<br>\\n## Solution 3: Using recursion <sup>(accepted in 92 ms)</sup>\\n\\nObligatory recursive oneliner version of solution 2.\\n\\n    def superPow(self, a, b):\\n        return pow(a, b.pop(), 1337) * pow(self.superPow(a, b), 10, 1337) % 1337 if b else 1\\n\\n<br>\\n## Solution 4: Using `reduce` <sup>(accepted in 80 ms)</sup>\\n\\nObligatory `reduce`-oneliner version of solution 2.\\n\\n    def superPow(self, a, b):\\n        return reduce(lambda result, digit: pow(result, 10, 1337) * pow(a, digit, 1337) % 1337, b, 1)\\n\\n<br>\\n## Solution 5: omg was i stupid <sup>(accepted in 72 ms)\\n\\nMy original do-it-yourself before I saw other people's solutions and wrote solutions 2-4.\\n\\nUsing only small ints, also accepted in 72 ms:\\n\\n    def superPow(self, a, b):\\n        result = 1\\n        apower = a\\n        for digit in reversed(b):\\n            result = result * pow(apower, digit, 1337) % 1337\\n            apower = pow(apower, 10, 1337)\\n        return result\\n\\nExplanation by example:\\n\\na<sup>**5347**</sup>\\n= a<sup>5000</sup> * a<sup>300</sup> * a<sup>40</sup> * a<sup>7</sup>\\n= (a<sup>1000</sup>)<sup>5</sup> * (a<sup>100</sup>)<sup>3</sup> * (a<sup>10</sup>)<sup>4</sup> * a<sup>7</sup>\\n= (((a<sup>10</sup>)<sup>10</sup>)<sup>10</sup>)<sup>**5**</sup> * ((a<sup>10</sup>)<sup>10</sup>)<sup>**3**</sup> * (a<sup>10</sup>)<sup>**4**</sup> * a<sup>**7**</sup>\\n\\nComputing that from back to front is straightforward (or straightbackward?).",
                "codeTag": "Python3"
            },
            {
                "id": 84479,
                "title": "java-4ms-solution-using-the-remainder-repeat-pattern",
                "content": "The main idea is cashed on the repeated pattern of the remainder of **a^b**.\\nAs long as we know the length of the pattern **m**, we just have to find an index point of this pattern based on **b mod m**. \\nIn addition, if **a > 1337**, we can let **a = a mod 1337**. \\nBecause if we let a = (1337*x + c) where c = a mod 1337,\\n(1337*x + c)(1337*x + c)(1337*x + c)...(1337*x + c) mod 1337 == c*c*c*...c mod 1337.  \\n\\n````\\npublic class Solution {\\n    int DIV = 1337;\\n    \\n    List<Integer> findLoop(int a){\\n        List<Integer> index = new ArrayList<>();\\n        boolean[] set = new boolean[DIV];\\n        int rem = a % DIV;\\n        while ( ! set[rem] ) {\\n            set[rem]=true;\\n            index.add(rem);\\n            rem = (rem*a) % DIV;\\n        }\\n        return index;\\n    }\\n    \\n    int modBy(int[] b, int m){\\n        int rem = 0;\\n        for (int i=0; i < b.length; i++) {\\n            rem = (rem*10+b[i]) % m;\\n        }\\n        return rem;\\n    }\\n\\n    public int superPow(int a, int[] b) {\\n        if (a==0 || a==DIV || b==null || b.length == 0) return 0;\\n        if (a==1) return 1;\\n        if (a > DIV) return superPow( a % DIV, b);\\n        List<Integer> index = findLoop(a);\\n        int loopsize = index.size();\\n        int rem = modBy(b, loopsize);\\n        rem = rem==0? loopsize: rem;\\n        return index.get(rem-1);\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\npublic class Solution {\\n    int DIV = 1337;\\n    \\n    List<Integer> findLoop(int a){\\n        List<Integer> index = new ArrayList<>();\\n        boolean[] set = new boolean[DIV];\\n        int rem = a % DIV;\\n        while ( ! set[rem] ) {\\n            set[rem]=true;\\n            index.add(rem);\\n            rem = (rem*a) % DIV;\\n        }\\n        return index;\\n    }\\n    \\n    int modBy(int[] b, int m){\\n        int rem = 0;\\n        for (int i=0; i < b.length; i++) {\\n            rem = (rem*10+b[i]) % m;\\n        }\\n        return rem;\\n    }\\n\\n    public int superPow(int a, int[] b) {\\n        if (a==0 || a==DIV || b==null || b.length == 0) return 0;\\n        if (a==1) return 1;\\n        if (a > DIV) return superPow( a % DIV, b);\\n        List<Integer> index = findLoop(a);\\n        int loopsize = index.size();\\n        int rem = modBy(b, loopsize);\\n        rem = rem==0? loopsize: rem;\\n        return index.get(rem-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84475,
                "title": "fermat-and-chinese-remainder",
                "content": "If the modulus weren't 1337 = 7 * 191 but a prime number p, we could use [Fermat's little theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem) to first reduce the exponent to **e = b % (p-1)** and then compute the result as **a<sup>e</sup> % p**. Oh well, we can do it for 1337's prime factors 7 and 191 and then combine the two results with the [Chinese remainder theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem). I'll show my derivation of the magic constants 764 and 574 after the solutions below.\\n\\nI got the solution using Fermat from @Stomach_ache (thanks) and only added the Chinese remainder theorem stuff to adapt it to non-primes like 1337.\\n\\n## Solution 1: Python \"golf\"\\n\\nThe helper computes **a<sup>b</sup>** modulo the prime `p`.\\n\\n    def superPow(self, a, b):\\n        def mod(p):\\n            return pow(a, reduce(lambda e, d: (10*e + d) % (p-1), b, 0), p) if a%p else 0\\n        return (764 * mod(7) + 574 * mod(191)) % 1337\\n\\n## Solution 2: C++\\n\\nThe helper computes **a<sup>b</sup>** modulo the given prime.\\n\\n    int superPow(int a, vector<int>& b) {\\n        return (764 * superPow(a, b, 7) + 574 * superPow(a, b, 191)) % 1337;\\n    }\\n\\n    int superPow(int a, vector<int>& b, int prime) {\\n        if (!(a %= prime)) return 0;\\n        int e = 0, mod = prime - 1;\\n        for (int digit : b)\\n            e = (e * 10 + digit) % mod;\\n        int pow = 1;\\n        while (e) {\\n            if (e & 1)\\n                pow = pow * a % prime;\\n            a = a * a % prime;\\n            e >>= 1;\\n        }\\n        return pow;\\n    }\\n\\n## Using the Chinese Remainder Theorem\\n\\nLet's call **x = a<sup>b</sup>**. We want to know **x % 1337**. The helper function using Fermat already gave us **u** and **w** so that **x % 7 = u** and **x % 191 = w**. Or put differently, **x \\u2261 u (mod 7)** and **x = w + 191t** for some integer **t**. Combine these to get **w + 191t \\u2261 u (mod 7)**. Subtracting **w** and multiplying with [191<sup>-1</sup>]<sub>7</sub> (the multiplicative inverse of 191 modulo 7) we get **t \\u2261 (u-w)\\xb7[191<sup>-1</sup>]<sub>7</sub> (mod 7)**.\\n\\nWe have  [191<sup>-1</sup>]<sub>7</sub> = [(191%7)<sup>-1</sup>]<sub>7</sub> = [2<sup>-1</sup>]<sub>7</sub> and one can easily see that the latter is 4, as (2*4)%7=1.\\n\\nUsing that, we have **t \\u2261 4(u-w) (mod 7)** or in other words **t = 4(u-w) + 7s** for some integer **s**. Which means:\\n\\n **x = w + 191t\\n = w + 191(4(u-w) + 7s)\\n= 764u - 763w + 1337s\\n= 764u + (1337-763)w + 1337(s-w)\\n= 764u + 574w + 1337(s-w)**\\n\\nSo we can compute **x** from **u** and **v** as **x = (764u + 574w) % 1337**, like I have done in my solutions.",
                "solutionTags": [],
                "code": "If the modulus weren't 1337 = 7 * 191 but a prime number p, we could use [Fermat's little theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem) to first reduce the exponent to **e = b % (p-1)** and then compute the result as **a<sup>e</sup> % p**. Oh well, we can do it for 1337's prime factors 7 and 191 and then combine the two results with the [Chinese remainder theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem). I'll show my derivation of the magic constants 764 and 574 after the solutions below.\\n\\nI got the solution using Fermat from @Stomach_ache (thanks) and only added the Chinese remainder theorem stuff to adapt it to non-primes like 1337.\\n\\n## Solution 1: Python \"golf\"\\n\\nThe helper computes **a<sup>b</sup>** modulo the prime `p`.\\n\\n    def superPow(self, a, b):\\n        def mod(p):\\n            return pow(a, reduce(lambda e, d: (10*e + d) % (p-1), b, 0), p) if a%p else 0\\n        return (764 * mod(7) + 574 * mod(191)) % 1337\\n\\n## Solution 2: C++\\n\\nThe helper computes **a<sup>b</sup>** modulo the given prime.\\n\\n    int superPow(int a, vector<int>& b) {\\n        return (764 * superPow(a, b, 7) + 574 * superPow(a, b, 191)) % 1337;\\n    }\\n\\n    int superPow(int a, vector<int>& b, int prime) {\\n        if (!(a %= prime)) return 0;\\n        int e = 0, mod = prime - 1;\\n        for (int digit : b)\\n            e = (e * 10 + digit) % mod;\\n        int pow = 1;\\n        while (e) {\\n            if (e & 1)\\n                pow = pow * a % prime;\\n            a = a * a % prime;\\n            e >>= 1;\\n        }\\n        return pow;\\n    }\\n\\n## Using the Chinese Remainder Theorem\\n\\nLet's call **x = a<sup>b</sup>**. We want to know **x % 1337**. The helper function using Fermat already gave us **u** and **w** so that **x % 7 = u** and **x % 191 = w**. Or put differently, **x \\u2261 u (mod 7)** and **x = w + 191t** for some integer **t**. Combine these to get **w + 191t \\u2261 u (mod 7)**. Subtracting **w** and multiplying with [191<sup>-1</sup>]<sub>7</sub> (the multiplicative inverse of 191 modulo 7) we get **t \\u2261 (u-w)\\xb7[191<sup>-1</sup>]<sub>7</sub> (mod 7)**.\\n\\nWe have  [191<sup>-1</sup>]<sub>7</sub> = [(191%7)<sup>-1</sup>]<sub>7</sub> = [2<sup>-1</sup>]<sub>7</sub> and one can easily see that the latter is 4, as (2*4)%7=1.\\n\\nUsing that, we have **t \\u2261 4(u-w) (mod 7)** or in other words **t = 4(u-w) + 7s** for some integer **s**. Which means:\\n\\n **x = w + 191t\\n = w + 191(4(u-w) + 7s)\\n= 764u - 763w + 1337s\\n= 764u + (1337-763)w + 1337(s-w)\\n= 764u + 574w + 1337(s-w)**\\n\\nSo we can compute **x** from **u** and **v** as **x = (764u + 574w) % 1337**, like I have done in my solutions.",
                "codeTag": "Python3"
            },
            {
                "id": 84467,
                "title": "simple-python-solution-using-recursion",
                "content": "Here we use the following two properties:\\n* `n1*n2 % 1337 == (n1 % 1337)*(n2 % 1337) % 1337`\\n* If `b = m*10 + d`,  we have `a**b == (a**d)*(a**10)**m`\\n```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        if not b:\\n            return 1\\n        return pow(a, b.pop(), 1337)*self.superPow(pow(a, 10, 1337), b)%1337\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        if not b:\\n            return 1\\n        return pow(a, b.pop(), 1337)*self.superPow(pow(a, 10, 1337), b)%1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673733,
                "title": "cpp-solution-full-explained-esay-to-understand",
                "content": "***Resources: https://github.com/AJAYKR00KJ/LeetCode_Solution***\\n\\nTake a brief observation:\\na=2 , n=[5,4,3,2,1]\\nWe have to find 2^(54321)%1337\\nBasic Rule: (a * b)%c = (a%c * b%c )%c\\n\\nNow , 2^(54321) = 2^(54320) * 2^1\\n                            = ((2^5432)^10) * 2^1\\n\\t\\t\\t\\t\\t\\t\\t= ([((2^5430) * (2^2)]^10) * 2^1\\n\\t\\t\\t\\t\\t\\t\\t= [ [ 2^543] ^ 10 * 2^2 ] ^ 10 * 2^1\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t.\\n\\t\\t\\t\\t\\t\\t\\t=[[[(2^**5**)^10 * 2^**4** ]^10 * 2^**3** ] ^10 ] * 2^**2** ] ^ 10 * 2^**1**\\n\\t\\t\\t\\t\\t\\t\\tDont forgot to use multiplication mod property , I have not added that one in explanation\\n\\t\\t\\t\\t\\t\\t\\tBelow is the implementation of this explain\\n```\\nclass Solution {\\npublic:\\n       int find(int a,int b)\\n       {\\n           a%=1337;\\n           int res=1;\\n           for(int i=0;i<b;i++)\\n           {\\n              res*=a;\\n               res%=1337;\\n           }\\n           return res;\\n       }\\n    int superPow(int a, vector<int>& b) { \\n        int res=1,x,f;\\n        for(int i=0;i<b.size();i++)\\n        {\\n             x=find(a,b[i]);\\n             x*=res;\\n             x%=1337;\\n             f=x;\\n             x=find(x,10);\\n             res=x;\\n        }\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       int find(int a,int b)\\n       {\\n           a%=1337;\\n           int res=1;\\n           for(int i=0;i<b;i++)\\n           {\\n              res*=a;\\n               res%=1337;\\n           }\\n           return res;\\n       }\\n    int superPow(int a, vector<int>& b) { \\n        int res=1,x,f;\\n        for(int i=0;i<b.size();i++)\\n        {\\n             x=find(a,b[i]);\\n             x*=res;\\n             x%=1337;\\n             f=x;\\n             x=find(x,10);\\n             res=x;\\n        }\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2412552,
                "title": "java-binary-exponentiation-euler-totient-function-etf-with-explanation",
                "content": "**Runtime: 2 ms, faster than 94.43% of Java online submissions for Super Pow.\\nMemory Usage: 45.1 MB, less than 83.62% of Java online submissions for Super Pow.**\\n```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        int num=0;\\n        for(int i:b){\\n            num=(num*10+i)%1140;\\n        }\\n        return binexpo(a,num,1337);\\n    }\\n    public int binexpo(int a, int b, int m){\\n        a%=m;\\n        int res=1;\\n        while(b>0){\\n            if((b&1)==1)\\n                res=(res*a)%m;\\n            a=(a*a)%m;\\n            b>>=1;\\n        }\\n        return res;\\n    }\\n}\\n```\\n**Euler theorem = (a^(b%\\u03A6(m)))%m. Basically in Euler Totient Function we count the number less than m (here it\\'s 1337) which are coprime with m i.e gcd(m,{1,2,....,m-1})=1. So to count the number of coprimes we need to use a formula i.e \\u03A6(m)=m*\\u220F (1-(1/p)) where m is 1337 here, p is all the distinct prime factors of m (here it is 7 and 191 for 1337). So \\u03A6(m)=1337*(1-(1/7))*(1-(1/191)) which is equal to 1140 so now its (a^(b%1140))%m so, we will take the elements of array and convert it into number by continuosly doing mod 1140. After that use modular binary exponentiation to calculate the result.If you don\\'t know what is binary exponentiation then go to this famous website and study about it or you can check about it on youtube as well. Link of the website :- https://cp-algorithms.com/algebra/binary-exp.html.**\\n\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        int num=0;\\n        for(int i:b){\\n            num=(num*10+i)%1140;\\n        }\\n        return binexpo(a,num,1337);\\n    }\\n    public int binexpo(int a, int b, int m){\\n        a%=m;\\n        int res=1;\\n        while(b>0){\\n            if((b&1)==1)\\n                res=(res*a)%m;\\n            a=(a*a)%m;\\n            b>>=1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84485,
                "title": "8ms-java-solution-using-fast-power",
                "content": "```\\nprivate static final int M = 1337;\\n\\n    public int normalPow(int a, int b) {\\n        int result = 1;\\n        while (b != 0) {\\n            if (b % 2 != 0)\\n                result = result * a % M;\\n            a = a * a % M;\\n            b /= 2;\\n        }\\n        return result;\\n    }\\n\\n    public int superPow(int a, int[] b) {\\n        a %= M;\\n        int result = 1;\\n        for (int i = b.length - 1; i >= 0; i--) {\\n            result = result * normalPow(a, b[i]) % M;\\n            a = normalPow(a, 10);\\n        }\\n        return result;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\nprivate static final int M = 1337;\\n\\n    public int normalPow(int a, int b) {\\n        int result = 1;\\n        while (b != 0) {\\n            if (b % 2 != 0)\\n                result = result * a % M;\\n            a = a * a % M;\\n            b /= 2;\\n        }\\n        return result;\\n    }\\n\\n    public int superPow(int a, int[] b) {\\n        a %= M;\\n        int result = 1;\\n        for (int i = b.length - 1; i >= 0; i--) {\\n            result = result * normalPow(a, b[i]) % M;\\n            a = normalPow(a, 10);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1197792,
                "title": "8-lines-cpp-clean",
                "content": "```\\n int pow(int a, int b){\\n        if(b==0) return 1;\\n        int temp=pow(a,b/2);\\n        if(b%2==0) return ((temp%1337)*temp%1337)%1337;\\n        else return (a%1337*((temp%1337*temp%1337)%1337))%1337;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        if(b.size()==0) return 1;\\n        int x=b.back(); b.pop_back();\\n        return pow(superPow(a, b), 10) * pow(a, x) % 1337;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int pow(int a, int b){\\n        if(b==0) return 1;\\n        int temp=pow(a,b/2);\\n        if(b%2==0) return ((temp%1337)*temp%1337)%1337;\\n        else return (a%1337*((temp%1337*temp%1337)%1337))%1337;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        if(b.size()==0) return 1;\\n        int x=b.back(); b.pop_back();\\n        return pow(superPow(a, b), 10) * pow(a, x) % 1337;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 400893,
                "title": "python-3-with-explanation-handles-all-test-cases-one-line-beats-97",
                "content": "_Explanation:_\\n\\nThis program is based on [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem) which states that: a^( phi(n) ) = 1 (mod n), where phi(n) is Euler\\'s Totient Function, provided that a and n are relatively prime (meaning they have no common factors). In our case, n = 1337, which has prime factorization 1337 = 7 x 191. We know that phi(p) = p - 1 when p is prime and also that phi(p x q) = phi(p) x phi(q). Thus it follows that phi(1337) = phi(7 x 191) = phi(7) x phi(191) = 6 x 190 = 1140. Thus, using Euler\\'s Theorem it follows that a^1140 = 1 (mod 1337), provided that a and 1337 have no common factors. Since 1337 only has two factors, 7 and 191, it follows that a^1140 = 1 (mod 1337), provided that a is not divisible by 7 or 191. This makes sense intuitively because one can only find an inverse of a number (mod n), if the number is relatively prime to n. No multiple of 7 or 191 will ever be congruent to 1 mod 1337 because they are factors of 1337. The closest you can get to 1 mod 1337, is getting 0 mod 1337. For this reason, it is very important that we never allow 1 to be the answer in the case when a is divisible by 7 or 9 since that doesn\\'t make sense.\\n\\nSince a^1140 = 1 (mod 1337), provided that a is not divisible by 7 or 191, it follows that if we write b = 1140q + r (where q is the quotient and r is the remainder after dividing b by 1140), then a^b = a^(1140q + r) = a^(1140q) x a^r = (a^1140)^q x a^r = 1^q x a^r = a^r (mod 1337). Thus if we reduce b (mod 1337) we can find the answer to a^b by instead just doing a^r (i.e. a^(b % 1337)). Furthermore since we want our answer mod 1337, it is wise to reduce a mod 1337 to keep the numbers smaller. Thus, provided that a is not divisible by 7 or 191, it follows by Euler\\'s Theorem that a^b = (a %1337)^(b % 1140) % 1337.\\n\\nHowever, we must carefuly reflect on the case when a is divisible by 7 or 191. If it is divisible by both, then obviously a mod 1337 is 0 and our answer is 0. However, if it is divisisble by one of them and if b = 0 mod 1140 (i.e. b is a multiple of 1140), then our problem would reduce to (7n)^0 = 1 (mod 1337) or (191m)^0 = 1 (mod 1337). These are obviously wrong because a multiple of 7 or 191 can never be congruent to 1 mod 1337. They are also an impermissible application of Euler\\'s Theorem because Euler\\'s Theorem requires that a and n be relatively prime. The way around this issue is to be careful to not use r = 0, which will occur when b is divisible by 1140. Using r = 0 will lead to an incorrect result. What we will do in this case is if b mod 1140 = 0, then we will use b = 1140 instead. This will keep the 0 from being in the exponent. However, we do not have to check it with an if statement, we can simply always add 1140 to b mod 1140 for all cases. This will give us the correct result in the cases when a and b are not divisible by 7 or 191 but will also protect us for the case when they are divisible by 7 or 191.\\n\\nThe program then simply converts the list b to a string then a long int. It then reduces b mod 1140 and adds 1140 to that result so we never have to worry about getting a 0 in the exponent. The program finally evaluates (a % 1337)^(1140 + b % 1140) % 1337 which gives us the correct final answer.\\n\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        return (a % 1337)**(1140 + int(\\'\\'.join(map(str, b))) % 1140) % 1337\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "_Explanation:_\\n\\nThis program is based on [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem) which states that: a^( phi(n) ) = 1 (mod n), where phi(n) is Euler\\'s Totient Function, provided that a and n are relatively prime (meaning they have no common factors). In our case, n = 1337, which has prime factorization 1337 = 7 x 191. We know that phi(p) = p - 1 when p is prime and also that phi(p x q) = phi(p) x phi(q). Thus it follows that phi(1337) = phi(7 x 191) = phi(7) x phi(191) = 6 x 190 = 1140. Thus, using Euler\\'s Theorem it follows that a^1140 = 1 (mod 1337), provided that a and 1337 have no common factors. Since 1337 only has two factors, 7 and 191, it follows that a^1140 = 1 (mod 1337), provided that a is not divisible by 7 or 191. This makes sense intuitively because one can only find an inverse of a number (mod n), if the number is relatively prime to n. No multiple of 7 or 191 will ever be congruent to 1 mod 1337 because they are factors of 1337. The closest you can get to 1 mod 1337, is getting 0 mod 1337. For this reason, it is very important that we never allow 1 to be the answer in the case when a is divisible by 7 or 9 since that doesn\\'t make sense.\\n\\nSince a^1140 = 1 (mod 1337), provided that a is not divisible by 7 or 191, it follows that if we write b = 1140q + r (where q is the quotient and r is the remainder after dividing b by 1140), then a^b = a^(1140q + r) = a^(1140q) x a^r = (a^1140)^q x a^r = 1^q x a^r = a^r (mod 1337). Thus if we reduce b (mod 1337) we can find the answer to a^b by instead just doing a^r (i.e. a^(b % 1337)). Furthermore since we want our answer mod 1337, it is wise to reduce a mod 1337 to keep the numbers smaller. Thus, provided that a is not divisible by 7 or 191, it follows by Euler\\'s Theorem that a^b = (a %1337)^(b % 1140) % 1337.\\n\\nHowever, we must carefuly reflect on the case when a is divisible by 7 or 191. If it is divisible by both, then obviously a mod 1337 is 0 and our answer is 0. However, if it is divisisble by one of them and if b = 0 mod 1140 (i.e. b is a multiple of 1140), then our problem would reduce to (7n)^0 = 1 (mod 1337) or (191m)^0 = 1 (mod 1337). These are obviously wrong because a multiple of 7 or 191 can never be congruent to 1 mod 1337. They are also an impermissible application of Euler\\'s Theorem because Euler\\'s Theorem requires that a and n be relatively prime. The way around this issue is to be careful to not use r = 0, which will occur when b is divisible by 1140. Using r = 0 will lead to an incorrect result. What we will do in this case is if b mod 1140 = 0, then we will use b = 1140 instead. This will keep the 0 from being in the exponent. However, we do not have to check it with an if statement, we can simply always add 1140 to b mod 1140 for all cases. This will give us the correct result in the cases when a and b are not divisible by 7 or 191 but will also protect us for the case when they are divisible by 7 or 191.\\n\\nThe program then simply converts the list b to a string then a long int. It then reduces b mod 1140 and adds 1140 to that result so we never have to worry about getting a 0 in the exponent. The program finally evaluates (a % 1337)^(1140 + b % 1140) % 1337 which gives us the correct final answer.\\n\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        return (a % 1337)**(1140 + int(\\'\\'.join(map(str, b))) % 1140) % 1337\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 84478,
                "title": "java-recursive-code-6ms",
                "content": "6ms Java code, \\u6ce8\\u91ca\\u5728\\u4ee3\\u7801\\u91cc\\n```\\npublic class Solution {\\n    /*\\n     \\u5148\\u9a8c\\u77e5\\u8bc6: a^(b*c) %m = a^b %m ^c %m\\n    */\\n    public int superPow(int a, int[] b) {\\n        return superPowerSub(a, b, b.length-1);\\n    }\\n    \\n    /* \\u9012\\u5f52\\u65b9\\u6cd5\\n    a^[1,2,3,4] = pow(a^[1,2,3], 10) * pow(a, 4)\\n    a^[1,2,3] = pow(a^[1,2], 10) * pow(a, 3)\\n    a^[1,2] = pow(a^[1], 10) * pow(a, 2)\\n    a^[1] = pow(a, 1)\\n    */\\n    public int superPowerSub(int a, int[] b, int index) {\\n        if (index == 0)\\n            return pow(a, b[index]) % 1337;\\n        int pre = superPowerSub(a, b, index-1);\\n        return (pow(pre, 10) * pow(a, b[index])) % 1337;\\n    }\\n    \\n    /*\\n    x \\u7684n\\u6b21\\u65b9\\uff0c\\u8fd9\\u91ccn\\u90fd\\u662f\\u4e2a\\u4f4d\\u6570\\n    */\\n    public int pow(int x, int n) {\\n        if (n == 0)\\n            return 1;\\n        if (n == 1)\\n            return x % 1337;\\n        int half = pow(x, n/2); \\n        if(n%2==0)  \\n            return (half*half) % 1337;  // half\\u662f\\u9012\\u5f52\\u4f20\\u56de\\u6765\\u7684\\uff0c\\u4e0d\\u4f1a\\u5927\\u4e8e1337\\n        else  \\n            return (((half*half) % 1337) *(x % 1337)) % 1337; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /*\\n     \\u5148\\u9a8c\\u77e5\\u8bc6: a^(b*c) %m = a^b %m ^c %m\\n    */\\n    public int superPow(int a, int[] b) {\\n        return superPowerSub(a, b, b.length-1);\\n    }\\n    \\n    /* \\u9012\\u5f52\\u65b9\\u6cd5\\n    a^[1,2,3,4] = pow(a^[1,2,3], 10) * pow(a, 4)\\n    a^[1,2,3] = pow(a^[1,2], 10) * pow(a, 3)\\n    a^[1,2] = pow(a^[1], 10) * pow(a, 2)\\n    a^[1] = pow(a, 1)\\n    */\\n    public int superPowerSub(int a, int[] b, int index) {\\n        if (index == 0)\\n            return pow(a, b[index]) % 1337;\\n        int pre = superPowerSub(a, b, index-1);\\n        return (pow(pre, 10) * pow(a, b[index])) % 1337;\\n    }\\n    \\n    /*\\n    x \\u7684n\\u6b21\\u65b9\\uff0c\\u8fd9\\u91ccn\\u90fd\\u662f\\u4e2a\\u4f4d\\u6570\\n    */\\n    public int pow(int x, int n) {\\n        if (n == 0)\\n            return 1;\\n        if (n == 1)\\n            return x % 1337;\\n        int half = pow(x, n/2); \\n        if(n%2==0)  \\n            return (half*half) % 1337;  // half\\u662f\\u9012\\u5f52\\u4f20\\u56de\\u6765\\u7684\\uff0c\\u4e0d\\u4f1a\\u5927\\u4e8e1337\\n        else  \\n            return (((half*half) % 1337) *(x % 1337)) % 1337; \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790113,
                "title": "python3-1-liner-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        return pow(a,int(\"\".join(list(map(str,b)))),1337)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        return pow(a,int(\"\".join(list(map(str,b)))),1337)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420719,
                "title": "372-super-pow-c-solution-with-easy-explanation",
                "content": "This is a simple approach to the problem Super Pow.This requires few concepts of mathematics which are Euler\\'s theorem and ETF(Euler Totient Function).\\nNow,what is ETF ?\\nETF of a number n can be defined as :\\n* ETF(n)=n*product_of(1-1/p)\\nwhere p=**prime factors**.\\n* Euler\\'s Theorem States that:\\na^b %M =a^(b%ETF(n)) % M .\\n\\nIn This question ETF(1337)=1140.\\nOnce we implement Euler\\'s theorem ,the ques becomes really easy .Then we need to use simple binary exponentiation to solve rest of the question.\\n\\n\\n**CODE**\\n\\n```\\nclass Solution {\\npublic:\\n    int binexp(long long a, long long b){\\n        a%=1337;\\n        int ans=1;\\n        while(b){\\n           if(b&1) ans=(ans*1ll*a)%1337;\\n           a=(a*1ll *a)%1337;\\n        b>>=1;\\n        }return ans;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n       //ETF(1337)=1140\\n        long long sum=0;\\n        for(int i=0;i<b.size();++i){\\n           sum=((sum*10)+b[i])%1140; \\n        }\\n       \\n        return binexp(a,sum);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binexp(long long a, long long b){\\n        a%=1337;\\n        int ans=1;\\n        while(b){\\n           if(b&1) ans=(ans*1ll*a)%1337;\\n           a=(a*1ll *a)%1337;\\n        b>>=1;\\n        }return ans;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n       //ETF(1337)=1140\\n        long long sum=0;\\n        for(int i=0;i<b.size();++i){\\n           sum=((sum*10)+b[i])%1140; \\n        }\\n       \\n        return binexp(a,sum);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487785,
                "title": "just-python-things-easy",
                "content": "If you are a **python** lover than this program is very easy for you as there is **no Integer Overflow**. So just covert the *power array to an integer* and calculate* a power b* with the given modulo.\\n\\n\\n```\\ndef superPow(self, a: int, b: List[int]) -> int:\\n        mod = 1337\\n        p = \\'\\'\\n        for i in b:\\n            p+=str(i)\\n        p=int(p)\\n        return pow(a,p,mod)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef superPow(self, a: int, b: List[int]) -> int:\\n        mod = 1337\\n        p = \\'\\'\\n        for i in b:\\n            p+=str(i)\\n        p=int(p)\\n        return pow(a,p,mod)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 297487,
                "title": "c-neat-solution",
                "content": "Following code is developed by vikramhegde. I felt his approach is unique to solve Superpow problem.\\n\\n\\'\\'\\'\\n#define MOD_NUM 1337\\n\\nclass Solution {\\npublic:\\n    \\n    int superPow(int &p, int exp)\\n    {\\n        int p1 = p%MOD_NUM,\\n            p2 = (p1*p1)%MOD_NUM,\\n            p4 = (p2*p2)%MOD_NUM,\\n            p8 = (p4*p4)%MOD_NUM;\\n        \\n        p = (p8*p2)%MOD_NUM;\\n        \\n        int product = 1;\\n        \\n        switch(exp)\\n        {\\n            case 1: product = (p1)%MOD_NUM; break;\\n            case 2: product = (p2)%MOD_NUM; break;\\n            case 3: product = (p1*p2)%MOD_NUM; break;\\n            case 4: product = (p4)%MOD_NUM; break;\\n            case 5: product = (p1*p4)%MOD_NUM; break;\\n            case 6: product = (p2*p4)%MOD_NUM; break;\\n            case 7: product = (p4*p1*p2)%MOD_NUM; break;\\n            case 8: product = (p4*p4)%MOD_NUM; break;\\n            case 9: product = (p4*p4*p1)%MOD_NUM; break;\\n        }\\n        \\n        return product;        \\n    }\\n    \\n    \\n    int superPow(int a, vector<int>& b) {\\n\\n        a %= MOD_NUM;\\n        int pow_10 = a;\\n        int product = 1;\\n        \\n        for (int i=b.size()-1; i>=0;--i)\\n        {\\n            product *= superPow(pow_10, b[i]);\\n            product %= MOD_NUM;\\n        }\\n        \\n        return product;\\n    }\\n};\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int superPow(int &p, int exp)\\n    {\\n        int p1 = p%MOD_NUM,\\n            p2 = (p1*p1)%MOD_NUM,\\n            p4 = (p2*p2)%MOD_NUM,\\n            p8 = (p4*p4)%MOD_NUM;\\n        \\n        p = (p8*p2)%MOD_NUM;\\n        \\n        int product = 1;\\n        \\n        switch(exp)\\n        {\\n            case 1: product = (p1)%MOD_NUM; break;\\n            case 2: product = (p2)%MOD_NUM; break;\\n            case 3: product = (p1*p2)%MOD_NUM; break;\\n            case 4: product = (p4)%MOD_NUM; break;\\n            case 5: product = (p1*p4)%MOD_NUM; break;\\n            case 6: product = (p2*p4)%MOD_NUM; break;\\n            case 7: product = (p4*p1*p2)%MOD_NUM; break;\\n            case 8: product = (p4*p4)%MOD_NUM; break;\\n            case 9: product = (p4*p4*p1)%MOD_NUM; break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1982177,
                "title": "cpp-easy-explained-commented-solution",
                "content": "```\\nint solve(int a , int b)\\n    {\\n\\t// base case\\n        if(b==0) return 1;\\n\\t\\t// calculate the current solution\\n        int temp=solve(a,b/2);\\n\\t\\t// if power is even then we just divided the power by 2 above and calculated the values\\n\\t\\t// else we just need to multiply an extra factor of a%1337 that will cover up the solution\\n        if(b%2==0) return ((temp%1337)*temp%1337)%1337;\\n        else return (a%1337*((temp%1337*temp%1337)%1337))%1337;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n\\t// base case when size of vector is zero\\n        if(b.size()==0) return 1;\\n\\t\\t// maintain a variable to store the last element of the vector at the current state\\n        int x = b.back();\\n\\t\\t// pop it once stored\\n        b.pop_back();\\n\\t\\t// we popped because once stored we can mutliply the value and call for further recursion \\n        return solve(superPow(a,b),10)*solve(a,x)%1337;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint solve(int a , int b)\\n    {\\n\\t// base case\\n        if(b==0) return 1;\\n\\t\\t// calculate the current solution\\n        int temp=solve(a,b/2);\\n\\t\\t// if power is even then we just divided the power by 2 above and calculated the values\\n\\t\\t// else we just need to multiply an extra factor of a%1337 that will cover up the solution\\n        if(b%2==0) return ((temp%1337)*temp%1337)%1337;\\n        else return (a%1337*((temp%1337*temp%1337)%1337))%1337;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n\\t// base case when size of vector is zero\\n        if(b.size()==0) return 1;\\n\\t\\t// maintain a variable to store the last element of the vector at the current state\\n        int x = b.back();\\n\\t\\t// pop it once stored\\n        b.pop_back();\\n\\t\\t// we popped because once stored we can mutliply the value and call for further recursion \\n        return solve(superPow(a,b),10)*solve(a,x)%1337;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552743,
                "title": "c-uses-chinese-remainder-fermat-s-little-theorems-beats-99-6",
                "content": "# Intuition\\nLike implementing RSA encryption\\n\\n# Approach\\nUse least significant bit first/most significant bit first algorithm  to compute the modular exponentiation. And use the Euler-Fermat Theorem to reduce exponent number modulo phi(n). \\n**Euler-Fermat Theorem:**\\n$$\\na^{\\\\phi(n)}\\\\equiv 1 \\\\pmod{n}\\n$$\\nfor $\\\\gcd(a, n)=1$.\\n\\nIn this problem, \\n$$n=1337=(191)(7), \\\\phi(n)=(191-1)(7-1)=(190)(6)=1140.$$\\n\\n What if $\\\\gcd(a, n)\\\\not=1$?\\n That will be the boundary case. Try these 2 test cases: \\n```\\n7\\n[1,1,4,0]\\n191\\n[1,1,4,0]\\n```\\nYou will find Euler-Fermat Theorem not enough! Suppose $\\\\gcd(a, p)=1$ & $\\\\gcd(a, q) \\\\not=1 $,  one can still use $a^{p-1} \\\\equiv 1 \\\\pmod{p}$ to deal with. Then the Chinese Remainder Theorem comes to play.\\n\\nChinese Remainder says:\\nLet $x\\\\equiv x_i \\\\pmod{n_i}$ with pairwise coprime $n_i$. Let $n=\\\\prod_i n_i$ Then \\n$$\\nx \\\\equiv \\\\sum_i x_iM_is_i \\\\pmod{n}\\n$$\\nwhere $M_i=n/n_i, s_i\\\\equiv M_i^{-1}\\\\pmod{n_i}$ \\n\\nIn our case:\\n$$\\n7^{-1}\\\\pmod{191}\\\\equiv 82, \\\\ 191^{-1}\\\\pmod{7}\\\\equiv 4\\n$$\\n\\nIn fact Euler-Fermat Theorem is the basis for RSA. It can prove with the aid of Chinese Remainder the following theorem\\n# Therem. If an postive integer a<n Then a^{k*phi(n)+1} =a (mod n) on matter what gcd(a, n) is.\\n\\nIn other word, the function $f(x)=a^x\\\\pmod{n}$ is a periodic function with $f(x)=f(x+k\\\\phi(n))$ which quarantees RSA works!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n[Please turn on the English subtitles if necessary]\\n[https://youtu.be/R3KdIxi0KLE](https://youtu.be/R3KdIxi0KLE)\\n# Code\\nC++ solution using Chinese Remainder.\\n```\\nint n=1337;\\nint phi=1140;\\nclass Solution {\\npublic:\\n    int Chinese_Remainder(int a,  int x, vector<int>& b){\\n        if (x==n) return 0;\\n        int p=n/x;\\n        int M;//modInverse i.e. x*M==1%p\\n        if (x==7) M=82;//can be computed by extended euclidean algorithm\\n        else M=4;\\n        \\n        int s=b.size();\\n        int exp=0;\\n        for(int i=0; i<s; i++)\\n            exp=(b[i]+10*exp)%(p-1);\\n        bitset<12> e(exp);\\n        int y=1;\\n        a%=n;\\n        for(int i=11; i>=0; i--){\\n            y=y*y%n;\\n            if (e[i]==1) y=y*a%n;\\n        }\\n        int ans=y*M*x%n;\\n        while( ans<0)\\n            ans+=n;\\n    //    cout<<ans<<endl;\\n        return ans;//Chinese Remainder Theorem\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        int g=gcd(a, n);\\n    //    cout<<\"gcd=\"<<g<<endl;\\n        if (g!=1) return Chinese_Remainder(a, g, b);\\n        int s=b.size();\\n        int exp=0;\\n        for(int i=0; i<s; i++)\\n            exp=(b[i]+10*exp)%phi;\\n        bitset<12> e(exp);\\n        int y=1;\\n        a%=n;\\n        for(int&& i=11; i>=0; i--){\\n            y=y*y%n;\\n            if (e[i]==1) y=y*a%n;\\n        }\\n        return y;\\n    }\\n};\\n```\\n# Code using Chinese Remainder & Fermat\\'s Little Theorem Beats 99.6%\\n```\\nclass Solution {\\npublic:\\n    int n=1337;\\n    int phi=1140;\\n    int p2=7, p1=191;\\n    int xq=82; //7^{-1}%191=82\\n    long long modPow(int a, int exp, int p){//MSBF modular exponentiation algorithm\\n        a%=p;//mod p to make base smaller\\n        if (a==0) return 0; // gcd(a, n)!=1\\n        if (exp==0) return 1;\\n        if (exp==1) return a;\\n        int y=(exp%2==1)?a:1;\\n        return modPow( a*a%p , exp/2, p)*y%p;\\n    }\\n\\n    long long Chinese_Remainder(int x1, int x2){\\n        long long num=xq*p2;// num%p1=1\\n        long long ans=(num*x1+(1-num)*x2)% n;\\n        while (ans<0) \\n            ans+=n;//ans>0\\n        return ans;\\n    }\\n\\n    int superPow(int a, vector<int>& b) {\\n        int s=b.size();\\n        int exp=0, exp1=0, exp2=0;\\n        for(int i=0; i<s; i++)\\n            exp=(b[i]+10*exp)%phi;\\n        exp1=exp%(p1-1);\\n        exp2=exp%(p2-1);          \\n    //    cout<<exp1<<\",\"<<exp2<<endl;\\n    //    int gcd0=gcd(a, n);\\n    //    cout<<gcd0<<endl;\\n        int x1=modPow(a, exp1, p1);//Fermat\\'s Little Theorem\\n        int x2=modPow(a, exp2, p2);\\n    //    cout<<\"x1=\"<<x1<<\", x2=\"<<x2<<endl;\\n        return Chinese_Remainder(x1, x2); \\n    }\\n};\\n```\\n# Python solution dealing the boundary cases\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        exp=0\\n        for e in b:\\n            exp=e+10*exp\\n            exp%=1140\\n            if exp==0: exp=1140 #Add this line can save old solution\\n        return pow(a, exp, 1337)\\n        \\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\n7\\n[1,1,4,0]\\n191\\n[1,1,4,0]\\n```\n```\\nint n=1337;\\nint phi=1140;\\nclass Solution {\\npublic:\\n    int Chinese_Remainder(int a,  int x, vector<int>& b){\\n        if (x==n) return 0;\\n        int p=n/x;\\n        int M;//modInverse i.e. x*M==1%p\\n        if (x==7) M=82;//can be computed by extended euclidean algorithm\\n        else M=4;\\n        \\n        int s=b.size();\\n        int exp=0;\\n        for(int i=0; i<s; i++)\\n            exp=(b[i]+10*exp)%(p-1);\\n        bitset<12> e(exp);\\n        int y=1;\\n        a%=n;\\n        for(int i=11; i>=0; i--){\\n            y=y*y%n;\\n            if (e[i]==1) y=y*a%n;\\n        }\\n        int ans=y*M*x%n;\\n        while( ans<0)\\n            ans+=n;\\n    //    cout<<ans<<endl;\\n        return ans;//Chinese Remainder Theorem\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        int g=gcd(a, n);\\n    //    cout<<\"gcd=\"<<g<<endl;\\n        if (g!=1) return Chinese_Remainder(a, g, b);\\n        int s=b.size();\\n        int exp=0;\\n        for(int i=0; i<s; i++)\\n            exp=(b[i]+10*exp)%phi;\\n        bitset<12> e(exp);\\n        int y=1;\\n        a%=n;\\n        for(int&& i=11; i>=0; i--){\\n            y=y*y%n;\\n            if (e[i]==1) y=y*a%n;\\n        }\\n        return y;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n=1337;\\n    int phi=1140;\\n    int p2=7, p1=191;\\n    int xq=82; //7^{-1}%191=82\\n    long long modPow(int a, int exp, int p){//MSBF modular exponentiation algorithm\\n        a%=p;//mod p to make base smaller\\n        if (a==0) return 0; // gcd(a, n)!=1\\n        if (exp==0) return 1;\\n        if (exp==1) return a;\\n        int y=(exp%2==1)?a:1;\\n        return modPow( a*a%p , exp/2, p)*y%p;\\n    }\\n\\n    long long Chinese_Remainder(int x1, int x2){\\n        long long num=xq*p2;// num%p1=1\\n        long long ans=(num*x1+(1-num)*x2)% n;\\n        while (ans<0) \\n            ans+=n;//ans>0\\n        return ans;\\n    }\\n\\n    int superPow(int a, vector<int>& b) {\\n        int s=b.size();\\n        int exp=0, exp1=0, exp2=0;\\n        for(int i=0; i<s; i++)\\n            exp=(b[i]+10*exp)%phi;\\n        exp1=exp%(p1-1);\\n        exp2=exp%(p2-1);          \\n    //    cout<<exp1<<\",\"<<exp2<<endl;\\n    //    int gcd0=gcd(a, n);\\n    //    cout<<gcd0<<endl;\\n        int x1=modPow(a, exp1, p1);//Fermat\\'s Little Theorem\\n        int x2=modPow(a, exp2, p2);\\n    //    cout<<\"x1=\"<<x1<<\", x2=\"<<x2<<endl;\\n        return Chinese_Remainder(x1, x2); \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        exp=0\\n        for e in b:\\n            exp=e+10*exp\\n            exp%=1140\\n            if exp==0: exp=1140 #Add this line can save old solution\\n        return pow(a, exp, 1337)\\n        \\n```",
                "codeTag": "C++"
            },
            {
                "id": 3250433,
                "title": "372-time-100-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The input a is a positive integer, and b is an array representing an extremely large positive integer.\\n\\n2. The first step is to compute a_mod, which is a modulo 1337. This is done because we need to return the final result modulo 1337.\\n\\n3. The second step is to compute n, which is the number represented by the array b. This is done using the reduce() function from the functools module, which applies a function to the elements of an iterable and reduces them to a single value. The lambda function lambda x, y: (x * 10 + y) % 1140 is applied to each digit of b in turn, starting with the first digit. The function takes two arguments x and y, which represent the running total and the next digit of b, respectively. It multiplies the running total by 10, adds the next digit y, and then takes the result modulo 1140. This is because 1140 is a multiple of 1337 (1140 = 2 x 2 x 3 x 5 x 19), so any number modulo 1140 is also modulo 1337.\\n\\n4. The third step is to compute result, which is initialized to 1. We then perform repeated squaring to compute a_mod raised to the power of n. This is done using a while loop that continues as long as n is greater than 0. If n is odd (i.e., n modulo 2 is 1), we multiply result by a_mod and take the result modulo 1337. We then update a_mod to be a_mod squared modulo 1337, and divide n by 2 using integer division (n //= 2). If n is even (i.e., n modulo 2 is 0), we simply update a_mod to be a_mod squared modulo 1337 and divide n by 2.\\n\\n5. Finally, we return the result modulo 1337.\\n\\n# Complexity\\n- Time complexity:\\n100%\\n\\n- Space complexity:\\n47.88%\\n\\n# Code\\n```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        # Compute a_mod = a mod 1337\\n        a_mod = a % 1337\\n        \\n        # Compute n, the number represented by the array b, using reduce()\\n        n = reduce(lambda x, y: (x * 10 + y) % 1140, b, 0)\\n        \\n        # Compute a_mod raised to the power of n using repeated squaring\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result = (result * a_mod) % 1337\\n            a_mod = (a_mod * a_mod) % 1337\\n            n //= 2\\n        \\n        # Return the result modulo 1337\\n        return result % 1337\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Divide and Conquer"
                ],
                "code": "```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        # Compute a_mod = a mod 1337\\n        a_mod = a % 1337\\n        \\n        # Compute n, the number represented by the array b, using reduce()\\n        n = reduce(lambda x, y: (x * 10 + y) % 1140, b, 0)\\n        \\n        # Compute a_mod raised to the power of n using repeated squaring\\n        result = 1\\n        while n > 0:\\n            if n % 2 == 1:\\n                result = (result * a_mod) % 1337\\n            a_mod = (a_mod * a_mod) % 1337\\n            n //= 2\\n        \\n        # Return the result modulo 1337\\n        return result % 1337\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84525,
                "title": "7ms-java-solution-using-fast-power-algorithm",
                "content": "\\n\\n    public class Solution {\\n\\n    private static final int NUM = 1337;\\n    public int superPow(int a, int[] b) {\\n        int ans = 1;\\n        //not expecting to be a part of input\\n        if(b==null||b.length==0)\\n            return 0;\\n        a = a%NUM;\\n        int len = b.length;\\n        for (int i = 0; i < len; i++) {\\n            ans = ((pow(ans,10)*pow(a,b[i]))%NUM);\\n        }\\n        return ans;\\n    }\\n\\n    private int pow(int a, int b){\\n        if(b==1)\\n            return a;\\n        if(b==0)\\n            return 1;\\n        int x = pow(a,b/2);\\n        x = (x*x)%NUM;\\n        if((b&1)==1)\\n            x = (x*a)%NUM;\\n        return x;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    private static final int NUM = 1337;\\n    public int superPow(int a, int[] b) {\\n        int ans = 1;\\n        //not expecting to be a part of input\\n        if(b==null||b.length==0)\\n            return 0;\\n        a = a%NUM;\\n        int len = b.length;\\n        for (int i = 0; i < len; i++) {\\n            ans = ((pow(ans,10)*pow(a,b[i]))%NUM);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3565746,
                "title": "java-100-faster-time-complexity-o-1-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing binary exponentiation and math with divide and conquer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy Using binary exponentiation and math with divide and conquer and then after do same as the power question.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        long k=0;\\n        for(int i=0;i<b.length;i++)\\n        {\\n            k=k*10+b[i];\\n            k=k%1140;\\n        }\\n        int ans=1;\\n        a=a%1337;\\n        k=k%1140;\\n        while(k>0)\\n        {\\n            if(k%2==1)\\n                ans=((ans%1337)*(a%1337))%1337;\\n            a=((a%1337)*(a%1337))%1337;\\n            k/=2;\\n        }\\n        return ans%1337;\\n    }\\n}\\nfeel free to ask your doubt happy to help...\\nIf it help then plz upvote it....Thanks!!!!!\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        long k=0;\\n        for(int i=0;i<b.length;i++)\\n        {\\n            k=k*10+b[i];\\n            k=k%1140;\\n        }\\n        int ans=1;\\n        a=a%1337;\\n        k=k%1140;\\n        while(k>0)\\n        {\\n            if(k%2==1)\\n                ans=((ans%1337)*(a%1337))%1337;\\n            a=((a%1337)*(a%1337))%1337;\\n            k/=2;\\n        }\\n        return ans%1337;\\n    }\\n}\\nfeel free to ask your doubt happy to help...\\nIf it help then plz upvote it....Thanks!!!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059571,
                "title": "very-easy-c-code-using-euler-s-theorem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink to solve using mathematics like Euler\\'s Theorem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse the Euler\\'s Titient Functio and Euler\\'s theorem to solve the question. Calculate the modulo of the array b with the number of co-primes of 1337.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(size(b))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryExp(int a, int b){\\n        a = a%1337;\\n        int ans =1;\\n        while(b>0){\\n            if(b&1){\\n                ans =( ans*1LL*a)%1337;\\n            }\\n            a = (a*1LL*a)%1337;\\n            b >>=1;\\n        }\\n        return ans;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        int bmod = 0;\\n        for(int val:b){\\n            bmod = (bmod*10+val)%1140;\\n        }\\n        return binaryExp(a, bmod);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryExp(int a, int b){\\n        a = a%1337;\\n        int ans =1;\\n        while(b>0){\\n            if(b&1){\\n                ans =( ans*1LL*a)%1337;\\n            }\\n            a = (a*1LL*a)%1337;\\n            b >>=1;\\n        }\\n        return ans;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        int bmod = 0;\\n        for(int val:b){\\n            bmod = (bmod*10+val)%1140;\\n        }\\n        return binaryExp(a, bmod);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645771,
                "title": "python-explained-recursive-o-log-n-comparison-with-pow-x-n",
                "content": "# Approach :\\n- We can use recursive method.\\n- when `n` will be even we can decrease the recursive calls by calculating it for `n/2` let\\'s say `res` and return <sub>res</sub>2.\\n- when `n` will be odd we just use previous step for calculating it for`(n-1)` as `res` and this time return x*(<sub>res</sub>2).\\n\\n\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n- Space complexity: O(1)\\n\\n# Super-pow :\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        b = [str(i) for i in b]\\n        n = int(\"\".join(b)) #converting list into integer\\n        def pow(x, n):\\n            if n == 0:\\n                return 1\\n            elif n%2==0:\\n                res =  pow(x, n>>1)%1337\\n                return res**2\\n            else:\\n                res = pow(x, (n-1)>>1)%1337\\n                return x*(res**2)\\n            \\n        return pow(a, n)%1337\\n        \\n```\\n\\n# Pow(x, n) :\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        def pow(x, n):\\n            if n == 0:\\n                return 1\\n            elif n%2==0:\\n                res =  pow(x, n/2)\\n                return res*res\\n            else:\\n                res =  pow(x, (n-1)/2)\\n                return x*(res**2)\\n            \\n        if n>=0: \\n            return pow(x, n)\\n        else:\\n            return 1/pow(x, abs(n))\\n\\n```\\n**Upvote the post if you find it helpful.\\nHappy coding.**\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        b = [str(i) for i in b]\\n        n = int(\"\".join(b)) #converting list into integer\\n        def pow(x, n):\\n            if n == 0:\\n                return 1\\n            elif n%2==0:\\n                res =  pow(x, n>>1)%1337\\n                return res**2\\n            else:\\n                res = pow(x, (n-1)>>1)%1337\\n                return x*(res**2)\\n            \\n        return pow(a, n)%1337\\n        \\n```\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        def pow(x, n):\\n            if n == 0:\\n                return 1\\n            elif n%2==0:\\n                res =  pow(x, n/2)\\n                return res*res\\n            else:\\n                res =  pow(x, (n-1)/2)\\n                return x*(res**2)\\n            \\n        if n>=0: \\n            return pow(x, n)\\n        else:\\n            return 1/pow(x, abs(n))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527739,
                "title": "python-sol-by-euler-theorem-89-w-hint-reference",
                "content": "Python sol with speed up by **Euler theorem**.\\n\\n---\\n\\n**Hint** & **Reference**:\\n\\nFirst step is to **extract exponent** from input parameter *b*, either by string operation, or reduce with lambda.\\n\\nSecond step is to **compute power** with **speed up by [Euler theorem](https://en.wikipedia.org/wiki/Euler\\'s_theorem)**\\n\\nFor more detailed demo and illustration, please refer to [this article by @ShuangquanLi](https://leetcode.com/problems/super-pow/discuss/84466/Math-solusion-based-on-Euler\\'s-theorem-power-called-only-ONCE-C%2B%2BJava1-line-Python)\\n\\n---\\nFrom Euler theorem, we have,\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583253275.png)\\n\\n\\n\\nLet exp denote the exponent extracted from input b\\n\\nGoal = (*a* ^ *exp*) mod 1337 \\n= *a* ^ ( *exp* mod \\u03C6(1337) ) mod 1337\\n= *a* ^ ( *exp* mod 1140) mod 1337\\nuse the formula derived above to reduce computation loading and to have higher performance.\\n\\n**Remark**:\\n\\n\\u03C6( 1337 ) \\n= \\u03C6( 7 x 191 ) where 7 and 191 are prime factor of 1337\\'s factor decomposition\\n= \\u03C6( 7 ) x  \\u03C6( 191 )\\n= ( 7 - 1 ) x ( 191 - 1 )\\n= 6 x 190\\n=1140\\n\\n[Euler\\'s totient function \\u03C6( n )](https://en.wikipedia.org/wiki/Euler\\'s_totient_function) counts the positive integers up to a given integer n that are relatively prime to n\\n\\n---\\n**Implementation_#1**\\nExtract exponent by string operation\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        \\n        \\n        if a % 1337 == 0:\\n            return 0\\n        \\n        else:\\n            # Euler theorem:\\n            #\\n            # ( a ^ phi(n) ) mod n = 1\\n            #  \\n            # => ( a ^ b ) mod n = ( a ^ ( b mod phi(n) ) ) mod n\\n            \\n            exponent = int( \\'\\'.join( map( str, b) ) )\\n\\t\\t\\t\\n\\t\\t\\treturn pow( base = a, exp = exponent % 1140, mod = 1337 )\\n```\\n---\\n**Implementation_#2**\\nExtract exponent by reduce with lambda\\n```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        \\n        \\n        if a % 1337 == 0:\\n            return 0\\n        \\n        else:\\n            # Euler theorem:\\n            #\\n            # ( a ^ phi(n) ) mod n = 1\\n            #  \\n            # => ( a ^ b ) mod n = ( a ^ ( b mod phi(n) ) ) mod n\\n            \\n            decimal = lambda x,y : 10*x+y\\n            exponent = reduce( decimal, b )\\n\\t\\t\\t\\n            return pow( base = a, exp = exponent % 1140, mod = 1337 )\\n```\\n\\n---\\n\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #50 Pow(x, n)](https://leetcode.com/problems/powx-n/)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        \\n        \\n        if a % 1337 == 0:\\n            return 0\\n        \\n        else:\\n            # Euler theorem:\\n            #\\n            # ( a ^ phi(n) ) mod n = 1\\n            #  \\n            # => ( a ^ b ) mod n = ( a ^ ( b mod phi(n) ) ) mod n\\n            \\n            exponent = int( \\'\\'.join( map( str, b) ) )\\n\\t\\t\\t\\n\\t\\t\\treturn pow( base = a, exp = exponent % 1140, mod = 1337 )\\n```\n```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        \\n        \\n        if a % 1337 == 0:\\n            return 0\\n        \\n        else:\\n            # Euler theorem:\\n            #\\n            # ( a ^ phi(n) ) mod n = 1\\n            #  \\n            # => ( a ^ b ) mod n = ( a ^ ( b mod phi(n) ) ) mod n\\n            \\n            decimal = lambda x,y : 10*x+y\\n            exponent = reduce( decimal, b )\\n\\t\\t\\t\\n            return pow( base = a, exp = exponent % 1140, mod = 1337 )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373908,
                "title": "python-one-line-solution-95",
                "content": "Using Python is easy.\\n\\n```python\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        return (a % 1337) ** (int(\\'\\'.join(map(str, b))) % 570) % 1337\\n```\\n\\n`1377 = 7 * 191` where 7 and 191 are prime. By the fermat theorem, for any `a`, we have `a^6=1(mod 7)` and `a^190=1(mod 191)`. Thus , we can get `a^570=1(mod 1337)`. This is why we need to calculate `int(\\'\\'.join(map(str, b))) % 570`.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        return (a % 1337) ** (int(\\'\\'.join(map(str, b))) % 570) % 1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84465,
                "title": "dynamic-programming-solution-without-complex-math-theory",
                "content": "I use the following two simple modular calculation skills to derive the DP recursion formula.\\n1. (a * b) mod c = ((a mod c) * (b mod c)) mod c\\n2. (a ^ b) mod c = ((a mod c) ^ b) mod c\\n\\nMy DP starts from insignificant power digits (from the end of array b)\\n\\nGiven input a = 2, b = {1,2,3,4}\\ndp[0] = (2^4) mod 1337\\ndp[1] = (2^34) mod 1337\\ndp[2] = (2^234) mod 1337\\ndp[3] = (2^1234) mod 1337\\n\\nDP base case : \\ndp[0] = 2^4 mod 1337 = (2 mod 1337)^4 mod 1337 **==>(skill 2)**\\n\\nI call (2 mod 1337) the **factor**. It can be reused in the next round DP building.\\n\\ndp[1] = (2^4 * 2^(3 * 10)) mod 1337 = ((2^4 mod 1337) * (2^(3*10) mod 1337)) mod 1337 **==>(skill 1)**\\n\\ndp[1] = (dp[0] * (((2^10 mod 1337)^3) mod 1337)) mod 1337 **==>(skill 2)**\\n\\ndp[1] = (dp[0] * ((((2 mod 1337)^10) mod 1337)^3)) mod 1337 **==>(skill 2)**\\n\\ndp[1] = (dp[0] * (((factor^10) mod 1337)^3)) mod 1337\\n\\nfinally, update the factor for next round reusing : factor = (factor^10) mod 1337\\n\\nBy the above derivation, the DP recursion formula is : \\nfactor = (factor^10) mod 1337;\\ndp[i] = (dp[i-1] * (factor^b[b.length-i-1]) % 1337) % 1337\\n\\n```\\nclass Solution {\\n    \\n    final int k = 1337;\\n\\t\\n    public int superPow(int a, int[] b) {\\n    \\tint fac=a%1337,l=b.length;\\n    \\tint[] dp=new int[l];\\n    \\tdp[0] = pMod(fac,b[l-1]);\\n        for (int i=1;i<l;i++) dp[i]=dp[i-1]*pMod(fac=pMod(fac,10),b[l-i-1])%k;\\n        return dp[l-1];\\n    }\\n    \\n    // pMod is for calculating (a^b) mod 1337\\n    private int pMod(int a, int b) {\\n    \\treturn b==0?1%k:b==1?a%k:a%k*pMod(a,b-1)%k;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    final int k = 1337;\\n\\t\\n    public int superPow(int a, int[] b) {\\n    \\tint fac=a%1337,l=b.length;\\n    \\tint[] dp=new int[l];\\n    \\tdp[0] = pMod(fac,b[l-1]);\\n        for (int i=1;i<l;i++) dp[i]=dp[i-1]*pMod(fac=pMod(fac,10),b[l-i-1])%k;\\n        return dp[l-1];\\n    }\\n    \\n    // pMod is for calculating (a^b) mod 1337\\n    private int pMod(int a, int b) {\\n    \\treturn b==0?1%k:b==1?a%k:a%k*pMod(a,b-1)%k;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84480,
                "title": "c-ac-recursive-solution",
                "content": "The key observation is  `pow(a,b)%1337` = `pow(1337*k+a,b) % 1337`\\n```\\nclass Solution {\\npublic:\\n long long myPow(long long num, int k) {\\n   if (k == 0) return 1;\\n   if (k == 1) return (num % 1337);\\n   long long ret = myPow(num % 1337, k / 2) % 1337;\\n   return (ret * ret * ((k%2) ? num : 1))%1337;\\n }\\n\\n int superPow(int a, vector<int>& b) {\\n   int L = b.size();\\n   long long ret = 1;\\n   for (int i = 0; i < L; i++) {\\n     ret = (long long)(myPow(ret, 10) * (long long)myPow(a, b[i])) % 1337;\\n   }\\n   return ret;\\n }\\n};\\n```'",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n long long myPow(long long num, int k) {\\n   if (k == 0) return 1;\\n   if (k == 1) return (num % 1337);\\n   long long ret = myPow(num % 1337, k / 2) % 1337;\\n   return (ret * ret * ((k%2) ? num : 1))%1337;\\n }\\n\\n int superPow(int a, vector<int>& b) {\\n   int L = b.size();\\n   long long ret = 1;\\n   for (int i = 0; i < L; i++) {\\n     ret = (long long)(myPow(ret, 10) * (long long)myPow(a, b[i])) % 1337;\\n   }\\n   return ret;\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864118,
                "title": "beats-99-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        number = \\'\\'\\n        for digit in b:\\n            number += str(digit)\\n        number = int(number)\\n        return pow(a, number, 1337)     \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        number = \\'\\'\\n        for digit in b:\\n            number += str(digit)\\n        number = int(number)\\n        return pow(a, number, 1337)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644331,
                "title": "c-simple-solution-with-explanation-etf",
                "content": "**_________Solution Using**\\n**Euler\\' Theorem and ETF**\\n```\\nclass Solution {\\npublic:\\n    int M = 1337;\\n    int superPow(int a, vector<int>& b) {\\n        /**\\n         * prime factors of 1337 are 7 and 191;\\n         * Euler Totient Function \\u03A6(1337) = etf (let);\\n         * etf = 1337*(1-1/7)*(1-1/191);\\n         * etf = 1337*6*190/(191*7);\\n         * Euler\\'s Theorem--> a^b % M == (a^(b%etf))%M\\n        **/\\n        int etf = 6*190;\\n        int n = b.size(), k = 0;\\n        /**calculate b%etf **/\\n        for(int i=0;i<n;i++){\\n            k = k*10 + b[i];\\n            if(k>=etf) k%=etf;\\n        }\\n        int c = Pow(a,k);\\n        return c;\\n    }\\n    int Pow(int a,int k){\\n        int res = 1;\\n        while(k){\\n            if(k&1) res = (res*1LL*a)%M;\\n            a = (a*1LL*a)%M;\\n            k>>=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M = 1337;\\n    int superPow(int a, vector<int>& b) {\\n        /**\\n         * prime factors of 1337 are 7 and 191;\\n         * Euler Totient Function \\u03A6(1337) = etf (let);\\n         * etf = 1337*(1-1/7)*(1-1/191);\\n         * etf = 1337*6*190/(191*7);\\n         * Euler\\'s Theorem--> a^b % M == (a^(b%etf))%M\\n        **/\\n        int etf = 6*190;\\n        int n = b.size(), k = 0;\\n        /**calculate b%etf **/\\n        for(int i=0;i<n;i++){\\n            k = k*10 + b[i];\\n            if(k>=etf) k%=etf;\\n        }\\n        int c = Pow(a,k);\\n        return c;\\n    }\\n    int Pow(int a,int k){\\n        int res = 1;\\n        while(k){\\n            if(k&1) res = (res*1LL*a)%M;\\n            a = (a*1LL*a)%M;\\n            k>>=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906009,
                "title": "easy-to-understnand-javascript-solution",
                "content": "\\tvar superPow = function(a, b) {\\n\\t\\tconst MOD = 1337;\\n\\t\\tconst pow = (num, n) => {\\n\\t\\t\\tlet result = 1;\\n\\t\\t\\tfor (let index = 0; index < n; index++) {\\n\\t\\t\\t\\tresult = result * num % MOD;\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t};\\n\\n\\t\\treturn b.reduceRight((result, n) => {\\n\\t\\t\\ta %= MOD;\\n\\t\\t\\tconst powNum = result * pow(a, n) % MOD;\\n\\n\\t\\t\\ta = pow(a, 10);\\n\\t\\t\\treturn powNum;\\n\\t\\t}, 1);\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar superPow = function(a, b) {\\n\\t\\tconst MOD = 1337;\\n\\t\\tconst pow = (num, n) => {\\n\\t\\t\\tlet result = 1;\\n\\t\\t\\tfor (let index = 0; index < n; index++) {\\n\\t\\t\\t\\tresult = result * num % MOD;\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t};\\n\\n\\t\\treturn b.reduceRight((result, n) => {\\n\\t\\t\\ta %= MOD;\\n\\t\\t\\tconst powNum = result * pow(a, n) % MOD;\\n\\n\\t\\t\\ta = pow(a, 10);\\n\\t\\t\\treturn powNum;\\n\\t\\t}, 1);\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1545520,
                "title": "java-1-simple-indices-law-2-montgomery-powering-ladder",
                "content": "**Approach 1:**\\nSimple Law of Indices and Pre-computation.\\n[![image](https://assets.leetcode.com/users/images/ba4905b6-4682-45b1-88ed-434eb09794e6_1635634835.3509424.png)\\n](http://)\\n```\\nclass Solution {\\n    public int superPow(int a, int[] b){\\n       \\n        int len = b.length;\\n        int mod = 1337;\\n        int[] pw = new int[len];\\n        pw[len-1]= a%mod;\\n        for(int i=len-2; i>=0; i--){\\n            pw[i] = pow(pw[i+1],10,mod);\\n        }\\n        int res = 1;\\n        for(int i=0; i<len; i++){\\n            int temp = pow(pw[i], b[i], mod);\\n            res = (temp * res)%mod;\\n        }\\n        return Long.valueOf(res).intValue();\\n    }\\n    public int pow(int x, int n, int mod){\\n        if(n==0)return 1;\\n        if(n == 1)return x%mod;\\n        int half = pow(x,n/2,mod);\\n        int extra = n%2==1?x:1;\\n        return (((half*half)%mod)*(extra%mod))%mod;\\n    }\\n```\\n**Approach 2: **\\nCheckout the \"[Montgomery Modular Multiplication](https://en.wikipedia.org/wiki/Montgomery_modular_multiplication)\". It is also called Montgomery Powering Ladder.\\n![image](https://assets.leetcode.com/users/images/5c6751b5-56da-4381-a695-f1004a49e34a_1635428856.58655.png)\\n\\n\\nThe main approach in this method the conversion of `b` into binary string. My approach of conversion is definition not optimal.\\n```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        int R0 = 1, R1 = a%1337, mod = 1337;\\n        LinkedList<Boolean> eBits = getBits(b);\\n        for(boolean bit: eBits){\\n            if(bit){\\n                R0 = (R0%mod * R1%mod) % mod;\\n                R1 = (R1%mod * R1%mod) % mod;\\n            }else{\\n                R1 = (R0%mod * R1%mod) % mod;\\n                R0 = (R0%mod * R0%mod) % mod;\\n            }\\n        }\\n        return R0;\\n    }\\n    private LinkedList<Boolean> getBits(int[] arr){\\n        Queue<Integer> rems = new LinkedList<>();\\n        LinkedList<Boolean> eBits = new LinkedList<>();\\n        int digit;\\n        for(int i=0; i<arr.length; i++){\\n            digit = arr[i];\\n            int adds = rems.size();\\n            while(digit > 0 || adds > 0){\\n                if(i == arr.length-1)\\n                    eBits.addFirst(digit%2 == 0?false:true);\\n                else\\n                    rems.offer(digit%2 == 0?0:5);\\n                digit /= 2;\\n                if(adds-- > 0)\\n                    digit += rems.poll();\\n            }\\n        }\\n        return eBits;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int superPow(int a, int[] b){\\n       \\n        int len = b.length;\\n        int mod = 1337;\\n        int[] pw = new int[len];\\n        pw[len-1]= a%mod;\\n        for(int i=len-2; i>=0; i--){\\n            pw[i] = pow(pw[i+1],10,mod);\\n        }\\n        int res = 1;\\n        for(int i=0; i<len; i++){\\n            int temp = pow(pw[i], b[i], mod);\\n            res = (temp * res)%mod;\\n        }\\n        return Long.valueOf(res).intValue();\\n    }\\n    public int pow(int x, int n, int mod){\\n        if(n==0)return 1;\\n        if(n == 1)return x%mod;\\n        int half = pow(x,n/2,mod);\\n        int extra = n%2==1?x:1;\\n        return (((half*half)%mod)*(extra%mod))%mod;\\n    }\\n```\n```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        int R0 = 1, R1 = a%1337, mod = 1337;\\n        LinkedList<Boolean> eBits = getBits(b);\\n        for(boolean bit: eBits){\\n            if(bit){\\n                R0 = (R0%mod * R1%mod) % mod;\\n                R1 = (R1%mod * R1%mod) % mod;\\n            }else{\\n                R1 = (R0%mod * R1%mod) % mod;\\n                R0 = (R0%mod * R0%mod) % mod;\\n            }\\n        }\\n        return R0;\\n    }\\n    private LinkedList<Boolean> getBits(int[] arr){\\n        Queue<Integer> rems = new LinkedList<>();\\n        LinkedList<Boolean> eBits = new LinkedList<>();\\n        int digit;\\n        for(int i=0; i<arr.length; i++){\\n            digit = arr[i];\\n            int adds = rems.size();\\n            while(digit > 0 || adds > 0){\\n                if(i == arr.length-1)\\n                    eBits.addFirst(digit%2 == 0?false:true);\\n                else\\n                    rems.offer(digit%2 == 0?0:5);\\n                digit /= 2;\\n                if(adds-- > 0)\\n                    digit += rems.poll();\\n            }\\n        }\\n        return eBits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420565,
                "title": "python-3-na-ve-array-operation-euler-s-theorem-and-optimization-explanation",
                "content": "### Approach #1 - Naive array operation\\n- Take the same idea of below example, imagine `b = [1,2,3]`\\n- `a^123 = a^100 * a^20 * a^3 = (a^1)^10^10 * (a^2)^10 * (a^3)`\\n```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        @cache    \\n        def cus_pow(a, b):  # A customized pow(a, b)\\n            if b == 0 or a == 1: return 1\\n            if b % 2:\\n                return a * cus_pow(a, b - 1) % 1337\\n            return cus_pow((a * a) % 1337, b / 2) % 1337\\n        res = 1\\n        for x in b:         # power on array\\n            res = cus_pow(res, 10) * cus_pow(a, x) % 1337\\n        return res\\n```\\n\\n### Approach #2 - Euler\\'s theorem\\n- Euler\\'s theorem is only applicable when `a` and `1337` are coprime to each other\\n- For more general case, when `a` and `1337` are NOT coprime, the equation becomes this:\\n\\t- `a^b % m == a^(b%phi(m) + phi(m)) % m`, which is same as below\\n\\t- `a^b == a^(b%phi(m) + phi(m)) (mod m)`\\n\\t- When apply to this question, `a` is the base number, `b` is the large integer represented by array, `m` is `1337`\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        if a % 1337 == 0:\\n            return 0\\n        else:\\n            exponent = int(\\'\\'.join(map(str, b)))\\n            return pow(a, exponent % 1140 + 1140, 1337)\\n```\\n### Approach #3 - Euler\\'s theorem (optimized)\\n- [@ShuangquanLi \\'s article](https://leetcode.com/problems/super-pow/discuss/84466/Math-solusion-based-on-Euler\\'s-theorem-power-called-only-ONCE-C%2B%2BJava1-line-Python) gave a detailed prove to the optimization\\n- And this is only for the special case when mod 1337, might not work for other mod value\\n- The optimized equation can be represented this way:\\n\\t- `a^b == a^(b%phi(1337)) (mod 1337)`, or\\n\\t- `a^b == a^(b%1140) (mod 1337)`\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        if a % 1337 == 0:\\n            return 0\\n        else:\\n            exponent = int(\\'\\'.join(map(str, b)))\\n            return pow(a, exponent % 1140, 1337)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        @cache    \\n        def cus_pow(a, b):  # A customized pow(a, b)\\n            if b == 0 or a == 1: return 1\\n            if b % 2:\\n                return a * cus_pow(a, b - 1) % 1337\\n            return cus_pow((a * a) % 1337, b / 2) % 1337\\n        res = 1\\n        for x in b:         # power on array\\n            res = cus_pow(res, 10) * cus_pow(a, x) % 1337\\n        return res\\n```\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        if a % 1337 == 0:\\n            return 0\\n        else:\\n            exponent = int(\\'\\'.join(map(str, b)))\\n            return pow(a, exponent % 1140 + 1140, 1337)\\n```\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        if a % 1337 == 0:\\n            return 0\\n        else:\\n            exponent = int(\\'\\'.join(map(str, b)))\\n            return pow(a, exponent % 1140, 1337)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389075,
                "title": "c-iterative-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        long curr_power_of_10 = a;\\n        long ret = 1;\\n        \\n        for(int i = b.size()-1;i>=0;i--){\\n            int digit = b[i];\\n            //next digit\\n            for(int j=0;j<digit;j++){\\n                ret*=curr_power_of_10;\\n                ret%=1337;\\n            }\\n            //next power of 10 multiplier\\n            long new_curr_pow = 1;\\n            for(int i=0;i<10;i++){\\n                new_curr_pow *= curr_power_of_10;\\n                new_curr_pow %= 1337;\\n            }\\n            //cout<<new_curr_pow<<\"\\\\n iteration complete \\\\n\"<<endl;\\n            curr_power_of_10 = new_curr_pow;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        long curr_power_of_10 = a;\\n        long ret = 1;\\n        \\n        for(int i = b.size()-1;i>=0;i--){\\n            int digit = b[i];\\n            //next digit\\n            for(int j=0;j<digit;j++){\\n                ret*=curr_power_of_10;\\n                ret%=1337;\\n            }\\n            //next power of 10 multiplier\\n            long new_curr_pow = 1;\\n            for(int i=0;i<10;i++){\\n                new_curr_pow *= curr_power_of_10;\\n                new_curr_pow %= 1337;\\n            }\\n            //cout<<new_curr_pow<<\"\\\\n iteration complete \\\\n\"<<endl;\\n            curr_power_of_10 = new_curr_pow;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1325611,
                "title": "multiply-and-square-solution-220-ms-faster-than-16-35-14-2-mb-less-than-93-13",
                "content": "Title Multiply and Square Solution (220 ms, faster than 16.35%, 14.2 MB, less than 93.13%)\\n\\nWe will use Square and Multiply Method to finish this problem.\\n\\nHow does it works ? \\nLearn with examples, we need to calculate 5 ^ 9\\n\\nWe need to calculate (a ^ b) % 1337 , here are the steps :\\nWhere y = a and n is the current bit\\n\\nNote : You need to convert b to one int variable\\n\\n1. convert b to binary\\n2. iterate from second bits to the end\\n\\t2.1 y = y ^ 2\\n\\t2.2 if n == 1 then y = y * a\\n3. return y\\n\\nsmall example : \\na = 5, b = 9\\n1. convert b into binary\\n\\tb = 9, then the binary value of 9 is 1 0 0 1\\n2. iterate from second bits to the end, so we iterate from binary 001 (the first 1 bit in the beginning are skipped)\\ny = a -> so y = 5\\n\\tFirst Iteration -> n = 0\\n\\ty = 5 * 5 = 25\\n\\tbecause of n (the current bit) is 0 then we skipped and continue to the next iteration\\n\\n\\tSecond Iteration -> n = 0\\n\\ty = 25 * 25 = 625\\n\\tbecause of n (the current bit) is 0 then we skipped and continue to the next iteration\\n\\n\\tThird Iteration -> n = 1\\n\\ty = 625 * 625 = 390625\\n\\tbecause of n (the current bit) is 1 then we multiply y with a\\n\\ty = 390625 * 5 = 1953125\\n\\n3. return y (which is 1953125)\\n\\nWhy is this works ?\\n\\nBecause of \\n\\t5 * 5 = 5 ^ 2\\n\\t25 * 25 = 5 ^ 4\\n\\t625 * 625 = 5 ^ 8\\n\\t1953125 = 5 ^ 8 * 5 -> 5 ^ 9\\n\\nSo instead of iterate 9 times (brute force, so we multiply 5 9 times), instead we loop for only 3 times\\nwith O(lg n) time complexity (from the source i read).\\n\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        x = a\\n        n = 0\\n        for p in range(len(b)):\\n            n += b[p]\\n            if p != len(b) - 1:\\n                n *= 10\\n        bin_b = bin(n)[2:]\\n        y = a\\n        l = 1\\n        bin_len = len(bin_b)\\n        while l < bin_len:\\n            y = y * y % 1337\\n            if bin_b[l] == \\'1\\':\\n                y = y * x % 1337\\n            l += 1\\n        return y % 1337\\n```\\n\\nFor this solution, you need to mod every arithmethic operation with 1337 so the result won\\'t be too big or you will get a time limit exceeded error.\\nFirst time posting and I am currently still learning, any critics or suggestion are needed. Thank you :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        x = a\\n        n = 0\\n        for p in range(len(b)):\\n            n += b[p]\\n            if p != len(b) - 1:\\n                n *= 10\\n        bin_b = bin(n)[2:]\\n        y = a\\n        l = 1\\n        bin_len = len(bin_b)\\n        while l < bin_len:\\n            y = y * y % 1337\\n            if bin_b[l] == \\'1\\':\\n                y = y * x % 1337\\n            l += 1\\n        return y % 1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231588,
                "title": "c-solution-with-explanation",
                "content": "```\\n/**\\n * @brief A function to calculate a^b % k\\n*/\\nint powModFunc(int a, int b, int k)\\n{\\n\\t// Overflow occured if directly calculate a^b % k\\n\\t// Use (a*a*a*a*...) % k instead\\n\\t// let a^1 = kq + r,      a^1 % k = r % k                         =             (a % k)     \\n\\t//     a^2 = akq + ar,    a^2 % k = ar % k  = (a % k)(r % k) % k  = (a^1 % k)   (a % k) % k\\n\\t//     a^3 = aakq + aar,  a^3 % k = aar % k = (a % k)(ar % k) % k = (a^2 % k)   (a % k) % k\\n\\t// So                     a^n % k                                 = (a^n-1 % k) (a % k) % k\\n\\t// Notes that a^0 = 1\\n\\n\\tif (b == 0) return 1;\\n\\n\\tlong reminderA = a % k;\\n\\tlong result = reminderA;\\n\\tfor (int i = 1; i < b ; i++)\\n\\t{\\n\\t\\tresult = (result * reminderA) % k;\\n\\t}        \\n\\treturn result;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n\\tint k = 1337;\\n\\t// There have two properties we must know.\\n\\t// 1. ab % k = (a%k)(b%k)%k\\n\\t// 2. a^(bc) % k = (a^b % k)^c % k\\n\\t// e.g. a^123 % k = (a^120 * a^3) % k\\n\\t//                = ((a^12 * 10) % k) (a^3 % k) % k                           // Use property 1\\n\\t//                = ((a^12 % k)^10 % k) (a^3 % k) % k                         // Use property 2\\n\\t//                = (((a^1 % k) (a^2 % k) % k)^10 % k) (a^3 % k) % k          // Use property 1\\n\\n\\tint result;\\n\\tif (b.size() == 1) {\\n\\t\\tresult = powModFunc(a, b[0], k);\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tint lastValue = b.back();\\n\\t\\tb.pop_back();\\n\\t\\tresult = ((long)powModFunc(superPow(a, b), 10, k) * (long)powModFunc(a, lastValue, k)) % k;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * @brief A function to calculate a^b % k\\n*/\\nint powModFunc(int a, int b, int k)\\n{\\n\\t// Overflow occured if directly calculate a^b % k\\n\\t// Use (a*a*a*a*...) % k instead\\n\\t// let a^1 = kq + r,      a^1 % k = r % k                         =             (a % k)     \\n\\t//     a^2 = akq + ar,    a^2 % k = ar % k  = (a % k)(r % k) % k  = (a^1 % k)   (a % k) % k\\n\\t//     a^3 = aakq + aar,  a^3 % k = aar % k = (a % k)(ar % k) % k = (a^2 % k)   (a % k) % k\\n\\t// So                     a^n % k                                 = (a^n-1 % k) (a % k) % k\\n\\t// Notes that a^0 = 1\\n\\n\\tif (b == 0) return 1;\\n\\n\\tlong reminderA = a % k;\\n\\tlong result = reminderA;\\n\\tfor (int i = 1; i < b ; i++)\\n\\t{\\n\\t\\tresult = (result * reminderA) % k;\\n\\t}        \\n\\treturn result;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n\\tint k = 1337;\\n\\t// There have two properties we must know.\\n\\t// 1. ab % k = (a%k)(b%k)%k\\n\\t// 2. a^(bc) % k = (a^b % k)^c % k\\n\\t// e.g. a^123 % k = (a^120 * a^3) % k\\n\\t//                = ((a^12 * 10) % k) (a^3 % k) % k                           // Use property 1\\n\\t//                = ((a^12 % k)^10 % k) (a^3 % k) % k                         // Use property 2\\n\\t//                = (((a^1 % k) (a^2 % k) % k)^10 % k) (a^3 % k) % k          // Use property 1\\n\\n\\tint result;\\n\\tif (b.size() == 1) {\\n\\t\\tresult = powModFunc(a, b[0], k);\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tint lastValue = b.back();\\n\\t\\tb.pop_back();\\n\\t\\tresult = ((long)powModFunc(superPow(a, b), 10, k) * (long)powModFunc(a, lastValue, k)) % k;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1077907,
                "title": "c-95-77-solution",
                "content": "The code is attached below for reference.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int power(int a, int b)\\n    {\\n        if(b==0)\\n        {\\n            return 1;\\n        }\\n        if(b==1)\\n        {\\n            return a%1337;\\n        }\\n        if(b&1)\\n        {\\n            return (a*power(a,b-1))%1337;\\n        }\\n        else{\\n            int x=power(a,b/2)%1337;\\n            return (x*x)%1337;\\n        }\\n    }\\n    \\n    \\n    int superPow(int a, vector<int>& b) {\\n        a = a%1337;\\n        if(a==0)\\n        {\\n            return 0;\\n        }\\n        int n = b.size();\\n        int res = 1;\\n        for (int i = n-1; i>=0; i--)\\n        {\\n            int p=power(a,b[i]);\\n            res =  res*p;\\n            res%=1337;\\n            a = power(a,10)%1337;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int power(int a, int b)\\n    {\\n        if(b==0)\\n        {\\n            return 1;\\n        }\\n        if(b==1)\\n        {\\n            return a%1337;\\n        }\\n        if(b&1)\\n        {\\n            return (a*power(a,b-1))%1337;\\n        }\\n        else{\\n            int x=power(a,b/2)%1337;\\n            return (x*x)%1337;\\n        }\\n    }\\n    \\n    \\n    int superPow(int a, vector<int>& b) {\\n        a = a%1337;\\n        if(a==0)\\n        {\\n            return 0;\\n        }\\n        int n = b.size();\\n        int res = 1;\\n        for (int i = n-1; i>=0; i--)\\n        {\\n            int p=power(a,b[i]);\\n            res =  res*p;\\n            res%=1337;\\n            a = power(a,10)%1337;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616492,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        long res = 1;\\n        for (int i = 0; i < b.size(); ++i) {\\n            res = pow(res, 10) * pow(a, b[i]) % 1337;\\n        }\\n        return res;\\n    }\\n    \\n    int pow(int x, int n) {\\n        if (n == 0) return 1;\\n        if (n == 1) return x % 1337;\\n        return pow(x % 1337, n / 2) * pow(x % 1337, n - n / 2) % 1337;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        long res = 1;\\n        for (int i = 0; i < b.size(); ++i) {\\n            res = pow(res, 10) * pow(a, b[i]) % 1337;\\n        }\\n        return res;\\n    }\\n    \\n    int pow(int x, int n) {\\n        if (n == 0) return 1;\\n        if (n == 1) return x % 1337;\\n        return pow(x % 1337, n / 2) * pow(x % 1337, n - n / 2) % 1337;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314762,
                "title": "c-binary-search",
                "content": "```\\npublic class Solution \\n{\\n    long mod = 1337;\\n    public int SuperPow(int a, int[] b) \\n    {\\n        long result = 1;\\n        for (int i = 0; i < b.Length; i++)\\n        {\\n            result = Pow(result, 10) * Pow(a, b[i]);\\n            result %= mod;\\n        }\\n        return (int)result;\\n    }\\n\\n    private long Pow(long num, long n)\\n    {\\n        if (n == 0) return 1;\\n        if (n == 1) return num % mod;\\n\\n        var tempResult = Pow(num % mod, n / 2) % mod;\\n\\n        if (n % 2 == 1) return (num % mod) * tempResult * tempResult;\\n        else            return tempResult * tempResult;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    long mod = 1337;\\n    public int SuperPow(int a, int[] b) \\n    {\\n        long result = 1;\\n        for (int i = 0; i < b.Length; i++)\\n        {\\n            result = Pow(result, 10) * Pow(a, b[i]);\\n            result %= mod;\\n        }\\n        return (int)result;\\n    }\\n\\n    private long Pow(long num, long n)\\n    {\\n        if (n == 0) return 1;\\n        if (n == 1) return num % mod;\\n\\n        var tempResult = Pow(num % mod, n / 2) % mod;\\n\\n        if (n % 2 == 1) return (num % mod) * tempResult * tempResult;\\n        else            return tempResult * tempResult;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84520,
                "title": "java-16-lines-ac-solution-11ms",
                "content": "just a java version \\n[you can check the C++ solution with more detail here](https://discuss.leetcode.com/topic/50489/c-clean-and-short-solution)\\nBasic math knowlege:\\n(ab)%k=(a%k)(b%k)%k;\\n(abc)%k=(a%k)(b%k)(c%k)%k \\n\\n An example:\\n<h4><code>23^1335%base\\n=(23^1330%base)*(23^5%base)%base\\n=((23^133%base)^10)%base*(23^5%base)%base\\n=function(function(23,133),10)*function(23,5)%base\\n</code></h4>\\n``` java \\npublic class Solution {\\n    int base =1337;\\n    public int superPow(int a, int[] b) {\\n        return helper(a,b,b.length-1);\\n    }\\n    int helper(int a,int[]b,int endidx){\\n        if(endidx==-1) return 1;\\n        int last_digit=b[endidx];\\n        return powmod(helper(a,b,endidx-1),10)*powmod(a,last_digit)%base;\\n    }\\n    int powmod(int a,int k){\\n        a%=base;\\n        int result=1;\\n        for(int i=0;i<k;i++){\\n            result=(result*a)%base;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java \\npublic class Solution {\\n    int base =1337;\\n    public int superPow(int a, int[] b) {\\n        return helper(a,b,b.length-1);\\n    }\\n    int helper(int a,int[]b,int endidx){\\n        if(endidx==-1) return 1;\\n        int last_digit=b[endidx];\\n        return powmod(helper(a,b,endidx-1),10)*powmod(a,last_digit)%base;\\n    }\\n    int powmod(int a,int k){\\n        a%=base;\\n        int result=1;\\n        for(int i=0;i<k;i++){\\n            result=(result*a)%base;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84528,
                "title": "16ms-c-solution",
                "content": "'''\\nclass Solution {\\npublic:\\n\\tint superPow(int a, vector<int>& b) \\n\\t{\\n\\t\\tif (b.size() == 0) return 1;\\n\\n\\t\\tconst int D = 1337;\\n\\t\\tint A = a % D;\\n\\t\\tvector<int> v(10, 0);\\n\\t\\tv[0] = 1;\\n\\t\\tfor (int i = 1; i < 10; i++)\\n\\t\\t{\\n\\t\\t\\tv[i] = (v[i - 1] * A) % 1337;\\n\\t\\t}\\n\\n\\t\\tint L = v[b[0]];\\n\\n\\t\\tfor (int i = 1; i < b.size(); i++)\\n\\t\\t{\\n\\t\\t\\tint M = 1;\\n\\t\\t\\tfor (int i = 0; i < 10; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tM = M*L % D;\\n\\t\\t\\t}\\n\\n\\t\\t\\tM = M*v[b[i]] % D;\\n\\t\\t\\tL = M;\\n\\t\\t}\\n\\n\\t\\treturn L;\\n\\t}\\n};\\n'''",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\tint superPow(int a, vector<int>& b) \\n\\t{\\n\\t\\tif (b.size() == 0) return 1;\\n\\n\\t\\tconst int D = 1337;\\n\\t\\tint A = a % D;\\n\\t\\tvector<int> v(10, 0);\\n\\t\\tv[0] = 1;\\n\\t\\tfor (int i = 1; i < 10; i++)\\n\\t\\t{\\n\\t\\t\\tv[i] = (v[i - 1] * A) % 1337;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 84544,
                "title": "my-easy-understood-java-solution-with-explanation-any-idea-how-to-make-it-faster",
                "content": "My idea is to split the number we have into two parts: repeater and remainder.\\nFor example:\\n2^40 : \\n    1. First we construct the smallest repeater which is >= 1337. \\n        Coz 2^10 < 1337 < 2^11, we choose 2^11 as repeater.\\n    2. Then we have 2^30: 2^11, 2^11, 2^11 and 2^8, 2^8 is the remainder that is smaller than repeater.\\n    3. We do the mod with 1337 : 711, 711, 711, 2^8\\n    4. Repeat Step 1, combine the rest part of repeater with the remainder and do mod: \\n(711^2, (711*2^8) mod 1337)\\n   5. Do the repeat process until we get for a^b, a==1 or b<=1;\\n\\nCode:\\n```\\nimport java.math.BigInteger;\\n\\npublic class Solution {\\n    public int superPow(int a, int[] b) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < b.length; i++){\\n            sb.append(b[i]);\\n        }\\n        BigInteger numB = new BigInteger(sb.toString());\\n        return helper((long)a, numB, 1);\\n        \\n    }\\n    public int helper(long a, BigInteger b, long remainder){\\n        if (a == 1 || (b.compareTo(BigInteger.valueOf(1)) <= 0)) \\n            return (int)(((a % 1337)*(remainder % 1337)) % 1337);\\n        \\n        BigInteger powNeed = BigInteger.valueOf((long)(Math.log(1337)/Math.log(a)) + 1);\\n        long newA = (b.compareTo(powNeed) < 0) ? 1 : (long)(Math.pow(a,powNeed.intValue()) % 1337);\\n        long newRemainder = (long)(((remainder % 1337)*(Math.pow(a, b.mod(powNeed).intValue()) % 1337)) % 1337);\\n        return helper(newA, b.divide(powNeed), newRemainder);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\n\\npublic class Solution {\\n    public int superPow(int a, int[] b) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < b.length; i++){\\n            sb.append(b[i]);\\n        }\\n        BigInteger numB = new BigInteger(sb.toString());\\n        return helper((long)a, numB, 1);\\n        \\n    }\\n    public int helper(long a, BigInteger b, long remainder){\\n        if (a == 1 || (b.compareTo(BigInteger.valueOf(1)) <= 0)) \\n            return (int)(((a % 1337)*(remainder % 1337)) % 1337);\\n        \\n        BigInteger powNeed = BigInteger.valueOf((long)(Math.log(1337)/Math.log(a)) + 1);\\n        long newA = (b.compareTo(powNeed) < 0) ? 1 : (long)(Math.pow(a,powNeed.intValue()) % 1337);\\n        long newRemainder = (long)(((remainder % 1337)*(Math.pow(a, b.mod(powNeed).intValue()) % 1337)) % 1337);\\n        return helper(newA, b.divide(powNeed), newRemainder);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687258,
                "title": "simple-code-in-c-using-math-beats-100-runtime-and-100-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        long long  sum=0;\\n        for(int i=0;i<b.size();i++) sum=(sum*10+b[i])%1140;\\n        sum%=1140;\\n        long long  power = a;\\n        for(int i=1;i<sum;i++) power = (power*a)%1337;\\n        return power%1337 ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        long long  sum=0;\\n        for(int i=0;i<b.size();i++) sum=(sum*10+b[i])%1140;\\n        sum%=1140;\\n        long long  power = a;\\n        for(int i=1;i<sum;i++) power = (power*a)%1337;\\n        return power%1337 ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747777,
                "title": "java-recursive-solution",
                "content": "# Approach\\nRecursion solution\\n\\n# Code\\n```\\nclass Solution {\\n    int base = 1337;\\n\\n    public int superPow(int a, int[] b) {\\n        return superPow(a, b, b.length-1);\\n    }\\n\\n    public int superPow(int a, int[] b, int index) {\\n        if (index == 0)\\n            return pow(a, b[index]) % base;\\n        int pre = superPow(a, b, index-1);\\n        return (pow(pre, 10) * pow(a, b[index])) % base;\\n    }\\n\\n    public int pow(int x, int n) {\\n        if (n == 0)\\n            return 1;\\n        if (n == 1)\\n            return x % base;\\n        int half = pow(x, n/2); \\n        if(n%2==0)  \\n            return (half*half) % base;\\n        else  \\n            return (((half*half) % base) *(x % base)) % base; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int base = 1337;\\n\\n    public int superPow(int a, int[] b) {\\n        return superPow(a, b, b.length-1);\\n    }\\n\\n    public int superPow(int a, int[] b, int index) {\\n        if (index == 0)\\n            return pow(a, b[index]) % base;\\n        int pre = superPow(a, b, index-1);\\n        return (pow(pre, 10) * pow(a, b[index])) % base;\\n    }\\n\\n    public int pow(int x, int n) {\\n        if (n == 0)\\n            return 1;\\n        if (n == 1)\\n            return x % base;\\n        int half = pow(x, n/2); \\n        if(n%2==0)  \\n            return (half*half) % base;\\n        else  \\n            return (((half*half) % base) *(x % base)) % base; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927300,
                "title": "python-82-explained",
                "content": "Some simple mathematical transforms\\n![image](https://assets.leetcode.com/users/images/e5f490b8-1918-4073-a92e-5ad970be845c_1649457573.260148.png)\\n\\n\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        c, ans, MOD = a, 1, 1337\\n        for i in range(len(b)-1,-1,-1):\\n            ans = (ans * (c**b[i] % MOD)) % MOD\\n            c = c**10 % MOD\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        c, ans, MOD = a, 1, 1337\\n        for i in range(len(b)-1,-1,-1):\\n            ans = (ans * (c**b[i] % MOD)) % MOD\\n            c = c**10 % MOD\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827192,
                "title": "c-100-91-38-1140-reason-easy",
                "content": "Calculate the power first with iteration and mod by 1140(reason below).\\n\\u03C6( 1337 )\\n= \\u03C6( 7 x 191 ) where 7 and 191 are prime factor of 1337\\'s factor decomposition\\n= \\u03C6( 7 ) x \\u03C6( 191 )\\n= ( 7 - 1 ) x ( 191 - 1 )\\n= 6 x 190\\n=1140\\nthat means there are 1140 non negative numbers those are coprime to 1337.\\n\\ncalculate the pow till it is greater then 0.\\nif power is ODD then multiply with the temp number(for the first iteration temp is a).\\nif power is EVEN then multiply the temp number with itself and so that power will be half.\\n\\n```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        \\n        long long temp = (long long)a;\\n        int num = 1, pow = 0, mod = 1337;\\n        \\n        for(auto x : b) pow = ((pow * 10) + x) % 1140;\\n        \\n        while(pow)\\n            if(pow & 1) {\\n                num = (num * temp) % mod;\\n                pow--;\\n            } else {\\n                temp = (temp * temp) % mod;\\n                pow >>= 1;\\n            }\\n        \\n        return num % mod;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        \\n        long long temp = (long long)a;\\n        int num = 1, pow = 0, mod = 1337;\\n        \\n        for(auto x : b) pow = ((pow * 10) + x) % 1140;\\n        \\n        while(pow)\\n            if(pow & 1) {\\n                num = (num * temp) % mod;\\n                pow--;\\n            } else {\\n                temp = (temp * temp) % mod;\\n                pow >>= 1;\\n            }\\n        \\n        return num % mod;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736181,
                "title": "inf-is-outside-the-range-of-representable-values-of-type-long-long",
                "content": "what do i use except long long. pls let me know\\n\\n```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        int s = b.size();\\n        int dig = 0;\\n        for(int i=0;i<s;i++)\\n        {\\n            dig += b[i] * pow(10,s-(i+1)); \\n        }\\n        long long int ans = pow(a,dig);\\n        int fin = ans%1337;\\n        return fin;\\n       \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        int s = b.size();\\n        int dig = 0;\\n        for(int i=0;i<s;i++)\\n        {\\n            dig += b[i] * pow(10,s-(i+1)); \\n        }\\n        long long int ans = pow(a,dig);\\n        int fin = ans%1337;\\n        return fin;\\n       \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712367,
                "title": "easy-c-solution-0-ms-solution",
                "content": "simple code using eulers theorem\\n\\n```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        int num=0;\\n        int res=1;\\n        for(int i=0;i<b.size();i++){\\n            num=((num*10)+b[i])%1140;\\n        }\\n      while(num>0){\\n          if(num&1){\\n              res=(1LL*(res)*(a)%1337)%1337;\\n          }\\n          a=(1LL*(a)%1337*(a)%1337)%1337;\\n          num=num>>1;\\n          \\n      }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        int num=0;\\n        int res=1;\\n        for(int i=0;i<b.size();i++){\\n            num=((num*10)+b[i])%1140;\\n        }\\n      while(num>0){\\n          if(num&1){\\n              res=(1LL*(res)*(a)%1337)%1337;\\n          }\\n          a=(1LL*(a)%1337*(a)%1337)%1337;\\n          num=num>>1;\\n          \\n      }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658177,
                "title": "easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    int m=1337;\\n    //calculate power with binary expo\\n    int power(int a,int b){\\n        int res=1;\\n        while(b){\\n            if(b%2){\\n                res=(res*a)%m;\\n                --b;\\n            }\\n            else{\\n                a=(a*a)%m;\\n                b=b>>1;\\n            }\\n        }\\n        return res%m;\\n    }\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        //  (a^x)%m --> ( (a%m)^(x%f(m)) )%m; --> euler algo\\n        //  f(m)--> total number of coprimes\\n        // if gcd(p,q)==1 then p and q is coprime\\n        // first of all find all coprimes of m\\n        // to find coprimes-->\\n        // i.e f(m)=m*(1-1/p1)*(1-1/p2)*(1-1/p3)...\\n        // p1,p2,p3,... are unique prime factors of m\\n        \\n        // In given question m=1337\\n        // primes factors of m is 7,191\\n        // so 1337*(1-1/7)*(1-1/191)=>1140 (total number of coprime)\\n        \\n        a=a%m;\\n        int x=0;\\n        for(int i=0;i<b.size();i++){\\n            x=(x*10+b[i])%(1140);\\n        }\\n        return power(a,x);\\n    }\\n};\\n```\\n\\n\\n\\n2nd-->\\n\\n\\n```\\nyou can also try this solution-->\\n\\n\\n    int superPow(int a, vector<int>& b) {\\n        int res=1;\\n        a=a%m;\\n        for(int i=b.size()-1;i>=0;i--){\\n            res=(res*power(a,b[i]))%m;  //same power function as in first solution\\n            a=power(a,10)%m;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m=1337;\\n    //calculate power with binary expo\\n    int power(int a,int b){\\n        int res=1;\\n        while(b){\\n            if(b%2){\\n                res=(res*a)%m;\\n                --b;\\n            }\\n            else{\\n                a=(a*a)%m;\\n                b=b>>1;\\n            }\\n        }\\n        return res%m;\\n    }\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        //  (a^x)%m --> ( (a%m)^(x%f(m)) )%m; --> euler algo\\n        //  f(m)--> total number of coprimes\\n        // if gcd(p,q)==1 then p and q is coprime\\n        // first of all find all coprimes of m\\n        // to find coprimes-->\\n        // i.e f(m)=m*(1-1/p1)*(1-1/p2)*(1-1/p3)...\\n        // p1,p2,p3,... are unique prime factors of m\\n        \\n        // In given question m=1337\\n        // primes factors of m is 7,191\\n        // so 1337*(1-1/7)*(1-1/191)=>1140 (total number of coprime)\\n        \\n        a=a%m;\\n        int x=0;\\n        for(int i=0;i<b.size();i++){\\n            x=(x*10+b[i])%(1140);\\n        }\\n        return power(a,x);\\n    }\\n};\\n```\n```\\nyou can also try this solution-->\\n\\n\\n    int superPow(int a, vector<int>& b) {\\n        int res=1;\\n        a=a%m;\\n        for(int i=b.size()-1;i>=0;i--){\\n            res=(res*power(a,b[i]))%m;  //same power function as in first solution\\n            a=power(a,10)%m;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613940,
                "title": "c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int pow(int a, int e) {\\n        int res = 1;\\n        a %= 1337;\\n        for (; e; e /= 2) {\\n            if (e & 1) {\\n                res = (res * a) % 1337;\\n            }\\n            a = (a * a) % 1337;\\n        }\\n        return res;\\n    }\\n\\n    int superPow(int a, vector<int>& b) {\\n        int res = 1;\\n        int r = a % 1337;\\n        for (int i = b.size() - 1; i >= 0; --i) {\\n            res = (res * pow(r, b[i])) % 1337;\\n            r = pow(r, 10);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int pow(int a, int e) {\\n        int res = 1;\\n        a %= 1337;\\n        for (; e; e /= 2) {\\n            if (e & 1) {\\n                res = (res * a) % 1337;\\n            }\\n            a = (a * a) % 1337;\\n        }\\n        return res;\\n    }\\n\\n    int superPow(int a, vector<int>& b) {\\n        int res = 1;\\n        int r = a % 1337;\\n        for (int i = b.size() - 1; i >= 0; --i) {\\n            res = (res * pow(r, b[i])) % 1337;\\n            r = pow(r, 10);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394755,
                "title": "python-o-log-b-o-1-time-and-space-complexity",
                "content": "\\tclass Solution:\\n\\t\\tdef superPow(self, a: int, b: List[int]) -> int:\\n\\t\\t   \\'\\'\\'\\n\\t\\t   For converting b list to number.\\n\\t\\t   \\'\\'\\'\\n\\t\\t\\tdef calB(b):\\n\\t\\t\\t\\tn = 0\\n\\t\\t\\t\\tl = len(b)\\n\\t\\t\\t\\tfor i in range(l):\\n\\t\\t\\t\\t\\tn = n*10 + b[i]\\n\\t\\t\\t\\treturn n\\n         \\'\\'\\'\\n\\t\\t For calculating the power (a**b) %m\\n\\t\\t \\'\\'\\'\\n\\t\\t\\tdef calPow(a, b):\\n\\t\\t\\t\\tmod = 1337\\n\\t\\t\\t\\tif b == 0:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\telif b == 1: \\n\\t\\t\\t\\t\\treturn a\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thalf = calPow(a, b//2) % mod\\n\\t\\t\\t\\t\\tif (b%2 == 0):\\n\\t\\t\\t\\t\\t\\treturn (half*half) %mod\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn (((half*half)% mod) *a) %mod\\n\\t\\t\\treturn calPow(a, calB(b))\\n\\t\\t\\t\\nSimilar question:\\n\\n[Pow(x,n)](https://leetcode.com/problems/powx-n/)\\n\\n\\t\\t\\t\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef superPow(self, a: int, b: List[int]) -> int:\\n\\t\\t   \\'\\'\\'\\n\\t\\t   For converting b list to number.\\n\\t\\t   \\'\\'\\'\\n\\t\\t\\tdef calB(b):\\n\\t\\t\\t\\tn = 0\\n\\t\\t\\t\\tl = len(b)\\n\\t\\t\\t\\tfor i in range(l):\\n\\t\\t\\t\\t\\tn = n*10 + b[i]\\n\\t\\t\\t\\treturn n\\n         \\'\\'\\'\\n\\t\\t For calculating the power (a**b) %m\\n\\t\\t \\'\\'\\'\\n\\t\\t\\tdef calPow(a, b):\\n\\t\\t\\t\\tmod = 1337\\n\\t\\t\\t\\tif b == 0:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\telif b == 1: \\n\\t\\t\\t\\t\\treturn a\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thalf = calPow(a, b//2) % mod\\n\\t\\t\\t\\t\\tif (b%2 == 0):\\n\\t\\t\\t\\t\\t\\treturn (half*half) %mod\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn (((half*half)% mod) *a) %mod\\n\\t\\t\\treturn calPow(a, calB(b))\\n\\t\\t\\t\\nSimilar question:\\n\\n[Pow(x,n)](https://leetcode.com/problems/powx-n/)\\n\\n\\t\\t\\t\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1362681,
                "title": "java-straightforward-iterative-solution",
                "content": "**Prerequisite Math Knowledge**\\n`(a * b) % c = ((a % c) * (b % c)) % c`(I remember I learned from my **Cryptography** course...)\\n\\nFor example,  `(11 * 6) % 7` equals :\\n1. 66 % 7 = 3\\n2. ((11 % 7) * (6 % 7)) % 7 = (4 * 6) % 7 = 24 % 7 = 3\\n---\\n**Logic**\\nWe iterate each digit in array `b`, when we go to the index of i, if let\\'s call previous power as `prev`,  we know that the new power is `prev * 10 + b[i]`. \\nAssuming we already know previous result as \\n`res  = a ^ prev`, then we need to compute: \\n`newRes = a ^ (prev * 10 + b[i])`, and this can be transformed as \\n`newRes = (a ^ prev) ^ 10 * (a ^ b[i]) = (res ^ 10) * (a ^ b[i]) = left * right`, where we denote `res ^ 10` as `left` and `a ^ b[i]` as `right`\\nThen we just need to apply our math process in the left and right part in iterative way\\n\\n---\\n**Code**\\n```java\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        a %= 1337;\\n        int res = 1;\\n        for(int i = 0; i < b.length; i++){\\n            // calculate res ^ 10\\n            int left = 1;\\n            for(int j = 0; j < 10; j++){\\n                left = (left * res) % 1337;\\n            }\\n            // calculate a ^ b[i]\\n            int right = 1;\\n            for(int j = 0; j < b[i]; j++) {\\n                right = (right * a % 1337) % 1337;\\n            }\\n            \\n            // calculate result\\n            res = (left * right) % 1337;  \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        a %= 1337;\\n        int res = 1;\\n        for(int i = 0; i < b.length; i++){\\n            // calculate res ^ 10\\n            int left = 1;\\n            for(int j = 0; j < 10; j++){\\n                left = (left * res) % 1337;\\n            }\\n            // calculate a ^ b[i]\\n            int right = 1;\\n            for(int j = 0; j < b[i]; j++) {\\n                right = (right * a % 1337) % 1337;\\n            }\\n            \\n            // calculate result\\n            res = (left * right) % 1337;  \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043248,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long LL;\\n    int superPow(int a, vector<int>& b) {\\n        a %= 1337;\\n        if(b.empty()) return 1;\\n        int t = b.back();\\n        b.pop_back();\\n        return qmi(a, t) * qmi(superPow(a, b), 10) % 1337;\\n    }\\n\\n    LL qmi(LL a, LL n)\\n    {\\n        LL res = 1;\\n        while(n)\\n        {\\n            if(n & 1)\\n                res = res * a % 1337;\\n            n>>=1;\\n            a = a * a % 1337 ;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long LL;\\n    int superPow(int a, vector<int>& b) {\\n        a %= 1337;\\n        if(b.empty()) return 1;\\n        int t = b.back();\\n        b.pop_back();\\n        return qmi(a, t) * qmi(superPow(a, b), 10) % 1337;\\n    }\\n\\n    LL qmi(LL a, LL n)\\n    {\\n        LL res = 1;\\n        while(n)\\n        {\\n            if(n & 1)\\n                res = res * a % 1337;\\n            n>>=1;\\n            a = a * a % 1337 ;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994119,
                "title": "simple-binary-search-based-solution",
                "content": "\\tvoid half(int* nums, int n){\\n    \\n    for(int i=0; i<n-1; i++){\\n        nums[i+1] += 10 * (nums[i] % 2);\\n        nums[i] /= 2;\\n    }\\n    \\n    nums[n-1] /= 2;\\n    \\n\\t}\\n\\n\\tint superPow(int a, int* b, int bSize){\\n\\n    if(bSize == 0)\\n        return 1;\\n    \\n    if(b[bSize-1]%2 == 1){\\n        b[bSize-1]--;\\n        return ( (a % 1337) * superPow(a, b, bSize) ) % 1337;\\n    }\\n    \\n    half(b, bSize);\\n    \\n    if(b[0]==0)\\n        b++, bSize--;\\n    \\n    return superPow( (a % 1337) * (a % 1337), b, bSize);\\n\\t}",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "\\tvoid half(int* nums, int n){\\n    \\n    for(int i=0; i<n-1; i++){\\n        nums[i+1] += 10 * (nums[i] % 2);\\n        nums[i] /= 2;\\n    }\\n    \\n    nums[n-1] /= 2;\\n    \\n\\t}\\n\\n\\tint superPow(int a, int* b, int bSize){\\n\\n    if(bSize == 0)\\n        return 1;\\n    \\n    if(b[bSize-1]%2 == 1){\\n        b[bSize-1]--;\\n        return ( (a % 1337) * superPow(a, b, bSize) ) % 1337;\\n    }\\n    \\n    half(b, bSize);\\n    \\n    if(b[0]==0)\\n        b++, bSize--;\\n    \\n    return superPow( (a % 1337) * (a % 1337), b, bSize);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 910886,
                "title": "c-recursive-solution-using-binary-modular-exponentiation",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod=1337;\\n    int binpow(int a, int b)\\n    {\\n        int res=1;\\n        while(b)\\n        {\\n            if(b&1) res=(res*a)%mod;\\n            a=((a%mod)*(a%mod))%mod;\\n            b>>=1;\\n        }\\n        return res;\\n    }\\n    \\n    int superPow(int a, vector<int>& b) {\\n        if(b.size()==0) return 1;\\n        int digit=b.back();\\n        b.pop_back();\\n        return (binpow(superPow(a,b),10)%mod)*binpow(a,digit)%mod;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    const int mod=1337;\\n    int binpow(int a, int b)\\n    {\\n        int res=1;\\n        while(b)\\n        {\\n            if(b&1) res=(res*a)%mod;\\n            a=((a%mod)*(a%mod))%mod;\\n            b>>=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 859225,
                "title": "python-easy-to-understand-recursive-solution",
                "content": "```\\n# recursive solution based on idea here: https://leetcode.com/problems/super-pow/discuss/84472/C%2B%2B-Clean-and-Short-Solution\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        K = 1337\\n        if len(b) == 1:\\n            return a**b[0] % K\\n        return ((self.superPow(a, b[:-1])) ** 10) * (self.superPow(a, [b[-1]])) % K\\n```",
                "solutionTags": [],
                "code": "```\\n# recursive solution based on idea here: https://leetcode.com/problems/super-pow/discuss/84472/C%2B%2B-Clean-and-Short-Solution\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        K = 1337\\n        if len(b) == 1:\\n            return a**b[0] % K\\n        return ((self.superPow(a, b[:-1])) ** 10) * (self.superPow(a, [b[-1]])) % K\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813007,
                "title": "c-another-solution-of-lowering-the-exponent-99-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        // 1337 = 7 * 191 -> 1140 = 6 * 190\\n        // a^phi(n) = 1 mod n\\n        // a^1140 = 1 mod 1337\\n        // a^b mod 1337 = a^(b % 1140) % 1337 = (a % 1337)^(b % 1140) % 1337\\n        //   because a = (d + 1137f)^b mod n = d^b mod n\\n        \\n        auto op = [] (const auto &cur, const auto &in) {\\n            return (cur * 10 + in) % 1140;\\n        };\\n        int e = accumulate(b.begin(), b.end(), 0, op);\\n        \\n        // cout << a % 1337 <<\", \"<<e % 1140<<endl;\\n\\t\\t// Here we\\'d like to lower the exponent. If a = 932, b = 200:\\n\\t\\t// 932^200 % 1337\\n\\t\\t// = (932^2 % 1337) ^ 100 % 1337\\n\\t\\t// = (911^2 % 1337) ^ 50 % 1337\\n\\t\\t// = (981^2 % 1337) ^ 25 % 1337\\n\\t\\t// = 1058 * (1058^2 % 1337) ^ 12 % 1337\\n\\t\\t//   ^^^^ this value will be cached in `rem`\\n\\t\\t// ...\\n\\t\\t// = rem * <value> ^ 1 % 1337\\n        a =  a % 1337;\\n        int rem = 1;\\n        while (e > 1) {\\n            if (e & 1) {\\n                rem = rem * a % 1337;\\n                --e;\\n            }\\n            a = a * a % 1337;\\n            e >>= 1;\\n        }\\n        return rem * a % 1337;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        // 1337 = 7 * 191 -> 1140 = 6 * 190\\n        // a^phi(n) = 1 mod n\\n        // a^1140 = 1 mod 1337\\n        // a^b mod 1337 = a^(b % 1140) % 1337 = (a % 1337)^(b % 1140) % 1337\\n        //   because a = (d + 1137f)^b mod n = d^b mod n\\n        \\n        auto op = [] (const auto &cur, const auto &in) {\\n            return (cur * 10 + in) % 1140;\\n        };\\n        int e = accumulate(b.begin(), b.end(), 0, op);\\n        \\n        // cout << a % 1337 <<\", \"<<e % 1140<<endl;\\n\\t\\t// Here we\\'d like to lower the exponent. If a = 932, b = 200:\\n\\t\\t// 932^200 % 1337\\n\\t\\t// = (932^2 % 1337) ^ 100 % 1337\\n\\t\\t// = (911^2 % 1337) ^ 50 % 1337\\n\\t\\t// = (981^2 % 1337) ^ 25 % 1337\\n\\t\\t// = 1058 * (1058^2 % 1337) ^ 12 % 1337\\n\\t\\t//   ^^^^ this value will be cached in `rem`\\n\\t\\t// ...\\n\\t\\t// = rem * <value> ^ 1 % 1337\\n        a =  a % 1337;\\n        int rem = 1;\\n        while (e > 1) {\\n            if (e & 1) {\\n                rem = rem * a % 1337;\\n                --e;\\n            }\\n            a = a * a % 1337;\\n            e >>= 1;\\n        }\\n        return rem * a % 1337;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 733099,
                "title": "python-hardworking-way-high-speed-o-log-b-time-o-1-space",
                "content": "**Python  | Hardworking Way | High Speed | O( log b ) time, O(1) space**\\n\\nHardworking Solution for the problem, without using Python\\'s \"pow\" function. The following comments provide some insights. Cheers,\\n\\n**Insights:**\\n\\n1) If we convert b into a binary number, we get:\\n    \\n    ```a^b = a^( 2^(n-1) b[0]   +    2^(n-2) b[1]  + ... +    b[n-1] )```\\n        \\n    which is equal to...\\n        \\n    ```a^b = a^( 2^(n-1)*b[0] ) * a^(2^(n-2)*b[1]) * ...  a^( b[n-1] )```\\n     \\n2) Powers also fulfill this interesting property:\\n         \\n    ```a^(2^n) = a^(2^(n-1)) * a^(2^(n-1))```\\n \\n \\n**Conclusions:**\\n\\n1) We can convert b into a binary number to simplify the operations:\\n        \\n    ```a^b = a^( 2^(n-1)*b[0] ) * a^(2^(n-2)*b[1]) * ...  a^( b[n-1] )```\\n            \\n    Here, ```b[i]``` only corresponds to a ```[True/False]``` array telling us if a binary power is active or not.\\n     \\n2) To aid the process, we can consider this iterative procedure:\\n         \\n    ```a^b = Prod( mag[i]*b[i] ) % K```\\n             \\n    Where \"mag\" is an integer tracking the magnitude of the binary powers:\\n             \\n    ```mag    = a^(2^(n-1)), a^(2^(n-2)), ... a^4, a^2, 1```\\n                 \\n    One interesting property for the variable \"mag\" is that:\\n                 \\n    ```[i] = mag[i-1]^2```\\n                 \\n    Or applying the mod operator:\\n                     \\n    ```mag[i] = (mag[i-1]^2) % K```\\n         \\n3) To facilitate the iterations, it\\'s better to loop backwards starting from the last index position in the binary number \"b\"\\n\\n**Final Code**\\n```\\nclass Solution:\\n    def superPow(self, a, b):\\n        \\n        K     =  1337\\n        b     =  format( int(\\'\\'.join(map(str,b))) , \\'b\\' )\\n        mag   =  a % K\\n        res   =  1\\n\\t\\t\\n        for i in range(len(b)-1,-1,-1):\\n            if b[i]==\\'1\\':\\n                res = (res*mag) % K\\n            mag = (mag*mag) % K\\n        \\n\\t\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```a^b = a^( 2^(n-1) b[0]   +    2^(n-2) b[1]  + ... +    b[n-1] )```\n```a^b = a^( 2^(n-1)*b[0] ) * a^(2^(n-2)*b[1]) * ...  a^( b[n-1] )```\n```a^(2^n) = a^(2^(n-1)) * a^(2^(n-1))```\n```a^b = a^( 2^(n-1)*b[0] ) * a^(2^(n-2)*b[1]) * ...  a^( b[n-1] )```\n```b[i]```\n```[True/False]```\n```a^b = Prod( mag[i]*b[i] ) % K```\n```mag    = a^(2^(n-1)), a^(2^(n-2)), ... a^4, a^2, 1```\n```[i] = mag[i-1]^2```\n```mag[i] = (mag[i-1]^2) % K```\n```\\nclass Solution:\\n    def superPow(self, a, b):\\n        \\n        K     =  1337\\n        b     =  format( int(\\'\\'.join(map(str,b))) , \\'b\\' )\\n        mag   =  a % K\\n        res   =  1\\n\\t\\t\\n        for i in range(len(b)-1,-1,-1):\\n            if b[i]==\\'1\\':\\n                res = (res*mag) % K\\n            mag = (mag*mag) % K\\n        \\n\\t\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545749,
                "title": "less-than-100-memory-usage",
                "content": "```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a = a % 1337\\n        sum = pow(a,b[-1])%1337\\n        for i in range(len(b) - 2, -1, -1):\\n            a = pow(a, 10)%1337\\n            sum *= pow(a,b[i])\\n        return sum % 1337\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a = a % 1337\\n        sum = pow(a,b[-1])%1337\\n        for i in range(len(b) - 2, -1, -1):\\n            a = pow(a, 10)%1337\\n            sum *= pow(a,b[i])\\n        return sum % 1337\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 368820,
                "title": "java-100-with-explanation",
                "content": "East to prove:\\n \\n * for index i > 0 in b[], f(a, b, i) = a^(value(b(0...i-1) * 10 + b[i])) = f(a,b,i-1)^10 * a^b[i]\\n * (a1 \\xD7 a2 \\xD7 ... \\xD7 an) % p = (a1%p) \\xD7 (a2%p)... \\xD7 (an%p)\\n \\n ```\\n public static int superPow(int a, int[] b){\\n        if(b == null || b.length == 0) return 0;\\n        if(a == 0 || a == 1) return a;\\n        //case i == 0\\n        int ans = doPow(a, b[0]);\\n        //case i > 0\\n        for(int i=1;i<b.length;i++){\\n            int tmp = doPow(a, b[i]);\\n            ans = (doPow(ans, 10) * tmp) % 1337;\\n        }\\n        return ans;\\n    }\\n\\n    private static int doPow(int a, int pow){\\n        if(a > 1337) a %= 1337;\\n        int ans = 1;\\n        for(int i=0;i<pow;i++){\\n            ans *= a;\\n            if(ans > 1337) ans %= 1337;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n public static int superPow(int a, int[] b){\\n        if(b == null || b.length == 0) return 0;\\n        if(a == 0 || a == 1) return a;\\n        //case i == 0\\n        int ans = doPow(a, b[0]);\\n        //case i > 0\\n        for(int i=1;i<b.length;i++){\\n            int tmp = doPow(a, b[i]);\\n            ans = (doPow(ans, 10) * tmp) % 1337;\\n        }\\n        return ans;\\n    }\\n\\n    private static int doPow(int a, int pow){\\n        if(a > 1337) a %= 1337;\\n        int ans = 1;\\n        for(int i=0;i<pow;i++){\\n            ans *= a;\\n            if(ans > 1337) ans %= 1337;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 303536,
                "title": "java-iterative-solution",
                "content": "```\\nclass Solution {\\n    \\n    int mod = 1337;\\n    \\n    public int superPow(int a, int[] b) {\\n        a = a % mod;\\n        int result = 1;\\n        for (int i : b) {\\n            result = pow(result, 10) * pow(a, i) % mod;\\n        }\\n        return result;\\n    }\\n    \\n    private int pow(int a, int b) {\\n        a = a % mod;\\n        int pow = 1;\\n        for (int i = 0; i < b; i++) {\\n            pow = (pow * a) % mod;\\n        }\\n        return pow;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int mod = 1337;\\n    \\n    public int superPow(int a, int[] b) {\\n        a = a % mod;\\n        int result = 1;\\n        for (int i : b) {\\n            result = pow(result, 10) * pow(a, i) % mod;\\n        }\\n        return result;\\n    }\\n    \\n    private int pow(int a, int b) {\\n        a = a % mod;\\n        int pow = 1;\\n        for (int i = 0; i < b; i++) {\\n            pow = (pow * a) % mod;\\n        }\\n        return pow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180339,
                "title": "python-o-n-time-complexity",
                "content": "**pow_mod** is quite similar to ordinary **pow** except computing remainder instead of product. Since **b** could be larger than 2^31 so **superPow** is added. Otherwise **pow_mod(a, c)** is enough with O(lgN), where N is the value of c.\\nInside  **superPow**, I only call **pow_mod(a, 10)** with O(1). So the overall time complexity is O(N), where N is the length of b.\\n```\\nclass Solution:\\n    def superPow(self, a, b):\\n        if not b:\\n            return 1\\n        \\n        a = a % 1337\\n        ans = pow(a, b[len(b) - 1]) % 1337\\n        for i in range(len(b)-2, -1, -1):\\n            a = self.pow_mod(a, 10)\\n            ans = ans * pow(a, b[i]) % 1337\\n        return ans\\n    \\n    def pow_mod(self, a, b):\\n        ans = 1\\n        while b > 0:\\n            if b & 1 == 1:\\n                ans = ans * a % 1337\\n            a = a * a % 1337\\n            b = b >> 1\\n        return ans\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def superPow(self, a, b):\\n        if not b:\\n            return 1\\n        \\n        a = a % 1337\\n        ans = pow(a, b[len(b) - 1]) % 1337\\n        for i in range(len(b)-2, -1, -1):\\n            a = self.pow_mod(a, 10)\\n            ans = ans * pow(a, b[i]) % 1337\\n        return ans\\n    \\n    def pow_mod(self, a, b):\\n        ans = 1\\n        while b > 0:\\n            if b & 1 == 1:\\n                ans = ans * a % 1337\\n            a = a * a % 1337\\n            b = b >> 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145957,
                "title": "super-fast-solution-beats-100-with-fermat-s-little-theorem",
                "content": "This super fast solution based on **Fermat\\'s little theorem**, which could dramatically reduce N. We can always consider N smaller than 1337, in facts smaller than 191, to reduce complexity and computational scale of this problem. \\n\\nFirst of first, I attach **Fermat\\'s little theorem** here as:\\nmod(a ** p, p) == p if p is prime number.\\nThen we use the remainer of 7 and 191 to find the correct answer, where 7 * 191 = 1337 and both 7 and 191 are prime numbers.\\nAs many other people, we only concern the remainer of a over b, too. \\n\\n\\n```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a = a % 1337\\n        if a == 0:\\n            return 0\\n        if a % 7 != 0:\\n            b7 = 0\\n            for c in b:\\n                b7 *= 10\\n                b7 += c\\n                b7 %= 6\\n            re7 = a ** b7 % 7\\n        else:\\n            re7 = 0\\n            \\n        if a % 191 != 0:            \\n            b191 = 0            \\n            for c in b:\\n                b191 *= 10\\n                b191 += c\\n                b191 %= 190\\n            re191 = a ** b191 % 191\\n        else:\\n            re191 = 0\\n        for i in range(1337):\\n            if i % 7 == re7 and i % 191 == re191:\\n                return i****\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a = a % 1337\\n        if a == 0:\\n            return 0\\n        if a % 7 != 0:\\n            b7 = 0\\n            for c in b:\\n                b7 *= 10\\n                b7 += c\\n                b7 %= 6\\n            re7 = a ** b7 % 7\\n        else:\\n            re7 = 0\\n            \\n        if a % 191 != 0:            \\n            b191 = 0            \\n            for c in b:\\n                b191 *= 10\\n                b191 += c\\n                b191 %= 190\\n            re191 = a ** b191 % 191\\n        else:\\n            re191 = 0\\n        for i in range(1337):\\n            if i % 7 == re7 and i % 191 == re191:\\n                return i****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141239,
                "title": "chinese-remainder-theory-fermat-small-theorem-and-extended-euclid-method-with-explanation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getmod(vector<int> a,int m){\\n        int rmd=0;\\n        for (auto i:a){\\n            rmd=rmd*10+i;\\n            rmd%=m;\\n        }\\n        return rmd;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        //1337=7*191, gcd(7,191)=1\\n        //a^b = a^(b%6) (mod 7) = a1 (mod 7), because a^6 = 1 (mod 7) when a cannot divide 7, when a can divide 7, a1 is always 0\\n        //a^b = a^(b%190) (mod 191) =a2 (mod 191)\\n        //a^b = [a1*191q+a2*7p] (mod 1337)\\n        //where 7p+191q=1\\n        //191=7*27+2\\n        //7=2*3+1\\n        //2=191+(-27)*7\\n        //1=7+(-3)*2\\n        //1=7+[191+(-27)*7]*(-3)\\n        //1=(-3)*191+82*7\\n        //p=82, q=-3\\n        //a^b = [574a2-573a1] (mod 1337)\\n        a%=1337;\\n        int t7=getmod(b,6),t191=getmod(b,190);\\n        int a1=1,a2=1;\\n        while (t7--) a1=(a1*a)%7;\\n        while (t191--) a2=(a2*a)%191;\\n        if (a%7==0) a1=0;\\n        if (a%191==0) a2=0;\\n        return (574*a2-573*a1+1337*1337)%1337;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getmod(vector<int> a,int m){\\n        int rmd=0;\\n        for (auto i:a){\\n            rmd=rmd*10+i;\\n            rmd%=m;\\n        }\\n        return rmd;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        //1337=7*191, gcd(7,191)=1\\n        //a^b = a^(b%6) (mod 7) = a1 (mod 7), because a^6 = 1 (mod 7) when a cannot divide 7, when a can divide 7, a1 is always 0\\n        //a^b = a^(b%190) (mod 191) =a2 (mod 191)\\n        //a^b = [a1*191q+a2*7p] (mod 1337)\\n        //where 7p+191q=1\\n        //191=7*27+2\\n        //7=2*3+1\\n        //2=191+(-27)*7\\n        //1=7+(-3)*2\\n        //1=7+[191+(-27)*7]*(-3)\\n        //1=(-3)*191+82*7\\n        //p=82, q=-3\\n        //a^b = [574a2-573a1] (mod 1337)\\n        a%=1337;\\n        int t7=getmod(b,6),t191=getmod(b,190);\\n        int a1=1,a2=1;\\n        while (t7--) a1=(a1*a)%7;\\n        while (t191--) a2=(a2*a)%191;\\n        if (a%7==0) a1=0;\\n        if (a%191==0) a2=0;\\n        return (574*a2-573*a1+1337*1337)%1337;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84471,
                "title": "short-c-solution-o-n-no-recursion-does-not-require-mathmatics-knowledge",
                "content": "```\\n    int superPow(int a, vector<int>& b) {\\n        int result = 1;\\n        a %= 1337;\\n        for(int i = 0;i<b.size();i++){\\n            for(int j = 0;j<b[b.size()-i-1];j++){\\n                result=(result*a)%1337;\\n            }\\n            int a2 = (a*a)%1337;\\n            int a4 = (a2*a2)%1337;\\n            int a8 = (a4*a4)%1337; \\n            a = (a8*a2)%1337;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int superPow(int a, vector<int>& b) {\\n        int result = 1;\\n        a %= 1337;\\n        for(int i = 0;i<b.size();i++){\\n            for(int j = 0;j<b[b.size()-i-1];j++){\\n                result=(result*a)%1337;\\n            }\\n            int a2 = (a*a)%1337;\\n            int a4 = (a2*a2)%1337;\\n            int a8 = (a4*a4)%1337; \\n            a = (a8*a2)%1337;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 84481,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Super Pow** https://leetcode.com/problems/super-pow/\\n\\n**Brute-Force Solution**\\n* Brute force solution uses `result, iterations = int((result * int(a % 1337))%1337), iterations-1`\\n* Time complexity of the solution is O(b) where b is the size or value of b.\\n\\n```\\nclass Solution1(object):\\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        factor, result = 1, 1\\n        for i in range(len(b)-1, -1, -1):\\n            iterations = b[i]*factor\\n            while iterations:\\n                result, iterations = int((result * int(a % 1337))%1337), iterations-1\\n            factor *= 10\\n        return result\\n```\\n\\n**Optimized Solution - Order of number of digits of b**\\n* The algorithm can be described using this example where b = [7,8,5]\\n*  a^785 = a^700 * a^80 * a^5 = ((a^70 * a^8)^10) * ( a^5)\\n* (((a^7)^10 * a^8)^10) * ( a^5) \\n* First iteration: a^7 and (a^7)^10 = a^70\\n* Second iteration = a^70 * a^8 and (a^78)^10 = a^780\\n* Third iteration = a^780 * a ^5 = a^785\\n\\n```\\nclass Solution(object):\\n    def compute_pow(self, a, b):\\n        if b == 0:\\n            return 1\\n        elif b == 1:\\n            return a\\n        elif b & 1:\\n            x = self.compute_pow(a,(b-1)//2) % 1337\\n            return int(((a % 1337) * (x * x) % 1337) % 1337)\\n        else:\\n            x = self.compute_pow(a,b//2) % 1337\\n            return int((x * x) % 1337)\\n    \\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a, result = a%1337, 1\\n        for i in range(len(b)):\\n            result = (result * self.compute_pow(a, b[i])) % 1337\\n            result = self.compute_pow(result, 10) if i != len(b)-1 else result\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution1(object):\\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        factor, result = 1, 1\\n        for i in range(len(b)-1, -1, -1):\\n            iterations = b[i]*factor\\n            while iterations:\\n                result, iterations = int((result * int(a % 1337))%1337), iterations-1\\n            factor *= 10\\n        return result\\n```\n```\\nclass Solution(object):\\n    def compute_pow(self, a, b):\\n        if b == 0:\\n            return 1\\n        elif b == 1:\\n            return a\\n        elif b & 1:\\n            x = self.compute_pow(a,(b-1)//2) % 1337\\n            return int(((a % 1337) * (x * x) % 1337) % 1337)\\n        else:\\n            x = self.compute_pow(a,b//2) % 1337\\n            return int((x * x) % 1337)\\n    \\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a, result = a%1337, 1\\n        for i in range(len(b)):\\n            result = (result * self.compute_pow(a, b[i])) % 1337\\n            result = self.compute_pow(result, 10) if i != len(b)-1 else result\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84504,
                "title": "java-4ms-short-solution",
                "content": "```\\n    public int superPow(int a, int[] b) {\\n        int[] buf = new int[10];\\n        buf[0] = 1;\\n        a = a%1337;\\n        for(int i =1;i<10;i++){               //since b is large, and b[i] is between 0 and 9, which reuse several times, we build pattern for them\\n            buf[i] = (buf[i-1]*a)%1337;\\n        }\\n        int ans = buf[b[0]], temp;\\n        for(int i = 1;i<b.length;i++){\\n            ans = (ans*ans)%1337;      //calculate ans^10%1337 in 5 lines, since we may have ans^3>Integer.MAX_VALUE.\\n            temp = ans;\\n            ans = (ans*ans)%1337;\\n            ans = (ans*ans)%1337;\\n            ans = (ans*temp)%1337;\\n            ans = (ans*buf[b[i]])%1337;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int superPow(int a, int[] b) {\\n        int[] buf = new int[10];\\n        buf[0] = 1;\\n        a = a%1337;\\n        for(int i =1;i<10;i++){               //since b is large, and b[i] is between 0 and 9, which reuse several times, we build pattern for them\\n            buf[i] = (buf[i-1]*a)%1337;\\n        }\\n        int ans = buf[b[0]], temp;\\n        for(int i = 1;i<b.length;i++){\\n            ans = (ans*ans)%1337;      //calculate ans^10%1337 in 5 lines, since we may have ans^3>Integer.MAX_VALUE.\\n            temp = ans;\\n            ans = (ans*ans)%1337;\\n            ans = (ans*ans)%1337;\\n            ans = (ans*temp)%1337;\\n            ans = (ans*buf[b[i]])%1337;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 84524,
                "title": "java-solution-pigeonhole-principle",
                "content": "The idea is to find a cycle in the power. As the number is modded by 1337, there must be a duplication among the power of from 1 to 1337. This tells which position in cycle b corresponds to.\\n\\n    public int superPow(int a, int[] b) {\\n    \\tint []pows = new int[1337];    // max cycle is 1337 \\t\\n        Set<Integer> set = new HashSet<Integer>();\\n        \\n        // pigeon hole principle dictates that must be a duplicate among the power from 1 to 1337 if moded by 1337\\n        int cycle = 0;\\n        int val = 1;\\n        for (int i = 0; i < 1337; i++)  {\\n            val = (int)(((long)val * a) % 1337);\\n            // cycle found\\n            if (set.contains(val)) break;\\n            set.add(val);\\n            pows[cycle++] = val;\\n        }\\n        \\n        // b: String -> BigInteger\\n        StringBuilder str = new StringBuilder();\\n        for(int v: b) str.append(v);\\n        BigInteger bVal = new BigInteger(str.toString());\\n        \\n        bVal = bVal.subtract(new BigInteger(\"1\")).mod(new BigInteger(\"\" + cycle));\\n        return pows[bVal.intValue()];\\n    }",
                "solutionTags": [],
                "code": "The idea is to find a cycle in the power. As the number is modded by 1337, there must be a duplication among the power of from 1 to 1337. This tells which position in cycle b corresponds to.\\n\\n    public int superPow(int a, int[] b) {\\n    \\tint []pows = new int[1337];    // max cycle is 1337 \\t\\n        Set<Integer> set = new HashSet<Integer>();\\n        \\n        // pigeon hole principle dictates that must be a duplicate among the power from 1 to 1337 if moded by 1337\\n        int cycle = 0;\\n        int val = 1;\\n        for (int i = 0; i < 1337; i++)  {\\n            val = (int)(((long)val * a) % 1337);\\n            // cycle found\\n            if (set.contains(val)) break;\\n            set.add(val);\\n            pows[cycle++] = val;\\n        }\\n        \\n        // b: String -> BigInteger\\n        StringBuilder str = new StringBuilder();\\n        for(int v: b) str.append(v);\\n        BigInteger bVal = new BigInteger(str.toString());\\n        \\n        bVal = bVal.subtract(new BigInteger(\"1\")).mod(new BigInteger(\"\" + cycle));\\n        return pows[bVal.intValue()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 84530,
                "title": "really-strange-result-anyone-can-help",
                "content": "This is the solution that worked perfectly:\\n```\\npublic class Solution {\\n    public int superPow(int a, int[] b) {\\n        int res = 1;\\n        for(int i = 0; i < b.length; i++){\\n            res = pow(res, 10) * pow(a, b[i]) % 1337;\\n        }\\n        return res;\\n    }\\n    public int pow(int a, int b){\\n        if(b == 0) return 1;\\n        if(b == 1) return a % 1337;\\n\\n        return pow(a % 1337, b/2)*pow(a % 1337, b - b/2) % 1337;\\n    }\\n}\\n```\\nThen I only changed a little bit on the last line of pow function:\\n```\\n    public int pow(int a, int b){\\n        if(b == 0) return 1;\\n        if(b == 1) return a % 1337;\\n        return pow(a % 1337, b/2)*pow(a % 1337, b/2)*pow(a % 1337, b - b/2 - b/2) % 1337;\\n    }\\n```\\nI thought these two expression were equivalent. How ever, the latter generated wrong result. Can anyone help me with this problem? Thanks in advance.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int superPow(int a, int[] b) {\\n        int res = 1;\\n        for(int i = 0; i < b.length; i++){\\n            res = pow(res, 10) * pow(a, b[i]) % 1337;\\n        }\\n        return res;\\n    }\\n    public int pow(int a, int b){\\n        if(b == 0) return 1;\\n        if(b == 1) return a % 1337;\\n\\n        return pow(a % 1337, b/2)*pow(a % 1337, b - b/2) % 1337;\\n    }\\n}\\n```\n```\\n    public int pow(int a, int b){\\n        if(b == 0) return 1;\\n        if(b == 1) return a % 1337;\\n        return pow(a % 1337, b/2)*pow(a % 1337, b/2)*pow(a % 1337, b - b/2 - b/2) % 1337;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84473,
                "title": "simple-python-solution-by-find-the-loop",
                "content": "```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        s = 1\\n        idx = 0\\n        d = {1:0}\\n        res = [1]\\n        while True:\\n            idx += 1\\n            s = (s * a) % 1337\\n            if s in d:\\n                break\\n            res.append(s)\\n            d[s] = idx\\n        ib = int(''.join(map(str, b)))\\n        idx1 = (ib - d[s]) % (idx - d[s])\\n        return res[d[s]+idx1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        s = 1\\n        idx = 0\\n        d = {1:0}\\n        res = [1]\\n        while True:\\n            idx += 1\\n            s = (s * a) % 1337\\n            if s in d:\\n                break\\n            res.append(s)\\n            d[s] = idx\\n        ib = int(''.join(map(str, b)))\\n        idx1 = (ib - d[s]) % (idx - d[s])\\n        return res[d[s]+idx1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047177,
                "title": "python-2-diff-approach-99-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n<!-- 1 Approach -->\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        s = \\'\\'\\n        for n in b:\\n            s += str(n)\\n\\n        return pow(a,int(s),1337)\\n\\n#==================================================\\n<!-- 2 Approach -->\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        s = \\'\\'\\n        for n in b:\\n            s += str(n)\\n        b = int(s)\\n\\n        ans = 1\\n        while b != 0:\\n            if b%2 == 0:             #even\\n                b = b//2\\n                a = (a*a) %1337\\n            else:                       #odd\\n                ans = (ans*a) %1337\\n                b = b-1\\n        \\n        return ans\\n\\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Divide and Conquer"
                ],
                "code": "```\\n<!-- 1 Approach -->\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        s = \\'\\'\\n        for n in b:\\n            s += str(n)\\n\\n        return pow(a,int(s),1337)\\n\\n#==================================================\\n<!-- 2 Approach -->\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        s = \\'\\'\\n        for n in b:\\n            s += str(n)\\n        b = int(s)\\n\\n        ans = 1\\n        while b != 0:\\n            if b%2 == 0:             #even\\n                b = b//2\\n                a = (a*a) %1337\\n            else:                       #odd\\n                ans = (ans*a) %1337\\n                b = b-1\\n        \\n        return ans\\n\\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691328,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n         int num=0;\\n        for(int i:b){\\n            num=(num*10+i)%1140;\\n        }\\n        return binexpo(a,num,1337);\\n    }\\n    public int binexpo(int a, int b, int m){\\n        a%=m;\\n        int res=1;\\n        while(b>0){\\n            if((b&1)==1)\\n                res=(res*a)%m;\\n            a=(a*a)%m;\\n            b>>=1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n         int num=0;\\n        for(int i:b){\\n            num=(num*10+i)%1140;\\n        }\\n        return binexpo(a,num,1337);\\n    }\\n    public int binexpo(int a, int b, int m){\\n        a%=m;\\n        int res=1;\\n        while(b>0){\\n            if((b&1)==1)\\n                res=(res*a)%m;\\n            a=(a*a)%m;\\n            b>>=1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186474,
                "title": "big-mod-algorithm-c-easy-to-understand",
                "content": "# Don\\'t forget to upvote this post       ^_^\\n# Approach\\nlet a=1 and v=[2,5,4];\\nso we have to find out the value of a^(254)%mod [mod=1337]\\n\\n**Observation:**\\n\\n (a^1)^10 * a^2= a^2\\n (a^2)^10 * a^5=a^(20+5)=a^25\\n (a^25)^10 * a^4= a^250 * a^4= a^254\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n O(nlogn)\\n\\n- Space complexity:\\n O(1)\\n\\n# video Link: https://youtu.be/BR2Gyr9EvH8\\n\\n# Code\\n```\\nclass Solution {\\ntypedef long long int ll;\\npublic:\\n   ll bigmod(ll num,ll power,ll mod)\\n   {\\n       if(power==0)return 1;\\n       else if(power&1)\\n        return (num*(bigmod(num,power-1,mod)))%mod;\\n      else{\\n          ll p=bigmod(num,power/2,mod)%mod;\\n          return (p*p)%mod;\\n      }\\n       \\n   }\\n\\n    int superPow(int a, vector<int>& b) {\\n        \\n      ll ans=1,mod=1337;\\n      for(auto power:b)\\n        {\\n             ans=bigmod(ans,10,mod)*bigmod(a,power,mod);\\n             ans%=mod;\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long int ll;\\npublic:\\n   ll bigmod(ll num,ll power,ll mod)\\n   {\\n       if(power==0)return 1;\\n       else if(power&1)\\n        return (num*(bigmod(num,power-1,mod)))%mod;\\n      else{\\n          ll p=bigmod(num,power/2,mod)%mod;\\n          return (p*p)%mod;\\n      }\\n       \\n   }\\n\\n    int superPow(int a, vector<int>& b) {\\n        \\n      ll ans=1,mod=1337;\\n      for(auto power:b)\\n        {\\n             ans=bigmod(ans,10,mod)*bigmod(a,power,mod);\\n             ans%=mod;\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131242,
                "title": "python-solution-one-linear-easy-to-understand-for-begineers-pow-function",
                "content": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        return pow(a,int(\\'\\'.join(map(str,b))),1337)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        return pow(a,int(\\'\\'.join(map(str,b))),1337)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102618,
                "title": "python-easiest-code-beating-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Firstly convert the list b to an integer and then return the power od the given number to the integer with mod 1337.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Firstly converted the list b to an integer(s). Then, simply returning the value of power of a to s mod 1337 by the following statement:\\npow(a,s,1337)\\n# Code\\n```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        s=0\\n        for i in b:\\n            if i==0:\\n                s*=10\\n            else:\\n                s=s*10+i\\n        return (pow(a,s,1337))\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        s=0\\n        for i in b:\\n            if i==0:\\n                s*=10\\n            else:\\n                s=s*10+i\\n        return (pow(a,s,1337))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994880,
                "title": "easiest-python-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        number = \\'\\'\\n        for digit in b:\\n            number += str(digit)\\n        number = int(number)\\n        return pow(a, number, 1337) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        number = \\'\\'\\n        for digit in b:\\n            number += str(digit)\\n        number = int(number)\\n        return pow(a, number, 1337) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618542,
                "title": "full-explanation",
                "content": "class Solution {\\npublic:\\n\\n    //basic iterative function to calculate the power\\n    int power_cal(int a,int power,int M)\\n    {\\n        a=a%M;//if a is too large we can mod it tooo((a^b)%M=((a%M)^b)%M)\\n         int ans=1;\\n        while(power)\\n        {\\n            if(power&1)\\n            {\\n                ans=(ans*1LL*a)%M;\\n            }\\n            a=(a*1LL*a)%M;\\n            power=power>>1;\\n        }\\n        return ans;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n       \\n        //since we need to calculate a to the power b and for that we know..what we know\\uD83D\\uDE02\\uD83D\\uDE02\\n        \\n        //ummm so basically a to the power b needs to be calculated and we know b is too large so its modulus needs to be taken but wait a to the power b (jisme hmm b ka modulus ka bolre) but it is not mathematicaly proved so it\\'s wrong..\\n        \\n        //so here aaya maths which states...\\n        \\n        // euler theorem stats that a^b=(a^(b % etf of M))%M where etf is euler totient function and further it is the number of coprimes till that number(coprime having 1 as the common factor only..example 2,3 and 3,4)....note etf of 5 is 4(1,2,3,4)...\\n        \\n        int M=1337;\\n        \\n        //step 1:-cal etf of 1337..basically it has a formula but there we need prime number(will discuss that too but later on)\\n        int etf=0;\\n        for(int i=1;i<=1337;i++)\\n        {\\n            if(__gcd(i,1337)==1)\\n                etf++;\\n        }\\n      // step 2:- calculate the power completety using euler theorem..power to be calculated from forward\\n       \\n        int power=0;\\n        for(int i=0;i<b.size();i++)//how to generate a number from 1 2 3 to 123 we know that (num*10+b[i]) and since we need in terms of modulo so...\\n        {\\n            power=(power*10+b[i])%etf;\\n        }\\n        \\n        //step 3 we have the setup complete so now just calculate it(a^b)\\n       return power_cal(a,power,M);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n\\n    //basic iterative function to calculate the power\\n    int power_cal(int a,int power,int M)\\n    {\\n        a=a%M;//if a is too large we can mod it tooo((a^b)%M=((a%M)^b)%M)\\n         int ans=1;\\n        while(power)\\n        {\\n            if(power&1)\\n            {\\n                ans=(ans*1LL*a)%M;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2470649,
                "title": "java-euler-s-theorem-binary-exponentiation",
                "content": "**References**\\n* https://en.wikipedia.org/wiki/Modular_arithmetic\\n* https://cp-algorithms.com/algebra/binary-exp.html#algorithm\\n* https://math.stackexchange.com/questions/735253/in-fermats-little-theorem-if-mod-is-not-prime\\n* https://mathtools.lagrida.com/arithmetic/euler_totient.html\\n\\n\\n**Approach** \\n\\nWe have to find `(a^b) mod 1337`\\n\\nBy Eulers Theorem : `\\uD835\\uDC4E^\\uD835\\uDF19(1337) \\u2261 1 mod 1337` where `\\uD835\\uDF19()` is Euler\\'s Toitent Function\\nNow, `\\uD835\\uDF19(1337) = 1140 `  (See References)\\n\\n`\\uD835\\uDC4E^\\uD835\\uDF19(1337) \\u2261 1 mod 1337` \\u21D2 `\\uD835\\uDC4E^1140 \\u2261 1 mod 1337` \\u21D2 Multiply with `a^(b/1140)` on both sides\\n\\u21D2 `a^b \\u2261  (a^(b/1140) mod m * a ^ (b % 1140) mod m`\\n\\nNow, Since `\\uD835\\uDC4E^1140 \\u2261 1 mod 1337`, it can proven that `a^(1140n) \\u2261 1 mod 1337` \\n\\u21D2 `a^b \\u2261  1 * a ^ (b % 1140) mod m`\\n\\nSince, `b[]` is an array and we need to find the mod of actual power, for every digit we need to find ` (digit * 10^place ) % 1140` and add this to result of modded power\\n\\nWe can use binary exponentiation with modular operations to find this.\\n\\n**Time Complexity** : O(logM * N * logN) , `N = b[].length, M = b(as a number) mod 1140`\\n**Space Complexity** : O(1)\\n\\nImplementation:\\n```\\nclass Mod{\\n\\n  private final long mod;\\n\\n  Mod(int mod) {\\n    this.mod = mod;\\n  }\\n\\n  int get(long val) {\\n\\n    return (int)((val + mod) % mod);\\n\\n  }\\n\\n  int mul(long x, long y) {\\n\\n    return get(get(x) * get(y));\\n\\n  }\\n\\n  int add(long x, long y) {\\n    return get(get(x) + get(y));\\n  }\\n\\n  public int expo(long a, long b) {\\n\\n    long res = 1;\\n\\n    while (b > 0) {\\n\\n      if (b % 2 != 0) res = mul(res, a);\\n\\n      a = mul(a, a);\\n\\n      b /= 2;\\n\\n    }\\n\\n    return get(res);\\n\\n  }\\n\\n  public int reduce(int b[]) {\\n\\n    int res = 0, n = b.length;\\n\\n    for (int i = 0; i < b.length; i++) {\\n\\n      res = add(res, mul(b[i], expo(10, n - i - 1)));\\n\\n    }\\n\\n    return res;\\n\\n  }\\n\\n}\\n\\nclass Solution {\\n\\n  public int superPow(int a, int[] b) {\\n\\n    Mod mod = new Mod(1337);\\n      \\n    Mod tmod = new Mod(1140);\\n      \\n    return mod.expo(a,tmod.reduce(b));\\n\\n  }\\n}\\n```\\n\\n**Note** : One thing to note is that according to Euler\\'s Theorem, `a` and `1337` must also be co-prime, for the congurence to hold. But this solution still seems to be working for other cases as well. e.g `a = 191, b[] = [2,0,0]`\\nProofs, Explanations and Contradictions are welcome.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Mod{\\n\\n  private final long mod;\\n\\n  Mod(int mod) {\\n    this.mod = mod;\\n  }\\n\\n  int get(long val) {\\n\\n    return (int)((val + mod) % mod);\\n\\n  }\\n\\n  int mul(long x, long y) {\\n\\n    return get(get(x) * get(y));\\n\\n  }\\n\\n  int add(long x, long y) {\\n    return get(get(x) + get(y));\\n  }\\n\\n  public int expo(long a, long b) {\\n\\n    long res = 1;\\n\\n    while (b > 0) {\\n\\n      if (b % 2 != 0) res = mul(res, a);\\n\\n      a = mul(a, a);\\n\\n      b /= 2;\\n\\n    }\\n\\n    return get(res);\\n\\n  }\\n\\n  public int reduce(int b[]) {\\n\\n    int res = 0, n = b.length;\\n\\n    for (int i = 0; i < b.length; i++) {\\n\\n      res = add(res, mul(b[i], expo(10, n - i - 1)));\\n\\n    }\\n\\n    return res;\\n\\n  }\\n\\n}\\n\\nclass Solution {\\n\\n  public int superPow(int a, int[] b) {\\n\\n    Mod mod = new Mod(1337);\\n      \\n    Mod tmod = new Mod(1140);\\n      \\n    return mod.expo(a,tmod.reduce(b));\\n\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393255,
                "title": "337-c-solution-easy-to-understand",
                "content": "```\\n//We are using the property that mod can be distibuted \\n//(a*b)%m = ((a%m)*(b%m))%m\\n//To deal with big number given in vector , we first take the last integer out\\n//this makes the big number divisible by 10\\n//Then we take the power 10 outside which reduces the number length\\n//We do this until the length of big number reduces to 0\\n//a^523 = a^520*a^3 = ((a^52)^10)*a^3 =(((a^50)*a^2)^10)*a^3 = ((((a^5)^10)*a^2)^10)*a^3 \\n\\nclass Solution {\\nint mod= 1337;\\n    int pow(int a, int b){\\n        if(b==0){\\n            return 1;\\n        }\\n        int res=1;\\n        while(b){\\n            if(b&1){\\n                res=(res*(a%mod))%mod;\\n            }\\n            a = ((a%mod)*(a%mod))%mod;\\n            b=b>>1;\\n        }\\n           return res;      \\n    }\\n    int count (int a, vector<int>&b, int len){\\n        if(len==0){\\n            return 1;\\n        }\\n        int last=b[len-1];\\n        int res1= pow(a,last);\\n        int res2= pow(count(a,b,len-1),10);\\n        return (res1*res2)%mod;\\n    }\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        int len = b.size();\\n        return count(a,b,len);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//We are using the property that mod can be distibuted \\n//(a*b)%m = ((a%m)*(b%m))%m\\n//To deal with big number given in vector , we first take the last integer out\\n//this makes the big number divisible by 10\\n//Then we take the power 10 outside which reduces the number length\\n//We do this until the length of big number reduces to 0\\n//a^523 = a^520*a^3 = ((a^52)^10)*a^3 =(((a^50)*a^2)^10)*a^3 = ((((a^5)^10)*a^2)^10)*a^3 \\n\\nclass Solution {\\nint mod= 1337;\\n    int pow(int a, int b){\\n        if(b==0){\\n            return 1;\\n        }\\n        int res=1;\\n        while(b){\\n            if(b&1){\\n                res=(res*(a%mod))%mod;\\n            }\\n            a = ((a%mod)*(a%mod))%mod;\\n            b=b>>1;\\n        }\\n           return res;      \\n    }\\n    int count (int a, vector<int>&b, int len){\\n        if(len==0){\\n            return 1;\\n        }\\n        int last=b[len-1];\\n        int res1= pow(a,last);\\n        int res2= pow(count(a,b,len-1),10);\\n        return (res1*res2)%mod;\\n    }\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        int len = b.size();\\n        return count(a,b,len);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256376,
                "title": "c-solution-binary-exponentiation",
                "content": "Binary exponentiation has a time complexity of O(log |b|) (Where |b| represents the numerical value of b vector. since size of b <=2000, |b|\\'s max will be ~ 10^2000 . log |10^2000| number of computations will be performed, however in normal binary exponentiation, dividing b by 2 takes constant time, here in our approach, dividing the whole array b by 2 will take O(b.size()) time. so finally the upper bound for calculating the final answer will be ~ 2000* 2000 , which can positively give AC. \\n \\n Here is the code.\\n \\n ```\\n \\nclass Solution {\\n    void divideby(vector<int>&b)\\n    {\\n        int i =0;\\n        int temp=b[0];\\n        while(temp<2)\\n        { b[i]=temp/2; \\n         if(i+1<b.size()) \\n          temp = temp * 10+b[++i];\\n         else\\n         break; }\\n       \\n        while(b.size()>i)\\n        {\\n            b[i]=temp/2;\\n             if(i+1<b.size()) \\n            temp = (temp % 2) * 10+b[++i];\\n            else\\n            break;\\n        }\\n      \\n                \\n    }\\n    \\n\\n\\n\\npublic: int superPow(int a, vector<int>& b) {\\n       int res = 1;\\n    while (accumulate(b.begin(),b.end(),0) > 0) {\\n        if (b[b.size()-1]%2)\\n            res = (res%1337 * a%1337)%1337;\\n        a = (a%1337) * (a%1337)%1337;\\n       divideby(b);\\n    }\\n    return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\n    void divideby(vector<int>&b)\\n    {\\n        int i =0;\\n        int temp=b[0];\\n        while(temp<2)\\n        { b[i]=temp/2; \\n         if(i+1<b.size()) \\n          temp = temp * 10+b[++i];\\n         else\\n         break; }",
                "codeTag": "Java"
            },
            {
                "id": 2177384,
                "title": "c-solution-from-scratch-finding-etf-of-mod",
                "content": "```\\nclass Solution {\\n    int temp=1337, m=1337;\\n    void sieve() {\\n        bool isPrime[m+1];\\n        memset(isPrime, 1, sizeof(isPrime));\\n        for(int p=2; p*p<=m; p++) {\\n            if(isPrime[p]) {\\n                for(int i=p*p; i<=m; i+=p) isPrime[i]=0;\\n            }\\n        }\\n        for(int i=2; i<m+1; i++) {\\n            if(isPrime[i]&&m%i==0) temp*=(i-1), temp/=i;\\n        }\\n        // cout<<temp;\\n    }\\n    \\n    int power(int a, int b) {\\n        a%=m;\\n        int ans=1;\\n        long long power=1;\\n        while(b) {\\n            if(power&b) {\\n                ans=(ans%m*a)%m;\\n                b-=power;\\n            }\\n            a=(a*a)%m;\\n            power<<=1;\\n        }\\n        return ans%m;\\n    }\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        sieve();\\n        int num=0, base=1;\\n        for(int i=b.size()-1; i>=0; i--) {\\n            num+=(b[i]%temp*(base%temp))%temp;\\n            base=(base*10)%temp;\\n        }\\n        return (power(a,num))%m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int temp=1337, m=1337;\\n    void sieve() {\\n        bool isPrime[m+1];\\n        memset(isPrime, 1, sizeof(isPrime));\\n        for(int p=2; p*p<=m; p++) {\\n            if(isPrime[p]) {\\n                for(int i=p*p; i<=m; i+=p) isPrime[i]=0;\\n            }\\n        }\\n        for(int i=2; i<m+1; i++) {\\n            if(isPrime[i]&&m%i==0) temp*=(i-1), temp/=i;\\n        }\\n        // cout<<temp;\\n    }\\n    \\n    int power(int a, int b) {\\n        a%=m;\\n        int ans=1;\\n        long long power=1;\\n        while(b) {\\n            if(power&b) {\\n                ans=(ans%m*a)%m;\\n                b-=power;\\n            }\\n            a=(a*a)%m;\\n            power<<=1;\\n        }\\n        return ans%m;\\n    }\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        sieve();\\n        int num=0, base=1;\\n        for(int i=b.size()-1; i>=0; i--) {\\n            num+=(b[i]%temp*(base%temp))%temp;\\n            base=(base*10)%temp;\\n        }\\n        return (power(a,num))%m;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2115886,
                "title": "c-efficient-and-concise-math-etf-concept-fastest-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int  binPowMod(int a, long long  number ,long long mod =1337 ){\\n        long long  res =1;\\n        long long x =a;\\n        while(number>0){\\n            if(number&1){\\n                res = (res%mod * x%mod)%mod;\\n            }\\n            x = (x%mod * x%mod)%mod;\\n            number = number>>1;\\n        }\\n        return res%mod;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        long long number = 0;\\n        long long ten = 1;\\n//         phi(1337) => 1337(1-1/7)(1-1/191) => 1140\\n        for(long long i = b.size()-1LL ; i>=0 ; i--){\\n            number += (b[i]%1140*ten%1140)%1140;\\n            ten = (ten%1140 * 10%1140)%1140;\\n        }\\n        return binPowMod(a,number);\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int  binPowMod(int a, long long  number ,long long mod =1337 ){\\n        long long  res =1;\\n        long long x =a;\\n        while(number>0){\\n            if(number&1){\\n                res = (res%mod * x%mod)%mod;\\n            }\\n            x = (x%mod * x%mod)%mod;\\n            number = number>>1;\\n        }\\n        return res%mod;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        long long number = 0;\\n        long long ten = 1;\\n//         phi(1337) => 1337(1-1/7)(1-1/191) => 1140\\n        for(long long i = b.size()-1LL ; i>=0 ; i--){\\n            number += (b[i]%1140*ten%1140)%1140;\\n            ten = (ten%1140 * 10%1140)%1140;\\n        }\\n        return binPowMod(a,number);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093684,
                "title": "c-solution-euler-s-theorem",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int powr(long long int a, long long int b, int m) {\\n        long long int ans=1;\\n        while(b>0) {\\n            if(b&1) ans=(ans*a)%m; \\n\\t\\t\\ta=(a*a)%m; b>>=1;\\n        } \\n\\t\\treturn (ans%m);\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        int m_a = 1337, m_b = 1140; // cause ETF Value(m_a) = 1140\\n        long long int b_value=0;\\n        for(auto i: b)\\n            b_value=((b_value*10)+i)%m_b;\\n        return powr(a%m_a,b_value,m_a);\\n\\t}\\n};\\n```\\n>This solution is easier to understand if you have the knowledge of ETF & Euler\\'s Theorem (which you can get [here](https://youtu.be/GApcdkIe9WM)).",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int powr(long long int a, long long int b, int m) {\\n        long long int ans=1;\\n        while(b>0) {\\n            if(b&1) ans=(ans*a)%m; \\n\\t\\t\\ta=(a*a)%m; b>>=1;\\n        } \\n\\t\\treturn (ans%m);\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        int m_a = 1337, m_b = 1140; // cause ETF Value(m_a) = 1140\\n        long long int b_value=0;\\n        for(auto i: b)\\n            b_value=((b_value*10)+i)%m_b;\\n        return powr(a%m_a,b_value,m_a);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969219,
                "title": "one-line-python",
                "content": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        return pow(a, int(\"\".join([str(i) for i in b])), 1337)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        return pow(a, int(\"\".join([str(i) for i in b])), 1337)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920679,
                "title": "simple-python-solution",
                "content": "Similar to https://leetcode.com/problems/powx-n/\\n\\n```\\nclass Solution:\\n    def calc_pow(self,x,n):\\n        if n == 0: return 1\\n        \\n        mid = self.calc_pow(x,n//2)\\n        \\n        if n%2==0:\\n            return (mid*mid)%1337\\n        else:\\n            return (x*mid*mid)%1337\\n        \\n    def superPow(self, a: int, b: List[int]) -> int:\\n        b_str = \"\".join([str(i) for i in b])\\n        power = int(b_str)        \\n        return self.calc_pow(a,power)\\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Similar to https://leetcode.com/problems/powx-n/\\n\\n```\\nclass Solution:\\n    def calc_pow(self,x,n):\\n        if n == 0: return 1\\n        \\n        mid = self.calc_pow(x,n//2)\\n        \\n        if n%2==0:\\n            return (mid*mid)%1337\\n        else:\\n            return (x*mid*mid)%1337\\n        \\n    def superPow(self, a: int, b: List[int]) -> int:\\n        b_str = \"\".join([str(i) for i in b])\\n        power = int(b_str)        \\n        return self.calc_pow(a,power)\\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1873389,
                "title": "2-approaches-brute-force-and-binary-exponentiation",
                "content": "[Leetcode](https://leetcode.com/) [372. Super Pow](https://leetcode-cn.com/problems/super-pow/).\\n\\n***By Frank Luo***\\n\\n\\n# Intuition\\n\\nThis problem is to find a integer raised to the power **a very large number** whose length may be $200$ or more.\\n\\n\\n# Brute Froce\\n\\nWe multiply $a$ to itself $b$ times. That is, $a^b = \\\\underbrace{a \\\\times a \\\\dots \\\\times a}_b$. \\n\\nWe can write such code easily.\\n\\n```java\\n    public static int superPow(int a, int[] b) {\\n        if (a == 1) {\\n            return 1;\\n        }\\n\\n        int ans = a;\\n        int len = b.length;\\n        for (int i = len - 1; i >= 0; i--) {\\n            int base = (int) Math.pow(10, len - 1 - i);\\n            int num = b[i] * base;\\n            for (int j = 1; j < num; j++) {\\n                ans = ((ans % 1337) * (a % 1337)) % 1337;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(10^mb_i)$, $m$ is the length of array b.\\n- **Space Complexity**: $O(1)$\\n\\nObiviously, it will exceed time limit, so we have to find a more efficiently algorithm.\\n\\n\\n\\n# Binary Exponentiation\\n\\nRecall the [Fast Power Algorithm: Binary Exponentiation](https://leetcode.com/problems/powx-n/solutions/1869646/fast-power-algorithm-binary-exponentiation/), we develop a fast power algorithm, so we can use it here directly.\\n\\nWe didn\\'t need to change the method of fast power.\\n\\n```java\\n    public int superPow(int a, int[] b) {\\n        if (a == 1) {\\n            return 1;\\n        }\\n\\n        int ans = 1;\\n        int len = b.length;\\n        for (int i = len - 1; i >= 0; i--) {\\n            ans = (int) ((long) ans * binaryPower(a, b[i]) % 1337);\\n            a = binaryPower(a, 10);\\n        }\\n\\n        return ans;\\n    }\\n\\n    public static int binaryPower(int base, int exp) {\\n        int res = 1;\\n        while (exp > 0) {\\n            if ((exp & 1) == 1) {\\n                res = (int) ((long) res * base % 1337);\\n            }\\n\\n            base = (int) ((long) base * base % 1337);\\n            exp = exp >> 1;\\n        }\\n\\n        return res;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(\\\\sum\\\\limits_{i=0}^{m-1} \\\\log b_i)$, $m$ is the length of array $b$.\\n- **Space Complexity**: $O(1)$\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```java\\n    public static int superPow(int a, int[] b) {\\n        if (a == 1) {\\n            return 1;\\n        }\\n\\n        int ans = a;\\n        int len = b.length;\\n        for (int i = len - 1; i >= 0; i--) {\\n            int base = (int) Math.pow(10, len - 1 - i);\\n            int num = b[i] * base;\\n            for (int j = 1; j < num; j++) {\\n                ans = ((ans % 1337) * (a % 1337)) % 1337;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\n```java\\n    public int superPow(int a, int[] b) {\\n        if (a == 1) {\\n            return 1;\\n        }\\n\\n        int ans = 1;\\n        int len = b.length;\\n        for (int i = len - 1; i >= 0; i--) {\\n            ans = (int) ((long) ans * binaryPower(a, b[i]) % 1337);\\n            a = binaryPower(a, 10);\\n        }\\n\\n        return ans;\\n    }\\n\\n    public static int binaryPower(int base, int exp) {\\n        int res = 1;\\n        while (exp > 0) {\\n            if ((exp & 1) == 1) {\\n                res = (int) ((long) res * base % 1337);\\n            }\\n\\n            base = (int) ((long) base * base % 1337);\\n            exp = exp >> 1;\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1847201,
                "title": "o-n-c-solution",
                "content": "**Idea :**\\n1. To understand the solution, knowledge of  [Fermat-Euler theorum](https://en.wikipedia.org/w/index.php?title=Euler%27s_theorem&oldid=1069867279) and how to calculate value of [Euler\\'s totient function](https://en.wikipedia.org/w/index.php?title=Euler%27s_totient_function&oldid=1060227676) is required.\\n\\nIt is mentionable that [Fermat-Euler theorum](https://en.wikipedia.org/w/index.php?title=Euler%27s_theorem&oldid=1069867279) is a generalization of [Fermat\\'s little theorem](https://en.wikipedia.org/w/index.php?title=Fermat%27s_little_theorem&oldid=1076742381). While fermat\\'s little theorum is applicable only for prime numbers Fermat-Euler is applicable for all numbers.\\n\\n![image](https://assets.leetcode.com/users/images/fb41ba9f-f879-48d9-8517-a01b2c161b4f_1647211207.0776253.png)\\n\\n2. Here [binary exponentiation](https://cp-algorithms.com/algebra/binary-exp.html) is used for fast exponentiation.\\n\\n**Algorithm steps :**\\n1. Find power % 1140 from vector b;\\n2. FInd exponentiation by [binary exponentiation](https://cp-algorithms.com/algebra/binary-exp.html)\\n\\n**code**\\n```cpp\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n\\t\\t//calculation of power\\n        int pow = 0;\\n        for(auto x: b) pow = (10 * pow + x) % 1140;\\n        \\n\\t\\t//exponentiation\\n        int ans = 1, t = a % 1337;\\n        \\n        while(pow){\\n            if(pow % 2)\\n                ans = t * ans % 1337;\\n            \\n            t = t * t % 1337;\\n            pow /= 2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\nCalculation to find power needs one iteration => O(N) \\nBinary exponentiation takes O(logN) time on the exponent N.\\nAs here power highest can be 1139 so, exponentiation part is roughly a contant\\n\\nTotal Complexity : O(N)\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n\\t\\t//calculation of power\\n        int pow = 0;\\n        for(auto x: b) pow = (10 * pow + x) % 1140;\\n        \\n\\t\\t//exponentiation\\n        int ans = 1, t = a % 1337;\\n        \\n        while(pow){\\n            if(pow % 2)\\n                ans = t * ans % 1337;\\n            \\n            t = t * t % 1337;\\n            pow /= 2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733157,
                "title": "c-simple",
                "content": "class Solution {\\npublic:\\n    long long binExp(long long a,long long b,long long m){\\n        long long ans=1;\\n        while(b){\\n            if(b&1){\\n                ans=(ans*a)%m;\\n            }\\n            a=(a*a)%m;\\n            b>>=1;\\n        }\\n        return ans;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n       //phi(1337)=7*191\\n       // 1337*(1-1/7)*(1-1/191)\\n       //1140\\n        int bmod=0;\\n        for(int val:b){\\n            bmod=(bmod*10+val)%1140;\\n        }\\n        return binExp(a,bmod,1337);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long binExp(long long a,long long b,long long m){\\n        long long ans=1;\\n        while(b){\\n            if(b&1){\\n                ans=(ans*a)%m;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1709461,
                "title": "python-explanation-built-in-function-dp-dfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        if a==1:\\n            return 1\\n        c=0\\n        for i in b:\\n            c=10*c+i\\n        return pow(a,c,1337)\\n```\\n**For Explanation:**\\nRead [this](https://www.w3schools.com/python/ref_func_pow.asp).",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        if a==1:\\n            return 1\\n        c=0\\n        for i in b:\\n            c=10*c+i\\n        return pow(a,c,1337)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701860,
                "title": "an-easy-solution-through-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n         int size = b.size() - 1;\\n        int value = b[0];\\n        for (int i = 1; i <= size; i++)\\n        {\\n            value = (value * 10 + b[i]) % 1140;\\n        }\\n        int ans = power(a, value, 1337);\\n        return ans;\\n        \\n    }\\n    long long power(long long a, long long b, long m)\\n    {\\n        long long ans = 1;\\n        while (b > 0)\\n        {\\n            if (b & 1)\\n            {\\n                ans = (ans * a) % m;\\n            }\\n            a = (a * a) % m;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n};\\n// just simply used eulers theorem\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n         int size = b.size() - 1;\\n        int value = b[0];\\n        for (int i = 1; i <= size; i++)\\n        {\\n            value = (value * 10 + b[i]) % 1140;\\n        }\\n        int ans = power(a, value, 1337);\\n        return ans;\\n        \\n    }\\n    long long power(long long a, long long b, long m)\\n    {\\n        long long ans = 1;\\n        while (b > 0)\\n        {\\n            if (b & 1)\\n            {\\n                ans = (ans * a) % m;\\n            }\\n            a = (a * a) % m;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n};\\n// just simply used eulers theorem\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588818,
                "title": "python-80ms-99-28-14-3mb-65-7-using-chinese-remainder-theorem-and-binary-exponentiation",
                "content": "1337=7*190\\nby Fermat\\'s Theorem:\\n\\na mod 7 has order phi(7)=6\\na mod 191 has order phi(191)=190\\n\\nTherefore a^n mod 7 can be computed as a7^exp7 mod 7 where\\na7=a%7 and exp7=n%6.\\nAnd, a^n mod 191 can be computed as a191^exp191 mod 191 where\\na191=a%191 and exp191=n%190\\n\\nThen the solution  a7*764+a191*574%1337 has the required property that it is \\ncongruent to a^n mod7 and a^n mod 191 because:\\n\\t  764 = 191*( 191^(-1) mod7) % 1337\\nand 574= 7*(7^(-1)mod191) %1337\\n\\n\"\"\"\\ndef superPow(self, a: int, b: List[int]) -> int:\\n\\n\\texp7=(sum(b)*4-3*b[-1])%6 #each non-trivial power of 10 is congruent to 4 mod 6, except for the zeroth power.\\n\\texp191=0\\n\\tfor x in b:\\n\\t\\texp191=(x+10*exp191)%190\\n\\n\\ta7,a191=a%7,a%191       \\n\\tif a7>1: a7=pow(a7,exp7,7)\\n\\tif a191>1: a191=pow(a191,exp191,191)\\n\\treturn((a7*764+a191*574)%1337)\\n\\ndef pow(a,n,m): #return a^n mod p, p a prime\\n\\n\\t\\n\\tpower=a%p\\n\\tif power<=1: return power\\n\\tans=1\\n\\twhile (n):\\n\\t\\tif n&1:\\n\\t\\t\\tans*=pow%p\\n\\t\\tpow*=pow%(p-1)\\n\\t\\tn= n>>1\\n\\treturn(ans)\\n\"\"\"",
                "solutionTags": [],
                "code": "1337=7*190\\nby Fermat\\'s Theorem:\\n\\na mod 7 has order phi(7)=6\\na mod 191 has order phi(191)=190\\n\\nTherefore a^n mod 7 can be computed as a7^exp7 mod 7 where\\na7=a%7 and exp7=n%6.\\nAnd, a^n mod 191 can be computed as a191^exp191 mod 191 where\\na191=a%191 and exp191=n%190\\n\\nThen the solution  a7*764+a191*574%1337 has the required property that it is \\ncongruent to a^n mod7 and a^n mod 191 because:\\n\\t  764 = 191*( 191^(-1) mod7) % 1337\\nand 574= 7*(7^(-1)mod191) %1337\\n\\n\"\"\"\\ndef superPow(self, a: int, b: List[int]) -> int:\\n\\n\\texp7=(sum(b)*4-3*b[-1])%6 #each non-trivial power of 10 is congruent to 4 mod 6, except for the zeroth power.\\n\\texp191=0\\n\\tfor x in b:\\n\\t\\texp191=(x+10*exp191)%190\\n\\n\\ta7,a191=a%7,a%191       \\n\\tif a7>1: a7=pow(a7,exp7,7)\\n\\tif a191>1: a191=pow(a191,exp191,191)\\n\\treturn((a7*764+a191*574)%1337)\\n\\ndef pow(a,n,m): #return a^n mod p, p a prime\\n\\n\\t\\n\\tpower=a%p\\n\\tif power<=1: return power\\n\\tans=1\\n\\twhile (n):\\n\\t\\tif n&1:\\n\\t\\t\\tans*=pow%p\\n\\t\\tpow*=pow%(p-1)\\n\\t\\tn= n>>1\\n\\treturn(ans)\\n\"\"\"",
                "codeTag": "Python3"
            },
            {
                "id": 1557098,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        ans = 1\\n        for i in b:\\n            ans = (ans**10 * a**i) % 1337\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        ans = 1\\n        for i in b:\\n            ans = (ans**10 * a**i) % 1337\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552629,
                "title": "python-solution-beats-86",
                "content": "A simple python solution beats 86.07%\\nFirst convert the list into a string list and then convert it into a integer. \\n\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        b=list(map(str,b))\\n        b=\"\".join(b)\\n        b=int(b)\\n        x=pow(a,b,1337)\\n        return x\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        b=list(map(str,b))\\n        b=\"\".join(b)\\n        b=int(b)\\n        x=pow(a,b,1337)\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307063,
                "title": "ruby-solution",
                "content": "\\n```\\n# @param {Integer} a\\n# @param {Integer[]} b\\n# @return {Integer}\\n\\ndef super_pow(a, b)\\n  return 0 if a == 0\\n  \\n  ans = 1\\n  b.each do |i|\\n    ans = (((ans ** 10) % 1337) * ((a ** i) % 1337)) % 1337\\n  end\\n  \\n  ans\\nend\\n```\\n\\n\\nfor example:\\nb = [3, 2, 5]\\na ^ 325 = a ^ ((3 * 10 + 2) * 10 + 5)\\n\\nWe can loop through the array and calculate the final result. \\nTo aviod memory brusting, always mod the numbers in the process.\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} a\\n# @param {Integer[]} b\\n# @return {Integer}\\n\\ndef super_pow(a, b)\\n  return 0 if a == 0\\n  \\n  ans = 1\\n  b.each do |i|\\n    ans = (((ans ** 10) % 1337) * ((a ** i) % 1337)) % 1337\\n  end\\n  \\n  ans\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1303560,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        List<Integer> modulos = getModulos(a, 1337);\\n        int remainder = calcRemainder(b, modulos.size());\\n        int moduloIndex = (remainder == 0 ? modulos.size() : remainder) - 1;\\n        return modulos.get(moduloIndex);\\n    }\\n    \\n    public List<Integer> getModulos(int pow, int mod) {\\n        List<Integer> modulos = new ArrayList<Integer>();\\n        Set<Integer> found = new HashSet<Integer>();\\n        int modulo = pow % mod;\\n        do {\\n            found.add(modulo);\\n            modulos.add(modulo);\\n            modulo *= (pow % mod);\\n            modulo %= mod;\\n        } while (!found.contains(modulo));\\n        return modulos;\\n    }\\n    \\n    public int calcRemainder(int[] dividend, int divisor) {\\n        int remainder = 0;\\n        for (int d : dividend) {\\n            remainder *= 10;\\n            remainder += d;\\n            remainder %= divisor;\\n        }\\n        return remainder;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int superPow(int a, int[] b) {\\n        List<Integer> modulos = getModulos(a, 1337);\\n        int remainder = calcRemainder(b, modulos.size());\\n        int moduloIndex = (remainder == 0 ? modulos.size() : remainder) - 1;\\n        return modulos.get(moduloIndex);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1133258,
                "title": "python3-solution-94-64-faster",
                "content": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        if a in [1,0]:\\n            return a\\n        return int(pow(a,int(\"\".join(str(i) for i in b)),1337))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        if a in [1,0]:\\n            return a\\n        return int(pow(a,int(\"\".join(str(i) for i in b)),1337))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124654,
                "title": "java-4ms-solution-use-hashmap",
                "content": "1.  If `a = 1337 x + y`, then `a^b % 1337 = y^b % 1337`, so at the beginning we can do `a = a % 1337`.\\n2.  Use a hashmap to store power to the mod value, because the different entries cannot be more than 1337, mod value will start cycling afterwards.\\n3.  Do the textbook division math by dividing `b` with the size of the map, from left to right, to get the final reminder.\\n\\n```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        a = a % 1337; \\n        if (a <= 1) return a;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();  // power of a -> a^power mod 1337\\n        Set<Integer> set = new HashSet<>();  // for O(1) search of existing value in the map\\n\\t\\t\\n        int val = a, power = 1;\\n        while (! set.contains(val)) {\\n            map.put(power, val);\\n            set.add(val);\\n            val = (val * a) % 1337;\\n            power++;\\n        }\\n        \\n        int reminder = 0;\\n        for (int i = 0; i < b.length; i++) {\\n            reminder = (reminder * 10 + b[i]) % set.size();\\n        }\\n        \\n        return map.get(reminder);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        a = a % 1337; \\n        if (a <= 1) return a;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();  // power of a -> a^power mod 1337\\n        Set<Integer> set = new HashSet<>();  // for O(1) search of existing value in the map\\n\\t\\t\\n        int val = a, power = 1;\\n        while (! set.contains(val)) {\\n            map.put(power, val);\\n            set.add(val);\\n            val = (val * a) % 1337;\\n            power++;\\n        }\\n        \\n        int reminder = 0;\\n        for (int i = 0; i < b.length; i++) {\\n            reminder = (reminder * 10 + b[i]) % set.size();\\n        }\\n        \\n        return map.get(reminder);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059858,
                "title": "java",
                "content": "may have faster ways, idea should be same, optimization not worthy,lol\\n```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        int mod = 1337;\\n        int len = b.length;\\n        long res = 1;\\n        long base = a;\\n        for(int i=len-1; i>=0; i--){\\n            int cur = b[i];\\n            long local = 1;\\n            while(cur>0){\\n                local = (local*base)%mod;\\n                cur--;\\n            }\\n            res = (res*local)%mod;\\n            long nextbase = 1;\\n            for(int c=0; c<10; c++)\\n                nextbase = (nextbase*base)%mod;\\n            base = nextbase;\\n        }\\n        return (int)res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int superPow(int a, int[] b) {\\n        int mod = 1337;\\n        int len = b.length;\\n        long res = 1;\\n        long base = a;\\n        for(int i=len-1; i>=0; i--){\\n            int cur = b[i];\\n            long local = 1;\\n            while(cur>0){\\n                local = (local*base)%mod;\\n                cur--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1050294,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        k = 1337\\n        mod = a % k\\n        mod_pow = [mod]\\n        rest = mod\\n        for i in range(k):\\n            rest = (mod*rest) % k\\n            if rest == mod:    \\n                break\\n            else:\\n                mod_pow.append(rest)\\n                \\n        max_mod_pow = len(mod_pow)        \\n        index =0\\n        for b_pow in b:\\n            index = index*10 +b_pow\\n            if index>max_mod_pow:\\n                index= index % max_mod_pow\\n    \\n        return mod_pow[index-1]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        k = 1337\\n        mod = a % k\\n        mod_pow = [mod]\\n        rest = mod\\n        for i in range(k):\\n            rest = (mod*rest) % k\\n            if rest == mod:    \\n                break\\n            else:\\n                mod_pow.append(rest)\\n                \\n        max_mod_pow = len(mod_pow)        \\n        index =0\\n        for b_pow in b:\\n            index = index*10 +b_pow\\n            if index>max_mod_pow:\\n                index= index % max_mod_pow\\n    \\n        return mod_pow[index-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 921815,
                "title": "fast-power-using-c",
                "content": "```\\nint fastpow(int base,int pow,int k){\\n    long long ans=1;\\n    while(pow>0){\\n        if(pow%2==0){\\n            base=(base*base)%k;\\n            pow/=2;\\n        }\\n        else{\\n            pow--;\\n            ans=(ans*base)%k;\\n        }\\n    }\\n    return ans%k;\\n}\\nint superPow(int a, int* b, int size){\\n    const int k=1337;\\n    a=a%k;\\n    int i,ans=1,sub=a;\\n    for(i=size-1;i>-1;i--){\\n        ans=(ans*fastpow(sub,b[i],k))%k;\\n        sub=fastpow(sub,10,k);\\n            \\n        \\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint fastpow(int base,int pow,int k){\\n    long long ans=1;\\n    while(pow>0){\\n        if(pow%2==0){\\n            base=(base*base)%k;\\n            pow/=2;\\n        }\\n        else{\\n            pow--;\\n            ans=(ans*base)%k;\\n        }\\n    }\\n    return ans%k;\\n}\\nint superPow(int a, int* b, int size){\\n    const int k=1337;\\n    a=a%k;\\n    int i,ans=1,sub=a;\\n    for(i=size-1;i>-1;i--){\\n        ans=(ans*fastpow(sub,b[i],k))%k;\\n        sub=fastpow(sub,10,k);\\n            \\n        \\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 886433,
                "title": "euler-c",
                "content": "```\\n// Approach: Use Euler formula but write a custom function to divide array by 2\\nclass Solution {\\n    // divide number by 2\\n    void div2(vector<int> &b){\\n        int carry=0;\\n        for (int i=0;i<b.size();i++){\\n            int num=carry*10+b[i];\\n            int q=num/2;\\n            int rem=num%2;\\n            b[i]=q;\\n            carry=rem;\\n        }\\n        while (!b.empty() and b.front()==0){\\n            b.erase(b.begin());\\n        }\\n    }\\n    int expo (int n, vector<int>& b, int m){\\n        int ans=1;\\n        while (!b.empty()){\\n            if (b.back()&1) ans = ((ans%m)*(n%m))%m;\\n            n=((n%m)*(n%m))%m;\\n            div2(b);\\n        }\\n        return ans;\\n        \\n    }\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        return expo(a,b,1337);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Approach: Use Euler formula but write a custom function to divide array by 2\\nclass Solution {\\n    // divide number by 2\\n    void div2(vector<int> &b){\\n        int carry=0;\\n        for (int i=0;i<b.size();i++){\\n            int num=carry*10+b[i];\\n            int q=num/2;\\n            int rem=num%2;\\n            b[i]=q;\\n            carry=rem;\\n        }\\n        while (!b.empty() and b.front()==0){\\n            b.erase(b.begin());\\n        }\\n    }\\n    int expo (int n, vector<int>& b, int m){\\n        int ans=1;\\n        while (!b.empty()){\\n            if (b.back()&1) ans = ((ans%m)*(n%m))%m;\\n            n=((n%m)*(n%m))%m;\\n            div2(b);\\n        }\\n        return ans;\\n        \\n    }\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        return expo(a,b,1337);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856637,
                "title": "c-o-n-iterative-solution",
                "content": "```\\n\\tstatic const int MOD = 1337;\\n    int myPow(int x, int n) {\\n        \\n        int ans = 1;\\n        int base = x % 1337;\\n        for(;n;n>>=1,base=(base*base)%1337){\\n            if(n&1)ans=(ans*base)%1337;\\n        }\\n        return ans;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n\\n        reverse(b.begin(),b.end());\\n        \\n        int base = a;\\n        int ans = 1;\\n        for(int d:b){\\n            ans=(ans*myPow(base,d))%MOD;\\n            base=myPow(base,10)%MOD;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tstatic const int MOD = 1337;\\n    int myPow(int x, int n) {\\n        \\n        int ans = 1;\\n        int base = x % 1337;\\n        for(;n;n>>=1,base=(base*base)%1337){\\n            if(n&1)ans=(ans*base)%1337;\\n        }\\n        return ans;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n\\n        reverse(b.begin(),b.end());\\n        \\n        int base = a;\\n        int ans = 1;\\n        for(int d:b){\\n            ans=(ans*myPow(base,d))%MOD;\\n            base=myPow(base,10)%MOD;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736826,
                "title": "python-with-fermat-euler-theorem",
                "content": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        n=0\\n        for d in b:\\n            n=n*10\\n            n=n+d\\n        # Fermat\\u2013Euler theorem: a^(\\u03D5(n)) mod n = 1\\n        n=n%1140 # \\u03D5(1337)=1337*(1-1/7)*(1-1/191)=1140\\n        return (a**n)%1337\\n```\\n\\nEuler Theorem: https://en.wikipedia.org/wiki/Euler%27s_theorem",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        n=0\\n        for d in b:\\n            n=n*10\\n            n=n+d\\n        # Fermat\\u2013Euler theorem: a^(\\u03D5(n)) mod n = 1\\n        n=n%1140 # \\u03D5(1337)=1337*(1-1/7)*(1-1/191)=1140\\n        return (a**n)%1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711512,
                "title": "simple-java-biginteger-solution",
                "content": "```\\nimport java.math.*; \\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        BigInteger A = BigInteger.valueOf(a);\\n        String s = \"\";\\n        for(int i=0; i<b.length; i++) {\\n            s += b[i];\\n        }\\n        \\n        BigInteger B = new BigInteger(s);\\n        \\n        return A.modPow(B, BigInteger.valueOf(1337)).intValue();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.*; \\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        BigInteger A = BigInteger.valueOf(a);\\n        String s = \"\";\\n        for(int i=0; i<b.length; i++) {\\n            s += b[i];\\n        }\\n        \\n        BigInteger B = new BigInteger(s);\\n        \\n        return A.modPow(B, BigInteger.valueOf(1337)).intValue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708739,
                "title": "java-2ms-fermat-s-little-theorem-and-chinese-remainder-theorem",
                "content": "https://en.wikipedia.org/wiki/Fermat%27s_little_theorem\\nhttps://en.wikipedia.org/wiki/Chinese_remainder_theorem \\n\\n```\\n  static final int MOD = 1337;  // prime factorization 7 * 191\\n\\n  public static int superPow(int a, int[] b) {\\n    int r1 = superPow(a, b, 7);\\n    int r2 = superPow(a, b, 191);\\n    for (int i = r2; i < MOD; i += 191) {\\n      if (i % 7 == r1) {\\n        return i;\\n      }\\n    }\\n    return -1;\\n  }\\n\\n  public static int superPow(int a, int[] b, int p) {\\n    a = a % p;\\n    int c = 0;\\n    // Fermat\\'s little theorem: a^(p-1) == 1 mod p\\n    for (int i : b) {\\n      c = (c * 10 + i) % (p-1);\\n    }\\n    return powmod(a, c, p);\\n  }\\n\\n  // compute a^c % mod\\n  static int powmod(int a, int c, int mod) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    int ans = 1;\\n    int m = a;\\n    while (c > 0) {\\n      if (c % 2 == 1) {\\n        ans = (ans * m) % mod;\\n      }\\n      m = (m * m) % mod;\\n      c >>= 1;\\n    }\\n    return ans;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  static final int MOD = 1337;  // prime factorization 7 * 191\\n\\n  public static int superPow(int a, int[] b) {\\n    int r1 = superPow(a, b, 7);\\n    int r2 = superPow(a, b, 191);\\n    for (int i = r2; i < MOD; i += 191) {\\n      if (i % 7 == r1) {\\n        return i;\\n      }\\n    }\\n    return -1;\\n  }\\n\\n  public static int superPow(int a, int[] b, int p) {\\n    a = a % p;\\n    int c = 0;\\n    // Fermat\\'s little theorem: a^(p-1) == 1 mod p\\n    for (int i : b) {\\n      c = (c * 10 + i) % (p-1);\\n    }\\n    return powmod(a, c, p);\\n  }\\n\\n  // compute a^c % mod\\n  static int powmod(int a, int c, int mod) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    int ans = 1;\\n    int m = a;\\n    while (c > 0) {\\n      if (c % 2 == 1) {\\n        ans = (ans * m) % mod;\\n      }\\n      m = (m * m) % mod;\\n      c >>= 1;\\n    }\\n    return ans;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 624405,
                "title": "getting-wrong-answer",
                "content": "In problem statement, it was required to calculate **a^b** with **mod 1337**. I\\'m doing exactly the same, didn\\'t understand where I\\'m going wrong.\\n```\\ns=0\\nfor i, d in enumerate(ls[::-1]): \\n    s = (s+d*(10**i))%1337\\na = 78267%1337\\nprint(a, s)\\nprint((a**s)%1337)\\n```",
                "solutionTags": [],
                "code": "```\\ns=0\\nfor i, d in enumerate(ls[::-1]): \\n    s = (s+d*(10**i))%1337\\na = 78267%1337\\nprint(a, s)\\nprint((a**s)%1337)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 514663,
                "title": "python3-faster-than-99-5-1-line-code",
                "content": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        return pow(a,int(\\'\\'.join(map(str,b))),1337)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        return pow(a,int(\\'\\'.join(map(str,b))),1337)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478176,
                "title": "easy-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private const int MODULO = 1337;\\n\\n        private int SimplePow(int n, int pow)\\n        {\\n            checked\\n            {\\n                int res = 1;\\n                for (int i = 0; i < pow; i++)\\n                {\\n                    res *= (n % MODULO);\\n                    res = res % MODULO;\\n                }\\n\\n                return res;\\n            }\\n        }\\n\\n        public int SuperPow(int a, int[] b)\\n        {\\n            int res = 1;\\n\\n            for (int i = 0; i < b.Length; i++)\\n            {\\n                res = SimplePow(res, 10);\\n                res *= SimplePow(a, b[i]);\\n                res = res % MODULO;\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private const int MODULO = 1337;\\n\\n        private int SimplePow(int n, int pow)\\n        {\\n            checked\\n            {\\n                int res = 1;\\n                for (int i = 0; i < pow; i++)\\n                {\\n                    res *= (n % MODULO);\\n                    res = res % MODULO;\\n                }\\n\\n                return res;\\n            }\\n        }\\n\\n        public int SuperPow(int a, int[] b)\\n        {\\n            int res = 1;\\n\\n            for (int i = 0; i < b.Length; i++)\\n            {\\n                res = SimplePow(res, 10);\\n                res *= SimplePow(a, b[i]);\\n                res = res % MODULO;\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383468,
                "title": "javascript-easy-to-understand-2-solutions-52ms",
                "content": "First solution, we loop the `b` array and do the multiplication for it. At last, we get the answer.\\n\\n```js\\nconst superPow = (a, b) => {\\n  const MOD_BASE = 1337;\\n  if (a % MOD_BASE < 2) return a % MOD_BASE;\\n  let ret = 1;\\n  for (let i = 0; i < b.length; ++i) {\\n    for (let j = 0; j < b[i]; ++j) {\\n      ret = (ret * a) % MOD_BASE;\\n    }\\n    if (i !== b.length - 1) {\\n      const tmp = ret;\\n      for (let j = 0; j < 9; ++j) {\\n        ret = (ret * tmp) % MOD_BASE;\\n      }\\n    }\\n  }\\n  return ret;\\n};\\n```\\n\\nSecond solution is a more mathmatic one which I read from [this post](https://leetcode.com/problems/super-pow/discuss/84466/Math-solusion-based-on-Euler\\'s-theorem-power-called-only-ONCE-C%2B%2BJava1-line-Python). And here\\'s the JS code:\\n\\n```js\\nconst MOD_BASE = 1337;\\nconst myPow = (x, n) => {\\n  if (n === 0) return 1;\\n  if (n === 1) return x;\\n  const a = (x * x) % MOD_BASE;\\n  const b = (n & 1) === 0 ? myPow(a, n >>> 1) : x * myPow(a, (n - 1) >>> 1);\\n  return b % MOD_BASE;\\n};\\nconst superPow = (a, b) => {\\n  if (a % MOD_BASE === 0) return 0;\\n  let c = 0;\\n  for (let i = 0; i < b.length; ++i) {\\n    c = (c * 10 + b[i]) % 1140;\\n  }\\n  if (c === 0) c += 1440;\\n  return myPow(a % MOD_BASE, c);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst superPow = (a, b) => {\\n  const MOD_BASE = 1337;\\n  if (a % MOD_BASE < 2) return a % MOD_BASE;\\n  let ret = 1;\\n  for (let i = 0; i < b.length; ++i) {\\n    for (let j = 0; j < b[i]; ++j) {\\n      ret = (ret * a) % MOD_BASE;\\n    }\\n    if (i !== b.length - 1) {\\n      const tmp = ret;\\n      for (let j = 0; j < 9; ++j) {\\n        ret = (ret * tmp) % MOD_BASE;\\n      }\\n    }\\n  }\\n  return ret;\\n};\\n```\n```js\\nconst MOD_BASE = 1337;\\nconst myPow = (x, n) => {\\n  if (n === 0) return 1;\\n  if (n === 1) return x;\\n  const a = (x * x) % MOD_BASE;\\n  const b = (n & 1) === 0 ? myPow(a, n >>> 1) : x * myPow(a, (n - 1) >>> 1);\\n  return b % MOD_BASE;\\n};\\nconst superPow = (a, b) => {\\n  if (a % MOD_BASE === 0) return 0;\\n  let c = 0;\\n  for (let i = 0; i < b.length; ++i) {\\n    c = (c * 10 + b[i]) % 1140;\\n  }\\n  if (c === 0) c += 1440;\\n  return myPow(a % MOD_BASE, c);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249193,
                "title": "easy-understand-memory-efficient-method",
                "content": "[Wiki Modular_exponentiation](https://en.wikipedia.org/wiki/Modular_exponentiation)\\nusing memory-efficent method to handle bit by bit\\nmultiple the left right part  and mod by 1337 recursively\\n\\nExample:\\n\\n888<sup>666</sup> \\n= (888<sup>66</sup>)<sup>10</sup> * 888<sup>6</sup> \\n= ((888<sup>6</sup>)<sup>10</sup> * 888<sup>6</sup> )<sup>10</sup> * 888<sup>6</sup> \\n= ((888<sup>6</sup> mod 1337)<sup>10</sup> mod 1337 * 888<sup>6</sup> mod 1337)<sup>10</sup> mod 1337 * 888<sup>6</sup> mod 1337\\n= ((1170)<sup>10</sup> mod 1337 * 1170)<sup>10</sup> mod 1337 * 1170\\n= (1198 * 1170 mod 1337)<sup>10</sup> mod 1337 * 1170\\n= 484<sup>10</sup> mod 1337 * 1170\\n= 918 * 1170 mod 1337\\n= 449\\n\\nSolution:\\n```c#\\npublic class Solution {\\n    public int SuperPow (int a, int[] b) {\\n        a = a % 1337;\\n        return SuperPow (a, b, b.Length - 1);\\n    }\\n\\n    public int SuperPow (int a, int[] b, int index) {\\n        var right = SuperPow (a, b[index]);\\n        var left = 1;\\n        if (index != 0) {\\n            left = SuperPow (SuperPow (a, b, index - 1), 10);\\n        }\\n        return left * right % 1337;\\n    }\\n\\n    public int SuperPow (int a, int b) {\\n        var c = 1;\\n        for (int i = 0; i < b; i++) {\\n            c = (c * a) % 1337;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```c#\\npublic class Solution {\\n    public int SuperPow (int a, int[] b) {\\n        a = a % 1337;\\n        return SuperPow (a, b, b.Length - 1);\\n    }\\n\\n    public int SuperPow (int a, int[] b, int index) {\\n        var right = SuperPow (a, b[index]);\\n        var left = 1;\\n        if (index != 0) {\\n            left = SuperPow (SuperPow (a, b, index - 1), 10);\\n        }\\n        return left * right % 1337;\\n    }\\n\\n    public int SuperPow (int a, int b) {\\n        var c = 1;\\n        for (int i = 0; i < b; i++) {\\n            c = (c * a) % 1337;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152271,
                "title": "javascript-solution",
                "content": "```js\\nfunction superPow(a, b) {\\n  let res = 1;\\n  for (let n of b) {\\n    let next = 1;\\n    for (let i = 0; i < 10; i++) {\\n      next *= res;\\n      next %= 1337;\\n    }\\n    for (let i = 0; i < n; i++) {\\n      next *= a;\\n      next %= 1337;\\n    }\\n    res = next;\\n  }\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction superPow(a, b) {\\n  let res = 1;\\n  for (let n of b) {\\n    let next = 1;\\n    for (let i = 0; i < 10; i++) {\\n      next *= res;\\n      next %= 1337;\\n    }\\n    for (let i = 0; i < n; i++) {\\n      next *= a;\\n      next %= 1337;\\n    }\\n    res = next;\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150677,
                "title": "python-solution-without-math-and-work-with-any-num-not-only-1337-o-logb",
                "content": "```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        b = int(\\'\\'.join(map(str,b)))\\n        a = a%1337\\n        return self.helper(a,b)\\n    \\n    def helper(self,a,b):\\n        if a==0:return 0\\n        if a==1:return 1\\n        if b==1:return a%1337\\n        if b%2==0:\\n            coco = self.helper(a,b//2)\\n            return (coco*coco)%1337\\n        if b%2==1:\\n            coco = self.helper(a,b//2)\\n            return (coco*coco*a)%1337\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        \"\"\"\\n        :type a: int\\n        :type b: List[int]\\n        :rtype: int\\n        \"\"\"\\n        b = int(\\'\\'.join(map(str,b)))\\n        a = a%1337\\n        return self.helper(a,b)\\n    \\n    def helper(self,a,b):\\n        if a==0:return 0\\n        if a==1:return 1\\n        if b==1:return a%1337\\n        if b%2==0:\\n            coco = self.helper(a,b//2)\\n            return (coco*coco)%1337\\n        if b%2==1:\\n            coco = self.helper(a,b//2)\\n            return (coco*coco*a)%1337\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116329,
                "title": "my-c-solution-using-divide-and-conquer",
                "content": "(ab)%m = ((a%m)*(b%m))%m\nAs a result, (a^b)%m is equal to:\n1. If b = 2k, then (a^2k)%m = ((a^k)%m * (a^k)%m) % m\n2. If b = 2k+1, then (a^(2k+1))%m = ((a^k)%m * (a^(k+1))%m) % m = ((a^k)%m * (((a^k)%m * a%m)%m)) % m\n\nSo, we need to compute a^(b/2)%m first.\nThe way I used to compute b/2 will cost O(digits(b)) time, where digits(b) represent how many digits number b has (i.e., the lenght of vector b). Note that digits(b)=O(log10(b)), we have the time complexity formula:\nT(a, b, m) = T(a, b/2, m)+O(log10(b))    ==>    T(a, b, m) = log10(b)\nHere, b is the value of the number represented by vector b, not the length of vector b.\n\n```\nclass Solution {\npublic:\n    int superPow(int a, vector<int>& b, int mod = 1337) {\n        int start;\n        \n        for (start = 0; start<b.size() && b[start]==0; start++);\n        return superPow(a, b, start, mod);\n    }\n    \nprivate:\n    int superPow(int a, vector<int>& b, int start, int mod) {\n        if (b.size()-1==start && b[start]==1) {\n            return a%mod;\n        } else {\n            int r = 0, halfBMod, tmp;\n            \n            for (int idx = start; idx < b.size(); idx++) {\n                if (idx>start || b[idx]>1) {\n                    tmp = b[idx];\n                    b[idx] = (r*10+tmp) / 2;\n                    r = (r*10+tmp) % 2;\n                } else {\n                    b[start] = 0;\n                    r = 1;\n                }\n            }\n            halfBMod = superPow(a, b, b[start]==0?start+1:start, mod);\n            if (r == 0) {\n                return (halfBMod*halfBMod)%mod;\n            } else {\n                return (halfBMod*((halfBMod*(a%mod))%mod))%mod;\n            }\n        }\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    int superPow(int a, vector<int>& b, int mod = 1337) {\n        int start;\n        \n        for (start = 0; start<b.size() && b[start]==0; start++);\n        return superPow(a, b, start, mod);\n    }\n    \nprivate:\n    int superPow(int a, vector<int>& b, int start, int mod) {\n        if (b.size()-1==start && b[start]==1) {\n            return a%mod;\n        } else {\n            int r = 0, halfBMod, tmp;\n            \n            for (int idx = start; idx < b.size(); idx++) {\n                if (idx>start || b[idx]>1) {\n                    tmp = b[idx];\n                    b[idx] = (r*10+tmp) / 2;\n                    r = (r*10+tmp) % 2;\n                } else {\n                    b[start] = 0;\n                    r = 1;\n                }\n            }\n            halfBMod = superPow(a, b, b[start]==0?start+1:start, mod);\n            if (r == 0) {\n                return (halfBMod*halfBMod)%mod;\n            } else {\n                return (halfBMod*((halfBMod*(a%mod))%mod))%mod;\n            }\n        }\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 84469,
                "title": "general-algorithm-for-any-number-other-than-1337-no-fancy-math",
                "content": "```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        int[] dp=new int[b.length];\\n        int newa=a%1337;\\n        int result=1;\\n        for(int i=b.length-1;i>=0;i--){\\n            dp[i]=newa;\\n            result=(result*mypow(dp[i],b[i]))%1337;\\n            newa=mypow(newa,10);\\n        }\\n        return result;\\n    }\\n    private int mypow(int a,int b){\\n        int result=1;\\n        for(int i=0;i<b;i++){\\n            result=(result*(a%1337))%1337;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        int[] dp=new int[b.length];\\n        int newa=a%1337;\\n        int result=1;\\n        for(int i=b.length-1;i>=0;i--){\\n            dp[i]=newa;\\n            result=(result*mypow(dp[i],b[i]))%1337;\\n            newa=mypow(newa,10);\\n        }\\n        return result;\\n    }\\n    private int mypow(int a,int b){\\n        int result=1;\\n        for(int i=0;i<b;i++){\\n            result=(result*(a%1337))%1337;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84487,
                "title": "c-9ms-solution-improved-by-fermat-s-little-theorem",
                "content": "First, 1337 = 7 * 191. \\nAccording to Fermat's Little Theorem, a ^ 6 \\u2261 1 (mod 7), a ^ 190 \\u2261 1 (mod 191), \\nso a ^ lcm(6,190) \\u2261 1 (mod 1337), i.e., a ^ 570 \\u2261 1 (mod 1337). \\nThen, a ^ b \\u2261 a ^ (b % 570) (mod 1337). \\n\\n```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        if(a % 1337 == 0) return 0;\\n        \\n        a %= 1337;\\n        \\n        int exp = 0, size = b.size();\\n        for(int i = 0; i < size; ++i) {   // exp = b % 570\\n            exp = (exp * 10 + b[i]) % 570;\\n        }\\n        \\n        return powModL(a, exp, 1337);\\n    }\\n    \\n    int powMod(int a, int k, int m) {    // a ^ k % m, 0<= k <= 10\\n        int res = 1;\\n        while(k-- > 0) {\\n            res = res * a % m;\\n        }\\n        return res;\\n    }\\n    \\n    int powModL(int a, int k, int m) {  // a ^ k % m, for large k\\n        if(k == 0) return 1;\\n        return powMod( powModL(a, k / 10, m), 10, m ) * powMod( a, k % 10, m ) % m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        if(a % 1337 == 0) return 0;\\n        \\n        a %= 1337;\\n        \\n        int exp = 0, size = b.size();\\n        for(int i = 0; i < size; ++i) {   // exp = b % 570\\n            exp = (exp * 10 + b[i]) % 570;\\n        }\\n        \\n        return powModL(a, exp, 1337);\\n    }\\n    \\n    int powMod(int a, int k, int m) {    // a ^ k % m, 0<= k <= 10\\n        int res = 1;\\n        while(k-- > 0) {\\n            res = res * a % m;\\n        }\\n        return res;\\n    }\\n    \\n    int powModL(int a, int k, int m) {  // a ^ k % m, for large k\\n        if(k == 0) return 1;\\n        return powMod( powModL(a, k / 10, m), 10, m ) * powMod( a, k % 10, m ) % m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84484,
                "title": "c-based-on-group-theory-and-fast-exponentiation-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        a = a % 1337;\\n        int ord = 6*190, expo = 0, res = 1;\\n        // 1337 = 7 * 191, ord(1337) = (7-1)*(191-1) => a^k = a^(k mod 6*190)\\n        for(int x:b) expo = (10 * expo + x) % ord;\\n        // fast exponentiation: see exponent as binary,a^b = a^b0 * (a^2)^b1 * (a^4)^b2 ....\\n        for(int m=1; m<expo; m*=2){\\n            if(expo & m) res = (res*a) % 1337;\\n            a = (a*a) % 1337;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        a = a % 1337;\\n        int ord = 6*190, expo = 0, res = 1;\\n        // 1337 = 7 * 191, ord(1337) = (7-1)*(191-1) => a^k = a^(k mod 6*190)\\n        for(int x:b) expo = (10 * expo + x) % ord;\\n        // fast exponentiation: see exponent as binary,a^b = a^b0 * (a^2)^b1 * (a^4)^b2 ....\\n        for(int m=1; m<expo; m*=2){\\n            if(expo & m) res = (res*a) % 1337;\\n            a = (a*a) % 1337;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84490,
                "title": "java-solution-using-stack-inspired-by-pow-x-n",
                "content": "```\\npublic static final int M = 1337;\\n    public int superPow(int a, int[] b) {\\n        Stack<Integer> stack = new Stack();\\n        for(int digit: b) stack.push(digit);\\n        return myPow(a, stack);\\n    }\\n    \\n    public int myPow(int a, Stack<Integer> stack){\\n        if(stack.isEmpty()) return 1;\\n        int last = stack.pop();\\n        return fastPow(myPow(a, stack), 10) * fastPow(a, last) % M;\\n    }\\n    \\n    // calculate a^k % M\\n    public int fastPow(int a, int k){\\n        if(k == 0) return 1;\\n        a %= M;\\n        if((k&1) == 1) return a * fastPow(a*a, k/2)%M;\\n        else return fastPow(a*a, k/2)%M;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static final int M = 1337;\\n    public int superPow(int a, int[] b) {\\n        Stack<Integer> stack = new Stack();\\n        for(int digit: b) stack.push(digit);\\n        return myPow(a, stack);\\n    }\\n    \\n    public int myPow(int a, Stack<Integer> stack){\\n        if(stack.isEmpty()) return 1;\\n        int last = stack.pop();\\n        return fastPow(myPow(a, stack), 10) * fastPow(a, last) % M;\\n    }\\n    \\n    // calculate a^k % M\\n    public int fastPow(int a, int k){\\n        if(k == 0) return 1;\\n        a %= M;\\n        if((k&1) == 1) return a * fastPow(a*a, k/2)%M;\\n        else return fastPow(a*a, k/2)%M;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 84498,
                "title": "python-math-based-solution-easy-to-understand",
                "content": "      class Solution(object):\\n         def superPow(self, a, b):\\n\\n            #find the cycle\\n            cycle = self.find_cycle(a)\\n            cycle_length = len(cycle)\\n\\n            #division to find the remainder\\n            r = 0\\n            for i in b:\\n            r = (r * 10 + i) % cycle_length\\n            \\n            return cycle[r - 1]\\n        \\n        \\n         def find_cycle(self, a):\\n        \\n            r = a % 1337\\n            cycle = []\\n            while r not in cycle:\\n               cycle.append(r)\\n               r = r * a % 1337\\n\\n            return cycle",
                "solutionTags": [],
                "code": "      class Solution(object):\\n         def superPow(self, a, b):\\n\\n            #find the cycle\\n            cycle = self.find_cycle(a)\\n            cycle_length = len(cycle)\\n\\n            #division to find the remainder\\n            r = 0\\n            for i in b:\\n            r = (r * 10 + i) % cycle_length\\n            \\n            return cycle[r - 1]\\n        \\n        \\n         def find_cycle(self, a):\\n        \\n            r = a % 1337\\n            cycle = []\\n            while r not in cycle:\\n               cycle.append(r)\\n               r = r * a % 1337\\n\\n            return cycle",
                "codeTag": "Java"
            },
            {
                "id": 84510,
                "title": "simple-java-solution",
                "content": "```\\nimport java.math.BigInteger;\\n\\npublic class Solution {\\n    public int superPow(int a, int[] b) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int bNum : b){\\n            sb.append(bNum);\\n        }\\n\\n        BigInteger bb = new BigInteger(sb.toString());\\n        BigInteger aa = new BigInteger(String.valueOf(a));\\n        BigInteger result = aa.modPow(bb, new BigInteger(String.valueOf(1337)));\\n        return result.intValue();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\n\\npublic class Solution {\\n    public int superPow(int a, int[] b) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int bNum : b){\\n            sb.append(bNum);\\n        }\\n\\n        BigInteger bb = new BigInteger(sb.toString());\\n        BigInteger aa = new BigInteger(String.valueOf(a));\\n        BigInteger result = aa.modPow(bb, new BigInteger(String.valueOf(1337)));\\n        return result.intValue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84517,
                "title": "java-solution",
                "content": "Here I use the formula:\\n\\n  ab mod m = ( (a mod m) * ( b mod m) ) mod m;\\n \\n  So the following formula would be achieved:\\n  mod = ( (pow(mod,10) % 1377) * (pow(a,b[i])) % 1377) ) % 1377;\\n  i is the current index of b, mod is the modular by (i-1); \\n\\n However, both of pow(mod,10) and pow(a,b[i]) are potential to exceed the maximum of integer, so here two while loops are used to calculate the value of (pow(mod,10) % 1377) and (pow(a,b[i])) % 1377).\\n\\nMy code:\\n```\\npublic class Solution { \\n   public int superPow(int a, int[] b) {        \\n        final int M = 1337;\\n       \\n        int mod = 1; int curr =  a; int pow = 0; int j = 0;\\n        int mod_temp, mod_curr; \\n        \\n        for (int i = 0; i < b.length; i++){\\n            \\n             j = 0;\\n            /* calculate the mod of previous mod ^ 10  */ \\n            mod_temp = 1; \\n            while(j++ < 10){\\n                mod_temp = (mod_temp * mod) % M;\\n            }\\n            \\n           j = 0; \\n           mod_curr = 1;\\n            /* calculate the mod of a ^ b[i] */\\n            while(j++ < b[i]){\\n                mod_curr = (mod_curr * (a%M)) % M;   \\n            }\\n            \\n            mod = (mod_temp * mod_curr) % M;\\n            \\n        }\\n        \\n        return mod;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution { \\n   public int superPow(int a, int[] b) {        \\n        final int M = 1337;\\n       \\n        int mod = 1; int curr =  a; int pow = 0; int j = 0;\\n        int mod_temp, mod_curr; \\n        \\n        for (int i = 0; i < b.length; i++){\\n            \\n             j = 0;\\n            /* calculate the mod of previous mod ^ 10  */ \\n            mod_temp = 1; \\n            while(j++ < 10){\\n                mod_temp = (mod_temp * mod) % M;\\n            }\\n            \\n           j = 0; \\n           mod_curr = 1;\\n            /* calculate the mod of a ^ b[i] */\\n            while(j++ < b[i]){\\n                mod_curr = (mod_curr * (a%M)) % M;   \\n            }\\n            \\n            mod = (mod_temp * mod_curr) % M;\\n            \\n        }\\n        \\n        return mod;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84515,
                "title": "3ms-short-java-solution",
                "content": "```\\npublic int superPow(int a, int[] b) {\\n        if(a==1)return 1;\\n        int l=b.length,m=a,i,v=0;\\n        int[] p = new int[1337];\\n        int mod = a%1337;\\n        p[0] = mod;\\n        for(i=1;i<1337;i++){\\n            m = (int)(((long)m*a) % 1337);\\n            if(m!=mod)p[i]=m;\\n            else break;\\n        }\\n        for(int j=0;j<l;j++){\\n            v = ((v*10) + b[j]) % i;\\n        }\\n        return p[v-1];\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int superPow(int a, int[] b) {\\n        if(a==1)return 1;\\n        int l=b.length,m=a,i,v=0;\\n        int[] p = new int[1337];\\n        int mod = a%1337;\\n        p[0] = mod;\\n        for(i=1;i<1337;i++){\\n            m = (int)(((long)m*a) % 1337);\\n            if(m!=mod)p[i]=m;\\n            else break;\\n        }\\n        for(int j=0;j<l;j++){\\n            v = ((v*10) + b[j]) % i;\\n        }\\n        return p[v-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 84538,
                "title": "my-c-solution",
                "content": "```\\nclass Solution {\\nconst int DIV = 1337;\\npublic:\\n    int superPow(int a, vector<int>& b) \\n    {\\n        int rem = a%DIV, rempow = 1;\\n        int result = 1;\\n        for(int i = b.size() - 1; i >= 0; i--)\\n        {\\n            int k = 0;\\n            while(k < 10)\\n            {\\n                if(b[i] == k)\\n                    result = rempow*result%DIV;\\n\\n                k++;\\n                rempow *= rem;\\n                if(rempow >= DIV)\\n                    rempow %= DIV;\\n            }\\n            rem = rempow;\\n            rempow = 1;\\n        }\\n        return result%DIV;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nconst int DIV = 1337;\\npublic:\\n    int superPow(int a, vector<int>& b) \\n    {\\n        int rem = a%DIV, rempow = 1;\\n        int result = 1;\\n        for(int i = b.size() - 1; i >= 0; i--)\\n        {\\n            int k = 0;\\n            while(k < 10)\\n            {\\n                if(b[i] == k)\\n                    result = rempow*result%DIV;\\n\\n                k++;\\n                rempow *= rem;\\n                if(rempow >= DIV)\\n                    rempow %= DIV;\\n            }\\n            rem = rempow;\\n            rempow = 1;\\n        }\\n        return result%DIV;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84542,
                "title": "share-my-c-solution-with-a-brief-explanation-easy-to-understand",
                "content": "> a ^ b = a ^ (b1 * 10 + c)\\n>         = (a ^ c) * (a ^ (10 * b1))\\n>         = (a ^ c) * ((a ^ 10) ^ b1)\\n---\\n> c = 2 ^ x1 + 2 ^ x2 +...... 2 ^ xn, xi = 0 or 1\\n> a ^ c = (a * a)^x1 * (a * a)^x2 * ...... * (a * a)^xn\\n---\\n```\\nclass Solution {\\npublic:\\n    const int MOD = 1337;\\n\\n    int superPow(int a, vector<int>& b) {\\n        int n = b.size();\\n        int ret = 1;\\n        \\n        for (int i = n-1; i >= 0; i--)\\n        {\\n            ret = ret * pow_help(a, b[i]) % MOD;\\n            a = pow_help(a, 10);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int pow_help(int a, int b)\\n    {\\n        int ret = 1;\\n        a %= MOD;\\n        \\n        while (b > 0)\\n        {\\n            if (b & 1)\\n                ret = ret * a % MOD;\\n            \\n            b >>= 1;\\n            a = a * a % MOD;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int MOD = 1337;\\n\\n    int superPow(int a, vector<int>& b) {\\n        int n = b.size();\\n        int ret = 1;\\n        \\n        for (int i = n-1; i >= 0; i--)\\n        {\\n            ret = ret * pow_help(a, b[i]) % MOD;\\n            a = pow_help(a, 10);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int pow_help(int a, int b)\\n    {\\n        int ret = 1;\\n        a %= MOD;\\n        \\n        while (b > 0)\\n        {\\n            if (b & 1)\\n                ret = ret * a % MOD;\\n            \\n            b >>= 1;\\n            a = a * a % MOD;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84545,
                "title": "non-recursive-o-n-time-complexity-c-code-with-some-hints",
                "content": "**O(n) time complexity, where n is the length of b.**\\n\\nSome Hints:\\n* 1). There are at most 1337 (0~1336) possible results. So increasing b from 1 to an extreme large number, the same results will repetitively show up, as a loop. (**What is the length of the loop?**)\\n* 2). If the length of loop is c, then **(a^b)%1337 = (a^(b%c))%1337**.\\n* 3). If (a^b)%x = y, what is (a^(b+1))%x equal to?  ------------------------------- (a*y)%x.\\n\\n```\\n    // O(c): for this problem, c=1337, so...O(1).\\n    int findLoopLength(long long a, long long c)\\n    {\\n        unordered_set<long long> unset;  // can also use array of length c\\n        long long t = a%c;\\n        while(unset.find(t)==unset.end())\\n        {\\n            unset.insert(t);\\n            t = (t*a)%c;\\n        }\\n        return unset.size();\\n    }\\n    \\n    // return b%c\\n    int bigMod(vector<int>&b, int c)\\n    {\\n        int p = 0;\\n        for(auto d:b)\\n        {\\n            p = (p*10 + d)%c;\\n        }\\n        return p;\\n    }\\n    \\n    int superPow(int a, vector<int>& b) {\\n        if(a==1) return 1;\\n        \\n        int loop = findLoopLength(a, 1337);    // O(1)\\n        int m = bigMod(b, loop);               // O(n), where n is the length of b\\n        \\n        // costs no more than findLoopLength(...). If the results were stored during the process of finding loop length, this while-loop could be avoided.\\n        long long r = a%1337;                         \\n        while(m>1)    \\n        {\\n            --m;\\n            r = (r*a)%1337;\\n        }\\n        return r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // O(c): for this problem, c=1337, so...O(1).\\n    int findLoopLength(long long a, long long c)\\n    {\\n        unordered_set<long long> unset;  // can also use array of length c\\n        long long t = a%c;\\n        while(unset.find(t)==unset.end())\\n        {\\n            unset.insert(t);\\n            t = (t*a)%c;\\n        }\\n        return unset.size();\\n    }\\n    \\n    // return b%c\\n    int bigMod(vector<int>&b, int c)\\n    {\\n        int p = 0;\\n        for(auto d:b)\\n        {\\n            p = (p*10 + d)%c;\\n        }\\n        return p;\\n    }\\n    \\n    int superPow(int a, vector<int>& b) {\\n        if(a==1) return 1;\\n        \\n        int loop = findLoopLength(a, 1337);    // O(1)\\n        int m = bigMod(b, loop);               // O(n), where n is the length of b\\n        \\n        // costs no more than findLoopLength(...). If the results were stored during the process of finding loop length, this while-loop could be avoided.\\n        long long r = a%1337;                         \\n        while(m>1)    \\n        {\\n            --m;\\n            r = (r*a)%1337;\\n        }\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 84549,
                "title": "14ms-o-size-of-b-iterative-solution-c",
                "content": "https://en.wikipedia.org/wiki/Modular_exponentiation\\n\\nO(size of b) solution, slightly adapted from the one in Wiki.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        int n = b.size();\\n        int result = 1;\\n        for(int i = n-1; i >=0; i--) {\\n            result = ((result * modPower(a, b[i])) % 1337);\\n            a = modPower(a, 10);\\n        }\\n        return result;\\n    }\\nprivate:\\n    int modPower(int a, int e) {\\n        int result = 1;    \\n        a = a%1337;\\n   \\n        while (e > 0) {\\n            if (e & 1) {\\n                result = ((result * a) % 1337);\\n            }\\n            e >>= 1;\\n            a = ((a * a) % 1337);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        int n = b.size();\\n        int result = 1;\\n        for(int i = n-1; i >=0; i--) {\\n            result = ((result * modPower(a, b[i])) % 1337);\\n            a = modPower(a, 10);\\n        }\\n        return result;\\n    }\\nprivate:\\n    int modPower(int a, int e) {\\n        int result = 1;    \\n        a = a%1337;\\n   \\n        while (e > 0) {\\n            if (e & 1) {\\n                result = ((result * a) % 1337);\\n            }\\n            e >>= 1;\\n            a = ((a * a) % 1337);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103460,
                "title": "beats-100-of-users-13-line-code",
                "content": "# Approach\\n1. The problem states that we need to mod 1337 with a^b so we can start by doing a % 1337. \\n2. Then we run a for loop to make b a value.\\n3. if num turns out to be 0, we know that num was what we mod by which is 1140 since this number is mathematically proven to give correct value.\\n4. Then we run a for loop which will keep multiplying \\'a\\' by result. This will do the job of a^b\\n5. we return result after\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n(O1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        int mod = 1337;\\n        a %= mod; // Reduce a to the range [0, 1336] to optimize\\n        int num = 0;\\n        for (int i = 0; i < b.length; i++) {\\n            num = (num * 10 + b[i]) % 1140;\\n        }\\n        if (num == 0) {\\n            num += 1140;\\n        }\\n        int result = 1;\\n        for (int i = 0; i < num; i++) {\\n            result = (result * a) % mod;\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        int mod = 1337;\\n        a %= mod; // Reduce a to the range [0, 1336] to optimize\\n        int num = 0;\\n        for (int i = 0; i < b.length; i++) {\\n            num = (num * 10 + b[i]) % 1140;\\n        }\\n        if (num == 0) {\\n            num += 1140;\\n        }\\n        int result = 1;\\n        for (int i = 0; i < num; i++) {\\n            result = (result * a) % mod;\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077326,
                "title": "best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        s=0\\n        for i in b:\\n            s=s*10+i\\n\\n        return pow(a,s,1337)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        s=0\\n        for i in b:\\n            s=s*10+i\\n\\n        return pow(a,s,1337)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068115,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        long base =a;\\n        int m=1337;\\n        long power=0;\\n        for(int i=0;i<b.length;i++){\\n            power=(power*10+b[i]);\\n            if(power==1140){\\n                continue;\\n            }\\n            power=power%1140;\\n\\n        }\\n         \\n\\n          long ans = 1;\\n\\n        while (power > 0) {\\n            if ((power & 1) == 1) {\\n                ans =(ans*(base))%m;\\n                \\n            }\\n\\n            \\n            base=((base)*(base))%m;\\n            power = power >> 1;\\n        }\\nreturn(int) ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        long base =a;\\n        int m=1337;\\n        long power=0;\\n        for(int i=0;i<b.length;i++){\\n            power=(power*10+b[i]);\\n            if(power==1140){\\n                continue;\\n            }\\n            power=power%1140;\\n\\n        }\\n         \\n\\n          long ans = 1;\\n\\n        while (power > 0) {\\n            if ((power & 1) == 1) {\\n                ans =(ans*(base))%m;\\n                \\n            }\\n\\n            \\n            base=((base)*(base))%m;\\n            power = power >> 1;\\n        }\\nreturn(int) ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067447,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        totalB = int(\\'\\'.join(map(str, b)))\\n        return pow(a,totalB,1337)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def superPow(self, a, b):\\n        totalB = int(\\'\\'.join(map(str, b)))\\n        return pow(a,totalB,1337)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035387,
                "title": "easy-to-understand-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public final static int MOD=1337;\\n    public int superPow(int a, int[] b) {\\n        if(a==0 || a==1){\\n            return a;\\n        }\\n        a%=MOD;\\n        int res=1;\\n        for(int digit:b){\\n            res=(pow(res,10)*pow(a,digit))%MOD;\\n        }\\n        return res;\\n\\n\\n\\n    }\\n    public int pow(int a,int b){\\n        int res=1;\\n        while(b>0){\\n            if((b&1)!=0){\\n                res=(res * a%MOD )%MOD;\\n            }\\n            a=(a%MOD *a%MOD)%MOD;\\n            b=b>>1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public final static int MOD=1337;\\n    public int superPow(int a, int[] b) {\\n        if(a==0 || a==1){\\n            return a;\\n        }\\n        a%=MOD;\\n        int res=1;\\n        for(int digit:b){\\n            res=(pow(res,10)*pow(a,digit))%MOD;\\n        }\\n        return res;\\n\\n\\n\\n    }\\n    public int pow(int a,int b){\\n        int res=1;\\n        while(b>0){\\n            if((b&1)!=0){\\n                res=(res * a%MOD )%MOD;\\n            }\\n            a=(a%MOD *a%MOD)%MOD;\\n            b=b>>1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999513,
                "title": "by-euler-s-theorem",
                "content": "Time Complexity = `O(Nlog(n))`\\n- N= length of vector\\n- n=bits in obtained number from vector\\n\\n---\\nSpace Complexity = `O(1)`\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int binaryExpo(int a, int b){\\n        a = a%1337;\\n        int ans = 1;\\n        while(b>0){\\n            if(b&1){\\n                ans = ((ans*1LL*a) % 1337);\\n            }\\n            a = (a*1LL*a) % 1337;\\n            b = b>>1;\\n        }\\n        return ans;\\n    }\\n\\n    int superPow(int a, vector<int>& b) {\\n        // we can get the number by two ways\\n        // Ecf of given mod is 1140\\n        // way->1\\n        int n = 0;\\n        for(auto i: b){\\n            n = (n*10 + i)%1140;\\n        }\\n        // way -> 2\\n        // int ten = 1;\\n        // for(int i = b.size()-1; i>=0; i--){\\n        //     n = (n +(b[i] *1LL* ten)) % 1140;\\n        //     ten = (ten*10)%1140;\\n        // }\\n        return binaryExpo(a, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int binaryExpo(int a, int b){\\n        a = a%1337;\\n        int ans = 1;\\n        while(b>0){\\n            if(b&1){\\n                ans = ((ans*1LL*a) % 1337);\\n            }\\n            a = (a*1LL*a) % 1337;\\n            b = b>>1;\\n        }\\n        return ans;\\n    }\\n\\n    int superPow(int a, vector<int>& b) {\\n        // we can get the number by two ways\\n        // Ecf of given mod is 1140\\n        // way->1\\n        int n = 0;\\n        for(auto i: b){\\n            n = (n*10 + i)%1140;\\n        }\\n        // way -> 2\\n        // int ten = 1;\\n        // for(int i = b.size()-1; i>=0; i--){\\n        //     n = (n +(b[i] *1LL* ten)) % 1140;\\n        //     ten = (ten*10)%1140;\\n        // }\\n        return binaryExpo(a, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992715,
                "title": "easy-way-using-modulo-and-bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst apply modulo on number to reduce this than using binary exponential operation to calculate a^b\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(b))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int a, int b, int m){\\n        a %=m;\\n        int ans = 1;\\n        while(b>0){\\n            if(b&1){\\n                ans = (ans * 1LL * a) % m;\\n            }\\n            a = (a * 1LL * a) % m;\\n            b>>=1;\\n        }\\n        return ans;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        int bmod = 0;\\n        for(auto val : b){\\n            bmod = (bmod*10 + val) % 1140;\\n        }\\n        return f(a, bmod, 1337);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int a, int b, int m){\\n        a %=m;\\n        int ans = 1;\\n        while(b>0){\\n            if(b&1){\\n                ans = (ans * 1LL * a) % m;\\n            }\\n            a = (a * 1LL * a) % m;\\n            b>>=1;\\n        }\\n        return ans;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        int bmod = 0;\\n        for(auto val : b){\\n            bmod = (bmod*10 + val) % 1140;\\n        }\\n        return f(a, bmod, 1337);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990689,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} a\\n * @param {number[]} b\\n * @return {number}\\n */\\nvar superPow = function(a, b) {\\n    let bInt = BigInt(b.join(\"\")), m = 1337, res = 1;\\n    a = a % m;\\n    while (bInt > 0){\\n        if (bInt % 2n == 1) res = (res * a) % m;\\n        a = (a * a) % m;\\n        bInt = bInt >> 1n;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} a\\n * @param {number[]} b\\n * @return {number}\\n */\\nvar superPow = function(a, b) {\\n    let bInt = BigInt(b.join(\"\")), m = 1337, res = 1;\\n    a = a % m;\\n    while (bInt > 0){\\n        if (bInt % 2n == 1) res = (res * a) % m;\\n        a = (a * a) % m;\\n        bInt = bInt >> 1n;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971324,
                "title": "easy-best-c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryExp(int a, int b) {\\n        a = a % 1337;\\n        int ans = 1;\\n        while(b > 0)\\n        {\\n            if(b&1)\\n                ans =(ans * 1LL * a) % 1337;\\n            a = (a * 1LL * a) % 1337;\\n            b = b >> 1;\\n        }\\n        return ans;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        int bmod = 0;\\n        for(int val : b)\\n            bmod = (bmod * 10 + val) % 1140;\\n        return binaryExp(a, bmod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryExp(int a, int b) {\\n        a = a % 1337;\\n        int ans = 1;\\n        while(b > 0)\\n        {\\n            if(b&1)\\n                ans =(ans * 1LL * a) % 1337;\\n            a = (a * 1LL * a) % 1337;\\n            b = b >> 1;\\n        }\\n        return ans;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        int bmod = 0;\\n        for(int val : b)\\n            bmod = (bmod * 10 + val) % 1140;\\n        return binaryExp(a, bmod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968220,
                "title": "superpow-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int binoexp(int a, int b, int c){\\n        a%=c;\\n        int rslt=1;\\n        while(b>0){\\n            if((b&1)==1){\\n                rslt =(rslt*a)%c;\\n            }\\n            a=(a*a)%c;\\n            b>>=1;\\n        }\\n        return rslt;\\n    }\\n\\n    public int superPow(int a, int[] b) {\\n        int bnum=0;\\n        for(int i:b){\\n            bnum = bnum*10+i;\\n            bnum = bnum%1140;\\n        }\\n        return binoexp(a,bnum,1337);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int binoexp(int a, int b, int c){\\n        a%=c;\\n        int rslt=1;\\n        while(b>0){\\n            if((b&1)==1){\\n                rslt =(rslt*a)%c;\\n            }\\n            a=(a*a)%c;\\n            b>>=1;\\n        }\\n        return rslt;\\n    }\\n\\n    public int superPow(int a, int[] b) {\\n        int bnum=0;\\n        for(int i:b){\\n            bnum = bnum*10+i;\\n            bnum = bnum%1140;\\n        }\\n        return binoexp(a,bnum,1337);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958800,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // don\\'t know that why they have take modulo of k by 1140;\\n    public int superPow(int a, int[] b) {\\n        long k=0;\\n        for(int i=0;i<b.length;i++)\\n        {\\n            k=k*10+b[i];\\n            k=k%1140;\\n        }\\n        int ans=1;\\n        a=a%1337;\\n        k=k%1140;\\n        while(k>0)\\n        {\\n            if(k%2==1)\\n                ans=((ans%1337)*(a%1337))%1337;\\n            a=((a%1337)*(a%1337))%1337;\\n            k/=2;\\n        }\\n        return ans%1337;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // don\\'t know that why they have take modulo of k by 1140;\\n    public int superPow(int a, int[] b) {\\n        long k=0;\\n        for(int i=0;i<b.length;i++)\\n        {\\n            k=k*10+b[i];\\n            k=k%1140;\\n        }\\n        int ans=1;\\n        a=a%1337;\\n        k=k%1140;\\n        while(k>0)\\n        {\\n            if(k%2==1)\\n                ans=((ans%1337)*(a%1337))%1337;\\n            a=((a%1337)*(a%1337))%1337;\\n            k/=2;\\n        }\\n        return ans%1337;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951707,
                "title": "0ms-100-fastest-solution-java-modulo-arithmetic-math-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        a = a % 1337;\\n        long rem=0;\\n        for(int i=0; i<b.length; i++){\\n            rem = (10*rem + b[i]) % 1140;\\n        }\\n\\n        return (int)myPow(a,rem) % 1337;\\n    }\\n\\n    public long myPow(long x, long n) {\\n        long res=1;\\n        while(n>0){\\n            if((n&1) != 0){\\n                res = (res * x % 1337) % 1337;\\n            }\\n            x = (x % 1337 * x % 1337) % 1337;\\n            n = n>>1;\\n        }\\n        return res % 1337;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        a = a % 1337;\\n        long rem=0;\\n        for(int i=0; i<b.length; i++){\\n            rem = (10*rem + b[i]) % 1140;\\n        }\\n\\n        return (int)myPow(a,rem) % 1337;\\n    }\\n\\n    public long myPow(long x, long n) {\\n        long res=1;\\n        while(n>0){\\n            if((n&1) != 0){\\n                res = (res * x % 1337) % 1337;\\n            }\\n            x = (x % 1337 * x % 1337) % 1337;\\n            n = n>>1;\\n        }\\n        return res % 1337;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948652,
                "title": "simple-c-solution-etf-euler-theorem-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        long long num=0;\\n        for(int i=0;i<b.size();i++) //calculate num\\n        {\\n            num=(num*10+b[i])%1140; \\n        }\\n        a=a%1337;\\n        long long res=1;\\n        for(int i=0;i<num;i++)  //calculate a^nums\\n            res=1LL*(res*a)%1337;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        long long num=0;\\n        for(int i=0;i<b.size();i++) //calculate num\\n        {\\n            num=(num*10+b[i])%1140; \\n        }\\n        a=a%1337;\\n        long long res=1;\\n        for(int i=0;i<num;i++)  //calculate a^nums\\n            res=1LL*(res*a)%1337;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947865,
                "title": "c-recursion-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n Utilize modular exponentiation and Euler\\'s theorem to efficiently calculate the superpower.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse recursive approach:\\nIf the exponent array b is empty, return 1 (base case).\\nOtherwise, pop the last digit from b and call the function recursively for the remaining digits.\\nFor each recursive call:\\nTake modulo MOD of the base a.\\nCalculate the superpower recursively for the remaining digits by raising it to the power of 10.\\nApply the popped digit as an exponent to the base a, and take modulo MOD.\\nThe final result is the product of the recursive superpower with exponent 10 and the separate exponentiation of the base a with the popped digit as exponent, both taken modulo MOD\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int MOD = 1337;\\n\\n    int power(int x, int n) {\\n        if (n == 0) return 1;\\n        x %= MOD;\\n        if (n % 2 == 1) return (x * power(x, n - 1)) % MOD;\\n        int half = power(x, n / 2);\\n        return (half * half) % MOD;\\n    }\\n\\n    int superPow(int a, vector<int>& b) {\\n        if (b.empty()) return 1;\\n        \\n        a %= MOD;\\n        int last_digit = b.back();\\n        b.pop_back();\\n        return (power(superPow(a, b), 10) * power(a, last_digit)) % MOD;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int MOD = 1337;\\n\\n    int power(int x, int n) {\\n        if (n == 0) return 1;\\n        x %= MOD;\\n        if (n % 2 == 1) return (x * power(x, n - 1)) % MOD;\\n        int half = power(x, n / 2);\\n        return (half * half) % MOD;\\n    }\\n\\n    int superPow(int a, vector<int>& b) {\\n        if (b.empty()) return 1;\\n        \\n        a %= MOD;\\n        int last_digit = b.back();\\n        b.pop_back();\\n        return (power(superPow(a, b), 10) * power(a, last_digit)) % MOD;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938026,
                "title": "best-approach-c-for-large-exponentiation-etf-euler-theorem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binExp(int a, int b, int m){\\n        int ans = 1;\\n        a %= m;\\n        //int m = 1140;\\n        while(b){\\n            if((b & 1)){\\n                ans = (ans * a)% m;\\n            }\\n            a = (a*a) % m;\\n            b >>= 1;\\n        }\\n\\n        return ans;\\n    }\\n  \\n    // int bmod(vector<int> &b, int m){\\n    //     int p = 0;\\n    //     int val = 0;\\n    //     for(int it = b.size() - 1; it >= 0; it--){\\n    //         val += (b[it] * power(10,p)) % m;\\n    //         p++;\\n    //     }\\n    //     return val;\\n    // }\\n\\n    int superPow(int a, vector<int>& b) {\\n        //etf of 1337 : \\n        // prime factors of 1337 = 7, 191\\n        // etf of 1337 = 6*190 = 1140\\n        int m = 1140;\\n        int M = 1337;\\n        int bm = 0;\\n        // int ans = 1;\\n        // while(bm){\\n        //     if((bm & 1)){\\n        //         ans = (ans *1ll* a)% M;\\n        //     }\\n        //     a = (a* 1ll * a) % M;\\n        //     bm >>= 1;\\n        // }\\n\\n        for(int val : b){\\n            bm = (bm * 10 + val) % 1140;\\n        }\\n\\n        return binExp(a , bm , 1337);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binExp(int a, int b, int m){\\n        int ans = 1;\\n        a %= m;\\n        //int m = 1140;\\n        while(b){\\n            if((b & 1)){\\n                ans = (ans * a)% m;\\n            }\\n            a = (a*a) % m;\\n            b >>= 1;\\n        }\\n\\n        return ans;\\n    }\\n  \\n    // int bmod(vector<int> &b, int m){\\n    //     int p = 0;\\n    //     int val = 0;\\n    //     for(int it = b.size() - 1; it >= 0; it--){\\n    //         val += (b[it] * power(10,p)) % m;\\n    //         p++;\\n    //     }\\n    //     return val;\\n    // }\\n\\n    int superPow(int a, vector<int>& b) {\\n        //etf of 1337 : \\n        // prime factors of 1337 = 7, 191\\n        // etf of 1337 = 6*190 = 1140\\n        int m = 1140;\\n        int M = 1337;\\n        int bm = 0;\\n        // int ans = 1;\\n        // while(bm){\\n        //     if((bm & 1)){\\n        //         ans = (ans *1ll* a)% M;\\n        //     }\\n        //     a = (a* 1ll * a) % M;\\n        //     bm >>= 1;\\n        // }\\n\\n        for(int val : b){\\n            bm = (bm * 10 + val) % 1140;\\n        }\\n\\n        return binExp(a , bm , 1337);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929175,
                "title": "beats-74-25-of-users-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        b=int(\"\".join([str(i) for i in b]))\\n        return pow(a,b,1337)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        b=int(\"\".join([str(i) for i in b]))\\n        return pow(a,b,1337)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884668,
                "title": "what-is-wrong",
                "content": "long long power(long long a,long long b,long long mod)\\n    {\\n        a%=mod;\\n        long long res=1;\\n        \\n        while(b>0)\\n        {\\n            if(b&1)\\n                res=res*a %mod;\\n            a=(a*a)%mod;\\n            b>>=1;\\n        }\\n        \\n        return res;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        \\n        int rem=0;\\n        for(int i:b)\\n        {\\n            rem=(10*rem +i)%(1336);\\n        }\\n        \\n        return power(a,rem,1337);\\n    }",
                "solutionTags": [],
                "code": "long long power(long long a,long long b,long long mod)\\n    {\\n        a%=mod;\\n        long long res=1;\\n        \\n        while(b>0)\\n        {\\n            if(b&1)\\n                res=res*a %mod;\\n            a=(a*a)%mod;\\n            b>>=1;\\n        }\\n        \\n        return res;\\n    }\\n    int superPow(int a, vector<int>& b) {\\n        \\n        int rem=0;\\n        for(int i:b)\\n        {\\n            rem=(10*rem +i)%(1336);\\n        }\\n        \\n        return power(a,rem,1337);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3881317,
                "title": "simple-using-biginteger-in-java",
                "content": "# Intuition\\nUsing BigInteger\\n\\n# Approach\\nconvert the int array to string array and using BigInteger  BruteForce used\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int superPow(int a, int[] arr) {\\n        if(a<=1){\\n            return a;\\n        }\\n        String num = a+\"\";\\n        String[] strArray = new String[arr.length];\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            strArray[i] = String.valueOf(arr[i]);\\n        }\\n        String sumInd =\"\";\\n        for (int i = 0; i <strArray.length ; i++) {\\n            sumInd = sumInd +strArray[i];\\n        }\\n        BigInteger big = new BigInteger(num);\\n        BigInteger x = new BigInteger(sumInd);\\n        BigInteger y = new BigInteger(\"1337\");\\n        big = big.modPow(x , y);\\n        return big.intValue();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int superPow(int a, int[] arr) {\\n        if(a<=1){\\n            return a;\\n        }\\n        String num = a+\"\";\\n        String[] strArray = new String[arr.length];\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            strArray[i] = String.valueOf(arr[i]);\\n        }\\n        String sumInd =\"\";\\n        for (int i = 0; i <strArray.length ; i++) {\\n            sumInd = sumInd +strArray[i];\\n        }\\n        BigInteger big = new BigInteger(num);\\n        BigInteger x = new BigInteger(sumInd);\\n        BigInteger y = new BigInteger(\"1337\");\\n        big = big.modPow(x , y);\\n        return big.intValue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860830,
                "title": "divide-and-conquer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        long k = 0;\\n\\n        for(int i = 0; i < b.length; i++) {\\n            k = k * 10 + b[i];\\n            k = k % 1140;\\n        }\\n\\n        int ans = 1;\\n        a = a % 1337;\\n        k = k % 1140;\\n\\n        while(k > 0) {\\n            if(k % 2 == 1)\\n                ans = ((ans % 1337) * (a % 1337)) % 1337;\\n            a = ((a % 1337) * (a % 1337)) % 1337;\\n            k /= 2;\\n        }\\n\\n        return ans % 1337;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        long k = 0;\\n\\n        for(int i = 0; i < b.length; i++) {\\n            k = k * 10 + b[i];\\n            k = k % 1140;\\n        }\\n\\n        int ans = 1;\\n        a = a % 1337;\\n        k = k % 1140;\\n\\n        while(k > 0) {\\n            if(k % 2 == 1)\\n                ans = ((ans % 1337) * (a % 1337)) % 1337;\\n            a = ((a % 1337) * (a % 1337)) % 1337;\\n            k /= 2;\\n        }\\n\\n        return ans % 1337;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840462,
                "title": "simple-java-solution-using-biginteger",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        String ans =\"\";\\n        String num = a +\"\";\\n        for(int i = 0; i < b.length; i++){\\n            ans += b[i];\\n        }\\n        BigInteger big = new BigInteger(num);\\n        BigInteger x = new BigInteger(ans);\\n        BigInteger y = new BigInteger(\"1337\");\\n        big = big.modPow(x , y);\\n        return big.intValue();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int superPow(int a, int[] b) {\\n        String ans =\"\";\\n        String num = a +\"\";\\n        for(int i = 0; i < b.length; i++){\\n            ans += b[i];\\n        }\\n        BigInteger big = new BigInteger(num);\\n        BigInteger x = new BigInteger(ans);\\n        BigInteger y = new BigInteger(\"1337\");\\n        big = big.modPow(x , y);\\n        return big.intValue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831734,
                "title": "simplepythoncode3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        s=\\'\\'.join(list(map(str,b)))\\n        s1=pow(a,int(s),1337)\\n        return s1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        s=\\'\\'.join(list(map(str,b)))\\n        s1=pow(a,int(s),1337)\\n        return s1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812713,
                "title": "swift-easy-solution-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func superPow(_ a: Int, _ b: [Int]) -> Int {\\n    \\n        if b.count == 0 { return 1 }\\n        \\n        func powerWithMode(_ a: Int, _ b: Int, _ mod: Int = 1337) -> Int {\\n            if b == 0 { return 1 }\\n            if b == 1 { return a % mod }\\n            \\n            let power = powerWithMode(a, b / 2, mod)\\n            let powerWithMode = (power * power) % mod\\n            return b % 2 == 0 ? powerWithMode : (powerWithMode * a) % mod\\n            \\n        }\\n        \\n        var b = b\\n        let last = b.removeLast()\\n        return powerWithMode(a, last) * powerWithMode(superPow(a, b), 10) % 1337\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func superPow(_ a: Int, _ b: [Int]) -> Int {\\n    \\n        if b.count == 0 { return 1 }\\n        \\n        func powerWithMode(_ a: Int, _ b: Int, _ mod: Int = 1337) -> Int {\\n            if b == 0 { return 1 }\\n            if b == 1 { return a % mod }\\n            \\n            let power = powerWithMode(a, b / 2, mod)\\n            let powerWithMode = (power * power) % mod\\n            return b % 2 == 0 ? powerWithMode : (powerWithMode * a) % mod\\n            \\n        }\\n        \\n        var b = b\\n        let last = b.removeLast()\\n        return powerWithMode(a, last) * powerWithMode(superPow(a, b), 10) % 1337\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810054,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        str_b = \"\"\\n        for i in b:\\n            str_b += str(i)\\n        int_b = int(str_b)\\n\\n        return pow(a, int_b, 1337)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        str_b = \"\"\\n        for i in b:\\n            str_b += str(i)\\n        int_b = int(str_b)\\n\\n        return pow(a, int_b, 1337)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809618,
                "title": "super-pow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/fbe04b6f-a630-45a4-a617-b3c88ce768e9_1690200241.7310228.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        num=int(\"\".join(list(map(str,b))))\\n        return pow(a,num,1337)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def superPow(self, a: int, b: List[int]) -> int:\\n        num=int(\"\".join(list(map(str,b))))\\n        return pow(a,num,1337)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807587,
                "title": "use-euler-s-theorem",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    int pow(int x, int n)\\n    {\\n        x %= 1337;\\n        if (x == 0) return 0;\\n        int a = 1;\\n        while (n) {\\n            if (n & 1) {\\n                a *= x;\\n                a %= 1337;\\n            } \\n            x *= x;\\n            x %= 1337;\\n            n /= 2;\\n        }\\n        return a;\\n    }\\n    \\n    int superPow(int a, vector<int>& b) {\\n        const int phi1337 = 1140;\\n        int pw = 0;\\n        for (int i = 0; i < b.size(); i++) {\\n            pw = pw*10 + b[i];\\n            pw %= phi1337;\\n        }\\n        return pow(a, pw);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int pow(int x, int n)\\n    {\\n        x %= 1337;\\n        if (x == 0) return 0;\\n        int a = 1;\\n        while (n) {\\n            if (n & 1) {\\n                a *= x;\\n                a %= 1337;\\n            } \\n            x *= x;\\n            x %= 1337;\\n            n /= 2;\\n        }\\n        return a;\\n    }\\n    \\n    int superPow(int a, vector<int>& b) {\\n        const int phi1337 = 1140;\\n        int pw = 0;\\n        for (int i = 0; i < b.size(); i++) {\\n            pw = pw*10 + b[i];\\n            pw %= phi1337;\\n        }\\n        return pow(a, pw);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760571,
                "title": "easy-solution-simple",
                "content": "# Intuition\\n\\n\\n# Approach\\n- loop 1 calcuates the value of extremely large array b with modulo of 1140(calculated using euler\\'s theorem) and store it into nums\\n1337=(191)(7)\\nx(N)=(191-1)(7-1) = (190)*(6) = 1140\\n- a is extremely large number so its power would be beyond range of int so we modulo a by 1337\\n- res stores the result\\n- loop 2 calculates **a^nums** and stores it into res\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![leet.jpeg](https://assets.leetcode.com/users/images/ab84f452-3bfe-4cb4-b072-b28bd8d17d5f_1689270479.3579228.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        long long num=0;\\n        for(int i=0;i<b.size();i++) //calculate num\\n        {\\n            num=(num*10+b[i])%1140; \\n        }\\n        a=a%1337;\\n        long long res=1;\\n        for(int i=0;i<num;i++)  //calculate a^nums\\n            res=1LL*(res*a)%1337;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int superPow(int a, vector<int>& b) {\\n        long long num=0;\\n        for(int i=0;i<b.size();i++) //calculate num\\n        {\\n            num=(num*10+b[i])%1140; \\n        }\\n        a=a%1337;\\n        long long res=1;\\n        for(int i=0;i<num;i++)  //calculate a^nums\\n            res=1LL*(res*a)%1337;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564763,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1983986,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1711197,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1740437,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1751103,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1719466,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1718730,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1699464,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1670076,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1575287,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1564763,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1983986,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1711197,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1740437,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1751103,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1719466,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1718730,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1699464,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1670076,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            },
            {
                "id": 1575287,
                "content": [
                    {
                        "username": "coder2",
                        "content": "Just to test whether the candidate knows https://en.wikipedia.org/wiki/Modular_exponentiation?\\n\\nWhich company has asked this question? Curious."
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "this question is asked by adobe 3 times, amazon 2 times and flipkart 2 time in past 1-2 years"
                    },
                    {
                        "username": "xsdnmg",
                        "content": "we don't have to know this to solve this question. Just high school math. If i am the inteviewer and you indeed know this, I would rather change a question to find sth you don't know to test your logic ability. The aim of leetcode is not memorizing sth, is to test your ability to solve problems with some basic knowledge"
                    },
                    {
                        "username": "anwendeng",
                        "content": " # What if  a & n are not coprime?\n$\\gcd(a, n)!=1$\n That will be the boundary case. Try this test case: \n```\n7\n[1,1,4,0]\n```\nYou will find Euler-Fermat Theorem not enough! Euler-Fermat only say: If $\\gcd(a, n)=1$ then\n$a^{\\phi(n)} \\equiv 1 \\pmod{n}$ but not about  $\\gcd(a, n)!=1$!In this question n=1337=191*7=> $\\phi(n)=190*6=1140.$ A fully correct Math solution needs other Theorem on RSA!"
                    },
                    {
                        "username": "godshiva",
                        "content": "This felt more like a project Euler problem than a LC problem, but I still had a lot of fun and did two separate methods for solving it :)"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "Why do many of the solutions have exponent % 1140.\\nWhere is the magical 1140 coming from. "
                    },
                    {
                        "username": "Ayush_vacchhani",
                        "content": "https://www.youtube.com/watch?v=877jLgKg_yg&list=PLauivoElc3giVROwL-6g9hO-LlSen_NaV&index=14"
                    },
                    {
                        "username": "anwendeng",
                        "content": "n=1137=7*191 is the prime factorization, Euler-phi(n)=(7-1)(191-1)=1140. Euler 's theorem says if a, n are coprime integers=> a^phi(n)%n=1"
                    },
                    {
                        "username": "salyu",
                        "content": "I found an explanation here: https://math.stackexchange.com/questions/491576/\\nit\\'s the Euler\\'s totient function of 1337"
                    },
                    {
                        "username": "__Ace__",
                        "content": "can someone me where to do mod and where not;"
                    },
                    {
                        "username": "pritamberad9",
                        "content": "Ninja is given an easy task. He has to implement a function which calculates a^b. But there is a small difference, b is an extremely large positive number given in the form of an array.\\nNote: Since answers can be huge, print answer mod 1337.\\nIt is given that b will not contain leading zeros.\\nInput Format:\\n First line of input contains an integer a\\n Second line of input contains an integer n, representing the size of the array.\\n Third line of input contains an array (space separated).\\nConstraints:\\n1 <= a <= 2^31 - 1\\n1 <= b.length <= 3 * 10^6\\n0 <= b[i] <= 9\\nTime Limit: 1 second\\nOutput Format:\\nSingle line of output printing a^b\\nSample Input 1:\\n5\\n2\\n1 5\\nSample Output:\\n944\\nExplanation:\\n5 to the power 15 is 30517578125. Its mod with\\xA01337\\xA0is\\xA0944. \\ncan anyone gime me code of this question using main method?plz\\n"
                    },
                    {
                        "username": "albertoyao",
                        "content": "Returning infinity for some reason, using JS\\n    var exponent = Number(b.join(\\'\\'));\\n    return Math.pow(a, exponent);"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Because it is returning a number larger than the datatype can hold, and your language has actually slightly protected you from an integer overflow error. "
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\nint base = 1337;\\n\\nint mypow(int a, int k) {\\n    \\n    a %= base;\\n    int res = 1;\\n    for (int _ = 0; _ < k; _++) {\\n        \\n        res *= a;\\n        \\n        res %= base;\\n    }\\n    return res;\\n}\\n\\nint superPow(int a, vector<int>& b) {\\n    if (b.empty()) return 1;\\n    int last = b.back();\\n    b.pop_back();\\n    \\n    int part1 = mypow(a, last);\\n    int part2 = mypow(superPow(a, b), 10);\\n    \\n    return (part1 * part2) % base;\\n}\\n};\\n```"
                    },
                    {
                        "username": "ShreyaJain",
                        "content": "def superPow(self, a: int, b: List[int]) -> int:\\n\\t res = int(\"\".join(map(str, b))) \\n\\t return pow(a,res,1337)"
                    },
                    {
                        "username": "cswartzell",
                        "content": "LOL at the downvotes. Its a perfectly valid solution. Some languages dont have upper limits (short of hardware) on size of int. Heck, this solution is in the top 10% for speed so its not even slow to not use the math trick here. Whats a few megabytes of RAM and a quarter of second? \n\nYes its trivial, yes they are *heavily* implying you should use a math trick, but honestly thats not always the best answer. In an interview I'd have done it the \"proper\" way first, then tried this just to see how it compares in speed, and explain that, as Python has unlimited int size, assuming this runs in decent time, it should be considered effective. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Concatenated Words",
        "question_content": "<p>Given an array of strings <code>words</code> (<strong>without duplicates</strong>), return <em>all the <strong>concatenated words</strong> in the given list of</em> <code>words</code>.</p>\n\n<p>A <strong>concatenated word</strong> is defined as a string that is comprised entirely of at least two shorter words (not necesssarily distinct)&nbsp;in the given array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;cat&quot;,&quot;cats&quot;,&quot;catsdogcats&quot;,&quot;dog&quot;,&quot;dogcatsdog&quot;,&quot;hippopotamuses&quot;,&quot;rat&quot;,&quot;ratcatdogcat&quot;]\n<strong>Output:</strong> [&quot;catsdogcats&quot;,&quot;dogcatsdog&quot;,&quot;ratcatdogcat&quot;]\n<strong>Explanation:</strong> &quot;catsdogcats&quot; can be concatenated by &quot;cats&quot;, &quot;dog&quot; and &quot;cats&quot;; \n&quot;dogcatsdog&quot; can be concatenated by &quot;dog&quot;, &quot;cats&quot; and &quot;dog&quot;; \n&quot;ratcatdogcat&quot; can be concatenated by &quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot; and &quot;cat&quot;.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;cat&quot;,&quot;dog&quot;,&quot;catdog&quot;]\n<strong>Output:</strong> [&quot;catdog&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code> consists of only lowercase English letters.</li>\n\t<li>All the strings of <code>words</code> are <strong>unique</strong>.</li>\n\t<li><code>1 &lt;= sum(words[i].length) &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3103555,
                "title": "c-simple-dp-with-full-explanation-beats-99",
                "content": "# Intuition\\nThe intuition behind this solution is to use dynamic programming to check if a word can be constructed by the concatenation of other words in the set.\\n\\n# Approach\\nFirst, the input list of words is converted into an unordered_set, which is an efficient data structure for checking if a word is in the set in constant time. Then, an empty vector res is created to store the concatenated words that are found.\\n\\nThe code then iterates over the input list of words. For each word, it creates a vector dp of size n+1 where n is the length of the word. This vector is used to store whether it is possible to construct the word until a certain index by concatenating other words in the set. The vector is initially set to 0 for all indices, except for the first element, which is set to 1.\\n\\nThe code then iterates over the word again, and for each index i, it checks if the dp value at index i is 1, which means it is possible to construct the word until this index by concatenating other words. If so, it checks if there is a word in the set that starts from this index and has a length j - i, where j is the next index. If such a word is found, it updates the dp value at index j to 1.\\n\\nFinally, after iterating over the word, the code checks if the dp value at the last index is 1, which means that the word can be constructed by the concatenation of other words in the set. If so, it adds the word to the result vector.\\n\\nAfter iterating over all the words, the code returns the result vector, which contains all the concatenated words in the input list of words.\\n\\n\\uD83D\\uDCCD Here is an example of how the code would work for the word \"catdog\" and the set of words {\"cat\",\"dog\"}:\\n1. First, the input list of words is converted into an unordered_set, which is an efficient data structure for checking if a word is in the set in constant time.\\n2. Then, an empty vector res is created to store the concatenated words that are found.\\n3. The code then iterates over the input list of words. For each word \"catdog\", it creates a vector dp of size n+1 where n is the length of the word. This vector is used to store whether it is possible to construct the word until a certain index by concatenating other words in the set. The vector is initially set to 0 for all indices, except for the first element, which is set to 1.\\n    ```\\n    dp = [1, 0, 0, 0, 0, 0, 0]\\n\\n    ```\\n4. The code then iterates over the word again, and for each index i, it checks if the dp value at index i is 1, which means it is possible to construct the word until this index by concatenating other words. If so, it checks if there is a word in the set that starts from this index and has a length j - i, where j is the next index. If such a word is found, it updates the dp value at index j to 1.\\n    ```\\n    i = 0, j = 3, check if \"cat\" is in set: Yes, update dp[3] = 1\\n    i = 3, j = 6, check if \"dog\" is in set: Yes, update dp[6] = 1\\n    ```\\n5. Finally, after iterating over the word, the code checks if the dp value at the last index is 1, which means that the word can be constructed by the concatenation of other words in the set. If so, it adds the word to the result vector.\\n    ```\\n    dp = [1, 0, 0, 1, 0, 0, 1]\\n\\n    ```\\n\\nAs the dp array\\'s last index is 1, which means the word \"catdog\" can be constructed by the concatenation of other words in the set, so it\\'s added to the result vector.\\n\\nIn this way, this approach is checking if a word is a concatenated word by breaking it down into substrings and checking if each substring is a word in the set, making use of a dp array to store intermediate results. This method is much more efficient than checking all possible concatenations of words.\\n\\n# Complexity\\n- **Time complexity:**\\nThe time complexity of this solution is **O(n * L^2)**, where n is the number of words in the input list and L is the maximum length of the words.\\nThe main source of the time complexity is the nested loops that iterate over the words and the characters of the words. The outer loop iterates over the words and has a time complexity of O(n). The inner loop iterates over the characters of the words and has a time complexity of O(L). The inner loop also performs additional operations, such as checking if a word is in the set and updating the dp array, which also contribute to the overall time complexity.\\n\\n- **Space complexity:**\\nThe space complexity is **O(n * L)**, where n is the number of words in the input list and L is the maximum length of the words. The main source of the space complexity is the dp array, which is created for each word and has a size of L. Additionally, creating a unordered_set of all the words also takes O(n) space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> words_set;\\n        for (string word : words) words_set.insert(word);\\n        vector<string> res;\\n    \\n        for (string word : words) {\\n            int n = word.size();\\n            vector<int> dp(n + 1, 0);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (!dp[i]) continue;\\n                for (int j = i + 1; j <= n; j++) {\\n                    if (j - i < n && words_set.count(word.substr(i, j - i))) {\\n                        dp[j] = 1;\\n                    }\\n                }\\n                if (dp[n]) {\\n                    res.push_back(word);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\n![2wlbi6.webp](https://assets.leetcode.com/users/images/b96b0303-1829-44d2-b5c9-f052e1a797da_1674782842.712479.webp)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n    dp = [1, 0, 0, 0, 0, 0, 0]\\n\\n    ```\n```\\n    i = 0, j = 3, check if \"cat\" is in set: Yes, update dp[3] = 1\\n    i = 3, j = 6, check if \"dog\" is in set: Yes, update dp[6] = 1\\n    ```\n```\\n    dp = [1, 0, 0, 1, 0, 0, 1]\\n\\n    ```\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> words_set;\\n        for (string word : words) words_set.insert(word);\\n        vector<string> res;\\n    \\n        for (string word : words) {\\n            int n = word.size();\\n            vector<int> dp(n + 1, 0);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (!dp[i]) continue;\\n                for (int j = i + 1; j <= n; j++) {\\n                    if (j - i < n && words_set.count(word.substr(i, j - i))) {\\n                        dp[j] = 1;\\n                    }\\n                }\\n                if (dp[n]) {\\n                    res.push_back(word);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95652,
                "title": "java-dp-solution",
                "content": "Do you still remember how did you solve this problem? https://leetcode.com/problems/word-break/\\n\\nIf you do know one optimized solution for above question is using ```DP```, this problem is just one more step further. We iterate through each ```word``` and see if it can be formed by using other ```words```.\\n\\nOf course it is also obvious that a ```word``` can only be formed by ```words``` shorter than it. So we can first sort the input by length of each ```word```, and only try to form one ```word``` by using ```words``` in front of it.\\n```\\npublic class Solution {\\n    public static List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        Set<String> preWords = new HashSet<>();\\n        Arrays.sort(words, new Comparator<String>() {\\n            public int compare (String s1, String s2) {\\n                return s1.length() - s2.length();\\n            }\\n        });\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            if (canForm(words[i], preWords)) {\\n                result.add(words[i]);\\n            }\\n            preWords.add(words[i]);\\n        }\\n        \\n        return result;\\n    }\\n\\t\\n    private static boolean canForm(String word, Set<String> dict) {\\n        if (dict.isEmpty()) return false;\\n\\tboolean[] dp = new boolean[word.length() + 1];\\n\\tdp[0] = true;\\n\\tfor (int i = 1; i <= word.length(); i++) {\\n\\t    for (int j = 0; j < i; j++) {\\n\\t\\tif (!dp[j]) continue;\\n\\t\\tif (dict.contains(word.substring(j, i))) {\\n\\t\\t    dp[i] = true;\\n\\t\\t    break;\\n\\t\\t}\\n\\t    }\\n\\t}\\n\\treturn dp[word.length()];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```DP```\n```word```\n```words```\n```word```\n```words```\n```word```\n```word```\n```words```\n```\\npublic class Solution {\\n    public static List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        Set<String> preWords = new HashSet<>();\\n        Arrays.sort(words, new Comparator<String>() {\\n            public int compare (String s1, String s2) {\\n                return s1.length() - s2.length();\\n            }\\n        });\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            if (canForm(words[i], preWords)) {\\n                result.add(words[i]);\\n            }\\n            preWords.add(words[i]);\\n        }\\n        \\n        return result;\\n    }\\n\\t\\n    private static boolean canForm(String word, Set<String> dict) {\\n        if (dict.isEmpty()) return false;\\n\\tboolean[] dp = new boolean[word.length() + 1];\\n\\tdp[0] = true;\\n\\tfor (int i = 1; i <= word.length(); i++) {\\n\\t    for (int j = 0; j < i; j++) {\\n\\t\\tif (!dp[j]) continue;\\n\\t\\tif (dict.contains(word.substring(j, i))) {\\n\\t\\t    dp[i] = true;\\n\\t\\t    break;\\n\\t\\t}\\n\\t    }\\n\\t}\\n\\treturn dp[word.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159348,
                "title": "python-dfs-readable-solution",
                "content": "```\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        d = set(words)\\n        \\n        def dfs(word):\\n            for i in range(1, len(word)):\\n                prefix = word[:i]\\n                suffix = word[i:]\\n                \\n                if prefix in d and suffix in d:\\n                    return True\\n                if prefix in d and dfs(suffix):\\n                    return True\\n                if suffix in d and dfs(prefix):\\n                    return True\\n            \\n            return False\\n        \\n        res = []\\n        for word in words:\\n            if dfs(word):\\n                res.append(word)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        d = set(words)\\n        \\n        def dfs(word):\\n            for i in range(1, len(word)):\\n                prefix = word[:i]\\n                suffix = word[i:]\\n                \\n                if prefix in d and suffix in d:\\n                    return True\\n                if prefix in d and dfs(suffix):\\n                    return True\\n                if suffix in d and dfs(prefix):\\n                    return True\\n            \\n            return False\\n        \\n        res = []\\n        for word in words:\\n            if dfs(word):\\n                res.append(word)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348972,
                "title": "java-common-template-word-break-i-word-break-ii-concatenated-words",
                "content": "* Word Break I - [Link](https://leetcode.com/problems/word-break/)\\n* Word Break II - [Link](https://leetcode.com/problems/word-break-ii/) \\n* Concatenated Words - [Link](https://leetcode.com/problems/concatenated-words/)\\n\\nCommon approach for Word Break I, Word Break II, and Concatenated Words problems. \\nConcatenated Words is the reverse process of Word Break I, hence can be broken down to Word Break I.\\n\\n1. Word Break I  \\n      This is the top-Down approach\\n\\t   \\n\\t   class Solution { \\n\\t   \\n\\t   public boolean wordBreak(String s, List<String> wordDict) {\\n        \\n        // Need to use Boolean[] memo instead of boolean[], because we store both \"true\" and \"false\" in this array\\n        // and need to return our pre-calculated result of \"true/\"false\" when we hit the scenario,\\n        // if it is not yet precomputed, the value will be \"null\"\\n        \\n        // If boolean[] is used, then the array will be initialized with \"false\", \\n        // this might not be the pre-computed \"false\"\\n        return topDown(s, new HashSet<>(wordDict), 0, new Boolean[s.length()]);\\n       }\\n    \\n      \\n\\t    private boolean topDown(String s, Set<String> wordDict, int startIndex, Boolean[] memo) {\\n        \\n\\t\\t// if we reach the beyond the string, then return true\\n        // s = \"leetcode\" when \"code\" is being checked in the IF() of the loop, we reach endIndex == s.length(), \\n        // and wordDict.contains(\"code\") => true and topDown(s, wordDict, endIndex, memo) needs to return true. \\n        if(startIndex == s.length()) {\\n            return true;\\n        }\\n        \\n        // memo[i] = true means => that the substring from index i can be segmented. \\n        // memo[startIndex] means => wordDict contains substring from startIndex and it can be segemented.\\n        if(memo[startIndex] != null) { //Boolean[] array\\'s default value is \"null\"\\n            return memo[startIndex];\\n        }\\n        \\n        for(int endIndex = startIndex + 1; endIndex <= s.length(); endIndex++) {\\n            if(wordDict.contains(s.substring(startIndex, endIndex)) && topDown(s, wordDict, endIndex, memo)) {\\n                memo[startIndex] = true;\\n                return true;\\n            }\\n        }\\n        memo[startIndex] = false;\\n        return false;\\n         }\\n       }\\n\\t  Time Complexity : O(n^3)\\n\\t  \\n\\t  \\n\\t  This is the bottom-up approach, where base case is dp[0] = true, because string of length 0 (empty string) is present in wordDict.\\n\\t   dp[i] = true => means a valid word (word that exists in wordDict) ends at index i.\\n\\n       class Solution {\\n\\t\\n       public boolean wordBreak(String s, List<String> wordDict) {\\n        boolean[] dp = new boolean[s.length() + 1]; //DP array to store previous results.\\n        dp[0] = true; //default value.\\n        \\n        for(int i=1; i <= s.length(); i++){\\n            for(int j=0; j < i; j++){\\n                if(dp[j] && wordDict.contains(s.substring(j, i))){\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n        }\\n       }\\n\\nTime Complexity : O(n^3) since substring() in Java version > 7 takes O(n) time.\\n\\n\\n\\n\\n2. Word Break II - use a HashMap to store previously computed results. You check given string starts with any of the words from wordDict, instead of checking every prefix of \\'s\\' in wordDict.\\n\\n       \\n\\t   class Solution {\\t\\n       public List<String> wordBreak(String s, List<String> wordDict) {\\t\\n        return DFS(s, wordDict, new HashMap<String, List<String>>());\\n       }\\n       \\n\\t   public List<String> DFS(String s, List<String> wordDict, Map<String, List<String>> map){\\n        \\n        if(map.containsKey(s)) return map.get(s);\\n        \\n        List<String> result = new ArrayList<>();\\n        for(String word : wordDict){\\n            if(s.startsWith(word)){\\n               String nextWord = s.substring(word.length());\\n               if(nextWord.length() == 0) \\n                   result.add(word);\\n               else{\\n                   for(String w : DFS(nextWord, wordDict, map)) \\n                       result.add(word + \" \" + w);\\n                   } \\n            }            \\n        }\\n        map.put(s, result);\\n        return result;\\n        }\\n       }\\n\\t   \\nTime Complexity: O(n^3).\\nThis approach is too time consuming if the wordDict has millions of words.\\n\\nAnother approach based on Word Break I, where we check if every prefix of given string exists in wordDict -\\n\\n    class Solution {\\n    \\n    public Map<String, List<String>> memo = new HashMap<String, List<String>>(); \\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return topDown(s, new HashSet<>(wordDict), memo);\\n    }\\n    \\n    private List<String> topDown(String s, Set<String> wordDict, Map<String, List<String>> memo) {\\n        \\n        if(memo.containsKey(s)) {\\n            return memo.get(s);\\n        }\\n        \\n        List<String> result = new ArrayList<String>();\\n        if(wordDict.contains(s)) {\\n            result.add(s);\\n        }\\n        \\n        for(int endIndex = 1; endIndex <= s.length(); endIndex++) {\\n            if(wordDict.contains(s.substring(0, endIndex))) {\\n                for (String ss : topDown(s.substring(endIndex), wordDict, memo)) {\\n                    result.add(s.substring(0, endIndex) + \" \" + ss);\\n                }\\n            }\\n        }\\n        memo.put(s, result);\\n        return result;\\n    }\\n    }\\n\\n\\n3. Concatenated Words - Call Word Break I function to check if a word can be concatenated by the list of words in preWords set.\\n      \\n\\t  This is the top-down approach - \\n\\n       class Solution {\\n       public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        //sort the array in asc order of word length, since longer words are formed by shorter words.\\n        Arrays.sort(words, (a,b) -> a.length() - b.length());\\n\\n         List<String> result = new ArrayList<>();\\n\\n         //list of shorter words \\n         HashSet<String> preWords = new HashSet<>();\\n\\n         for(int i=0; i< words.length; i++){\\n             //Word Break-I problem.\\n             if(topDown(words[i], preWords, 0, new Boolean[words[i].length()])) {\\n                 result.add(words[i]);\\n             }\\n             preWords.add(words[i]);\\n         }\\n         return result;\\n        }\\n    \\n       private boolean topDown(String s, HashSet<String> wordDict, int startIndex, Boolean[] memo) {\\n        if(wordDict.isEmpty()) {\\n            return false;\\n        }\\n        // if we reach the beyond the string, then return true\\n        // s = \"leetcode\" when \"code\" is being checked in the IF() of the loop, we reach endIndex == s.length(), \\n        // and wordDict.contains(\"code\") => true and topDown(s, wordDict, endIndex, memo) needs to return true. \\n        if(startIndex == s.length()) {\\n            return true;\\n        }\\n        \\n        // memo[i] = true means => that the substring from index i can be segmented. \\n        // memo[startIndex] means => wordDict contains substring from startIndex and it can be segemented.\\n        if(memo[startIndex] != null) { //Boolean[] array\\'s default value is \"null\"\\n            return memo[startIndex];\\n        }\\n        \\n        for(int endIndex = startIndex + 1; endIndex <= s.length(); endIndex++) {\\n            if(wordDict.contains(s.substring(startIndex, endIndex)) && topDown(s, wordDict, endIndex, memo)) {\\n                memo[startIndex] = true;\\n                return true;\\n            }\\n        }\\n        memo[startIndex] = false;\\n        return false;\\n       }\\n       } \\n\\n\\t  \\nThis is the bottom-up approach - \\n\\n       class Solution {\\t \\n       public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n\\t   \\n        //sort the array in asc order of word length, since longer words are formed by shorter words.\\n        Arrays.sort(words, (a,b) -> a.length() - b.length());\\n        \\n\\t\\tList<String> result = new ArrayList<>();\\n        \\n        //list of shorter words \\n        HashSet<String> preWords = new HashSet<>();\\n        \\n        for(int i=0; i< words.length; i++){\\n            //Word Break-I problem.\\n            if(wordBreak(words[i], preWords)) result.add(words[i]);\\n            preWords.add(words[i]);\\n        }\\n        return result;\\n       }\\n       \\n\\t   private boolean wordBreak(String s, HashSet<String> preWords){\\n        if(preWords.isEmpty()) return false;\\n        \\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        \\n        for(int i = 1; i <= s.length(); i++){\\n            for(int j = 0; j < i; j++){\\n                if(dp[j] && preWords.contains(s.substring(j, i))){\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n       }\\n       }\\n\\t   \\n\\t   \\nTime Complexity: O(total no.of words * (n^3)) where n = avg length of each word.\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution { \\n\\t   \\n\\t   public boolean wordBreak(String s, List<String> wordDict) {\\n        \\n        // Need to use Boolean[] memo instead of boolean[], because we store both \"true\" and \"false\" in this array\\n        // and need to return our pre-calculated result of \"true/\"false\" when we hit the scenario,\\n        // if it is not yet precomputed, the value will be \"null\"\\n        \\n        // If boolean[] is used, then the array will be initialized with \"false\", \\n        // this might not be the pre-computed \"false\"\\n        return topDown(s, new HashSet<>(wordDict), 0, new Boolean[s.length()]);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 3103568,
                "title": "day-27-simple-recursion-dfs-easiest-beginner-friendly-sol",
                "content": "# Intuition of this Problem:\\nWe can solve this problem using various methods:\\n- Trie data strucutre\\n- dynamic programming\\n\\nBut I solved this problem using simple recursion - dfs.\\n![WhatsApp Image 2023-01-27 at 7.35.18 AM.jpeg](https://assets.leetcode.com/users/images/d47869df-216b-4184-a650-00035a86e96c_1674785146.2162044.jpeg)\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Create an empty set \\'s\\' to store all the words in the given array of strings.\\n2. Iterate through the array of strings and insert each word into the set \\'s\\'.\\n3. Create an empty vector \\'concatenateWords\\' to store all the concatenated words.\\n4. Iterate through the array of strings again, for each word, check if it is a concatenated word using the function \\'checkConcatenate(word)\\'.\\n5. In the \\'checkConcatenate(word)\\' function, use a for loop to iterate through each substring of the word, starting from index 1 to the second last index of the word.\\n6. For each substring, check if the prefix and suffix of the substring exists in the set \\'s\\'.\\n7. If the prefix and suffix both exist in the set \\'s\\', then return true, indicating that the word is a concatenated word.\\n8. If the function \\'checkConcatenate(word)\\' returns true, then insert the word into the \\'concatenateWords\\' vector.\\n9. Return the \\'concatenateWords\\' vector.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    set<string> s;\\n    bool checkConcatenate(string word) {\\n        for(int i = 1; i < word.length(); i++) {\\n            string prefixWord = word.substr(0, i);\\n            string suffixWord = word.substr(i, word.length()-i);\\n            if(s.find(prefixWord) != s.end() && (s.find(suffixWord) != s.end() || checkConcatenate(suffixWord)))\\n                return true;\\n        }\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> concatenateWords;\\n        for(string word : words)\\n            s.insert(word);\\n        for(string word : words) {\\n            if(checkConcatenate(word) == true)\\n                concatenateWords.push_back(word);\\n        }\\n        return concatenateWords;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        s = set()\\n        concatenateWords = []\\n        for word in words:\\n            s.add(word)\\n        for word in words:\\n            if self.checkConcatenate(word, s) == True:\\n                concatenateWords.append(word)\\n        return concatenateWords\\n    def checkConcatenate(self, word: str, s: set) -> bool:\\n        for i in range(1, len(word)):\\n            prefixWord = word[:i]\\n            suffixWord = word[i:]\\n            if prefixWord in s and (suffixWord in s or self.checkConcatenate(suffixWord, s)):\\n                return True\\n        return False\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n^2*m)** //where n is the number of words in the input array and m is the average length of the words.\\n\\nThe checkConcatenate() function is called for each word in the input array, and for each call, it iterates through the word to check for possible concatenation, which takes O(m) time. The find() function of the set data structure takes O(log(n)) time on average. So, the total time complexity of the checkConcatenate() function is **O(n*m*log(n))**. Since this function is called for each word in the input array, the total time complexity of the findAllConcatenatedWordsInADict() function is **O(n^2*m*log(n))**.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n*m)** //where n is the number of words in the input array and m is the average length of the words.\\n\\nThe space complexity **O(nm)**, where n is the number of words in the input array and m is the average length of the words. The set data structure is used to store all the words in the input array, which takes O(nm) space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nReference Video Link - https://www.youtube.com/watch?v=RLc0SyvDjrI",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    set<string> s;\\n    bool checkConcatenate(string word) {\\n        for(int i = 1; i < word.length(); i++) {\\n            string prefixWord = word.substr(0, i);\\n            string suffixWord = word.substr(i, word.length()-i);\\n            if(s.find(prefixWord) != s.end() && (s.find(suffixWord) != s.end() || checkConcatenate(suffixWord)))\\n                return true;\\n        }\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> concatenateWords;\\n        for(string word : words)\\n            s.insert(word);\\n        for(string word : words) {\\n            if(checkConcatenate(word) == true)\\n                concatenateWords.push_back(word);\\n        }\\n        return concatenateWords;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        s = set()\\n        concatenateWords = []\\n        for word in words:\\n            s.add(word)\\n        for word in words:\\n            if self.checkConcatenate(word, s) == True:\\n                concatenateWords.append(word)\\n        return concatenateWords\\n    def checkConcatenate(self, word: str, s: set) -> bool:\\n        for i in range(1, len(word)):\\n            prefixWord = word[:i]\\n            suffixWord = word[i:]\\n            if prefixWord in s and (suffixWord in s or self.checkConcatenate(suffixWord, s)):\\n                return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95644,
                "title": "102ms-java-trie-dfs-solution-with-explanation-easy-to-understand",
                "content": "```\\npublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> res = new ArrayList<String>();\\n        if (words == null || words.length == 0) {\\n            return res;\\n        }\\n        TrieNode root = new TrieNode();\\n        for (String word : words) { // construct Trie tree\\n            if (word.length() == 0) {\\n                continue;\\n            }\\n            addWord(word, root);\\n        }\\n        for (String word : words) { // test word is a concatenated word or not\\n            if (word.length() == 0) {\\n                continue;\\n            }\\n            if (testWord(word.toCharArray(), 0, root, 0)) {\\n                res.add(word);\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean testWord(char[] chars, int index, TrieNode root, int count) { // count means how many words during the search path\\n        TrieNode cur = root;\\n        int n = chars.length;\\n        for (int i = index; i < n; i++) {\\n            if (cur.sons[chars[i] - 'a'] == null) {\\n                return false;\\n            }\\n            if (cur.sons[chars[i] - 'a'].isEnd) {\\n                if (i == n - 1) { // no next word, so test count to get result.\\n                    return count >= 1;\\n                }\\n                if (testWord(chars, i + 1, root, count + 1)) {\\n                    return true;\\n                }\\n            }\\n            cur = cur.sons[chars[i] - 'a'];\\n        }\\n        return false;\\n    }\\n    public void addWord(String str, TrieNode root) {\\n        char[] chars = str.toCharArray();\\n        TrieNode cur = root;\\n        for (char c : chars) {\\n            if (cur.sons[c - 'a'] == null) {\\n                cur.sons[c - 'a'] = new TrieNode();\\n            }\\n            cur = cur.sons[c - 'a'];\\n        }\\n        cur.isEnd = true;\\n    }\\n}\\nclass TrieNode {\\n    TrieNode[] sons;\\n    boolean isEnd;\\n    public TrieNode() {\\n        sons = new TrieNode[26];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> res = new ArrayList<String>();\\n        if (words == null || words.length == 0) {\\n            return res;\\n        }\\n        TrieNode root = new TrieNode();\\n        for (String word : words) { // construct Trie tree\\n            if (word.length() == 0) {\\n                continue;\\n            }\\n            addWord(word, root);\\n        }\\n        for (String word : words) { // test word is a concatenated word or not\\n            if (word.length() == 0) {\\n                continue;\\n            }\\n            if (testWord(word.toCharArray(), 0, root, 0)) {\\n                res.add(word);\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean testWord(char[] chars, int index, TrieNode root, int count) { // count means how many words during the search path\\n        TrieNode cur = root;\\n        int n = chars.length;\\n        for (int i = index; i < n; i++) {\\n            if (cur.sons[chars[i] - 'a'] == null) {\\n                return false;\\n            }\\n            if (cur.sons[chars[i] - 'a'].isEnd) {\\n                if (i == n - 1) { // no next word, so test count to get result.\\n                    return count >= 1;\\n                }\\n                if (testWord(chars, i + 1, root, count + 1)) {\\n                    return true;\\n                }\\n            }\\n            cur = cur.sons[chars[i] - 'a'];\\n        }\\n        return false;\\n    }\\n    public void addWord(String str, TrieNode root) {\\n        char[] chars = str.toCharArray();\\n        TrieNode cur = root;\\n        for (char c : chars) {\\n            if (cur.sons[c - 'a'] == null) {\\n                cur.sons[c - 'a'] = new TrieNode();\\n            }\\n            cur = cur.sons[c - 'a'];\\n        }\\n        cur.isEnd = true;\\n    }\\n}\\nclass TrieNode {\\n    TrieNode[] sons;\\n    boolean isEnd;\\n    public TrieNode() {\\n        sons = new TrieNode[26];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176805,
                "title": "trie-with-explanations",
                "content": "```\\nA concatenated word is a word add other word(words) as prefix.\\n\\nWe have to answer a question recursively: is a substring(word[x, word.length()-1]) prefixed with another word in words?\\n\\nThat\\'s natural to prefix tree(trie). \\n\\nWe can build a trie using words and search for concatenated words in the trie. \\n\\nWe have to make a decision when we meet a node that meets the end of a word (with en in the example below). We can\\n  - either take the current node\\'s associated word as prefix (and restart at root for another word) \\n  - or not take the current node\\'s associated word as prefix (i.e. move further within the same branch).\\nFor example,\\n    root           \\n     /\\\\\\n    c  d\\n    /   \\\\\\n    a    o\\n   /      \\\\\\n  t(en)    g(en)\\n  /         \\n s(en)    \\n \\nTo concatenate catsdogcats using {cat, cats, dog}\\nsearch tree: (-\\'s in the same vertical line are sibling nodes)\\n    root - c - a - t(en)  - X [to take cat as prefix doesn\\'t work]\\n                          - s(en) - d - o - g(en) - c - a - t  - s(en) DONE!\\n                                                  - X [not to take dog as prefix doesn\\'t work]\\n                                  -  [not to take cats as prefix doesn\\'t work]\\n```\\n****\\n```\\nclass Solution {\\n    private static Node root;\\n    \\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        if (words == null || words.length == 0)\\n            return new ArrayList<>();\\n        \\n        root = new Node();\\n        buildTrie(words);\\n        \\n        List<String> result = new LinkedList<>();\\n        for (String word : words) {\\n            if (isConcatenated(word, 0, 0))\\n                result.add(word);\\n        }\\n        return result;\\n    }\\n    \\n    // Return true if word starting from index is concatenated\\n    boolean isConcatenated(String word, int index, int countConcatenatedWords) {\\n        if (index == word.length())\\n            return countConcatenatedWords >= 2;\\n        \\n        Node ptr = root;\\n        for (int i = index; i < word.length(); i++) {\\n            if (ptr.children[word.charAt(i) - \\'a\\'] == null) \\n                return false;\\n            ptr = ptr.children[word.charAt(i) - \\'a\\'];\\n            \\n            if (ptr.isWordEnd)\\n                if (isConcatenated(word, i + 1, countConcatenatedWords + 1))\\n                    return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void buildTrie(String[] words) {\\n        Node ptr;\\n        for (String word : words) {\\n            ptr = root;\\n            for (char ch : word.toCharArray()) {\\n                int order = ch - \\'a\\';\\n                if (ptr.children[order] == null) {\\n                    ptr.children[order] = new Node();\\n                } \\n                ptr = ptr.children[order];\\n            }\\n            ptr.isWordEnd = true;\\n        }\\n    }\\n    \\n    class Node {\\n        Node[] children;\\n        boolean isWordEnd;\\n        \\n        public Node() {\\n            children = new Node[26];\\n            isWordEnd = false;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nA concatenated word is a word add other word(words) as prefix.\\n\\nWe have to answer a question recursively: is a substring(word[x, word.length()-1]) prefixed with another word in words?\\n\\nThat\\'s natural to prefix tree(trie). \\n\\nWe can build a trie using words and search for concatenated words in the trie. \\n\\nWe have to make a decision when we meet a node that meets the end of a word (with en in the example below). We can\\n  - either take the current node\\'s associated word as prefix (and restart at root for another word) \\n  - or not take the current node\\'s associated word as prefix (i.e. move further within the same branch).\\nFor example,\\n    root           \\n     /\\\\\\n    c  d\\n    /   \\\\\\n    a    o\\n   /      \\\\\\n  t(en)    g(en)\\n  /         \\n s(en)    \\n \\nTo concatenate catsdogcats using {cat, cats, dog}\\nsearch tree: (-\\'s in the same vertical line are sibling nodes)\\n    root - c - a - t(en)  - X [to take cat as prefix doesn\\'t work]\\n                          - s(en) - d - o - g(en) - c - a - t  - s(en) DONE!\\n                                                  - X [not to take dog as prefix doesn\\'t work]\\n                                  -  [not to take cats as prefix doesn\\'t work]\\n```\n```\\nclass Solution {\\n    private static Node root;\\n    \\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        if (words == null || words.length == 0)\\n            return new ArrayList<>();\\n        \\n        root = new Node();\\n        buildTrie(words);\\n        \\n        List<String> result = new LinkedList<>();\\n        for (String word : words) {\\n            if (isConcatenated(word, 0, 0))\\n                result.add(word);\\n        }\\n        return result;\\n    }\\n    \\n    // Return true if word starting from index is concatenated\\n    boolean isConcatenated(String word, int index, int countConcatenatedWords) {\\n        if (index == word.length())\\n            return countConcatenatedWords >= 2;\\n        \\n        Node ptr = root;\\n        for (int i = index; i < word.length(); i++) {\\n            if (ptr.children[word.charAt(i) - \\'a\\'] == null) \\n                return false;\\n            ptr = ptr.children[word.charAt(i) - \\'a\\'];\\n            \\n            if (ptr.isWordEnd)\\n                if (isConcatenated(word, i + 1, countConcatenatedWords + 1))\\n                    return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void buildTrie(String[] words) {\\n        Node ptr;\\n        for (String word : words) {\\n            ptr = root;\\n            for (char ch : word.toCharArray()) {\\n                int order = ch - \\'a\\';\\n                if (ptr.children[order] == null) {\\n                    ptr.children[order] = new Node();\\n                } \\n                ptr = ptr.children[order];\\n            }\\n            ptr.isWordEnd = true;\\n        }\\n    }\\n    \\n    class Node {\\n        Node[] children;\\n        boolean isWordEnd;\\n        \\n        public Node() {\\n            children = new Node[26];\\n            isWordEnd = false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836924,
                "title": "python-template-word-break-i-word-break-ii-concatenated-words",
                "content": "Code & Idea for questions :\\n1. [Word Break : Ques No. 139](http://leetcode.com/problems/word-break/)\\n2. [Word Break II : Ques No. 140](http://leetcode.com/problems/word-break-ii/)\\n3. [Concatenated Words : Ques No. 472](http://leetcode.com/problems/concatenated-words/)\\n\\nBasic idea is same for all, find if string can be broken down to smaller string. Word Break I template follows other two.\\n\\n### Word Break I\\nUsing dynamic programming to calculate if word break is possible or not\\n\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [False] * (len(s) + 1)\\n        dp[0] = True\\n        wordDict = set(wordDict)\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n        return dp[-1]\\n```\\n\\n### Word Break II\\nThis is backtracking plus dynamic programming. We use dp array generated from word break I to figure out remaining string can be splitted or not, this reduces lot of backtracking calls. \\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if not s:\\n            return [\"\"]\\n        \\n        self.res = []\\n        self.wordDict = set(wordDict)\\n        self.dp = self.isWordBreak(s, wordDict)\\n        self.backtrack(s, 0, [])\\n        \\n        return self.res\\n    \\n    def backtrack(self, s, idx, path):\\n        # Before we backtrack, we check whether the remaining string \\n        # can be splitted by using the dictionary,\\n        # in this way we can decrease unnecessary computation greatly.\\n        if self.dp[idx+len(s)]: # if word break possible then only proceed\\n            if not s:\\n                self.res.append(\\' \\'.join(path))\\n            else:\\n                for i in range(1, len(s)+1):\\n                    if s[:i] in self.wordDict:\\n                        self.backtrack(s[i:], idx+i, path + [s[:i]])\\n        \\n    # this is from Word Break I\\n    def isWordBreak(self, s, wordDict):\\n        dp = [False] * (len(s) + 1)\\n        dp[0] = True\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n        return dp\\n```\\n\\n### Concatenated Words\\nConcatenated Words is the reverse of Word Break I, so can be broken down to Word Break I. \\n1. Sort the words according to shortest length since short ones form long words\\n2. for each word start building our dictionary of words and check if word split is possible or not\\n\\n```\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        res = []\\n        preWords = set()\\n        \\n        # asc order of word length, since longer words are formed by shorter words\\n        words.sort(key = len)\\n        \\n        # for each short word start building preWords\\n        for word in words:\\n            if self.wordBreak(word, preWords):\\n                res.append(word)\\n            preWords.add(word)\\n        \\n        return res\\n    \\n    # Word Break I template\\n    def wordBreak(self, string, words):\\n        if not words:\\n            return False\\n        \\n        dp = [False] * (len(string) + 1)\\n        dp[0] = True\\n        \\n        for i in range(len(string)+1):\\n            for j in range(i):\\n                if dp[j] and string[j:i] in words:\\n                    dp[i] = True\\n                    break\\n        \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        dp = [False] * (len(s) + 1)\\n        dp[0] = True\\n        wordDict = set(wordDict)\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n        return dp[-1]\\n```\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        if not s:\\n            return [\"\"]\\n        \\n        self.res = []\\n        self.wordDict = set(wordDict)\\n        self.dp = self.isWordBreak(s, wordDict)\\n        self.backtrack(s, 0, [])\\n        \\n        return self.res\\n    \\n    def backtrack(self, s, idx, path):\\n        # Before we backtrack, we check whether the remaining string \\n        # can be splitted by using the dictionary,\\n        # in this way we can decrease unnecessary computation greatly.\\n        if self.dp[idx+len(s)]: # if word break possible then only proceed\\n            if not s:\\n                self.res.append(\\' \\'.join(path))\\n            else:\\n                for i in range(1, len(s)+1):\\n                    if s[:i] in self.wordDict:\\n                        self.backtrack(s[i:], idx+i, path + [s[:i]])\\n        \\n    # this is from Word Break I\\n    def isWordBreak(self, s, wordDict):\\n        dp = [False] * (len(s) + 1)\\n        dp[0] = True\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n        return dp\\n```\n```\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        res = []\\n        preWords = set()\\n        \\n        # asc order of word length, since longer words are formed by shorter words\\n        words.sort(key = len)\\n        \\n        # for each short word start building preWords\\n        for word in words:\\n            if self.wordBreak(word, preWords):\\n                res.append(word)\\n            preWords.add(word)\\n        \\n        return res\\n    \\n    # Word Break I template\\n    def wordBreak(self, string, words):\\n        if not words:\\n            return False\\n        \\n        dp = [False] * (len(string) + 1)\\n        dp[0] = True\\n        \\n        for i in range(len(string)+1):\\n            for j in range(i):\\n                if dp[j] and string[j:i] in words:\\n                    dp[i] = True\\n                    break\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541520,
                "title": "java-dfs-memoization-clean-code",
                "content": "**Solution 1: Straigtforward DFS + Memoization**\\n```java\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        HashSet<String> wordSet = new HashSet<>(Arrays.asList(words));\\n        HashMap<String, Boolean> cache = new HashMap<>();\\n        for (String word : words) if (dfs(word, wordSet, cache)) ans.add(word);\\n        return ans;\\n    }\\n    boolean dfs(String word, HashSet<String> wordSet, HashMap<String, Boolean> cache) {\\n        if (cache.containsKey(word)) return cache.get(word);\\n        for (int i = 1; i < word.length(); i++) {\\n            if (wordSet.contains(word.substring(0, i))) {\\n                String suffix = word.substring(i);\\n                if (wordSet.contains(suffix) || dfs(suffix, wordSet, cache)) {\\n                    cache.put(word, true);\\n                    return true;\\n                }\\n            }\\n        }\\n        cache.put(word, false);\\n        return false;\\n    }\\n}\\n```\\n\\n**Solution 2: Concise**\\n```java\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        HashSet<String> wordSet = new HashSet<>(Arrays.asList(words));\\n        for (String word : words) if (dfs(word, wordSet)) ans.add(word);\\n        return ans;\\n    }\\n    boolean dfs(String word, HashSet<String> wordSet) {\\n        for (int i = 1; i < word.length(); i++) {\\n            if (wordSet.contains(word.substring(0, i))) {\\n                String suffix = word.substring(i);\\n                if (wordSet.contains(suffix) || dfs(suffix, wordSet)) {\\n                    wordSet.add(word); // can treat concatenated word as a new word for quickly lookup later\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n**Solution 3: Cache nonCombination**\\n```java\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        HashSet<String> wordSet = new HashSet<>(Arrays.asList(words));\\n        HashSet<String> nonCombination = new HashSet<>();\\n        for (String word : words) if (dfs(word, wordSet, nonCombination)) ans.add(word);\\n        return ans;\\n    }\\n    boolean dfs(String word, HashSet<String> wordSet, HashSet<String> nonCombination) {\\n        if (nonCombination.contains(word)) return false;\\n        for (int i = 1; i < word.length(); i++) {\\n            if (wordSet.contains(word.substring(0, i))) {\\n                String suffix = word.substring(i);\\n                if (wordSet.contains(suffix) || dfs(suffix, wordSet, nonCombination)) {\\n                    wordSet.add(word); // can treat concatenated word as a new word for quickly lookup later\\n                    return true;\\n                }\\n            }\\n        }\\n        nonCombination.add(word);\\n        return false;\\n    }\\n}\\n```\\n\\n**Solution 4: Trie**\\n```java\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] children = new TrieNode[26];\\n        boolean isWord;\\n    }\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String word : words) {\\n            TrieNode current = root;\\n            for (char c : word.toCharArray()) {\\n                if (current.children[c-\\'a\\'] == null) current.children[c-\\'a\\'] = new TrieNode();\\n                current = current.children[c-\\'a\\'];\\n            }\\n            if (current != root) current.isWord = true;\\n        }\\n        List<String> ans = new ArrayList<>();\\n        for (String word : words) if (dfs(root, word.toCharArray(), 0, word.length() - 1)) ans.add(word);\\n        return ans;\\n    }\\n    boolean dfs(TrieNode root, char[] cstr, int left, int right) {\\n        TrieNode current = root;\\n        for (int i = left; i <= right; i++) {\\n            char c = cstr[i];\\n            if (current.children[c-\\'a\\'] == null) return false;\\n            current = current.children[c-\\'a\\'];\\n            if (current.isWord) { // prefix\\n                if (isWord(root, cstr, i + 1, right) || dfs(root, cstr, i + 1, right))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    boolean isWord(TrieNode root, char[] cstr, int left, int right) {\\n        TrieNode current = root;\\n        for (int i = left; i <= right; i++) {\\n            char c = cstr[i];\\n            if (current.children[c-\\'a\\'] == null) return false;\\n            current = current.children[c-\\'a\\'];\\n        }\\n        return current.isWord;\\n    }\\n}\\n```\\n\\nSmilliar problems:\\n- [139. Word Break](https://leetcode.com/problems/word-break/)\\n- [140. Word Break II](https://leetcode.com/problems/word-break-ii/)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        HashSet<String> wordSet = new HashSet<>(Arrays.asList(words));\\n        HashMap<String, Boolean> cache = new HashMap<>();\\n        for (String word : words) if (dfs(word, wordSet, cache)) ans.add(word);\\n        return ans;\\n    }\\n    boolean dfs(String word, HashSet<String> wordSet, HashMap<String, Boolean> cache) {\\n        if (cache.containsKey(word)) return cache.get(word);\\n        for (int i = 1; i < word.length(); i++) {\\n            if (wordSet.contains(word.substring(0, i))) {\\n                String suffix = word.substring(i);\\n                if (wordSet.contains(suffix) || dfs(suffix, wordSet, cache)) {\\n                    cache.put(word, true);\\n                    return true;\\n                }\\n            }\\n        }\\n        cache.put(word, false);\\n        return false;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        HashSet<String> wordSet = new HashSet<>(Arrays.asList(words));\\n        for (String word : words) if (dfs(word, wordSet)) ans.add(word);\\n        return ans;\\n    }\\n    boolean dfs(String word, HashSet<String> wordSet) {\\n        for (int i = 1; i < word.length(); i++) {\\n            if (wordSet.contains(word.substring(0, i))) {\\n                String suffix = word.substring(i);\\n                if (wordSet.contains(suffix) || dfs(suffix, wordSet)) {\\n                    wordSet.add(word); // can treat concatenated word as a new word for quickly lookup later\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        HashSet<String> wordSet = new HashSet<>(Arrays.asList(words));\\n        HashSet<String> nonCombination = new HashSet<>();\\n        for (String word : words) if (dfs(word, wordSet, nonCombination)) ans.add(word);\\n        return ans;\\n    }\\n    boolean dfs(String word, HashSet<String> wordSet, HashSet<String> nonCombination) {\\n        if (nonCombination.contains(word)) return false;\\n        for (int i = 1; i < word.length(); i++) {\\n            if (wordSet.contains(word.substring(0, i))) {\\n                String suffix = word.substring(i);\\n                if (wordSet.contains(suffix) || dfs(suffix, wordSet, nonCombination)) {\\n                    wordSet.add(word); // can treat concatenated word as a new word for quickly lookup later\\n                    return true;\\n                }\\n            }\\n        }\\n        nonCombination.add(word);\\n        return false;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] children = new TrieNode[26];\\n        boolean isWord;\\n    }\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (String word : words) {\\n            TrieNode current = root;\\n            for (char c : word.toCharArray()) {\\n                if (current.children[c-\\'a\\'] == null) current.children[c-\\'a\\'] = new TrieNode();\\n                current = current.children[c-\\'a\\'];\\n            }\\n            if (current != root) current.isWord = true;\\n        }\\n        List<String> ans = new ArrayList<>();\\n        for (String word : words) if (dfs(root, word.toCharArray(), 0, word.length() - 1)) ans.add(word);\\n        return ans;\\n    }\\n    boolean dfs(TrieNode root, char[] cstr, int left, int right) {\\n        TrieNode current = root;\\n        for (int i = left; i <= right; i++) {\\n            char c = cstr[i];\\n            if (current.children[c-\\'a\\'] == null) return false;\\n            current = current.children[c-\\'a\\'];\\n            if (current.isWord) { // prefix\\n                if (isWord(root, cstr, i + 1, right) || dfs(root, cstr, i + 1, right))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    boolean isWord(TrieNode root, char[] cstr, int left, int right) {\\n        TrieNode current = root;\\n        for (int i = left; i <= right; i++) {\\n            char c = cstr[i];\\n            if (current.children[c-\\'a\\'] == null) return false;\\n            current = current.children[c-\\'a\\'];\\n        }\\n        return current.isWord;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104096,
                "title": "c-image-detailed-explanation-recursion",
                "content": "![Screenshot (735).png](https://assets.leetcode.com/users/images/9f393807-9971-447a-96a6-9f94001fb861_1674798993.8750749.png)\\n![Screenshot (734).png](https://assets.leetcode.com/users/images/2b2826c0-3bc9-4d60-b3a5-322fd8ee4774_1674799019.1884854.png)\\n![Screenshot (736).png](https://assets.leetcode.com/users/images/c31195ad-b430-43ca-bd45-157992360e6a_1674799031.5851164.png)\\n\\n**NOTE:-**here emoji says that \"**\"ca\"**,**\"t\"** and **\"dogcats\"** all are present in set and returning true. if some part like **tdogcats** did not returened true as it was not present in our map .then we breaked it as the same way we did earlier so ,simply pass it to recursive function.. when it returns true from both side only then add that word to our answer.. \\n\\n\\n**i draw all this things for you..so that you feel the problem.if you gain something then please motivate me by upvoting my solution.**\\n\\nLets Connect On Linkedin https://www.linkedin.com/in/sonal-prasad-sahu-78973a229/\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic: bool concat_possible(string &word,vector<string>& words, unordered_map<string,int>&mp){\\n          int size=word.size();\\n          for(int i=1;i<size;++i){ \\n              string prefix=word.substr(0,i);// left subpart\\n              string suffix=word.substr(i);  // right subpart\\n              if(mp[prefix] && (mp[suffix] || concat_possible(suffix,words,mp))){   /*checking if left and right subpart is present in map or not .\\nif one subpart is present(lets say prefix) and other is not(lets say suffix) then recursively check the suffix subpart .if both subparts is present then return true*/\\n                  return true;\\n              }\\n          }\\n          return false;\\n}\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string>ans;\\n        unordered_map<string,int>mp; \\n        for(auto string:words){   //storing each words into unordered_map\\n            mp[string]++;\\n        }\\n\\n\\n        for(auto &word:words){  //check for each word .if its return true then add it into our solution\\n            if(concat_possible(word,words,mp)){\\n                ans.push_back(word);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![begging.jpg](https://assets.leetcode.com/users/images/437a3a83-5b50-406d-a2e0-4f5d625402ab_1674799238.571603.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic: bool concat_possible(string &word,vector<string>& words, unordered_map<string,int>&mp){\\n          int size=word.size();\\n          for(int i=1;i<size;++i){ \\n              string prefix=word.substr(0,i);// left subpart\\n              string suffix=word.substr(i);  // right subpart\\n              if(mp[prefix] && (mp[suffix] || concat_possible(suffix,words,mp))){   /*checking if left and right subpart is present in map or not .\\nif one subpart is present(lets say prefix) and other is not(lets say suffix) then recursively check the suffix subpart .if both subparts is present then return true*/\\n                  return true;\\n              }\\n          }\\n          return false;\\n}\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string>ans;\\n        unordered_map<string,int>mp; \\n        for(auto string:words){   //storing each words into unordered_map\\n            mp[string]++;\\n        }\\n\\n\\n        for(auto &word:words){  //check for each word .if its return true then add it into our solution\\n            if(concat_possible(word,words,mp)){\\n                ans.push_back(word);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103680,
                "title": "clean-codes-full-explanation-trie-dfs-c-java-python3",
                "content": "# Intuition :\\n- We can use the data structure trie to store the words. Then for each word in the list of words, we use depth first search to see whether it is a concatenation of two or more words from the list.\\n\\n- We first build a trie structure that stores the list of words. In every trie node, we use an array of length 26 to store possible next trie node, and a flag to indicate whether the trie node is the last letter of a word in the dictionary.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\n- Suppose we have a list of words like this, words = [\\u201Ccat\\u201D, \\u201Ccats\\u201D, \\u201Ccatsdogcats\\u201D, \\u201Cdog\\u201D, \\u201Cdogcatsdog\\u201D, \\u201Chippopotamuses\\u201D, \\u201Crat\\u201D, \\u201Cratcatdogcat\\u201D]. The trie structure we build looks like the following. If the node is an end of a word, there is a * next to it.\\n```\\n    c    d    h    r\\n    |    |    |    |\\n    a    o    i    a\\n    |    |    |    |\\n    t*   g*   p    t*\\n    |    |    |    |\\n    s*   c    p    c\\n    |    |    |    |\\n    d    a    o    a\\n    |    |    |    |\\n    o    t    p    t\\n    |    |    |    |\\n    g    s    o    d\\n    |    |    |    |\\n    c    d    t    o\\n    |    |    |    |\\n    a    o    a    g\\n    |    |    |    |\\n    t    g*   m    c\\n    |         |    |\\n    s*        u    a\\n            |    |\\n            s    t*\\n            |\\n            e\\n            |\\n            s*\\n```\\n- Next, for each word in the sentence, we search whether the word is a concatenation of two or more other words from the list. We can use depth first search here.\\n\\n- For each word, we start from the root node of the trie and the first letter of the word. If the letter is not null in the current trie node, we go to the next trie node of that letter. We keep searching until the trie node is an end of a word (with a * in the above graph). \\n\\n- We increase the count of words the comprise the current word. Then we start from the root node of the trie again, and keep on searching until we reach the end of the current word. If we cannot find the letter in the trie, we go backtrack to the last run of trie nodes and continue the search.\\n\\n- If we can find a concatenation of words that reaches the end of the current word, we check how many words are concatenated. If it is greater than 2, we put the current word to the final answer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes for above Explained Approach :\\n```C++ []\\nclass Solution {\\nstruct TrieNode {\\n    TrieNode* arr[26];\\n    bool is_end;\\n    TrieNode() {\\n        for (int i = 0; i < 26; i ++) arr[i] = NULL;\\n        is_end = false;\\n    }  \\n};\\n\\nvoid insert(TrieNode* root, string key) {\\n    TrieNode* curr = root;\\n    for (int i = 0; i < key.size(); i ++) {\\n        int idx = key[i] - \\'a\\';\\n        if (curr->arr[idx] == NULL)\\n            curr->arr[idx] = new TrieNode();\\n        curr = curr->arr[idx];\\n    }\\n    curr->is_end = true;\\n}\\n\\nbool dfs(TrieNode* root, string key, int index, int count) {\\n    if (index >= key.size())\\n        return count > 1;\\n    TrieNode* curr = root;\\n    for (int i = index; i < key.size(); i ++) {\\n        int p = key[i] - \\'a\\';\\n        if (curr->arr[p] == NULL) {\\n            return false;\\n        }\\n        curr = curr->arr[p];\\n        if (curr->is_end) {\\n            if (dfs(root, key, i+1, count+1))\\n                return true;\\n        }\\n    }\\n    return false;\\n}\\npublic:\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    TrieNode* root = new TrieNode();\\n    for (int i = 0; i < words.size(); i ++) {\\n        insert(root, words[i]);\\n    }\\n    vector<string> ans;\\n    for (int i = 0; i < words.size(); i ++) {\\n        if (dfs(root, words[i], 0, 0))\\n            ans.push_back(words[i]);\\n    }\\n    return ans;   \\n}\\n};\\n```\\n```Java []\\nimport java.util.List;\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] arr = new TrieNode[26];\\n        boolean is_end;\\n        TrieNode() {\\n            for (int i = 0; i < 26; i ++) arr[i] = null;\\n            is_end = false;\\n        }  \\n    };\\n\\n    void insert(TrieNode root, String key) {\\n        TrieNode curr = root;\\n        for (int i = 0; i < key.length(); i ++) {\\n            int idx = key.charAt(i) - \\'a\\';\\n            if (curr.arr[idx] == null)\\n                curr.arr[idx] = new TrieNode();\\n            curr = curr.arr[idx];\\n        }\\n        curr.is_end = true;\\n    }\\n\\n    boolean dfs(TrieNode root, String key, int index, int count) {\\n        if (index >= key.length())\\n            return count > 1;\\n        TrieNode curr = root;\\n        for (int i = index; i < key.length(); i ++) {\\n            int p = key.charAt(i) - \\'a\\';\\n            if (curr.arr[p] == null) {\\n                return false;\\n            }\\n            curr = curr.arr[p];\\n            if (curr.is_end) {\\n                if (dfs(root, key, i+1, count+1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (int i = 0; i < words.length; i ++) {\\n            insert(root, words[i]);\\n        }\\n        List<String> ans = new ArrayList<String>();\\n        for (int i = 0; i < words.length; i ++) {\\n            if (dfs(root, words[i], 0, 0))\\n                ans.add(words[i]);\\n        }\\n        return ans;   \\n    }\\n}\\n```\\n```Python3 []\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = [None] * 26\\n        self.is_end = False\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, root, key):\\n        curr = root\\n        for i in range(len(key)):\\n            idx = ord(key[i]) - ord(\\'a\\')\\n            if not curr.children[idx]:\\n                curr.children[idx] = TrieNode()\\n            curr = curr.children[idx]\\n        curr.is_end = True\\n\\n    def dfs(self, root, key, index, count):\\n        if index >= len(key):\\n            return count > 1\\n        curr = root\\n        for i in range(index, len(key)):\\n            p = ord(key[i]) - ord(\\'a\\')\\n            if not curr.children[p]:\\n                return False\\n            curr = curr.children[p]\\n            if curr.is_end:\\n                if self.dfs(root, key, i+1, count+1):\\n                    return True\\n        return False\\n\\n    def findAllConcatenatedWordsInADict(self, words):\\n        for i in range(len(words)):\\n            self.insert(self.root, words[i])\\n        ans = []\\n        for i in range(len(words)):\\n            if self.dfs(self.root, words[i], 0, 0):\\n                ans.append(words[i])\\n        return ans\\n```\\n# For the 42/43 test case passing issue in C++ : Use this code\\n```\\nclass Solution {\\nprivate:\\n    struct Trie\\n    {\\n        vector<Trie*> children{26};\\n        bool end{false};\\n    };\\n    \\n    Trie* root;\\n    \\n    void insert(string& s)\\n    {\\n        if (s.empty()) return;\\n        Trie* cur = root;\\n        for (char c:s)\\n        {\\n            if (cur->children[c-\\'a\\'] == nullptr)\\n                cur->children[c-\\'a\\'] = new Trie();\\n            cur = cur->children[c-\\'a\\'];\\n        }\\n        cur->end = true;\\n    }\\n    \\n    bool dfs(Trie* root, Trie* node, string& word, int idx, int count)\\n    {\\n        if (!node)\\n            return false;\\n        \\n        if (idx >= word.size())\\n        {\\n            if (node->end && count >=1 )\\n                return true;\\n            else\\n                return false;\\n        }\\n        \\n        if (node->end && dfs(root, root, word, idx, count+1))\\n            return true;\\n        return dfs(root, node->children[word[idx]-\\'a\\'], word, idx+1, count);\\n    }\\n    \\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string& w1, const string& w2) {\\n            return w1.size() < w2.size();\\n        });\\n        \\n        vector<string> ret;\\n        root = new Trie();\\n        \\n        for(auto &w: words)\\n        {\\n            if (w.empty()) continue;\\n            if(dfs(root, root, w, 0, 0)) \\n                ret.push_back(w);\\n            else \\n                insert(w);\\n        }\\n    \\n        return ret;\\n    }\\n};\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/72a4b9ca-318a-44de-8711-814663986266_1674788273.972068.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\n    c    d    h    r\\n    |    |    |    |\\n    a    o    i    a\\n    |    |    |    |\\n    t*   g*   p    t*\\n    |    |    |    |\\n    s*   c    p    c\\n    |    |    |    |\\n    d    a    o    a\\n    |    |    |    |\\n    o    t    p    t\\n    |    |    |    |\\n    g    s    o    d\\n    |    |    |    |\\n    c    d    t    o\\n    |    |    |    |\\n    a    o    a    g\\n    |    |    |    |\\n    t    g*   m    c\\n    |         |    |\\n    s*        u    a\\n            |    |\\n            s    t*\\n            |\\n            e\\n            |\\n            s*\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution {\\nstruct TrieNode {\\n    TrieNode* arr[26];\\n    bool is_end;\\n    TrieNode() {\\n        for (int i = 0; i < 26; i ++) arr[i] = NULL;\\n        is_end = false;\\n    }  \\n};\\n\\nvoid insert(TrieNode* root, string key) {\\n    TrieNode* curr = root;\\n    for (int i = 0; i < key.size(); i ++) {\\n        int idx = key[i] - \\'a\\';\\n        if (curr->arr[idx] == NULL)\\n            curr->arr[idx] = new TrieNode();\\n        curr = curr->arr[idx];\\n    }\\n    curr->is_end = true;\\n}\\n\\nbool dfs(TrieNode* root, string key, int index, int count) {\\n    if (index >= key.size())\\n        return count > 1;\\n    TrieNode* curr = root;\\n    for (int i = index; i < key.size(); i ++) {\\n        int p = key[i] - \\'a\\';\\n        if (curr->arr[p] == NULL) {\\n            return false;\\n        }\\n        curr = curr->arr[p];\\n        if (curr->is_end) {\\n            if (dfs(root, key, i+1, count+1))\\n                return true;\\n        }\\n    }\\n    return false;\\n}\\npublic:\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    TrieNode* root = new TrieNode();\\n    for (int i = 0; i < words.size(); i ++) {\\n        insert(root, words[i]);\\n    }\\n    vector<string> ans;\\n    for (int i = 0; i < words.size(); i ++) {\\n        if (dfs(root, words[i], 0, 0))\\n            ans.push_back(words[i]);\\n    }\\n    return ans;   \\n}\\n};\\n```\n```Java []\\nimport java.util.List;\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] arr = new TrieNode[26];\\n        boolean is_end;\\n        TrieNode() {\\n            for (int i = 0; i < 26; i ++) arr[i] = null;\\n            is_end = false;\\n        }  \\n    };\\n\\n    void insert(TrieNode root, String key) {\\n        TrieNode curr = root;\\n        for (int i = 0; i < key.length(); i ++) {\\n            int idx = key.charAt(i) - \\'a\\';\\n            if (curr.arr[idx] == null)\\n                curr.arr[idx] = new TrieNode();\\n            curr = curr.arr[idx];\\n        }\\n        curr.is_end = true;\\n    }\\n\\n    boolean dfs(TrieNode root, String key, int index, int count) {\\n        if (index >= key.length())\\n            return count > 1;\\n        TrieNode curr = root;\\n        for (int i = index; i < key.length(); i ++) {\\n            int p = key.charAt(i) - \\'a\\';\\n            if (curr.arr[p] == null) {\\n                return false;\\n            }\\n            curr = curr.arr[p];\\n            if (curr.is_end) {\\n                if (dfs(root, key, i+1, count+1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for (int i = 0; i < words.length; i ++) {\\n            insert(root, words[i]);\\n        }\\n        List<String> ans = new ArrayList<String>();\\n        for (int i = 0; i < words.length; i ++) {\\n            if (dfs(root, words[i], 0, 0))\\n                ans.add(words[i]);\\n        }\\n        return ans;   \\n    }\\n}\\n```\n```Python3 []\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = [None] * 26\\n        self.is_end = False\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, root, key):\\n        curr = root\\n        for i in range(len(key)):\\n            idx = ord(key[i]) - ord(\\'a\\')\\n            if not curr.children[idx]:\\n                curr.children[idx] = TrieNode()\\n            curr = curr.children[idx]\\n        curr.is_end = True\\n\\n    def dfs(self, root, key, index, count):\\n        if index >= len(key):\\n            return count > 1\\n        curr = root\\n        for i in range(index, len(key)):\\n            p = ord(key[i]) - ord(\\'a\\')\\n            if not curr.children[p]:\\n                return False\\n            curr = curr.children[p]\\n            if curr.is_end:\\n                if self.dfs(root, key, i+1, count+1):\\n                    return True\\n        return False\\n\\n    def findAllConcatenatedWordsInADict(self, words):\\n        for i in range(len(words)):\\n            self.insert(self.root, words[i])\\n        ans = []\\n        for i in range(len(words)):\\n            if self.dfs(self.root, words[i], 0, 0):\\n                ans.append(words[i])\\n        return ans\\n```\n```\\nclass Solution {\\nprivate:\\n    struct Trie\\n    {\\n        vector<Trie*> children{26};\\n        bool end{false};\\n    };\\n    \\n    Trie* root;\\n    \\n    void insert(string& s)\\n    {\\n        if (s.empty()) return;\\n        Trie* cur = root;\\n        for (char c:s)\\n        {\\n            if (cur->children[c-\\'a\\'] == nullptr)\\n                cur->children[c-\\'a\\'] = new Trie();\\n            cur = cur->children[c-\\'a\\'];\\n        }\\n        cur->end = true;\\n    }\\n    \\n    bool dfs(Trie* root, Trie* node, string& word, int idx, int count)\\n    {\\n        if (!node)\\n            return false;\\n        \\n        if (idx >= word.size())\\n        {\\n            if (node->end && count >=1 )\\n                return true;\\n            else\\n                return false;\\n        }\\n        \\n        if (node->end && dfs(root, root, word, idx, count+1))\\n            return true;\\n        return dfs(root, node->children[word[idx]-\\'a\\'], word, idx+1, count);\\n    }\\n    \\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string& w1, const string& w2) {\\n            return w1.size() < w2.size();\\n        });\\n        \\n        vector<string> ret;\\n        root = new Trie();\\n        \\n        for(auto &w: words)\\n        {\\n            if (w.empty()) continue;\\n            if(dfs(root, root, w, 0, 0)) \\n                ret.push_back(w);\\n            else \\n                insert(w);\\n        }\\n    \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401307,
                "title": "accepted-192ms-c-solution-using-dp-and-trie",
                "content": "Following is pretty straight-forward, kind-of brute-force approach that result to TLE upon submission. Almost all the solution-posts follow this approach and result to TLE with newly added test-cases.  \\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](string& w1, string& w2){\\n            return (w1.length() <= w2.length());\\n        });\\n        \\n        vector<string> ret;\\n        unordered_set<string> m;\\n        \\n        for(string w : words) {\\n            vector<bool> dp(w.length()+1, false);\\n            dp[0] = true;\\n            for(int i = 0; i < w.length(); i++) {\\n                for(int j = i; j >= 0; j--) {\\n                    string s = w.substr(j, i-j+1); // O(length) operation\\n                    if(dp[j] && m.find(s) != m.end()) {\\n                        dp[i+1] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if(dp[w.length()])\\n                ret.push_back(w);\\n            \\n            m.insert(w);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```\\n\\nTime complexity : *O(N * L^3)*, where N = number of words and L = length of word.  \\n\\nWhile applying DP for each of the word, we are using `substr` to calculate the suffix and then searching it on `map`. We can use a `trie` instead to check if current suffix is a valid smaller word. That will bring down the complexity from `O(length)` to `O(1)`. \\n\\nSo, following snippet\\n```\\nfor(int j = i; j >= 0; j--) {\\n    string s = w.substr(j, i-j+1); // O(length) operation\\n    if(dp[j] && m.find(s) != m.end()) {\\n        dp[i+1] = true;\\n        break;\\n    }\\n}\\n``` \\ncan be replaced with (provided that the word has been inserted into trie in reverse order)\\n```\\ntrie* node = root;\\nfor(int j = i; j >= 0; j--) {\\n    if(node->arr[w[j]-\\'a\\'] == NULL)\\n        break;\\n    node = node->arr[w[j]-\\'a\\'];\\n    if(dp[j] && node->end) {\\n        dp[i+1] = true;\\n        break;\\n    }\\n}\\n```\\n\\nHere is the final accepted version,\\n```\\nclass Solution {\\n    struct trie{\\n\\t    struct trie* arr[26];\\n\\t    bool end = false;\\n\\t    trie() {\\n\\t\\t    memset(arr,0,sizeof(arr));\\n\\t\\t    end = false;\\n\\t    }\\n    };\\n\\n    trie* root;\\n\\n    void insert(string s){\\n        trie* node = root;\\n        /* \\n         * inserting the string in reverse order as we will search from the\\n         * end (i.e. suffix) of the word while using DP.\\n         */\\n        for(int i = s.length()-1; i >= 0; i--) {\\n            char ch = s[i];\\n            if(!node->arr[ch-\\'a\\']) {\\n                node->arr[ch-\\'a\\'] = new trie();\\n            }\\n            node = node->arr[ch-\\'a\\'];\\n        }\\n        node->end = true;\\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        /* \\n         * every word can be generated by concatinating smaller words only,\\n         * so smaller words will be processed and inserted into trie first \\n         */\\n        sort(words.begin(), words.end(), [](const string& w1, const string& w2) {\\n            return (w1.size() < w2.size());\\n        });\\n        \\n        vector<string> ret;\\n        root = new trie();\\n        \\n        for(string w : words) {\\n            if(w.length() == 0)\\n                continue;\\n            \\n            vector<bool> dp(w.length()+1, false);\\n            dp[0] = true;\\n            for(int i = 0; i < w.length(); i++) {\\n                trie* node = root;\\n                for(int j = i; j >= 0; j--) {\\n                    /* \\n                     * instead of keeping the smaller words into a map and \\n                     * searching in the map after doing substr() which is O(n)\\n                     * operation, trie is being used here to achieve constant \\n                     * time search operation of current suffix\\n                     */ \\n                    if(node->arr[w[j]-\\'a\\'] == NULL)\\n                        break;\\n                    node = node->arr[w[j]-\\'a\\'];\\n                    if(dp[j] && node->end) {\\n                        dp[i+1] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if(dp[w.length()])\\n                ret.push_back(w);\\n            \\n            insert(w);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```\\n\\nTime complexity : *O(N * L^2)*, where N = number of words and L = length of word.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](string& w1, string& w2){\\n            return (w1.length() <= w2.length());\\n        });\\n        \\n        vector<string> ret;\\n        unordered_set<string> m;\\n        \\n        for(string w : words) {\\n            vector<bool> dp(w.length()+1, false);\\n            dp[0] = true;\\n            for(int i = 0; i < w.length(); i++) {\\n                for(int j = i; j >= 0; j--) {\\n                    string s = w.substr(j, i-j+1); // O(length) operation\\n                    if(dp[j] && m.find(s) != m.end()) {\\n                        dp[i+1] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if(dp[w.length()])\\n                ret.push_back(w);\\n            \\n            m.insert(w);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```\n```\\nfor(int j = i; j >= 0; j--) {\\n    string s = w.substr(j, i-j+1); // O(length) operation\\n    if(dp[j] && m.find(s) != m.end()) {\\n        dp[i+1] = true;\\n        break;\\n    }\\n}\\n```\n```\\ntrie* node = root;\\nfor(int j = i; j >= 0; j--) {\\n    if(node->arr[w[j]-\\'a\\'] == NULL)\\n        break;\\n    node = node->arr[w[j]-\\'a\\'];\\n    if(dp[j] && node->end) {\\n        dp[i+1] = true;\\n        break;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    struct trie{\\n\\t    struct trie* arr[26];\\n\\t    bool end = false;\\n\\t    trie() {\\n\\t\\t    memset(arr,0,sizeof(arr));\\n\\t\\t    end = false;\\n\\t    }\\n    };\\n\\n    trie* root;\\n\\n    void insert(string s){\\n        trie* node = root;\\n        /* \\n         * inserting the string in reverse order as we will search from the\\n         * end (i.e. suffix) of the word while using DP.\\n         */\\n        for(int i = s.length()-1; i >= 0; i--) {\\n            char ch = s[i];\\n            if(!node->arr[ch-\\'a\\']) {\\n                node->arr[ch-\\'a\\'] = new trie();\\n            }\\n            node = node->arr[ch-\\'a\\'];\\n        }\\n        node->end = true;\\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        /* \\n         * every word can be generated by concatinating smaller words only,\\n         * so smaller words will be processed and inserted into trie first \\n         */\\n        sort(words.begin(), words.end(), [](const string& w1, const string& w2) {\\n            return (w1.size() < w2.size());\\n        });\\n        \\n        vector<string> ret;\\n        root = new trie();\\n        \\n        for(string w : words) {\\n            if(w.length() == 0)\\n                continue;\\n            \\n            vector<bool> dp(w.length()+1, false);\\n            dp[0] = true;\\n            for(int i = 0; i < w.length(); i++) {\\n                trie* node = root;\\n                for(int j = i; j >= 0; j--) {\\n                    /* \\n                     * instead of keeping the smaller words into a map and \\n                     * searching in the map after doing substr() which is O(n)\\n                     * operation, trie is being used here to achieve constant \\n                     * time search operation of current suffix\\n                     */ \\n                    if(node->arr[w[j]-\\'a\\'] == NULL)\\n                        break;\\n                    node = node->arr[w[j]-\\'a\\'];\\n                    if(dp[j] && node->end) {\\n                        dp[i+1] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if(dp[w.length()])\\n                ret.push_back(w);\\n            \\n            insert(w);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103514,
                "title": "simple-recursion-and-optimization-java-c",
                "content": "Intution\\nFirst lets approach the easiest ones.\\n\\n1. Solution 1: a sub problem\\n\\tThe simple idea is we will break a string into 2  Strings and see if they are they are there in the array\\n\\teg [cat, s, cats]; \\n\\t\\n![image](https://assets.leetcode.com/users/images/719680f5-338f-4d6a-999c-f4e57325c379_1674780347.8472507.png)\\n\\nHowever the second part need not always be there in the array, but it can aslo be a comination of words, but simple idea is to pass the right part again to function. If left is in dict and right can be formed or is in dict we have a word that can be formed.\\n![image](https://assets.leetcode.com/users/images/e4435ad6-2721-4ff6-93e0-7578271f5557_1674780594.4040034.png)\\n\\nThe approach is simple, we pass the words to canBeformed function and check and then add to result;\\n\\nFurther optimization\\n\\nWe are recalculating can be formed for the same word multiple time i.e cat can be passed to canBeformed multiple times. We can simple store already formed words in hashSet\\n\\nhttps://youtu.be/BThdNPvJrpQ\\n\\n![upvote.webp](https://assets.leetcode.com/users/images/e81a44ac-2a0a-4268-8033-63780c428560_1674698166.6324708.webp)\\n\\n\\n\\tSet<String> dict;\\n    Set <String> formedWords;\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        dict = new HashSet<>(Arrays.asList(words));\\n        formedWords = new HashSet<>();\\n        \\n        \\n        for(String word:words){\\n            if(canbeFormed(word)){\\n                result.add(word);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public boolean canbeFormed(String s){\\n        if(formedWords.contains(s)) return true;\\n        \\n        for(int i = 1;i<s.length();i++){\\n            String s1 = s.substring(0,i);\\n            String s2 = s.substring(i);\\n            if(dict.contains(s1)){\\n                if(dict.contains(s2) || canbeFormed(s2)) {\\n                    formedWords.add(s);\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n\\n```\\nunordered_set<string> dict;\\nunordered_set<string> formedWords;\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n   \\n    vector<string> result;\\n    dict = unordered_set<string>(words.begin(), words.end());\\n    formedWords = unordered_set<string>();\\n    \\n    for (auto word : words) {\\n        if (canbeFormed(word)) {\\n            result.push_back(word);\\n        }\\n    }\\n    return result;\\n}\\n\\nbool canbeFormed(std::string s) {\\n    if (formedWords.count(s)) return true;\\n\\n    for (int i = 1; i < s.length(); i++) {\\n        string s1 = s.substr(0, i);\\n        string s2 = s.substr(i);\\n        if (dict.count(s1)) {\\n            if (dict.count(s2) || canbeFormed(s2)) {\\n                formedWords.insert(s);\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nunordered_set<string> dict;\\nunordered_set<string> formedWords;\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n   \\n    vector<string> result;\\n    dict = unordered_set<string>(words.begin(), words.end());\\n    formedWords = unordered_set<string>();\\n    \\n    for (auto word : words) {\\n        if (canbeFormed(word)) {\\n            result.push_back(word);\\n        }\\n    }\\n    return result;\\n}\\n\\nbool canbeFormed(std::string s) {\\n    if (formedWords.count(s)) return true;\\n\\n    for (int i = 1; i < s.length(); i++) {\\n        string s1 = s.substr(0, i);\\n        string s2 = s.substr(i);\\n        if (dict.count(s1)) {\\n            if (dict.count(s2) || canbeFormed(s2)) {\\n                formedWords.insert(s);\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95647,
                "title": "python-explanation",
                "content": "Let's discuss whether a word should be included in our answer.\\nConsider the word as a topologically sorted directed graph, where each node is a letter, and an edge exists from i to j if word[i:j] is in our wordlist, [and there is no edge from i=0 to j=len(word)-1].  We want to know if there is a path from beginning to end.  If there is, then the word can be broken into concatenated parts from our wordlist.  To answer this question, we DFS over this graph.\\n\\nCode:\\n```\\nS = set(A)\\nans = []\\nfor word in A:\\n  if not word: continue\\n  stack = [0]\\n  seen = {0}\\n  M = len(word)\\n  while stack:\\n    node = stack.pop()\\n    if node == M:\\n      ans.append(word)\\n      break\\n    for j in xrange(M - node + 1):\\n      if (word[node:node+j] in S and \\n          node + j not in seen and\\n          (node > 0 or node + j != M)):\\n        stack.append(node + j)\\n        seen.add(node + j)\\n\\nreturn ans\\n```",
                "solutionTags": [],
                "code": "```\\nS = set(A)\\nans = []\\nfor word in A:\\n  if not word: continue\\n  stack = [0]\\n  seen = {0}\\n  M = len(word)\\n  while stack:\\n    node = stack.pop()\\n    if node == M:\\n      ans.append(word)\\n      break\\n    for j in xrange(M - node + 1):\\n      if (word[node:node+j] in S and \\n          node + j not in seen and\\n          (node > 0 or node + j != M)):\\n        stack.append(node + j)\\n        seen.add(node + j)\\n\\nreturn ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95639,
                "title": "python3-solution-beats-100",
                "content": "This is the python version of [this post](https://discuss.leetcode.com/topic/95747/having-been-troubled-by-this-for-a-long-time-here-is-my-pretty-short-java-code-beats-78-quite-easy-no-comlicated-data-structure) written by @JayS03. Surprisingly, the runtime beats 100% of python 3 submissions.\\n```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        res = []\\n        words_dict = set(words)\\n        for word in words:\\n            words_dict.remove(word)\\n            if self.check(word, words_dict) is True:\\n                res.append(word)\\n            words_dict.add(word)\\n        return res\\n    \\n    def check(self, word, d):\\n        if word in d:\\n            return True\\n        \\n        for i in range(len(word),0, -1):\\n            if word[:i] in d and self.check(word[i:], d):\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        res = []\\n        words_dict = set(words)\\n        for word in words:\\n            words_dict.remove(word)\\n            if self.check(word, words_dict) is True:\\n                res.append(word)\\n            words_dict.add(word)\\n        return res\\n    \\n    def check(self, word, d):\\n        if word in d:\\n            return True\\n        \\n        for i in range(len(word),0, -1):\\n            if word[:i] in d and self.check(word[i:], d):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95677,
                "title": "c-772-ms-dp-solution",
                "content": "For any qualified word, there must be at least 3 indexes (at least 1 besides 0 and n-1 which n is the length of the word), which can be used to split the whole string to at least two sub strings and all sub strings can be found in words.\\nE.g. input ```[\"cat\",\"cats\", \"dog\", \"sdog\",\"dogcatsdog\"]```, for word ```dogcatsdog```, there are 2 sets of numbers: ```[0, 3, 6, 10]``` and ```[0, 3, 7, 10]``` which can be formed by concatenating ```[dog, cat, sdog]``` and ```[dog, cats, dog]``` respectively.\\nSo, we can use a ```vector<int> dp(n+1)``` to store if ```w.substr(0, i)``` can be formed by existing words. Once ```i``` reach to ```n``` and it is not the word itself, we put the word to results.\\n\\n```\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```[\"cat\",\"cats\", \"dog\", \"sdog\",\"dogcatsdog\"]```\n```dogcatsdog```\n```[0, 3, 6, 10]```\n```[0, 3, 7, 10]```\n```[dog, cat, sdog]```\n```[dog, cats, dog]```\n```vector<int> dp(n+1)```\n```w.substr(0, i)```\n```i```\n```n```\n```\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95638,
                "title": "having-been-troubled-by-this-for-a-long-time-here-is-my-pretty-short-java-code-beats-78-quite-easy-no-comlicated-data-structure",
                "content": "```\\npublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        Set<String> dictionary = new HashSet<>();\\n        for(String string : words) dictionary.add(string);\\n        for(String word:words) {\\n            dictionary.remove(word);\\n            if(check(word,dictionary)) list.add(word);\\n            dictionary.add(word);\\n        }\\n        return list;\\n    }\\n    \\n    private boolean check(String word,Set<String> dictionary) {\\n        if(dictionary.contains(word)) return true;\\n        int i = word.length() - 1;\\n        while(i >= 1) {\\n            if(dictionary.contains(word.substring(0,i)) && check(word.substring(i),dictionary)) return true;\\n            i--;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        Set<String> dictionary = new HashSet<>();\\n        for(String string : words) dictionary.add(string);\\n        for(String word:words) {\\n            dictionary.remove(word);\\n            if(check(word,dictionary)) list.add(word);\\n            dictionary.add(word);\\n        }\\n        return list;\\n    }\\n    \\n    private boolean check(String word,Set<String> dictionary) {\\n        if(dictionary.contains(word)) return true;\\n        int i = word.length() - 1;\\n        while(i >= 1) {\\n            if(dictionary.contains(word.substring(0,i)) && check(word.substring(i),dictionary)) return true;\\n            i--;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 871866,
                "title": "easyway-explanation-every-step",
                "content": "```\\nfor word in words:\\n            if dfs(word):\\n```\\n\\n# Taking word from wods list /array one by one\\n\\n```\\ndef dfs(word):\\n            for i in range(1, len(word)):\\n```\\n.\\n# travesing one by character which selecte from word list every time \\n\\n```\\nprefix = word[:i]\\n suffix = word[i:]\\n```\\n.\\n# divide the word \\n.\\n# word =prefix [0:i ] +suffix [i :n]\\n.\\n```\\nif prefix in d and suffix in d:\\n                    return True\\n\\t\\t\\t\\t\\t\\n         \\n```\\n# if prefix and suffix present then return ture\\n .\\n```\\n\\t\\t\\t\\t\\t\\n                if prefix in d and dfs(suffix):\\n                    return True\\n                \\n            \\n            return False\\n```\\n \\n# or if prefix present then searching suffix parts .if you find suffix is present in wordlist return true\\n.\\n# else false\\n\\n```    # Explanation \\n#Input: [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\\n\\n\\n    \\n>>>>cat \\n\\nword= cat\\nprefix= c suffix= at\\nprefix= ca suffix= t\\n\\n>>>>>cats\\n\\n\\nword= cats\\nprefix= c suffix= ats\\nprefix= ca suffix= ts\\nprefix= cat suffix= s\\n\\nsending suffix= s\\nword= s\\n           return dfs suffix= s False\\n\\n>>>>>>catsdogcats \\n\\n\\nword= catsdogcats\\nprefix= c suffix= atsdogcats\\nprefix= ca suffix= tsdogcats\\nprefix= cat suffix= sdogcats\\n\\nsending suffix= sdogcats\\nword= sdogcats\\nprefix= s suffix= dogcats\\nprefix= sd suffix= ogcats\\nprefix= sdo suffix= gcats\\nprefix= sdog suffix= cats\\nprefix= sdogc suffix= ats\\nprefix= sdogca suffix= ts\\nprefix= sdogcat suffix= s\\n           return dfs suffix= sdogcats False\\nprefix= cats suffix= dogcats\\n\\nsending suffix= dogcats\\nword= dogcats\\nprefix= d suffix= ogcats\\nprefix= do suffix= gcats\\nprefix= dog suffix= cats\\nsuffix and prefix both present= dog cats\\n         return dfs suffix= dogcats True\\n\\n>>>>>>dog   \\n\\nword= dog\\nprefix= d suffix= og\\nprefix= do suffix= g\\n\\n>>>>>>dogcatsdog \\n\\nword= dogcatsdog\\nprefix= d suffix= ogcatsdog\\nprefix= do suffix= gcatsdog\\nprefix= dog suffix= catsdog\\n\\nsending suffix= catsdog\\nword= catsdog\\nprefix= c suffix= atsdog\\nprefix= ca suffix= tsdog\\nprefix= cat suffix= sdog\\n\\nsending suffix= sdog\\nword= sdog\\nprefix= s suffix= dog\\nprefix= sd suffix= og\\nprefix= sdo suffix= g\\n           return dfs suffix= sdog False\\nprefix= cats suffix= dog\\nsuffix and prefix both present= cats dog\\n         return dfs suffix= catsdog True\\n\\n>>>>>> hippopotamuses\\n\\n\\nword= hippopotamuses\\nprefix= h suffix= ippopotamuses\\nprefix= hi suffix= ppopotamuses\\nprefix= hip suffix= popotamuses\\nprefix= hipp suffix= opotamuses\\nprefix= hippo suffix= potamuses\\nprefix= hippop suffix= otamuses\\nprefix= hippopo suffix= tamuses\\nprefix= hippopot suffix= amuses\\nprefix= hippopota suffix= muses\\nprefix= hippopotam suffix= uses\\nprefix= hippopotamu suffix= ses\\nprefix= hippopotamus suffix= es\\nprefix= hippopotamuse suffix= s\\n\\n>>>>rat\\n\\n\\nword= rat\\nprefix= r suffix= at\\nprefix= ra suffix= t\\n\\n>>>>> ratcatdogcat\\n\\n\\nword= ratcatdogcat\\nprefix= r suffix= atcatdogcat\\nprefix= ra suffix= tcatdogcat\\nprefix= rat suffix= catdogcat\\n\\nsending suffix= catdogcat\\nword= catdogcat\\nprefix= c suffix= atdogcat\\nprefix= ca suffix= tdogcat\\nprefix= cat suffix= dogcat\\n\\nsending suffix= dogcat\\nword= dogcat\\nprefix= d suffix= ogcat\\nprefix= do suffix= gcat\\nprefix= dog suffix= cat\\nsuffix and prefix both present= dog cat\\n         return dfs suffix= dogcat True\\n         return dfs suffix= catdogcat True\\n\\n[\\'catsdogcats\\', \\'dogcatsdog\\', \\'ratcatdogcat\\']\\n\\n \\n \\n```\\n\\n\\n```\\n# python code\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        d = set(words)\\n        \\n        def dfs(word):\\n            for i in range(1, len(word)):\\n                prefix = word[:i]\\n                suffix = word[i:]\\n                \\n                if prefix in d and suffix in d:\\n                    return True\\n\\t\\t\\t\\t\\t\\n                if prefix in d and dfs(suffix):\\n                    return True\\n                \\n            \\n            return False\\n        \\n        res = []\\n        for word in words:\\n            if dfs(word):\\n                res.append(word)\\n        \\n        return res\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfor word in words:\\n            if dfs(word):\\n```\n```\\ndef dfs(word):\\n            for i in range(1, len(word)):\\n```\n```\\nprefix = word[:i]\\n suffix = word[i:]\\n```\n```\\nif prefix in d and suffix in d:\\n                    return True\\n\\t\\t\\t\\t\\t\\n         \\n```\n```\\n\\t\\t\\t\\t\\t\\n                if prefix in d and dfs(suffix):\\n                    return True\\n                \\n            \\n            return False\\n```\n```    # Explanation \\n#Input: [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\\n\\n\\n    \\n>>>>cat \\n\\nword= cat\\nprefix= c suffix= at\\nprefix= ca suffix= t\\n\\n>>>>>cats\\n\\n\\nword= cats\\nprefix= c suffix= ats\\nprefix= ca suffix= ts\\nprefix= cat suffix= s\\n\\nsending suffix= s\\nword= s\\n           return dfs suffix= s False\\n\\n>>>>>>catsdogcats \\n\\n\\nword= catsdogcats\\nprefix= c suffix= atsdogcats\\nprefix= ca suffix= tsdogcats\\nprefix= cat suffix= sdogcats\\n\\nsending suffix= sdogcats\\nword= sdogcats\\nprefix= s suffix= dogcats\\nprefix= sd suffix= ogcats\\nprefix= sdo suffix= gcats\\nprefix= sdog suffix= cats\\nprefix= sdogc suffix= ats\\nprefix= sdogca suffix= ts\\nprefix= sdogcat suffix= s\\n           return dfs suffix= sdogcats False\\nprefix= cats suffix= dogcats\\n\\nsending suffix= dogcats\\nword= dogcats\\nprefix= d suffix= ogcats\\nprefix= do suffix= gcats\\nprefix= dog suffix= cats\\nsuffix and prefix both present= dog cats\\n         return dfs suffix= dogcats True\\n\\n>>>>>>dog   \\n\\nword= dog\\nprefix= d suffix= og\\nprefix= do suffix= g\\n\\n>>>>>>dogcatsdog \\n\\nword= dogcatsdog\\nprefix= d suffix= ogcatsdog\\nprefix= do suffix= gcatsdog\\nprefix= dog suffix= catsdog\\n\\nsending suffix= catsdog\\nword= catsdog\\nprefix= c suffix= atsdog\\nprefix= ca suffix= tsdog\\nprefix= cat suffix= sdog\\n\\nsending suffix= sdog\\nword= sdog\\nprefix= s suffix= dog\\nprefix= sd suffix= og\\nprefix= sdo suffix= g\\n           return dfs suffix= sdog False\\nprefix= cats suffix= dog\\nsuffix and prefix both present= cats dog\\n         return dfs suffix= catsdog True\\n\\n>>>>>> hippopotamuses\\n\\n\\nword= hippopotamuses\\nprefix= h suffix= ippopotamuses\\nprefix= hi suffix= ppopotamuses\\nprefix= hip suffix= popotamuses\\nprefix= hipp suffix= opotamuses\\nprefix= hippo suffix= potamuses\\nprefix= hippop suffix= otamuses\\nprefix= hippopo suffix= tamuses\\nprefix= hippopot suffix= amuses\\nprefix= hippopota suffix= muses\\nprefix= hippopotam suffix= uses\\nprefix= hippopotamu suffix= ses\\nprefix= hippopotamus suffix= es\\nprefix= hippopotamuse suffix= s\\n\\n>>>>rat\\n\\n\\nword= rat\\nprefix= r suffix= at\\nprefix= ra suffix= t\\n\\n>>>>> ratcatdogcat\\n\\n\\nword= ratcatdogcat\\nprefix= r suffix= atcatdogcat\\nprefix= ra suffix= tcatdogcat\\nprefix= rat suffix= catdogcat\\n\\nsending suffix= catdogcat\\nword= catdogcat\\nprefix= c suffix= atdogcat\\nprefix= ca suffix= tdogcat\\nprefix= cat suffix= dogcat\\n\\nsending suffix= dogcat\\nword= dogcat\\nprefix= d suffix= ogcat\\nprefix= do suffix= gcat\\nprefix= dog suffix= cat\\nsuffix and prefix both present= dog cat\\n         return dfs suffix= dogcat True\\n         return dfs suffix= catdogcat True\\n\\n[\\'catsdogcats\\', \\'dogcatsdog\\', \\'ratcatdogcat\\']\\n\\n \\n \\n```\n```\\n# python code\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        d = set(words)\\n        \\n        def dfs(word):\\n            for i in range(1, len(word)):\\n                prefix = word[:i]\\n                suffix = word[i:]\\n                \\n                if prefix in d and suffix in d:\\n                    return True\\n\\t\\t\\t\\t\\t\\n                if prefix in d and dfs(suffix):\\n                    return True\\n                \\n            \\n            return False\\n        \\n        res = []\\n        for word in words:\\n            if dfs(word):\\n                res.append(word)\\n        \\n        return res\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103561,
                "title": "python-very-easy-dp-recursion-memoisation-space-and-time-optimised",
                "content": "First Lets look at the recursion solution so that we get the clarity and then we can move to dp solution\\n```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        # helper function to check if a given word can be formed by concatenating \\n        # two or more words in the input list\\n        def can(w,dit):\\n            for i in range(1,len(w)):\\n                # check the left part of the word\\n                lf=w[:i]\\n                # check the right part of the word\\n                rt=w[i:]\\n                if lf in dit:\\n                    # if left part of the word is in the input set, check if the right part is in the set\\n                    # or can be formed by concatenating other words in the set\\n                    if rt in dit or can(rt,dit):\\n                        return True\\n            return False\\n        # initialize an empty list to store concatenated words\\n        res=[]\\n        # create a set of all words from the input list to improve lookup time\\n        dit = set(list(words))\\n        for w in words:\\n            # check if the word can be formed by concatenating other words in the set\\n            if can(w,dit):\\n                # if it can, add it to the list of concatenated words\\n                res.append(w)\\n                \\n        return res\\n```\\n\\nNow lets look a bit space optimized solution\\n**Space optimized**\\n```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        def can(w,dit):\\n            for i in range(mini,len(w)):\\n                lf=w[:i]\\n                rt=w[i:]\\n                if lf in dit:\\n                    if rt in dit or can(rt,dit):\\n                        return True\\n            return False\\n        res=[]\\n        dit = set(list(words))\\n        mini=10000\\n        for w in words:\\n            mini=min(len(w),mini)\\n        for w in words:\\n            if can(w,dit):\\n                res.append(w)\\n                \\n        return res\\n```\\nNow lets look at the most optimized\\n**DP solution most optimize**\\n```\\nclass Solution:\\ndef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n\\tdef can(w,dit):\\n\\t\\tif w in dp:\\n\\t\\t\\treturn True\\n\\t\\tfor i in range(mini,len(w)):\\n\\t\\t\\tlf=w[:i]\\n\\t\\t\\trt=w[i:]\\n\\t\\t\\tif lf in dit:\\n\\t\\t\\t\\tif rt in dit or can(rt,dit):\\n\\t\\t\\t\\t\\tdp.append(w)\\n\\t\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\tres=[]\\n\\tdit = set(list(words))\\n\\tmini=10000\\n\\tdp=[]\\n\\tfor w in words:\\n\\t\\tmini=min(len(w),mini)\\n\\tfor w in words:\\n\\t\\tif can(w,dit):\\n\\t\\t\\tres.append(w)\\n\\n\\treturn res\\n```\\nHope it helps \\n**UPVOTE** if helped\\nfeel free to post query \\n\\t",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        # helper function to check if a given word can be formed by concatenating \\n        # two or more words in the input list\\n        def can(w,dit):\\n            for i in range(1,len(w)):\\n                # check the left part of the word\\n                lf=w[:i]\\n                # check the right part of the word\\n                rt=w[i:]\\n                if lf in dit:\\n                    # if left part of the word is in the input set, check if the right part is in the set\\n                    # or can be formed by concatenating other words in the set\\n                    if rt in dit or can(rt,dit):\\n                        return True\\n            return False\\n        # initialize an empty list to store concatenated words\\n        res=[]\\n        # create a set of all words from the input list to improve lookup time\\n        dit = set(list(words))\\n        for w in words:\\n            # check if the word can be formed by concatenating other words in the set\\n            if can(w,dit):\\n                # if it can, add it to the list of concatenated words\\n                res.append(w)\\n                \\n        return res\\n```\n```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        def can(w,dit):\\n            for i in range(mini,len(w)):\\n                lf=w[:i]\\n                rt=w[i:]\\n                if lf in dit:\\n                    if rt in dit or can(rt,dit):\\n                        return True\\n            return False\\n        res=[]\\n        dit = set(list(words))\\n        mini=10000\\n        for w in words:\\n            mini=min(len(w),mini)\\n        for w in words:\\n            if can(w,dit):\\n                res.append(w)\\n                \\n        return res\\n```\n```\\nclass Solution:\\ndef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n\\tdef can(w,dit):\\n\\t\\tif w in dp:\\n\\t\\t\\treturn True\\n\\t\\tfor i in range(mini,len(w)):\\n\\t\\t\\tlf=w[:i]\\n\\t\\t\\trt=w[i:]\\n\\t\\t\\tif lf in dit:\\n\\t\\t\\t\\tif rt in dit or can(rt,dit):\\n\\t\\t\\t\\t\\tdp.append(w)\\n\\t\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\tres=[]\\n\\tdit = set(list(words))\\n\\tmini=10000\\n\\tdp=[]\\n\\tfor w in words:\\n\\t\\tmini=min(len(w),mini)\\n\\tfor w in words:\\n\\t\\tif can(w,dit):\\n\\t\\t\\tres.append(w)\\n\\n\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95654,
                "title": "20-line-c-169-ms-beats-100-why-i-think-this-problem-is-not-properly-judged",
                "content": "The following simple naive brutal force easily beats 100% C++ submission from the past 6 months!\\n\\n**You know why your algorithm was slower?**\\n**Because you are too smart!**\\n\\n DO NOT memoize the intermediate results and DO NOT use trie. The additional data structure slows the algorithm down!!\\n\\nThis is why I think this problem is not properly judged. The judge system should favor smarter solutions, like DP (DFS with memoization) or Trie over a naive solution like mine. \\n\\nAnd truth to be told, this brutal force naive one is actually my 3rd attempts: Trie is MLE, DFS with memoization is too slow (220 ms)...\\n```\\nclass Solution {\\n    vector<string> results;\\n    unordered_set<string> dict;\\n    int min_len = 1;\\n    bool isConcatenated(string const & word)\\n    {\\n        if (dict.count(word)) return true;\\n        for (int i =  min_len; i < word.size() - min_len + 1 ; ++ i)\\n            if (dict.count(word.substr(0, i)) > 0 && isConcatenated(word.substr(i, word.size() - i)))\\n                return true;\\n        return false;\\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string &lhs, const string &rhs){return lhs.size() < rhs.size();});\\n        min_len = max(1ul, words.front().size());\\n        for (int i = 0; i < words.size(); dict.insert(words[i++]))\\n            if (words[i].size() >= min_len * 2 && isConcatenated(words[i]))\\n                results.push_back(words[i]);\\n        return results;\\n    }\\n};\\n```\\n\\nThis is my Trie which got a MLE\\n```\\n///Passed all cases but last one got a MLE (memory limit exceeded).\\nstruct TrieNode\\n{\\n    const static char BEGC = \\'`\\', ENDC = \\'{\\';\\n    TrieNode * m_children[27] = {nullptr};\\n    TrieNode(char c = BEGC)\\n    {\\n    }\\n    inline const TrieNode * operator[](char c) const\\n    {\\n        return m_children[c - \\'a\\'];\\n    }\\n    inline TrieNode *& operator[](char c)\\n    {\\n        return m_children[c - \\'a\\'];\\n    }\\n    virtual ~TrieNode ()\\n    {\\n        for (auto ptr : m_children)\\n            delete ptr;\\n    }\\n};\\nstruct Trie\\n{\\n    TrieNode* root;\\n    const static char BEGC = TrieNode::BEGC, ENDC = TrieNode::ENDC;\\n    virtual ~Trie()\\n    {\\n        delete root;\\n    }\\n    Trie()\\n    {\\n        root = new TrieNode();\\n    }\\n    void insert(const string & word)\\n    {\\n        TrieNode *cur_node_ptr = root;\\n        for (const auto c : word)\\n        {\\n            TrieNode &cur_node = *cur_node_ptr;\\n            if (cur_node[c] == nullptr)\\n                cur_node[c] = new TrieNode(c);\\n            cur_node_ptr = cur_node[c];\\n        }\\n        TrieNode &cur_node = *cur_node_ptr;\\n        if (cur_node[ENDC] == nullptr)\\n            cur_node[ENDC] = new TrieNode(ENDC);\\n    }\\n};\\nclass Solution {\\n    vector<string> results;\\n    Trie trie;\\n    bool isConcatenated(string const & word, int start)\\n    {\\n        TrieNode * cur_node_ptr = trie.root;\\n        for (int i = start; i < word.size(); ++i)\\n        {\\n            TrieNode & cur_node = *cur_node_ptr;\\n            if (cur_node[Trie::ENDC] != nullptr && isConcatenated(word, i))\\n                return true;\\n            cur_node_ptr = cur_node[word[i]];\\n            if (cur_node_ptr == nullptr)\\n                return false;\\n        }\\n        if ((*cur_node_ptr)[Trie::ENDC] != nullptr)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string &lhs, const string &rhs){return lhs.size() < rhs.size();});\\n        for (auto word : words)\\n        {\\n            if (word.empty())\\n                continue;\\n            if (isConcatenated(word, 0))\\n                results.push_back(word);\\n            trie.insert(word);\\n        }\\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<string> results;\\n    unordered_set<string> dict;\\n    int min_len = 1;\\n    bool isConcatenated(string const & word)\\n    {\\n        if (dict.count(word)) return true;\\n        for (int i =  min_len; i < word.size() - min_len + 1 ; ++ i)\\n            if (dict.count(word.substr(0, i)) > 0 && isConcatenated(word.substr(i, word.size() - i)))\\n                return true;\\n        return false;\\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string &lhs, const string &rhs){return lhs.size() < rhs.size();});\\n        min_len = max(1ul, words.front().size());\\n        for (int i = 0; i < words.size(); dict.insert(words[i++]))\\n            if (words[i].size() >= min_len * 2 && isConcatenated(words[i]))\\n                results.push_back(words[i]);\\n        return results;\\n    }\\n};\\n```\n```\\n///Passed all cases but last one got a MLE (memory limit exceeded).\\nstruct TrieNode\\n{\\n    const static char BEGC = \\'`\\', ENDC = \\'{\\';\\n    TrieNode * m_children[27] = {nullptr};\\n    TrieNode(char c = BEGC)\\n    {\\n    }\\n    inline const TrieNode * operator[](char c) const\\n    {\\n        return m_children[c - \\'a\\'];\\n    }\\n    inline TrieNode *& operator[](char c)\\n    {\\n        return m_children[c - \\'a\\'];\\n    }\\n    virtual ~TrieNode ()\\n    {\\n        for (auto ptr : m_children)\\n            delete ptr;\\n    }\\n};\\nstruct Trie\\n{\\n    TrieNode* root;\\n    const static char BEGC = TrieNode::BEGC, ENDC = TrieNode::ENDC;\\n    virtual ~Trie()\\n    {\\n        delete root;\\n    }\\n    Trie()\\n    {\\n        root = new TrieNode();\\n    }\\n    void insert(const string & word)\\n    {\\n        TrieNode *cur_node_ptr = root;\\n        for (const auto c : word)\\n        {\\n            TrieNode &cur_node = *cur_node_ptr;\\n            if (cur_node[c] == nullptr)\\n                cur_node[c] = new TrieNode(c);\\n            cur_node_ptr = cur_node[c];\\n        }\\n        TrieNode &cur_node = *cur_node_ptr;\\n        if (cur_node[ENDC] == nullptr)\\n            cur_node[ENDC] = new TrieNode(ENDC);\\n    }\\n};\\nclass Solution {\\n    vector<string> results;\\n    Trie trie;\\n    bool isConcatenated(string const & word, int start)\\n    {\\n        TrieNode * cur_node_ptr = trie.root;\\n        for (int i = start; i < word.size(); ++i)\\n        {\\n            TrieNode & cur_node = *cur_node_ptr;\\n            if (cur_node[Trie::ENDC] != nullptr && isConcatenated(word, i))\\n                return true;\\n            cur_node_ptr = cur_node[word[i]];\\n            if (cur_node_ptr == nullptr)\\n                return false;\\n        }\\n        if ((*cur_node_ptr)[Trie::ENDC] != nullptr)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string &lhs, const string &rhs){return lhs.size() < rhs.size();});\\n        for (auto word : words)\\n        {\\n            if (word.empty())\\n                continue;\\n            if (isConcatenated(word, 0))\\n                results.push_back(word);\\n            trie.insert(word);\\n        }\\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103975,
                "title": "c-easy-no-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<string,int> m;\\n    bool cal(string &str,int idx,int cnt)\\n    {\\n        if(idx==str.size())\\n            return cnt>1;   // check atleat two string are concate\\n        string tmp=\"\";\\n        for(int i=idx;i<str.size();i++)\\n        {\\n            tmp+=str[i];\\n            if(m.find(tmp)!=m.end())\\n            {\\n                // if string found then check with next index\\n                bool flag=cal(str,i+1,cnt+1);\\n                if(flag)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for(auto x:words)\\n            m[x]++;\\n        vector<string> ans;\\n        for(auto x:words)\\n        {\\n            bool flag=cal(x,0,0);\\n            // if given string satisfy the condition then add it to our answer\\n            if(flag)\\n                ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<string,int> m;\\n    bool cal(string &str,int idx,int cnt)\\n    {\\n        if(idx==str.size())\\n            return cnt>1;   // check atleat two string are concate\\n        string tmp=\"\";\\n        for(int i=idx;i<str.size();i++)\\n        {\\n            tmp+=str[i];\\n            if(m.find(tmp)!=m.end())\\n            {\\n                // if string found then check with next index\\n                bool flag=cal(str,i+1,cnt+1);\\n                if(flag)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for(auto x:words)\\n            m[x]++;\\n        vector<string> ans;\\n        for(auto x:words)\\n        {\\n            bool flag=cal(x,0,0);\\n            // if given string satisfy the condition then add it to our answer\\n            if(flag)\\n                ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322444,
                "title": "python-solutions-top-down-dp-trie-dfs",
                "content": "Please see and vote for my Python DP solutions for\\n[139. Word Break](https://leetcode.com/problems/word-break/discuss/322388/Standard-DP-solutions-(Bottom-up-Top-down))\\n[140. Word Break II](https://leetcode.com/problems/word-break-ii/discuss/322400/Standard-Python-DP-solutions-(Bottom-up-Top-down))\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n\\nMethod 1: top-down DP (444 ms, beat 52%)\\nLet dp[i] = whether s[i:len(s)] can be segmented into a space-separated sequence of words, i=0,1,2,..., len(s).\\nThe possible values of dp[i] are: \\n0 means s[i:len(s)] cannot be sucessfully segmented, \\n1 means s[i:len(s)] is in words and cannot be sucessfully segmented,\\n2 means s[i:len(s)] can be segmented into a space-spearated sequence of at least two words.\\n```\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        def recursive(s, i, n):\\n            if i in dp:\\n                return dp[i]\\n            j = i + 1\\n            while j <= n:\\n                if s[i:j] in word_set and recursive(s, j, n):\\n                    dp[i] = 2 if j < n else 1\\n                    return dp[i]\\n                j += 1\\n            dp[i] = 0\\n            return dp[i]\\n            \\n        word_set = set(words)\\n        res = []\\n        for w in words:\\n            n = len(w)\\n            dp = {n: 1}\\n            if recursive(w, 0, n) > 1:\\n                res.append(w)\\n        return res\\n```\\n\\nMethod 2: implement same algorithm via Trie + DFS (1616 ms, beat 6.95%)\\n\\nPlease see and vote for my solutions for\\n[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/320224/Simple-Python-solution)\\n[1233. Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/discuss/409075/standard-python-prefix-tree-solution)\\n[1032. Stream of Characters](https://leetcode.com/problems/stream-of-characters/discuss/320837/Standard-Python-Trie-Solution)\\n[211. Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/319361/Simple-Python-solution)\\n[676. Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/discuss/320197/Simple-Python-solution)\\n[677. Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/discuss/320237/Simple-Python-solution)\\n[745. Prefix and Suffix Search](https://leetcode.com/problems/prefix-and-suffix-search/discuss/320712/Different-Python-solutions-with-thinking-process)\\n[425. Word Squares](https://leetcode.com/problems/word-squares/discuss/320916/Easily-implemented-Python-solution%3A-Backtrack-%2B-Trie)\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/319071/Standard-Python-solution-with-Trie-%2B-Backtrack)\\n[336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/discuss/316960/Different-Python-solutions%3A-brute-force-dictionary-Trie)\\n\\n```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass Trie():\\n    def __init__(self, words):\\n        self.root = TrieNode()\\n        for w in words:\\n            if w:\\n                self.insert(w)\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        def dfs(node, i, w, space_inserted):\\n            if i == len(w):\\n                return node.isEnd and space_inserted\\n            if node.isEnd:\\n                if dfs(trie.root, i, w, True):\\n                    return True\\n            if w[i] not in node.children:\\n                return False\\n            else:\\n                return dfs(node.children[w[i]], i + 1, w, space_inserted)\\n        \\n        trie = Trie(words)\\n        res = []\\n        for w in words:\\n            if dfs(trie.root, 0, w, False):\\n                res.append(w)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        def recursive(s, i, n):\\n            if i in dp:\\n                return dp[i]\\n            j = i + 1\\n            while j <= n:\\n                if s[i:j] in word_set and recursive(s, j, n):\\n                    dp[i] = 2 if j < n else 1\\n                    return dp[i]\\n                j += 1\\n            dp[i] = 0\\n            return dp[i]\\n            \\n        word_set = set(words)\\n        res = []\\n        for w in words:\\n            n = len(w)\\n            dp = {n: 1}\\n            if recursive(w, 0, n) > 1:\\n                res.append(w)\\n        return res\\n```\n```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass Trie():\\n    def __init__(self, words):\\n        self.root = TrieNode()\\n        for w in words:\\n            if w:\\n                self.insert(w)\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        def dfs(node, i, w, space_inserted):\\n            if i == len(w):\\n                return node.isEnd and space_inserted\\n            if node.isEnd:\\n                if dfs(trie.root, i, w, True):\\n                    return True\\n            if w[i] not in node.children:\\n                return False\\n            else:\\n                return dfs(node.children[w[i]], i + 1, w, space_inserted)\\n        \\n        trie = Trie(words)\\n        res = []\\n        for w in words:\\n            if dfs(trie.root, 0, w, False):\\n                res.append(w)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95636,
                "title": "simple-java-trie-dfs-solution-144ms",
                "content": "Most of lines are adding words into Trie Tree \\nThis solution is like putting two pointers to search through the tree. When find a word, put the other pointer back on root then continue searching.\\nBut I'm not sure about the time complexity of my solution. Suppose word length is len and there are n words. Is the time complexity O(len * n ^ 2)?\\n```\\npublic class Solution {\\n    class TrieNode {\\n        TrieNode[] children;\\n        String word;\\n        boolean isEnd;\\n        boolean combo; //if this word is a combination of simple words\\n        boolean added; //if this word is already added in result\\n        public TrieNode() {\\n            this.children = new TrieNode[26];\\n            this.word = new String();\\n            this.isEnd = false;\\n            this.combo = false;\\n            this.added = false;\\n        }\\n    }\\n    private void addWord(String str) {\\n        TrieNode node = root;\\n        for (char ch : str.toCharArray()) {\\n            if (node.children[ch - 'a'] == null) {\\n                node.children[ch - 'a'] = new TrieNode();\\n            }\\n            node = node.children[ch - 'a'];\\n        }\\n        node.isEnd = true;\\n        node.word = str;\\n    }\\n    private TrieNode root;\\n    private List<String> result;\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        root = new TrieNode();\\n        for (String str : words) {\\n            if (str.length() == 0) {\\n                continue;\\n            }\\n            addWord(str);\\n        }\\n        result = new ArrayList<>();\\n        dfs(root, 0);\\n        return result;\\n    }\\n    private void dfs(TrieNode node, int multi) {\\n    \\t//multi counts how many single words combined in this word\\n        if(node.isEnd && !node.added && multi > 1) {\\n            node.combo = true;\\n            node.added = true;\\n            result.add(node.word);\\n        }\\n        searchWord(node, root, multi);\\n    }\\n    private void searchWord(TrieNode node1, TrieNode node2, int multi) {\\n        if (node2.combo) {\\n            return;\\n        }\\n        if (node2.isEnd) {\\n            //take the pointer of node2 back to root\\n            dfs(node1, multi + 1);\\n        }\\n        for (int  i = 0; i < 26; i++) {\\n            if (node1.children[i] != null && node2.children[i] != null) {\\n                searchWord(node1.children[i], node2.children[i], multi);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    class TrieNode {\\n        TrieNode[] children;\\n        String word;\\n        boolean isEnd;\\n        boolean combo; //if this word is a combination of simple words\\n        boolean added; //if this word is already added in result\\n        public TrieNode() {\\n            this.children = new TrieNode[26];\\n            this.word = new String();\\n            this.isEnd = false;\\n            this.combo = false;\\n            this.added = false;\\n        }\\n    }\\n    private void addWord(String str) {\\n        TrieNode node = root;\\n        for (char ch : str.toCharArray()) {\\n            if (node.children[ch - 'a'] == null) {\\n                node.children[ch - 'a'] = new TrieNode();\\n            }\\n            node = node.children[ch - 'a'];\\n        }\\n        node.isEnd = true;\\n        node.word = str;\\n    }\\n    private TrieNode root;\\n    private List<String> result;\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        root = new TrieNode();\\n        for (String str : words) {\\n            if (str.length() == 0) {\\n                continue;\\n            }\\n            addWord(str);\\n        }\\n        result = new ArrayList<>();\\n        dfs(root, 0);\\n        return result;\\n    }\\n    private void dfs(TrieNode node, int multi) {\\n    \\t//multi counts how many single words combined in this word\\n        if(node.isEnd && !node.added && multi > 1) {\\n            node.combo = true;\\n            node.added = true;\\n            result.add(node.word);\\n        }\\n        searchWord(node, root, multi);\\n    }\\n    private void searchWord(TrieNode node1, TrieNode node2, int multi) {\\n        if (node2.combo) {\\n            return;\\n        }\\n        if (node2.isEnd) {\\n            //take the pointer of node2 back to root\\n            dfs(node1, multi + 1);\\n        }\\n        for (int  i = 0; i < 26; i++) {\\n            if (node1.children[i] != null && node2.children[i] != null) {\\n                searchWord(node1.children[i], node2.children[i], multi);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573115,
                "title": "simple-solution-javascript-beats-90-with-explanation",
                "content": "\\n1. Use a set for quick lookup\\n2. Call isConcat on each word.  If a word\\'s prefix is in the dictionary, see if the suffix can also be concatenated.\\n3. You can use the dictionary as a memo, when you find a word that can be made via concatenation, you can store it in the dictionary\\n4. When you loop through the words, remember to delete and add the word from the set before and after the isConcat call\\n\\n```\\nlet findAllConcatenatedWordsInADict = (words) => {\\n    const dict = new Set(words);\\n    const isConcat = (word) => {\\n        if(dict.has(word)) return true;\\n        for(let i = 0; i < word.length; i++){\\n            let prefix = word.slice(0,i+1);\\n            if(dict.has(prefix)){\\n                let suffix = word.slice(i+1);\\n                let result = isConcat(suffix);\\n                if(result){\\n                    dict.add(word);\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    const results = [];\\n    for(const word of words){\\n        dict.delete(word);\\n        if(isConcat(word)) results.push(word);\\n        dict.add(word);\\n    }\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nlet findAllConcatenatedWordsInADict = (words) => {\\n    const dict = new Set(words);\\n    const isConcat = (word) => {\\n        if(dict.has(word)) return true;\\n        for(let i = 0; i < word.length; i++){\\n            let prefix = word.slice(0,i+1);\\n            if(dict.has(prefix)){\\n                let suffix = word.slice(i+1);\\n                let result = isConcat(suffix);\\n                if(result){\\n                    dict.add(word);\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    const results = [];\\n    for(const word of words){\\n        dict.delete(word);\\n        if(isConcat(word)) results.push(word);\\n        dict.add(word);\\n    }\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 95670,
                "title": "a-review-of-top-solutions",
                "content": "After studying the top solutions, I might not be the only one wondering which is the best and why. So I would like to share my understanding with this post.\\n\\nOne sub problem is word break. There are three ways to solve word break,[ DFS, BFS and DP](https://discuss.leetcode.com/topic/66356/evolve-from-brute-force-to-optimal). DFS is the best way because it terminates as soon as it finds one way to break the word. DP and BFS checks all the substrings thus less efficient. Combined with the sorting idea by [@shawngao ](https://discuss.leetcode.com/topic/72113/java-dp-solution) is the best I have.\\n```\\n    struct comp {\\n        bool operator()(string &s1, string &s2) {\\n            return s1.size()<s2.size();\\n        }\\n    };\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> ht; \\n        vector<string> res;\\n        sort(words.begin(),words.end(),comp());\\n        for(auto &s:words) {\\n            if(s.empty()) continue;\\n            if(canbrk(0,s,ht)) res.push_back(s);\\n            ht.insert(s);\\n        }\\n        return res;\\n    }\\n    bool canbrk(int p, string &s, unordered_set<string>& ht) {\\n        int n = s.size();\\n        if(p==n) return 1;\\n        string sub;\\n        for(int i=p;i<n;i++) if(ht.count(sub+=s[i])&&canbrk(i+1,s,ht)) return 1;\\n        return 0;\\n    }\\n```\\nAnother improve is to use trie instead of hash table to save memory. However, looks like all c++ solution with trie gets memory limit exceeded. I think the oj bug needs to be fixed @administrators \\n```\\n    struct Node {\\n        Node():end(),nxt() {};\\n        bool end;\\n        Node* nxt[26];\\n    };\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> res;\\n        sort(words.begin(),words.end(),comp());\\n        Node *root = new Node();\\n        for(auto &s:words) {\\n            if(s.empty()) continue;\\n            if(canbrk(0,s,root)) res.push_back(s);\\n            addWord(s,root);\\n        }\\n        destroy(root);\\n        return res;\\n    }\\n    bool canbrk(int p, string &s, Node *r) {\\n        int n = s.size();\\n        if(p==n) return 1;\\n        string sub;\\n        for(int i=p;i<n;i++) if(search(sub+=s[i], r)&&canbrk(i+1,s,r)) return 1;\\n        return 0;\\n    }\\n    void addWord(string word, Node *p) {\\n        for(char c:word) {\\n            Node *&nxt = p->nxt[c-'a'];\\n            if(!nxt) nxt = new Node();\\n            p = nxt;\\n        }\\n        p->end = 1;\\n    }\\n    bool search(string& word, Node *r) {\\n        for(char c:word) {\\n            Node *&nxt = r->nxt[c-'a'];\\n            if(!nxt) return 0;\\n            r = nxt;\\n        }\\n        return r->end;\\n    }\\n    void destroy(Node* r) {\\n        if (!r) return;\\n        for (int i = 0; i < 26; i++) destroy(r->nxt[i]);\\n        delete r;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    struct comp {\\n        bool operator()(string &s1, string &s2) {\\n            return s1.size()<s2.size();\\n        }\\n    };\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> ht; \\n        vector<string> res;\\n        sort(words.begin(),words.end(),comp());\\n        for(auto &s:words) {\\n            if(s.empty()) continue;\\n            if(canbrk(0,s,ht)) res.push_back(s);\\n            ht.insert(s);\\n        }\\n        return res;\\n    }\\n    bool canbrk(int p, string &s, unordered_set<string>& ht) {\\n        int n = s.size();\\n        if(p==n) return 1;\\n        string sub;\\n        for(int i=p;i<n;i++) if(ht.count(sub+=s[i])&&canbrk(i+1,s,ht)) return 1;\\n        return 0;\\n    }\\n```\n```\\n    struct Node {\\n        Node():end(),nxt() {};\\n        bool end;\\n        Node* nxt[26];\\n    };\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> res;\\n        sort(words.begin(),words.end(),comp());\\n        Node *root = new Node();\\n        for(auto &s:words) {\\n            if(s.empty()) continue;\\n            if(canbrk(0,s,root)) res.push_back(s);\\n            addWord(s,root);\\n        }\\n        destroy(root);\\n        return res;\\n    }\\n    bool canbrk(int p, string &s, Node *r) {\\n        int n = s.size();\\n        if(p==n) return 1;\\n        string sub;\\n        for(int i=p;i<n;i++) if(search(sub+=s[i], r)&&canbrk(i+1,s,r)) return 1;\\n        return 0;\\n    }\\n    void addWord(string word, Node *p) {\\n        for(char c:word) {\\n            Node *&nxt = p->nxt[c-'a'];\\n            if(!nxt) nxt = new Node();\\n            p = nxt;\\n        }\\n        p->end = 1;\\n    }\\n    bool search(string& word, Node *r) {\\n        for(char c:word) {\\n            Node *&nxt = r->nxt[c-'a'];\\n            if(!nxt) return 0;\\n            r = nxt;\\n        }\\n        return r->end;\\n    }\\n    void destroy(Node* r) {\\n        if (!r) return;\\n        for (int i = 0; i < 26; i++) destroy(r->nxt[i]);\\n        delete r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 145057,
                "title": "java-hashset-48ms-beats-100",
                "content": "```\\npublic class Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ret = new ArrayList<>();\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            set.add(word);\\n        }\\n        for (String word : words) {\\n            if (isConcatenated(set, word)) ret.add(word);\\n        }\\n        return ret;\\n    }\\n    \\n    private boolean isConcatenated(Set<String> set, String s) {\\n        for (int i = 1; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i))) {\\n                String rightStr = s.substring(i);\\n                if (set.contains(rightStr) || isConcatenated(set, rightStr))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ret = new ArrayList<>();\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            set.add(word);\\n        }\\n        for (String word : words) {\\n            if (isConcatenated(set, word)) ret.add(word);\\n        }\\n        return ret;\\n    }\\n    \\n    private boolean isConcatenated(Set<String> set, String s) {\\n        for (int i = 1; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i))) {\\n                String rightStr = s.substring(i);\\n                if (set.contains(rightStr) || isConcatenated(set, rightStr))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765634,
                "title": "python-trie-solution-explained",
                "content": "This question is very similar to [208. Implement Trie (Prefix Tree)](http://leetcode.com/problems/implement-trie-prefix-tree/) with one modification. Apart from searching for a word in the trie, we should also keep track of smaller words encountered during the search. \\n\\n1. We insert all the words into the `trie`. \\n2. Iterate through each word and check if we can successfully perform `DFS`.\\n\\t2.1 If yes, add the word to `result`\\n3. Return the `result`\\n\\nDuring the `DFS`, we keep track of 4 parameters: \\n`word`  - word to be searched\\n`start` - to track the current character of the `word` \\n`root`   -  root of the `trie`\\n`count` - number of smaller words encountered so far\\n\\nWe iterate through the characters of the `word` one by one starting from `start`.  Check if the current character is a word ending and also if it is the last character of the `word`. We make a decision based on the `count` value. Otherwise, we recur for remaining indices of the `word` with `count ` increased by 1. \\n\\nHead over to [link](http://skdoosh-leetcode.herokuapp.com) for more python solutions to leetcode problems and star my [github repo](https://github.com/Anirudh-Muthukumar/Leetcode-Solutions) if you like my work. \\n\\n```\\nimport collections\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.isEnd = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        marker = self.root\\n        for ch in word:\\n            marker = marker.children[ch]\\n        marker.isEnd = True\\n\\n\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \\n        def dfs(word, start, root, count):\\n            n = len(word)\\n            marker = root\\n            for i in range(start, n):\\n                marker = marker.children[word[i]]\\n                if marker.isEnd:           # smaller word encountered\\n                    if i == n-1:               # leaf node\\n                        return count>=1\\n                    elif dfs(word, i+1, root, count+1):     # increment the count and start a new DFS\\n                        return True\\n            return False\\n        \\n        res = []\\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n\\n        for word in words:\\n            if dfs(word, 0, trie.root, 0):\\n                res += word,\\n        \\n        return res\\n```\\n            \\n        \\n\\n        \\n        \\n        \\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nimport collections\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.isEnd = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        marker = self.root\\n        for ch in word:\\n            marker = marker.children[ch]\\n        marker.isEnd = True\\n\\n\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \\n        def dfs(word, start, root, count):\\n            n = len(word)\\n            marker = root\\n            for i in range(start, n):\\n                marker = marker.children[word[i]]\\n                if marker.isEnd:           # smaller word encountered\\n                    if i == n-1:               # leaf node\\n                        return count>=1\\n                    elif dfs(word, i+1, root, count+1):     # increment the count and start a new DFS\\n                        return True\\n            return False\\n        \\n        res = []\\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n\\n        for word in words:\\n            if dfs(word, 0, trie.root, 0):\\n                res += word,\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521059,
                "title": "fast-python-dp-solution",
                "content": "```\\n\\'\\'\\'\\nIf a word can be Concatenated from shorter words, then word[:i] and word[i:] must also be Concatenated from shorter words.\\nBuild results of word from results of word[:i] and word[i:]\\nIterate i from range(1, len(word)) to avoid a word is Concatenated from itself.\\nUse memorization to avoid repeat calculation.\\nTime: O(n*l)\\nSpace: O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        mem = {}\\n        words_set = set(words)\\n        return [w for w in words if self.check(w, words_set, mem)]\\n    \\n    def check(self, word, word_set, mem):\\n        if word in mem:\\n            return mem[word]\\n        mem[word] = False\\n        for i in range(1, len(word)):\\n            if word[:i] in word_set and (word[i:] in word_set or self.check(word[i:], word_set, mem)):\\n                mem[word] = True\\n                break\\n        return mem[word]\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\'\\'\\'\\nIf a word can be Concatenated from shorter words, then word[:i] and word[i:] must also be Concatenated from shorter words.\\nBuild results of word from results of word[:i] and word[i:]\\nIterate i from range(1, len(word)) to avoid a word is Concatenated from itself.\\nUse memorization to avoid repeat calculation.\\nTime: O(n*l)\\nSpace: O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        mem = {}\\n        words_set = set(words)\\n        return [w for w in words if self.check(w, words_set, mem)]\\n    \\n    def check(self, word, word_set, mem):\\n        if word in mem:\\n            return mem[word]\\n        mem[word] = False\\n        for i in range(1, len(word)):\\n            if word[:i] in word_set and (word[i:] in word_set or self.check(word[i:], word_set, mem)):\\n                mem[word] = True\\n                break\\n        return mem[word]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95640,
                "title": "c-solutions-backtrack-dp-or-trie",
                "content": "First, I provide my working solution using unorederd_set. But I think a better solution should use Trie. Though it passed all test cases, I always get MLE. But the java solution using Trie can be accepted. Did anybody have any suggestions about this? I have already made some optimization on it, e.g., a word that can be concatenated by shorter words will not be inserted into the Trie. But I still get MLE.\\n\\nunordered_set solution  486 ms\\n```\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> result;\\n        if(words.empty()) return result; \\n        auto mycomp = [&](const string& str1, const string& str2){return str1.size() < str2.size();};\\n        sort(words.begin(), words.end(), mycomp);\\n        unordered_set<string> mp;\\n        for(auto& word: words) {\\n            string path = \"\";\\n            if(dfs(word, 0, path, 0, mp)) result.push_back(word); // We don't need to insert this word, because it can be concatenated from other words.\\n            else mp.insert(word); \\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    bool dfs(string& word, int pos, string& path, int nb, unordered_set<string>& mp) {\\n        if(pos == word.size()) {\\n            if(mp.find(path) != mp.end() && nb > 0) return true;\\n            else return false;\\n        }\\n        path.push_back(word[pos]);\\n        if(mp.find(path) != mp.end()) {\\n            string temp = \"\";\\n            if(dfs(word, pos+1, temp, nb+1, mp)) return true;\\n        }\\n        if(dfs(word, pos+1, path, nb, mp)) return true;\\n        else return false;\\n    }\\n```\\n\\nDP solution based on Word Break  739 ms\\n```\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> result;\\n        if(words.empty()) return result; \\n        auto mycomp = [&](const string& str1, const string& str2){return str1.size() < str2.size();};\\n        sort(words.begin(), words.end(), mycomp);\\n        unordered_set<string> mp;\\n        for(auto& word: words) {\\n            string path = \"\";\\n            if(wordBreak(word, mp)) result.push_back(word); // We don't need to insert this word, because it can be concatenated from other words.\\n            else mp.insert(word); \\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    bool wordBreak(string& s, unordered_set<string>& wordDict) {\\n        if(s.empty() || wordDict.empty()) return false;\\n        vector<bool> dp(s.size()+1, false);\\n        dp[0] = true;\\n        for(int i = 1; i <= s.size(); i++) {\\n            for(int k = i-1; k >= 0; k--) {\\n                if(dp[k] && wordDict.find(s.substr(k, i-k)) != wordDict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n```\\n\\nHere I provide my Trie-based solution, but it gets MLE.\\n```\\nclass Solution {\\npublic:\\n    struct TrieNode {\\n        bool isWord;\\n        unordered_map<char, TrieNode*> children;\\n        TrieNode(): isWord(false) {};\\n    };\\n\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> result;\\n        if(words.empty()) return result; \\n        auto mycomp = [&](const string& str1, const string& str2){return str1.size() < str2.size();};\\n        sort(words.begin(), words.end(), mycomp);\\n        \\n        root = new TrieNode();\\n        for(auto& word: words) {\\n            if(dfs(word, 0, root, 0)) result.push_back(word);\\n            else insert(word);\\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    TrieNode* root;\\n    \\n    void insert(string& word) {\\n        auto run = root;\\n        for(char c: word) {\\n            if(run->children.find(c) == run->children.end()) {\\n                TrieNode* newnode = new TrieNode();\\n                run->children[c] = newnode;\\n            }\\n            run = run->children[c];\\n        }\\n        run->isWord = true;\\n    }\\n    \\n    bool dfs(string& word, int pos, TrieNode* node, int nb) {\\n        if(pos == word.size()) {\\n            if(node->isWord && nb > 0) return true;\\n            else return false;\\n        }\\n        \\n        if(node->children.find(word[pos]) == node->children.end()) return false;\\n        auto next = node->children[word[pos]];\\n        if(next->isWord) {\\n            if(dfs(word, pos+1, root, nb+1)) return true;\\n        }\\n        if(dfs(word, pos+1, next, nb)) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> result;\\n        if(words.empty()) return result; \\n        auto mycomp = [&](const string& str1, const string& str2){return str1.size() < str2.size();};\\n        sort(words.begin(), words.end(), mycomp);\\n        unordered_set<string> mp;\\n        for(auto& word: words) {\\n            string path = \"\";\\n            if(dfs(word, 0, path, 0, mp)) result.push_back(word); // We don't need to insert this word, because it can be concatenated from other words.\\n            else mp.insert(word); \\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    bool dfs(string& word, int pos, string& path, int nb, unordered_set<string>& mp) {\\n        if(pos == word.size()) {\\n            if(mp.find(path) != mp.end() && nb > 0) return true;\\n            else return false;\\n        }\\n        path.push_back(word[pos]);\\n        if(mp.find(path) != mp.end()) {\\n            string temp = \"\";\\n            if(dfs(word, pos+1, temp, nb+1, mp)) return true;\\n        }\\n        if(dfs(word, pos+1, path, nb, mp)) return true;\\n        else return false;\\n    }\\n```\n```\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> result;\\n        if(words.empty()) return result; \\n        auto mycomp = [&](const string& str1, const string& str2){return str1.size() < str2.size();};\\n        sort(words.begin(), words.end(), mycomp);\\n        unordered_set<string> mp;\\n        for(auto& word: words) {\\n            string path = \"\";\\n            if(wordBreak(word, mp)) result.push_back(word); // We don't need to insert this word, because it can be concatenated from other words.\\n            else mp.insert(word); \\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    bool wordBreak(string& s, unordered_set<string>& wordDict) {\\n        if(s.empty() || wordDict.empty()) return false;\\n        vector<bool> dp(s.size()+1, false);\\n        dp[0] = true;\\n        for(int i = 1; i <= s.size(); i++) {\\n            for(int k = i-1; k >= 0; k--) {\\n                if(dp[k] && wordDict.find(s.substr(k, i-k)) != wordDict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    struct TrieNode {\\n        bool isWord;\\n        unordered_map<char, TrieNode*> children;\\n        TrieNode(): isWord(false) {};\\n    };\\n\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> result;\\n        if(words.empty()) return result; \\n        auto mycomp = [&](const string& str1, const string& str2){return str1.size() < str2.size();};\\n        sort(words.begin(), words.end(), mycomp);\\n        \\n        root = new TrieNode();\\n        for(auto& word: words) {\\n            if(dfs(word, 0, root, 0)) result.push_back(word);\\n            else insert(word);\\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    TrieNode* root;\\n    \\n    void insert(string& word) {\\n        auto run = root;\\n        for(char c: word) {\\n            if(run->children.find(c) == run->children.end()) {\\n                TrieNode* newnode = new TrieNode();\\n                run->children[c] = newnode;\\n            }\\n            run = run->children[c];\\n        }\\n        run->isWord = true;\\n    }\\n    \\n    bool dfs(string& word, int pos, TrieNode* node, int nb) {\\n        if(pos == word.size()) {\\n            if(node->isWord && nb > 0) return true;\\n            else return false;\\n        }\\n        \\n        if(node->children.find(word[pos]) == node->children.end()) return false;\\n        auto next = node->children[word[pos]];\\n        if(next->isWord) {\\n            if(dfs(word, pos+1, root, nb+1)) return true;\\n        }\\n        if(dfs(word, pos+1, next, nb)) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103801,
                "title": "fast-c-code",
                "content": "# Solution Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> words_set;\\n        for (string word : words) words_set.insert(word);\\n        vector<string> res;\\n    \\n        for (string word : words) {\\n            int n = word.size();\\n            vector<int> dp(n + 1, 0);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (!dp[i]) continue;\\n                for (int j = i + 1; j <= n; j++) {\\n                    if (j - i < n && words_set.count(word.substr(i, j - i))) {\\n                        dp[j] = 1;\\n                    }\\n                }\\n                if (dp[n]) {\\n                    res.push_back(word);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/18059b71-18b6-4d9e-8c8a-eb5e64f636fa_1674813837.6846375.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> words_set;\\n        for (string word : words) words_set.insert(word);\\n        vector<string> res;\\n    \\n        for (string word : words) {\\n            int n = word.size();\\n            vector<int> dp(n + 1, 0);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (!dp[i]) continue;\\n                for (int j = i + 1; j <= n; j++) {\\n                    if (j - i < n && words_set.count(word.substr(i, j - i))) {\\n                        dp[j] = 1;\\n                    }\\n                }\\n                if (dp[n]) {\\n                    res.push_back(word);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280915,
                "title": "java-41ms-trie-and-dfs-solution-which-beats-97",
                "content": "We can solve the problem in two steps:\\n1. put the given words in a trie;\\n2. For each word, dfs the trie (traverse characters in the word one by one). If the trie node of current character represent a word, then for next character, we search from the root node of trie. \\n\\n```\\npublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n    Trie root = new Trie();\\n    for(int i = 0; i < words.length; i++) {\\n        if( words[i].length() > 0 )\\n            buildTrie(root, words[i]);\\n    }\\n\\n    List<String> resultList = new ArrayList<String>();\\n    for(int i = 0; i < words.length; i++)\\n        if( search(root, words[i], 0, 0) )\\n            resultList.add(words[i]);\\n    return resultList;\\n}\\n\\npublic void buildTrie(Trie root, String word) {\\n    Trie current = root;\\n    for(int i = 0; i < word.length(); i++) {\\n        int index = word.charAt(i) - \\'a\\';\\n        if( current.array[index] == null )\\n            current.array[index] = new Trie();\\n        current = current.array[index];\\n    }\\n    current.isWord = true;\\n}\\n\\n// num represent the number of words that current word can be comprised of\\npublic boolean search(Trie root, String word, int begin, int num) {\\n    Trie current = root;\\n    for(int i = begin; i < word.length(); i++) {\\n        int index = word.charAt(i) - \\'a\\';\\n        if( current.array[index] == null )\\n            return false;\\n        current = current.array[index];\\n        if( current.isWord && search(root, word, i + 1, num + 1) ) \\n            return true;\\n    }\\n    return num >= 1 && current.isWord;\\n}\\n\\nclass Trie {\\n    Trie array[] = new Trie[26];\\n    boolean isWord = false;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\npublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n    Trie root = new Trie();\\n    for(int i = 0; i < words.length; i++) {\\n        if( words[i].length() > 0 )\\n            buildTrie(root, words[i]);\\n    }\\n\\n    List<String> resultList = new ArrayList<String>();\\n    for(int i = 0; i < words.length; i++)\\n        if( search(root, words[i], 0, 0) )\\n            resultList.add(words[i]);\\n    return resultList;\\n}\\n\\npublic void buildTrie(Trie root, String word) {\\n    Trie current = root;\\n    for(int i = 0; i < word.length(); i++) {\\n        int index = word.charAt(i) - \\'a\\';\\n        if( current.array[index] == null )\\n            current.array[index] = new Trie();\\n        current = current.array[index];\\n    }\\n    current.isWord = true;\\n}\\n\\n// num represent the number of words that current word can be comprised of\\npublic boolean search(Trie root, String word, int begin, int num) {\\n    Trie current = root;\\n    for(int i = begin; i < word.length(); i++) {\\n        int index = word.charAt(i) - \\'a\\';\\n        if( current.array[index] == null )\\n            return false;\\n        current = current.array[index];\\n        if( current.isWord && search(root, word, i + 1, num + 1) ) \\n            return true;\\n    }\\n    return num >= 1 && current.isWord;\\n}\\n\\nclass Trie {\\n    Trie array[] = new Trie[26];\\n    boolean isWord = false;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159916,
                "title": "51ms-easy-java-trie-solution",
                "content": "```\\nclass Solution {\\n    TrieNode root = new TrieNode();\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        build(words);\\n        for (String word : words)  \\n            if (search(root,word,0,0))\\n                res.add(word);\\n        return res;\\n    }\\n    \\n    public void build(String[] dict) {\\n        for (String word : dict) {\\n            if (word == null || word.length() == 0) continue;\\n            TrieNode temp = root;\\n            int len = word.length();\\n            for (int i = 0; i < len; i++) {\\n                char c = word.charAt(i);\\n                if (temp.children[c-\\'a\\'] == null) temp.children[c-\\'a\\'] = new TrieNode();\\n                temp = temp.children[c-\\'a\\'];\\n            }\\n            temp.isWord = true;\\n        }\\n    }\\n    \\n    public boolean search(TrieNode temp, String word, int index, int curr) {\\n        int len = word.length();\\n        for (int i = index; i < len; i++) {\\n            if (temp.children[word.charAt(i)-\\'a\\'] == null) return false;\\n            temp = temp.children[word.charAt(i)-\\'a\\'];\\n            if (temp.isWord && search(root,word,i+1,curr+1)) return true;\\n        }\\n        return curr >= 1 && temp.isWord;\\n    }\\n}\\n\\nclass TrieNode {\\n    boolean isWord;\\n    TrieNode[] children;\\n    public TrieNode(){\\n        isWord = false;\\n        children = new TrieNode[26];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TrieNode root = new TrieNode();\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        build(words);\\n        for (String word : words)  \\n            if (search(root,word,0,0))\\n                res.add(word);\\n        return res;\\n    }\\n    \\n    public void build(String[] dict) {\\n        for (String word : dict) {\\n            if (word == null || word.length() == 0) continue;\\n            TrieNode temp = root;\\n            int len = word.length();\\n            for (int i = 0; i < len; i++) {\\n                char c = word.charAt(i);\\n                if (temp.children[c-\\'a\\'] == null) temp.children[c-\\'a\\'] = new TrieNode();\\n                temp = temp.children[c-\\'a\\'];\\n            }\\n            temp.isWord = true;\\n        }\\n    }\\n    \\n    public boolean search(TrieNode temp, String word, int index, int curr) {\\n        int len = word.length();\\n        for (int i = index; i < len; i++) {\\n            if (temp.children[word.charAt(i)-\\'a\\'] == null) return false;\\n            temp = temp.children[word.charAt(i)-\\'a\\'];\\n            if (temp.isWord && search(root,word,i+1,curr+1)) return true;\\n        }\\n        return curr >= 1 && temp.isWord;\\n    }\\n}\\n\\nclass TrieNode {\\n    boolean isWord;\\n    TrieNode[] children;\\n    public TrieNode(){\\n        isWord = false;\\n        children = new TrieNode[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541384,
                "title": "c-124ms-98-sorting-trie-memorisation",
                "content": "**New version : fixed for new cases. In old version I want to not use memorisation, but for NEW case of test I need to do it and I done it**\\nRuntime: 164 ms, faster than 97.29% of C++ online submissions for Concatenated Words.\\nMemory Usage: 242.3 MB, less than 49.85% of C++ online submissions for Concatenated Words.\\n```\\nclass Trie {\\npublic:\\n  struct Node{\\n    bool eow;\\n    Node* nb[26];\\n    Node(){eow = false; for(int i=0;i!=26;i++) nb[i] = NULL;}\\n  };\\n  Node *root;\\n\\n  Trie() {root = new Node(); root->eow = true;}\\n  \\n  void insert(string &word) {\\n    Node *tmp = root;\\n    \\n    for(int j = 0, idx ;j < word.size(); j++)\\n      if(tmp->nb[idx = word[j] - \\'a\\']) tmp = tmp->nb[idx];              //if this node present\\n      else                                                              //if not\\n        for(int idx; j != word.size(); j++, tmp = tmp->nb[idx])\\n          tmp->nb[idx = word[j] - \\'a\\'] = new Node();\\n\\n    tmp->eow = true;\\n  }\\n    \\n  bool is_concatenated(string &sample, int j, vector<int> &hash){       //check : is the sample concatenation of words from Trie ? \\n    Node *tmp = root;\\n    if(hash[j]) return false;                                                                        \\n    hash[j] = 1;\\n    for(int idx; j < sample.size(); j++){ \\n      if(tmp->nb[idx = sample[j] - \\'a\\']) tmp = tmp->nb[idx];              \\n      else return false;\\n      if(tmp->eow && (j + 1 == sample.size() || is_concatenated(sample, j + 1, hash)) ) return true; \\n    }\\n    return false;  \\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    sort(words.begin(), words.end(), [](string &a, string &b) -> bool{return a.size() < b.size();});\\n    Trie t;\\n    vector<string> answer;\\n    vector<int> hash;\\n    \\n    for(auto &w: words){\\n      hash.clear();                                                                            //hash for indexes\\n      hash.resize(w.size()+1, 0);                                                      //for next word\\n      if(t.is_concatenated(w,0,hash)) answer.push_back(w);\\n      else t.insert(w);\\n    }\\n    \\n    return answer;  \\n  }\\n};\\n```\\n\\n**Good day !!! FOR NEW CASE OF TEST IT HAVE TLE !!! I try to fix it !!!**\\nRuntime: 124 ms, faster than 98.20% of C++ online submissions for Concatenated Words.\\nMemory Usage: 241.7 MB, less than 63.26% of C++ online submissions for Concatenated Words.\\n**General idea:**\\n**1.** Sort our words from array from the smallest to the largest and will consider from the smallest\\n**2.** take our current word from array and check : is this word the concatenation of words or not ? if yes : put it into answer **AND NOT PUT INTO Trie** ; if not : add this word into Trie\\n**3.** I use my own realisation of Trie from https://leetcode.com/problems/implement-trie-prefix-tree/discuss/1110993/c%2B%2B(44ms-99)-classical-(with-comments)\\n```\\nclass Trie {\\npublic:\\n  struct Node{\\n    bool eow;\\n    Node* nb[26];\\n    Node(){eow = false; for(int i=0;i!=26;i++) nb[i] = NULL;}\\n  };\\n  Node *root;\\n\\n  Trie() {root = new Node(); root->eow = true;}\\n  \\n  void insert(string &word) {\\n    Node *tmp = root;\\n    \\n    for(int j = 0, idx ;j < word.size(); j++)\\n      if(tmp->nb[idx = word[j] - \\'a\\']) tmp = tmp->nb[idx];              //if this node present\\n      else                                                              //if not\\n        for(int idx; j != word.size(); j++, tmp = tmp->nb[idx])\\n          tmp->nb[idx = word[j] - \\'a\\'] = new Node();\\n\\n    tmp->eow = true;\\n  }\\n    \\n  bool is_concatenated(string &sample, int j){        //check : is the sample concatenation of words from Trie ? \\n    Node *tmp = root;\\n    for(int idx; j < sample.size(); j++){\\n      if(tmp->nb[idx = sample[j] - \\'a\\']) tmp = tmp->nb[idx];              \\n      else return false;\\n      if(tmp->eow && (j + 1 == sample.size() || is_concatenated(sample, j + 1)) ) return true; \\n    }\\n    return false;  \\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    sort(words.begin(), words.end(), [](string &a, string &b) -> bool{return a.size() < b.size();});\\n    Trie t;\\n    vector<string> answer;\\n    \\n    for(auto &w: words)\\n      if(t.is_concatenated(w,0)) answer.push_back(w);\\n      else t.insert(w);\\n    \\n    return answer;  \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Trie {\\npublic:\\n  struct Node{\\n    bool eow;\\n    Node* nb[26];\\n    Node(){eow = false; for(int i=0;i!=26;i++) nb[i] = NULL;}\\n  };\\n  Node *root;\\n\\n  Trie() {root = new Node(); root->eow = true;}\\n  \\n  void insert(string &word) {\\n    Node *tmp = root;\\n    \\n    for(int j = 0, idx ;j < word.size(); j++)\\n      if(tmp->nb[idx = word[j] - \\'a\\']) tmp = tmp->nb[idx];              //if this node present\\n      else                                                              //if not\\n        for(int idx; j != word.size(); j++, tmp = tmp->nb[idx])\\n          tmp->nb[idx = word[j] - \\'a\\'] = new Node();\\n\\n    tmp->eow = true;\\n  }\\n    \\n  bool is_concatenated(string &sample, int j, vector<int> &hash){       //check : is the sample concatenation of words from Trie ? \\n    Node *tmp = root;\\n    if(hash[j]) return false;                                                                        \\n    hash[j] = 1;\\n    for(int idx; j < sample.size(); j++){ \\n      if(tmp->nb[idx = sample[j] - \\'a\\']) tmp = tmp->nb[idx];              \\n      else return false;\\n      if(tmp->eow && (j + 1 == sample.size() || is_concatenated(sample, j + 1, hash)) ) return true; \\n    }\\n    return false;  \\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    sort(words.begin(), words.end(), [](string &a, string &b) -> bool{return a.size() < b.size();});\\n    Trie t;\\n    vector<string> answer;\\n    vector<int> hash;\\n    \\n    for(auto &w: words){\\n      hash.clear();                                                                            //hash for indexes\\n      hash.resize(w.size()+1, 0);                                                      //for next word\\n      if(t.is_concatenated(w,0,hash)) answer.push_back(w);\\n      else t.insert(w);\\n    }\\n    \\n    return answer;  \\n  }\\n};\\n```\n```\\nclass Trie {\\npublic:\\n  struct Node{\\n    bool eow;\\n    Node* nb[26];\\n    Node(){eow = false; for(int i=0;i!=26;i++) nb[i] = NULL;}\\n  };\\n  Node *root;\\n\\n  Trie() {root = new Node(); root->eow = true;}\\n  \\n  void insert(string &word) {\\n    Node *tmp = root;\\n    \\n    for(int j = 0, idx ;j < word.size(); j++)\\n      if(tmp->nb[idx = word[j] - \\'a\\']) tmp = tmp->nb[idx];              //if this node present\\n      else                                                              //if not\\n        for(int idx; j != word.size(); j++, tmp = tmp->nb[idx])\\n          tmp->nb[idx = word[j] - \\'a\\'] = new Node();\\n\\n    tmp->eow = true;\\n  }\\n    \\n  bool is_concatenated(string &sample, int j){        //check : is the sample concatenation of words from Trie ? \\n    Node *tmp = root;\\n    for(int idx; j < sample.size(); j++){\\n      if(tmp->nb[idx = sample[j] - \\'a\\']) tmp = tmp->nb[idx];              \\n      else return false;\\n      if(tmp->eow && (j + 1 == sample.size() || is_concatenated(sample, j + 1)) ) return true; \\n    }\\n    return false;  \\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    sort(words.begin(), words.end(), [](string &a, string &b) -> bool{return a.size() < b.size();});\\n    Trie t;\\n    vector<string> answer;\\n    \\n    for(auto &w: words)\\n      if(t.is_concatenated(w,0)) answer.push_back(w);\\n      else t.insert(w);\\n    \\n    return answer;  \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563969,
                "title": "c-200ms-straightforward-trie-dfs-solution-without-dp",
                "content": "```\\nclass Solution {\\nprivate:\\n    struct Trie\\n    {\\n        vector<Trie*> children{26};\\n        bool end{false};\\n    };\\n    \\n    Trie* root;\\n    \\n    void insert(string& s)\\n    {\\n        if (s.empty()) return;\\n        Trie* cur = root;\\n        for (char c:s)\\n        {\\n            if (cur->children[c-\\'a\\'] == nullptr)\\n                cur->children[c-\\'a\\'] = new Trie();\\n            cur = cur->children[c-\\'a\\'];\\n        }\\n        cur->end = true;\\n    }\\n    \\n    bool dfs(Trie* root, Trie* node, string& word, int idx, int count)\\n    {\\n        if (!node)\\n            return false;\\n        \\n        if (idx >= word.size())\\n        {\\n            if (node->end && count >=1 )\\n                return true;\\n            else\\n                return false;\\n        }\\n        \\n        if (node->end && dfs(root, root, word, idx, count+1))\\n            return true;\\n        return dfs(root, node->children[word[idx]-\\'a\\'], word, idx+1, count);\\n    }\\n    \\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string& w1, const string& w2) {\\n            return w1.size() < w2.size();\\n        });\\n        \\n        vector<string> ret;\\n        root = new Trie();\\n        \\n        for(auto &w: words)\\n        {\\n            if (w.empty()) continue;\\n            if(dfs(root, root, w, 0, 0)) \\n                ret.push_back(w);\\n            else \\n                insert(w);\\n        }\\n    \\n        return ret;\\n    }\\n};\\n```\\n\\nThe keys to pass the unit tests.\\n1) sort words.\\n2) only build trie with un-concatenated words.\\n3) handle empty string.",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct Trie\\n    {\\n        vector<Trie*> children{26};\\n        bool end{false};\\n    };\\n    \\n    Trie* root;\\n    \\n    void insert(string& s)\\n    {\\n        if (s.empty()) return;\\n        Trie* cur = root;\\n        for (char c:s)\\n        {\\n            if (cur->children[c-\\'a\\'] == nullptr)\\n                cur->children[c-\\'a\\'] = new Trie();\\n            cur = cur->children[c-\\'a\\'];\\n        }\\n        cur->end = true;\\n    }\\n    \\n    bool dfs(Trie* root, Trie* node, string& word, int idx, int count)\\n    {\\n        if (!node)\\n            return false;\\n        \\n        if (idx >= word.size())\\n        {\\n            if (node->end && count >=1 )\\n                return true;\\n            else\\n                return false;\\n        }\\n        \\n        if (node->end && dfs(root, root, word, idx, count+1))\\n            return true;\\n        return dfs(root, node->children[word[idx]-\\'a\\'], word, idx+1, count);\\n    }\\n    \\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string& w1, const string& w2) {\\n            return w1.size() < w2.size();\\n        });\\n        \\n        vector<string> ret;\\n        root = new Trie();\\n        \\n        for(auto &w: words)\\n        {\\n            if (w.empty()) continue;\\n            if(dfs(root, root, w, 0, 0)) \\n                ret.push_back(w);\\n            else \\n                insert(w);\\n        }\\n    \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302956,
                "title": "c-simple-c-code-no-trie-73-time-78-space",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    unordered_map<string, int> um;\\n    vector<string> ans;\\n    bool dfs(string &str, int i)\\n    {\\n        if(i == str.size())\\n        {\\n            return true;\\n        }\\n        string tmp = \"\";\\n        for(int j = i; j < str.size(); j++)\\n        {\\n            tmp += str[j];\\n            if(j == str.size()-1 && i == 0)\\n                return false;\\n            else if(um.count(tmp))\\n            {\\n                if(dfs(str, j+1)) return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for(string &str : words)\\n            um[str]++;\\n        for(string &str : words)\\n        {\\n            if(dfs(str, 0))\\n                ans.push_back(str);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string, int> um;\\n    vector<string> ans;\\n    bool dfs(string &str, int i)\\n    {\\n        if(i == str.size())\\n        {\\n            return true;\\n        }\\n        string tmp = \"\";\\n        for(int j = i; j < str.size(); j++)\\n        {\\n            tmp += str[j];\\n            if(j == str.size()-1 && i == 0)\\n                return false;\\n            else if(um.count(tmp))\\n            {\\n                if(dfs(str, j+1)) return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for(string &str : words)\\n            um[str]++;\\n        for(string &str : words)\\n        {\\n            if(dfs(str, 0))\\n                ans.push_back(str);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027384,
                "title": "python-fast-simple-top-down-dynamic-programming",
                "content": "```python\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        wordset = set(words)\\n        @cache\\n        def iscat(word):\\n            for i in range(1, len(word)):\\n                if word[:i] in wordset and (word[i:] in wordset or iscat(word[i:])):\\n                    return True\\n            return False\\n        \\n        return [word for word in words if iscat(word)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        wordset = set(words)\\n        @cache\\n        def iscat(word):\\n            for i in range(1, len(word)):\\n                if word[:i] in wordset and (word[i:] in wordset or iscat(word[i:])):\\n                    return True\\n            return False\\n        \\n        return [word for word in words if iscat(word)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398049,
                "title": "java-dp-trie-75ms",
                "content": "Step 1: created Trie from words\\nStep 2: check each word\\n\\tdp[i]: number of concatenated words  for substring of word[i, word.length() - 1]\\n\\tfor each index i at each word, check the second part of word[i, n -1] is a word.\\n\\tdp[i] >= 2 means it can be concatenated from two words \\n\\t\\nTime complexity: O(m * n^2).   Geneate Trie. O(m * n). dp check each word O(n^2). m loops\\nSpace complexity: O(m * n*).   O(m*n) for Trie and O(n) for dp\\n\\nm: words.length\\nn: maximum word length\\n```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        TrieNode root = new TrieNode();\\n\\t\\t//put each word in the Trie\\n        for(String word : words) {\\n            insertWord(root, word);\\n        }\\n        List<String> result = new ArrayList<>();\\n\\t\\t//check each word\\n        for (String word : words) {\\n            if (isConcatenated(word, root)){\\n                result.add(word);\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isConcatenated(String word, TrieNode root) {\\n        int[] dp = new int[word.length() + 1];\\n        dp[word.length()] = 0;\\n        for (int i = word.length() - 1; i >= 0; i--) {\\n            TrieNode cur = root;\\n            dp[i] = -1;\\n\\t\\t\\t//check word substring from right to left\\n            for (int j = i; j < word.length(); j++) {\\n                cur = cur.children[word.charAt(j) - \\'a\\'];\\n                if (cur == null) {\\n                    break;\\n                }\\n\\t\\t\\t\\t//if prefix does not exist, no need to check further\\n                if (cur.isWord && dp[j + 1] != -1) {\\n                    dp[i] = dp[j + 1] + 1;\\n                    if (dp[i] >= 2) {\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t//once found it can be composed by two words, break\\n                }\\n            }\\n        }\\n        return dp[0] >= 2;\\n    }\\n    private void insertWord(TrieNode root, String word) {\\n        TrieNode cur = root;\\n        for (char c : word.toCharArray()) {\\n            TrieNode next = cur.children[c - \\'a\\'];\\n            if (next == null) {\\n                next = new TrieNode();\\n                cur.children[c - \\'a\\'] = next;\\n            }\\n            cur = next;\\n        }\\n        cur.isWord = true;\\n    }\\n    private class TrieNode {\\n        TrieNode[] children = new TrieNode[26];\\n        boolean isWord = false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        TrieNode root = new TrieNode();\\n\\t\\t//put each word in the Trie\\n        for(String word : words) {\\n            insertWord(root, word);\\n        }\\n        List<String> result = new ArrayList<>();\\n\\t\\t//check each word\\n        for (String word : words) {\\n            if (isConcatenated(word, root)){\\n                result.add(word);\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isConcatenated(String word, TrieNode root) {\\n        int[] dp = new int[word.length() + 1];\\n        dp[word.length()] = 0;\\n        for (int i = word.length() - 1; i >= 0; i--) {\\n            TrieNode cur = root;\\n            dp[i] = -1;\\n\\t\\t\\t//check word substring from right to left\\n            for (int j = i; j < word.length(); j++) {\\n                cur = cur.children[word.charAt(j) - \\'a\\'];\\n                if (cur == null) {\\n                    break;\\n                }\\n\\t\\t\\t\\t//if prefix does not exist, no need to check further\\n                if (cur.isWord && dp[j + 1] != -1) {\\n                    dp[i] = dp[j + 1] + 1;\\n                    if (dp[i] >= 2) {\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t//once found it can be composed by two words, break\\n                }\\n            }\\n        }\\n        return dp[0] >= 2;\\n    }\\n    private void insertWord(TrieNode root, String word) {\\n        TrieNode cur = root;\\n        for (char c : word.toCharArray()) {\\n            TrieNode next = cur.children[c - \\'a\\'];\\n            if (next == null) {\\n                next = new TrieNode();\\n                cur.children[c - \\'a\\'] = next;\\n            }\\n            cur = next;\\n        }\\n        cur.isWord = true;\\n    }\\n    private class TrieNode {\\n        TrieNode[] children = new TrieNode[26];\\n        boolean isWord = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238759,
                "title": "472-concatenated-words-analysis",
                "content": "<h2>Concatenated Words</h2>\\nGiven a list of words (<b>without duplicates</b>), please write a program that returns all concatenated words in the given list of words.\\nA concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\\n\\n**Example**\\n<pre><strong>Input:</strong> [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\\n<strong>Output: </strong>[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\\n<strong>Explanation: </strong> \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \\n \"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \\n\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\\n</pre>\\n\\n<h2 id=\"solution\">Solution</h2>\\n<hr>\\n<h4>Approach 1: Dynamic Programming</h4>\\n<strong>Intuition and Algorithm</strong>\\n<p>\\nA concatenated word  must be formed by 2 or more shorter words. We will iterate through each word and see if this is a <code>concatenated word</code>.\\n</p>\\n<p>\\nLet\\'s try for a dynamic programming (DP) solution.\\nGiven the input\\n\\n<code>Words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]</code>\\nWe are going to check, for example, if the word <code>W = ratcatdogcat</code>  is concatenated.\\nGiven a prefix of size <code>K</code> of the word <code>W</code>, <code>dp[k]</code> returns a boolean if this prefix can be formed by other words in the dictionary. We have:\\n</p>\\n\\n* <code>dp[0] = True,</code> (empy string) base case\\n* <code>dp[1] = False,</code> prefix <code>\"r\"  </code> is not formed by other words \\n* <code>dp[2] = False,</code> prefix <code>\"ra\"  </code> is not formed by other words\\n* <code>dp[3] = True,</code> prefix <code>\"rat\" </code> exists in W (dictionary)\\n* <code>dp[4] = False,</code> prefix <code>\"ratc\" </code> is not formed by other words\\n* <code>dp[5] = False,</code> prefix <code>\"ratca\"  </code> is not formed by other words \\n* <code>dp[6] = False,</code> prefix <code>\"ratcat\"  </code> Its formed by 2 words in W <code>rat + cat</code>\\n* <code>dp[7] = dp[8] =False,</code> \\n* <code>dp[9] = True,</code> prefix <code>\"ratcatdog\"  </code> Its formed by 3 words in W <code>rat + cat +dog</code>\\n* <code>dp[10] = dp[11] =False,</code> \\n* <code>dp[12] = True,</code> prefix <code>\"ratcatdogcat\"  </code> Its formed by 4 words in W <code>rat + cat +dog + cat</code> (It\\'s allowed to repeat a word as <code>cat</code>).\\n\\nA word is concatenated if <code>dp[N] is true </code> where N is the size of W.\\n<code>\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\n\\t\\tvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\tunordered_set<string>dict(words.begin(),words.end());\\n\\t\\t\\t\\t\\n\\t\\t\\tfor(auto w : words){\\n\\t\\t\\t\\tint n = w.size();\\n\\t\\t\\t\\tif(n == 0) continue;\\n\\t\\t\\t\\tbool dp[n+1];\\n\\t\\t\\t\\tmemset(dp,false,sizeof(dp));\\n\\t\\t\\t\\tdp[0] = true;\\n\\t\\t\\t\\n\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\tif(dp[i] == false) continue;\\n\\t\\t\\t\\t\\tstring generate=\"\";\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfor(int j=i; j<n; j++){\\n\\t\\t\\t\\t\\t\\tgenerate += w[j];\\n\\t\\t\\t\\t\\t\\tif(dp[j+1])continue;\\n\\t\\t\\t\\t\\t\\tif(i==0 && j==n-1)continue;\\n\\t\\t\\t\\t\\t\\tif(dict.find(generate) != dict.end())\\n\\t\\t\\t\\t\\t\\t\\tdp[j+1]=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif(dp[n]){\\n\\t\\t\\t\\t\\t\\tans.push_back(w);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}    \\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n</code>\\n\\n<b>Complexity time </b>\\n* O(m * n^3) where m is the length of words and n is the average length of words.\\n  \\nBecause of our improvements, the complexity analysis corresponds to the worst case.\\n\\n<h4>Approach 2: Trie + Dynamic Programming</h4>\\n<strong> Algorithm</strong>\\n<p>\\nFrom the previous algorithm, in this line,  <code>if(dict.find(generate) != dict.end()) </code>. We check if a substring is a word in the dictionary using <code> unordered_set</code>. We could improved it using <b>Trie</b> in constant time.\\n</p>\\n\\n<i>\\nThe improvement is not significant, due to the additional memory used to create the Trie, in addition to the weak test cases..\\n</i>\\n\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\t\\n\\t\\tstruct TrieNode { \\n\\t\\t\\tTrieNode *children[26];\\n\\t\\t\\tbool isTerminal; \\n\\t\\t}; \\n\\t\\n\\t\\tstruct TrieNode *getNode(void){ \\n\\t\\t\\tTrieNode *p = new TrieNode; \\n\\t\\t\\tp->isTerminal = false; \\n\\t\\t\\tfor (int i = 0; i < 26; i++) \\n\\t\\t\\t\\tp->children[i] = NULL;\\n\\t\\t\\treturn p; \\n\\t\\t} \\n\\t\\t\\n\\t\\tvoid add(TrieNode *p, string w){ \\n\\t\\t\\tint n = w.size(); \\n\\t\\n\\t\\t\\tfor (int i = 0; i < n; i++) { \\n\\t\\t\\t\\tint index = w[i]-\\'a\\'; \\n\\t\\t\\t\\tif (!p->children[index]) \\n\\t\\t\\t\\t\\tp->children[index] = getNode(); \\n\\t\\t\\t\\tp = p->children[index]; \\n\\t\\t\\t}\\n\\t\\n\\t\\t\\tp->isTerminal = true; \\n\\t\\t} \\n\\t\\t\\n\\t\\tvector<string> findAllConcatenatedWordsInADict(vector<string>& words){\\n\\t\\t\\tTrieNode *root = getNode();\\n\\t\\t\\t\\n\\t\\t\\tfor (int i = 0; i < words.size(); i++) \\n\\t\\t\\t\\tadd(root, words[i]);\\n\\t\\t\\t\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tfor(auto w : words){\\n\\t\\t\\t\\tint n = w.size();\\n\\t\\t\\t\\tif(n == 0) continue;\\n\\t\\t\\t\\tbool dp[n+1];\\n\\t\\t\\t\\tmemset(dp,false,sizeof(dp));\\n\\t\\t\\t\\tdp[0] = true;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\tif(dp[i] == false) continue;\\n\\t\\t\\t\\t\\tTrieNode *p = root;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfor(int j=i;j<n;j++){\\n\\t\\t\\t\\t\\t\\tif (!p->children[w[j]-\\'a\\'])break;\\n\\t\\t\\t\\t\\t\\tp = p->children[w[j]-\\'a\\'];\\n\\t\\t\\t\\t\\t\\tif(i==0 && j==n-1)continue;\\n\\t\\t\\t\\t\\t\\tif(p->isTerminal)\\n\\t\\t\\t\\t\\t\\t\\tdp[j+1]=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif(dp[n]){\\n\\t\\t\\t\\t\\t\\tans.push_back(w);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n</code>\\n\\n<b>Complexity time </b>\\n\\n* O(m * n^2 + K*26) where <code>m</code> is the length of words ,<code> n</code> is the average length of words and <code>K</code> is the number of nodes in the trie.\\n  \\n The second term represents Trie construction, 26 is the  alphabet size.  \\nBecause of our improvements, the complexity analysis corresponds to the worst case.\\n\\nAnother implementation, without pointers, (number of nodes in the Trie is setted in <code>50000</code> because of weak cases.  \\n\\n<code>\\n\\n\\tint trie[50000][26];\\n\\tbool terminal[50000];\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint node;\\n\\t\\t\\n\\t\\tvoid add(string s){\\n\\t\\t\\tint tam = s.size();\\n\\t\\t\\tint p = 0;    \\n\\t\\t\\tfor(int i=0;i<tam;i++){\\n\\t\\t\\t\\tif(trie[p][s[i]-\\'a\\'] != 0){\\n\\t\\t\\t\\t\\tp = trie[p][s[i]-\\'a\\'];\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tp = trie[p][s[i]-\\'a\\'] = node++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tterminal[p]= true;\\n\\t\\t}\\n\\t\\t\\n\\t\\tvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n\\t\\t\\tnode = 1;\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\tmemset(trie,0,sizeof(trie));\\n\\t\\t\\tmemset(terminal,false,sizeof(terminal));\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<words.size();i++)\\n\\t\\t\\t\\tadd(words[i]);\\n\\t\\t\\t\\n\\t\\t\\tfor(auto w : words){\\n\\t\\t\\t\\tint n = w.size();\\n\\t\\t\\t\\tif(n == 0) continue;\\n\\t\\t\\t\\tbool dp[n+1];\\n\\t\\t\\t\\tmemset(dp,false,sizeof(dp));\\n\\t\\t\\t\\tdp[0] = true;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\tif(dp[i] == false) continue;\\n\\t\\t\\t\\t\\tint index = 0;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfor(int j=i;j<n;j++){\\n\\t\\t\\t\\t\\t\\tindex = trie[index][w[j]-\\'a\\'];\\n\\t\\t\\t\\t\\t\\tif(index == 0)break;\\n\\t\\t\\t\\t\\t\\tif(i==0 && j==n-1)continue;\\n\\t\\t\\t\\t\\t\\tif(terminal[index])\\n\\t\\t\\t\\t\\t\\t\\tdp[j+1]=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif(dp[n]){\\n\\t\\t\\t\\t\\t\\tans.push_back(w);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}    \\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n</code>\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\n\\t\\tvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\tunordered_set<string>dict(words.begin(),words.end());\\n\\t\\t\\t\\t\\n\\t\\t\\tfor(auto w : words){\\n\\t\\t\\t\\tint n = w.size();\\n\\t\\t\\t\\tif(n == 0) continue;\\n\\t\\t\\t\\tbool dp[n+1];\\n\\t\\t\\t\\tmemset(dp,false,sizeof(dp));\\n\\t\\t\\t\\tdp[0] = true;\\n\\t\\t\\t\\n\\t\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\t\\tif(dp[i] == false) continue;\\n\\t\\t\\t\\t\\tstring generate=\"\";\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfor(int j=i; j<n; j++){\\n\\t\\t\\t\\t\\t\\tgenerate += w[j];\\n\\t\\t\\t\\t\\t\\tif(dp[j+1])continue;\\n\\t\\t\\t\\t\\t\\tif(i==0 && j==n-1)continue;\\n\\t\\t\\t\\t\\t\\tif(dict.find(generate) != dict.end())\\n\\t\\t\\t\\t\\t\\t\\tdp[j+1]=true;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3107037,
                "title": "c-template-for-word-break-i-ii-concatenated-words-all-u-need",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition for all the problems:\\nAll the three given problems  can be divided into sub-problems .And  If these subproblems individually satisfy the required conditions, then  complete problem will also satisfy the same. And hence we can say whether it is true to find the word in the dictionary or not.\\n\\n# Approach\\n- **Naive Approach**: Use recursion and backtracking. For finding the solution, we check every prefix of the string in the word_dict of words, if it is found , then the recursive function is called for the remaining portion of that string. But this will be$$ 2^n$$ so will give tle . SO we can optimize using memoization or dp.\\n- **DP**: So as we can see that in recurion we call for evrery prefix substring and check if its presnt and like this the we check the whole is present or not .So similarly we can store the same ,like upto certain index whether the substring upto that index is present or not . In this way our dp array will be filled with 0\\'s and 1\\'s representing whether the substring upto that index is present or not . And at last if last index is true i.e dp[n] is true this means whole string is presnt .\\n- So applying this logic we can do all the three problems with a little modification based on requirements.\\n<!-- Describe your approach to solving the problem. -->\\n# **For Word Break I**\\n\\n# Code\\n\\n```\\n bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **For Word Break II**\\n```\\nvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n    \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);  \\n                    }\\n                }\\n            }\\n        }\\n         return dp[n];\\n    }\\n```\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# **For concatenated Words**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:$$O(N*W^3)$$\\n    - where `N=word.length and W = words[i].length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N*W)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\n```\\nvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n    \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);  \\n                    }\\n                }\\n            }\\n        }\\n         return dp[n];\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103552,
                "title": "simple-dfs-no-trie-no-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(set<string>&st, string& word, int start)\\n    {\\n        if (start >= word.size()) return 0;\\n\\n        string strTillPivot = \"\";\\n        int mx = INT_MIN;\\n        for (int pivotIdx = start; pivotIdx < word.size(); pivotIdx++)\\n        {\\n            strTillPivot.push_back(word[pivotIdx]);\\n            if (st.find(strTillPivot) == st.end()) continue;\\n            \\n            int nextPartitionCount = solve(st, word, pivotIdx + 1);\\n            if (nextPartitionCount == INT_MIN) continue;\\n\\t\\t\\t//INT_MIN defines that the nextString cannot form a valid partition\\n\\t\\t\\t\\n            int totalPartitions = 1 + nextPartitionCount;\\n            mx = max(mx, totalPartitions);\\n        }\\n        return mx;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) \\n    {\\n        set<string>st;\\n        for (string& word : words) st.insert(word);\\n        vector<string>ans;\\n        for (string word : words)\\n        {\\n            int partitionCount = solve(st, word, 0);\\n            if (partitionCount >= 2) ans.push_back(word); //If we can partition the word in >=2 parts\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(set<string>&st, string& word, int start)\\n    {\\n        if (start >= word.size()) return 0;\\n\\n        string strTillPivot = \"\";\\n        int mx = INT_MIN;\\n        for (int pivotIdx = start; pivotIdx < word.size(); pivotIdx++)\\n        {\\n            strTillPivot.push_back(word[pivotIdx]);\\n            if (st.find(strTillPivot) == st.end()) continue;\\n            \\n            int nextPartitionCount = solve(st, word, pivotIdx + 1);\\n            if (nextPartitionCount == INT_MIN) continue;\\n\\t\\t\\t//INT_MIN defines that the nextString cannot form a valid partition\\n\\t\\t\\t\\n            int totalPartitions = 1 + nextPartitionCount;\\n            mx = max(mx, totalPartitions);\\n        }\\n        return mx;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) \\n    {\\n        set<string>st;\\n        for (string& word : words) st.insert(word);\\n        vector<string>ans;\\n        for (string word : words)\\n        {\\n            int partitionCount = solve(st, word, 0);\\n            if (partitionCount >= 2) ans.push_back(word); //If we can partition the word in >=2 parts\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103524,
                "title": "javascript-98-11-fast-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/LRhVY83R9cI\\n\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar findAllConcatenatedWordsInADict = function(words) {\\n    const set = new Set(words);\\n    let res = []\\n\\n    let isValid = (word) =>{\\n        if(word.length == 0) return true;\\n        for(let i =1; i<=word.length;i++){\\n            let value = word.slice(0,i);\\n            if(set.has(value)){\\n                let check = isValid(word.slice(i))\\n                if(check) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    for(let word of words){\\n        set.delete(word);\\n        if(isValid(word)) res.push(word)\\n        set.add(word)\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar findAllConcatenatedWordsInADict = function(words) {\\n    const set = new Set(words);\\n    let res = []\\n\\n    let isValid = (word) =>{\\n        if(word.length == 0) return true;\\n        for(let i =1; i<=word.length;i++){\\n            let value = word.slice(0,i);\\n            if(set.has(value)){\\n                let check = isValid(word.slice(i))\\n                if(check) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    for(let word of words){\\n        set.delete(word);\\n        if(isValid(word)) res.push(word)\\n        set.add(word)\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1058190,
                "title": "python-14-line-dp-with-inline-explanation",
                "content": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        \\n        wordSet = set(words)\\n        ans = []\\n        # 1) For each word w, For loop w[:i] \\n        # 2) check if the front segment[0:j] is in wordSet and if the [j+1: i] is in the wordset\\n        # EDGE CASE: cats is in wordSet but not concatenated, catsdog is in wordSet but also concatenated\\n        # SOLUTION to edge case: instead of storing True/False, store the concatenated time, base is 1, and 2 means it is\\n        # concatenated with \"\" + word, which is the word itself\\n        # 3) If yes:w[:i] is concatenated=> dp[-1] > 2, append to ans, BREAK(to pass the edge case full of \"a\")\\n        \\n        for i, w in enumerate(words):\\n            dp = [0] * (len(w) + 1)\\n            dp[0] = 1\\n            for i in range(1, len(w) + 1):\\n                for j in range(i):\\n                    if dp[j] and w[j: i] in wordSet:\\n                        dp[i] = max(dp[i], dp[j] + 1)\\n                        if dp[i] > 2:\\n                            break\\n            if dp[-1] > 2:\\n                ans.append(w)\\n        return ans\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        \\n        wordSet = set(words)\\n        ans = []\\n        # 1) For each word w, For loop w[:i] \\n        # 2) check if the front segment[0:j] is in wordSet and if the [j+1: i] is in the wordset\\n        # EDGE CASE: cats is in wordSet but not concatenated, catsdog is in wordSet but also concatenated\\n        # SOLUTION to edge case: instead of storing True/False, store the concatenated time, base is 1, and 2 means it is\\n        # concatenated with \"\" + word, which is the word itself\\n        # 3) If yes:w[:i] is concatenated=> dp[-1] > 2, append to ans, BREAK(to pass the edge case full of \"a\")\\n        \\n        for i, w in enumerate(words):\\n            dp = [0] * (len(w) + 1)\\n            dp[0] = 1\\n            for i in range(1, len(w) + 1):\\n                for j in range(i):\\n                    if dp[j] and w[j: i] in wordSet:\\n                        dp[i] = max(dp[i], dp[j] + 1)\\n                        if dp[i] > 2:\\n                            break\\n            if dp[-1] > 2:\\n                ans.append(w)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105763,
                "title": "c-very-simple-dp-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is to check if a word  can be constructed by the concatenation of other words in the set. Actually first fill all the word in aset that is a perfect data structure to check if a word s present or not . \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo here we have to check for substring of a word is presnt or not if starting substring is not present then no need to get further if presnt then we add up and atlast check if dp[n] is true or not ,if yes then we push the word in ans vector. \\nActually DP array will track the  substring  upto some index is present or not and at n the index if it is true in dp array then whole word is found and then we push_back that word.\\n# Complexity\\n- Time complexity:$$O(N*W^3)$$\\n  - where N=words.length() and W=words[i].length()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N*W)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104076,
                "title": "c-easy-solution-with-explanation",
                "content": "# Intuition\\nYou don\\'t need to find all the words you just need to check whether the words are made or not , so simply check for the word form (i to j) and then call the check for j + 1;\\n\\n# Approach\\nWhat Function findWord is doing ?\\nIt makes a word from i till j where there is word , \\neg : [cat , catanddog , and , dog]\\nAt catanddog\\nc -> not found\\n     ca -> not found\\n     cat call for(anddog)-> found then it checks whether there exist a word from after cat and calls for it and before that it increses the count for word and if not found then it decrements the word count.\\n\\nSimilarly it\\'ll check for all the words and call for the next part of the string and check for words in it.\\n\\n# Complexity\\n- Time Complexity : O(words.size() + (words[i].size() * log(words[i].size()))\\n\\n- Space Complexity : O(words.size())\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findWord(set<string>& mp , int i , string & str , int &cnt){\\n        if(i >= str.size() ){\\n            return true;\\n        }\\n        string temp = \"\";\\n        for(int j = i ; j < str.size() ; j++){\\n            temp += str[j];\\n            if(mp.find(temp) != mp.end()){\\n                //cout<<temp<<\" : sub\\\\n\";\\n                cnt++;\\n                if(findWord(mp , j + 1 , str , cnt)){\\n                    return true;\\n                }\\n                cnt--;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& wd) {\\n        int n = wd.size();\\n        set<string> words;\\n        vector<string> ans;\\n        for(auto it : wd){\\n            words.insert(it);\\n        }\\n        int cnt = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            string str = wd[i];\\n            int cnt = 0;\\n            if(findWord(words , 0 , str , cnt) && cnt >= 2){\\n                ans.push_back(str);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findWord(set<string>& mp , int i , string & str , int &cnt){\\n        if(i >= str.size() ){\\n            return true;\\n        }\\n        string temp = \"\";\\n        for(int j = i ; j < str.size() ; j++){\\n            temp += str[j];\\n            if(mp.find(temp) != mp.end()){\\n                //cout<<temp<<\" : sub\\\\n\";\\n                cnt++;\\n                if(findWord(mp , j + 1 , str , cnt)){\\n                    return true;\\n                }\\n                cnt--;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& wd) {\\n        int n = wd.size();\\n        set<string> words;\\n        vector<string> ans;\\n        for(auto it : wd){\\n            words.insert(it);\\n        }\\n        int cnt = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            string str = wd[i];\\n            int cnt = 0;\\n            if(findWord(words , 0 , str , cnt) && cnt >= 2){\\n                ans.push_back(str);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3103713,
                "title": "java-easy-understaing-using-recursion-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String>al=new ArrayList<>();\\n        Set<String>hs=new HashSet<>();\\n        for(String i:words) hs.add(i);\\n        Map<String,Integer>hm=new HashMap<>();\\n        for(String i:words) if(check(i,hs,hm)) al.add(i);\\n        return al;\\n    }\\n    public static boolean check(String i,Set<String>hs,Map<String,Integer>hm){\\n        if(hm.containsKey(i)) return hm.get(i)==1;\\n        for(int z=0;z<i.length();z++){\\n            if(hs.contains(i.substring(0,z))){\\n                String s1=i.substring(z);\\n                if(hs.contains(s1)||check(s1,hs,hm)){\\n                    hm.put(i,1);\\n                    return true;\\n                }\\n            }\\n        }\\n        hm.put(i,0);\\n        return false;\\n    }\\n}\\n```\\nUPVOTE IF U LIKE THE APPROACH",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String>al=new ArrayList<>();\\n        Set<String>hs=new HashSet<>();\\n        for(String i:words) hs.add(i);\\n        Map<String,Integer>hm=new HashMap<>();\\n        for(String i:words) if(check(i,hs,hm)) al.add(i);\\n        return al;\\n    }\\n    public static boolean check(String i,Set<String>hs,Map<String,Integer>hm){\\n        if(hm.containsKey(i)) return hm.get(i)==1;\\n        for(int z=0;z<i.length();z++){\\n            if(hs.contains(i.substring(0,z))){\\n                String s1=i.substring(z);\\n                if(hs.contains(s1)||check(s1,hs,hm)){\\n                    hm.put(i,1);\\n                    return true;\\n                }\\n            }\\n        }\\n        hm.put(i,0);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189673,
                "title": "python3-trie-with-recursion-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nWe create a trie data structure from all given words. Then we iterate over the characters of every word. When we see that a current prefix is in the trie, we call a recursive function asking whether the slice of the word starting after the prefix is a concatenated word.\\n\\nTime: **O(n)**\\nSpace: **O(n)**\\n\\n```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        ddic = lambda: defaultdict(ddic)\\n        trie = ddic()\\n        \\n        for word in words:\\n            cur = trie\\n            for char in word:\\n                cur = cur[char]\\n\\n            cur[\\'end\\'] = True\\n        \\n        def isConcat(word, start):\\n            cur = trie\\n            for i in range(start, len(word)):\\n                char = word[i]\\n                if char not in cur:\\n                    return False\\n                cur = cur[char]\\n\\n                if \\'end\\' in cur:\\n                    if i + 1 == len(word):\\n                        # tricky part that helps us distinguish simple word from concat word\\n                        return start != 0\\n                    \\n                    if isConcat(word, i + 1):\\n                        return True\\n\\n            return False\\n            \\n        return [word for word in words if isConcat(word, 0)]\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        ddic = lambda: defaultdict(ddic)\\n        trie = ddic()\\n        \\n        for word in words:\\n            cur = trie\\n            for char in word:\\n                cur = cur[char]\\n\\n            cur[\\'end\\'] = True\\n        \\n        def isConcat(word, start):\\n            cur = trie\\n            for i in range(start, len(word)):\\n                char = word[i]\\n                if char not in cur:\\n                    return False\\n                cur = cur[char]\\n\\n                if \\'end\\' in cur:\\n                    if i + 1 == len(word):\\n                        # tricky part that helps us distinguish simple word from concat word\\n                        return start != 0\\n                    \\n                    if isConcat(word, i + 1):\\n                        return True\\n\\n            return False\\n            \\n        return [word for word in words if isConcat(word, 0)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933796,
                "title": "recursion-memoization-js-solution",
                "content": "```\\nvar findAllConcatenatedWordsInADict = function(words) {\\n    let m = new Map(), memo = new Map();\\n    let res = [];\\n    for (let i = 0; i < words.length; i++) {\\n        m.set(words[i], 1);\\n    }\\n    for (let i = 0; i < words.length; i++) {\\n        if (isConcat(words[i], m, memo)) res.push(words[i]);\\n    }\\n    return res;\\n};\\n\\nfunction isConcat(word, m, memo) {\\n    if (memo.has(word)) return memo.get(word);\\n    for (let i = 1; i < word.length; i++) {\\n        let prefix = word.slice(0, i);\\n        let suffix = word.slice(i);\\n        if (m.has(prefix) && (m.has(suffix) || isConcat(suffix, m, memo))) {\\n            memo.set(word, true);\\n            return true;\\n        }\\n    }\\n    \\n    memo.set(word, false);\\n    return false;\\n};\\n\\n// Time Complexity: O(n*k^2) where k is the maximum length of word\\n// Space Complexity: O(max(n, k)) because call stack can go as much as k\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findAllConcatenatedWordsInADict = function(words) {\\n    let m = new Map(), memo = new Map();\\n    let res = [];\\n    for (let i = 0; i < words.length; i++) {\\n        m.set(words[i], 1);\\n    }\\n    for (let i = 0; i < words.length; i++) {\\n        if (isConcat(words[i], m, memo)) res.push(words[i]);\\n    }\\n    return res;\\n};\\n\\nfunction isConcat(word, m, memo) {\\n    if (memo.has(word)) return memo.get(word);\\n    for (let i = 1; i < word.length; i++) {\\n        let prefix = word.slice(0, i);\\n        let suffix = word.slice(i);\\n        if (m.has(prefix) && (m.has(suffix) || isConcat(suffix, m, memo))) {\\n            memo.set(word, true);\\n            return true;\\n        }\\n    }\\n    \\n    memo.set(word, false);\\n    return false;\\n};\\n\\n// Time Complexity: O(n*k^2) where k is the maximum length of word\\n// Space Complexity: O(max(n, k)) because call stack can go as much as k\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 746438,
                "title": "easy-python-100-speed-highly-optimized",
                "content": "**Easy Python | 100% Speed | Highly Optimized**\\n\\nThe Python code below corresponds to a simple solution based on:\\n\\n1. Matching substrings against a global set (I experimented using \"Tries\" originally, but they don\\'t provide any benefits).\\n\\n2. Using Binary Search to look for compatible substring lengths (the process is still O(n), but it\\'s a significant boost).\\n\\n3. Using Depth-First Search to look for complete matches for a word.\\n\\nThe comments inside the code provide further insights. I hope you find it helpful. Cheers,\\n\\nPS. Those notes about bisect_right, and bisect_left changed my life lol\\n```\\n# Python 2/3\\nfrom bisect import bisect_right,bisect_left\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words):\\n        words = set([word for word in words if word]) # Filter Empty Words\\n        #\\n        # Find Compatible substring lengths using binary search\\n        nlens = sorted( set(map(len,words)) )\\n        def getsizes(L,i):\\n            # BISECT USAGE:\\n            #     bisect_left   ->  a[lo:i] <  x <= a[i:hi]\\n            #     bisect_right  ->  a[lo:i] <= x <  a[i:hi]\\n            if i:\\n                Lj = bisect_right(nlens,L) # include L\\n            else:\\n                Lj = bisect_left(nlens,L) # exclude L\\n            # Yield Reversed without delay\\n            for j in range(Lj-1,-1,-1):\\n                yield nlens[j]\\n        #\\n        # DFS matching function:\\n        def dfs(i,word,L):\\n            if i == L:\\n                return True\\n            #\\n            for a in getsizes(L-i,i):\\n                if word[i:i+a] in words and dfs(i+a,word,L):\\n                    return True\\n            return False\\n        #\\n        # Final Loop:\\n        res = []\\n        for word in words:\\n            if dfs(0,word,len(word)):\\n                res.append(word)\\n        #\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Python 2/3\\nfrom bisect import bisect_right,bisect_left\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words):\\n        words = set([word for word in words if word]) # Filter Empty Words\\n        #\\n        # Find Compatible substring lengths using binary search\\n        nlens = sorted( set(map(len,words)) )\\n        def getsizes(L,i):\\n            # BISECT USAGE:\\n            #     bisect_left   ->  a[lo:i] <  x <= a[i:hi]\\n            #     bisect_right  ->  a[lo:i] <= x <  a[i:hi]\\n            if i:\\n                Lj = bisect_right(nlens,L) # include L\\n            else:\\n                Lj = bisect_left(nlens,L) # exclude L\\n            # Yield Reversed without delay\\n            for j in range(Lj-1,-1,-1):\\n                yield nlens[j]\\n        #\\n        # DFS matching function:\\n        def dfs(i,word,L):\\n            if i == L:\\n                return True\\n            #\\n            for a in getsizes(L-i,i):\\n                if word[i:i+a] in words and dfs(i+a,word,L):\\n                    return True\\n            return False\\n        #\\n        # Final Loop:\\n        res = []\\n        for word in words:\\n            if dfs(0,word,len(word)):\\n                res.append(word)\\n        #\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105040,
                "title": "short-and-easy-recursive-solution",
                "content": "Use ranges to split a particular word into two: `w[..i]` and `w[i..]`:\\n```csharp\\npublic class Solution\\n{\\n    public IList<string> FindAllConcatenatedWordsInADict(string[] words)\\n    {\\n        HashSet<string> ws = new(words);\\n        return words.Where(w => IsConcatenated(w)).ToList();\\n\\n        bool IsConcatenated(string w, int count = 0)\\n        {\\n            if (w.Length == 0) return count > 1;\\n\\n            for (int i = 1; i <= w.Length; i++)\\n            {\\n                if (ws.Contains(w[..i]) && IsConcatenated(w[i..], count + 1)) return true;\\n            }\\n            \\n            return false;\\n        }\\n    }\\n}\\n```\\n\\nThe same logic can be expressed in a more concise way, looks horrible though:\\n```csharp\\npublic class Solution\\n{\\n    public IList<string> FindAllConcatenatedWordsInADict(string[] words)\\n    {\\n        HashSet<string> ws = new(words);\\n        return words.Where(w => IsConcatenated(w)).ToList();\\n\\n        bool IsConcatenated(string w, int count = 0) =>\\n            w.Length == 0 && count > 1\\n            || Enumerable.Range(1, w.Length)\\n                .Where(i => ws.Contains(w[..i]) && IsConcatenated(w[i..], count + 1))\\n                .Any();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public IList<string> FindAllConcatenatedWordsInADict(string[] words)\\n    {\\n        HashSet<string> ws = new(words);\\n        return words.Where(w => IsConcatenated(w)).ToList();\\n\\n        bool IsConcatenated(string w, int count = 0)\\n        {\\n            if (w.Length == 0) return count > 1;\\n\\n            for (int i = 1; i <= w.Length; i++)\\n            {\\n                if (ws.Contains(w[..i]) && IsConcatenated(w[i..], count + 1)) return true;\\n            }\\n            \\n            return false;\\n        }\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public IList<string> FindAllConcatenatedWordsInADict(string[] words)\\n    {\\n        HashSet<string> ws = new(words);\\n        return words.Where(w => IsConcatenated(w)).ToList();\\n\\n        bool IsConcatenated(string w, int count = 0) =>\\n            w.Length == 0 && count > 1\\n            || Enumerable.Range(1, w.Length)\\n                .Where(i => ws.Contains(w[..i]) && IsConcatenated(w[i..], count + 1))\\n                .Any();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104231,
                "title": "c-explained-simple-approach-easy-recursion-using-set",
                "content": "# PLZ UPVOTE\\n![Cute-Cat.jpg](https://assets.leetcode.com/users/images/0ce2ad99-bff2-48e8-88ba-c5a513488ffc_1674801341.2756007.jpeg)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    //Our lc function breaks the word into two parts left and right\\n    // and check if these are already present in our dictionary \\n    //or can be formed using the words presnt in dictionary\\n\\n    bool lc(string s , set<string>&dictionary){\\n\\n        for(int i=1; i<s.size(); ++i){\\n\\n            string left=s.substr(0,i);\\n            string right=s.substr(i);\\n            \\n            //iterators for the string to check their presence\\n            auto ii=dictionary.find(left);\\n            auto j=dictionary.find(right);\\n            \\n            // if left is found then right is also found \\n            //or our right can be made\\n\\n            if(ii!=dictionary.end()){\\n                if(j!=dictionary.end() or lc(right,dictionary)) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        \\n        //Made for storing the answer\\n        vector<string> beri;\\n\\n        //Making a set of the string (dictionary) for all the words \\n        set<string> dictionary;\\n        for(auto i:words) dictionary.insert(i);\\n        \\n        //we are checking if the particular word can be made\\n        // from other words presnt inside the dictionary\\n        for(auto i :words){\\n            if(lc(i,dictionary)) beri.push_back(i);\\n        }\\n\\n        return beri;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    //Our lc function breaks the word into two parts left and right\\n    // and check if these are already present in our dictionary \\n    //or can be formed using the words presnt in dictionary\\n\\n    bool lc(string s , set<string>&dictionary){\\n\\n        for(int i=1; i<s.size(); ++i){\\n\\n            string left=s.substr(0,i);\\n            string right=s.substr(i);\\n            \\n            //iterators for the string to check their presence\\n            auto ii=dictionary.find(left);\\n            auto j=dictionary.find(right);\\n            \\n            // if left is found then right is also found \\n            //or our right can be made\\n\\n            if(ii!=dictionary.end()){\\n                if(j!=dictionary.end() or lc(right,dictionary)) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        \\n        //Made for storing the answer\\n        vector<string> beri;\\n\\n        //Making a set of the string (dictionary) for all the words \\n        set<string> dictionary;\\n        for(auto i:words) dictionary.insert(i);\\n        \\n        //we are checking if the particular word can be made\\n        // from other words presnt inside the dictionary\\n        for(auto i :words){\\n            if(lc(i,dictionary)) beri.push_back(i);\\n        }\\n\\n        return beri;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252726,
                "title": "c-easy-to-understand-simple-backtracking-siolution",
                "content": "```\\nclass Solution {\\npublic:\\n    set<string> dict;\\n    bool check(string &word,int c)\\n    {\\n        if(word.size()==0)\\n        {\\n            // cout<<c<<endl;\\n            if(c>=2)\\n            return true;\\n            \\n            return false;\\n        }\\n\\n        for(int i=1;i<=word.size();i++)\\n        {\\n            string left=word.substr(0,i);\\n            string right=word.substr(i);\\n            if(dict.find(left)!=dict.end())\\n            {\\n                ++c;\\n                if(check(right,c))\\n                {\\n                    return true;\\n                }\\n                --c;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> ans;\\n        for(auto &word:words)\\n        {\\n            dict.insert(word);\\n        }\\n        for(auto &word:words)\\n        {\\n            if(check(word,0))\\n            {\\n                ans.push_back(word);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<string> dict;\\n    bool check(string &word,int c)\\n    {\\n        if(word.size()==0)\\n        {\\n            // cout<<c<<endl;\\n            if(c>=2)\\n            return true;\\n            \\n            return false;\\n        }\\n\\n        for(int i=1;i<=word.size();i++)\\n        {\\n            string left=word.substr(0,i);\\n            string right=word.substr(i);\\n            if(dict.find(left)!=dict.end())\\n            {\\n                ++c;\\n                if(check(right,c))\\n                {\\n                    return true;\\n                }\\n                --c;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> ans;\\n        for(auto &word:words)\\n        {\\n            dict.insert(word);\\n        }\\n        for(auto &word:words)\\n        {\\n            if(check(word,0))\\n            {\\n                ans.push_back(word);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2240108,
                "title": "java-trie-sort-dfs-91ms-some-thoughts",
                "content": "Sort it by length in ascending order because we only need to try to form the current string with shorter strings.\\nThen we construct the trie as we go and do a dfs on each word.\\n\\nFor the DFS, we generally have two possible options:\\n- Continue with the current word\\n- If the current index has a valid word ended there, start a new DFS from the root Trie.\\n\\nHere is the normal version that **passed** it in 91ms, but it has a fatal flaw and **should NOT have passed**.\\nCould you see where the problem is?\\n```Java\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        Trie root = new Trie();\\n        Arrays.sort(words, Comparator.comparingInt(o->o.length()));\\n        for (String s : words){\\n            if (dfs(0,s,root,root)){ // check for current word\\n                ans.add(s);\\n            }\\n            Trie cur = root;\\n            for (char ch : s.toCharArray()){ // build tree\\n                if (cur.nodes[ch-\\'a\\']==null){\\n                    cur.nodes[ch-\\'a\\']=new Trie();\\n                }\\n                cur=cur.nodes[ch-\\'a\\'];\\n            }\\n            cur.isWord=true;\\n        }\\n        return ans;\\n    }\\n\\n    private boolean dfs(int idx, String s, Trie cur, Trie root){\\n        if (cur==null){\\n            return false;\\n        }\\n        if (idx==s.length()){\\n            return cur.isWord;\\n        }\\n        return cur.isWord && dfs(idx,s,root,root)||dfs(idx+1,s,cur.nodes[s.charAt(idx)-\\'a\\'],root); // two options.\\n    }\\n\\n    private class Trie {\\n        Trie[] nodes = new Trie[26];\\n        boolean isWord;\\n        Trie(){}\\n    }\\n}\\n```\\n*Answer:*\\nOne may notice that it got TLE for this test case that I discovered:\\n```\\n[\"aaaaaaaaaaaaaaaaaaaaaaaaaaab\",\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\",\"aaaaaaaaaaa\",\"aaaaaaaaaaaa\",\"aaaaaaaaaaaaa\",\"aaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaa\"]\\n```\\nHence, we need to add memo to avoid it.\\n- In particular, we will not allow DFS to start **anew** at an index that was previous explored anew as well.\\n- If you don\\'t like to reallocate at most 30 new bytes per word, use `int[]` and a rolling `id` to mark as seen.\\n- Byte? isn\\'t boolean in Java bit? No, JVM usually reserves 1 byte for boolean.\\n```Java\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        Trie root = new Trie();\\n        Arrays.sort(words, Comparator.comparingInt(o->o.length()));\\n        for (String s : words){\\n            if (dfs(0,s,root,root, new boolean[s.length()])){\\n                ans.add(s);\\n            }\\n            Trie cur = root;\\n            for (char ch : s.toCharArray()){\\n                if (cur.nodes[ch-\\'a\\']==null){\\n                    cur.nodes[ch-\\'a\\']=new Trie();\\n                }\\n                cur=cur.nodes[ch-\\'a\\'];\\n            }\\n            cur.isWord=true;\\n        }\\n        return ans;\\n    }\\n\\n    private boolean dfs(int idx, String s, Trie cur, Trie root, boolean[] seen){\\n        if (cur==null){\\n            return false;\\n        }\\n        if (idx==s.length()){\\n            return cur.isWord;\\n        }\\n        if (cur==root){ // memo\\n            if (seen[idx]){\\n                return false;\\n            }\\n            seen[idx]=true;\\n        }\\n        return cur.isWord && dfs(idx,s,root,root,seen)||dfs(idx+1,s,cur.nodes[s.charAt(idx)-\\'a\\'],root,seen);\\n    }\\n\\n    private class Trie {\\n        Trie[] nodes = new Trie[26];\\n        boolean isWord;\\n        Trie(){}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```Java\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        Trie root = new Trie();\\n        Arrays.sort(words, Comparator.comparingInt(o->o.length()));\\n        for (String s : words){\\n            if (dfs(0,s,root,root)){ // check for current word\\n                ans.add(s);\\n            }\\n            Trie cur = root;\\n            for (char ch : s.toCharArray()){ // build tree\\n                if (cur.nodes[ch-\\'a\\']==null){\\n                    cur.nodes[ch-\\'a\\']=new Trie();\\n                }\\n                cur=cur.nodes[ch-\\'a\\'];\\n            }\\n            cur.isWord=true;\\n        }\\n        return ans;\\n    }\\n\\n    private boolean dfs(int idx, String s, Trie cur, Trie root){\\n        if (cur==null){\\n            return false;\\n        }\\n        if (idx==s.length()){\\n            return cur.isWord;\\n        }\\n        return cur.isWord && dfs(idx,s,root,root)||dfs(idx+1,s,cur.nodes[s.charAt(idx)-\\'a\\'],root); // two options.\\n    }\\n\\n    private class Trie {\\n        Trie[] nodes = new Trie[26];\\n        boolean isWord;\\n        Trie(){}\\n    }\\n}\\n```\n```\\n[\"aaaaaaaaaaaaaaaaaaaaaaaaaaab\",\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\",\"aaaaaaaaaaa\",\"aaaaaaaaaaaa\",\"aaaaaaaaaaaaa\",\"aaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaa\"]\\n```\n```Java\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        Trie root = new Trie();\\n        Arrays.sort(words, Comparator.comparingInt(o->o.length()));\\n        for (String s : words){\\n            if (dfs(0,s,root,root, new boolean[s.length()])){\\n                ans.add(s);\\n            }\\n            Trie cur = root;\\n            for (char ch : s.toCharArray()){\\n                if (cur.nodes[ch-\\'a\\']==null){\\n                    cur.nodes[ch-\\'a\\']=new Trie();\\n                }\\n                cur=cur.nodes[ch-\\'a\\'];\\n            }\\n            cur.isWord=true;\\n        }\\n        return ans;\\n    }\\n\\n    private boolean dfs(int idx, String s, Trie cur, Trie root, boolean[] seen){\\n        if (cur==null){\\n            return false;\\n        }\\n        if (idx==s.length()){\\n            return cur.isWord;\\n        }\\n        if (cur==root){ // memo\\n            if (seen[idx]){\\n                return false;\\n            }\\n            seen[idx]=true;\\n        }\\n        return cur.isWord && dfs(idx,s,root,root,seen)||dfs(idx+1,s,cur.nodes[s.charAt(idx)-\\'a\\'],root,seen);\\n    }\\n\\n    private class Trie {\\n        Trie[] nodes = new Trie[26];\\n        boolean isWord;\\n        Trie(){}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829842,
                "title": "my-simple-java-solution-using-dp-no-sort",
                "content": "```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        Set<String> set = new HashSet<>();\\n        for(String word: words)\\n            set.add(word);\\n        for(String word: words){\\n            if(helper(word, set)){\\n                result.add(word);\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean helper(String s, Set<String> set){\\n        int len = s.length();\\n        if(len == 0)\\n            return false;\\n        boolean[] dp = new boolean[len + 1];\\n        dp[0] = true;\\n        for(int i = 0; i <= len; i++){\\n            for(int j = i - 1 ; j >= 0; j--){ // running this loop in the backwards direction saves time\\n                if(i == len && j == 0) // we can\\'t consider the string to be made up of itself i.e we ignore s.substring(0, len)\\n                    continue;\\n                if(dp[j] && set.contains(s.substring(j,i))){\\n                    dp[i] = true;\\n                    break;\\n                }                \\n            }\\n        }\\n        return dp[len];\\n    }\\n}\\n```\\nThe time complexity of this solution is O( N * len^3) were N is the size of words array and len is the length of the string",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        Set<String> set = new HashSet<>();\\n        for(String word: words)\\n            set.add(word);\\n        for(String word: words){\\n            if(helper(word, set)){\\n                result.add(word);\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean helper(String s, Set<String> set){\\n        int len = s.length();\\n        if(len == 0)\\n            return false;\\n        boolean[] dp = new boolean[len + 1];\\n        dp[0] = true;\\n        for(int i = 0; i <= len; i++){\\n            for(int j = i - 1 ; j >= 0; j--){ // running this loop in the backwards direction saves time\\n                if(i == len && j == 0) // we can\\'t consider the string to be made up of itself i.e we ignore s.substring(0, len)\\n                    continue;\\n                if(dp[j] && set.contains(s.substring(j,i))){\\n                    dp[i] = true;\\n                    break;\\n                }                \\n            }\\n        }\\n        return dp[len];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637842,
                "title": "java-nice-small-whats-the-timecomplexity",
                "content": "```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> aList = new ArrayList<>();\\n        if(words.length == 0) return aList;\\n        Set<String> wordSet = new HashSet<>();\\n        for (String string : words) {\\n            wordSet.add(string);\\n        }\\n        for (String word : words) {\\n            if(canConcatinate(word, wordSet)) {\\n                aList.add(word);\\n            }\\n        }\\n        return aList;\\n    }\\n\\n    private boolean canConcatinate(String word, Set<String> wSet) {\\n        for (int i = 1 ; i < word.length(); i++) {\\n            String prefix = word.substring(0 , i);\\n            String suffix = word.substring(i , word.length());\\n            if(wSet.contains(prefix) && (wSet.contains(suffix) || canConcatinate(suffix, wSet))) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> aList = new ArrayList<>();\\n        if(words.length == 0) return aList;\\n        Set<String> wordSet = new HashSet<>();\\n        for (String string : words) {\\n            wordSet.add(string);\\n        }\\n        for (String word : words) {\\n            if(canConcatinate(word, wordSet)) {\\n                aList.add(word);\\n            }\\n        }\\n        return aList;\\n    }\\n\\n    private boolean canConcatinate(String word, Set<String> wSet) {\\n        for (int i = 1 ; i < word.length(); i++) {\\n            String prefix = word.substring(0 , i);\\n            String suffix = word.substring(i , word.length());\\n            if(wSet.contains(prefix) && (wSet.contains(suffix) || canConcatinate(suffix, wSet))) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422734,
                "title": "python-concise-dfs-solution",
                "content": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:#dfs to search.\\n        def dfs(w,oneGood):#return True or False\\n            if w in Set and oneGood:\\n                return True\\n            if w in memo:\\n                return memo[w]\\n            for i in range(len(w)-1):#[:i+1] and [i+1:] part \\n                if w[:i+1] in Set and dfs(w[i+1:],True):\\n                    memo[w]=True\\n                    return True\\n            memo[w]=False\\n            return False  \\n        \\n        memo={}#cache visited word\\'s result \\n        res=[]\\n        Set=set(words)\\n        for w in words:\\n            if dfs(w,False):\\n                res.append(w)\\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:#dfs to search.\\n        def dfs(w,oneGood):#return True or False\\n            if w in Set and oneGood:\\n                return True\\n            if w in memo:\\n                return memo[w]\\n            for i in range(len(w)-1):#[:i+1] and [i+1:] part \\n                if w[:i+1] in Set and dfs(w[i+1:],True):\\n                    memo[w]=True\\n                    return True\\n            memo[w]=False\\n            return False  \\n        \\n        memo={}",
                "codeTag": "Java"
            },
            {
                "id": 417336,
                "title": "python-trie-solution",
                "content": "* sort words by word length, so that short words are inserted firstly\\n* insert words into trie one by one, if all of sub-words already exist in trie, return False.\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.isWord = False\\n        self.children = collections.defaultdict(TrieNode)\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for i, c in enumerate(word):\\n            node = node.children[c]\\n            if node.isWord:\\n                if self.exists(word[i+1:]):\\n                    return False\\n                else:\\n                    continue\\n        node.isWord = True\\n        return True\\n    \\n    def exists(self, word):\\n        node = self.root\\n        for i, c in enumerate(word):\\n            if c in node.children:\\n                node = node.children[c]\\n                if node.isWord:\\n                    if i == len(word)-1 or self.exists(word[i+1:]):\\n                        return True\\n                    else:\\n                        continue\\n            else:\\n                return False\\n\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        \\n        trie = Trie()\\n        \\n        return [word for word in sorted(words, key=len) if not trie.insert(word)]",
                "solutionTags": [],
                "code": "* sort words by word length, so that short words are inserted firstly\\n* insert words into trie one by one, if all of sub-words already exist in trie, return False.\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.isWord = False\\n        self.children = collections.defaultdict(TrieNode)\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        node = self.root\\n        for i, c in enumerate(word):\\n            node = node.children[c]\\n            if node.isWord:\\n                if self.exists(word[i+1:]):\\n                    return False\\n                else:\\n                    continue\\n        node.isWord = True\\n        return True\\n    \\n    def exists(self, word):\\n        node = self.root\\n        for i, c in enumerate(word):\\n            if c in node.children:\\n                node = node.children[c]\\n                if node.isWord:\\n                    if i == len(word)-1 or self.exists(word[i+1:]):\\n                        return True\\n                    else:\\n                        continue\\n            else:\\n                return False\\n\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        \\n        trie = Trie()\\n        \\n        return [word for word in sorted(words, key=len) if not trie.insert(word)]",
                "codeTag": "Java"
            },
            {
                "id": 3106099,
                "title": "c-simple-brute-force-recursion-with-memoization",
                "content": "# Intuition\\nWe check for each word given and if it is comprised entirely of at least two shorter words in the given array then we store it in our ans vector.\\n\\n# Approach\\nIterate through the each word. If upto any particular index, it is present in given vector then call recursively for next indices. Cnt shows how much time recursive function is called (cnt>1 shows every word concatenates at least two words given in array).\\n\\n\\n# Code\\n```\\nclass Solution {\\n    unordered_set<string> st;\\n    int dp[10000][30][31];\\n    bool check(int idx, vector<string>& words, int i, int cnt)\\n    {\\n        if(idx==words[i].size())\\n        {\\n            if(cnt>1) return true;\\n            return false;\\n        }\\n        if(dp[i][idx][cnt]!=-1) return dp[i][idx][cnt];\\n        for(int k=idx; k<words[i].size(); k++)\\n        {\\n            string t=words[i].substr(idx, k-idx+1);\\n            if(st.find(t) != st.end() && check(k+1, words, i, cnt+1)) \\n            {\\n                return dp[i][idx][cnt] = 1;\\n            }\\n        }\\n        return dp[i][idx][cnt] = 0;\\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) \\n    {\\n        int n=words.size();\\n        vector<string> ans;\\n        for(auto &w: words) st.insert(w);\\n        memset(dp, -1, sizeof(dp));\\n        for(int i=0; i<n; i++)\\n        {\\n            if(check(0, words, i, 0)) ans.push_back(words[i]);\\n        }  \\n        return ans;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    unordered_set<string> st;\\n    int dp[10000][30][31];\\n    bool check(int idx, vector<string>& words, int i, int cnt)\\n    {\\n        if(idx==words[i].size())\\n        {\\n            if(cnt>1) return true;\\n            return false;\\n        }\\n        if(dp[i][idx][cnt]!=-1) return dp[i][idx][cnt];\\n        for(int k=idx; k<words[i].size(); k++)\\n        {\\n            string t=words[i].substr(idx, k-idx+1);\\n            if(st.find(t) != st.end() && check(k+1, words, i, cnt+1)) \\n            {\\n                return dp[i][idx][cnt] = 1;\\n            }\\n        }\\n        return dp[i][idx][cnt] = 0;\\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) \\n    {\\n        int n=words.size();\\n        vector<string> ans;\\n        for(auto &w: words) st.insert(w);\\n        memset(dp, -1, sizeof(dp));\\n        for(int i=0; i<n; i++)\\n        {\\n            if(check(0, words, i, 0)) ans.push_back(words[i]);\\n        }  \\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106087,
                "title": "java-simple-recursion-explained",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n``` java []\\nclass Solution {\\n    // globally declare a hashset to store all the words \\n    private Set<String> set = new HashSet<>();\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        // add the words to the set\\n        for (String w : words) {\\n            set.add(w);\\n        }\\n\\n        // initialise answer arraylist\\n        List<String> ans = new ArrayList<>();\\n        // iterate over words[]\\n        for (String w : words) {\\n            if (isConcat(w)) {  // if the method returns a true,\\n                ans.add(w);     // we add the word to answer list\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    // this method tells us if the word is a concatenation of other words\\n    private boolean isConcat(String s) {\\n        // we will partition the word into 2 words\\n        for (int i = 0; i < s.length(); i++) {\\n            String prefix = s.substring(0, i);  // first part\\n            String suffix = s.substring(i);     // second part\\n            // if both the parts are present in set means that\\n            // the original word is a concatenation\\n            // if the prefix is not in set, we will create the next prefix\\n            // s = \"catsdogcats\", we have the prefix \"cat\" which is not in set\\n            // so we would make the next prefix \"cats\", which is present in set\\n            // we are left with \"dogcats\" as suffix. It is not present in set\\n            // (if it were present in set we would have got our answer)\\n            // Now we would recusively call isConcat() to partition \"dogcats\" the way we did \"catsdogcats\"\\n            // it\\'ll make further partitions of the suffix and check if the partitions are present in set\\n            if (set.contains(prefix) && (set.contains(suffix) || isConcat(suffix))) {\\n                return true;    // return true if we find that the word is a concatenation\\n            }\\n        }\\n\\n        // no partitioning could create the word, means no concatenation possible\\n        return false;   // so return false\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(n)\\n```\\n---\\n### Clean solution:\\n``` java []\\nclass Solution {\\n    private Set<String> set = new HashSet<>();\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        for (String w : words) {\\n            set.add(w);\\n        }\\n\\n        List<String> ans = new ArrayList<>();\\n        for (String w : words) {\\n            if (isConcat(w)) {  \\n                ans.add(w);    \\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isConcat(String s) {        \\n        for (int i = 0; i < s.length(); i++) {\\n            String prefix = s.substring(0, i);  \\n            String suffix = s.substring(i);    \\n            if (set.contains(prefix) && (set.contains(suffix) || isConcat(suffix))) {\\n                return true;    \\n            }\\n        }\\n\\n        return false;  \\n    }\\n}\\n```\\n---\\n#### Time complexity: $$O(n * k)$$\\n`n` be the number of strings in the `word` array. \\n`k`be the length of each individual word in words array.\\n#### Space complexity: $$O(n)$$\\nWe are creating a hashset and putting all the words (from words array) into it.\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "``` java []\\nclass Solution {\\n    // globally declare a hashset to store all the words \\n    private Set<String> set = new HashSet<>();\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        // add the words to the set\\n        for (String w : words) {\\n            set.add(w);\\n        }\\n\\n        // initialise answer arraylist\\n        List<String> ans = new ArrayList<>();\\n        // iterate over words[]\\n        for (String w : words) {\\n            if (isConcat(w)) {  // if the method returns a true,\\n                ans.add(w);     // we add the word to answer list\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    // this method tells us if the word is a concatenation of other words\\n    private boolean isConcat(String s) {\\n        // we will partition the word into 2 words\\n        for (int i = 0; i < s.length(); i++) {\\n            String prefix = s.substring(0, i);  // first part\\n            String suffix = s.substring(i);     // second part\\n            // if both the parts are present in set means that\\n            // the original word is a concatenation\\n            // if the prefix is not in set, we will create the next prefix\\n            // s = \"catsdogcats\", we have the prefix \"cat\" which is not in set\\n            // so we would make the next prefix \"cats\", which is present in set\\n            // we are left with \"dogcats\" as suffix. It is not present in set\\n            // (if it were present in set we would have got our answer)\\n            // Now we would recusively call isConcat() to partition \"dogcats\" the way we did \"catsdogcats\"\\n            // it\\'ll make further partitions of the suffix and check if the partitions are present in set\\n            if (set.contains(prefix) && (set.contains(suffix) || isConcat(suffix))) {\\n                return true;    // return true if we find that the word is a concatenation\\n            }\\n        }\\n\\n        // no partitioning could create the word, means no concatenation possible\\n        return false;   // so return false\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    private Set<String> set = new HashSet<>();\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        for (String w : words) {\\n            set.add(w);\\n        }\\n\\n        List<String> ans = new ArrayList<>();\\n        for (String w : words) {\\n            if (isConcat(w)) {  \\n                ans.add(w);    \\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isConcat(String s) {        \\n        for (int i = 0; i < s.length(); i++) {\\n            String prefix = s.substring(0, i);  \\n            String suffix = s.substring(i);    \\n            if (set.contains(prefix) && (set.contains(suffix) || isConcat(suffix))) {\\n                return true;    \\n            }\\n        }\\n\\n        return false;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827392,
                "title": "java-dp-22-lines-and-beat-90-with-comments",
                "content": "This is the medium question \"139. Word Break\" + a for loop. \\nIf the input size of the list is N and the average of the word length is M.\\nTo solve Leetcode 139, we have two dp approaches:\\n1.For each position in a word, we loop through all the words in the List and update the dp arrays.  BigO: N * M * N\\n2.For each word, we loop through all the possible sub strings to find a match in the List and update the dp arrays. BigO: N * M * M\\nFor this one, since N is bigger than M, so we use the 2nd approach.\\n(I have also tried the 1 approach, and I got a ETL).\\n\\n```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        HashSet<String> set = new HashSet<>();\\n        for(String word : words) set.add(word);     \\n        for(String word : words) helper(result, set, word);    \\n        return result;\\n    }    \\n    private void helper(List<String> list, HashSet<String> set, String word){\\n        if(word.length() == 0) return;\\n        boolean[] dp = new boolean[word.length() + 1];\\n        dp[0] = true;\\n        for(int i = 0; i < word.length(); i++){\\n            if(!dp[i]) continue;\\n            for(int j = i + 1; j < dp.length; j++){\\n                if(i == 0 && j == word.length()) continue;\\n                if(set.contains(word.substring(i,j)))dp[j] = true;                 \\n            }\\n        }            \\n        if(dp[dp.length - 1]) list.add(word);       \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        HashSet<String> set = new HashSet<>();\\n        for(String word : words) set.add(word);     \\n        for(String word : words) helper(result, set, word);    \\n        return result;\\n    }    \\n    private void helper(List<String> list, HashSet<String> set, String word){\\n        if(word.length() == 0) return;\\n        boolean[] dp = new boolean[word.length() + 1];\\n        dp[0] = true;\\n        for(int i = 0; i < word.length(); i++){\\n            if(!dp[i]) continue;\\n            for(int j = i + 1; j < dp.length; j++){\\n                if(i == 0 && j == word.length()) continue;\\n                if(set.contains(word.substring(i,j)))dp[j] = true;                 \\n            }\\n        }            \\n        if(dp[dp.length - 1]) list.add(word);       \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242009,
                "title": "c-soln-trie-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    struct trie{\\n        trie* child[26];\\n        bool isend;\\n    };\\n    trie* root;\\n    trie* getnode(){\\n        trie* node=new trie;\\n        for(int i=0;i<26;i++){\\n            node->child[i]=NULL;\\n        }\\n        node->isend=false;\\n        return node;\\n    }\\n    void addword(string s){\\n        trie *cur=root;\\n        for(int i=0;i<s.length();i++){\\n            if(!cur->child[s[i]-\\'a\\'])cur->child[s[i]-\\'a\\']=getnode();\\n            cur=cur->child[s[i]-\\'a\\'];\\n        }\\n        cur->isend=true;\\n    }\\n    bool search(string w) {\\n        trie* cur=root;\\n        for(int i=0;i<w.length();i++){\\n            if(!cur->child[w[i]-\\'a\\'])return false;\\n            cur=cur->child[w[i]-\\'a\\'];\\n        }\\n        return (cur!=NULL && cur->isend);\\n    }\\n    vector<string> res;\\n    bool sol(string word, int count){\\n        if(count>1 && search(word))return true;\\n        for(int j=0;j<word.length()-1;j++){\\n            string left=word.substr(0,j+1);\\n            string right=word.substr(j+1);\\n            if(search(left) && sol(right, count+1)) return true;\\n            \\n        }\\n        return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        root=getnode();\\n        bool flag=false;\\n        vector<string> ans;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i]==\"\")continue;\\n            addword(words[i]);\\n            \\n        }\\n        for(auto &w:words){\\n            if(w==\"\")continue;\\n            if(sol(w,1))ans.push_back(w);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct trie{\\n        trie* child[26];\\n        bool isend;\\n    };\\n    trie* root;\\n    trie* getnode(){\\n        trie* node=new trie;\\n        for(int i=0;i<26;i++){\\n            node->child[i]=NULL;\\n        }\\n        node->isend=false;\\n        return node;\\n    }\\n    void addword(string s){\\n        trie *cur=root;\\n        for(int i=0;i<s.length();i++){\\n            if(!cur->child[s[i]-\\'a\\'])cur->child[s[i]-\\'a\\']=getnode();\\n            cur=cur->child[s[i]-\\'a\\'];\\n        }\\n        cur->isend=true;\\n    }\\n    bool search(string w) {\\n        trie* cur=root;\\n        for(int i=0;i<w.length();i++){\\n            if(!cur->child[w[i]-\\'a\\'])return false;\\n            cur=cur->child[w[i]-\\'a\\'];\\n        }\\n        return (cur!=NULL && cur->isend);\\n    }\\n    vector<string> res;\\n    bool sol(string word, int count){\\n        if(count>1 && search(word))return true;\\n        for(int j=0;j<word.length()-1;j++){\\n            string left=word.substr(0,j+1);\\n            string right=word.substr(j+1);\\n            if(search(left) && sol(right, count+1)) return true;\\n            \\n        }\\n        return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        root=getnode();\\n        bool flag=false;\\n        vector<string> ans;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i]==\"\")continue;\\n            addword(words[i]);\\n            \\n        }\\n        for(auto &w:words){\\n            if(w==\"\")continue;\\n            if(sol(w,1))ans.push_back(w);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962425,
                "title": "java-trie",
                "content": "Note: With the new test cases this solution gives TLE.\\n\\n\\n```\\n\\npublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        TrieNode root = buildTrie(words);\\n        List<String> result = new ArrayList();\\n        for(String word : words){\\n            if(searchWords(root, word, 0, 0))\\n                result.add(word);\\n        }\\n        return result;\\n    }\\n    \\n    private boolean searchWords(TrieNode root, String word, int idx, int count){\\n\\n        int n = word.length();\\n        TrieNode node = root;\\n        for(int i=idx ; i<n ; i++){\\n            char c = word.charAt(i);\\n            node = node.next[c - \\'a\\'];\\n            if(node == null) return false;\\n            \\n            if(node.isWord){\\n                //check at the end\\n                if(i == n-1){\\n                    //check at least this word is made of more than 1 word\\n                    return count >= 1;\\n                } else{\\n                    if(searchWords(root, word, i+1, count+1))\\n                        return true;\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    \\n    private TrieNode buildTrie(String[] words){\\n        TrieNode root = new TrieNode();\\n        for(String word : words){\\n            if(word.isEmpty()) continue;\\n            TrieNode node = root;\\n            for(int i=0 ; i<word.length() ; i++){\\n                char c = word.charAt(i);\\n                if(node.next[c - \\'a\\'] == null){\\n                    node.next[c - \\'a\\'] = new TrieNode();\\n                }\\n                node = node.next[c - \\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n        return root;\\n    }\\n    \\n    class TrieNode{\\n        TrieNode[] next = new TrieNode[26];\\n        boolean isWord;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        TrieNode root = buildTrie(words);\\n        List<String> result = new ArrayList();\\n        for(String word : words){\\n            if(searchWords(root, word, 0, 0))\\n                result.add(word);\\n        }\\n        return result;\\n    }\\n    \\n    private boolean searchWords(TrieNode root, String word, int idx, int count){\\n\\n        int n = word.length();\\n        TrieNode node = root;\\n        for(int i=idx ; i<n ; i++){\\n            char c = word.charAt(i);\\n            node = node.next[c - \\'a\\'];\\n            if(node == null) return false;\\n            \\n            if(node.isWord){\\n                //check at the end\\n                if(i == n-1){\\n                    //check at least this word is made of more than 1 word\\n                    return count >= 1;\\n                } else{\\n                    if(searchWords(root, word, i+1, count+1))\\n                        return true;\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    \\n    private TrieNode buildTrie(String[] words){\\n        TrieNode root = new TrieNode();\\n        for(String word : words){\\n            if(word.isEmpty()) continue;\\n            TrieNode node = root;\\n            for(int i=0 ; i<word.length() ; i++){\\n                char c = word.charAt(i);\\n                if(node.next[c - \\'a\\'] == null){\\n                    node.next[c - \\'a\\'] = new TrieNode();\\n                }\\n                node = node.next[c - \\'a\\'];\\n            }\\n            node.isWord = true;\\n        }\\n        return root;\\n    }\\n    \\n    class TrieNode{\\n        TrieNode[] next = new TrieNode[26];\\n        boolean isWord;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490920,
                "title": "java-clean-code-with-trie",
                "content": "``` \\npublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result = new ArrayList<>();     \\n        Trie root = new Trie();\\n        // Insert each word \\n        for (String word : words) {\\n            if (word.length() == 0) continue;\\n            Trie node = root;         \\n            for (char c : word.toCharArray()) {\\n                if (node.next[c - \\'a\\'] == null) \\n                    node.next[c - \\'a\\'] = new Trie();\\n                node = node.next[c - \\'a\\'];\\n            }\\n            node.word = word;\\n        }    \\n        for (String word : words)\\n            if (search(word, 0, root, root))\\n                result.add(word);\\n        \\n        return result;\\n    }\\n    \\n    private boolean search(String word, int index, Trie node, Trie root) {\\n        // tricky : the last word of the concatenated word is definitely storing the last word\\n        if (index == word.length())\\n            return node.word != null && !node.word.equals(word); \\n        \\n        Trie current = node.next[word.charAt(index) - \\'a\\'];\\n        \\n        if (current == null) return false;\\n        \\n        // only time when you found word and the search for the rest of the words are true which is searched from the root\\n        if (current.word != null && \\n            search(word, index + 1, root, root)) return true;\\n        \\n        // Keep moving with the next index\\n        return search(word, index + 1, current, root);\\n    }\\n    \\n    class Trie {\\n        Trie[] next = new Trie[26];\\n        String word;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\npublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result = new ArrayList<>();     \\n        Trie root = new Trie();\\n        // Insert each word \\n        for (String word : words) {\\n            if (word.length() == 0) continue;\\n            Trie node = root;         \\n            for (char c : word.toCharArray()) {\\n                if (node.next[c - \\'a\\'] == null) \\n                    node.next[c - \\'a\\'] = new Trie();\\n                node = node.next[c - \\'a\\'];\\n            }\\n            node.word = word;\\n        }    \\n        for (String word : words)\\n            if (search(word, 0, root, root))\\n                result.add(word);\\n        \\n        return result;\\n    }\\n    \\n    private boolean search(String word, int index, Trie node, Trie root) {\\n        // tricky : the last word of the concatenated word is definitely storing the last word\\n        if (index == word.length())\\n            return node.word != null && !node.word.equals(word); \\n        \\n        Trie current = node.next[word.charAt(index) - \\'a\\'];\\n        \\n        if (current == null) return false;\\n        \\n        // only time when you found word and the search for the rest of the words are true which is searched from the root\\n        if (current.word != null && \\n            search(word, index + 1, root, root)) return true;\\n        \\n        // Keep moving with the next index\\n        return search(word, index + 1, current, root);\\n    }\\n    \\n    class Trie {\\n        Trie[] next = new Trie[26];\\n        String word;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444565,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Sort the array by length\\n2. Use dynamic programming (bottom up) to check whether array[0,i-1] is a concatenated word\\n3. Build the dp array as we iterate through the word from left to right using `end` pointer. Iterate array[0, end-1] use another point `start`. This way, we essentially split the question into 2 parts, array[0,start-1] (which is just dp[start])and array[start, end-1].\\n``` javascript\\nvar findAllConcatenatedWordsInADict = function(words) {\\n    words.sort((a,b)=>a.length-b.length);\\n    let wordList = new Set();\\n    let allConcat = [];\\n    let isConcat = function(word) {\\n        if (!word) return false;\\n        let dp = new Array(word.length+1).fill(false);\\n        dp[0] = true;\\n        for (let end=1;end<=word.length;end++) {\\n            for (let start=0;start<end;start++) {\\n                if (dp[start] && wordList.has(word.slice(start, end))) {\\n                    dp[end] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp.pop();\\n    }\\n\\n    for (let i=0;i<words.length;i++) {\\n        if(isConcat(words[i])) {\\n            allConcat.push(words[i]);\\n        }\\n        wordList.add(words[i]);\\n    }\\n    return allConcat;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar findAllConcatenatedWordsInADict = function(words) {\\n    words.sort((a,b)=>a.length-b.length);\\n    let wordList = new Set();\\n    let allConcat = [];\\n    let isConcat = function(word) {\\n        if (!word) return false;\\n        let dp = new Array(word.length+1).fill(false);\\n        dp[0] = true;\\n        for (let end=1;end<=word.length;end++) {\\n            for (let start=0;start<end;start++) {\\n                if (dp[start] && wordList.has(word.slice(start, end))) {\\n                    dp[end] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp.pop();\\n    }\\n\\n    for (let i=0;i<words.length;i++) {\\n        if(isConcat(words[i])) {\\n            allConcat.push(words[i]);\\n        }\\n        wordList.add(words[i]);\\n    }\\n    return allConcat;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3106543,
                "title": "o-n-l-o-n-l-python-solution-explained",
                "content": "Hello **Tenno Leetcoders**, \\n\\nFor this problem, we want to return all  non duplicated `concatenated words`\\n\\nThis problem has the same logic as `139. Word Break`. This problem has its differences though because we want only words that are concatenated by 2 or more other words\\n\\nWe can use `Dynamic Programming` to break the problem down and try to form a single word by using words in our array.\\n\\n### Dynamic Programming\\n\\n1) Iterate over our given array and try to form a word by checking if each given word is a `concatenation` of other words\\n\\n2) If we found a word that is a concatenation of other words, we will add it to our result\\n\\n\\n\\n### Code\\n```\\ndef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        \\n        words_set = set(words)\\n      \\n        result = []\\n    \\n        def dfs(word):\\n            for i in range(len(word)):\\n  \\n                if word[:i+1] in words_set and word[i+1:] in words_set:\\n                    return True\\n\\t\\t\\t\\t\\t\\n                if word[:i+1] in words_set and dfs(word[i+1:]):\\n                    return True\\n\\n            return False\\n    \\n        for word in words:\\n            if dfs(word):\\n                result.append(word)\\n        return result\\n```\\n\\n#### Time Complexity: O(N*L)\\n#### Space Complexity: O(N*L)\\n\\n\\n***Upvote if this tenno\\'s discussion helped you in some type of way***\\n \\n***Warframe\\'s short pvp clip of the day***\\n![image](https://assets.leetcode.com/users/images/4b75b9d6-ac59-479a-b2e9-82211507948a_1674843889.7265222.gif)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        \\n        words_set = set(words)\\n      \\n        result = []\\n    \\n        def dfs(word):\\n            for i in range(len(word)):\\n  \\n                if word[:i+1] in words_set and word[i+1:] in words_set:\\n                    return True\\n\\t\\t\\t\\t\\t\\n                if word[:i+1] in words_set and dfs(word[i+1:]):\\n                    return True\\n\\n            return False\\n    \\n        for word in words:\\n            if dfs(word):\\n                result.append(word)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3105340,
                "title": "python3-347-ms-faster-than-91-39-of-python3",
                "content": "```\\ndef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        wordset = set(words)\\n        result = []\\n        def dfs(word, wordset):\\n            if word == \"\":\\n                return True\\n            for i in range(len(word)):\\n                if word[:i+1] in wordset:\\n                    if dfs(word[i+1:], wordset):\\n                        return True\\n            return False\\n        for word in words:\\n            wordset.remove(word)\\n            if dfs(word, wordset):\\n                result.append(word)\\n            wordset.add(word)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\ndef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        wordset = set(words)\\n        result = []\\n        def dfs(word, wordset):\\n            if word == \"\":\\n                return True\\n            for i in range(len(word)):\\n                if word[:i+1] in wordset:\\n                    if dfs(word[i+1:], wordset):\\n                        return True\\n            return False\\n        for word in words:\\n            wordset.remove(word)\\n            if dfs(word, wordset):\\n                result.append(word)\\n            wordset.add(word)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3103423,
                "title": "daily-leetcoding-challenge-january-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/concatenated-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/concatenated-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1637480,
                "title": "python-trie",
                "content": "\\tclass Trie:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.root = dict()\\n\\n\\t\\tdef insert(self, words):\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tcurrent = self.root\\n\\t\\t\\t\\tfor char in word:\\n\\t\\t\\t\\t\\tif char not in current:\\n\\t\\t\\t\\t\\t\\tcurrent[char] = dict()\\n\\t\\t\\t\\t\\tcurrent = current[char]\\n\\t\\t\\t\\tcurrent[\\'*\\'] = \\'*\\'\\n\\n\\t\\t@lru_cache()\\n\\t\\tdef search(self, target):\\n\\t\\t\\tif target == \\'\\':\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tresult = False\\n\\t\\t\\tnode = self.root\\n\\n\\t\\t\\tfor index, char in enumerate(target):\\n\\t\\t\\t\\tif char not in node:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tnode = node[char]\\n\\t\\t\\t\\tif \\'*\\' in node:\\n\\t\\t\\t\\t\\tresult = result or self.search(target[index+1:])\\n\\t\\t\\t\\t\\tif result:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\treturn result\\n\\n\\tclass Solution:\\n\\t\\tdef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n\\t\\t\\tobj = Trie()\\n\\t\\t\\tobj.insert(words)\\n\\t\\t\\tfinal = []\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tnode = obj.root\\n\\t\\t\\t\\tfor index , char in enumerate(word):\\n\\t\\t\\t\\t\\tnode=node[char]\\n\\t\\t\\t\\t\\tif \"*\" in node:\\n\\t\\t\\t\\t\\t\\tif index!=len(word)-1 and obj.search(word[index+1:]):\\n\\t\\t\\t\\t\\t\\t\\tfinal.append(word)\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\treturn final\\n\\t\\t\\t\\n**If You Like The Solution Upvote.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "\\tclass Trie:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.root = dict()\\n\\n\\t\\tdef insert(self, words):\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tcurrent = self.root\\n\\t\\t\\t\\tfor char in word:\\n\\t\\t\\t\\t\\tif char not in current:\\n\\t\\t\\t\\t\\t\\tcurrent[char] = dict()\\n\\t\\t\\t\\t\\tcurrent = current[char]\\n\\t\\t\\t\\tcurrent[\\'*\\'] = \\'*\\'\\n\\n\\t\\t@lru_cache()\\n\\t\\tdef search(self, target):\\n\\t\\t\\tif target == \\'\\':\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tresult = False\\n\\t\\t\\tnode = self.root\\n\\n\\t\\t\\tfor index, char in enumerate(target):\\n\\t\\t\\t\\tif char not in node:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tnode = node[char]\\n\\t\\t\\t\\tif \\'*\\' in node:\\n\\t\\t\\t\\t\\tresult = result or self.search(target[index+1:])\\n\\t\\t\\t\\t\\tif result:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\treturn result\\n\\n\\tclass Solution:\\n\\t\\tdef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n\\t\\t\\tobj = Trie()\\n\\t\\t\\tobj.insert(words)\\n\\t\\t\\tfinal = []\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tnode = obj.root\\n\\t\\t\\t\\tfor index , char in enumerate(word):\\n\\t\\t\\t\\t\\tnode=node[char]\\n\\t\\t\\t\\t\\tif \"*\" in node:\\n\\t\\t\\t\\t\\t\\tif index!=len(word)-1 and obj.search(word[index+1:]):\\n\\t\\t\\t\\t\\t\\t\\tfinal.append(word)\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\treturn final\\n\\t\\t\\t\\n**If You Like The Solution Upvote.**",
                "codeTag": "Java"
            },
            {
                "id": 1604692,
                "title": "concatenated-words-python3-solution-with-comments-time-complexity-analysis",
                "content": "\\'\\'\\'\\n\\n\\tdef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        # creating a hashset of words for faster look-up\\n        wordset = set(words)\\n        # List to store the final desired output\\n        result = []\\n        # Hashmap for keeping account of word of the wordset\\n        dict_map = {}\\n        \\n        # DfS algorithm for calculating concatenated words\\n        def dfs(word):\\n            # if the word is already present in the hashMap, return its value\\n            if word in dict_map:\\n                return dict_map[word]\\n            \\n            # Going over the prefix and suffix of the given word to check whether they exist in the wordset\\n            # If yes, then return True and update the hashMap value of that word to True\\n            for indx in range(1,len(word)):\\n                prefix = word[:indx]\\n                suffix = word[indx:]\\n                \\n                if prefix in wordset and suffix in wordset:\\n                    dict_map[word] = True\\n                    return True\\n                elif prefix in wordset and dfs(suffix):\\n                    dict_map[word] = True\\n                    return True\\n            \\n            dict_map[word] = False\\n            return False\\n        # Going over each word in words list\\n        for word in words:\\n            if dfs(word):\\n                # Appending the word to the result \\n                result.append(word)\\n        return result\\n    \\nTime Complexity:- O(MN)\\nHere,\\nM --> Number of words in a word list\\nN --> Length of word\\n\\nHope this helps. Thanks!",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "\\'\\'\\'\\n\\n\\tdef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        # creating a hashset of words for faster look-up\\n        wordset = set(words)\\n        # List to store the final desired output\\n        result = []\\n        # Hashmap for keeping account of word of the wordset\\n        dict_map = {}\\n        \\n        # DfS algorithm for calculating concatenated words\\n        def dfs(word):\\n            # if the word is already present in the hashMap, return its value\\n            if word in dict_map:\\n                return dict_map[word]\\n            \\n            # Going over the prefix and suffix of the given word to check whether they exist in the wordset\\n            # If yes, then return True and update the hashMap value of that word to True\\n            for indx in range(1,len(word)):\\n                prefix = word[:indx]\\n                suffix = word[indx:]\\n                \\n                if prefix in wordset and suffix in wordset:\\n                    dict_map[word] = True\\n                    return True\\n                elif prefix in wordset and dfs(suffix):\\n                    dict_map[word] = True\\n                    return True\\n            \\n            dict_map[word] = False\\n            return False\\n        # Going over each word in words list\\n        for word in words:\\n            if dfs(word):\\n                # Appending the word to the result \\n                result.append(word)\\n        return result\\n    \\nTime Complexity:- O(MN)\\nHere,\\nM --> Number of words in a word list\\nN --> Length of word\\n\\nHope this helps. Thanks!",
                "codeTag": "Python3"
            },
            {
                "id": 1573504,
                "title": "python-beats-97-runtime-trie",
                "content": "```\\nclass Solution:\\ndef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n\\ttrie={}\\n\\tfor w in words:\\n\\t\\troot=trie\\n\\t\\tfor s in w:\\n\\t\\t\\tif s not in root:\\n\\t\\t\\t\\troot[s]={}\\n\\t\\t\\troot=root[s]\\n\\t\\troot[\"$\"]=True\\n\\n\\t@lru_cache(None)\\n\\tdef find(w):\\n\\t\\tif not w:\\n\\t\\t\\treturn True\\n\\t\\ttmp=trie\\n\\t\\tval=False\\n\\t\\tfor i,s in enumerate(w):\\n\\t\\t\\tif s not in tmp:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\ttmp=tmp[s]\\n\\t\\t\\tif \"$\" in tmp:\\n\\t\\t\\t\\tval|= find(w[i+1:])\\n\\t\\t\\t\\tif val:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\treturn val\\n\\n\\tres=[]\\n\\tfor w in words:\\n\\t\\troot=trie\\n\\t\\tfor i,s in enumerate(w):\\n\\t\\t\\troot=root[s]\\n\\t\\t\\tif \"$\" in root:\\n\\t\\t\\t\\tif i!=len(w)-1 and find(w[i+1:]):\\n\\t\\t\\t\\t\\tres.append(w)\\n\\t\\t\\t\\t\\tbreak\\n\\treturn res\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\ndef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n\\ttrie={}\\n\\tfor w in words:\\n\\t\\troot=trie\\n\\t\\tfor s in w:\\n\\t\\t\\tif s not in root:\\n\\t\\t\\t\\troot[s]={}\\n\\t\\t\\troot=root[s]\\n\\t\\troot[\"$\"]=True\\n\\n\\t@lru_cache(None)\\n\\tdef find(w):\\n\\t\\tif not w:\\n\\t\\t\\treturn True\\n\\t\\ttmp=trie\\n\\t\\tval=False\\n\\t\\tfor i,s in enumerate(w):\\n\\t\\t\\tif s not in tmp:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\ttmp=tmp[s]\\n\\t\\t\\tif \"$\" in tmp:\\n\\t\\t\\t\\tval|= find(w[i+1:])\\n\\t\\t\\t\\tif val:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\treturn val\\n\\n\\tres=[]\\n\\tfor w in words:\\n\\t\\troot=trie\\n\\t\\tfor i,s in enumerate(w):\\n\\t\\t\\troot=root[s]\\n\\t\\t\\tif \"$\" in root:\\n\\t\\t\\t\\tif i!=len(w)-1 and find(w[i+1:]):\\n\\t\\t\\t\\t\\tres.append(w)\\n\\t\\t\\t\\t\\tbreak\\n\\treturn res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464085,
                "title": "c-472-concatenated-words",
                "content": "\\n```\\nclass TrieNode {\\npublic: \\n    TrieNode* children[26] = {nullptr}; \\n    bool word = false; \\n    ~TrieNode() {\\n        for (auto& child : children) \\n            delete child; \\n    }\\n}; \\n\\nclass Trie {\\n    TrieNode* root = nullptr; \\npublic: \\n    Trie() { root = new TrieNode(); }\\n    \\n    ~Trie() { delete root; }\\n    \\n    void insert(string word) {\\n        TrieNode* node = root; \\n        for (int i = word.size()-1; i >= 0; --i) {\\n            if (!node->children[word[i] - \\'a\\'])\\n                node->children[word[i] - \\'a\\'] = new TrieNode(); \\n            node = node->children[word[i] - \\'a\\']; \\n        }\\n        node->word = true; \\n    }\\n    \\n    bool search(string word) {\\n        vector<bool> dp(1 + word.size()); \\n        dp[0] = true; \\n        for (int i = 0; i < word.size(); ++i) {\\n            TrieNode* node = root; \\n            for (int j = i; j >= 0; --j) {\\n                if (!node->children[word[j] - \\'a\\']) break; \\n                node = node->children[word[j] - \\'a\\']; \\n                if (dp[j] && node->word) {\\n                    dp[i+1] = true; \\n                    break; \\n                }\\n            }\\n        }\\n        return dp.back(); \\n    }\\n}; \\n\\n\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string& w1, const string& w2) { return (w1.size() < w2.size()); });\\n        vector<string> ans;\\n        \\n        Trie* trie = new Trie(); \\n        for (auto& word : words) \\n            if (word.size()) {\\n                if (trie->search(word)) ans.push_back(word); \\n                trie->insert(word); \\n            }\\n        \\n        delete trie; \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass TrieNode {\\npublic: \\n    TrieNode* children[26] = {nullptr}; \\n    bool word = false; \\n    ~TrieNode() {\\n        for (auto& child : children) \\n            delete child; \\n    }\\n}; \\n\\nclass Trie {\\n    TrieNode* root = nullptr; \\npublic: \\n    Trie() { root = new TrieNode(); }\\n    \\n    ~Trie() { delete root; }\\n    \\n    void insert(string word) {\\n        TrieNode* node = root; \\n        for (int i = word.size()-1; i >= 0; --i) {\\n            if (!node->children[word[i] - \\'a\\'])\\n                node->children[word[i] - \\'a\\'] = new TrieNode(); \\n            node = node->children[word[i] - \\'a\\']; \\n        }\\n        node->word = true; \\n    }\\n    \\n    bool search(string word) {\\n        vector<bool> dp(1 + word.size()); \\n        dp[0] = true; \\n        for (int i = 0; i < word.size(); ++i) {\\n            TrieNode* node = root; \\n            for (int j = i; j >= 0; --j) {\\n                if (!node->children[word[j] - \\'a\\']) break; \\n                node = node->children[word[j] - \\'a\\']; \\n                if (dp[j] && node->word) {\\n                    dp[i+1] = true; \\n                    break; \\n                }\\n            }\\n        }\\n        return dp.back(); \\n    }\\n}; \\n\\n\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(), words.end(), [](const string& w1, const string& w2) { return (w1.size() < w2.size()); });\\n        vector<string> ans;\\n        \\n        Trie* trie = new Trie(); \\n        for (auto& word : words) \\n            if (word.size()) {\\n                if (trie->search(word)) ans.push_back(word); \\n                trie->insert(word); \\n            }\\n        \\n        delete trie; \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463933,
                "title": "python3-hash",
                "content": "\\n```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        seen = set(words)\\n        \\n        @cache\\n        def fn(word):\\n            \"\"\"Return True if input is a concatenated word.\"\"\"\\n            for i in range(1, len(word)): \\n                prefix = word[:i]\\n                suffix = word[i:]\\n                if prefix in seen and (suffix in seen or fn(suffix)): return True \\n            return False \\n        \\n        ans = []\\n        for word in words: \\n            if fn(word): ans.append(word)\\n        return ans \\n```\\n\\n```\\nclass Trie: \\n    \\n    def __init__(self): \\n        self.root = {}\\n        \\n    def insert(self, word): \\n        node = self.root\\n        for ch in reversed(word): \\n            node = node.setdefault(ch, {})\\n        node[\"#\"] = True\\n        \\n    def search(self, word): \\n        \"\"\"Return True if input is a concatenated word.\"\"\"\\n        dp = [True] + [False] * len(word)\\n        for i in range(len(word)): \\n            node = self.root\\n            for j in reversed(range(i+1)): \\n                if word[j] not in node: break \\n                node = node[word[j]]\\n                if dp[j] and node.get(\"#\"):\\n                    dp[i+1] = True \\n                    break \\n        return dp[-1]\\n\\n\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        ans = []\\n        trie = Trie()\\n        for word in sorted(words, key=len): \\n            if word: \\n                if trie.search(word): ans.append(word)\\n                trie.insert(word)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        seen = set(words)\\n        \\n        @cache\\n        def fn(word):\\n            \"\"\"Return True if input is a concatenated word.\"\"\"\\n            for i in range(1, len(word)): \\n                prefix = word[:i]\\n                suffix = word[i:]\\n                if prefix in seen and (suffix in seen or fn(suffix)): return True \\n            return False \\n        \\n        ans = []\\n        for word in words: \\n            if fn(word): ans.append(word)\\n        return ans \\n```\n```\\nclass Trie: \\n    \\n    def __init__(self): \\n        self.root = {}\\n        \\n    def insert(self, word): \\n        node = self.root\\n        for ch in reversed(word): \\n            node = node.setdefault(ch, {})\\n        node[\"#\"] = True\\n        \\n    def search(self, word): \\n        \"\"\"Return True if input is a concatenated word.\"\"\"\\n        dp = [True] + [False] * len(word)\\n        for i in range(len(word)): \\n            node = self.root\\n            for j in reversed(range(i+1)): \\n                if word[j] not in node: break \\n                node = node[word[j]]\\n                if dp[j] and node.get(\"#\"):\\n                    dp[i+1] = True \\n                    break \\n        return dp[-1]\\n\\n\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        ans = []\\n        trie = Trie()\\n        for word in sorted(words, key=len): \\n            if word: \\n                if trie.search(word): ans.append(word)\\n                trie.insert(word)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451267,
                "title": "two-approaches-1-memo-dfs-2-dp",
                "content": "Memo + DFS:\\n```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        wordSet = set(words)\\n        rv = []\\n        for wd in words:\\n            memo = {}\\n            wordSet.remove(wd)\\n            if len(wd) > 0 and self.dfs(wd, wordSet, memo):\\n                rv.append(wd)\\n            wordSet.add(wd)    \\n        return rv\\n    \\n    def dfs(self, s, wordSet, memo):\\n        if len(s) == 0:\\n            return True\\n        \\n        if s in memo:\\n            return memo[s]\\n        \\n        result = False\\n        nw = \\'\\'\\n        for c in s:\\n            nw += c\\n            if nw in wordSet and self.dfs(s[len(nw):], wordSet, memo):\\n                result = True\\n                break\\n        \\n        memo[s] = result\\n        return result \\n```\\t\\t\\n\\t\\nDP:\\n```\\n\\tclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        wordSet = set(words)\\n        rv = []\\n        for wd in words:\\n            if len(wd) == 0:\\n                continue\\n            wordSet.remove(wd)\\n            dp = [False for _ in range(len(wd)+1)]\\n            dp[0] = True\\n            for i in range(len(wd)):\\n                for j in range(i+1, len(wd)+1):\\n                    ss = wd[i:j]\\n                    if ss in wordSet and dp[i]:\\n                        dp[j] = True\\n            wordSet.add(wd)\\n            if dp[len(wd)]:\\n                rv.append(wd)\\n        return rv\\n```\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        wordSet = set(words)\\n        rv = []\\n        for wd in words:\\n            memo = {}\\n            wordSet.remove(wd)\\n            if len(wd) > 0 and self.dfs(wd, wordSet, memo):\\n                rv.append(wd)\\n            wordSet.add(wd)    \\n        return rv\\n    \\n    def dfs(self, s, wordSet, memo):\\n        if len(s) == 0:\\n            return True\\n        \\n        if s in memo:\\n            return memo[s]\\n        \\n        result = False\\n        nw = \\'\\'\\n        for c in s:\\n            nw += c\\n            if nw in wordSet and self.dfs(s[len(nw):], wordSet, memo):\\n                result = True\\n                break\\n        \\n        memo[s] = result\\n        return result \\n```\n```\\n\\tclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        wordSet = set(words)\\n        rv = []\\n        for wd in words:\\n            if len(wd) == 0:\\n                continue\\n            wordSet.remove(wd)\\n            dp = [False for _ in range(len(wd)+1)]\\n            dp[0] = True\\n            for i in range(len(wd)):\\n                for j in range(i+1, len(wd)+1):\\n                    ss = wd[i:j]\\n                    if ss in wordSet and dp[i]:\\n                        dp[j] = True\\n            wordSet.add(wd)\\n            if dp[len(wd)]:\\n                rv.append(wd)\\n        return rv\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318752,
                "title": "c-dp-solution",
                "content": "```\\npublic class Solution {\\n    public IList<string> FindAllConcatenatedWordsInADict(string[] words) {\\n        \\n        List<string> res = new List<string>();\\n        if(words == null || words.Length == 0)\\n            return res;\\n      \\n        HashSet<string> wordSet = new HashSet<string>();\\n        Array.Sort(words, (a,b) => a.Length - b.Length);\\n        foreach(var word in words)\\n        {\\n            if(IsConcatenated(word, wordSet))\\n                res.Add(word);\\n            \\n            wordSet.Add(word);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public bool IsConcatenated(string word, HashSet<string> wordSet)\\n    {\\n        if(wordSet.Count == 0)\\n            return false;\\n        \\n        bool[] dp = new bool[word.Length + 1];\\n        dp[0] = true;\\n        \\n        // check substrings starting with length 1 for current word\\n        for(int i = 1; i <= word.Length; i++)\\n        {\\n            // check if the substring is concatenated\\n            // divide the substring into 2 parts, the 1st part has length j\\n            for(int j = 0; j < i; j++)\\n            {                \\n                if(dp[j] && wordSet.Contains(word.Substring(j, i - j)))\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[word.Length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> FindAllConcatenatedWordsInADict(string[] words) {\\n        \\n        List<string> res = new List<string>();\\n        if(words == null || words.Length == 0)\\n            return res;\\n      \\n        HashSet<string> wordSet = new HashSet<string>();\\n        Array.Sort(words, (a,b) => a.Length - b.Length);\\n        foreach(var word in words)\\n        {\\n            if(IsConcatenated(word, wordSet))\\n                res.Add(word);\\n            \\n            wordSet.Add(word);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public bool IsConcatenated(string word, HashSet<string> wordSet)\\n    {\\n        if(wordSet.Count == 0)\\n            return false;\\n        \\n        bool[] dp = new bool[word.Length + 1];\\n        dp[0] = true;\\n        \\n        // check substrings starting with length 1 for current word\\n        for(int i = 1; i <= word.Length; i++)\\n        {\\n            // check if the substring is concatenated\\n            // divide the substring into 2 parts, the 1st part has length j\\n            for(int j = 0; j < i; j++)\\n            {                \\n                if(dp[j] && wordSet.Contains(word.Substring(j, i - j)))\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[word.Length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084496,
                "title": "java-dfs-similar-to-word-break",
                "content": "\\n\\t// O(log(words.length*log(words.length)) + O(words.length*words[i].length^2))\\n\\tpublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n\\n\\t\\tList<String> res = new ArrayList<String>();\\n\\t\\tif (words.length == 1)\\n\\t\\t\\treturn res;\\n\\n\\t\\tArrays.sort(words, new Comparator<String>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(String o1, String o2) {\\n\\t\\t\\t\\treturn o1.length() - o2.length();\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tHashSet<String> dict = new HashSet<String>();\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tif (word.length() != 0 && wordBreak(word, dict))\\n\\t\\t\\t\\tres.add(word);\\n\\t\\t\\tdict.add(word);\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\t// O(s.length^2)\\n\\tpublic boolean wordBreak(String s, HashSet<String> dict) {\\n\\t\\tint[] memo = new int[s.length()];\\n\\t\\tint len = s.length();\\n\\t\\treturn wordBreakDFS(len - 1, s, dict, memo);\\n\\t}\\n\\n\\t// O(s.length^2)\\n\\tpublic boolean wordBreakDFS(int start, String s, HashSet<String> dict, int[] memo) {\\n\\n\\t\\tif (start == -1)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (memo[start] == 1)\\n\\t\\t\\treturn false;\\n\\n\\t\\tboolean ans = false;\\n\\t\\tfor (int i = start; i >= 0; i--) {\\n\\t\\t\\tif (dict.contains(s.substring(i, start + 1))) {\\n\\t\\t\\t\\tans = wordBreakDFS(i - 1, s, dict, memo);\\n\\t\\t\\t\\tif (ans)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmemo[start] = 1;\\n\\t\\treturn false;\\n\\t}\\n\\n",
                "solutionTags": [],
                "code": "\\n\\t// O(log(words.length*log(words.length)) + O(words.length*words[i].length^2))\\n\\tpublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n\\n\\t\\tList<String> res = new ArrayList<String>();\\n\\t\\tif (words.length == 1)\\n\\t\\t\\treturn res;\\n\\n\\t\\tArrays.sort(words, new Comparator<String>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(String o1, String o2) {\\n\\t\\t\\t\\treturn o1.length() - o2.length();\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tHashSet<String> dict = new HashSet<String>();\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tif (word.length() != 0 && wordBreak(word, dict))\\n\\t\\t\\t\\tres.add(word);\\n\\t\\t\\tdict.add(word);\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\t// O(s.length^2)\\n\\tpublic boolean wordBreak(String s, HashSet<String> dict) {\\n\\t\\tint[] memo = new int[s.length()];\\n\\t\\tint len = s.length();\\n\\t\\treturn wordBreakDFS(len - 1, s, dict, memo);\\n\\t}\\n\\n\\t// O(s.length^2)\\n\\tpublic boolean wordBreakDFS(int start, String s, HashSet<String> dict, int[] memo) {\\n\\n\\t\\tif (start == -1)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (memo[start] == 1)\\n\\t\\t\\treturn false;\\n\\n\\t\\tboolean ans = false;\\n\\t\\tfor (int i = start; i >= 0; i--) {\\n\\t\\t\\tif (dict.contains(s.substring(i, start + 1))) {\\n\\t\\t\\t\\tans = wordBreakDFS(i - 1, s, dict, memo);\\n\\t\\t\\t\\tif (ans)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tmemo[start] = 1;\\n\\t\\treturn false;\\n\\t}\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 511642,
                "title": "python-trie-memo-simple",
                "content": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words):\\n        t, memo, res = Trie(), {}, []\\n        for word in words:\\n            t.add(word)\\n        for word in words:\\n            if t.helper(word, 0, len(word) - 1, 0, memo):\\n                res.append(word)\\n        return res\\n\\n\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_end = False\\n\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node()\\n\\n    def add(self, word):\\n        p = self.root\\n        for c in word:\\n            if c not in p.children:\\n                p.children[c] = Node()\\n            p = p.children[c]\\n        p.is_end = True\\n\\n\\n    def helper(self, word, st, end, cnt, memo):\\n        p = self.root\\n        curr = word[st: end + 1]\\n        if curr in memo: \\n            return memo[curr]\\n        \\n        for x in range(st, end + 1):\\n            if word[x] in p.children:\\n                p = p.children[word[x]]\\n                if p.is_end:\\n                    if x == end:\\n                        return cnt >= 1\\n                    if self.helper(word, x + 1, end, cnt + 1, memo):\\n                        memo[curr] = True\\n                        return True\\n            else:\\n                break\\n                \\n        memo[curr] = False\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words):\\n        t, memo, res = Trie(), {}, []\\n        for word in words:\\n            t.add(word)\\n        for word in words:\\n            if t.helper(word, 0, len(word) - 1, 0, memo):\\n                res.append(word)\\n        return res\\n\\n\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_end = False\\n\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node()\\n\\n    def add(self, word):\\n        p = self.root\\n        for c in word:\\n            if c not in p.children:\\n                p.children[c] = Node()\\n            p = p.children[c]\\n        p.is_end = True\\n\\n\\n    def helper(self, word, st, end, cnt, memo):\\n        p = self.root\\n        curr = word[st: end + 1]\\n        if curr in memo: \\n            return memo[curr]\\n        \\n        for x in range(st, end + 1):\\n            if word[x] in p.children:\\n                p = p.children[word[x]]\\n                if p.is_end:\\n                    if x == end:\\n                        return cnt >= 1\\n                    if self.helper(word, x + 1, end, cnt + 1, memo):\\n                        memo[curr] = True\\n                        return True\\n            else:\\n                break\\n                \\n        memo[curr] = False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 435078,
                "title": "python-dp-simple-solution-with-3-lines",
                "content": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        s = set(words)\\n        \\n        memo = {}\\n        def isConcatenatedWord(w):\\n            if w in memo: return memo[w]\\n            \\n            for i in range(1, len(w)):\\n                if w[:i] not in s: continue\\n                \\n                r = w[i:]\\n                if r in s or isConcatenatedWord(r):\\n                    memo[w] = True\\n                    return True\\n                \\n            memo[w] = False\\n            return False\\n        \\n        return filter(isConcatenatedWord, words)\\n```\\n\\n3 lines Solution :P\\n```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        s, m = set(words), {}\\n        dp = lambda w: m[w] if w in m else any(w[:i] in s and (w[i:] in s or dp(w[i:])) for i in range(1, len(w)))\\n        return filter(dp, words)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        s = set(words)\\n        \\n        memo = {}\\n        def isConcatenatedWord(w):\\n            if w in memo: return memo[w]\\n            \\n            for i in range(1, len(w)):\\n                if w[:i] not in s: continue\\n                \\n                r = w[i:]\\n                if r in s or isConcatenatedWord(r):\\n                    memo[w] = True\\n                    return True\\n                \\n            memo[w] = False\\n            return False\\n        \\n        return filter(isConcatenatedWord, words)\\n```\n```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        s, m = set(words), {}\\n        dp = lambda w: m[w] if w in m else any(w[:i] in s and (w[i:] in s or dp(w[i:])) for i in range(1, len(w)))\\n        return filter(dp, words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409083,
                "title": "python-naive-solution-beats-99-and-100",
                "content": "```\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        words = set(words)\\n\\t\\t\\n        def is_concatenated(word):\\n            for i in range(1, len(word)):\\n                if word[:i] in words and (word[i:] in words or is_concatenated(word[i:])):\\n                    return True\\n            return False\\n        \\n        return [word for word in words if is_concatenated(word)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        words = set(words)\\n\\t\\t\\n        def is_concatenated(word):\\n            for i in range(1, len(word)):\\n                if word[:i] in words and (word[i:] in words or is_concatenated(word[i:])):\\n                    return True\\n            return False\\n        \\n        return [word for word in words if is_concatenated(word)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398560,
                "title": "very-simple-and-clean-solutions-on-java-2-approaches",
                "content": "\\n\\tApproach #1 Backtracking:\\n    \\n\\tpublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n      Set<String> hash = new HashSet<>(Arrays.asList(words));\\n\\n      List<String> list = new ArrayList<>();\\n      for (String word : words) {\\n        if (concatenated(word, 0, hash)) {\\n          list.add(word);\\n        }\\n      }\\n\\n      return list;\\n    }\\n\\n    private boolean concatenated(String word, int i, Set<String> words) {\\n      StringBuilder sb = new StringBuilder();\\n\\n      for (int k = i; k < word.length(); k++) {\\n        sb.append(word.charAt(k));\\n        if (words.contains(sb.toString())) {\\n          if (concatenated(word, k + 1, words)) {\\n            return true;\\n          }\\n        }\\n      }\\n\\n      return sb.length() > 0 && sb.length() < word.length() && words.contains(sb.toString());\\n    }\\n\\t\\n\\tApproach #2 Trie + DFS:\\n\\t\\n\\tpublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n      Trie trie = new Trie();\\n\\n      for (String word : words) {\\n        trie.addWord(word);\\n      }\\n\\n      List<String> solution = new ArrayList<>();\\n\\n      for (String word : words) {\\n        if (isConcatenated(trie.root, word, 0)) {\\n          solution.add(word);\\n        }\\n      }\\n\\n      return solution;\\n    }\\n\\n    private boolean isConcatenated(TrieNode root, String word, int index) {\\n      int counter = 0;\\n\\n      TrieNode node = root;\\n\\n      for (int i = index; i < word.length(); i++) {\\n        counter++;\\n\\n        char ch = word.charAt(i);\\n\\n        if (!node.map.containsKey(ch)) {\\n          return false;\\n        }\\n\\n        node = node.map.get(ch);\\n        if (node.isWord) {\\n          if (i == word.length() - 1 && counter < word.length()) {\\n            return true;\\n          } else if (i < word.length() - 1 && isConcatenated(root, word, i + 1)) {\\n            return true;\\n          }\\n        }\\n      }\\n\\n      return false;\\n    }\\n\\n    private static class Trie {\\n      private TrieNode root = new TrieNode();\\n\\n      private void addWord(String word) {\\n        TrieNode node = root;\\n\\n        for (int i = 0; i < word.length(); i++) {\\n          char ch = word.charAt(i);\\n\\n          if (node.map.containsKey(ch)) {\\n            node = node.map.get(ch);\\n          } else {\\n            node.map.put(ch, new TrieNode());\\n            node = node.map.get(ch);\\n          }\\n        }\\n\\n        node.isWord = true;\\n      }\\n    }\\n\\n    private static class TrieNode {\\n      Map<Character, TrieNode> map = new HashMap<>();\\n      boolean isWord = false;\\n    }",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "\\n\\tApproach #1 Backtracking:\\n    \\n\\tpublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n      Set<String> hash = new HashSet<>(Arrays.asList(words));\\n\\n      List<String> list = new ArrayList<>();\\n      for (String word : words) {\\n        if (concatenated(word, 0, hash)) {\\n          list.add(word);\\n        }\\n      }\\n\\n      return list;\\n    }\\n\\n    private boolean concatenated(String word, int i, Set<String> words) {\\n      StringBuilder sb = new StringBuilder();\\n\\n      for (int k = i; k < word.length(); k++) {\\n        sb.append(word.charAt(k));\\n        if (words.contains(sb.toString())) {\\n          if (concatenated(word, k + 1, words)) {\\n            return true;\\n          }\\n        }\\n      }\\n\\n      return sb.length() > 0 && sb.length() < word.length() && words.contains(sb.toString());\\n    }\\n\\t\\n\\tApproach #2 Trie + DFS:\\n\\t\\n\\tpublic List<String> findAllConcatenatedWordsInADict(String[] words) {\\n      Trie trie = new Trie();\\n\\n      for (String word : words) {\\n        trie.addWord(word);\\n      }\\n\\n      List<String> solution = new ArrayList<>();\\n\\n      for (String word : words) {\\n        if (isConcatenated(trie.root, word, 0)) {\\n          solution.add(word);\\n        }\\n      }\\n\\n      return solution;\\n    }\\n\\n    private boolean isConcatenated(TrieNode root, String word, int index) {\\n      int counter = 0;\\n\\n      TrieNode node = root;\\n\\n      for (int i = index; i < word.length(); i++) {\\n        counter++;\\n\\n        char ch = word.charAt(i);\\n\\n        if (!node.map.containsKey(ch)) {\\n          return false;\\n        }\\n\\n        node = node.map.get(ch);\\n        if (node.isWord) {\\n          if (i == word.length() - 1 && counter < word.length()) {\\n            return true;\\n          } else if (i < word.length() - 1 && isConcatenated(root, word, i + 1)) {\\n            return true;\\n          }\\n        }\\n      }\\n\\n      return false;\\n    }\\n\\n    private static class Trie {\\n      private TrieNode root = new TrieNode();\\n\\n      private void addWord(String word) {\\n        TrieNode node = root;\\n\\n        for (int i = 0; i < word.length(); i++) {\\n          char ch = word.charAt(i);\\n\\n          if (node.map.containsKey(ch)) {\\n            node = node.map.get(ch);\\n          } else {\\n            node.map.put(ch, new TrieNode());\\n            node = node.map.get(ch);\\n          }\\n        }\\n\\n        node.isWord = true;\\n      }\\n    }\\n\\n    private static class TrieNode {\\n      Map<Character, TrieNode> map = new HashMap<>();\\n      boolean isWord = false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 347648,
                "title": "c-hashset-wordbreak",
                "content": "```\\npublic class Solution {\\n    public IList<string> FindAllConcatenatedWordsInADict(string[] words) {\\n        var result = new List<string>();\\n        if (words.Length <= 2) return result;\\n\\n        var wordSet = new HashSet<string>(words);\\n        foreach (var word in words) {\\n            if (word == \"\") continue;\\n\\n            wordSet.Remove(word);\\n\\n            var canBreak = WordBreak(word, wordSet);\\n\\n            if (canBreak) result.Add(word);\\n            wordSet.Add(word);\\n        }\\n\\n        return result;\\n    }\\n\\n    private bool WordBreak(string s, HashSet<string> dict) {\\n        if (s.Length == 0) return false;\\n\\n        var n = s.Length;\\n        var dp = new bool[n + 1];\\n        dp[n] = true;\\n\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = i; j < n; ++j) {\\n                if (dp[j + 1] && dict.Contains(s.Substring(i, j - i + 1))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> FindAllConcatenatedWordsInADict(string[] words) {\\n        var result = new List<string>();\\n        if (words.Length <= 2) return result;\\n\\n        var wordSet = new HashSet<string>(words);\\n        foreach (var word in words) {\\n            if (word == \"\") continue;\\n\\n            wordSet.Remove(word);\\n\\n            var canBreak = WordBreak(word, wordSet);\\n\\n            if (canBreak) result.Add(word);\\n            wordSet.Add(word);\\n        }\\n\\n        return result;\\n    }\\n\\n    private bool WordBreak(string s, HashSet<string> dict) {\\n        if (s.Length == 0) return false;\\n\\n        var n = s.Length;\\n        var dp = new bool[n + 1];\\n        dp[n] = true;\\n\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = i; j < n; ++j) {\\n                if (dp[j + 1] && dict.Contains(s.Substring(i, j - i + 1))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95700,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        word_set = set(words)\\n        ans = []\\n        def helper(w, cur, cnt):\\n            if cur == len(w):\\n                if cnt > 1:\\n                    return True\\n                else:\\n                    return False\\n            for i in xrange(cur + 1, len(w) + 1):\\n                if w[cur : i] in word_set and helper(w, i, cnt + 1):\\n                    return True\\n            return False\\n        for w in words:\\n            if helper(w, 0, 0):\\n                ans.append(w)\\n        return ans\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        word_set = set(words)\\n        ans = []\\n        def helper(w, cur, cnt):\\n            if cur == len(w):\\n                if cnt > 1:\\n                    return True\\n                else:\\n                    return False\\n            for i in xrange(cur + 1, len(w) + 1):\\n                if w[cur : i] in word_set and helper(w, i, cnt + 1):\\n                    return True\\n            return False\\n        for w in words:\\n            if helper(w, 0, 0):\\n                ans.append(w)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104507,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> st(words.begin(), words.end());\\n        vector<string> ans;\\n        unordered_map<string, int> mp;\\n        for(string s:st)\\n        mp[s]++;\\n        for(string s:st)\\n        {\\n            int n=s.size();\\n            vector<bool> dp(n+1);\\n            dp[0]=true;\\n            for(int i=1;i<=n;i++)\\n            {\\n                for(int j=0;j<i;j++)\\n                {\\n                    if(dp[j])\\n                    {\\n                        string sub=s.substr(j, i-j);\\n                        if(mp.find(sub)!=mp.end() && sub!=s)\\n                        {\\n                            dp[i]=true;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(dp[n])\\n                ans.push_back(s);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> st(words.begin(), words.end());\\n        vector<string> ans;\\n        unordered_map<string, int> mp;\\n        for(string s:st)\\n        mp[s]++;\\n        for(string s:st)\\n        {\\n            int n=s.size();\\n            vector<bool> dp(n+1);\\n            dp[0]=true;\\n            for(int i=1;i<=n;i++)\\n            {\\n                for(int j=0;j<i;j++)\\n                {\\n                    if(dp[j])\\n                    {\\n                        string sub=s.substr(j, i-j);\\n                        if(mp.find(sub)!=mp.end() && sub!=s)\\n                        {\\n                            dp[i]=true;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(dp[n])\\n                ans.push_back(s);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104289,
                "title": "c-recursion-memoization-very-easy-approach-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursion\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- store all strings in set to find it in fast.\\n- traverse on each word\\n      - check if it can func(concat) or not\\n      - push in ans\\n\\n\\n## concat function\\n- traverse on each char of word\\n- pick up prefix string \\n- check if (curr string (0,idx) is present in set && prefix string is present || call concat function on prefix).\\n        - if yes return true\\n- after end of loop return false bcz we not find 2 or more words in that word.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(exponential)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*max.word.length) + O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nbool isConcat(string word,unordered_set<string>& st){\\n    int n = word.size();\\n    for(int i=1;i<n;i++){\\n        string prefix = word.substr(i);\\n        if(st.count(word.substr(0,i))&&(st.count(prefix)||isConcat(prefix,st)))return true;\\n    }\\n    return false;\\n}\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        if(words.size()==0)return {};\\n        unordered_set<string> st;\\n        vector<string> ans;\\n        for(auto word:words)st.insert(word);\\n        for(auto word:words){\\n            if(isConcat(word,st))ans.push_back(word);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- just apply memoization on Upper solution.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*(max.len.word)^3)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*max.word.length) + O(n)$$\\n\\n# Code\\n\\n```\\nclass Solution {\\nprivate:\\nbool isConcat(string word,unordered_set<string>& st,unordered_map<string,bool>& mp){\\n    int n = word.size();\\n    if(mp.count(word))return mp[word];\\n    for(int i=1;i<n;i++){\\n        string prefix = word.substr(i);\\n        if(st.count(word.substr(0,i))&&(st.count(prefix)||isConcat(prefix,st,mp)))return mp[word] = true;\\n    }\\n    return mp[word] = false;\\n}\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        if(words.size()==0)return {};\\n        unordered_set<string> st;\\n        unordered_map<string,bool> mp;\\n        vector<string> ans;\\n        for(auto word:words)st.insert(word);\\n        for(auto word:words){\\n            if(isConcat(word,st,mp))ans.push_back(word);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nbool isConcat(string word,unordered_set<string>& st){\\n    int n = word.size();\\n    for(int i=1;i<n;i++){\\n        string prefix = word.substr(i);\\n        if(st.count(word.substr(0,i))&&(st.count(prefix)||isConcat(prefix,st)))return true;\\n    }\\n    return false;\\n}\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        if(words.size()==0)return {};\\n        unordered_set<string> st;\\n        vector<string> ans;\\n        for(auto word:words)st.insert(word);\\n        for(auto word:words){\\n            if(isConcat(word,st))ans.push_back(word);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\nbool isConcat(string word,unordered_set<string>& st,unordered_map<string,bool>& mp){\\n    int n = word.size();\\n    if(mp.count(word))return mp[word];\\n    for(int i=1;i<n;i++){\\n        string prefix = word.substr(i);\\n        if(st.count(word.substr(0,i))&&(st.count(prefix)||isConcat(prefix,st,mp)))return mp[word] = true;\\n    }\\n    return mp[word] = false;\\n}\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        if(words.size()==0)return {};\\n        unordered_set<string> st;\\n        unordered_map<string,bool> mp;\\n        vector<string> ans;\\n        for(auto word:words)st.insert(word);\\n        for(auto word:words){\\n            if(isConcat(word,st,mp))ans.push_back(word);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104059,
                "title": "partition-dp-solution-c-easy-understanding",
                "content": "\\n\\n**T.C : O(n*s[i].length)\\nS.C : O(n * s[i].length)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> mp;\\n    // dp[i] = number of ways to partition strings such that each substring is in the words;\\n    int rec(string &s,int n,int i,vector<int> &dp){\\n        if(i>=n) return true;\\n        if(dp[i]!=-1) return dp[i];\\n        dp[i] = 0;\\n        for(int j=i;j<n;j++){\\n            string tmp = s.substr(i,j-i+1);\\n            if(mp.count(tmp)){ // if substring is in words.\\n                dp[i] += rec(s,n,j+1,dp);\\n            }\\n        }\\n        return dp[i];\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words){\\n        mp.clear();\\n        vector<string> ans;\\n        for(auto &ele:words) mp.insert(ele);\\n        for(auto &ele:words){\\n            vector<int> dp(ele.size()+1,-1);\\n            int ways = rec(ele,ele.size(),0,dp);\\n            if(ways>1){ // we can always partition whole string so that way is not considered.\\n                ans.push_back(ele);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you like the solution !!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> mp;\\n    // dp[i] = number of ways to partition strings such that each substring is in the words;\\n    int rec(string &s,int n,int i,vector<int> &dp){\\n        if(i>=n) return true;\\n        if(dp[i]!=-1) return dp[i];\\n        dp[i] = 0;\\n        for(int j=i;j<n;j++){\\n            string tmp = s.substr(i,j-i+1);\\n            if(mp.count(tmp)){ // if substring is in words.\\n                dp[i] += rec(s,n,j+1,dp);\\n            }\\n        }\\n        return dp[i];\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words){\\n        mp.clear();\\n        vector<string> ans;\\n        for(auto &ele:words) mp.insert(ele);\\n        for(auto &ele:words){\\n            vector<int> dp(ele.size()+1,-1);\\n            int ways = rec(ele,ele.size(),0,dp);\\n            if(ways>1){ // we can always partition whole string so that way is not considered.\\n                ans.push_back(ele);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103854,
                "title": "clean-optimized-code-commented",
                "content": "```\\nclass Solution {\\npublic:\\n     bool check(string word, unordered_set<string>& dict, unordered_map<string, bool> &ump){\\n        if(ump.find(word) !=  ump.end()) return ump[word];\\n        for(int i = 1 ; i < word.size() ; ++i) {\\n            string substring = word.substr(0, i); // check for every substring\\n            if(dict.count(substring)) { // if substring is pre-stored\\n                string nextpart = word.substr(i); // the rest substring\\n                if(dict.count(nextpart) || check(nextpart, dict, ump)) // check if the next substring is been there in our map already or using the next part we can do the same operation(recursive call) and is possible\\n                {\\n                    ump.insert({word, true});\\n                    return true;\\n                }\\n            }\\n        }\\n       ump.insert({word, false});\\n       return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> res;\\n        unordered_set<string> dict(words.begin(), words.end()); // let\\'s remove duplicate words first\\n        unordered_map<string, bool> mp;\\n        for(string word : words)\\n            if(check(word, dict, mp)) res.push_back(word);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool check(string word, unordered_set<string>& dict, unordered_map<string, bool> &ump){\\n        if(ump.find(word) !=  ump.end()) return ump[word];\\n        for(int i = 1 ; i < word.size() ; ++i) {\\n            string substring = word.substr(0, i); // check for every substring\\n            if(dict.count(substring)) { // if substring is pre-stored\\n                string nextpart = word.substr(i); // the rest substring\\n                if(dict.count(nextpart) || check(nextpart, dict, ump)) // check if the next substring is been there in our map already or using the next part we can do the same operation(recursive call) and is possible\\n                {\\n                    ump.insert({word, true});\\n                    return true;\\n                }\\n            }\\n        }\\n       ump.insert({word, false});\\n       return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> res;\\n        unordered_set<string> dict(words.begin(), words.end()); // let\\'s remove duplicate words first\\n        unordered_map<string, bool> mp;\\n        for(string word : words)\\n            if(check(word, dict, mp)) res.push_back(word);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103616,
                "title": "go-easy-to-understand-o-n-2-approach",
                "content": "# Complexity\\n- Time complexity: O(n^2*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc findAllConcatenatedWordsInADict(words []string) []string {\\n    s := make(map[string]bool)\\n    concatenateWords := []string{}\\n    for _, word := range words {\\n        s[word] = true\\n    }\\n    for _, word := range words {\\n        if checkConcatenate(word, s) {\\n            concatenateWords = append(concatenateWords, word)\\n        }\\n    }\\n    return concatenateWords\\n}\\n\\nfunc checkConcatenate(word string, s map[string]bool) bool {\\n    for i := 1; i < len(word); i++ {\\n        prefixWord := word[:i]\\n        suffixWord := word[i:]\\n        if s[prefixWord] && (s[suffixWord] || checkConcatenate(suffixWord, s)) {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findAllConcatenatedWordsInADict(words []string) []string {\\n    s := make(map[string]bool)\\n    concatenateWords := []string{}\\n    for _, word := range words {\\n        s[word] = true\\n    }\\n    for _, word := range words {\\n        if checkConcatenate(word, s) {\\n            concatenateWords = append(concatenateWords, word)\\n        }\\n    }\\n    return concatenateWords\\n}\\n\\nfunc checkConcatenate(word string, s map[string]bool) bool {\\n    for i := 1; i < len(word); i++ {\\n        prefixWord := word[:i]\\n        suffixWord := word[i:]\\n        if s[prefixWord] && (s[suffixWord] || checkConcatenate(suffixWord, s)) {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3103614,
                "title": "python3-sort-and-use-trie",
                "content": "If there is word whose substrings are already in array, the length of each substring would be <= len(word) itself. Here is the logic below. \\n1. Sort the array based on length of word.\\n2. Identify if trie contains already a list of words that make up the word we are looking for using recursion. \\n3. If (2) is true, add the word to list ans.\\n4. Regardless of (3) add the word to the trie and mark the end of a word by using \\'#\\'\\n\\n```\\nclass Solution:\\n    def check(self, trie, word, widx):\\n        if widx == len(word): \\n            return True\\n        \\n        t = trie\\n        ret = False\\n        \\n        for cidx in range(widx, len(word)):\\n            if word[cidx] in t:\\n                t = t[word[cidx]]\\n            else: \\n                return False \\n            \\n            if \\'#\\' in t: \\n                ret |= self.check(trie, word, cidx+1)\\n                \\n            if ret: \\n                return ret\\n                \\n        return ret\\n    \\n    def insert(self, word, trie):\\n        t = trie\\n        for c in word:\\n            if c not in t:\\n                t[c] = {}\\n                \\n            t = t[c]\\n        t[\\'#\\'] = {}\\n            \\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        words.sort(key=lambda x: len(x))\\n        t = {}\\n        ans = []\\n        for w in words:\\n            if self.check(t, w, 0):\\n                ans.append(w)\\n            self.insert(w, t)\\n            \\n        return ans\\n",
                "solutionTags": [
                    "Python3",
                    "Trie",
                    "Recursion"
                ],
                "code": "class Solution:\\n    def check(self, trie, word, widx):\\n        if widx == len(word): \\n            return True\\n        \\n        t = trie\\n        ret = False\\n        \\n        for cidx in range(widx, len(word)):\\n            if word[cidx] in t:\\n                t = t[word[cidx]]\\n            else: \\n                return False \\n            \\n            if \\'#\\' in t: \\n                ret |= self.check(trie, word, cidx+1)\\n                \\n            if ret: \\n                return ret\\n                \\n        return ret\\n    \\n    def insert(self, word, trie):\\n        t = trie\\n        for c in word:\\n            if c not in t:\\n                t[c] = {}",
                "codeTag": "Java"
            },
            {
                "id": 3103609,
                "title": "python-short-brute-force-85-time",
                "content": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        # Check if current word can be made from smaller words\\n        def check(word):\\n            if word in s:\\n                return True\\n            # If prefix is seen, recurse on rest of word\\n            return any(check(word[i:]) for i in range(1, len(word)) if word[:i] in s)\\n        \\n        s = set()\\n        res = []\\n        for word in sorted(words, key=lambda x:len(x)):\\n            if check(word):\\n                res.append(word)\\n            s.add(word)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        # Check if current word can be made from smaller words\\n        def check(word):\\n            if word in s:\\n                return True\\n            # If prefix is seen, recurse on rest of word\\n            return any(check(word[i:]) for i in range(1, len(word)) if word[:i] in s)\\n        \\n        s = set()\\n        res = []\\n        for word in sorted(words, key=lambda x:len(x)):\\n            if check(word):\\n                res.append(word)\\n            s.add(word)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3103581,
                "title": "python-straightforward-brute-force-solution-without-memoization-trie-dfs-bfs",
                "content": "A simple brute-force solution without memoization works for me. The algorithm is straightforward:\\n1. Construct a dictionary/hashmap of words to enable O(1) lookup.\\n2. For each word, check if the given word is concatenated:\\n    - Start with an empty subword\\n    - For each character `word[i]` in the given word, append the character to the end of the subword\\n    - If you can find the subword in the dictionary of words we previously created, recurse to check if `word[i + 1:]` (the rest of the word) is a concatenated word\\n    - Maintain the count of subwords found so far\\n    - Recursion terminates when you reach the end of the word and the count of subwords is at least two\\n3. Return the list of found concatenated words.\\n\\nHere is the code for the above algorithm:\\n\\n```python\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def is_concatenated(word, count):\\n            if word == \"\" and count >= 2:\\n                return True\\n            \\n            subword = \"\"\\n            for i in range(len(word)):\\n                subword += word[i] # append char to the end of the subword\\n                if subword in self.words_dict:\\n                    if is_concatenated(word[i + 1:], count + 1):\\n                        return True\\n\\n            # nothing found at this point\\n            return False\\n        \\n        # construct a dict of words to enable O(1) lookup\\n        self.words_dict = dict()\\n        for w in words:\\n            self.words_dict[w] = True\\n        \\n        res = []\\n        for w in words:\\n            if is_concatenated(w, 0):\\n                res.append(w)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def is_concatenated(word, count):\\n            if word == \"\" and count >= 2:\\n                return True\\n            \\n            subword = \"\"\\n            for i in range(len(word)):\\n                subword += word[i] # append char to the end of the subword\\n                if subword in self.words_dict:\\n                    if is_concatenated(word[i + 1:], count + 1):\\n                        return True\\n\\n            # nothing found at this point\\n            return False\\n        \\n        # construct a dict of words to enable O(1) lookup\\n        self.words_dict = dict()\\n        for w in words:\\n            self.words_dict[w] = True\\n        \\n        res = []\\n        for w in words:\\n            if is_concatenated(w, 0):\\n                res.append(w)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761402,
                "title": "are-we-allowed-to-use-a-same-word-twice",
                "content": "![image](https://assets.leetcode.com/users/images/8d631364-f317-4a11-9346-7d97b980b747_1667178041.3654702.png)\\n\\nAre we allowed to use same word twice?\\nFor example, the \"catcat\" seems to be broken into \"cat\" + \"cat\"\\nIs this allowed?\\nThe problem says \"A concatenated word is defined as a string that is comprised entirely of **at least two shorter words** in the given array\", so I was a bit confused.\\nIf the answer is yes, I think it might be better to clarify in the problem statements",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/8d631364-f317-4a11-9346-7d97b980b747_1667178041.3654702.png)\\n\\nAre we allowed to use same word twice?\\nFor example, the \"catcat\" seems to be broken into \"cat\" + \"cat\"\\nIs this allowed?\\nThe problem says \"A concatenated word is defined as a string that is comprised entirely of **at least two shorter words** in the given array\", so I was a bit confused.\\nIf the answer is yes, I think it might be better to clarify in the problem statements",
                "codeTag": "Unknown"
            },
            {
                "id": 2687370,
                "title": "java-hashset-efficient-appoach-learner-friendly-recursion",
                "content": "```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        \\n        Set<String> dict = new HashSet<>(Arrays.asList(words));\\n        \\n        for (String word : words) {\\n            if(form(word, dict)) {\\n            result.add(word);\\n            }\\n        }\\n        return result ;\\n    }\\n    \\n    public boolean form(String word, Set<String> dict) {\\n        for (int i=1; i<word.length(); i++) {\\n            String left = word.substring(0, i) ;\\n            String right = word.substring(i) ;\\n\\n            if(dict.contains(left)) {\\n                if(dict.contains(right) || form(right, dict)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        \\n        Set<String> dict = new HashSet<>(Arrays.asList(words));\\n        \\n        for (String word : words) {\\n            if(form(word, dict)) {\\n            result.add(word);\\n            }\\n        }\\n        return result ;\\n    }\\n    \\n    public boolean form(String word, Set<String> dict) {\\n        for (int i=1; i<word.length(); i++) {\\n            String left = word.substring(0, i) ;\\n            String right = word.substring(i) ;\\n\\n            if(dict.contains(left)) {\\n                if(dict.contains(right) || form(right, dict)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580992,
                "title": "dfs-the-beauty-of-programming-4ms-fast-c",
                "content": "```\\n//bohat hi easy question --> not at all hard ...\\n    \\n    unordered_map<string,int> m;\\n    int dfs(string s)\\n    {\\n        if(!s.size())\\n            return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string x=s.substr(0,i+1); //ith pos tak ki substring lo\\n            \\n            if(m.find(x)!=m.end())  //check if x in \\'words\\' (fast search through map)\\n               ans=max(ans,1+dfs(s.substr(i+1))); //if present 1+dfs(i+1)\\n        } \\n        \\n//agar ans 0 hai mtlb koi b substr map me nahi present to invalid condition return INT_MIN\\n        return ans==0?INT_MIN:ans;  \\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        \\n        for(auto i:words)  //map me search kralo for O(1) search \\n            m[i]++;\\n        \\n        vector<string> ans;\\n        for(auto s:words)\\n        {\\n            if(dfs(s)>=2)  // if dfs(s)>=2 yaani 2 se zda words se milke bna hai ye word\\n              ans.push_back(s); //add it in ans\\n        }\\n        return ans;        \\n    }",
                "solutionTags": [],
                "code": "```\\n//bohat hi easy question --> not at all hard ...\\n    \\n    unordered_map<string,int> m;\\n    int dfs(string s)\\n    {\\n        if(!s.size())\\n            return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string x=s.substr(0,i+1); //ith pos tak ki substring lo\\n            \\n            if(m.find(x)!=m.end())  //check if x in \\'words\\' (fast search through map)\\n               ans=max(ans,1+dfs(s.substr(i+1))); //if present 1+dfs(i+1)\\n        } \\n        \\n//agar ans 0 hai mtlb koi b substr map me nahi present to invalid condition return INT_MIN\\n        return ans==0?INT_MIN:ans;  \\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        \\n        for(auto i:words)  //map me search kralo for O(1) search \\n            m[i]++;\\n        \\n        vector<string> ans;\\n        for(auto s:words)\\n        {\\n            if(dfs(s)>=2)  // if dfs(s)>=2 yaani 2 se zda words se milke bna hai ye word\\n              ans.push_back(s); //add it in ans\\n        }\\n        return ans;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2002654,
                "title": "easy-java-recursion",
                "content": "```class Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            set.add(word);\\n        }\\n        for (String word : words) {\\n            set.remove(word);\\n            if (trim(set, word)) ans.add(word);\\n            set.add(word);\\n        }\\n        return ans;\\n    }\\n    \\n    boolean trim(Set<String> set, String word) {\\n        if (set.contains(word)) return true;\\n        for (int i = 1; i < word.length(); i++) {\\n            if (set.contains(word.substring(0, i))) if (trim(set, word.substring(i))) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```class Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            set.add(word);\\n        }\\n        for (String word : words) {\\n            set.remove(word);\\n            if (trim(set, word)) ans.add(word);\\n            set.add(word);\\n        }\\n        return ans;\\n    }\\n    \\n    boolean trim(Set<String> set, String word) {\\n        if (set.contains(word)) return true;\\n        for (int i = 1; i < word.length(); i++) {\\n            if (set.contains(word.substring(0, i))) if (trim(set, word.substring(i))) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001426,
                "title": "easy-to-understand-python-graph-solution",
                "content": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        \\n        \\n        def check(word):\\n            q=deque([(0,[],set([0]))])\\n            \\n            while q:\\n                start,path,seen=q.popleft()\\n                if start==len(word) :return True\\n                \\n                for end in range(start+1,len(word)+1):\\n                    newWord=word[start:end]\\n                    if newWord in words and newWord!=word and end not in seen:\\n                        seen.add(end)\\n                        q.append((end,path+[newWord],seen))\\n            return False\\n                        \\n        \\n        words=set(words)\\n        \\n        res=[]\\n        for word in words:\\n            if check(word) and word:\\n                res.append(word)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        \\n        \\n        def check(word):\\n            q=deque([(0,[],set([0]))])\\n            \\n            while q:\\n                start,path,seen=q.popleft()\\n                if start==len(word) :return True\\n                \\n                for end in range(start+1,len(word)+1):\\n                    newWord=word[start:end]\\n                    if newWord in words and newWord!=word and end not in seen:\\n                        seen.add(end)\\n                        q.append((end,path+[newWord],seen))\\n            return False\\n                        \\n        \\n        words=set(words)\\n        \\n        res=[]\\n        for word in words:\\n            if check(word) and word:\\n                res.append(word)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602959,
                "title": "c-dp-without-tle-memoization",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool dfs(string &word,int start,unordered_set<string>& st,vector<int>& dp)\\n    {\\n        if(start==word.size())\\n            return 1;\\n        \\n        if(dp[start]!=-1)\\n            return dp[start];\\n        \\n        string s;\\n        for(int i=start;i<word.size();++i)\\n        {\\n            s+=word[i];\\n            if(st.find(s)!=st.end() && dfs(word,i+1,st,dp))\\n                return dp[start]=1;\\n        }\\n        return dp[start]=0;\\n    }\\n    \\n    \\n    \\n    bool check(string &word,unordered_set<string>& st)\\n    {\\n        int n=word.size();\\n        vector<int>dp(n+1,-1);\\n        st.erase(word);       // We need to delete that word that we are searching for from our set\\n        bool res=dfs(word,0,st,dp);\\n        st.insert(word);          //Then again insert that word \\n        return res;\\n        \\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string>ans;\\n        unordered_set<string>st(words.begin(),words.end());\\n        for(auto &word:words)\\n        {\\n            if(word.size()<=1)\\n                continue;\\n            if(check(word,st))\\n                ans.push_back(word);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(string &word,int start,unordered_set<string>& st,vector<int>& dp)\\n    {\\n        if(start==word.size())\\n            return 1;\\n        \\n        if(dp[start]!=-1)\\n            return dp[start];\\n        \\n        string s;\\n        for(int i=start;i<word.size();++i)\\n        {\\n            s+=word[i];\\n            if(st.find(s)!=st.end() && dfs(word,i+1,st,dp))\\n                return dp[start]=1;\\n        }\\n        return dp[start]=0;\\n    }\\n    \\n    \\n    \\n    bool check(string &word,unordered_set<string>& st)\\n    {\\n        int n=word.size();\\n        vector<int>dp(n+1,-1);\\n        st.erase(word);       // We need to delete that word that we are searching for from our set\\n        bool res=dfs(word,0,st,dp);\\n        st.insert(word);          //Then again insert that word \\n        return res;\\n        \\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string>ans;\\n        unordered_set<string>st(words.begin(),words.end());\\n        for(auto &word:words)\\n        {\\n            if(word.size()<=1)\\n                continue;\\n            if(check(word,st))\\n                ans.push_back(word);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341173,
                "title": "c-trie-solution",
                "content": "```\\nstruct trie{\\n    trie* ptr[26];\\n    bool isword;\\n    trie(){\\n        for(int i=0;i<26;i++)ptr[i] = NULL;\\n        isword = false;\\n    }\\n};\\n\\ntypedef trie* tptr;\\nvoid insert(tptr t,string s){\\n    for(int i=0;i<s.length();i++){\\n        if(!t->ptr[s[i]-\\'a\\'])t->ptr[s[i]-\\'a\\'] = new trie();\\n        t = t->ptr[s[i]-\\'a\\'];\\n    }\\n    t->isword = true;\\n}\\nbool morethan2(tptr root,string s,int i=0,int cnt=1){\\n    tptr t = root;\\n    for(int j=i;j<s.length();j++){\\n        if(!t->ptr[s[j]-\\'a\\'])return false;\\n        t = t->ptr[s[j]-\\'a\\'];\\n        if(t->isword && morethan2(root,s,j+1,cnt+1))return true;\\n    }\\n    return (t->isword && cnt>1);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        tptr t = new trie();\\n        int n = words.size();\\n        for(string s : words)if(!s.empty())insert(t,s);\\n        vector<string>ans;\\n        for(string s : words){\\n            if(morethan2(t,s))ans.emplace_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct trie{\\n    trie* ptr[26];\\n    bool isword;\\n    trie(){\\n        for(int i=0;i<26;i++)ptr[i] = NULL;\\n        isword = false;\\n    }\\n};\\n\\ntypedef trie* tptr;\\nvoid insert(tptr t,string s){\\n    for(int i=0;i<s.length();i++){\\n        if(!t->ptr[s[i]-\\'a\\'])t->ptr[s[i]-\\'a\\'] = new trie();\\n        t = t->ptr[s[i]-\\'a\\'];\\n    }\\n    t->isword = true;\\n}\\nbool morethan2(tptr root,string s,int i=0,int cnt=1){\\n    tptr t = root;\\n    for(int j=i;j<s.length();j++){\\n        if(!t->ptr[s[j]-\\'a\\'])return false;\\n        t = t->ptr[s[j]-\\'a\\'];\\n        if(t->isword && morethan2(root,s,j+1,cnt+1))return true;\\n    }\\n    return (t->isword && cnt>1);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        tptr t = new trie();\\n        int n = words.size();\\n        for(string s : words)if(!s.empty())insert(t,s);\\n        vector<string>ans;\\n        for(string s : words){\\n            if(morethan2(t,s))ans.emplace_back(s);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325612,
                "title": "c-trie",
                "content": "This is not a very hard problem. It\\'s just lengthy. The implementation is much easier using trie than Dynamic Programming.   \\nRead[ this](https://leetcode.com/problems/implement-trie-prefix-tree/solution/\\n) if you are not familiar with Trie data structure.\\n```\\nclass Trie{\\n    public:\\n    vector<Trie*> dict; \\n    bool isEnd;\\n    Trie(){\\n        dict.assign(26,NULL);\\n        isEnd = false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    bool isWord(Trie* root, int left , int right, string s){\\n        Trie* curr =root;\\n        for(int i=left;i<=right;i++){\\n            if(!curr->dict[s[i]-\\'a\\'])\\n                return 0;\\n            curr = curr->dict[s[i]-\\'a\\'];\\n        }\\n        return curr->isEnd;\\n    }\\n    \\n    bool dfs(string s, int left,int right, Trie* root) {\\n        Trie* curr = root;\\n        for(int i=left;i<=right;i++){\\n            if(!curr->dict[s[i]-\\'a\\']) \\n                return false;\\n            curr = curr->dict[s[i]-\\'a\\'];\\n            if(curr->isEnd){\\n                if(isWord(root,i+1,right,s) || dfs(s , i+1, right, root)) //a word can be a concatenation of 2 or more words. \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        Trie* root = new Trie();\\n        //insert all the words into the trie. \\n        for(string word : words) {\\n            Trie* curr = root; \\n            for(char c : word){\\n                if(!curr->dict[c-\\'a\\']) \\n                    curr->dict[c-\\'a\\'] = new Trie();\\n                curr = curr->dict[c-\\'a\\'];\\n            }\\n            if(curr!=root)curr->isEnd = true; //there might be empty strings words\\n        }\\n        vector<string> result;\\n        \\n        for(string word : words) {\\n            if(dfs(word,0,word.length()-1 , root))\\n                result.push_back(word);\\n        }        \\n        \\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\n    public:\\n    vector<Trie*> dict; \\n    bool isEnd;\\n    Trie(){\\n        dict.assign(26,NULL);\\n        isEnd = false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    bool isWord(Trie* root, int left , int right, string s){\\n        Trie* curr =root;\\n        for(int i=left;i<=right;i++){\\n            if(!curr->dict[s[i]-\\'a\\'])\\n                return 0;\\n            curr = curr->dict[s[i]-\\'a\\'];\\n        }\\n        return curr->isEnd;\\n    }\\n    \\n    bool dfs(string s, int left,int right, Trie* root) {\\n        Trie* curr = root;\\n        for(int i=left;i<=right;i++){\\n            if(!curr->dict[s[i]-\\'a\\']) \\n                return false;\\n            curr = curr->dict[s[i]-\\'a\\'];\\n            if(curr->isEnd){\\n                if(isWord(root,i+1,right,s) || dfs(s , i+1, right, root)) //a word can be a concatenation of 2 or more words. \\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        Trie* root = new Trie();\\n        //insert all the words into the trie. \\n        for(string word : words) {\\n            Trie* curr = root; \\n            for(char c : word){\\n                if(!curr->dict[c-\\'a\\']) \\n                    curr->dict[c-\\'a\\'] = new Trie();\\n                curr = curr->dict[c-\\'a\\'];\\n            }\\n            if(curr!=root)curr->isEnd = true; //there might be empty strings words\\n        }\\n        vector<string> result;\\n        \\n        for(string word : words) {\\n            if(dfs(word,0,word.length()-1 , root))\\n                result.push_back(word);\\n        }        \\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223576,
                "title": "java-short-and-crisp-using-trie-time-99-dfs-time-74-with-explanation",
                "content": "**!! Intro-Algo-Optimization. Read till last for better understanding. !!**\\n```\\nclass Node {\\n    boolean end;\\n    Node[] nodeArray;\\n    Node(){\\n        end=false;\\n        nodeArray=new Node[26];\\n    }\\n}\\nclass Solution {\\n    Node root;\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result=new ArrayList<String>();\\n        if(words.length<=2) return result;\\n        root=new Node();\\n        \\n        Arrays.sort(words,(a,b) -> a.length()-b.length());\\n        \\n        for(String s : words){\\n\\t\\t\\tif(s.isEmpty()) continue;\\n\\t\\t/*words[] is sorted in asc order of length. So all the words inserted in \\n        TRIE are of length <= s.length() . As all strings in words[] are unique and \\n        as we did not insert \\'s\\' already , if \\'s\\' can be formed then it \\n\\t\\tmeans it was formed by concatenating two or more smaller words.\\n\\t\\t*/\\n            if(isPossible(s,0)) result.add(s);\\n            else insert(s);\\n        }\\n        \\n        return result;\\n    }\\n  \\n    private boolean isPossible(String s,int index){\\n        if( index==s.length() ) return true;\\n        \\n        Node curr=root;\\n        for(int i=index,n=s.length() ; i<n ; i++){\\n            curr=curr.nodeArray[ s.charAt(i)-\\'a\\' ];\\n            if(curr==null) return false;\\n            //Found a word, now check if rest of the string can be formed.\\n            if(curr.end && isPossible(s,i+1))\\n                    return true;\\n        }\\n        return false;\\n    }\\n     \\n    private void insert(String s){\\n        Node curr=root;\\n        for(int i=0,n=s.length() ; i<n ; i++){\\n            int c=s.charAt(i)-\\'a\\';\\n            if(curr.nodeArray[c]==null) curr.nodeArray[c]=new Node();\\n            curr=curr.nodeArray[c];\\n        }\\n        curr.end=true;\\n    }\\n}\\n```\\n**What is TRIE ?** An efficient DS for info re**Trie**val\\nparameters : Boolean end, Node[] nodeArray.\\nThe main use of TRIE is to maintain dictionary , as after each character there are two choices\\ni. any of the 26 characters [assuming loweraser]. node_array[char-\\'a\\'] will again form a TRIE.\\nii.or nothing i.e., current char is the last character of word. For this case we maintain boolean parameter \\ncalled end and end=true.\\n\\n![image](https://assets.leetcode.com/users/images/911df49e-c5b1-4a65-a8e9-c4bacb4affd9_1619610645.5904534.png)\\n \\n If you follow ROOT to a red circle then you can find a word. To represent red circles in TRIE \\'end\\' parameter of node is used.\\n We can see that common prefix is stored only once[ like for their,there..the is stored only once] and to insert or delete or search a word it on takes O(length of the word) , in english longest word is of 45char so typically to search/store all the words in english dictionary time complexity will be N* O(45) = N* O(1), but space complexity might be a issue here.\\n\\n**Algo:**\\n1.Intially add all words into TRIE. \\n2.For a word to be concatenated it should comprise entirely of at least two shorter words. \\nFOR each word in dict\\n....FOR i = 0 to n-2 in word\\ncheck if at word[i] in TRIE has end=true, then check if the rest of that string can be formed .\\n\\n**Optimization:**\\nFor Step1 in algo, it takes N x O(L) = 10^7 in worst case.\\nAgain for Step2 in algo, we are checking for each char in each word so again  N x O(L) = 10^7 operations. \\n***So how can we improve time complexity ?***\\nWe know that a bigger word requires smaller word to concatenate. So first insert smaller words first and check if a bigger word can be formed. \\n-If, bigger word (b1) can be formed then no need to insert the bigger word again. By doing this we can save O(L) time to insert and O(L) space to insert.  Previously we took O(L) time to insert and O(L) to search, but now if the bigger word can be concatenated then no need to insert.\\n\\n***How to implement ?***\\n-Sort words[] in ascending order of length.\\n-Now before inserting a word , check it can be concatenated by previously inserted words. If Yes, then no need to insert this bigger word thereby saving us O(L)-Time,space . Else, insert this word.\\n\\n## **Approach 2 : DFS**\\nSame optimized approach can be applied to DFS with hashset.\\n**Algo:**\\n1.Sort  words[] in ascending order of length.\\n2.Now before inserting a word , check it can be concatenated by previously inserted words. If Yes, then no need to insert this bigger word thereby saving us time,space . Else, insert this word.\\n\\n```\\nclass Solution {\\n    HashSet<String> set = new HashSet<>();\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result=new ArrayList<String>();\\n        if(words.length<=2) return result;\\n        \\n        Arrays.sort(words,(a,b) -> a.length()-b.length());\\n        \\n        for(String s : words){\\n            if(s.isEmpty()) continue;\\n            if(isPossible2(s)) result.add(s);\\n            else set.add(s);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private boolean isPossible2(String s){\\n        if(s.isEmpty()) return true;\\n        for(int i=1;i<=s.length();i++)\\n            if(set.contains(s.substring(0,i)) && isPossible2(s.substring(i)) )\\n                return true;\\n        return false;\\n    }\\n}\\n```\\n\\n**Comparison :**\\nTrie approach - 44ms, DFS+HashSet - 275ms. Here Trie is faster.\\n**Trie**\\n-Insertion takes exactly O(L) time.\\n-For search, if word exists in dictionary then O(L) else less than that.\\n-As common prefix needs to be stored only once this saves memory also..\\n \\n **HashSet:**\\n In ideal scenario insert and search should be O(1). A perfect hash function should evenly distribute N elements among N buckets, so that by calculating hash value we can retrieve from the respective bucket in O(1).\\n But in reality it is not the case, we have to handle collisions. If they are many collisions then lookup time may even become O(N).\\n -One more point to be noted, if hashmap is 75% full then it doubles the size,  rehashes and inserts all the data again. So if we are trying to store and lookup large dictionary hashmap may not be ideal.\\n -Moreover we are checking if [i=1 to L] s.substring(0,i) is present in dictionary , so it my take L* LookUptime. Ideally LookUpTime=k=1 but 1<=k<=N . And we are repetaing this process for N strings. \\n So overall T(N) = N* L* K.\\n \\n Luckily after Java8, if they are many collision in hashmap bucket then it converts linear linking to a self balancing tree which reduces lookup time to Log(N) , still Log(N) > 1. \\n \\n**Hope this post was useful. Happy Coding :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    boolean end;\\n    Node[] nodeArray;\\n    Node(){\\n        end=false;\\n        nodeArray=new Node[26];\\n    }\\n}\\nclass Solution {\\n    Node root;\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result=new ArrayList<String>();\\n        if(words.length<=2) return result;\\n        root=new Node();\\n        \\n        Arrays.sort(words,(a,b) -> a.length()-b.length());\\n        \\n        for(String s : words){\\n\\t\\t\\tif(s.isEmpty()) continue;\\n\\t\\t/*words[] is sorted in asc order of length. So all the words inserted in \\n        TRIE are of length <= s.length() . As all strings in words[] are unique and \\n        as we did not insert \\'s\\' already , if \\'s\\' can be formed then it \\n\\t\\tmeans it was formed by concatenating two or more smaller words.\\n\\t\\t*/\\n            if(isPossible(s,0)) result.add(s);\\n            else insert(s);\\n        }\\n        \\n        return result;\\n    }\\n  \\n    private boolean isPossible(String s,int index){\\n        if( index==s.length() ) return true;\\n        \\n        Node curr=root;\\n        for(int i=index,n=s.length() ; i<n ; i++){\\n            curr=curr.nodeArray[ s.charAt(i)-\\'a\\' ];\\n            if(curr==null) return false;\\n            //Found a word, now check if rest of the string can be formed.\\n            if(curr.end && isPossible(s,i+1))\\n                    return true;\\n        }\\n        return false;\\n    }\\n     \\n    private void insert(String s){\\n        Node curr=root;\\n        for(int i=0,n=s.length() ; i<n ; i++){\\n            int c=s.charAt(i)-\\'a\\';\\n            if(curr.nodeArray[c]==null) curr.nodeArray[c]=new Node();\\n            curr=curr.nodeArray[c];\\n        }\\n        curr.end=true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    HashSet<String> set = new HashSet<>();\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> result=new ArrayList<String>();\\n        if(words.length<=2) return result;\\n        \\n        Arrays.sort(words,(a,b) -> a.length()-b.length());\\n        \\n        for(String s : words){\\n            if(s.isEmpty()) continue;\\n            if(isPossible2(s)) result.add(s);\\n            else set.add(s);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private boolean isPossible2(String s){\\n        if(s.isEmpty()) return true;\\n        for(int i=1;i<=s.length();i++)\\n            if(set.contains(s.substring(0,i)) && isPossible2(s.substring(i)) )\\n                return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150726,
                "title": "java-tle-clear-easy-to-understand",
                "content": "```\\nclass Solution {\\n    //Caching\\n    HashMap<String,Boolean> map = new HashMap<String,Boolean>();\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n     \\n     HashSet<String> set =  new HashSet<>();\\n     List<String> result =  new ArrayList<>();\\n        \\n     for(String word: words){\\n        set.add(word);\\n     }\\n        \\n     for(int i = 0; i < words.length; i++){\\n         if(concatenate(words[i], set, 1)){\\n             result.add(words[i]);\\n             map.put(words[i],true);\\n         }  \\n     }\\n        \\n     return result;   \\n    }\\n\\n    \\n    public Boolean concatenate(String word, HashSet<String> set, int count){\\n        \\n        if(set.contains(word) && count>1){\\n            return true;\\n        }\\n        \\n        if(map.containsKey(word)){\\n            return map.get(word);\\n        }\\n        \\n        for(int i=1; i< word.length();i++){\\n            if(set.contains(word.substring(0,i)) && concatenate(word.substring(i), set, count+1)){\\n                map.put(word,true);\\n                return true;\\n            }\\n        }\\n        map.put(word,false);       \\n        \\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    //Caching\\n    HashMap<String,Boolean> map = new HashMap<String,Boolean>();\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n     \\n     HashSet<String> set =  new HashSet<>();\\n     List<String> result =  new ArrayList<>();\\n        \\n     for(String word: words){\\n        set.add(word);\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 1060543,
                "title": "c-trie-dp-memoization-easy-to-understand-solution-beats-96",
                "content": "\\n```\\nclass Solution {\\n    class TrieNode {\\n        public:\\n        TrieNode* next[26] = {NULL};\\n        bool isEOW = false;\\n        TrieNode() {}\\n    };\\n    \\n    class Trie {\\n        TrieNode* root;\\n        public:\\n        Trie() { root = new TrieNode(); }\\n        \\n\\t\\t// standard insertion of words into a trie\\n        void insert(string& word) {\\n            TrieNode* curr = root;\\n            for(auto& c: word) {\\n                int ch = c - \\'a\\';\\n                if(!curr->next[ch])\\n                    curr->next[ch] = new TrieNode();\\n                curr = curr->next[ch];\\n            }\\n            curr->isEOW = true;\\n        }\\n        \\n        bool dfs(string& word, int start, vector<int>& dp, int count) {\\n            if(start == word.length()) // If we have reached the end of the word, just check if atleast 2 prefix words exist\\n                return count >= 2;\\n            if(dp[start] != -1) return dp[start]; //memoization\\n            \\n            TrieNode* curr = root; // start with the root to check if the word[start....i] exists in the word list\\n            for(int i=start; i<word.length(); i++) {\\n                int ch = word[i]-\\'a\\';\\n                if(!curr->next[ch]) \\n                    return dp[start] = false;\\n                curr = curr->next[ch];\\n                if(curr->isEOW && dfs(word, i+1, dp, count+1)) // if we find such a word, check by recursively searching for word[i+1....]\\n                    return dp[start] = true;\\n            }\\n            return dp[start] = false;\\n        }\\n    };\\n    \\n\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        Trie trie;\\n        for(auto& word: words)\\n            trie.insert(word);\\n        \\n        vector<string> res;\\n        \\n        for(auto& word: words) {\\n            vector<int> dp(word.length(), -1);\\n            if(trie.dfs(word, 0, dp, 0))\\n                res.push_back(word);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    class TrieNode {\\n        public:\\n        TrieNode* next[26] = {NULL}",
                "codeTag": "Java"
            },
            {
                "id": 1052885,
                "title": "python-memoization",
                "content": "```\\n\\tdef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n\\t\\td = set(words)\\n        memo = {}\\n\\n        def canForm(word) -> bool:\\n            if word in memo:\\n                return memo[word]\\n                \\n            for i in range(1, len(word)):\\n                prefix, suffix = word[:i], word[i:]\\n                if (prefix in d and suffix in d) or (prefix in d and canForm(suffix)) or (suffix in d and canForm(prefix)):\\n                    memo[word] = True\\n                    return True\\n\\n            memo[word] = False\\n            return False\\n\\n        res = []\\n        for w in d:\\n            if canForm(w):\\n                res.append(w)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n\\t\\td = set(words)\\n        memo = {}\\n\\n        def canForm(word) -> bool:\\n            if word in memo:\\n                return memo[word]\\n                \\n            for i in range(1, len(word)):\\n                prefix, suffix = word[:i], word[i:]\\n                if (prefix in d and suffix in d) or (prefix in d and canForm(suffix)) or (suffix in d and canForm(prefix)):\\n                    memo[word] = True\\n                    return True\\n\\n            memo[word] = False\\n            return False\\n\\n        res = []\\n        for w in d:\\n            if canForm(w):\\n                res.append(w)\\n\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1024436,
                "title": "python-explanation-last-case-very-optimized-70-28-dhruv-vavliya",
                "content": "```\\nWritten by : Dhruv vavliya\\n\\ndef word_break(words,word,start,dp):\\n    if start in dp:\\n        return dp[start]\\n    if start!=0 and word[start:] in words:\\n        return True\\n\\n    for end in range(start+1,len(word)+1):\\n        left = word[start:end]\\n        if left in words and word_break(words ,word ,end,dp):\\n            dp[start]=True\\n            return True\\n    dp[start]=False\\n    return False\\n\\n\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        ans = []\\n        words = set([word for word in words if word])                   # this line take my one whole day  :)\\n\\n        for word in words:\\n            if len(word)>1 and word_break(words,word,0,{}):      \\n                ans.append(word)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nWritten by : Dhruv vavliya\\n\\ndef word_break(words,word,start,dp):\\n    if start in dp:\\n        return dp[start]\\n    if start!=0 and word[start:] in words:\\n        return True\\n\\n    for end in range(start+1,len(word)+1):\\n        left = word[start:end]\\n        if left in words and word_break(words ,word ,end,dp):\\n            dp[start]=True\\n            return True\\n    dp[start]=False\\n    return False\\n\\n\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        ans = []\\n        words = set([word for word in words if word])                   # this line take my one whole day  :)\\n\\n        for word in words:\\n            if len(word)>1 and word_break(words,word,0,{}):      \\n                ans.append(word)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018510,
                "title": "trie-solution-that-doesn-t-tle-90ms-faster-than-67-61",
                "content": "Almost all Trie solutions for this question TLE (time limit exceeded). The only Trie solution I could find that gets around TLE is by @mavs0603 here: https://leetcode.com/problems/concatenated-words/discuss/432417/Java-DFS-%2B-Trie\\n\\nThat solution works differently to my own, but I have used it to understand how to get around the TLE for my own solution.\\n\\nPlease provide corrections in the comments & I will gladly amend any mistakes.\\n\\n```\\n// Break down of complexities per operation:\\n// sort input: O(n log n) time where n is number of words\\n// time & space for building trie: O(n*m) where m is length of word\\n// find if a word is concatenated: O(n*2^m)\\n\\n// Overall:\\n// O(n*2^m) time where n is number of words, m is length of word.\\n// O(n*m) space for trie itself (probably higher due to recursive calls, but not sure what it is exactly)\\npublic static List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        if (words == null || words.length < 2) {\\n            return res;\\n        }\\n\\t\\t\\n\\t\\t// sort words in ascending order\\n\\t\\t// this way for an input like [\"aaaaaaaaaa\", \"aaaaaaaa\", \"aa\", \"a\"]\\n\\t\\t// we don\\'t actually bother inserting the largest words if they are concatenated\\n\\t\\t// this is what helps the solution not TLE for the recent test case\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\\n\\n        TrieNode root = new TrieNode(\\'#\\');\\n\\t\\t\\n\\t\\t// Building our trie upfront can cause TLE for the most recent test case\\n\\t\\t// That said one could uncomment the below line, then comment out the Arrays.sort() & the insert() operation\\n\\t\\t// doing so would pass all sane test cases (44/45 would pass, with the final one producing a TLE)\\n        // buildTrie(words, root);\\n\\n        for (String word : words) {\\n\\t\\t\\t// In order to avoid TLE (time limit exceeded) we process large words last (we have sorted the input)\\n\\t\\t\\t// So if a large word is concatenated (the first, smallest word, is never concatenated), it isn\\'t added to the trie\\n\\t\\t\\t// We can instead build the trie upfront (I have commented that portion out) and not bother with sorting the input\\n\\t\\t\\t// But due to a recently added test case on LC this would cause TLE\\n\\t\\t\\t// The caveat, or interesting thing, about not building the trie upfront is \\n\\t\\t\\t// that if later, larger, words are repeated versions of a prior concatenation - or comprised of prior concatenations\\n\\t\\t\\t// e.g input = [\"abcd\", \"abcd\", \"abcdabcd\", \"abcdabcdabcd\"] - our last word is either 3x\"abcd\" or \"abcdabcd\" + \"abcd\"\\n\\t\\t\\t// we do not/cannot use the prior concatenated words to determine if the later word is also concatenated/comprised of them\\n\\t\\t\\t// this is because all prior concatenated words are never inserted into the trie\\n\\t\\t\\t// instead, we have to use the smaller words to determine the if the later word is concatenated\\n\\t\\t\\t// for the given example, if we do not build the trie upfront, we would determine that yes, \\n\\t\\t\\t// \"abcdabcdabcd\" is concatenated - it is made up of \"abcd\" + abcd\" + abcd\"\\n\\t\\t\\t// If we build the trie upfront, so insert all words into the trie, then we would be able to determine that\\n\\t\\t\\t// either/both \"abcd\" + abcd\" + abcd\" &  \"abcdabcd\" + \"abcd\" are concatenations of \"abcdabcdabcd\"\\n\\t\\t\\t// this is because all the words will exist in the trie\\n\\t\\t\\t// Additionally, building the trie upfront means we do not have to modify (sort) the input\\n            if (isConcatenated(0, 0, word, root)) {\\n                res.add(word);\\n            } else {\\n\\t\\t\\t\\t// if you build the trie upfront you can comment this out:\\n                insert(word, root);\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private static void insert(String word, TrieNode root) {\\n        if (word == null || word.length() == 0) {\\n            return;\\n        }\\n\\n        TrieNode temp = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (!temp.children.containsKey(ch)) {\\n                temp.children.put(ch, new TrieNode(ch));\\n            }\\n\\n            temp = temp.children.get(ch);\\n        }\\n\\n        temp.isEndOfWord = true;\\n    }\\n\\n    private static boolean isConcatenated(int j, int count, String word, TrieNode root) {\\n        if (count >= 2 && j == word.length()) {\\n\\t\\t\\t// Our current word is built up of 2 or more other words from the input (in the trie)\\n\\t\\t\\t// and the current word has been fully explored (j == length)\\n            return true;\\n        }\\n\\n        TrieNode node = root;\\n        for (int i = j; i < word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (!node.children.containsKey(ch)) {\\n                return false;\\n            }\\n\\n            node = node.children.get(ch);\\n\\n            if (node.isEndOfWord && isConcatenated(i + 1, count + 1, word, root)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private static void buildTrie(String[] words, TrieNode root) {\\n        for (String word : words) {\\n            if (word == null || word.length() == 0) {\\n                continue;\\n            }\\n\\n            TrieNode temp = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char ch = word.charAt(i);\\n                if (!temp.children.containsKey(ch)) {\\n                    temp.children.put(ch, new TrieNode(ch));\\n                }\\n\\n                temp = temp.children.get(ch);\\n            }\\n\\n            temp.isEndOfWord = true;\\n        }\\n    }\\n\\n    private static class TrieNode {\\n\\n        public TrieNode(char ch) {\\n            character = ch;\\n            isEndOfWord = false;\\n            children = new HashMap<>();\\n        }\\n\\n        Map<Character, TrieNode> children;\\n\\t\\t// this isn\\'t used but it\\'s helpful for debugging/stepping through\\n        char character;\\n        boolean isEndOfWord;\\n    }\\n\\n// No idea if this is helpful for anyone, but adding it anyway:\\n\\n// For the time complexity of O(n*2^n) it helped me to think of the input [\"a\", \"a\", \"aaab\"]:\\n// for \"aaab\" we would do a lot of unnecessary exploration/recursion to ultimately find out it isn\\'t a concatenated word\\n// this is because \"a\" is in the trie & \"a\".isEndOfWord=true\\n// so for the first 3 characters we would recursively call isConcatenated(i + 1, count + 1, \"aaab\", root)\\n// once we get to the last/deepest level of recursion and reach \"b\"\\n// we determine that \"aaab\" is not a concatenated word afterall\\n// and each level of previous recursion where we encountered an \"a\"\\n// does another loop iteration before determining the next character also doesn\\'t yield a concatenated word. \\n\\n// More detailed brain debug:\\n// For isConcatenated(0, 0, \"aaab\", root) we loop over entire \"aaab\"\\n// In the first loop iteration we find \"a\" is both in the trie & isEndOfWord=true\\n// thus we recurse & pass in (i+1) - each level of recursion explores letters after the current one\\n// inside our recursive call we find another \"a\" (i=1 at this point) & so recurse again\\n// This continues to happen until the very last \"a\" when i=2\\n// we recurse for this last \"a\" and pass in i+1, so i=3 at our last depth of recursion\\n// for this level of recursion we find that \"b\" isn\\'t a child letter of our root node, so we return false\\n// Now we exit back up to our \"a\" & i=2 recursive level (and remember at this level our current trie node is \"a\", not root)\\n// This level of recursion continues in it\\'s for loop & i goes to 3\\n// we now explore \"b\" again, but at a different/the current level of recursion\\n// we return false as \"b\" isn\\'t a child of \"a\" and for every previous level of recursion where we encountered \"a\"\\n// we explore for another iteration in the same way:\\n// \"aa\" (i=1) would explore the next \"a\" during it\\'s next loop iteration\\n// because the node variable (TrieNode object) is now \"a\" for each level of recursion & not root\\n// and \"a\" in the trie has no children, each level of recursion\\'s next iteration would return false\\n// up another level of recursion we had \"a\" (i=0) & this would explore the next \"a\" which also returns false (same as \"aa\" case)\\n// As you can see, we do all this extra work even though the word \"aaab\" isn\\'t a concatenated word\\n```",
                "solutionTags": [],
                "code": "```\\n// Break down of complexities per operation:\\n// sort input: O(n log n) time where n is number of words\\n// time & space for building trie: O(n*m) where m is length of word\\n// find if a word is concatenated: O(n*2^m)\\n\\n// Overall:\\n// O(n*2^m) time where n is number of words, m is length of word.\\n// O(n*m) space for trie itself (probably higher due to recursive calls, but not sure what it is exactly)\\npublic static List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        if (words == null || words.length < 2) {\\n            return res;\\n        }\\n\\t\\t\\n\\t\\t// sort words in ascending order\\n\\t\\t// this way for an input like [\"aaaaaaaaaa\", \"aaaaaaaa\", \"aa\", \"a\"]\\n\\t\\t// we don\\'t actually bother inserting the largest words if they are concatenated\\n\\t\\t// this is what helps the solution not TLE for the recent test case\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\\n\\n        TrieNode root = new TrieNode(\\'#\\');\\n\\t\\t\\n\\t\\t// Building our trie upfront can cause TLE for the most recent test case\\n\\t\\t// That said one could uncomment the below line, then comment out the Arrays.sort() & the insert() operation\\n\\t\\t// doing so would pass all sane test cases (44/45 would pass, with the final one producing a TLE)\\n        // buildTrie(words, root);\\n\\n        for (String word : words) {\\n\\t\\t\\t// In order to avoid TLE (time limit exceeded) we process large words last (we have sorted the input)\\n\\t\\t\\t// So if a large word is concatenated (the first, smallest word, is never concatenated), it isn\\'t added to the trie\\n\\t\\t\\t// We can instead build the trie upfront (I have commented that portion out) and not bother with sorting the input\\n\\t\\t\\t// But due to a recently added test case on LC this would cause TLE\\n\\t\\t\\t// The caveat, or interesting thing, about not building the trie upfront is \\n\\t\\t\\t// that if later, larger, words are repeated versions of a prior concatenation - or comprised of prior concatenations\\n\\t\\t\\t// e.g input = [\"abcd\", \"abcd\", \"abcdabcd\", \"abcdabcdabcd\"] - our last word is either 3x\"abcd\" or \"abcdabcd\" + \"abcd\"\\n\\t\\t\\t// we do not/cannot use the prior concatenated words to determine if the later word is also concatenated/comprised of them\\n\\t\\t\\t// this is because all prior concatenated words are never inserted into the trie\\n\\t\\t\\t// instead, we have to use the smaller words to determine the if the later word is concatenated\\n\\t\\t\\t// for the given example, if we do not build the trie upfront, we would determine that yes, \\n\\t\\t\\t// \"abcdabcdabcd\" is concatenated - it is made up of \"abcd\" + abcd\" + abcd\"\\n\\t\\t\\t// If we build the trie upfront, so insert all words into the trie, then we would be able to determine that\\n\\t\\t\\t// either/both \"abcd\" + abcd\" + abcd\" &  \"abcdabcd\" + \"abcd\" are concatenations of \"abcdabcdabcd\"\\n\\t\\t\\t// this is because all the words will exist in the trie\\n\\t\\t\\t// Additionally, building the trie upfront means we do not have to modify (sort) the input\\n            if (isConcatenated(0, 0, word, root)) {\\n                res.add(word);\\n            } else {\\n\\t\\t\\t\\t// if you build the trie upfront you can comment this out:\\n                insert(word, root);\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private static void insert(String word, TrieNode root) {\\n        if (word == null || word.length() == 0) {\\n            return;\\n        }\\n\\n        TrieNode temp = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (!temp.children.containsKey(ch)) {\\n                temp.children.put(ch, new TrieNode(ch));\\n            }\\n\\n            temp = temp.children.get(ch);\\n        }\\n\\n        temp.isEndOfWord = true;\\n    }\\n\\n    private static boolean isConcatenated(int j, int count, String word, TrieNode root) {\\n        if (count >= 2 && j == word.length()) {\\n\\t\\t\\t// Our current word is built up of 2 or more other words from the input (in the trie)\\n\\t\\t\\t// and the current word has been fully explored (j == length)\\n            return true;\\n        }\\n\\n        TrieNode node = root;\\n        for (int i = j; i < word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (!node.children.containsKey(ch)) {\\n                return false;\\n            }\\n\\n            node = node.children.get(ch);\\n\\n            if (node.isEndOfWord && isConcatenated(i + 1, count + 1, word, root)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private static void buildTrie(String[] words, TrieNode root) {\\n        for (String word : words) {\\n            if (word == null || word.length() == 0) {\\n                continue;\\n            }\\n\\n            TrieNode temp = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char ch = word.charAt(i);\\n                if (!temp.children.containsKey(ch)) {\\n                    temp.children.put(ch, new TrieNode(ch));\\n                }\\n\\n                temp = temp.children.get(ch);\\n            }\\n\\n            temp.isEndOfWord = true;\\n        }\\n    }\\n\\n    private static class TrieNode {\\n\\n        public TrieNode(char ch) {\\n            character = ch;\\n            isEndOfWord = false;\\n            children = new HashMap<>();\\n        }\\n\\n        Map<Character, TrieNode> children;\\n\\t\\t// this isn\\'t used but it\\'s helpful for debugging/stepping through\\n        char character;\\n        boolean isEndOfWord;\\n    }\\n\\n// No idea if this is helpful for anyone, but adding it anyway:\\n\\n// For the time complexity of O(n*2^n) it helped me to think of the input [\"a\", \"a\", \"aaab\"]:\\n// for \"aaab\" we would do a lot of unnecessary exploration/recursion to ultimately find out it isn\\'t a concatenated word\\n// this is because \"a\" is in the trie & \"a\".isEndOfWord=true\\n// so for the first 3 characters we would recursively call isConcatenated(i + 1, count + 1, \"aaab\", root)\\n// once we get to the last/deepest level of recursion and reach \"b\"\\n// we determine that \"aaab\" is not a concatenated word afterall\\n// and each level of previous recursion where we encountered an \"a\"\\n// does another loop iteration before determining the next character also doesn\\'t yield a concatenated word. \\n\\n// More detailed brain debug:\\n// For isConcatenated(0, 0, \"aaab\", root) we loop over entire \"aaab\"\\n// In the first loop iteration we find \"a\" is both in the trie & isEndOfWord=true\\n// thus we recurse & pass in (i+1) - each level of recursion explores letters after the current one\\n// inside our recursive call we find another \"a\" (i=1 at this point) & so recurse again\\n// This continues to happen until the very last \"a\" when i=2\\n// we recurse for this last \"a\" and pass in i+1, so i=3 at our last depth of recursion\\n// for this level of recursion we find that \"b\" isn\\'t a child letter of our root node, so we return false\\n// Now we exit back up to our \"a\" & i=2 recursive level (and remember at this level our current trie node is \"a\", not root)\\n// This level of recursion continues in it\\'s for loop & i goes to 3\\n// we now explore \"b\" again, but at a different/the current level of recursion\\n// we return false as \"b\" isn\\'t a child of \"a\" and for every previous level of recursion where we encountered \"a\"\\n// we explore for another iteration in the same way:\\n// \"aa\" (i=1) would explore the next \"a\" during it\\'s next loop iteration\\n// because the node variable (TrieNode object) is now \"a\" for each level of recursion & not root\\n// and \"a\" in the trie has no children, each level of recursion\\'s next iteration would return false\\n// up another level of recursion we had \"a\" (i=0) & this would explore the next \"a\" which also returns false (same as \"aa\" case)\\n// As you can see, we do all this extra work even though the word \"aaab\" isn\\'t a concatenated word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985866,
                "title": "c-trie-and-dp-faster-than-92",
                "content": "```\\nclass Solution {\\npublic: \\n    struct TrieNode { \\n        TrieNode *children[26];\\n        bool isLeaf; \\n        TrieNode(){\\n            this->isLeaf = false;\\n            for(int i=0;i<26;i++){\\n                this->children[i]=NULL;\\n            }\\n        }\\n    }; \\n\\n    \\n    void insert(TrieNode *p, string w){ \\n        int n = w.size(); \\n\\n        for (int i = 0; i < n; i++) { \\n            int index = w[i]-\\'a\\'; \\n            if (!p->children[index]) \\n                p->children[index] = new TrieNode(); \\n            p = p->children[index]; \\n        }\\n\\n        p->isLeaf = true; \\n    } \\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words){\\n        TrieNode *root = new TrieNode();\\n        \\n        for (int i = 0; i < words.size(); i++) \\n            insert(root, words[i]);\\n        \\n        vector<string> ans;\\n                \\n        for(auto w : words){\\n            int n = w.size();\\n            if(n == 0) continue;\\n            bool dp[n+1];\\n            memset(dp,false,sizeof(dp));\\n            dp[0] = true;\\n            \\n            for(int i=0; i<n; i++){\\n                if(dp[i] == false) continue;\\n                TrieNode *p = root;\\n                \\n                for(int j=i;j<n;j++){\\n                    if (!p->children[w[j]-\\'a\\'])break;   \\n                    p = p->children[w[j]-\\'a\\'];\\n                    if(i==0 && j==n-1)continue; //to skip one words (unconcatenated)\\n                    if(p->isLeaf)\\n                        dp[j+1]=true;\\n                }\\n                \\n                if(dp[n]){\\n                    ans.push_back(w);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic: \\n    struct TrieNode { \\n        TrieNode *children[26];\\n        bool isLeaf; \\n        TrieNode(){\\n            this->isLeaf = false;\\n            for(int i=0;i<26;i++){\\n                this->children[i]=NULL;\\n            }\\n        }\\n    }; \\n\\n    \\n    void insert(TrieNode *p, string w){ \\n        int n = w.size(); \\n\\n        for (int i = 0; i < n; i++) { \\n            int index = w[i]-\\'a\\'; \\n            if (!p->children[index]) \\n                p->children[index] = new TrieNode(); \\n            p = p->children[index]; \\n        }\\n\\n        p->isLeaf = true; \\n    } \\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words){\\n        TrieNode *root = new TrieNode();\\n        \\n        for (int i = 0; i < words.size(); i++) \\n            insert(root, words[i]);\\n        \\n        vector<string> ans;\\n                \\n        for(auto w : words){\\n            int n = w.size();\\n            if(n == 0) continue;\\n            bool dp[n+1];\\n            memset(dp,false,sizeof(dp));\\n            dp[0] = true;\\n            \\n            for(int i=0; i<n; i++){\\n                if(dp[i] == false) continue;\\n                TrieNode *p = root;\\n                \\n                for(int j=i;j<n;j++){\\n                    if (!p->children[w[j]-\\'a\\'])break;   \\n                    p = p->children[w[j]-\\'a\\'];\\n                    if(i==0 && j==n-1)continue; //to skip one words (unconcatenated)\\n                    if(p->isLeaf)\\n                        dp[j+1]=true;\\n                }\\n                \\n                if(dp[n]){\\n                    ans.push_back(w);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921095,
                "title": "simple-java-trie-solution-java-trie",
                "content": "```\\nclass Solution {\\n    public class Trie{\\n        Trie[] links = new Trie[26];\\n        boolean isEnd;\\n        public Trie(){}\\n    }\\n    \\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Trie root = new Trie();\\n        \\n        buildTrie(words, root);\\n        \\n        List<String> result = new ArrayList<>();\\n        for(String word: words){\\n            if(isConcatenated(word, 0, root)){\\n                result.add(word);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public void buildTrie(String[] words, Trie root){\\n        for(String word : words){\\n            Trie curr = root;\\n            for(char ch : word.toCharArray()){\\n                if(curr.links[ch-\\'a\\'] == null){\\n                    curr.links[ch-\\'a\\'] = new Trie();\\n                }\\n                curr =  curr.links[ch-\\'a\\'];\\n            }\\n            curr.isEnd = true;\\n        }\\n    }\\n    \\n    public boolean isConcatenated(String word, int count, Trie node){\\n        Trie curr = node;\\n        if(word.length() == 0 && count > 1){\\n            return true;\\n        }\\n        for(int i=0; i<word.length(); i++){\\n            curr = curr.links[word.charAt(i)-\\'a\\'];\\n            if(curr == null){\\n                return false;\\n            }\\n            if(curr.isEnd && isConcatenated(word.substring(i+1), count+1, node)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public class Trie{\\n        Trie[] links = new Trie[26];\\n        boolean isEnd;\\n        public Trie(){}\\n    }\\n    \\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Trie root = new Trie();\\n        \\n        buildTrie(words, root);\\n        \\n        List<String> result = new ArrayList<>();\\n        for(String word: words){\\n            if(isConcatenated(word, 0, root)){\\n                result.add(word);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public void buildTrie(String[] words, Trie root){\\n        for(String word : words){\\n            Trie curr = root;\\n            for(char ch : word.toCharArray()){\\n                if(curr.links[ch-\\'a\\'] == null){\\n                    curr.links[ch-\\'a\\'] = new Trie();\\n                }\\n                curr =  curr.links[ch-\\'a\\'];\\n            }\\n            curr.isEnd = true;\\n        }\\n    }\\n    \\n    public boolean isConcatenated(String word, int count, Trie node){\\n        Trie curr = node;\\n        if(word.length() == 0 && count > 1){\\n            return true;\\n        }\\n        for(int i=0; i<word.length(); i++){\\n            curr = curr.links[word.charAt(i)-\\'a\\'];\\n            if(curr == null){\\n                return false;\\n            }\\n            if(curr.isEnd && isConcatenated(word.substring(i+1), count+1, node)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835690,
                "title": "trie-dfs-solution-c",
                "content": "```\\nclass TrieNode {\\npublic:\\n    bool isKey = false;\\n    TrieNode* child[26];\\n};\\n\\nclass Solution {\\npublic:\\n    TrieNode* root = new TrieNode();\\n    \\n    void addWord (string word) {\\n        TrieNode* curr = root;\\n        for(char c : word) {\\n            if(!curr->child[c - \\'a\\'])\\n                curr->child[c - \\'a\\'] = new TrieNode();\\n            curr = curr->child[c - \\'a\\'];\\n        }\\n        curr->isKey = true;\\n    }\\n    \\n    bool search (string word, int index, int count) {\\n        if(index >= word.size()) return count >= 2;\\n        \\n        TrieNode* curr = root;\\n        \\n        for(int i = index; i < word.size(); i++) {\\n            char c = word[i];\\n            if(!curr->child[c - \\'a\\'])\\n                return false;\\n            curr = curr->child[c - \\'a\\'];\\n            if(curr->isKey) {\\n                if(search(word, i + 1, count + 1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict (vector<string>& words) {\\n        vector<string> res;\\n        if(words.size() == 0) \\n            return res;\\n        for(string s : words)\\n            addWord(s);\\n        for(string s : words) {\\n            if(search(s, 0, 0))\\n                res.push_back(s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n    bool isKey = false;\\n    TrieNode* child[26];\\n};\\n\\nclass Solution {\\npublic:\\n    TrieNode* root = new TrieNode();\\n    \\n    void addWord (string word) {\\n        TrieNode* curr = root;\\n        for(char c : word) {\\n            if(!curr->child[c - \\'a\\'])\\n                curr->child[c - \\'a\\'] = new TrieNode();\\n            curr = curr->child[c - \\'a\\'];\\n        }\\n        curr->isKey = true;\\n    }\\n    \\n    bool search (string word, int index, int count) {\\n        if(index >= word.size()) return count >= 2;\\n        \\n        TrieNode* curr = root;\\n        \\n        for(int i = index; i < word.size(); i++) {\\n            char c = word[i];\\n            if(!curr->child[c - \\'a\\'])\\n                return false;\\n            curr = curr->child[c - \\'a\\'];\\n            if(curr->isKey) {\\n                if(search(word, i + 1, count + 1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict (vector<string>& words) {\\n        vector<string> res;\\n        if(words.size() == 0) \\n            return res;\\n        for(string s : words)\\n            addWord(s);\\n        for(string s : words) {\\n            if(search(s, 0, 0))\\n                res.push_back(s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814638,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> st(words.begin(), words.end());\\n        vector<string> ans;\\n        \\n        for(auto &word:words)\\n        {\\n            int n=word.length();\\n            \\n            if(word==\"\")\\n                continue;\\n            \\n            vector<bool> dp(n+1,false);\\n            dp[n]=true;\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                string s=\"\";\\n                for(int j=i;j<n;j++)\\n                {\\n                    if(dp[i]==true)\\n                    {\\n                        break;\\n                    }\\n                    s+=word[j];\\n                    if(st.count(s) && dp[j+1] && s!=word)\\n                    {\\n                        dp[i]=true;\\n                    }\\n                }\\n            }\\n            \\n            if(dp[0]==true)\\n                ans.push_back(word);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> st(words.begin(), words.end());\\n        vector<string> ans;\\n        \\n        for(auto &word:words)\\n        {\\n            int n=word.length();\\n            \\n            if(word==\"\")\\n                continue;\\n            \\n            vector<bool> dp(n+1,false);\\n            dp[n]=true;\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                string s=\"\";\\n                for(int j=i;j<n;j++)\\n                {\\n                    if(dp[i]==true)\\n                    {\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 579896,
                "title": "java-dfs-easy-to-understand-with-concise-code",
                "content": "```\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        // make a set to hold all the words\\n        Set<String> set = new HashSet<>(Arrays.asList(words));\\n        // try every word by dfs\\n        for (String word : words) if (dfs(set, word, 0)) res.add(word);\\n        return res;\\n    }\\n\\n    private boolean dfs(Set<String> set, String word, int level) {\\n        // level must be above 0 if you want to claim this word meet true criteria\\n        if (set.contains(word) && level != 0) return true;\\n        for (int i = 1; i < word.length(); i++) {\\n            // check if prefix exists\\n            if (!set.contains(word.substring(0, i))) continue;\\n            // if suffix exists in set, finish and return true, or recursively check the suffix\\n            String suffix = word.substring(i);\\n            if (set.contains(suffix) || dfs(set, suffix, level + 1)) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        // make a set to hold all the words\\n        Set<String> set = new HashSet<>(Arrays.asList(words));\\n        // try every word by dfs\\n        for (String word : words) if (dfs(set, word, 0)) res.add(word);\\n        return res;\\n    }\\n\\n    private boolean dfs(Set<String> set, String word, int level) {\\n        // level must be above 0 if you want to claim this word meet true criteria\\n        if (set.contains(word) && level != 0) return true;\\n        for (int i = 1; i < word.length(); i++) {\\n            // check if prefix exists\\n            if (!set.contains(word.substring(0, i))) continue;\\n            // if suffix exists in set, finish and return true, or recursively check the suffix\\n            String suffix = word.substring(i);\\n            if (set.contains(suffix) || dfs(set, suffix, level + 1)) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 356692,
                "title": "hashset-dfs",
                "content": "```\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> list = new LinkedList<>();\\n        if (words == null || words.length == 0) return list;\\n        Set<String> set = new HashSet<>(Arrays.asList(words));\\n        for (String s: words){\\n            set.remove(s);\\n            if (this.search(s, set)) list.add(s);\\n            set.add(s);\\n        }\\n        return list;\\n    }\\n    \\n    private boolean search(String s, Set<String> set){\\n        if (set.contains(s)) return true;\\n        \\n        for (int i = 1; i <= s.length(); i++)\\n            if(set.contains(s.substring(0, i)) && this.search(s.substring(i), set)) return true;\\n        \\n        return false;\\n    }\\n```\\n\\nI think this is the easiest...",
                "solutionTags": [],
                "code": "```\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> list = new LinkedList<>();\\n        if (words == null || words.length == 0) return list;\\n        Set<String> set = new HashSet<>(Arrays.asList(words));\\n        for (String s: words){\\n            set.remove(s);\\n            if (this.search(s, set)) list.add(s);\\n            set.add(s);\\n        }\\n        return list;\\n    }\\n    \\n    private boolean search(String s, Set<String> set){\\n        if (set.contains(s)) return true;\\n        \\n        for (int i = 1; i <= s.length(); i++)\\n            if(set.contains(s.substring(0, i)) && this.search(s.substring(i), set)) return true;\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 353235,
                "title": "c-trie-and-dfs",
                "content": "```\\nclass Solution {\\nstruct TreeNode{\\n    int flag;\\n    TreeNode* child[26];\\n    TreeNode(){\\n        flag=0;\\n        for(int i=0;i<26;++i) child[i]=NULL;\\n    }\\n};\\nprivate:\\n    void insert(string s,TreeNode* root){\\n        int l=s.length();\\n        TreeNode* p=root;\\n        for(int i=0;i<l;++i){\\n            int ii=s[i]-\\'a\\';\\n            if(p->child[ii]==NULL) p->child[ii]=new TreeNode();\\n            p=p->child[ii];\\n        }\\n        p->flag=true;\\n    }\\n    int find(string s,TreeNode* root){\\n        int l=s.length();\\n        TreeNode* p=root;\\n        for(int i=0;i<l;++i){\\n            int ii=s[i]-\\'a\\';\\n            if(p->child[ii]!=NULL) p=p->child[ii];\\n            else return 0;\\n        }\\n        return p->flag;\\n    }\\n    int dfs(string s,TreeNode* root){\\n        int n=s.length();\\n        for(int i=1;i<n;++i)\\n            if(find(s.substr(0,i),root)&&(find(s.substr(i),root)||dfs(s.substr(i),root))) return 1;\\n        return 0;\\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> ans;\\n        TreeNode* root=new TreeNode();\\n        int n=words.size();\\n        for(int i=0;i<n;++i) insert(words[i],root);\\n        for(int i=0;i<n;++i) if(dfs(words[i],root)) ans.push_back(words[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nstruct TreeNode{\\n    int flag;\\n    TreeNode* child[26];\\n    TreeNode(){\\n        flag=0;\\n        for(int i=0;i<26;++i) child[i]=NULL;\\n    }\\n};\\nprivate:\\n    void insert(string s,TreeNode* root){\\n        int l=s.length();\\n        TreeNode* p=root;\\n        for(int i=0;i<l;++i){\\n            int ii=s[i]-\\'a\\';\\n            if(p->child[ii]==NULL) p->child[ii]=new TreeNode();\\n            p=p->child[ii];\\n        }\\n        p->flag=true;\\n    }\\n    int find(string s,TreeNode* root){\\n        int l=s.length();\\n        TreeNode* p=root;\\n        for(int i=0;i<l;++i){\\n            int ii=s[i]-\\'a\\';\\n            if(p->child[ii]!=NULL) p=p->child[ii];\\n            else return 0;\\n        }\\n        return p->flag;\\n    }\\n    int dfs(string s,TreeNode* root){\\n        int n=s.length();\\n        for(int i=1;i<n;++i)\\n            if(find(s.substr(0,i),root)&&(find(s.substr(i),root)||dfs(s.substr(i),root))) return 1;\\n        return 0;\\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> ans;\\n        TreeNode* root=new TreeNode();\\n        int n=words.size();\\n        for(int i=0;i<n;++i) insert(words[i],root);\\n        for(int i=0;i<n;++i) if(dfs(words[i],root)) ans.push_back(words[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95650,
                "title": "java-trie-solution",
                "content": "```\\npublic class Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> concatenated = new ArrayList<>();\\n        if (words == null || words.length <= 1) {\\n            return concatenated;\\n        }\\n        Trie root = new Trie();\\n        for (String word : words) {\\n            root.insert(word, 0);\\n        }\\n        for (String word : words) {\\n            if (segments(root, root, word, 0) > 1) {\\n                concatenated.add(word);\\n            }\\n        }\\n        return concatenated;\\n    }\\n\\n    private int segments(Trie root, Trie current, String word, int index) {\\n        if (word == null || index >= word.length()) {\\n            return 0;\\n        }\\n        char ch = word.charAt(index);\\n        if (!current.children.containsKey(ch)) {\\n            return 0;\\n        }\\n        \\n        int candidate1 = 0;\\n        if (current.children.get(ch).isWordEnd) {\\n            int recursive = segments(root, root, word, index + 1);\\n            candidate1 = recursive > 0 ? 1 + recursive : (index == word.length() - 1 ? 1 : 0);\\n        }\\n        if (candidate1 > 1) {\\n            return candidate1;\\n        }\\n        \\n        int candidate2 = segments(root, current.children.get(ch), word, index + 1);\\n        \\n        return Math.max(candidate1, candidate2);\\n    }\\n\\n    static class Trie {\\n        Map<Character, Trie> children = new HashMap<>();\\n        boolean isWordEnd;\\n\\n        public void insert(String str, int index) {\\n            if (str == null || index >= str.length()) {\\n                return;\\n            }\\n            char ch = str.charAt(index);\\n            if (!children.containsKey(ch)) {\\n                children.put(ch, new Trie());\\n            }\\n            if (index == str.length() - 1) {\\n                children.get(ch).isWordEnd = true;\\n            }\\n            children.get(ch).insert(str, index + 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> concatenated = new ArrayList<>();\\n        if (words == null || words.length <= 1) {\\n            return concatenated;\\n        }\\n        Trie root = new Trie();\\n        for (String word : words) {\\n            root.insert(word, 0);\\n        }\\n        for (String word : words) {\\n            if (segments(root, root, word, 0) > 1) {\\n                concatenated.add(word);\\n            }\\n        }\\n        return concatenated;\\n    }\\n\\n    private int segments(Trie root, Trie current, String word, int index) {\\n        if (word == null || index >= word.length()) {\\n            return 0;\\n        }\\n        char ch = word.charAt(index);\\n        if (!current.children.containsKey(ch)) {\\n            return 0;\\n        }\\n        \\n        int candidate1 = 0;\\n        if (current.children.get(ch).isWordEnd) {\\n            int recursive = segments(root, root, word, index + 1);\\n            candidate1 = recursive > 0 ? 1 + recursive : (index == word.length() - 1 ? 1 : 0);\\n        }\\n        if (candidate1 > 1) {\\n            return candidate1;\\n        }\\n        \\n        int candidate2 = segments(root, current.children.get(ch), word, index + 1);\\n        \\n        return Math.max(candidate1, candidate2);\\n    }\\n\\n    static class Trie {\\n        Map<Character, Trie> children = new HashMap<>();\\n        boolean isWordEnd;\\n\\n        public void insert(String str, int index) {\\n            if (str == null || index >= str.length()) {\\n                return;\\n            }\\n            char ch = str.charAt(index);\\n            if (!children.containsKey(ch)) {\\n                children.put(ch, new Trie());\\n            }\\n            if (index == str.length() - 1) {\\n                children.get(ch).isWordEnd = true;\\n            }\\n            children.get(ch).insert(str, index + 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 95646,
                "title": "simple-c-199ms-hash-map-solution-no-tries-and-no-dp",
                "content": "I am so surprised that this simple (kind of brute force) solution can work that good. It basically puts every word into a hash map and then checks if sub-component of each word existed in the hash map recursively.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_map<string,bool> dic;\\n        for (int i=0;i<words.size();i++) {\\n            dic[words[i]]=true;\\n        }\\n        \\n        vector<string> res;\\n        for (int i=0;i<words.size();i++) {\\n            if (isConcatenated(words[i],dic,false)) res.push_back(words[i]);\\n        }\\n        return res;\\n    }\\n    \\n    bool isConcatenated(string word, unordered_map<string,bool>& dic, bool compareWholeWord) {\\n        if (word.size()==0) return compareWholeWord;\\n        if (compareWholeWord&&dic.count(word)>0) return dic[word];\\n        for (int len=1;len<word.size();len++) {\\n            if (dic.count(word.substr(0,len))>0&&dic[word.substr(0,len)]) {\\n                if (isConcatenated(word.substr(len),dic,true)) {\\n                    dic[word]=true;\\n                    return true;\\n                }\\n            } \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_map<string,bool> dic;\\n        for (int i=0;i<words.size();i++) {\\n            dic[words[i]]=true;\\n        }\\n        \\n        vector<string> res;\\n        for (int i=0;i<words.size();i++) {\\n            if (isConcatenated(words[i],dic,false)) res.push_back(words[i]);\\n        }\\n        return res;\\n    }\\n    \\n    bool isConcatenated(string word, unordered_map<string,bool>& dic, bool compareWholeWord) {\\n        if (word.size()==0) return compareWholeWord;\\n        if (compareWholeWord&&dic.count(word)>0) return dic[word];\\n        for (int len=1;len<word.size();len++) {\\n            if (dic.count(word.substr(0,len))>0&&dic[word.substr(0,len)]) {\\n                if (isConcatenated(word.substr(len),dic,true)) {\\n                    dic[word]=true;\\n                    return true;\\n                }\\n            } \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281104,
                "title": "472-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a set of all words in the given list.\\n2. Define a recursive function called isConcat to check if a word is concatenated.\\n3. Memoize the isConcat function using the functools.lru_cache decorator to cache its results and improve performance.\\n4. For a given word, try all possible splits of the word by iterating over its characters using a for loop.\\n5. For each split, get the prefix and suffix of the split using string slicing.\\n6. Check if the prefix is in the wordSet.\\n7. If the prefix is in the wordSet, check if the suffix is either in the wordSet or can be formed by concatenating other words by recursively calling the isConcat function on the suffix.\\n8. If the suffix is either in the wordSet or can be formed by concatenating other words, then the word is concatenated and we can return True from the isConcat function.\\n9. If none of the splits result in a concatenated word, then the word is not concatenated and we can return False from the isConcat function.\\n10. Use a list comprehension to get all concatenated words by iterating over the words in the input list and calling the isConcat function on each word.\\n11. Return the list of concatenated words.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        # Create a set of all words in the given list\\n        wordSet = set(words)\\n\\n        # Define a recursive function to check if a word is concatenated\\n        @functools.lru_cache(None)  # Memoize the function with least-recently-used cache\\n        def isConcat(word: str) -> bool:\\n            for i in range(1, len(word)):  # Try all possible splits of the word\\n                prefix = word[:i]  # Get the prefix of the split\\n                suffix = word[i:]  # Get the suffix of the split\\n                if prefix in wordSet and (suffix in wordSet or isConcat(suffix)):\\n                    # If the prefix is in the wordSet and the suffix is either in the wordSet\\n                    # or can be formed by concatenating other words, then the word is\\n                    # concatenated\\n                    return True\\n            return False\\n\\n        # Use a list comprehension to get all concatenated words\\n        return [word for word in words if isConcat(word)]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        # Create a set of all words in the given list\\n        wordSet = set(words)\\n\\n        # Define a recursive function to check if a word is concatenated\\n        @functools.lru_cache(None)  # Memoize the function with least-recently-used cache\\n        def isConcat(word: str) -> bool:\\n            for i in range(1, len(word)):  # Try all possible splits of the word\\n                prefix = word[:i]  # Get the prefix of the split\\n                suffix = word[i:]  # Get the suffix of the split\\n                if prefix in wordSet and (suffix in wordSet or isConcat(suffix)):\\n                    # If the prefix is in the wordSet and the suffix is either in the wordSet\\n                    # or can be formed by concatenating other words, then the word is\\n                    # concatenated\\n                    return True\\n            return False\\n\\n        # Use a list comprehension to get all concatenated words\\n        return [word for word in words if isConcat(word)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106651,
                "title": "hey-cool-cat-can-you-beat-me-o-n2",
                "content": "![memecat.jpeg](https://assets.leetcode.com/users/images/7102d04a-afb4-46ab-ae02-5b7c0a739ddc_1674845448.8218856.jpeg)\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/0f9efa19-3728-4245-9880-22f8b47e86bc_1674846522.0877063.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:o(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic List<String> findAllConcatenatedWordsInADict(String[] W) {\\n    var set = new HashSet<String>(); int min=31;\\n    for(var v: W){\\n        set.add(v);\\n        min = Math.min(min,v.length());\\n    } var ans = new ArrayList<String>();\\n    for(var v: W) if(isConcat(v,set,0,v.length(),min)) ans.add(v);\\n    return ans; \\n} private boolean isConcat(String w,Set<String> s,int start,int end,int min){\\n    for(int i=start+min;i<=end-min;i++)\\n        if (s.contains(w.substring(start,i)) && (s.contains(w.substring(i,end)) || isConcat(w,s,i,end,min))) return true;\\nreturn false; }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic List<String> findAllConcatenatedWordsInADict(String[] W) {\\n    var set = new HashSet<String>(); int min=31;\\n    for(var v: W){\\n        set.add(v);\\n        min = Math.min(min,v.length());\\n    } var ans = new ArrayList<String>();\\n    for(var v: W) if(isConcat(v,set,0,v.length(),min)) ans.add(v);\\n    return ans; \\n} private boolean isConcat(String w,Set<String> s,int start,int end,int min){\\n    for(int i=start+min;i<=end-min;i++)\\n        if (s.contains(w.substring(start,i)) && (s.contains(w.substring(i,end)) || isConcat(w,s,i,end,min))) return true;\\nreturn false; }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3106519,
                "title": "simple-java-easy-beginners-steps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    HashSet<String> set;\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> res=new ArrayList<>();\\n        if(words.length==0) return res;\\n        set=new HashSet<>();\\n        for(String word : words)\\n        {\\n            set.add(word);\\n        }\\n        for(String word : words)\\n        {\\n            if(isConcat(word))res.add(word);\\n        }\\n        return res;\\n    }\\n    private boolean isConcat(String word)\\n    {\\n        int len=word.length();\\n        for(int i=1;i<len;i++)\\n        {\\n            String suffix=word.substring(i);\\n            if(set.contains(word.substring(0,i)) && (set.contains(suffix) || isConcat(suffix)))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashSet<String> set;\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        List<String> res=new ArrayList<>();\\n        if(words.length==0) return res;\\n        set=new HashSet<>();\\n        for(String word : words)\\n        {\\n            set.add(word);\\n        }\\n        for(String word : words)\\n        {\\n            if(isConcat(word))res.add(word);\\n        }\\n        return res;\\n    }\\n    private boolean isConcat(String word)\\n    {\\n        int len=word.length();\\n        for(int i=1;i<len;i++)\\n        {\\n            String suffix=word.substring(i);\\n            if(set.contains(word.substring(0,i)) && (set.contains(suffix) || isConcat(suffix)))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106507,
                "title": "c-not-using-dp-easy",
                "content": "# Intuition\\nSo I have seen many DP Solutions here.\\nInstead of DP I used normal BFS but with Set,\\nBasically what DP does here is to avoid the same computation at a given index being queried multiple times due to recursion (worst case exponential)....so you use DP so as the queries are only entertained once and convert it into n^2 time (for n=string length).\\n\\n# Approach\\nBasically I kept this same concept in mind and Made a set which records partitions already pushed in queue once and so to not to compute them further every time they are added in queue due to various possible ways to reach there for a partition.\\n\\n# Complexity\\n- Time complexity:\\nO(N*(stringlength^2))\\n\\n- Space complexity:\\nO(N*stringlength)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) \\n    {\\n        unordered_map<string,bool>existsinwords;\\n        for(auto j:words)\\n        {\\n            existsinwords[j]=true;\\n        }\\n        vector<string>ans;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            bool partitionreachedend=false;\\n            //string: cat, partitions:|c|a|t|\\n            queue<int>checkfor;\\n            unordered_set<int>alreadypushedinqueue;\\n            checkfor.push(-1);\\n            while(!checkfor.empty())\\n            {\\n                int indexofword=checkfor.front();\\n                checkfor.pop();\\n                if(indexofword==(words[i].size()-1))\\n                {\\n                    partitionreachedend=true;\\n                    break;\\n                }\\n                string str;\\n                for(int j=indexofword+1;j<words[i].size();j++)\\n                {\\n                    str.push_back(words[i][j]);\\n                    if(existsinwords[str] && (j-indexofword)!=words[i].size())\\n                    {\\n                        if(alreadypushedinqueue.count(j)==0)\\n                        {\\n                            checkfor.push(j);\\n                            alreadypushedinqueue.insert(j);\\n                        }\\n                    }\\n                }\\n            }\\n            if(partitionreachedend)\\n            {\\n                ans.push_back(words[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) \\n    {\\n        unordered_map<string,bool>existsinwords;\\n        for(auto j:words)\\n        {\\n            existsinwords[j]=true;\\n        }\\n        vector<string>ans;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            bool partitionreachedend=false;\\n            //string: cat, partitions:|c|a|t|\\n            queue<int>checkfor;\\n            unordered_set<int>alreadypushedinqueue;\\n            checkfor.push(-1);\\n            while(!checkfor.empty())\\n            {\\n                int indexofword=checkfor.front();\\n                checkfor.pop();\\n                if(indexofword==(words[i].size()-1))\\n                {\\n                    partitionreachedend=true;\\n                    break;\\n                }\\n                string str;\\n                for(int j=indexofword+1;j<words[i].size();j++)\\n                {\\n                    str.push_back(words[i][j]);\\n                    if(existsinwords[str] && (j-indexofword)!=words[i].size())\\n                    {\\n                        if(alreadypushedinqueue.count(j)==0)\\n                        {\\n                            checkfor.push(j);\\n                            alreadypushedinqueue.insert(j);\\n                        }\\n                    }\\n                }\\n            }\\n            if(partitionreachedend)\\n            {\\n                ans.push_back(words[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105786,
                "title": "java-dp-approach-using-set",
                "content": "Will post the Explanation Soon. Maybe.\\n# Code\\n```\\n//Can we can make a string from a cobmination of other strings present in the words array?\\n//Looks like we can use the set data structure to store all the distinct string values\\n//Then iterate over every string to see if we can combine the other strings to make the current string \\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> set = new HashSet<>(); \\n        List<String> result = new ArrayList<>(); \\n        for(String word : words){\\n            set.add(word);\\n        }\\n    // Iterate over the array\\n        for(String word : words){ \\n            int sz = word.length();\\n        // Putting flags where the smaller valid string ends \\n            boolean[] flags = new boolean[sz + 1]; \\n            flags[0] = true;\\n            //Iterate over the string\\n            for(int i = 0; i < sz; i++){\\n            //Skipping already included characters\\n                if(!flags[i]){ \\n                    continue;\\n                }\\n            //Finding substrings which are present in the word array\\n                for(int k = i + 1; k <= sz; k++){\\n                  if(k - i < sz && set.contains(word.substring(i, k))){\\n                      flags[k] = true; // put down the flag where the selected smaller string ends \\n                  }  \\n                }\\n            //If the string is successfully made\\n            //by combination of other strings add it to the result and break out of\\n            //the loop to avoid adding repeated strings to the result\\n                if(flags[sz]){ \\n                    result.add(word); \\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Can we can make a string from a cobmination of other strings present in the words array?\\n//Looks like we can use the set data structure to store all the distinct string values\\n//Then iterate over every string to see if we can combine the other strings to make the current string \\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> set = new HashSet<>(); \\n        List<String> result = new ArrayList<>(); \\n        for(String word : words){\\n            set.add(word);\\n        }\\n    // Iterate over the array\\n        for(String word : words){ \\n            int sz = word.length();\\n        // Putting flags where the smaller valid string ends \\n            boolean[] flags = new boolean[sz + 1]; \\n            flags[0] = true;\\n            //Iterate over the string\\n            for(int i = 0; i < sz; i++){\\n            //Skipping already included characters\\n                if(!flags[i]){ \\n                    continue;\\n                }\\n            //Finding substrings which are present in the word array\\n                for(int k = i + 1; k <= sz; k++){\\n                  if(k - i < sz && set.contains(word.substring(i, k))){\\n                      flags[k] = true; // put down the flag where the selected smaller string ends \\n                  }  \\n                }\\n            //If the string is successfully made\\n            //by combination of other strings add it to the result and break out of\\n            //the loop to avoid adding repeated strings to the result\\n                if(flags[sz]){ \\n                    result.add(word); \\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105324,
                "title": "hindi-version-c-dp-memoization",
                "content": "This post is written in hindi as there are very less post explaining approach in hindi.\\n\\n# Approach\\nHum approach mein ye kar rahe hai ki prefix and suffix ko check karenge ki agar current word ka prefix and suffix hamare set mein hai toh usse apne answer mein rakh lo ya phir agar prefix set mein hai and suffix ek concatenated word hai toh usse bhi check karlo and agar uska answer bhi true milega toh apne answer mein rakh lo usse.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*(lengthOfWord)^4)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n// ye helper function basically hume help karega ye find karne mein ki kya prefix ya suffix current word ka present hai hamare words mein.\\n    bool helper(string word,unordered_set<string>&st)\\n    {\\n        // agar current word ko already solve kar chuke hai toh return kardunga jo bhi value hogi map mein current word ke liye\\n        if(mp.find(word)!=mp.end())\\n        {\\n            return mp[word];\\n        }\\n        int n = word.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            // current prefix ko rakh lenge apne pass\\n            string prefix = word.substr(0,i+1);\\n            // current suffix ko rakh lenge apne paas\\n            string suffix = word.substr(i+1);\\n            // ab 2 cases hai jinme mein se ek bhi true hogaya toh hume answer mil jaayega:\\n            // case-1 : Agar hume current prefix mein milgaya hai toh hume ye check karna hoga ki kahin aesa toh nahi ki suffix jo hai woh bhi concatenated ho\\n            // case-2 : agar hume current prefix and curren suffix dono hamare words mein mil jaate hai\\n            if((st.find(prefix)!=st.end() && helper(suffix,st)) || (st.find(prefix)!=st.end() && st.find(suffix)!=st.end()))\\n            {\\n                return mp[word] = true;\\n            }\\n        }\\n        // agar current word ke liye koyi bhi prefix ya suffix present nahi hai hamare words mein toh iska matlab current word concatenated word nahi hai\\n        return mp[word] = false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        int n = words.size();\\n        unordered_set<string>st;\\n        vector<string>res;\\n        mp.clear();\\n        // saare words ko unordered_set mein rakh lenge taaki baad mein check kar saken apne helper function mein ki kya jo prefix ya suffix hume mil raha hai woh hamara words mein present hai\\n        for(auto it:words)\\n        {\\n            st.insert(it);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            string word = words[i];\\n            // current word ko helper function mein send karenge and agar answer true mila toh apne result mein current word ko add kardenge\\n            if(helper(word,st))\\n            {\\n                res.push_back(word);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAgar post se kuch help mili ho toh please upvote karna!!!",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n// ye helper function basically hume help karega ye find karne mein ki kya prefix ya suffix current word ka present hai hamare words mein.\\n    bool helper(string word,unordered_set<string>&st)\\n    {\\n        // agar current word ko already solve kar chuke hai toh return kardunga jo bhi value hogi map mein current word ke liye\\n        if(mp.find(word)!=mp.end())\\n        {\\n            return mp[word];\\n        }\\n        int n = word.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            // current prefix ko rakh lenge apne pass\\n            string prefix = word.substr(0,i+1);\\n            // current suffix ko rakh lenge apne paas\\n            string suffix = word.substr(i+1);\\n            // ab 2 cases hai jinme mein se ek bhi true hogaya toh hume answer mil jaayega:\\n            // case-1 : Agar hume current prefix mein milgaya hai toh hume ye check karna hoga ki kahin aesa toh nahi ki suffix jo hai woh bhi concatenated ho\\n            // case-2 : agar hume current prefix and curren suffix dono hamare words mein mil jaate hai\\n            if((st.find(prefix)!=st.end() && helper(suffix,st)) || (st.find(prefix)!=st.end() && st.find(suffix)!=st.end()))\\n            {\\n                return mp[word] = true;\\n            }\\n        }\\n        // agar current word ke liye koyi bhi prefix ya suffix present nahi hai hamare words mein toh iska matlab current word concatenated word nahi hai\\n        return mp[word] = false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        int n = words.size();\\n        unordered_set<string>st;\\n        vector<string>res;\\n        mp.clear();\\n        // saare words ko unordered_set mein rakh lenge taaki baad mein check kar saken apne helper function mein ki kya jo prefix ya suffix hume mil raha hai woh hamara words mein present hai\\n        for(auto it:words)\\n        {\\n            st.insert(it);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            string word = words[i];\\n            // current word ko helper function mein send karenge and agar answer true mila toh apne result mein current word ko add kardenge\\n            if(helper(word,st))\\n            {\\n                res.push_back(word);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105207,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DP\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * L^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N * L)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> st;\\n        for(auto x: words) st.insert(x);\\n        vector<string> ans;\\n        for(auto word: words) {\\n            int n = word.size();\\n            vector<int> dp(n + 1);\\n            dp[0] = 1;\\n            for(int i=0; i<n; i++) {\\n                if(!dp[i]) continue;\\n                for(int j=i+1; j<=n; j++) {\\n                    if(j - i < n and st.count(word.substr(i, j - i))) {\\n                        dp[j] = 1;\\n                    }\\n                }\\n                if(dp[n]) {\\n                    ans.push_back(word);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> st;\\n        for(auto x: words) st.insert(x);\\n        vector<string> ans;\\n        for(auto word: words) {\\n            int n = word.size();\\n            vector<int> dp(n + 1);\\n            dp[0] = 1;\\n            for(int i=0; i<n; i++) {\\n                if(!dp[i]) continue;\\n                for(int j=i+1; j<=n; j++) {\\n                    if(j - i < n and st.count(word.substr(i, j - i))) {\\n                        dp[j] = 1;\\n                    }\\n                }\\n                if(dp[n]) {\\n                    ans.push_back(word);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104930,
                "title": "ruby-solution-t-484-ms-beats-100-m-213-4-mb-beats-100",
                "content": "# Approach\\nI have used DFS.\\n\\n# Code\\n```ruby []\\n# @param {String[]} words\\n# @return {String[]}\\ndef find_all_concatenated_words_in_a_dict(words)\\n  @words_hash = words.tally\\n\\n  words.each_with_object([]) do |word, result|\\n    result << word  if check_word(word, 0)\\n  end\\nend\\n\\ndef check_word(word, step)\\n  return step >= 2 if word == \\'\\'\\n\\n  1.upto(word.size) do |index|\\n    return true if @words_hash[word[0...index]] && check_word(word[index...], step + 1)\\n  end\\n\\n  false\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby []\\n# @param {String[]} words\\n# @return {String[]}\\ndef find_all_concatenated_words_in_a_dict(words)\\n  @words_hash = words.tally\\n\\n  words.each_with_object([]) do |word, result|\\n    result << word  if check_word(word, 0)\\n  end\\nend\\n\\ndef check_word(word, step)\\n  return step >= 2 if word == \\'\\'\\n\\n  1.upto(word.size) do |index|\\n    return true if @words_hash[word[0...index]] && check_word(word[index...], step + 1)\\n  end\\n\\n  false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3104397,
                "title": "easy-to-understand-using-dp",
                "content": "# Intuition\\nwe are just checking for each word whether the word can be formed by concatenation or not.In conc() function we are using **min(n-1,n-i)** because j is length we are going to check in the map if the length is equal to n then whole string will be checked and it will always return true;\\n\\n# Complexity\\n- Time complexity:\\nO(m*(n^2)) where m is no of words and n is length of each word\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nunordered_map<string,int>mp;\\nint dp[31];\\n   bool conc(string &word,int i)\\n   {\\n       int n=word.size();\\n       if(i==n)\\n       return true;\\n       if(dp[i]!=-1)\\n       return dp[i];\\n       bool a=false;\\n       for(int j=1;j<=min(n-1,n-i);j++)//j is length of string from i\\'th index\\n       {\\n           if(mp[word.substr(i,j)]>0)\\n           {\\n               a=a||conc(word,i+j);\\n           }\\n       }\\n       return dp[i]=a;\\n   }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(),words.end());\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[words[i]]++;\\n        }  \\n        vector<string>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            memset(dp,-1,sizeof(dp));\\n           if(conc(words[i],0))\\n           ans.push_back(words[i]);\\n        }      \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nunordered_map<string,int>mp;\\nint dp[31];\\n   bool conc(string &word,int i)\\n   {\\n       int n=word.size();\\n       if(i==n)\\n       return true;\\n       if(dp[i]!=-1)\\n       return dp[i];\\n       bool a=false;\\n       for(int j=1;j<=min(n-1,n-i);j++)//j is length of string from i\\'th index\\n       {\\n           if(mp[word.substr(i,j)]>0)\\n           {\\n               a=a||conc(word,i+j);\\n           }\\n       }\\n       return dp[i]=a;\\n   }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(),words.end());\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[words[i]]++;\\n        }  \\n        vector<string>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            memset(dp,-1,sizeof(dp));\\n           if(conc(words[i],0))\\n           ans.push_back(words[i]);\\n        }      \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104316,
                "title": "maps-cpp-solve-map-recursive-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMap stores the words \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrecursive approaches\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(string s,vector<string>& words,map<string,int>& mapp,string r,int vals){\\n        if(s.size()==0&&vals>=2)\\n        {\\n            return true;\\n        }\\n        else if(s.size()==0)\\n        return false;\\n        for(int p=1;p<=s.size();p++){\\n            if(mapp.count(s.substr(0,p))>0){\\n            if(solve(s.substr(p),words,mapp,r,vals+1))\\n        {return true;}\\n        }}\\n   return  false;}\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n       vector<string> sols;\\n       map<string,int> mapp;\\n       for(int p=0;p<words.size();p++){\\n           mapp[words[p]]++;\\n       }\\n       for(int po=0;po<words.size();po++){\\n       if(solve(words[po],words,mapp,\"\",0))\\n       sols.push_back(words[po]);\\n       }\\n        return sols;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(string s,vector<string>& words,map<string,int>& mapp,string r,int vals){\\n        if(s.size()==0&&vals>=2)\\n        {\\n            return true;\\n        }\\n        else if(s.size()==0)\\n        return false;\\n        for(int p=1;p<=s.size();p++){\\n            if(mapp.count(s.substr(0,p))>0){\\n            if(solve(s.substr(p),words,mapp,r,vals+1))\\n        {return true;}\\n        }}\\n   return  false;}\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n       vector<string> sols;\\n       map<string,int> mapp;\\n       for(int p=0;p<words.size();p++){\\n           mapp[words[p]]++;\\n       }\\n       for(int po=0;po<words.size();po++){\\n       if(solve(words[po],words,mapp,\"\",0))\\n       sols.push_back(words[po]);\\n       }\\n        return sols;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104305,
                "title": "c-binary-search-on-string-easy-solution-with-crisp-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is pretty simple.. Try to partition each word at each index and check every partitions are present in words vector. If it is then push it in ans vector and at the end return it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the words vector so that we can find any word within log(n) time.\\n2. Take every word and recursively do partition on each index and check if the both partition (before and after index) are present in word vector. \\n3. for example: `words = [ \"cat\", \"dog\", \"s\", \"catsdog\" ]`\\n   and we are checking for `s = \"catsdog\"`\\n\\n   So run a loop from 0 to s.size() and make partition on each index.\\n   - At first the left partition=\"c\" and right parition=\"atsdog\"\\n        - Check left partition is present in words vector..\\n        it\\'s not present. So continue this process..\\n   - Repeat the process untill left partition=\"cat\" and right partition=\"sdog\".\\n        - Now left partition is present in word vector (use binary search for finding).\\n        - As left partition is present so we will check if the right partition is also present or not.. \\n        - If it is then we will directly return true and if it is not then call the function for right partition to do the same. \\n\\n    - For this example the right partition \"sdog\" is not present in word vector. so `f(\"sdog\")` call will go.\\n    \\n    - Now like before again a loop will run from 0 to s.size() and make partition on each index. At first the left partition=\"s\" and right parition=\"dog\".\\n        - Now left partition is present in word vector and we will now check if right partition is present or not. \\n        - Here both partition is present so we will return true.\\n\\n    - And in the end if it returns true then we will push the string to ans vector and return the ans vector finally.\\n\\n# Complexity\\n- `Time complexity: O(nllog(n))`. where `n` is the number of words in the input vector, and `l` is the length of the longest word in the input vector.\\nThe sorting of the input vector takes `O(nlog(n))` time.\\nFor each word in the input vector, the function is_concatenated() is called, which takes `O(l)` time to check each substring of the word and check if it exists in the input vector using the is_present() function, which takes `O(log(n))` time as it uses binary search to check the presence of a word in the input vector.\\nSo, the total time complexity is O(nlog(n)) + O(nllog(n)) = O(nllog(n)).\\n\\n- `Space complexity: O(n)`. Ignoring recursion stack space.\\n\\n# Humble Request: Please UPVOTE so that it helps others as well. :)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool is_present(string &s, vector<string> &words){\\n        int low=0, high=words.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(words[mid]==s){\\n                return true;\\n            }else if(words[mid]<s){\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool is_concatenated(string s, vector<string> &words){\\n        string left=\"\";\\n        for(int i=0; i<s.size(); i++){\\n            left+=s[i];\\n            if(is_present(left,words)){\\n                string right=s.substr(i+1);\\n                if(is_present(right,words)) return true;\\n                if(is_concatenated(right,words)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(),words.end());\\n        vector<string> ans;\\n        for(int i=0; i<words.size(); i++){\\n            string s=words[i];\\n            if(is_concatenated(s,words)) ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool is_present(string &s, vector<string> &words){\\n        int low=0, high=words.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(words[mid]==s){\\n                return true;\\n            }else if(words[mid]<s){\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    bool is_concatenated(string s, vector<string> &words){\\n        string left=\"\";\\n        for(int i=0; i<s.size(); i++){\\n            left+=s[i];\\n            if(is_present(left,words)){\\n                string right=s.substr(i+1);\\n                if(is_present(right,words)) return true;\\n                if(is_concatenated(right,words)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        sort(words.begin(),words.end());\\n        vector<string> ans;\\n        for(int i=0; i<words.size(); i++){\\n            string s=words[i];\\n            if(is_concatenated(s,words)) ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104048,
                "title": "no-need-dp-only-recursion-is-enough-easy",
                "content": "**NOTE** : \\ncode is self explenatory , if you have any doubts do let me know in the comments \\u270C\\uFE0F\\n\\n**Intuition**: \\nSeeing these kind of problems, first thing that hit\\'s your brain is **Recursion**.\\n\\n**Approach**:\\nHere we recursively check for each string.\\n\\n* whenever we found a string that is present in our map we have two choices either take it or not take it.\\n* Out of these two the one which gives true , we consider that one.\\n* that\\'s it \\n\\n\\n**Please upvote if you like the post :)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for(auto &s : words) mp[s]++;\\n        vector<string> res;\\n        for(auto &x : words){\\n            if(dfs(0,0,0,x)==true) res.push_back(x);\\n        }\\n        return res;\\n    }\\n    \\n    bool dfs(int start,int pos,int c,string &s){\\n        if(pos>=s.size()){\\n            if(c>=2 and start==pos) return true;\\n            return false;\\n        }\\n        \\n        bool ans = false;\\n        if(mp.count(s.substr(start,pos-start+1))){\\n            if(dfs(pos+1,pos+1,c+1,s)==true) ans |= true;\\n            else if(dfs(start,pos+1,c,s)==true) ans |= true;\\n        }\\n        else{\\n            if(dfs(start,pos+1,c,s)==true) ans |= true;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for(auto &s : words) mp[s]++;\\n        vector<string> res;\\n        for(auto &x : words){\\n            if(dfs(0,0,0,x)==true) res.push_back(x);\\n        }\\n        return res;\\n    }\\n    \\n    bool dfs(int start,int pos,int c,string &s){\\n        if(pos>=s.size()){\\n            if(c>=2 and start==pos) return true;\\n            return false;\\n        }\\n        \\n        bool ans = false;\\n        if(mp.count(s.substr(start,pos-start+1))){\\n            if(dfs(pos+1,pos+1,c+1,s)==true) ans |= true;\\n            else if(dfs(start,pos+1,c,s)==true) ans |= true;\\n        }\\n        else{\\n            if(dfs(start,pos+1,c,s)==true) ans |= true;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104016,
                "title": "easily-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> words_set;\\n        for (string word : words) words_set.insert(word);\\n        vector<string> res;\\n    \\n        for (string word : words) {\\n            int n = word.size();\\n            vector<int> dp(n + 1, 0);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (!dp[i]) continue;\\n                for (int j = i + 1; j <= n; j++) {\\n                    if (j - i < n && words_set.count(word.substr(i, j - i))) {\\n                        dp[j] = 1;\\n                    }\\n                }\\n                if (dp[n]) {\\n                    res.push_back(word);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> words_set;\\n        for (string word : words) words_set.insert(word);\\n        vector<string> res;\\n    \\n        for (string word : words) {\\n            int n = word.size();\\n            vector<int> dp(n + 1, 0);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (!dp[i]) continue;\\n                for (int j = i + 1; j <= n; j++) {\\n                    if (j - i < n && words_set.count(word.substr(i, j - i))) {\\n                        dp[j] = 1;\\n                    }\\n                }\\n                if (dp[n]) {\\n                    res.push_back(word);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103936,
                "title": "c-trie-dfs-easy-solution",
                "content": "# Approach\\n    Use Trie Data Structure and do dfs to find the count of words that are used to make the current word\\n\\n# Complexity\\n- Time complexity:\\n-   O(N^2)\\n\\n- Space complexity:\\n-   O(26*N)\\n# Code\\n```\\n\\nstruct Node{\\n    bool end = false;\\n    Node* next[26] = { NULL };\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        root = new Node();\\n        for(const auto& word : words)\\n            add(word);\\n\\n        for(const auto& word : words){\\n            if(dfs(0, 0, word.size(), word))\\n                ans.push_back(word);\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    Node* root;\\n    vector<string> ans;\\n    void add(const string& str) {\\n        auto cur = root;\\n        for(auto& ch : str) {\\n            if(!cur->next[ch-\\'a\\']) cur->next[ch-\\'a\\'] = new Node();\\n            cur = cur->next[ch-\\'a\\'];\\n        }\\n        cur->end = true;\\n    }\\n\\n    bool dfs(int i, int cnt, int n, const string& s){\\n        if(i == n) return cnt > 1;\\n        auto cur = root;\\n        while(i<n && cur->next[s[i]-\\'a\\'] != NULL) {\\n            cur = cur->next[s[i] - \\'a\\'];\\n            i++;\\n            if(cur->end) {\\n                if(dfs(i, cnt+1, n, s)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\n\\nstruct Node{\\n    bool end = false;\\n    Node* next[26] = { NULL };\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        root = new Node();\\n        for(const auto& word : words)\\n            add(word);\\n\\n        for(const auto& word : words){\\n            if(dfs(0, 0, word.size(), word))\\n                ans.push_back(word);\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    Node* root;\\n    vector<string> ans;\\n    void add(const string& str) {\\n        auto cur = root;\\n        for(auto& ch : str) {\\n            if(!cur->next[ch-\\'a\\']) cur->next[ch-\\'a\\'] = new Node();\\n            cur = cur->next[ch-\\'a\\'];\\n        }\\n        cur->end = true;\\n    }\\n\\n    bool dfs(int i, int cnt, int n, const string& s){\\n        if(i == n) return cnt > 1;\\n        auto cur = root;\\n        while(i<n && cur->next[s[i]-\\'a\\'] != NULL) {\\n            cur = cur->next[s[i] - \\'a\\'];\\n            i++;\\n            if(cur->end) {\\n                if(dfs(i, cnt+1, n, s)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103856,
                "title": "easy-c-recursive-code-864-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Simple approach with take and not take method.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<string,int> mp; //to store all word,in order to access them in O(1) when require. \\n    bool f(int i,string &s,int cnt,string q){\\n        if(i == s.size()){\\n            if(cnt > 1 && q == \"\"){\\n                return true;\\n            }\\n            return false;\\n        }\\n        q += s[i];\\n        string g;\\n        //take\\n        if(mp[q]){\\n            return (f(i+1,s,cnt+1,g)||f(i+1,s,cnt,q));\\n        }\\n        //not take\\n        return f(i+1,s,cnt,q);\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n       \\n        vector<string> ans;\\n        for(auto it : words){\\n            mp[it]++;\\n        }\\n        for(auto x : words){\\n            string temp = x;\\n            string q;\\n            //f checks whether given condition in problem is satisfying or not.\\n            if(f(0,x,0,q)){\\n                ans.push_back(x); //if yes append it to ans.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<string,int> mp; //to store all word,in order to access them in O(1) when require. \\n    bool f(int i,string &s,int cnt,string q){\\n        if(i == s.size()){\\n            if(cnt > 1 && q == \"\"){\\n                return true;\\n            }\\n            return false;\\n        }\\n        q += s[i];\\n        string g;\\n        //take\\n        if(mp[q]){\\n            return (f(i+1,s,cnt+1,g)||f(i+1,s,cnt,q));\\n        }\\n        //not take\\n        return f(i+1,s,cnt,q);\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n       \\n        vector<string> ans;\\n        for(auto it : words){\\n            mp[it]++;\\n        }\\n        for(auto x : words){\\n            string temp = x;\\n            string q;\\n            //f checks whether given condition in problem is satisfying or not.\\n            if(f(0,x,0,q)){\\n                ans.push_back(x); //if yes append it to ans.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103672,
                "title": "c-dfs-hashset-faster-easy-to-understand",
                "content": "* ***Using DFS && Hashset***\\n\\n* ***Time Complexity :- O(N * L * L)***\\n\\n* ***Space Complexity :- O(N * L), Where L is the size of the string***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // set will store all the words of words\\n    \\n    unordered_set<string> s;\\n    \\n    bool helper(string& str, int i, int n)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n            return true;\\n        \\n        // partition str at j and call for next\\n        \\n        for(int j = i; j < n; j++)\\n        {\\n            if(str.substr(i, j - i + 1) != str && s.count(str.substr(i, j - i + 1)))\\n            {\\n                if(helper(str, j + 1, n))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        \\n        // insert all the word of words into s\\n        \\n        for(auto word : words)\\n        {\\n            s.insert(word);\\n        }\\n        \\n        vector<string> res;\\n        \\n        // iterate over words and check for each word is it concatenated or not\\n        \\n        for(auto word : words)\\n        { \\n            if(helper(word, 0, word.size()))\\n                res.push_back(word);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // set will store all the words of words\\n    \\n    unordered_set<string> s;\\n    \\n    bool helper(string& str, int i, int n)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n            return true;\\n        \\n        // partition str at j and call for next\\n        \\n        for(int j = i; j < n; j++)\\n        {\\n            if(str.substr(i, j - i + 1) != str && s.count(str.substr(i, j - i + 1)))\\n            {\\n                if(helper(str, j + 1, n))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        \\n        // insert all the word of words into s\\n        \\n        for(auto word : words)\\n        {\\n            s.insert(word);\\n        }\\n        \\n        vector<string> res;\\n        \\n        // iterate over words and check for each word is it concatenated or not\\n        \\n        for(auto word : words)\\n        { \\n            if(helper(word, 0, word.size()))\\n                res.push_back(word);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103661,
                "title": "java-dfs-simple-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M^3*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M*N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  HashSet<String> set;\\n  \\n  private boolean isConcatenated(String word, int i) {\\n    if (i > 0 && set.contains(word.substring(i)))\\n      return true;\\n\\n    for (int j = i+1; j < word.length(); j++) {\\n      if (set.contains(word.substring(i, j)) && isConcatenated(word, j)) {\\n        set.add(word.substring(i));\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n    set = new HashSet<>(Arrays.asList(words));\\n    List<String> ans = new ArrayList<>();\\n\\n    for (String word : words)\\n      if (isConcatenated(word, 0))\\n        ans.add(word);\\n    \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  HashSet<String> set;\\n  \\n  private boolean isConcatenated(String word, int i) {\\n    if (i > 0 && set.contains(word.substring(i)))\\n      return true;\\n\\n    for (int j = i+1; j < word.length(); j++) {\\n      if (set.contains(word.substring(i, j)) && isConcatenated(word, j)) {\\n        set.add(word.substring(i));\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n    set = new HashSet<>(Arrays.asList(words));\\n    List<String> ans = new ArrayList<>();\\n\\n    for (String word : words)\\n      if (isConcatenated(word, 0))\\n        ans.add(word);\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103563,
                "title": "c-dp",
                "content": "# Intuition & Approach\\nhttps://youtu.be/ARFt1KUt1RQ\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    unordered_set<string> dictionary;\\n    unordered_map<string, int> dp;\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        dictionary = unordered_set(words.begin(), words.end());\\n\\n        vector<string> res;\\n        for (auto &word : words)\\n            if (numOfConcatenatedWords(word) > 1)\\n                res.push_back(word);\\n\\n        return res;\\n    }\\n\\n    int numOfConcatenatedWords(string word) {\\n        if (word.empty()) return 0;\\n        if (dp.count(word)) return dp[word];\\n\\n        string curPrefix = \"\";\\n        int sz = word.size(), maxNumOfWords = INT_MIN;\\n        for (int i = 0; i < sz; ++i) {\\n            curPrefix += word[i];\\n            \\n            if (dictionary.count(curPrefix))\\n                maxNumOfWords = max(\\n                    maxNumOfWords,\\n                    1 + numOfConcatenatedWords(word.substr(i + 1))\\n                );\\n        }\\n\\n        return dp[word] = maxNumOfWords;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_set<string> dictionary;\\n    unordered_map<string, int> dp;\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        dictionary = unordered_set(words.begin(), words.end());\\n\\n        vector<string> res;\\n        for (auto &word : words)\\n            if (numOfConcatenatedWords(word) > 1)\\n                res.push_back(word);\\n\\n        return res;\\n    }\\n\\n    int numOfConcatenatedWords(string word) {\\n        if (word.empty()) return 0;\\n        if (dp.count(word)) return dp[word];\\n\\n        string curPrefix = \"\";\\n        int sz = word.size(), maxNumOfWords = INT_MIN;\\n        for (int i = 0; i < sz; ++i) {\\n            curPrefix += word[i];\\n            \\n            if (dictionary.count(curPrefix))\\n                maxNumOfWords = max(\\n                    maxNumOfWords,\\n                    1 + numOfConcatenatedWords(word.substr(i + 1))\\n                );\\n        }\\n\\n        return dp[word] = maxNumOfWords;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103462,
                "title": "java-solution-using-trie-runtime-42-ms-beats-96-92",
                "content": "```\\nclass Solution {\\n     private static class Node {\\n\\t\\tprivate char data;\\n\\t\\tprivate boolean isEnd;\\n\\t\\tprivate Node[] children;\\n\\n\\t\\tpublic Node(char data) {\\n\\t\\t\\tthis.data = data;\\n\\t\\t\\tthis.isEnd = false;\\n\\t\\t\\tthis.children = new Node[26];\\n\\t\\t}\\n\\t}\\n\\n\\tprivate Node root = new Node(\\'/\\');\\n\\n\\tprivate void insert(String word) {\\n\\t\\tNode curr = this.root;\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tint childIdx = word.charAt(i) - \\'a\\';\\n\\t\\t\\tif (curr.children[childIdx] == null) {\\n\\t\\t\\t\\tcurr.children[childIdx] = new Node(word.charAt(i));\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr.children[childIdx];\\n\\t\\t}\\n\\t\\tcurr.isEnd = true;\\n\\t}\\n    \\n    private boolean isConcatenated(String word, int index, int count) {\\n        if (index == word.length()){\\n            return count >= 2;\\n        }\\n        Node curr = this.root;\\n        for (int i = index; i < word.length(); i++) {\\n            if (curr.children[word.charAt(i) - \\'a\\'] == null){\\n                 return false;\\n            } \\n            curr = curr.children[word.charAt(i) - \\'a\\'];\\n            if (curr.isEnd){\\n                //start searching next part of string again from the root and increment \\n                if (isConcatenated(word, i + 1, count + 1)){\\n                      return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        for (String word : words) {\\n\\t\\t\\tinsert(word);\\n\\t\\t}\\n        List<String> result = new ArrayList<>();\\n        for (String word : words) {\\n            if (isConcatenated(word, 0, 0))\\n                result.add(word);\\n        }\\n        return result;\\n    }\\n}\\n```\\nSome Other Problems Using Trie Data Structure\\n[1268 : Search Suggestions System](https://leetcode.com/problems/search-suggestions-system/discuss/2638534/java-solution-using-trie-runtime-37-ms-beats-7219)\\n[1233 : Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/discuss/2638522/java-solution-using-trie-runtime-43-ms-beats-9605)\\n[648\\t: Replace Words](https://leetcode.com/problems/replace-words/discuss/2638625/java-solution-using-trie-runtime-14-ms-beats-962219)\\n[820\\t: Short Encoding of Words](https://leetcode.com/problems/short-encoding-of-words/discuss/2639021/java-solution-using-trie)\\n[208\\t: Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/2638657/simple-java-solution)\\n[386\\t: Lexicographical Numbers](https://leetcode.com/problems/lexicographical-numbers/discuss/2639107/java-solution-using-trie)\\n[1023 : Camelcase Matching](https://leetcode.com/problems/camelcase-matching/discuss/2639736/java-solution-using-trie)\\n[677\\t: Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/discuss/2639994/java-solution-using-trie-and-hashmap)\\n[676\\t: Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/discuss/2640276/java-solution-using-trie)\\n[421\\t: Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/2643276/java-trie-approach-add-number-and-check-its-max-xor-on-fly-tc-on-and-sc-on)\\n[792\\t: Number of Matching Subsequences](https://leetcode.com/problems/number-of-matching-subsequences/discuss/2643489/java-solutions-two-approach-1-using-trie-2-hashmap)\\n[720\\t: Longest Word in Dictionary](https://leetcode.com/problems/longest-word-in-dictionary/discuss/2643586/java-solution-using-trie-dfs)\\n[2261 : K Divisible Elements Subarrays](https://leetcode.com/problems/k-divisible-elements-subarrays/discuss/2643761/java-solution-sliding-window-trie-runtime-41-ms-faster-than-9846)\\n[139\\t: Word Break](https://leetcode.com/problems/word-break/discuss/2643915/java-solutions-two-approach-1-using-trie-bfs-2-dp)\\n[211\\t: Design Add and Search Words Data Structure](https://leetcode.com/problems/design-add-and-search-words-data-structure/discuss/2643839/java-solution-using-trie-dfs)\\n[1948 : Delete Duplicate Folders in System](https://leetcode.com/problems/delete-duplicate-folders-in-system/discuss/2646138/java-solution-using-trie-with-postorder-and-inorder-dfs-traversal)\\n[1032 : Stream of Characters](https://leetcode.com/problems/stream-of-characters/discuss/2646970/java-solution-using-trie)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/2779677/Java-Solution-or-Using-Trie)\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/3103462/Java-Solution-or-Using-Trie-or-Runtime-%3A-48-ms-or-beats-91.92)\\n",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n     private static class Node {\\n\\t\\tprivate char data;\\n\\t\\tprivate boolean isEnd;\\n\\t\\tprivate Node[] children;\\n\\n\\t\\tpublic Node(char data) {\\n\\t\\t\\tthis.data = data;\\n\\t\\t\\tthis.isEnd = false;\\n\\t\\t\\tthis.children = new Node[26];\\n\\t\\t}\\n\\t}\\n\\n\\tprivate Node root = new Node(\\'/\\');\\n\\n\\tprivate void insert(String word) {\\n\\t\\tNode curr = this.root;\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tint childIdx = word.charAt(i) - \\'a\\';\\n\\t\\t\\tif (curr.children[childIdx] == null) {\\n\\t\\t\\t\\tcurr.children[childIdx] = new Node(word.charAt(i));\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr.children[childIdx];\\n\\t\\t}\\n\\t\\tcurr.isEnd = true;\\n\\t}\\n    \\n    private boolean isConcatenated(String word, int index, int count) {\\n        if (index == word.length()){\\n            return count >= 2;\\n        }\\n        Node curr = this.root;\\n        for (int i = index; i < word.length(); i++) {\\n            if (curr.children[word.charAt(i) - \\'a\\'] == null){\\n                 return false;\\n            } \\n            curr = curr.children[word.charAt(i) - \\'a\\'];\\n            if (curr.isEnd){\\n                //start searching next part of string again from the root and increment \\n                if (isConcatenated(word, i + 1, count + 1)){\\n                      return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        for (String word : words) {\\n\\t\\t\\tinsert(word);\\n\\t\\t}\\n        List<String> result = new ArrayList<>();\\n        for (String word : words) {\\n            if (isConcatenated(word, 0, 0))\\n                result.add(word);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103457,
                "title": "let-s-learn-kotlin-recursion-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each word, we\\'ll check if it\\'s concatenated recursively. Check each word in the list to compute the return list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Duplicate the input array as a set because we\\'ll be checking for containment a lot and will benefit from the constant lookup time.\\n2. Create a helper function to evaluate a single word. It will have a second paramter `allowSelf` so that on initial call, it will not return `true` on the basis of the word matching itself. For recursive calls tho, some prefix portion will have already matched and the remainder should be allowed to match itself, hence `allowSelf = true` in the recursive call.\\n3. Iterate through the list and append all concatenated words to the `res`.\\n\\n# Complexity\\n$$L$$ is the length of the words (average for average, longest for worst case), $$N$$ is the number of words\\n- Time complexity: $$O(L^3 * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N * L)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun findAllConcatenatedWordsInADict(words: Array<String>): List<String> {\\n        // make a set for constant lookup time\\n        val wordBank = words.toSet()\\n\\n        // define a recursive helper function that checks if a word is concatenated\\n        fun isConcatenated(word: String, allowSelf: Boolean): Boolean {\\n            if (allowSelf && word in wordBank) return true\\n            var isConc = false\\n            for (i in 1 until word.length) {\\n                if (word.substring(0, i) in wordBank) {\\n                    isConc = isConc || isConcatenated(word.substring(i), true)\\n                }\\n            }\\n            return isConc\\n        }\\n\\n        var res = mutableListOf<String>()\\n        for (word in words) {\\n            if (isConcatenated(word, false)) {\\n                res.add(word)\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    fun findAllConcatenatedWordsInADict(words: Array<String>): List<String> {\\n        // make a set for constant lookup time\\n        val wordBank = words.toSet()\\n\\n        // define a recursive helper function that checks if a word is concatenated\\n        fun isConcatenated(word: String, allowSelf: Boolean): Boolean {\\n            if (allowSelf && word in wordBank) return true\\n            var isConc = false\\n            for (i in 1 until word.length) {\\n                if (word.substring(0, i) in wordBank) {\\n                    isConc = isConc || isConcatenated(word.substring(i), true)\\n                }\\n            }\\n            return isConc\\n        }\\n\\n        var res = mutableListOf<String>()\\n        for (word in words) {\\n            if (isConcatenated(word, false)) {\\n                res.add(word)\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799192,
                "title": "c-simple-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int noOfConcatedStrings(string word, unordered_map<string, int> &dp, unordered_set<string> &uniqueWords) {\\n        if(word == \"\") return 0;\\n        \\n        // If we\\'ve already calculated the \\n        //concatenated string count for current word, \\n        //return the count\\n        if(dp.count(word)) return dp[word];\\n        \\n        int sz = word.length();\\n        string current = \"\";       // to form possible combination\\n        int mxCount = INT_MIN;     // count of smaller concatenated strings\\n        \\n        for(int i = 0; i < sz; i++) \\n        {\\n            current += word[i];          // form the possible combination\\n            if(uniqueWords.count(current)) // does combination belongs to set of given words??\\n            {\\n                // increase count by 1 and find count for remaining word      \\n                mxCount = max(mxCount, 1 + noOfConcatedStrings(word.substr(i + 1), dp, uniqueWords)); \\n                \\n            }\\n        }\\n        \\n        return dp[word] = mxCount;       // store count for current word\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> ans;\\n        unordered_set<string> uniqueWords(words.begin(), words.end());// for O(1) search\\n        unordered_map<string, int> dp;                                \\n        \\n        for(string &word : words) \\n        {\\n            // check for given condition (last para of problem statement)\\n            if(noOfConcatedStrings(word, dp, uniqueWords) >= 2)  \\n            {\\n                ans.push_back(word);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int noOfConcatedStrings(string word, unordered_map<string, int> &dp, unordered_set<string> &uniqueWords) {\\n        if(word == \"\") return 0;\\n        \\n        // If we\\'ve already calculated the \\n        //concatenated string count for current word, \\n        //return the count\\n        if(dp.count(word)) return dp[word];\\n        \\n        int sz = word.length();\\n        string current = \"\";       // to form possible combination\\n        int mxCount = INT_MIN;     // count of smaller concatenated strings\\n        \\n        for(int i = 0; i < sz; i++) \\n        {\\n            current += word[i];          // form the possible combination\\n            if(uniqueWords.count(current)) // does combination belongs to set of given words??\\n            {\\n                // increase count by 1 and find count for remaining word      \\n                mxCount = max(mxCount, 1 + noOfConcatedStrings(word.substr(i + 1), dp, uniqueWords)); \\n                \\n            }\\n        }\\n        \\n        return dp[word] = mxCount;       // store count for current word\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> ans;\\n        unordered_set<string> uniqueWords(words.begin(), words.end());// for O(1) search\\n        unordered_map<string, int> dp;                                \\n        \\n        for(string &word : words) \\n        {\\n            // check for given condition (last para of problem statement)\\n            if(noOfConcatedStrings(word, dp, uniqueWords) >= 2)  \\n            {\\n                ans.push_back(word);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720835,
                "title": "c-dfs-hashmap-easy-to-understand",
                "content": "* ***Using DFS***\\n\\n* ***Time Complexity :- O(N * L * L), where L is the size of the string***\\n\\n* ***Space Complexity :- O(N * L)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // set will store all the words of words\\n    \\n    unordered_set<string> s;\\n    \\n    bool helper(string& str, int i, int n)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n            return true;\\n        \\n        // partition str at j and call for next\\n        \\n        for(int j = i; j < n; j++)\\n        {\\n            if(str.substr(i, j - i + 1) != str && s.count(str.substr(i, j - i + 1)))\\n            {\\n                if(helper(str, j + 1, n))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        \\n        // insert all the word of words into s\\n        \\n        for(auto word : words)\\n        {\\n            s.insert(word);\\n        }\\n        \\n        vector<string> res;\\n        \\n        // iterate over words and check for each word is it concatenated or not\\n        \\n        for(auto word : words)\\n        { \\n            if(helper(word, 0, word.size()))\\n                res.push_back(word);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // set will store all the words of words\\n    \\n    unordered_set<string> s;\\n    \\n    bool helper(string& str, int i, int n)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n            return true;\\n        \\n        // partition str at j and call for next\\n        \\n        for(int j = i; j < n; j++)\\n        {\\n            if(str.substr(i, j - i + 1) != str && s.count(str.substr(i, j - i + 1)))\\n            {\\n                if(helper(str, j + 1, n))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        \\n        // insert all the word of words into s\\n        \\n        for(auto word : words)\\n        {\\n            s.insert(word);\\n        }\\n        \\n        vector<string> res;\\n        \\n        // iterate over words and check for each word is it concatenated or not\\n        \\n        for(auto word : words)\\n        { \\n            if(helper(word, 0, word.size()))\\n                res.push_back(word);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630826,
                "title": "c-trie-dfs",
                "content": "```\\nclass Solution {\\nprivate:\\n    struct Node{\\n        Node* arr[26];\\n        bool end = false;\\n    };\\npublic:\\n    Node* root = new Node();\\n    \\n    void trie_insert(string &word){\\n        Node* node = root;\\n        for(int i = 0; i < word.size(); i++){\\n            if(node->arr[word[i] - \\'a\\'] == NULL){\\n                node->arr[word[i] - \\'a\\'] = new Node();\\n            }\\n            node = node->arr[word[i] - \\'a\\'];\\n        }\\n        node->end = true;\\n    }\\n    \\n    bool trie_prefix_search(string &word){\\n        Node* node = root;\\n        for(int i = 0; i < word.size(); i++){\\n            if(node->arr[word[i] - \\'a\\'] == NULL) return false;\\n            node = node->arr[word[i] - \\'a\\'];\\n        }\\n        return node->end;\\n    }\\n    \\n    bool dfs(string &word, int cuts){\\n        if(word == \"\" and cuts >= 2) return true;\\n        if(word == \"\") return false;\\n        for(int i = 0; i < word.size(); i++){\\n            string prefix = word.substr(0,i+1);\\n            string suffix = word.substr(i+1);\\n            if(trie_prefix_search(prefix)){\\n                if(dfs(suffix , cuts+1)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string> ans;\\n        for(auto w: words){\\n            trie_insert(w);\\n        }\\n        for(auto w: words){\\n            if(dfs(w, 0)) ans.push_back(w);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "class Solution {\\nprivate:\\n    struct Node{\\n        Node* arr[26];\\n        bool end = false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2612965,
                "title": "python-trie-dfs-solution",
                "content": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        root, res = {}, set()\\n\\n        for w in words:\\n            cur = root\\n            for c in w: cur = cur.setdefault(c, {})\\n            cur[\\'#\\'] = {}\\n        \\n        def dfs(word, l, i, n):\\n            if i == l:\\n                if n > 1: res.add(word)\\n                return\\n            cur = root\\n            while i < l:\\n                if word[i] not in cur: return\\n                if \\'#\\' in cur[word[i]]: dfs(word, l, i + 1, n + 1)\\n                cur = cur[word[i]]\\n                i += 1\\n                \\n        for w in words: dfs(w, len(w), 0, 0)\\n        return list(res)     \\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        root, res = {}, set()\\n\\n        for w in words:\\n            cur = root\\n            for c in w: cur = cur.setdefault(c, {})\\n            cur[\\'#\\'] = {}\\n        \\n        def dfs(word, l, i, n):\\n            if i == l:\\n                if n > 1: res.add(word)\\n                return\\n            cur = root\\n            while i < l:\\n                if word[i] not in cur: return\\n                if \\'#\\' in cur[word[i]]: dfs(word, l, i + 1, n + 1)\\n                cur = cur[word[i]]\\n                i += 1\\n                \\n        for w in words: dfs(w, len(w), 0, 0)\\n        return list(res)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475225,
                "title": "c-simple-dp-recursive-problem-faster-than-99",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_set<string> wordSet;\\n    \\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        wordSet = unordered_set<string>(words.begin(), words.end());\\n        vector<string> ans;\\n        for(auto& str : words){\\n            int count = 0;\\n            if(isConcat(str, 0, count) == true && count > 1){\\n                ans.push_back(str);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isConcat(string& str, int index, int& count){\\n        if(index >= str.size()){\\n            return true;\\n        }\\n        string subStr;\\n        for(int i = index; i < str.size(); ++i){\\n            subStr += str[i];\\n            if(wordSet.find(subStr) != wordSet.end()){\\n                if(isConcat(str, i + 1, count) == true){       //<- if a substring is found, then dive into next recursive call\\n                    count++;     //<- this counts the number of substrings present within \"str\" that are also present within \"wordSet\" \\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_set<string> wordSet;\\n    \\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        wordSet = unordered_set<string>(words.begin(), words.end());\\n        vector<string> ans;\\n        for(auto& str : words){\\n            int count = 0;\\n            if(isConcat(str, 0, count) == true && count > 1){\\n                ans.push_back(str);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isConcat(string& str, int index, int& count){\\n        if(index >= str.size()){\\n            return true;\\n        }\\n        string subStr;\\n        for(int i = index; i < str.size(); ++i){\\n            subStr += str[i];\\n            if(wordSet.find(subStr) != wordSet.end()){\\n                if(isConcat(str, i + 1, count) == true){       //<- if a substring is found, then dive into next recursive call\\n                    count++;     //<- this counts the number of substrings present within \"str\" that are also present within \"wordSet\" \\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458584,
                "title": "c-solution-using-dynamic-programming",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_set<string>dict;\\n    vector<int>mem;\\n    string s;\\n    int numWordsToMakeGivenString(int index){\\n        if(index==s.size()){\\n            return 0;\\n        } else if(mem[index]!=-1){\\n            return mem[index];\\n        } else {\\n            int ans=-1e9;\\n            for(int next=index;next<s.size();next++){\\n                string substr=s.substr(index,next-index+1);\\n                if(dict.count(substr)){\\n                    int tmp=numWordsToMakeGivenString(next+1);\\n                    if(tmp!=-1e9){\\n                        ans=max(ans,1+tmp);\\n                    }\\n                }\\n            }\\n            return mem[index]=ans;\\n        }\\n    }\\n    bool isConcatenatedWord(string &word){\\n        mem=vector<int>(word.size(),-1);\\n        s=word;\\n        int ans=numWordsToMakeGivenString(0);\\n        return ans>1;\\n    }\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for(int i=0;i<words.size();i++){\\n            dict.insert(words[i]);\\n        }\\n        vector<string>ans;\\n        for(string word:words){\\n            if(isConcatenatedWord(word)){\\n                ans.push_back(word);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    unordered_set<string>dict;\\n    vector<int>mem;\\n    string s;\\n    int numWordsToMakeGivenString(int index){\\n        if(index==s.size()){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2433376,
                "title": "c-easy-trie-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    class Node {\\n    public:\\n        Node* childs[26];\\n        string str;\\n        Node(){\\n            for(int i=0; i<26; i++){\\n                childs[i] = NULL;\\n            }\\n            str = \"\";\\n        }\\n    };\\n    Node* root;\\n    vector<string>ans;\\n    \\n    void insert(Node* cur, string s){\\n        for(int i=0; i<s.size(); i++){\\n            if(cur->childs[s[i] - \\'a\\'] == NULL){\\n                cur->childs[s[i] - \\'a\\'] = new Node();\\n            }\\n            cur = cur->childs[s[i] - \\'a\\'];\\n        }\\n        cur->str = s;\\n    }\\n    \\n    void search(Node* cur, Node* newWord){\\n        if(cur->str.size() > 0 && newWord->str.size() > 0){\\n            ans.push_back(cur->str);\\n            cur->str = \"\";\\n        }\\n        if(newWord->str.size() > 0){\\n            search(cur, root);\\n        }\\n        for(int i=0; i<26; i++){\\n            if(cur->childs[i] != NULL && newWord->childs[i] != NULL){\\n                search(cur->childs[i], newWord->childs[i]);\\n            }\\n        }\\n    }\\n    \\n    void search1(Node* cur){\\n        if(cur->str.size() > 0){\\n            search(cur, root);\\n        }\\n        \\n        for(Node* child : cur->childs){\\n            if(child != NULL){\\n                search1(child);\\n            }\\n        }\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        root = new Node();\\n        for(string s : words){\\n            insert(root, s);\\n        }\\n        search1(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    class Node {\\n    public:\\n        Node* childs[26];\\n        string str;\\n        Node(){\\n            for(int i=0; i<26; i++){\\n                childs[i] = NULL;\\n            }\\n            str = \"\";\\n        }\\n    };\\n    Node* root;\\n    vector<string>ans;\\n    \\n    void insert(Node* cur, string s){\\n        for(int i=0; i<s.size(); i++){\\n            if(cur->childs[s[i] - \\'a\\'] == NULL){\\n                cur->childs[s[i] - \\'a\\'] = new Node();\\n            }\\n            cur = cur->childs[s[i] - \\'a\\'];\\n        }\\n        cur->str = s;\\n    }\\n    \\n    void search(Node* cur, Node* newWord){\\n        if(cur->str.size() > 0 && newWord->str.size() > 0){\\n            ans.push_back(cur->str);\\n            cur->str = \"\";\\n        }\\n        if(newWord->str.size() > 0){\\n            search(cur, root);\\n        }\\n        for(int i=0; i<26; i++){\\n            if(cur->childs[i] != NULL && newWord->childs[i] != NULL){\\n                search(cur->childs[i], newWord->childs[i]);\\n            }\\n        }\\n    }\\n    \\n    void search1(Node* cur){\\n        if(cur->str.size() > 0){\\n            search(cur, root);\\n        }\\n        \\n        for(Node* child : cur->childs){\\n            if(child != NULL){\\n                search1(child);\\n            }\\n        }\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        root = new Node();\\n        for(string s : words){\\n            insert(root, s);\\n        }\\n        search1(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345210,
                "title": "python-bfs-easy-simple-with-explanation-faster-than-95-51",
                "content": "Taking the BFS approach that I used in Word Break - i and [Word-break-ii](https://leetcode.com/problems/word-break-ii/discuss/2344625/Python-45ms-Easy-clean-BFS-solution-with-explanation)\\n\\nSteps are simple:\\nIntution:\\nStep 1. We create the set of words for searching in O(1)\\nStep 2. We need to test if each word can be formed by using other words from the list.\\n\\t\\t\\tSo, we remove the word from the set and check if it satisfies the condition of\\n\\t\\t\\tword-break-i\\nStep 3.\\tIf it satisfies -> add to res\\nStep 4. Add the word back to set\\n\\nFunction Testing for each word:\\nWe create a visited set and a queue and add 0 to it (for indexing)\\nwe check ffor all the words for that word and add the index of the end of the new word.\\nOnce we reach end of our initial word that means the complete word in traversed so return True\\n\\n\\n```python\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        words = set(words)\\n        res = []\\n            \\n        for word in words:\\n            words.remove(word)\\n            if self.check_word(word, words):\\n                res.append(word)\\n            words.add(word)\\n\\n        return res\\n    \\n    def check_word(self, word, words):\\n            \\n            queue = deque([0])\\n            visited = set([0])\\n            while queue:\\n                ind = queue.popleft()\\n                \\n                for end in range(ind + 1, len(word) + 1):\\n                    if word[ind:end] in words:\\n                        if end not in visited:\\n                            queue.append(end)\\n                            visited.add(end)\\n                        if end == len(word):\\n                            return True\\n            return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        words = set(words)\\n        res = []\\n            \\n        for word in words:\\n            words.remove(word)\\n            if self.check_word(word, words):\\n                res.append(word)\\n            words.add(word)\\n\\n        return res\\n    \\n    def check_word(self, word, words):\\n            \\n            queue = deque([0])\\n            visited = set([0])\\n            while queue:\\n                ind = queue.popleft()\\n                \\n                for end in range(ind + 1, len(word) + 1):\\n                    if word[ind:end] in words:\\n                        if end not in visited:\\n                            queue.append(end)\\n                            visited.add(end)\\n                        if end == len(word):\\n                            return True\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258868,
                "title": "c-simple-solution-without-dp-or-trie-beats-80",
                "content": "Here is a simple solution that doesn\\'t require DP or using Trie and is pretty faster than the DP and Trie solutions.\\n* First of all we will sort the words vector in increasing lengths of its elements. So if we are finding if a particular word can be formed by concatinating other words in the vector, they all will be in the left side of the vector and no need to check in the right side.\\n* We can start checking from the 3rd element as given in the question, a concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array. So if the length of the vector will be 0,1 or 2 then the answer will be an empty vector.\\n* We will keep on storing the words in an unordered map it can be easily checked if a particular word is present or not in O(1) time.\\n* Now starting from the 3rd element, we will loop through it and check if the present substring is present in the unordered map or not, if it is present then we will check for the remaining substring. \\n* If the remaining substring is not present, we will again call the recursion and check for it\\'s substrings.\\n```\\nclass Solution {\\npublic:\\n    static bool comp(string s1, string s2){\\n        return s1.length() < s2.length();\\n    }\\n    bool solve(int i, string &s, unordered_map<string,int>&mp){\\n        if(mp.find(s.substr(i,s.length()-i)) != mp.end()) return true;\\n        if(i == s.length()) return false;\\n        for(int j = i; j<s.length(); j++){\\n            if(mp.find(s.substr(i,j-i+1)) != mp.end()){\\n                if(solve(j+1,s,mp)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string>ans;\\n        int n = words.size();\\n        if(n == 0 || n == 1 || n == 2) return ans;\\n        sort(words.begin(), words.end(), comp);\\n        unordered_map<string,int>mp;\\n        mp[words[0]] = 1;\\n        mp[words[1]] = 1;\\n        for(int i=2; i<n; i++){\\n            if(solve(0,words[i],mp)) ans.push_back(words[i]);\\n            mp[words[i]] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(string s1, string s2){\\n        return s1.length() < s2.length();\\n    }\\n    bool solve(int i, string &s, unordered_map<string,int>&mp){\\n        if(mp.find(s.substr(i,s.length()-i)) != mp.end()) return true;\\n        if(i == s.length()) return false;\\n        for(int j = i; j<s.length(); j++){\\n            if(mp.find(s.substr(i,j-i+1)) != mp.end()){\\n                if(solve(j+1,s,mp)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        vector<string>ans;\\n        int n = words.size();\\n        if(n == 0 || n == 1 || n == 2) return ans;\\n        sort(words.begin(), words.end(), comp);\\n        unordered_map<string,int>mp;\\n        mp[words[0]] = 1;\\n        mp[words[1]] = 1;\\n        for(int i=2; i<n; i++){\\n            if(solve(0,words[i],mp)) ans.push_back(words[i]);\\n            mp[words[i]] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253675,
                "title": "hashmap-dfs-python",
                "content": "```\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        memo={}\\n        words=set(words)\\n        def dfs(word):\\n            if word in memo:\\n                return memo[word]\\n            for second_idx in range(1,len(word)):\\n                prefix,suffix=word[:second_idx],word[second_idx:]\\n                if prefix in words and suffix in words or prefix in words and dfs(suffix):\\n                    memo[word]=True\\n                    return True\\n            memo[word]=False\\n            return False\\n        \\n        return [word for word in words if dfs(word)]\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def findAllConcatenatedWordsInADict(self, words):\\n        memo={}\\n        words=set(words)\\n        def dfs(word):\\n            if word in memo:\\n                return memo[word]\\n            for second_idx in range(1,len(word)):\\n                prefix,suffix=word[:second_idx],word[second_idx:]\\n                if prefix in words and suffix in words or prefix in words and dfs(suffix):\\n                    memo[word]=True\\n                    return True\\n            memo[word]=False\\n            return False\\n        \\n        return [word for word in words if dfs(word)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191590,
                "title": "easy-trie-solution",
                "content": "\\n    //Structure for TRIE\\n    struct Node {\\n        char c; //To store and iterate characters\\n        int end; //To store the end of a word\\n        Node* child[26]; //Child array\\n    };\\n    \\n    //To create a node\\n    struct Node* getNode(char c) {\\n        Node* newNode = new Node;\\n        newNode->c = c;\\n        newNode->end = 0;\\n        for(int i=0; i<26; i++) {\\n            newNode->child[i] = NULL;\\n        }\\n        \\n        return newNode;\\n    }\\n    \\n    //Root of the TRIE is created\\n    Node* root = getNode(\\'/\\');\\n    vector<string> v;\\n    \\n    //Function to insert a string into the TRIE\\n    void insert(string s) {\\n        Node* curr = root;\\n        int i = 0, index;\\n        while(i < s.length()) {\\n            index = s[i]-\\'a\\'; //Index\\n            if(curr->child[index] == NULL) {\\n                curr->child[index] = getNode(s[i]); //Create a node if it\\'s empty\\n            }\\n            curr = curr->child[index]; //Iterate to next child\\n            i++;\\n        }\\n        curr->end = 1; //Set end to 1 whenever a string\\'s iteration is ended\\n    }\\n    \\n    //Function to search a string in the TRIE\\n    bool search(string s) {\\n        Node* curr = root;\\n        int i = 0, index;\\n        while(i < s.length()) {\\n            index = s[i] -\\'a\\';\\n            if(curr->child[index] == NULL) {\\n                return false; //Whenever we get empty child for a given string in TRIE, we return false\\n            }\\n            curr = curr->child[index]; //Iterate to next child\\n            i++;\\n        }\\n        \\n        return curr->end == 1; //If the end is equal to 1 means that there is string present in the TRIE\\n    }\\n    \\n    //Function to check partitions and substrings\\n    bool solve(string &s, int cnt) {\\n        //If we have a valid concatenated word in the trie then return true\\n        if(cnt > 1 && search(s)) {\\n            return true;\\n        }\\n         \\n        //Check for each possible cases\\n        for(int i=0; i<s.length(); i++) {\\n            string s1 = s.substr(0, i+1); //One half\\n            string s2 = s.substr(i+1); //Other half\\n            \\n            //Check for 1st half in the trie and if it is present in the trie then recurse for next half\\n            if(search(s1) && solve(s2, cnt+1)) \\n                return true;\\n        }\\n        \\n        return false; //If not found concatenated words\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        //Insert all the words into the trie\\n        for(int i=0; i<words.size(); i++) {\\n            if(words[i] == \"\") continue;\\n            insert(words[i]);\\n        }\\n        \\n        vector<string> v;\\n        for(int i=0; i<words.size(); i++) {\\n            if(words[i] == \"\") continue;\\n            \\n            //DFS traversal to search for the words that might be concatenated to the words[i](of words > 1 so a count is included)\\n            if(solve(words[i], 1)) \\n                v.push_back(words[i]); //Store the concatenated words\\n        }\\n        \\n        return v;\\n    }\\n\\t\\n\\tIf you liked the approach....please upvote!!",
                "solutionTags": [
                    "C",
                    "String",
                    "Trie"
                ],
                "code": "\\n    //Structure for TRIE\\n    struct Node {\\n        char c; //To store and iterate characters\\n        int end; //To store the end of a word\\n        Node* child[26]; //Child array\\n    };\\n    \\n    //To create a node\\n    struct Node* getNode(char c) {\\n        Node* newNode = new Node;\\n        newNode->c = c;\\n        newNode->end = 0;\\n        for(int i=0; i<26; i++) {\\n            newNode->child[i] = NULL;\\n        }\\n        \\n        return newNode;\\n    }\\n    \\n    //Root of the TRIE is created\\n    Node* root = getNode(\\'/\\');\\n    vector<string> v;\\n    \\n    //Function to insert a string into the TRIE\\n    void insert(string s) {\\n        Node* curr = root;\\n        int i = 0, index;\\n        while(i < s.length()) {\\n            index = s[i]-\\'a\\'; //Index\\n            if(curr->child[index] == NULL) {\\n                curr->child[index] = getNode(s[i]); //Create a node if it\\'s empty\\n            }\\n            curr = curr->child[index]; //Iterate to next child\\n            i++;\\n        }\\n        curr->end = 1; //Set end to 1 whenever a string\\'s iteration is ended\\n    }\\n    \\n    //Function to search a string in the TRIE\\n    bool search(string s) {\\n        Node* curr = root;\\n        int i = 0, index;\\n        while(i < s.length()) {\\n            index = s[i] -\\'a\\';\\n            if(curr->child[index] == NULL) {\\n                return false; //Whenever we get empty child for a given string in TRIE, we return false\\n            }\\n            curr = curr->child[index]; //Iterate to next child\\n            i++;\\n        }\\n        \\n        return curr->end == 1; //If the end is equal to 1 means that there is string present in the TRIE\\n    }\\n    \\n    //Function to check partitions and substrings\\n    bool solve(string &s, int cnt) {\\n        //If we have a valid concatenated word in the trie then return true\\n        if(cnt > 1 && search(s)) {\\n            return true;\\n        }\\n         \\n        //Check for each possible cases\\n        for(int i=0; i<s.length(); i++) {\\n            string s1 = s.substr(0, i+1); //One half\\n            string s2 = s.substr(i+1); //Other half\\n            \\n            //Check for 1st half in the trie and if it is present in the trie then recurse for next half\\n            if(search(s1) && solve(s2, cnt+1)) \\n                return true;\\n        }\\n        \\n        return false; //If not found concatenated words\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        //Insert all the words into the trie\\n        for(int i=0; i<words.size(); i++) {\\n            if(words[i] == \"\") continue;\\n            insert(words[i]);\\n        }\\n        \\n        vector<string> v;\\n        for(int i=0; i<words.size(); i++) {\\n            if(words[i] == \"\") continue;\\n            \\n            //DFS traversal to search for the words that might be concatenated to the words[i](of words > 1 so a count is included)\\n            if(solve(words[i], 1)) \\n                v.push_back(words[i]); //Store the concatenated words\\n        }\\n        \\n        return v;\\n    }\\n\\t\\n\\tIf you liked the approach....please upvote!!",
                "codeTag": "Unknown"
            },
            {
                "id": 2161313,
                "title": "c-dp-solution-similar-to-word-break-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>st(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            st.erase(w);\\n            vector<bool>dp(w.size()+1,false);\\n            dp[0]=true;\\n            for(int i=1;i<w.size()+1;i++){\\n                for(int j=0;j<i;j++){\\n                    string temp=w.substr(j,i-j);\\n                    if(dp[j] and (st.find(temp)!=st.end())){\\n                        dp[i]=true;\\n                        break;\\n                    }\\n                }\\n                \\n                if(dp.back())ans.push_back(w);\\n            }\\n            st.insert(w);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**T.C ==> O(N*L*L)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>st(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            st.erase(w);\\n            vector<bool>dp(w.size()+1,false);\\n            dp[0]=true;\\n            for(int i=1;i<w.size()+1;i++){\\n                for(int j=0;j<i;j++){\\n                    string temp=w.substr(j,i-j);\\n                    if(dp[j] and (st.find(temp)!=st.end())){\\n                        dp[i]=true;\\n                        break;\\n                    }\\n                }\\n                \\n                if(dp.back())ans.push_back(w);\\n            }\\n            st.insert(w);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2149788,
                "title": "c-trie-solution",
                "content": "```\\nclass TrieNode{\\npublic:\\n    vector<TrieNode*> children;\\n    bool isEnd;\\n    \\n    TrieNode(){\\n        isEnd = false;\\n        children = vector<TrieNode*>(26, NULL);\\n    }\\n};\\n\\nclass Trie{\\nprivate:\\n    TrieNode* root;\\n    \\npublic:\\n    TrieNode* getRoot(){\\n        return root;\\n    }\\n    \\n    Trie(vector<string>& words) {\\n        root = new TrieNode();\\n        for(auto& word: words) insert(word);\\n    }\\n    \\n    void insert(string& word){\\n        auto cur = root;\\n        for(int i=0; i<word.size(); i++){\\n            int index = word[i] - \\'a\\';\\n            if(cur->children[index] == NULL){\\n                cur -> children[index] = new TrieNode();\\n            }\\n            cur = cur -> children[index];\\n        }\\n        cur -> isEnd = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        Trie* trie = new Trie(words);\\n        \\n        vector<string> result;\\n        for(auto& word: words){\\n            int index = 0, concatenatedWordCount = 0;\\n            if(isConcatenatedWord(trie, word, index, concatenatedWordCount)) {\\n                result.push_back(word);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    bool isConcatenatedWord(Trie* trie, string& word, int index, int concatenatedWordCount){\\n        if(index == word.size()) return concatenatedWordCount >= 2;\\n        \\n        auto root = trie -> getRoot();\\n        for(int i=index; i<word.size(); i++){\\n            int trieIndex = word[i] - \\'a\\';\\n            \\n            if(root->children[trieIndex] == NULL) return false;\\n            root = root->children[trieIndex];\\n            \\n            if(root->isEnd){\\n                if(isConcatenatedWord(trie, word, i+1, concatenatedWordCount+1)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode{\\npublic:\\n    vector<TrieNode*> children;\\n    bool isEnd;\\n    \\n    TrieNode(){\\n        isEnd = false;\\n        children = vector<TrieNode*>(26, NULL);\\n    }\\n};\\n\\nclass Trie{\\nprivate:\\n    TrieNode* root;\\n    \\npublic:\\n    TrieNode* getRoot(){\\n        return root;\\n    }\\n    \\n    Trie(vector<string>& words) {\\n        root = new TrieNode();\\n        for(auto& word: words) insert(word);\\n    }\\n    \\n    void insert(string& word){\\n        auto cur = root;\\n        for(int i=0; i<word.size(); i++){\\n            int index = word[i] - \\'a\\';\\n            if(cur->children[index] == NULL){\\n                cur -> children[index] = new TrieNode();\\n            }\\n            cur = cur -> children[index];\\n        }\\n        cur -> isEnd = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        Trie* trie = new Trie(words);\\n        \\n        vector<string> result;\\n        for(auto& word: words){\\n            int index = 0, concatenatedWordCount = 0;\\n            if(isConcatenatedWord(trie, word, index, concatenatedWordCount)) {\\n                result.push_back(word);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    bool isConcatenatedWord(Trie* trie, string& word, int index, int concatenatedWordCount){\\n        if(index == word.size()) return concatenatedWordCount >= 2;\\n        \\n        auto root = trie -> getRoot();\\n        for(int i=index; i<word.size(); i++){\\n            int trieIndex = word[i] - \\'a\\';\\n            \\n            if(root->children[trieIndex] == NULL) return false;\\n            root = root->children[trieIndex];\\n            \\n            if(root->isEnd){\\n                if(isConcatenatedWord(trie, word, i+1, concatenatedWordCount+1)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024720,
                "title": "c-solution-using-dfs-no-dp",
                "content": "Time Complexity : O(n*s^3)\\nwhere n = Length of words \\nand s = length of each string\\n```\\nclass Solution {\\npublic:\\n    bool check(string word,int index,int cnt,unordered_set<string>&st){\\n        if(index==word.size()){\\n            if(cnt>=2){\\n                return true;\\n            }\\n            return false;\\n        }\\n        for(int i=index;i<word.length();++i){\\n            string temp = word.substr(index,i-index+1);\\n            if(st.count(temp)&&check(word,i+1,cnt+1,st)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>st;\\n        for(auto str:words){\\n            st.insert(str);\\n        }\\n        vector<string>arr;\\n        for(auto word:words){\\n            if(check(word,0,0,st)){\\n                arr.push_back(word);\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string word,int index,int cnt,unordered_set<string>&st){\\n        if(index==word.size()){\\n            if(cnt>=2){\\n                return true;\\n            }\\n            return false;\\n        }\\n        for(int i=index;i<word.length();++i){\\n            string temp = word.substr(index,i-index+1);\\n            if(st.count(temp)&&check(word,i+1,cnt+1,st)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>st;\\n        for(auto str:words){\\n            st.insert(str);\\n        }\\n        vector<string>arr;\\n        for(auto word:words){\\n            if(check(word,0,0,st)){\\n                arr.push_back(word);\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969919,
                "title": "java-15-lines-of-code-beats-78",
                "content": "**HashSet and Backtracking Solution**\\nMy original intuition was to use a trie, but this does not save you from iterating through each character unless you maintain word length within the Trie. It seemed like unnecessary overhead to me, so I did this with a HashSet and it still passed.\\nMy Time complexity: O(nk^2), where n = number of words, k = length of each word\\nMy Space complexity: O(n) as I maintain an extra Set for O(1) contains() method invocation\\n\\nPlease let me know your thoughts, I thought this was a much simpler solution than using a Trie but am here learning like everyone else so totally welcome to feedback!\\n\\n```\\nprivate Set<String> seen;\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        seen = new HashSet(List.of(words));\\n        List<String> concat = new ArrayList();\\n        for(String word : words)\\n            if(backtrack(word, 0)) concat.add(word);\\n        return concat;\\n    }\\n    \\n    private boolean backtrack(String word, int count){\\n        //Base case: can have more than two concatenated words and still be valid but cannot have extraneous chars\\n\\t\\tif(word.length() == 0 && count >=2) return true;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < word.length(); i++){\\n            sb.append(word.charAt(i));\\n            if(seen.contains(sb.toString()) && backtrack(word.substring(i+1), count+1)) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nprivate Set<String> seen;\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        seen = new HashSet(List.of(words));\\n        List<String> concat = new ArrayList();\\n        for(String word : words)\\n            if(backtrack(word, 0)) concat.add(word);\\n        return concat;\\n    }\\n    \\n    private boolean backtrack(String word, int count){\\n        //Base case: can have more than two concatenated words and still be valid but cannot have extraneous chars\\n\\t\\tif(word.length() == 0 && count >=2) return true;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < word.length(); i++){\\n            sb.append(word.charAt(i));\\n            if(seen.contains(sb.toString()) && backtrack(word.substring(i+1), count+1)) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940923,
                "title": "python-soln-using-word-break-i-logic-dp",
                "content": "\\tclass Solution:\\n\\t\\tdef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n\\t\\t\\t# Time O(n*n) Space O(n)\\n\\t\\t\\t# dp - using word break I problem logic\\n\\t\\t\\tdef dp(s):\\n\\t\\t\\t\\tn = len(s)\\n\\n\\t\\t\\t\\tdp = [False] * (n+1)\\n\\t\\t\\t\\tdp[0] = True\\n\\n\\t\\t\\t\\tfor i in range(1,n+1):\\n\\t\\t\\t\\t\\tfor j in range(i):\\n\\t\\t\\t\\t\\t\\tif dp[j] and s[j:i] in word_set and s[j:i] != s:\\n\\t\\t\\t\\t\\t\\t\\tdp[i] = True\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\treturn dp[n]\\n\\n\\t\\t\\tresult = []\\n\\t\\t\\tword_set = set(words)\\n\\n\\t\\t\\tfor word in word_set:\\n\\t\\t\\t\\tif word and dp(word):\\n\\t\\t\\t\\t\\tresult.append(word)\\n\\n\\t\\t\\treturn result",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n\\t\\t\\t# Time O(n*n) Space O(n)\\n\\t\\t\\t# dp - using word break I problem logic\\n\\t\\t\\tdef dp(s):\\n\\t\\t\\t\\tn = len(s)\\n\\n\\t\\t\\t\\tdp = [False] * (n+1)\\n\\t\\t\\t\\tdp[0] = True\\n\\n\\t\\t\\t\\tfor i in range(1,n+1):\\n\\t\\t\\t\\t\\tfor j in range(i):\\n\\t\\t\\t\\t\\t\\tif dp[j] and s[j:i] in word_set and s[j:i] != s:\\n\\t\\t\\t\\t\\t\\t\\tdp[i] = True\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\treturn dp[n]\\n\\n\\t\\t\\tresult = []\\n\\t\\t\\tword_set = set(words)\\n\\n\\t\\t\\tfor word in word_set:\\n\\t\\t\\t\\tif word and dp(word):\\n\\t\\t\\t\\t\\tresult.append(word)\\n\\n\\t\\t\\treturn result",
                "codeTag": "Java"
            },
            {
                "id": 1902910,
                "title": "java-dfs-code-with-comments",
                "content": "```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n\\n        // Build the dictionary        \\n        Set<String> dict = new HashSet<>();        \\n        for(String word : words)\\n            dict.add(word);\\n        \\n        Set<String> result = new HashSet<>();\\n        \\n        // Check every word in the dictionary if it is concatenated or not\\n        // But before that, delete the current word and later add to the dictionary after check is complete\\n        for(String word : words){\\n            dict.remove(word);\\n            dfs(word, result, dict, 0);\\n            dict.add(word);\\n        }\\n        return new ArrayList<>(result);\\n    }\\n    \\n    void dfs(String word, Set<String> result, Set<String> dict, int idx){\\n        \\n        // Base condition: When the complete word is explored\\n        if(word.length() > 0 && idx >= word.length()){\\n            result.add(word);\\n            return;\\n        }\\n        \\n        // Check every possible combinations of substring of the current word\\n        for(int i=idx; i < word.length(); i++){\\n            String s = word.substring(idx, i+1);\\n            if(dict.contains(s))\\n                dfs(word, result, dict, i+1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n\\n        // Build the dictionary        \\n        Set<String> dict = new HashSet<>();        \\n        for(String word : words)\\n            dict.add(word);\\n        \\n        Set<String> result = new HashSet<>();\\n        \\n        // Check every word in the dictionary if it is concatenated or not\\n        // But before that, delete the current word and later add to the dictionary after check is complete\\n        for(String word : words){\\n            dict.remove(word);\\n            dfs(word, result, dict, 0);\\n            dict.add(word);\\n        }\\n        return new ArrayList<>(result);\\n    }\\n    \\n    void dfs(String word, Set<String> result, Set<String> dict, int idx){\\n        \\n        // Base condition: When the complete word is explored\\n        if(word.length() > 0 && idx >= word.length()){\\n            result.add(word);\\n            return;\\n        }\\n        \\n        // Check every possible combinations of substring of the current word\\n        for(int i=idx; i < word.length(); i++){\\n            String s = word.substring(idx, i+1);\\n            if(dict.contains(s))\\n                dfs(word, result, dict, i+1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845883,
                "title": "c-clean-and-simple-code-don-t-use-trie-or-dp-75-faster-and-97-memory-usage",
                "content": "**Don\\'t use trie or dp**\\nThis question is simple but **wronly judged**, there\\'s two way of solving this question **first** is to keep concatenating the string (each string have two options either to be added or not) and look for it into the set or given array of string; this method required **trie** . But the other way of solving this question which I found **simpler** is to look for all the **substrings** of a word that is present in the set or not.\\n\\n```\\nbool containSubstr(string word,  unordered_set<string> &st){\\n        for(int i = 1; i < word.size(); i++){\\n            string left = word.substr(0,i);\\n            string right = word.substr(i);\\n            \\n\\t\\t\\t// first make sure left substring is present or not\\n            if(st.find(left) != st.end()){\\n\\t\\t\\t \\n\\t\\t\\t //if left is present than look for either the right part is present or not\\n\\t\\t\\t //****right could be comprised of multiple word then recurr for it.\\n                if(st.find(right) != st.end() || containSubstr(right, st))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> st(words.begin(), words.end());\\n        vector<string>result;\\n        \\n        for(auto word : words){\\n            if(containSubstr(word , st)){   \\n\\t\\t\\t// if all the substring of this word is present in the set than \\n\\t\\t\\t//add it into the resultant array\\n                result.push_back(word);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool containSubstr(string word,  unordered_set<string> &st){\\n        for(int i = 1; i < word.size(); i++){\\n            string left = word.substr(0,i);\\n            string right = word.substr(i);\\n            \\n\\t\\t\\t// first make sure left substring is present or not\\n            if(st.find(left) != st.end()){\\n\\t\\t\\t \\n\\t\\t\\t //if left is present than look for either the right part is present or not\\n\\t\\t\\t //****right could be comprised of multiple word then recurr for it.\\n                if(st.find(right) != st.end() || containSubstr(right, st))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> st(words.begin(), words.end());\\n        vector<string>result;\\n        \\n        for(auto word : words){\\n            if(containSubstr(word , st)){   \\n\\t\\t\\t// if all the substring of this word is present in the set than \\n\\t\\t\\t//add it into the resultant array\\n                result.push_back(word);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802872,
                "title": "c-trie-based-solution-62-time-beat",
                "content": "**LOGIC** :  Count the number of words while doing dfs, if the result ends with a trie object with isend = true and the words count is greater than 1(we didnt find the word itself in the trie, i.e,  we didn\\'t match \\'cat\\' with \\'cat\\' but with \\'c\\' and \\'at\\' maybe) then we reten true;\\n\\n```\\nclass Trie {\\n    public:\\n    vector<Trie*> next;\\n    bool isend;\\n    Trie(){\\n        isend = false;\\n        next.resize(26);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void addword(Trie* head, string &w)\\n    {\\n        for(int i = 0; i < w.length(); i++)\\n        {\\n            if(!head->next[w[i]-\\'a\\']) head->next[w[i]-\\'a\\'] = new Trie();\\n            head = head->next[w[i]-\\'a\\'];\\n        }\\n        head->isend = true;\\n    }\\n    \\n    bool searchword(Trie* head, string &w, int idx = 0, int words = 0)\\n    {\\n        Trie* curr = head;\\n        \\n        for(int i = idx; i < w.length(); i++)\\n        {\\n            if(!head->next[w[i]-\\'a\\']) return false;\\n            head = head->next[w[i]-\\'a\\'];\\n            if(i != w.length()-1 && head->isend && searchword(curr, w, i+1, words+1)) return true;\\n            \\n        }\\n        words+=1;\\n        return words > 1 && head->isend;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        Trie* head = new Trie();\\n        vector<string> ans;\\n        for(string w : words)\\n        {\\n            addword(head, w);\\n        }\\n        for(string w : words)\\n        {\\n            if(searchword(head, w)) ans.push_back(w);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\n    public:\\n    vector<Trie*> next;\\n    bool isend;\\n    Trie(){\\n        isend = false;\\n        next.resize(26);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void addword(Trie* head, string &w)\\n    {\\n        for(int i = 0; i < w.length(); i++)\\n        {\\n            if(!head->next[w[i]-\\'a\\']) head->next[w[i]-\\'a\\'] = new Trie();\\n            head = head->next[w[i]-\\'a\\'];\\n        }\\n        head->isend = true;\\n    }\\n    \\n    bool searchword(Trie* head, string &w, int idx = 0, int words = 0)\\n    {\\n        Trie* curr = head;\\n        \\n        for(int i = idx; i < w.length(); i++)\\n        {\\n            if(!head->next[w[i]-\\'a\\']) return false;\\n            head = head->next[w[i]-\\'a\\'];\\n            if(i != w.length()-1 && head->isend && searchword(curr, w, i+1, words+1)) return true;\\n            \\n        }\\n        words+=1;\\n        return words > 1 && head->isend;\\n    }\\n    \\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        Trie* head = new Trie();\\n        vector<string> ans;\\n        for(string w : words)\\n        {\\n            addword(head, w);\\n        }\\n        for(string w : words)\\n        {\\n            if(searchword(head, w)) ans.push_back(w);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1775821,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1565962,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1775780,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1775771,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1575245,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1776370,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1776211,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1575024,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1569124,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1570252,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1775821,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1565962,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1775780,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1775771,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1575245,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1776370,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1776211,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1575024,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1569124,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1570252,
                "content": [
                    {
                        "username": "user8228j",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not. \\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "NickParzival",
                        "content": "you mean a trie? it gives you mle if used with all those words"
                    },
                    {
                        "username": "ac-amygdala",
                        "content": "[@utsavslife](/utsavslife) You need either to add all words to trie and then process all of them - or sort an array first"
                    },
                    {
                        "username": "Finesse",
                        "content": "No prefix trie is necessary. A simple set with backtracking give a top-tier performance."
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Scresat](/Scresat) and also faster."
                    },
                    {
                        "username": "harisriram2002",
                        "content": "[@shrined](/shrined) Yeah was about to say the same."
                    },
                    {
                        "username": "kzo",
                        "content": "normal dfs approach is easier"
                    },
                    {
                        "username": "utsavslife",
                        "content": "How to handle such cases after making a trie\\nInput: [\"dog\",\"dogscat\",\"dogs\",\"cat\"]"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Is this possible to have such a big tree. There are total 1e4 words, and it is about 1e4 C2 + 1e4C3 + ... 1e4C1e4 - 1"
                    },
                    {
                        "username": "shrined",
                        "content": "It\\'s called a trie.."
                    },
                    {
                        "username": "marcos_qiu",
                        "content": "Initially I failed the last test cases. \\nMy idea was, if there is empty string in the given list, then all the non-empty string can be regarded as a concatenated word of an empty string and itself. So once I found an empty string, I return all the non-empty ones. And it seems that this assumption is not right since I passed all the cases after changing this.\\nThis is what made me confused, what do you guys think."
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "It says two shorter string then if you take itself it is not shorter than itself\\n"
                    },
                    {
                        "username": "ved20",
                        "content": "There can never be an empty string in the given list. The constraints metion that 1 <= words[i].length <= 30."
                    },
                    {
                        "username": "AkashAgarwal00",
                        "content": "but the min length is 1 \\nstring can not be empty \\nalso question states that only lowercase alphabets are there \\nso no blank space is there \\nso I can\\'t understand how that part of code even bothered \\n"
                    },
                    {
                        "username": "drewbie",
                        "content": "What are some of these test cases. LOL. I am passing all besides the last 3, and I go \"okay I can manually test this on paper\" only to see that it\\'s like 100+ words for the input.\\n\\nThat\\'s just not right."
                    },
                    {
                        "username": "drewbie",
                        "content": "[@AniketYadav03](/AniketYadav03) I used a BFS and a hash to store words we\\'ve already gone through. I\\'m just unsure why some of these test cases need to be extremely large. It makes it hard to hand-validate stuff."
                    },
                    {
                        "username": "egor_sklyarov",
                        "content": "I was able to forge a shorter test case: [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]"
                    },
                    {
                        "username": "AniketYadav03",
                        "content": "what algo did you use? try this input:[\"cat\",\"dogbull\",\"dog\",\"catdogbull\"]"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See this solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "**DP Solution Idea**\\n\\nFor every possible position, we first need to check *if we can build up to that point*. \\nIf yes, we try to check for every possible substring starting from that position.\\n\\n<details>\\n  <summary>Implementation of the Idea <b>[Spoiler warning]</b></summary>\\n  \\n  ```c++\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string> s(words.begin(), words.end());\\n        vector<string> res;\\n        for (auto w : words) {\\n            int n = w.size();\\n            vector<int> dp(n+1);\\n            dp[0] = 1;\\n            for (int i = 0; i < n; i++) {\\n                if (dp[i] == 0) continue;\\n                for (int j = i+1; j <= n; j++) {\\n                    if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;\\n                }\\n                if (dp[n]) { res.push_back(w); break; }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n  ```\\n  \\n</details>"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "simple explanation"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I like the Spoiler warning. People in this tab should hide the solution as the way you are doing!"
                    },
                    {
                        "username": "problem_slayer",
                        "content": "The last test case of this question is incorrect. The question says \"***Given an array of strings words***\". For the last test case, this array of strings contains an empty string \"\". So, ***question defines empty string \"\" to be a word***. Question goes on to say, \"A ***concatenated word is defined*** as a string that is ***comprised entirely of at least two shorter words*** in the given array.\".\\n\\nSince the last test case\\'s input contains an empty string \"\" and ***empty string is in the input BECAUSE it is a word***, the output of last test case should be input - {\"\"} which is not the case.\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "\"ackshually\""
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Solving ( word break) problem will help you solve this one."
                    },
                    {
                        "username": "Elghobashy",
                        "content": "Here is my solution using the word break \\nhttps://leetcode.com/problems/concatenated-words/solutions/3106195/easy-to-understand-java-solution-using-solution-of-word-break-problem/"
                    },
                    {
                        "username": "xeniawann",
                        "content": "True, then you can just use answer from that problem as a helper function in this problem. Here\\u2019s the link to it if you need it: https://leetcode.com/problems/word-break/description/"
                    },
                    {
                        "username": "Ranjit-Kumar-Nayak",
                        "content": "public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        Set<String> s = new HashSet<>();\\n        List<String> concatenateWords = new ArrayList<>();\\n        for(String word : words)\\n            s.add(word);\\n        for(String word : words) {\\n            if(checkConcatenate(word, s) == true)\\n                concatenateWords.add(word);\\n        }\\n        return concatenateWords;\\n    }\\n    public boolean checkConcatenate(String word, Set<String> s) {\\n        for(int i = 1; i < word.length(); i++) {\\n            String prefixWord = word.substring(0, i);\\n            String suffixWord = word.substring(i, word.length());\\n            if(s.contains(prefixWord) && (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\\n                return true;\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "The solutions tab is to the right of Discussion. Thanks "
                    },
                    {
                        "username": "abstracted_0507",
                        "content": "The question defines concatenated word as: a string that is comprised entirely of at least two shorter words in the given array. So for the test case [\"cat\", \"dog\", \"catcat\"]. Will the word \"catcat\" be a valid concatenated word? it comprises entirely of only 1 word i.e. \"cat\". \\n\\nThe most voted answer here passes \"catcat\" as a valid concatenates word. But is it really valid?"
                    },
                    {
                        "username": "vivace",
                        "content": "It doesn\\'t say \"unique\". You can repeat a word. "
                    },
                    {
                        "username": "nyunyunyunyu",
                        "content": "I try to challenge some solutions of this problem. But it is always \"fetching...\" after I submit my challenge.\\nAnd I think the dataset is too weak. I'm not sure if there is a solution which could work under the data size, but at least many passed solutions are not correct. For example, it's obvious that the solution of awice(the first place) cannot pass this one, [\"a*599998b\", \"a\"]. And I found most of passed solutions cannot pass this one, too."
                    },
                    {
                        "username": "DaviLu",
                        "content": "There is empty string in the word list in test case.\\n\\nAs it says:\\n**A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.**\\n\\nWhat does **word** mean? If empty string is **word**, all onther words should be in the result but it is not. Otherwise empty string shouldn\\'t be in input as **word** list. It is just added in to create edge cases but not clearified in the question. The input is in a huge list as around 900 words, I didn\\'t check if empty list is in the input.  It could be easier just add test case as `[\"a\",\"aa\",\"\"]` to cover it and return whatever expected result. It wasted me over 1 hour to debug `Trie` stack overflow exception which I thought it was caused by too many recursion, such as `a`, `aa`, `aaa` and `aaaaaaaaaa...aaaaaaaaaab`, in list."
                    }
                ]
            },
            {
                "id": 1777252,
                "content": [
                    {
                        "username": "Brutal7skull",
                        "content": "Finally solved a hard problem without looking at the solution."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Easiest question...No TLE on backtracking :)\nif recursion is strong you can do it within minutes"
                    },
                    {
                        "username": "TFear",
                        "content": "why in massive [\"a\",\"b\",\"ab\",\"abc\"] output [\"ab\",\"abc\"] is incorrect (expected [\"ab\"]).\"a\" and \"b\" are words and \"abc\" is consist of them."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "simply use backtracking"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "\"c\" is not in the input array, so \"abc\" is incorrect (concatenated words must consist entirely of other words)"
                    },
                    {
                        "username": "zhuragat",
                        "content": "I have the same question\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Not really sure why this problem is 'hard'? A simple recursive c++ solution yielded \"faster than 100%\".\n\nOutline of my solution:\n * Add all words to unordered_set<string>\n * Implement a recursive function that checks if the specified string is a concatenated word\n * The function can loop to build a string of the initial characters to check if those characters form a word that is in the set and if yes then recursively call itself on the remainder of the string, if the remainder is a concatenated word then return true. If the loop ends then return false.\n* Call the function for all words in the dictionary and add to answer vector if the function returns true\n\nA tiny amount if special handling is needed to ensure that a word is not considered concatenated just because the word itself is in the set. The recursive function can be optimized a bit by not building new strings for each call, but instead add another parameter which specifies where to start checking in the given string."
                    },
                    {
                        "username": "mmm713",
                        "content": "I tried input [\"a\",\"aa\"], and I expect the result to be []\\n\\nHowever, OJ says result is  [\"aa\"].\\n\\nIs OJ wrong?"
                    },
                    {
                        "username": "vivace",
                        "content": "No. because you can actually repeat the words. \\nYou can take \"a\" twice and therefore the right answer would be \"aa\". \\nOJ is right."
                    },
                    {
                        "username": "XRancher_1232",
                        "content": "Frankly this should have been tagged as medium in my view, very similar to many (string+dp) problems out there."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "trie+memoization, that\\'s all folks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "What the hell is going on on case 42? "
                    },
                    {
                        "username": "warcayac",
                        "content": "What\\'s the limit time for every test? Because for an entry of 8377 words my method takes 1.43s to resolve it, however when submitting I get **Time exceeded**   :-("
                    },
                    {
                        "username": "mahendrakergaurav",
                        "content": "What should be the output for test case 43, I am not even clear what it is."
                    }
                ]
            },
            {
                "id": 1776880,
                "content": [
                    {
                        "username": "Brutal7skull",
                        "content": "Finally solved a hard problem without looking at the solution."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Easiest question...No TLE on backtracking :)\nif recursion is strong you can do it within minutes"
                    },
                    {
                        "username": "TFear",
                        "content": "why in massive [\"a\",\"b\",\"ab\",\"abc\"] output [\"ab\",\"abc\"] is incorrect (expected [\"ab\"]).\"a\" and \"b\" are words and \"abc\" is consist of them."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "simply use backtracking"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "\"c\" is not in the input array, so \"abc\" is incorrect (concatenated words must consist entirely of other words)"
                    },
                    {
                        "username": "zhuragat",
                        "content": "I have the same question\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Not really sure why this problem is 'hard'? A simple recursive c++ solution yielded \"faster than 100%\".\n\nOutline of my solution:\n * Add all words to unordered_set<string>\n * Implement a recursive function that checks if the specified string is a concatenated word\n * The function can loop to build a string of the initial characters to check if those characters form a word that is in the set and if yes then recursively call itself on the remainder of the string, if the remainder is a concatenated word then return true. If the loop ends then return false.\n* Call the function for all words in the dictionary and add to answer vector if the function returns true\n\nA tiny amount if special handling is needed to ensure that a word is not considered concatenated just because the word itself is in the set. The recursive function can be optimized a bit by not building new strings for each call, but instead add another parameter which specifies where to start checking in the given string."
                    },
                    {
                        "username": "mmm713",
                        "content": "I tried input [\"a\",\"aa\"], and I expect the result to be []\\n\\nHowever, OJ says result is  [\"aa\"].\\n\\nIs OJ wrong?"
                    },
                    {
                        "username": "vivace",
                        "content": "No. because you can actually repeat the words. \\nYou can take \"a\" twice and therefore the right answer would be \"aa\". \\nOJ is right."
                    },
                    {
                        "username": "XRancher_1232",
                        "content": "Frankly this should have been tagged as medium in my view, very similar to many (string+dp) problems out there."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "trie+memoization, that\\'s all folks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "What the hell is going on on case 42? "
                    },
                    {
                        "username": "warcayac",
                        "content": "What\\'s the limit time for every test? Because for an entry of 8377 words my method takes 1.43s to resolve it, however when submitting I get **Time exceeded**   :-("
                    },
                    {
                        "username": "mahendrakergaurav",
                        "content": "What should be the output for test case 43, I am not even clear what it is."
                    }
                ]
            },
            {
                "id": 1776840,
                "content": [
                    {
                        "username": "Brutal7skull",
                        "content": "Finally solved a hard problem without looking at the solution."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Easiest question...No TLE on backtracking :)\nif recursion is strong you can do it within minutes"
                    },
                    {
                        "username": "TFear",
                        "content": "why in massive [\"a\",\"b\",\"ab\",\"abc\"] output [\"ab\",\"abc\"] is incorrect (expected [\"ab\"]).\"a\" and \"b\" are words and \"abc\" is consist of them."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "simply use backtracking"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "\"c\" is not in the input array, so \"abc\" is incorrect (concatenated words must consist entirely of other words)"
                    },
                    {
                        "username": "zhuragat",
                        "content": "I have the same question\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Not really sure why this problem is 'hard'? A simple recursive c++ solution yielded \"faster than 100%\".\n\nOutline of my solution:\n * Add all words to unordered_set<string>\n * Implement a recursive function that checks if the specified string is a concatenated word\n * The function can loop to build a string of the initial characters to check if those characters form a word that is in the set and if yes then recursively call itself on the remainder of the string, if the remainder is a concatenated word then return true. If the loop ends then return false.\n* Call the function for all words in the dictionary and add to answer vector if the function returns true\n\nA tiny amount if special handling is needed to ensure that a word is not considered concatenated just because the word itself is in the set. The recursive function can be optimized a bit by not building new strings for each call, but instead add another parameter which specifies where to start checking in the given string."
                    },
                    {
                        "username": "mmm713",
                        "content": "I tried input [\"a\",\"aa\"], and I expect the result to be []\\n\\nHowever, OJ says result is  [\"aa\"].\\n\\nIs OJ wrong?"
                    },
                    {
                        "username": "vivace",
                        "content": "No. because you can actually repeat the words. \\nYou can take \"a\" twice and therefore the right answer would be \"aa\". \\nOJ is right."
                    },
                    {
                        "username": "XRancher_1232",
                        "content": "Frankly this should have been tagged as medium in my view, very similar to many (string+dp) problems out there."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "trie+memoization, that\\'s all folks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "What the hell is going on on case 42? "
                    },
                    {
                        "username": "warcayac",
                        "content": "What\\'s the limit time for every test? Because for an entry of 8377 words my method takes 1.43s to resolve it, however when submitting I get **Time exceeded**   :-("
                    },
                    {
                        "username": "mahendrakergaurav",
                        "content": "What should be the output for test case 43, I am not even clear what it is."
                    }
                ]
            },
            {
                "id": 1776365,
                "content": [
                    {
                        "username": "Brutal7skull",
                        "content": "Finally solved a hard problem without looking at the solution."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Easiest question...No TLE on backtracking :)\nif recursion is strong you can do it within minutes"
                    },
                    {
                        "username": "TFear",
                        "content": "why in massive [\"a\",\"b\",\"ab\",\"abc\"] output [\"ab\",\"abc\"] is incorrect (expected [\"ab\"]).\"a\" and \"b\" are words and \"abc\" is consist of them."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "simply use backtracking"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "\"c\" is not in the input array, so \"abc\" is incorrect (concatenated words must consist entirely of other words)"
                    },
                    {
                        "username": "zhuragat",
                        "content": "I have the same question\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Not really sure why this problem is 'hard'? A simple recursive c++ solution yielded \"faster than 100%\".\n\nOutline of my solution:\n * Add all words to unordered_set<string>\n * Implement a recursive function that checks if the specified string is a concatenated word\n * The function can loop to build a string of the initial characters to check if those characters form a word that is in the set and if yes then recursively call itself on the remainder of the string, if the remainder is a concatenated word then return true. If the loop ends then return false.\n* Call the function for all words in the dictionary and add to answer vector if the function returns true\n\nA tiny amount if special handling is needed to ensure that a word is not considered concatenated just because the word itself is in the set. The recursive function can be optimized a bit by not building new strings for each call, but instead add another parameter which specifies where to start checking in the given string."
                    },
                    {
                        "username": "mmm713",
                        "content": "I tried input [\"a\",\"aa\"], and I expect the result to be []\\n\\nHowever, OJ says result is  [\"aa\"].\\n\\nIs OJ wrong?"
                    },
                    {
                        "username": "vivace",
                        "content": "No. because you can actually repeat the words. \\nYou can take \"a\" twice and therefore the right answer would be \"aa\". \\nOJ is right."
                    },
                    {
                        "username": "XRancher_1232",
                        "content": "Frankly this should have been tagged as medium in my view, very similar to many (string+dp) problems out there."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "trie+memoization, that\\'s all folks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "What the hell is going on on case 42? "
                    },
                    {
                        "username": "warcayac",
                        "content": "What\\'s the limit time for every test? Because for an entry of 8377 words my method takes 1.43s to resolve it, however when submitting I get **Time exceeded**   :-("
                    },
                    {
                        "username": "mahendrakergaurav",
                        "content": "What should be the output for test case 43, I am not even clear what it is."
                    }
                ]
            },
            {
                "id": 1572276,
                "content": [
                    {
                        "username": "Brutal7skull",
                        "content": "Finally solved a hard problem without looking at the solution."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Easiest question...No TLE on backtracking :)\nif recursion is strong you can do it within minutes"
                    },
                    {
                        "username": "TFear",
                        "content": "why in massive [\"a\",\"b\",\"ab\",\"abc\"] output [\"ab\",\"abc\"] is incorrect (expected [\"ab\"]).\"a\" and \"b\" are words and \"abc\" is consist of them."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "simply use backtracking"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "\"c\" is not in the input array, so \"abc\" is incorrect (concatenated words must consist entirely of other words)"
                    },
                    {
                        "username": "zhuragat",
                        "content": "I have the same question\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Not really sure why this problem is 'hard'? A simple recursive c++ solution yielded \"faster than 100%\".\n\nOutline of my solution:\n * Add all words to unordered_set<string>\n * Implement a recursive function that checks if the specified string is a concatenated word\n * The function can loop to build a string of the initial characters to check if those characters form a word that is in the set and if yes then recursively call itself on the remainder of the string, if the remainder is a concatenated word then return true. If the loop ends then return false.\n* Call the function for all words in the dictionary and add to answer vector if the function returns true\n\nA tiny amount if special handling is needed to ensure that a word is not considered concatenated just because the word itself is in the set. The recursive function can be optimized a bit by not building new strings for each call, but instead add another parameter which specifies where to start checking in the given string."
                    },
                    {
                        "username": "mmm713",
                        "content": "I tried input [\"a\",\"aa\"], and I expect the result to be []\\n\\nHowever, OJ says result is  [\"aa\"].\\n\\nIs OJ wrong?"
                    },
                    {
                        "username": "vivace",
                        "content": "No. because you can actually repeat the words. \\nYou can take \"a\" twice and therefore the right answer would be \"aa\". \\nOJ is right."
                    },
                    {
                        "username": "XRancher_1232",
                        "content": "Frankly this should have been tagged as medium in my view, very similar to many (string+dp) problems out there."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "trie+memoization, that\\'s all folks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "What the hell is going on on case 42? "
                    },
                    {
                        "username": "warcayac",
                        "content": "What\\'s the limit time for every test? Because for an entry of 8377 words my method takes 1.43s to resolve it, however when submitting I get **Time exceeded**   :-("
                    },
                    {
                        "username": "mahendrakergaurav",
                        "content": "What should be the output for test case 43, I am not even clear what it is."
                    }
                ]
            },
            {
                "id": 2052147,
                "content": [
                    {
                        "username": "Brutal7skull",
                        "content": "Finally solved a hard problem without looking at the solution."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Easiest question...No TLE on backtracking :)\nif recursion is strong you can do it within minutes"
                    },
                    {
                        "username": "TFear",
                        "content": "why in massive [\"a\",\"b\",\"ab\",\"abc\"] output [\"ab\",\"abc\"] is incorrect (expected [\"ab\"]).\"a\" and \"b\" are words and \"abc\" is consist of them."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "simply use backtracking"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "\"c\" is not in the input array, so \"abc\" is incorrect (concatenated words must consist entirely of other words)"
                    },
                    {
                        "username": "zhuragat",
                        "content": "I have the same question\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Not really sure why this problem is 'hard'? A simple recursive c++ solution yielded \"faster than 100%\".\n\nOutline of my solution:\n * Add all words to unordered_set<string>\n * Implement a recursive function that checks if the specified string is a concatenated word\n * The function can loop to build a string of the initial characters to check if those characters form a word that is in the set and if yes then recursively call itself on the remainder of the string, if the remainder is a concatenated word then return true. If the loop ends then return false.\n* Call the function for all words in the dictionary and add to answer vector if the function returns true\n\nA tiny amount if special handling is needed to ensure that a word is not considered concatenated just because the word itself is in the set. The recursive function can be optimized a bit by not building new strings for each call, but instead add another parameter which specifies where to start checking in the given string."
                    },
                    {
                        "username": "mmm713",
                        "content": "I tried input [\"a\",\"aa\"], and I expect the result to be []\\n\\nHowever, OJ says result is  [\"aa\"].\\n\\nIs OJ wrong?"
                    },
                    {
                        "username": "vivace",
                        "content": "No. because you can actually repeat the words. \\nYou can take \"a\" twice and therefore the right answer would be \"aa\". \\nOJ is right."
                    },
                    {
                        "username": "XRancher_1232",
                        "content": "Frankly this should have been tagged as medium in my view, very similar to many (string+dp) problems out there."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "trie+memoization, that\\'s all folks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "What the hell is going on on case 42? "
                    },
                    {
                        "username": "warcayac",
                        "content": "What\\'s the limit time for every test? Because for an entry of 8377 words my method takes 1.43s to resolve it, however when submitting I get **Time exceeded**   :-("
                    },
                    {
                        "username": "mahendrakergaurav",
                        "content": "What should be the output for test case 43, I am not even clear what it is."
                    }
                ]
            },
            {
                "id": 2038083,
                "content": [
                    {
                        "username": "Brutal7skull",
                        "content": "Finally solved a hard problem without looking at the solution."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Easiest question...No TLE on backtracking :)\nif recursion is strong you can do it within minutes"
                    },
                    {
                        "username": "TFear",
                        "content": "why in massive [\"a\",\"b\",\"ab\",\"abc\"] output [\"ab\",\"abc\"] is incorrect (expected [\"ab\"]).\"a\" and \"b\" are words and \"abc\" is consist of them."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "simply use backtracking"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "\"c\" is not in the input array, so \"abc\" is incorrect (concatenated words must consist entirely of other words)"
                    },
                    {
                        "username": "zhuragat",
                        "content": "I have the same question\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Not really sure why this problem is 'hard'? A simple recursive c++ solution yielded \"faster than 100%\".\n\nOutline of my solution:\n * Add all words to unordered_set<string>\n * Implement a recursive function that checks if the specified string is a concatenated word\n * The function can loop to build a string of the initial characters to check if those characters form a word that is in the set and if yes then recursively call itself on the remainder of the string, if the remainder is a concatenated word then return true. If the loop ends then return false.\n* Call the function for all words in the dictionary and add to answer vector if the function returns true\n\nA tiny amount if special handling is needed to ensure that a word is not considered concatenated just because the word itself is in the set. The recursive function can be optimized a bit by not building new strings for each call, but instead add another parameter which specifies where to start checking in the given string."
                    },
                    {
                        "username": "mmm713",
                        "content": "I tried input [\"a\",\"aa\"], and I expect the result to be []\\n\\nHowever, OJ says result is  [\"aa\"].\\n\\nIs OJ wrong?"
                    },
                    {
                        "username": "vivace",
                        "content": "No. because you can actually repeat the words. \\nYou can take \"a\" twice and therefore the right answer would be \"aa\". \\nOJ is right."
                    },
                    {
                        "username": "XRancher_1232",
                        "content": "Frankly this should have been tagged as medium in my view, very similar to many (string+dp) problems out there."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "trie+memoization, that\\'s all folks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "What the hell is going on on case 42? "
                    },
                    {
                        "username": "warcayac",
                        "content": "What\\'s the limit time for every test? Because for an entry of 8377 words my method takes 1.43s to resolve it, however when submitting I get **Time exceeded**   :-("
                    },
                    {
                        "username": "mahendrakergaurav",
                        "content": "What should be the output for test case 43, I am not even clear what it is."
                    }
                ]
            },
            {
                "id": 1822009,
                "content": [
                    {
                        "username": "Brutal7skull",
                        "content": "Finally solved a hard problem without looking at the solution."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Easiest question...No TLE on backtracking :)\nif recursion is strong you can do it within minutes"
                    },
                    {
                        "username": "TFear",
                        "content": "why in massive [\"a\",\"b\",\"ab\",\"abc\"] output [\"ab\",\"abc\"] is incorrect (expected [\"ab\"]).\"a\" and \"b\" are words and \"abc\" is consist of them."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "simply use backtracking"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "\"c\" is not in the input array, so \"abc\" is incorrect (concatenated words must consist entirely of other words)"
                    },
                    {
                        "username": "zhuragat",
                        "content": "I have the same question\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Not really sure why this problem is 'hard'? A simple recursive c++ solution yielded \"faster than 100%\".\n\nOutline of my solution:\n * Add all words to unordered_set<string>\n * Implement a recursive function that checks if the specified string is a concatenated word\n * The function can loop to build a string of the initial characters to check if those characters form a word that is in the set and if yes then recursively call itself on the remainder of the string, if the remainder is a concatenated word then return true. If the loop ends then return false.\n* Call the function for all words in the dictionary and add to answer vector if the function returns true\n\nA tiny amount if special handling is needed to ensure that a word is not considered concatenated just because the word itself is in the set. The recursive function can be optimized a bit by not building new strings for each call, but instead add another parameter which specifies where to start checking in the given string."
                    },
                    {
                        "username": "mmm713",
                        "content": "I tried input [\"a\",\"aa\"], and I expect the result to be []\\n\\nHowever, OJ says result is  [\"aa\"].\\n\\nIs OJ wrong?"
                    },
                    {
                        "username": "vivace",
                        "content": "No. because you can actually repeat the words. \\nYou can take \"a\" twice and therefore the right answer would be \"aa\". \\nOJ is right."
                    },
                    {
                        "username": "XRancher_1232",
                        "content": "Frankly this should have been tagged as medium in my view, very similar to many (string+dp) problems out there."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "trie+memoization, that\\'s all folks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "What the hell is going on on case 42? "
                    },
                    {
                        "username": "warcayac",
                        "content": "What\\'s the limit time for every test? Because for an entry of 8377 words my method takes 1.43s to resolve it, however when submitting I get **Time exceeded**   :-("
                    },
                    {
                        "username": "mahendrakergaurav",
                        "content": "What should be the output for test case 43, I am not even clear what it is."
                    }
                ]
            },
            {
                "id": 1783717,
                "content": [
                    {
                        "username": "Brutal7skull",
                        "content": "Finally solved a hard problem without looking at the solution."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Easiest question...No TLE on backtracking :)\nif recursion is strong you can do it within minutes"
                    },
                    {
                        "username": "TFear",
                        "content": "why in massive [\"a\",\"b\",\"ab\",\"abc\"] output [\"ab\",\"abc\"] is incorrect (expected [\"ab\"]).\"a\" and \"b\" are words and \"abc\" is consist of them."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "simply use backtracking"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "\"c\" is not in the input array, so \"abc\" is incorrect (concatenated words must consist entirely of other words)"
                    },
                    {
                        "username": "zhuragat",
                        "content": "I have the same question\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Not really sure why this problem is 'hard'? A simple recursive c++ solution yielded \"faster than 100%\".\n\nOutline of my solution:\n * Add all words to unordered_set<string>\n * Implement a recursive function that checks if the specified string is a concatenated word\n * The function can loop to build a string of the initial characters to check if those characters form a word that is in the set and if yes then recursively call itself on the remainder of the string, if the remainder is a concatenated word then return true. If the loop ends then return false.\n* Call the function for all words in the dictionary and add to answer vector if the function returns true\n\nA tiny amount if special handling is needed to ensure that a word is not considered concatenated just because the word itself is in the set. The recursive function can be optimized a bit by not building new strings for each call, but instead add another parameter which specifies where to start checking in the given string."
                    },
                    {
                        "username": "mmm713",
                        "content": "I tried input [\"a\",\"aa\"], and I expect the result to be []\\n\\nHowever, OJ says result is  [\"aa\"].\\n\\nIs OJ wrong?"
                    },
                    {
                        "username": "vivace",
                        "content": "No. because you can actually repeat the words. \\nYou can take \"a\" twice and therefore the right answer would be \"aa\". \\nOJ is right."
                    },
                    {
                        "username": "XRancher_1232",
                        "content": "Frankly this should have been tagged as medium in my view, very similar to many (string+dp) problems out there."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "trie+memoization, that\\'s all folks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "What the hell is going on on case 42? "
                    },
                    {
                        "username": "warcayac",
                        "content": "What\\'s the limit time for every test? Because for an entry of 8377 words my method takes 1.43s to resolve it, however when submitting I get **Time exceeded**   :-("
                    },
                    {
                        "username": "mahendrakergaurav",
                        "content": "What should be the output for test case 43, I am not even clear what it is."
                    }
                ]
            },
            {
                "id": 1778126,
                "content": [
                    {
                        "username": "Brutal7skull",
                        "content": "Finally solved a hard problem without looking at the solution."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "Easiest question...No TLE on backtracking :)\nif recursion is strong you can do it within minutes"
                    },
                    {
                        "username": "TFear",
                        "content": "why in massive [\"a\",\"b\",\"ab\",\"abc\"] output [\"ab\",\"abc\"] is incorrect (expected [\"ab\"]).\"a\" and \"b\" are words and \"abc\" is consist of them."
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "simply use backtracking"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "\"c\" is not in the input array, so \"abc\" is incorrect (concatenated words must consist entirely of other words)"
                    },
                    {
                        "username": "zhuragat",
                        "content": "I have the same question\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Not really sure why this problem is 'hard'? A simple recursive c++ solution yielded \"faster than 100%\".\n\nOutline of my solution:\n * Add all words to unordered_set<string>\n * Implement a recursive function that checks if the specified string is a concatenated word\n * The function can loop to build a string of the initial characters to check if those characters form a word that is in the set and if yes then recursively call itself on the remainder of the string, if the remainder is a concatenated word then return true. If the loop ends then return false.\n* Call the function for all words in the dictionary and add to answer vector if the function returns true\n\nA tiny amount if special handling is needed to ensure that a word is not considered concatenated just because the word itself is in the set. The recursive function can be optimized a bit by not building new strings for each call, but instead add another parameter which specifies where to start checking in the given string."
                    },
                    {
                        "username": "mmm713",
                        "content": "I tried input [\"a\",\"aa\"], and I expect the result to be []\\n\\nHowever, OJ says result is  [\"aa\"].\\n\\nIs OJ wrong?"
                    },
                    {
                        "username": "vivace",
                        "content": "No. because you can actually repeat the words. \\nYou can take \"a\" twice and therefore the right answer would be \"aa\". \\nOJ is right."
                    },
                    {
                        "username": "XRancher_1232",
                        "content": "Frankly this should have been tagged as medium in my view, very similar to many (string+dp) problems out there."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "trie+memoization, that\\'s all folks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "What the hell is going on on case 42? "
                    },
                    {
                        "username": "warcayac",
                        "content": "What\\'s the limit time for every test? Because for an entry of 8377 words my method takes 1.43s to resolve it, however when submitting I get **Time exceeded**   :-("
                    },
                    {
                        "username": "mahendrakergaurav",
                        "content": "What should be the output for test case 43, I am not even clear what it is."
                    }
                ]
            },
            {
                "id": 1778105,
                "content": [
                    {
                        "username": "mahendrakergaurav",
                        "content": "Can someone explain what the answer should be in the last test case where its an empty string"
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Then use TreeMap, to avoid checking null when using floorEntry and ceilingEntry, add MAX_VALUE and MIN_VALUE to the tree. When get the intervals, use subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) to exclude these two extreme values."
                    },
                    {
                        "username": "PankajVP",
                        "content": "Failing on a test case:[\"a\",\"b\",\"ab\",\"abc\"]\\nMy codes Output:\\n[\"ab\",\"abc\"]\\nExpected Output:\\n[\"ab\"]\\n\\nWhy it\\'s not taking abc?\\nabc is composed of two shorter elements in an array, \\'a\\' and \\'b\\'."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "\"comprised entirely\" as you see in the question, in your case \"c\" is missing."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Why my code is Showing TLE: \nI sort the array and removed duplicates may that is the issue .. plss help me guide me how can i put some conditions so that Duplicate elements are not pushed into the array.\n\nclass Solution {\npublic:\n\n    vector<string> ans;\n\n    void help(int ind,string word,vector<string>words,int len)\n    {\n\n        int wordlen=word.length();\n        if(wordlen==0)\n        {\n            ans.push_back(words[ind]);\n            return;\n        }\n\n        for(int i=0;i<len;i++)\n        {\n            if(i!=ind)\n            {\n                int swlen=words[i].length();\n                if(wordlen>=swlen)\n                {\n                    string temp=word.substr(0,swlen);\n                    if(words[i]==temp)\n                    {\n                        // cout<<ind<<\" \"<<i<<\" \"<<word<<endl;\n                        help(ind,word.substr(swlen),words,len);\n                    }\n                }\n            }\n            \n        }\n        \n    }\n\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words)\n    {\n        int len=words.size();\n        // cout<<len<<endl;\n        for(int i=0;i<len;i++)\n        {\n            help(i,words[i],words,len);\n        }\n        std::sort(ans.begin(), ans.end());\n        ans.erase(std::unique(ans.begin(), ans.end()), ans.end());\n        return ans;    \n    }\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "try to pass arguments with reference\\n"
                    },
                    {
                        "username": "michaelmandich",
                        "content": "I\\'m getting a time limit exceeded. any  way I could fix this? it worked on 6/42\\nmy attempted solution below\\n||\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        // program will go through each word, and then see if the beginning substring is part of \\n        // another word, if it is, it will then see if there is another word (if not the same word,\\n        // that composes the remainder)\\n        // it will do so first by checking the length of the remaining letters, seeing if each word \\n        // will even fit, if so it will test the number of letters its being compared to , if it \\n        // matches then the remaining substring will be tested against all words. if it makes it \\n        // all the way to the end of the word, the word is flagged correct. if the current word  \\n        // fits,it will continue on and check all potential trees to see if one combo works. \\n    //  main function just runs through the list of words and calls the  recursive function, which is doing most of the heavy lifting.\\n    \\n    List<String> Concats = new ArrayList<String>();\\n        for(int currentWord = 0; currentWord<words.length ; currentWord++){\\n            if (isConcat(words,currentWord, words[currentWord]) == true){\\n                Concats.add(words[currentWord]);\\n            }\\n        }\\n        return Concats;\\n    }\\n\\n    // first if statement catches whether it\\'s checking itself within the list, and whether it will fit\\n    // second is to see if the word combonation in question is the end of the word, if so returns True\\n    // third sees if it fits within the current section, if not --- example: cat and cat of \"cats\" and \"cat\"\\n    public boolean isConcat(String[] listOfWords, int skip, String word){\\n        for(int i = 0; i<listOfWords.length;i++){\\n            if ((listOfWords[i]==null)||(i == skip)||(listOfWords[i].length()>word.length())){\\n                continue;\\n            }\\n            if (word.equals(listOfWords[i])){\\n                return true;\\n            }\\n            if ((word.substring(0,(listOfWords[i].length()))).equals(listOfWords[i])){\\n                if ((isConcat(listOfWords, skip, word.substring(listOfWords[i].length()))) == true){\\n                    return true;\\n                }\\n                continue; \\n            }\\n        }\\n        return false; \\n    }\\n}\\n\\n||"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Yongbi",
                        "content": "At first I think it should be a hard Trie-dict problem, then I run a dry test with \n`words = [\"cat\",\"catcatcat\"]` the expected output is: `[\"catcatcat\"]` it does consider the repeated word!!! That moment I breathed a sigh of relief. \n\nTIP! Just try a DFS for a set of given words. Everything _left_ is on you.\n`#Sets use hashing to perform look ups which makes them way faster than lists!`\n\nI'm pretty lazy to write the solution as usual. Below is not a solution, just one of approaches:\n\n```\n        def DFScheckstring(string=\"\", another argument):\n            for i in range(len(string)):                \n                 do something.. return True\n            return False\n        \n        dic, ans = set(words), []\n        for word in dic:             \n            if DFScheckstring(word): ans.append(word)\n        return ans  \n```\n"
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "[@Yongbi](/Yongbi)  Gotcha, Thank you"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Brutal7skull](/Brutal7skull) The idea of DFS is the same bro, but your approach has a better memory complexity than the slicing string. \\nNice one. But, \\n=> try to hide solution in spoil tab, cause we are discussing in \"public zone\"."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "Similar DFS \n\nAlgorithm:\n\n1. Sort it according to the length\n2. Convert words to set \n3. start iterating from last of the sorted words\n4. Make choice to take it or continue without taking it\n5. Keep count which will count the number of concatenated words\n6. Add it to result if count > 1\n       "
                    },
                    {
                        "username": "ajesk",
                        "content": "Just barely scraped by on this one... Word tree problems are still a bit of a weakness for me. Def revisiting this one when I understand it a tad better"
                    },
                    {
                        "username": "emirhanozlen",
                        "content": "A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\\n\\nInput\\nwords =\\n[\"cat\",\"catcat\"]\\nExpected\\n[\"catcat\"]\\n\\ncat does not exist twice, so isn\\'t this description a bit misleading?\\n"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think this problem should be medium."
                    },
                    {
                        "username": "ashishb97",
                        "content": "Testcase 5) \nThe word 'naturalized'  can be concatenated by words 'naturalize' and 'ed' (as per the rule).\nBut the expected array doesn't contain that word. am I missing something here? "
                    },
                    {
                        "username": "ashishb97",
                        "content": "[@Random_Letters](/Random_Letters)  But in Testcase 4)\\nit has allowed \\'bilt\\' because of \\'lt\\', \\'il\\' and \\'b\\'. (\\'i\\', \\'l\\', \\'t\\' were not in the list)"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "that would give \"naturalizeed\""
                    }
                ]
            },
            {
                "id": 1777222,
                "content": [
                    {
                        "username": "mahendrakergaurav",
                        "content": "Can someone explain what the answer should be in the last test case where its an empty string"
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Then use TreeMap, to avoid checking null when using floorEntry and ceilingEntry, add MAX_VALUE and MIN_VALUE to the tree. When get the intervals, use subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) to exclude these two extreme values."
                    },
                    {
                        "username": "PankajVP",
                        "content": "Failing on a test case:[\"a\",\"b\",\"ab\",\"abc\"]\\nMy codes Output:\\n[\"ab\",\"abc\"]\\nExpected Output:\\n[\"ab\"]\\n\\nWhy it\\'s not taking abc?\\nabc is composed of two shorter elements in an array, \\'a\\' and \\'b\\'."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "\"comprised entirely\" as you see in the question, in your case \"c\" is missing."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Why my code is Showing TLE: \nI sort the array and removed duplicates may that is the issue .. plss help me guide me how can i put some conditions so that Duplicate elements are not pushed into the array.\n\nclass Solution {\npublic:\n\n    vector<string> ans;\n\n    void help(int ind,string word,vector<string>words,int len)\n    {\n\n        int wordlen=word.length();\n        if(wordlen==0)\n        {\n            ans.push_back(words[ind]);\n            return;\n        }\n\n        for(int i=0;i<len;i++)\n        {\n            if(i!=ind)\n            {\n                int swlen=words[i].length();\n                if(wordlen>=swlen)\n                {\n                    string temp=word.substr(0,swlen);\n                    if(words[i]==temp)\n                    {\n                        // cout<<ind<<\" \"<<i<<\" \"<<word<<endl;\n                        help(ind,word.substr(swlen),words,len);\n                    }\n                }\n            }\n            \n        }\n        \n    }\n\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words)\n    {\n        int len=words.size();\n        // cout<<len<<endl;\n        for(int i=0;i<len;i++)\n        {\n            help(i,words[i],words,len);\n        }\n        std::sort(ans.begin(), ans.end());\n        ans.erase(std::unique(ans.begin(), ans.end()), ans.end());\n        return ans;    \n    }\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "try to pass arguments with reference\\n"
                    },
                    {
                        "username": "michaelmandich",
                        "content": "I\\'m getting a time limit exceeded. any  way I could fix this? it worked on 6/42\\nmy attempted solution below\\n||\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        // program will go through each word, and then see if the beginning substring is part of \\n        // another word, if it is, it will then see if there is another word (if not the same word,\\n        // that composes the remainder)\\n        // it will do so first by checking the length of the remaining letters, seeing if each word \\n        // will even fit, if so it will test the number of letters its being compared to , if it \\n        // matches then the remaining substring will be tested against all words. if it makes it \\n        // all the way to the end of the word, the word is flagged correct. if the current word  \\n        // fits,it will continue on and check all potential trees to see if one combo works. \\n    //  main function just runs through the list of words and calls the  recursive function, which is doing most of the heavy lifting.\\n    \\n    List<String> Concats = new ArrayList<String>();\\n        for(int currentWord = 0; currentWord<words.length ; currentWord++){\\n            if (isConcat(words,currentWord, words[currentWord]) == true){\\n                Concats.add(words[currentWord]);\\n            }\\n        }\\n        return Concats;\\n    }\\n\\n    // first if statement catches whether it\\'s checking itself within the list, and whether it will fit\\n    // second is to see if the word combonation in question is the end of the word, if so returns True\\n    // third sees if it fits within the current section, if not --- example: cat and cat of \"cats\" and \"cat\"\\n    public boolean isConcat(String[] listOfWords, int skip, String word){\\n        for(int i = 0; i<listOfWords.length;i++){\\n            if ((listOfWords[i]==null)||(i == skip)||(listOfWords[i].length()>word.length())){\\n                continue;\\n            }\\n            if (word.equals(listOfWords[i])){\\n                return true;\\n            }\\n            if ((word.substring(0,(listOfWords[i].length()))).equals(listOfWords[i])){\\n                if ((isConcat(listOfWords, skip, word.substring(listOfWords[i].length()))) == true){\\n                    return true;\\n                }\\n                continue; \\n            }\\n        }\\n        return false; \\n    }\\n}\\n\\n||"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Yongbi",
                        "content": "At first I think it should be a hard Trie-dict problem, then I run a dry test with \n`words = [\"cat\",\"catcatcat\"]` the expected output is: `[\"catcatcat\"]` it does consider the repeated word!!! That moment I breathed a sigh of relief. \n\nTIP! Just try a DFS for a set of given words. Everything _left_ is on you.\n`#Sets use hashing to perform look ups which makes them way faster than lists!`\n\nI'm pretty lazy to write the solution as usual. Below is not a solution, just one of approaches:\n\n```\n        def DFScheckstring(string=\"\", another argument):\n            for i in range(len(string)):                \n                 do something.. return True\n            return False\n        \n        dic, ans = set(words), []\n        for word in dic:             \n            if DFScheckstring(word): ans.append(word)\n        return ans  \n```\n"
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "[@Yongbi](/Yongbi)  Gotcha, Thank you"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Brutal7skull](/Brutal7skull) The idea of DFS is the same bro, but your approach has a better memory complexity than the slicing string. \\nNice one. But, \\n=> try to hide solution in spoil tab, cause we are discussing in \"public zone\"."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "Similar DFS \n\nAlgorithm:\n\n1. Sort it according to the length\n2. Convert words to set \n3. start iterating from last of the sorted words\n4. Make choice to take it or continue without taking it\n5. Keep count which will count the number of concatenated words\n6. Add it to result if count > 1\n       "
                    },
                    {
                        "username": "ajesk",
                        "content": "Just barely scraped by on this one... Word tree problems are still a bit of a weakness for me. Def revisiting this one when I understand it a tad better"
                    },
                    {
                        "username": "emirhanozlen",
                        "content": "A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\\n\\nInput\\nwords =\\n[\"cat\",\"catcat\"]\\nExpected\\n[\"catcat\"]\\n\\ncat does not exist twice, so isn\\'t this description a bit misleading?\\n"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think this problem should be medium."
                    },
                    {
                        "username": "ashishb97",
                        "content": "Testcase 5) \nThe word 'naturalized'  can be concatenated by words 'naturalize' and 'ed' (as per the rule).\nBut the expected array doesn't contain that word. am I missing something here? "
                    },
                    {
                        "username": "ashishb97",
                        "content": "[@Random_Letters](/Random_Letters)  But in Testcase 4)\\nit has allowed \\'bilt\\' because of \\'lt\\', \\'il\\' and \\'b\\'. (\\'i\\', \\'l\\', \\'t\\' were not in the list)"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "that would give \"naturalizeed\""
                    }
                ]
            },
            {
                "id": 1777188,
                "content": [
                    {
                        "username": "mahendrakergaurav",
                        "content": "Can someone explain what the answer should be in the last test case where its an empty string"
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Then use TreeMap, to avoid checking null when using floorEntry and ceilingEntry, add MAX_VALUE and MIN_VALUE to the tree. When get the intervals, use subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) to exclude these two extreme values."
                    },
                    {
                        "username": "PankajVP",
                        "content": "Failing on a test case:[\"a\",\"b\",\"ab\",\"abc\"]\\nMy codes Output:\\n[\"ab\",\"abc\"]\\nExpected Output:\\n[\"ab\"]\\n\\nWhy it\\'s not taking abc?\\nabc is composed of two shorter elements in an array, \\'a\\' and \\'b\\'."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "\"comprised entirely\" as you see in the question, in your case \"c\" is missing."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Why my code is Showing TLE: \nI sort the array and removed duplicates may that is the issue .. plss help me guide me how can i put some conditions so that Duplicate elements are not pushed into the array.\n\nclass Solution {\npublic:\n\n    vector<string> ans;\n\n    void help(int ind,string word,vector<string>words,int len)\n    {\n\n        int wordlen=word.length();\n        if(wordlen==0)\n        {\n            ans.push_back(words[ind]);\n            return;\n        }\n\n        for(int i=0;i<len;i++)\n        {\n            if(i!=ind)\n            {\n                int swlen=words[i].length();\n                if(wordlen>=swlen)\n                {\n                    string temp=word.substr(0,swlen);\n                    if(words[i]==temp)\n                    {\n                        // cout<<ind<<\" \"<<i<<\" \"<<word<<endl;\n                        help(ind,word.substr(swlen),words,len);\n                    }\n                }\n            }\n            \n        }\n        \n    }\n\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words)\n    {\n        int len=words.size();\n        // cout<<len<<endl;\n        for(int i=0;i<len;i++)\n        {\n            help(i,words[i],words,len);\n        }\n        std::sort(ans.begin(), ans.end());\n        ans.erase(std::unique(ans.begin(), ans.end()), ans.end());\n        return ans;    \n    }\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "try to pass arguments with reference\\n"
                    },
                    {
                        "username": "michaelmandich",
                        "content": "I\\'m getting a time limit exceeded. any  way I could fix this? it worked on 6/42\\nmy attempted solution below\\n||\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        // program will go through each word, and then see if the beginning substring is part of \\n        // another word, if it is, it will then see if there is another word (if not the same word,\\n        // that composes the remainder)\\n        // it will do so first by checking the length of the remaining letters, seeing if each word \\n        // will even fit, if so it will test the number of letters its being compared to , if it \\n        // matches then the remaining substring will be tested against all words. if it makes it \\n        // all the way to the end of the word, the word is flagged correct. if the current word  \\n        // fits,it will continue on and check all potential trees to see if one combo works. \\n    //  main function just runs through the list of words and calls the  recursive function, which is doing most of the heavy lifting.\\n    \\n    List<String> Concats = new ArrayList<String>();\\n        for(int currentWord = 0; currentWord<words.length ; currentWord++){\\n            if (isConcat(words,currentWord, words[currentWord]) == true){\\n                Concats.add(words[currentWord]);\\n            }\\n        }\\n        return Concats;\\n    }\\n\\n    // first if statement catches whether it\\'s checking itself within the list, and whether it will fit\\n    // second is to see if the word combonation in question is the end of the word, if so returns True\\n    // third sees if it fits within the current section, if not --- example: cat and cat of \"cats\" and \"cat\"\\n    public boolean isConcat(String[] listOfWords, int skip, String word){\\n        for(int i = 0; i<listOfWords.length;i++){\\n            if ((listOfWords[i]==null)||(i == skip)||(listOfWords[i].length()>word.length())){\\n                continue;\\n            }\\n            if (word.equals(listOfWords[i])){\\n                return true;\\n            }\\n            if ((word.substring(0,(listOfWords[i].length()))).equals(listOfWords[i])){\\n                if ((isConcat(listOfWords, skip, word.substring(listOfWords[i].length()))) == true){\\n                    return true;\\n                }\\n                continue; \\n            }\\n        }\\n        return false; \\n    }\\n}\\n\\n||"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Yongbi",
                        "content": "At first I think it should be a hard Trie-dict problem, then I run a dry test with \n`words = [\"cat\",\"catcatcat\"]` the expected output is: `[\"catcatcat\"]` it does consider the repeated word!!! That moment I breathed a sigh of relief. \n\nTIP! Just try a DFS for a set of given words. Everything _left_ is on you.\n`#Sets use hashing to perform look ups which makes them way faster than lists!`\n\nI'm pretty lazy to write the solution as usual. Below is not a solution, just one of approaches:\n\n```\n        def DFScheckstring(string=\"\", another argument):\n            for i in range(len(string)):                \n                 do something.. return True\n            return False\n        \n        dic, ans = set(words), []\n        for word in dic:             \n            if DFScheckstring(word): ans.append(word)\n        return ans  \n```\n"
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "[@Yongbi](/Yongbi)  Gotcha, Thank you"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Brutal7skull](/Brutal7skull) The idea of DFS is the same bro, but your approach has a better memory complexity than the slicing string. \\nNice one. But, \\n=> try to hide solution in spoil tab, cause we are discussing in \"public zone\"."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "Similar DFS \n\nAlgorithm:\n\n1. Sort it according to the length\n2. Convert words to set \n3. start iterating from last of the sorted words\n4. Make choice to take it or continue without taking it\n5. Keep count which will count the number of concatenated words\n6. Add it to result if count > 1\n       "
                    },
                    {
                        "username": "ajesk",
                        "content": "Just barely scraped by on this one... Word tree problems are still a bit of a weakness for me. Def revisiting this one when I understand it a tad better"
                    },
                    {
                        "username": "emirhanozlen",
                        "content": "A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\\n\\nInput\\nwords =\\n[\"cat\",\"catcat\"]\\nExpected\\n[\"catcat\"]\\n\\ncat does not exist twice, so isn\\'t this description a bit misleading?\\n"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think this problem should be medium."
                    },
                    {
                        "username": "ashishb97",
                        "content": "Testcase 5) \nThe word 'naturalized'  can be concatenated by words 'naturalize' and 'ed' (as per the rule).\nBut the expected array doesn't contain that word. am I missing something here? "
                    },
                    {
                        "username": "ashishb97",
                        "content": "[@Random_Letters](/Random_Letters)  But in Testcase 4)\\nit has allowed \\'bilt\\' because of \\'lt\\', \\'il\\' and \\'b\\'. (\\'i\\', \\'l\\', \\'t\\' were not in the list)"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "that would give \"naturalizeed\""
                    }
                ]
            },
            {
                "id": 1777142,
                "content": [
                    {
                        "username": "mahendrakergaurav",
                        "content": "Can someone explain what the answer should be in the last test case where its an empty string"
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Then use TreeMap, to avoid checking null when using floorEntry and ceilingEntry, add MAX_VALUE and MIN_VALUE to the tree. When get the intervals, use subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) to exclude these two extreme values."
                    },
                    {
                        "username": "PankajVP",
                        "content": "Failing on a test case:[\"a\",\"b\",\"ab\",\"abc\"]\\nMy codes Output:\\n[\"ab\",\"abc\"]\\nExpected Output:\\n[\"ab\"]\\n\\nWhy it\\'s not taking abc?\\nabc is composed of two shorter elements in an array, \\'a\\' and \\'b\\'."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "\"comprised entirely\" as you see in the question, in your case \"c\" is missing."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Why my code is Showing TLE: \nI sort the array and removed duplicates may that is the issue .. plss help me guide me how can i put some conditions so that Duplicate elements are not pushed into the array.\n\nclass Solution {\npublic:\n\n    vector<string> ans;\n\n    void help(int ind,string word,vector<string>words,int len)\n    {\n\n        int wordlen=word.length();\n        if(wordlen==0)\n        {\n            ans.push_back(words[ind]);\n            return;\n        }\n\n        for(int i=0;i<len;i++)\n        {\n            if(i!=ind)\n            {\n                int swlen=words[i].length();\n                if(wordlen>=swlen)\n                {\n                    string temp=word.substr(0,swlen);\n                    if(words[i]==temp)\n                    {\n                        // cout<<ind<<\" \"<<i<<\" \"<<word<<endl;\n                        help(ind,word.substr(swlen),words,len);\n                    }\n                }\n            }\n            \n        }\n        \n    }\n\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words)\n    {\n        int len=words.size();\n        // cout<<len<<endl;\n        for(int i=0;i<len;i++)\n        {\n            help(i,words[i],words,len);\n        }\n        std::sort(ans.begin(), ans.end());\n        ans.erase(std::unique(ans.begin(), ans.end()), ans.end());\n        return ans;    \n    }\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "try to pass arguments with reference\\n"
                    },
                    {
                        "username": "michaelmandich",
                        "content": "I\\'m getting a time limit exceeded. any  way I could fix this? it worked on 6/42\\nmy attempted solution below\\n||\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        // program will go through each word, and then see if the beginning substring is part of \\n        // another word, if it is, it will then see if there is another word (if not the same word,\\n        // that composes the remainder)\\n        // it will do so first by checking the length of the remaining letters, seeing if each word \\n        // will even fit, if so it will test the number of letters its being compared to , if it \\n        // matches then the remaining substring will be tested against all words. if it makes it \\n        // all the way to the end of the word, the word is flagged correct. if the current word  \\n        // fits,it will continue on and check all potential trees to see if one combo works. \\n    //  main function just runs through the list of words and calls the  recursive function, which is doing most of the heavy lifting.\\n    \\n    List<String> Concats = new ArrayList<String>();\\n        for(int currentWord = 0; currentWord<words.length ; currentWord++){\\n            if (isConcat(words,currentWord, words[currentWord]) == true){\\n                Concats.add(words[currentWord]);\\n            }\\n        }\\n        return Concats;\\n    }\\n\\n    // first if statement catches whether it\\'s checking itself within the list, and whether it will fit\\n    // second is to see if the word combonation in question is the end of the word, if so returns True\\n    // third sees if it fits within the current section, if not --- example: cat and cat of \"cats\" and \"cat\"\\n    public boolean isConcat(String[] listOfWords, int skip, String word){\\n        for(int i = 0; i<listOfWords.length;i++){\\n            if ((listOfWords[i]==null)||(i == skip)||(listOfWords[i].length()>word.length())){\\n                continue;\\n            }\\n            if (word.equals(listOfWords[i])){\\n                return true;\\n            }\\n            if ((word.substring(0,(listOfWords[i].length()))).equals(listOfWords[i])){\\n                if ((isConcat(listOfWords, skip, word.substring(listOfWords[i].length()))) == true){\\n                    return true;\\n                }\\n                continue; \\n            }\\n        }\\n        return false; \\n    }\\n}\\n\\n||"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Yongbi",
                        "content": "At first I think it should be a hard Trie-dict problem, then I run a dry test with \n`words = [\"cat\",\"catcatcat\"]` the expected output is: `[\"catcatcat\"]` it does consider the repeated word!!! That moment I breathed a sigh of relief. \n\nTIP! Just try a DFS for a set of given words. Everything _left_ is on you.\n`#Sets use hashing to perform look ups which makes them way faster than lists!`\n\nI'm pretty lazy to write the solution as usual. Below is not a solution, just one of approaches:\n\n```\n        def DFScheckstring(string=\"\", another argument):\n            for i in range(len(string)):                \n                 do something.. return True\n            return False\n        \n        dic, ans = set(words), []\n        for word in dic:             \n            if DFScheckstring(word): ans.append(word)\n        return ans  \n```\n"
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "[@Yongbi](/Yongbi)  Gotcha, Thank you"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Brutal7skull](/Brutal7skull) The idea of DFS is the same bro, but your approach has a better memory complexity than the slicing string. \\nNice one. But, \\n=> try to hide solution in spoil tab, cause we are discussing in \"public zone\"."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "Similar DFS \n\nAlgorithm:\n\n1. Sort it according to the length\n2. Convert words to set \n3. start iterating from last of the sorted words\n4. Make choice to take it or continue without taking it\n5. Keep count which will count the number of concatenated words\n6. Add it to result if count > 1\n       "
                    },
                    {
                        "username": "ajesk",
                        "content": "Just barely scraped by on this one... Word tree problems are still a bit of a weakness for me. Def revisiting this one when I understand it a tad better"
                    },
                    {
                        "username": "emirhanozlen",
                        "content": "A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\\n\\nInput\\nwords =\\n[\"cat\",\"catcat\"]\\nExpected\\n[\"catcat\"]\\n\\ncat does not exist twice, so isn\\'t this description a bit misleading?\\n"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think this problem should be medium."
                    },
                    {
                        "username": "ashishb97",
                        "content": "Testcase 5) \nThe word 'naturalized'  can be concatenated by words 'naturalize' and 'ed' (as per the rule).\nBut the expected array doesn't contain that word. am I missing something here? "
                    },
                    {
                        "username": "ashishb97",
                        "content": "[@Random_Letters](/Random_Letters)  But in Testcase 4)\\nit has allowed \\'bilt\\' because of \\'lt\\', \\'il\\' and \\'b\\'. (\\'i\\', \\'l\\', \\'t\\' were not in the list)"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "that would give \"naturalizeed\""
                    }
                ]
            },
            {
                "id": 1777133,
                "content": [
                    {
                        "username": "mahendrakergaurav",
                        "content": "Can someone explain what the answer should be in the last test case where its an empty string"
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Then use TreeMap, to avoid checking null when using floorEntry and ceilingEntry, add MAX_VALUE and MIN_VALUE to the tree. When get the intervals, use subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) to exclude these two extreme values."
                    },
                    {
                        "username": "PankajVP",
                        "content": "Failing on a test case:[\"a\",\"b\",\"ab\",\"abc\"]\\nMy codes Output:\\n[\"ab\",\"abc\"]\\nExpected Output:\\n[\"ab\"]\\n\\nWhy it\\'s not taking abc?\\nabc is composed of two shorter elements in an array, \\'a\\' and \\'b\\'."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "\"comprised entirely\" as you see in the question, in your case \"c\" is missing."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Why my code is Showing TLE: \nI sort the array and removed duplicates may that is the issue .. plss help me guide me how can i put some conditions so that Duplicate elements are not pushed into the array.\n\nclass Solution {\npublic:\n\n    vector<string> ans;\n\n    void help(int ind,string word,vector<string>words,int len)\n    {\n\n        int wordlen=word.length();\n        if(wordlen==0)\n        {\n            ans.push_back(words[ind]);\n            return;\n        }\n\n        for(int i=0;i<len;i++)\n        {\n            if(i!=ind)\n            {\n                int swlen=words[i].length();\n                if(wordlen>=swlen)\n                {\n                    string temp=word.substr(0,swlen);\n                    if(words[i]==temp)\n                    {\n                        // cout<<ind<<\" \"<<i<<\" \"<<word<<endl;\n                        help(ind,word.substr(swlen),words,len);\n                    }\n                }\n            }\n            \n        }\n        \n    }\n\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words)\n    {\n        int len=words.size();\n        // cout<<len<<endl;\n        for(int i=0;i<len;i++)\n        {\n            help(i,words[i],words,len);\n        }\n        std::sort(ans.begin(), ans.end());\n        ans.erase(std::unique(ans.begin(), ans.end()), ans.end());\n        return ans;    \n    }\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "try to pass arguments with reference\\n"
                    },
                    {
                        "username": "michaelmandich",
                        "content": "I\\'m getting a time limit exceeded. any  way I could fix this? it worked on 6/42\\nmy attempted solution below\\n||\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        // program will go through each word, and then see if the beginning substring is part of \\n        // another word, if it is, it will then see if there is another word (if not the same word,\\n        // that composes the remainder)\\n        // it will do so first by checking the length of the remaining letters, seeing if each word \\n        // will even fit, if so it will test the number of letters its being compared to , if it \\n        // matches then the remaining substring will be tested against all words. if it makes it \\n        // all the way to the end of the word, the word is flagged correct. if the current word  \\n        // fits,it will continue on and check all potential trees to see if one combo works. \\n    //  main function just runs through the list of words and calls the  recursive function, which is doing most of the heavy lifting.\\n    \\n    List<String> Concats = new ArrayList<String>();\\n        for(int currentWord = 0; currentWord<words.length ; currentWord++){\\n            if (isConcat(words,currentWord, words[currentWord]) == true){\\n                Concats.add(words[currentWord]);\\n            }\\n        }\\n        return Concats;\\n    }\\n\\n    // first if statement catches whether it\\'s checking itself within the list, and whether it will fit\\n    // second is to see if the word combonation in question is the end of the word, if so returns True\\n    // third sees if it fits within the current section, if not --- example: cat and cat of \"cats\" and \"cat\"\\n    public boolean isConcat(String[] listOfWords, int skip, String word){\\n        for(int i = 0; i<listOfWords.length;i++){\\n            if ((listOfWords[i]==null)||(i == skip)||(listOfWords[i].length()>word.length())){\\n                continue;\\n            }\\n            if (word.equals(listOfWords[i])){\\n                return true;\\n            }\\n            if ((word.substring(0,(listOfWords[i].length()))).equals(listOfWords[i])){\\n                if ((isConcat(listOfWords, skip, word.substring(listOfWords[i].length()))) == true){\\n                    return true;\\n                }\\n                continue; \\n            }\\n        }\\n        return false; \\n    }\\n}\\n\\n||"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Yongbi",
                        "content": "At first I think it should be a hard Trie-dict problem, then I run a dry test with \n`words = [\"cat\",\"catcatcat\"]` the expected output is: `[\"catcatcat\"]` it does consider the repeated word!!! That moment I breathed a sigh of relief. \n\nTIP! Just try a DFS for a set of given words. Everything _left_ is on you.\n`#Sets use hashing to perform look ups which makes them way faster than lists!`\n\nI'm pretty lazy to write the solution as usual. Below is not a solution, just one of approaches:\n\n```\n        def DFScheckstring(string=\"\", another argument):\n            for i in range(len(string)):                \n                 do something.. return True\n            return False\n        \n        dic, ans = set(words), []\n        for word in dic:             \n            if DFScheckstring(word): ans.append(word)\n        return ans  \n```\n"
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "[@Yongbi](/Yongbi)  Gotcha, Thank you"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Brutal7skull](/Brutal7skull) The idea of DFS is the same bro, but your approach has a better memory complexity than the slicing string. \\nNice one. But, \\n=> try to hide solution in spoil tab, cause we are discussing in \"public zone\"."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "Similar DFS \n\nAlgorithm:\n\n1. Sort it according to the length\n2. Convert words to set \n3. start iterating from last of the sorted words\n4. Make choice to take it or continue without taking it\n5. Keep count which will count the number of concatenated words\n6. Add it to result if count > 1\n       "
                    },
                    {
                        "username": "ajesk",
                        "content": "Just barely scraped by on this one... Word tree problems are still a bit of a weakness for me. Def revisiting this one when I understand it a tad better"
                    },
                    {
                        "username": "emirhanozlen",
                        "content": "A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\\n\\nInput\\nwords =\\n[\"cat\",\"catcat\"]\\nExpected\\n[\"catcat\"]\\n\\ncat does not exist twice, so isn\\'t this description a bit misleading?\\n"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think this problem should be medium."
                    },
                    {
                        "username": "ashishb97",
                        "content": "Testcase 5) \nThe word 'naturalized'  can be concatenated by words 'naturalize' and 'ed' (as per the rule).\nBut the expected array doesn't contain that word. am I missing something here? "
                    },
                    {
                        "username": "ashishb97",
                        "content": "[@Random_Letters](/Random_Letters)  But in Testcase 4)\\nit has allowed \\'bilt\\' because of \\'lt\\', \\'il\\' and \\'b\\'. (\\'i\\', \\'l\\', \\'t\\' were not in the list)"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "that would give \"naturalizeed\""
                    }
                ]
            },
            {
                "id": 1777097,
                "content": [
                    {
                        "username": "mahendrakergaurav",
                        "content": "Can someone explain what the answer should be in the last test case where its an empty string"
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Then use TreeMap, to avoid checking null when using floorEntry and ceilingEntry, add MAX_VALUE and MIN_VALUE to the tree. When get the intervals, use subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) to exclude these two extreme values."
                    },
                    {
                        "username": "PankajVP",
                        "content": "Failing on a test case:[\"a\",\"b\",\"ab\",\"abc\"]\\nMy codes Output:\\n[\"ab\",\"abc\"]\\nExpected Output:\\n[\"ab\"]\\n\\nWhy it\\'s not taking abc?\\nabc is composed of two shorter elements in an array, \\'a\\' and \\'b\\'."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "\"comprised entirely\" as you see in the question, in your case \"c\" is missing."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Why my code is Showing TLE: \nI sort the array and removed duplicates may that is the issue .. plss help me guide me how can i put some conditions so that Duplicate elements are not pushed into the array.\n\nclass Solution {\npublic:\n\n    vector<string> ans;\n\n    void help(int ind,string word,vector<string>words,int len)\n    {\n\n        int wordlen=word.length();\n        if(wordlen==0)\n        {\n            ans.push_back(words[ind]);\n            return;\n        }\n\n        for(int i=0;i<len;i++)\n        {\n            if(i!=ind)\n            {\n                int swlen=words[i].length();\n                if(wordlen>=swlen)\n                {\n                    string temp=word.substr(0,swlen);\n                    if(words[i]==temp)\n                    {\n                        // cout<<ind<<\" \"<<i<<\" \"<<word<<endl;\n                        help(ind,word.substr(swlen),words,len);\n                    }\n                }\n            }\n            \n        }\n        \n    }\n\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words)\n    {\n        int len=words.size();\n        // cout<<len<<endl;\n        for(int i=0;i<len;i++)\n        {\n            help(i,words[i],words,len);\n        }\n        std::sort(ans.begin(), ans.end());\n        ans.erase(std::unique(ans.begin(), ans.end()), ans.end());\n        return ans;    \n    }\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "try to pass arguments with reference\\n"
                    },
                    {
                        "username": "michaelmandich",
                        "content": "I\\'m getting a time limit exceeded. any  way I could fix this? it worked on 6/42\\nmy attempted solution below\\n||\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        // program will go through each word, and then see if the beginning substring is part of \\n        // another word, if it is, it will then see if there is another word (if not the same word,\\n        // that composes the remainder)\\n        // it will do so first by checking the length of the remaining letters, seeing if each word \\n        // will even fit, if so it will test the number of letters its being compared to , if it \\n        // matches then the remaining substring will be tested against all words. if it makes it \\n        // all the way to the end of the word, the word is flagged correct. if the current word  \\n        // fits,it will continue on and check all potential trees to see if one combo works. \\n    //  main function just runs through the list of words and calls the  recursive function, which is doing most of the heavy lifting.\\n    \\n    List<String> Concats = new ArrayList<String>();\\n        for(int currentWord = 0; currentWord<words.length ; currentWord++){\\n            if (isConcat(words,currentWord, words[currentWord]) == true){\\n                Concats.add(words[currentWord]);\\n            }\\n        }\\n        return Concats;\\n    }\\n\\n    // first if statement catches whether it\\'s checking itself within the list, and whether it will fit\\n    // second is to see if the word combonation in question is the end of the word, if so returns True\\n    // third sees if it fits within the current section, if not --- example: cat and cat of \"cats\" and \"cat\"\\n    public boolean isConcat(String[] listOfWords, int skip, String word){\\n        for(int i = 0; i<listOfWords.length;i++){\\n            if ((listOfWords[i]==null)||(i == skip)||(listOfWords[i].length()>word.length())){\\n                continue;\\n            }\\n            if (word.equals(listOfWords[i])){\\n                return true;\\n            }\\n            if ((word.substring(0,(listOfWords[i].length()))).equals(listOfWords[i])){\\n                if ((isConcat(listOfWords, skip, word.substring(listOfWords[i].length()))) == true){\\n                    return true;\\n                }\\n                continue; \\n            }\\n        }\\n        return false; \\n    }\\n}\\n\\n||"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Yongbi",
                        "content": "At first I think it should be a hard Trie-dict problem, then I run a dry test with \n`words = [\"cat\",\"catcatcat\"]` the expected output is: `[\"catcatcat\"]` it does consider the repeated word!!! That moment I breathed a sigh of relief. \n\nTIP! Just try a DFS for a set of given words. Everything _left_ is on you.\n`#Sets use hashing to perform look ups which makes them way faster than lists!`\n\nI'm pretty lazy to write the solution as usual. Below is not a solution, just one of approaches:\n\n```\n        def DFScheckstring(string=\"\", another argument):\n            for i in range(len(string)):                \n                 do something.. return True\n            return False\n        \n        dic, ans = set(words), []\n        for word in dic:             \n            if DFScheckstring(word): ans.append(word)\n        return ans  \n```\n"
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "[@Yongbi](/Yongbi)  Gotcha, Thank you"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Brutal7skull](/Brutal7skull) The idea of DFS is the same bro, but your approach has a better memory complexity than the slicing string. \\nNice one. But, \\n=> try to hide solution in spoil tab, cause we are discussing in \"public zone\"."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "Similar DFS \n\nAlgorithm:\n\n1. Sort it according to the length\n2. Convert words to set \n3. start iterating from last of the sorted words\n4. Make choice to take it or continue without taking it\n5. Keep count which will count the number of concatenated words\n6. Add it to result if count > 1\n       "
                    },
                    {
                        "username": "ajesk",
                        "content": "Just barely scraped by on this one... Word tree problems are still a bit of a weakness for me. Def revisiting this one when I understand it a tad better"
                    },
                    {
                        "username": "emirhanozlen",
                        "content": "A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\\n\\nInput\\nwords =\\n[\"cat\",\"catcat\"]\\nExpected\\n[\"catcat\"]\\n\\ncat does not exist twice, so isn\\'t this description a bit misleading?\\n"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think this problem should be medium."
                    },
                    {
                        "username": "ashishb97",
                        "content": "Testcase 5) \nThe word 'naturalized'  can be concatenated by words 'naturalize' and 'ed' (as per the rule).\nBut the expected array doesn't contain that word. am I missing something here? "
                    },
                    {
                        "username": "ashishb97",
                        "content": "[@Random_Letters](/Random_Letters)  But in Testcase 4)\\nit has allowed \\'bilt\\' because of \\'lt\\', \\'il\\' and \\'b\\'. (\\'i\\', \\'l\\', \\'t\\' were not in the list)"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "that would give \"naturalizeed\""
                    }
                ]
            },
            {
                "id": 1777060,
                "content": [
                    {
                        "username": "mahendrakergaurav",
                        "content": "Can someone explain what the answer should be in the last test case where its an empty string"
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Then use TreeMap, to avoid checking null when using floorEntry and ceilingEntry, add MAX_VALUE and MIN_VALUE to the tree. When get the intervals, use subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) to exclude these two extreme values."
                    },
                    {
                        "username": "PankajVP",
                        "content": "Failing on a test case:[\"a\",\"b\",\"ab\",\"abc\"]\\nMy codes Output:\\n[\"ab\",\"abc\"]\\nExpected Output:\\n[\"ab\"]\\n\\nWhy it\\'s not taking abc?\\nabc is composed of two shorter elements in an array, \\'a\\' and \\'b\\'."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "\"comprised entirely\" as you see in the question, in your case \"c\" is missing."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Why my code is Showing TLE: \nI sort the array and removed duplicates may that is the issue .. plss help me guide me how can i put some conditions so that Duplicate elements are not pushed into the array.\n\nclass Solution {\npublic:\n\n    vector<string> ans;\n\n    void help(int ind,string word,vector<string>words,int len)\n    {\n\n        int wordlen=word.length();\n        if(wordlen==0)\n        {\n            ans.push_back(words[ind]);\n            return;\n        }\n\n        for(int i=0;i<len;i++)\n        {\n            if(i!=ind)\n            {\n                int swlen=words[i].length();\n                if(wordlen>=swlen)\n                {\n                    string temp=word.substr(0,swlen);\n                    if(words[i]==temp)\n                    {\n                        // cout<<ind<<\" \"<<i<<\" \"<<word<<endl;\n                        help(ind,word.substr(swlen),words,len);\n                    }\n                }\n            }\n            \n        }\n        \n    }\n\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words)\n    {\n        int len=words.size();\n        // cout<<len<<endl;\n        for(int i=0;i<len;i++)\n        {\n            help(i,words[i],words,len);\n        }\n        std::sort(ans.begin(), ans.end());\n        ans.erase(std::unique(ans.begin(), ans.end()), ans.end());\n        return ans;    \n    }\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "try to pass arguments with reference\\n"
                    },
                    {
                        "username": "michaelmandich",
                        "content": "I\\'m getting a time limit exceeded. any  way I could fix this? it worked on 6/42\\nmy attempted solution below\\n||\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        // program will go through each word, and then see if the beginning substring is part of \\n        // another word, if it is, it will then see if there is another word (if not the same word,\\n        // that composes the remainder)\\n        // it will do so first by checking the length of the remaining letters, seeing if each word \\n        // will even fit, if so it will test the number of letters its being compared to , if it \\n        // matches then the remaining substring will be tested against all words. if it makes it \\n        // all the way to the end of the word, the word is flagged correct. if the current word  \\n        // fits,it will continue on and check all potential trees to see if one combo works. \\n    //  main function just runs through the list of words and calls the  recursive function, which is doing most of the heavy lifting.\\n    \\n    List<String> Concats = new ArrayList<String>();\\n        for(int currentWord = 0; currentWord<words.length ; currentWord++){\\n            if (isConcat(words,currentWord, words[currentWord]) == true){\\n                Concats.add(words[currentWord]);\\n            }\\n        }\\n        return Concats;\\n    }\\n\\n    // first if statement catches whether it\\'s checking itself within the list, and whether it will fit\\n    // second is to see if the word combonation in question is the end of the word, if so returns True\\n    // third sees if it fits within the current section, if not --- example: cat and cat of \"cats\" and \"cat\"\\n    public boolean isConcat(String[] listOfWords, int skip, String word){\\n        for(int i = 0; i<listOfWords.length;i++){\\n            if ((listOfWords[i]==null)||(i == skip)||(listOfWords[i].length()>word.length())){\\n                continue;\\n            }\\n            if (word.equals(listOfWords[i])){\\n                return true;\\n            }\\n            if ((word.substring(0,(listOfWords[i].length()))).equals(listOfWords[i])){\\n                if ((isConcat(listOfWords, skip, word.substring(listOfWords[i].length()))) == true){\\n                    return true;\\n                }\\n                continue; \\n            }\\n        }\\n        return false; \\n    }\\n}\\n\\n||"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Yongbi",
                        "content": "At first I think it should be a hard Trie-dict problem, then I run a dry test with \n`words = [\"cat\",\"catcatcat\"]` the expected output is: `[\"catcatcat\"]` it does consider the repeated word!!! That moment I breathed a sigh of relief. \n\nTIP! Just try a DFS for a set of given words. Everything _left_ is on you.\n`#Sets use hashing to perform look ups which makes them way faster than lists!`\n\nI'm pretty lazy to write the solution as usual. Below is not a solution, just one of approaches:\n\n```\n        def DFScheckstring(string=\"\", another argument):\n            for i in range(len(string)):                \n                 do something.. return True\n            return False\n        \n        dic, ans = set(words), []\n        for word in dic:             \n            if DFScheckstring(word): ans.append(word)\n        return ans  \n```\n"
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "[@Yongbi](/Yongbi)  Gotcha, Thank you"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Brutal7skull](/Brutal7skull) The idea of DFS is the same bro, but your approach has a better memory complexity than the slicing string. \\nNice one. But, \\n=> try to hide solution in spoil tab, cause we are discussing in \"public zone\"."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "Similar DFS \n\nAlgorithm:\n\n1. Sort it according to the length\n2. Convert words to set \n3. start iterating from last of the sorted words\n4. Make choice to take it or continue without taking it\n5. Keep count which will count the number of concatenated words\n6. Add it to result if count > 1\n       "
                    },
                    {
                        "username": "ajesk",
                        "content": "Just barely scraped by on this one... Word tree problems are still a bit of a weakness for me. Def revisiting this one when I understand it a tad better"
                    },
                    {
                        "username": "emirhanozlen",
                        "content": "A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\\n\\nInput\\nwords =\\n[\"cat\",\"catcat\"]\\nExpected\\n[\"catcat\"]\\n\\ncat does not exist twice, so isn\\'t this description a bit misleading?\\n"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think this problem should be medium."
                    },
                    {
                        "username": "ashishb97",
                        "content": "Testcase 5) \nThe word 'naturalized'  can be concatenated by words 'naturalize' and 'ed' (as per the rule).\nBut the expected array doesn't contain that word. am I missing something here? "
                    },
                    {
                        "username": "ashishb97",
                        "content": "[@Random_Letters](/Random_Letters)  But in Testcase 4)\\nit has allowed \\'bilt\\' because of \\'lt\\', \\'il\\' and \\'b\\'. (\\'i\\', \\'l\\', \\'t\\' were not in the list)"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "that would give \"naturalizeed\""
                    }
                ]
            },
            {
                "id": 1777045,
                "content": [
                    {
                        "username": "mahendrakergaurav",
                        "content": "Can someone explain what the answer should be in the last test case where its an empty string"
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Then use TreeMap, to avoid checking null when using floorEntry and ceilingEntry, add MAX_VALUE and MIN_VALUE to the tree. When get the intervals, use subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) to exclude these two extreme values."
                    },
                    {
                        "username": "PankajVP",
                        "content": "Failing on a test case:[\"a\",\"b\",\"ab\",\"abc\"]\\nMy codes Output:\\n[\"ab\",\"abc\"]\\nExpected Output:\\n[\"ab\"]\\n\\nWhy it\\'s not taking abc?\\nabc is composed of two shorter elements in an array, \\'a\\' and \\'b\\'."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "\"comprised entirely\" as you see in the question, in your case \"c\" is missing."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Why my code is Showing TLE: \nI sort the array and removed duplicates may that is the issue .. plss help me guide me how can i put some conditions so that Duplicate elements are not pushed into the array.\n\nclass Solution {\npublic:\n\n    vector<string> ans;\n\n    void help(int ind,string word,vector<string>words,int len)\n    {\n\n        int wordlen=word.length();\n        if(wordlen==0)\n        {\n            ans.push_back(words[ind]);\n            return;\n        }\n\n        for(int i=0;i<len;i++)\n        {\n            if(i!=ind)\n            {\n                int swlen=words[i].length();\n                if(wordlen>=swlen)\n                {\n                    string temp=word.substr(0,swlen);\n                    if(words[i]==temp)\n                    {\n                        // cout<<ind<<\" \"<<i<<\" \"<<word<<endl;\n                        help(ind,word.substr(swlen),words,len);\n                    }\n                }\n            }\n            \n        }\n        \n    }\n\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words)\n    {\n        int len=words.size();\n        // cout<<len<<endl;\n        for(int i=0;i<len;i++)\n        {\n            help(i,words[i],words,len);\n        }\n        std::sort(ans.begin(), ans.end());\n        ans.erase(std::unique(ans.begin(), ans.end()), ans.end());\n        return ans;    \n    }\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "try to pass arguments with reference\\n"
                    },
                    {
                        "username": "michaelmandich",
                        "content": "I\\'m getting a time limit exceeded. any  way I could fix this? it worked on 6/42\\nmy attempted solution below\\n||\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        // program will go through each word, and then see if the beginning substring is part of \\n        // another word, if it is, it will then see if there is another word (if not the same word,\\n        // that composes the remainder)\\n        // it will do so first by checking the length of the remaining letters, seeing if each word \\n        // will even fit, if so it will test the number of letters its being compared to , if it \\n        // matches then the remaining substring will be tested against all words. if it makes it \\n        // all the way to the end of the word, the word is flagged correct. if the current word  \\n        // fits,it will continue on and check all potential trees to see if one combo works. \\n    //  main function just runs through the list of words and calls the  recursive function, which is doing most of the heavy lifting.\\n    \\n    List<String> Concats = new ArrayList<String>();\\n        for(int currentWord = 0; currentWord<words.length ; currentWord++){\\n            if (isConcat(words,currentWord, words[currentWord]) == true){\\n                Concats.add(words[currentWord]);\\n            }\\n        }\\n        return Concats;\\n    }\\n\\n    // first if statement catches whether it\\'s checking itself within the list, and whether it will fit\\n    // second is to see if the word combonation in question is the end of the word, if so returns True\\n    // third sees if it fits within the current section, if not --- example: cat and cat of \"cats\" and \"cat\"\\n    public boolean isConcat(String[] listOfWords, int skip, String word){\\n        for(int i = 0; i<listOfWords.length;i++){\\n            if ((listOfWords[i]==null)||(i == skip)||(listOfWords[i].length()>word.length())){\\n                continue;\\n            }\\n            if (word.equals(listOfWords[i])){\\n                return true;\\n            }\\n            if ((word.substring(0,(listOfWords[i].length()))).equals(listOfWords[i])){\\n                if ((isConcat(listOfWords, skip, word.substring(listOfWords[i].length()))) == true){\\n                    return true;\\n                }\\n                continue; \\n            }\\n        }\\n        return false; \\n    }\\n}\\n\\n||"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Yongbi",
                        "content": "At first I think it should be a hard Trie-dict problem, then I run a dry test with \n`words = [\"cat\",\"catcatcat\"]` the expected output is: `[\"catcatcat\"]` it does consider the repeated word!!! That moment I breathed a sigh of relief. \n\nTIP! Just try a DFS for a set of given words. Everything _left_ is on you.\n`#Sets use hashing to perform look ups which makes them way faster than lists!`\n\nI'm pretty lazy to write the solution as usual. Below is not a solution, just one of approaches:\n\n```\n        def DFScheckstring(string=\"\", another argument):\n            for i in range(len(string)):                \n                 do something.. return True\n            return False\n        \n        dic, ans = set(words), []\n        for word in dic:             \n            if DFScheckstring(word): ans.append(word)\n        return ans  \n```\n"
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "[@Yongbi](/Yongbi)  Gotcha, Thank you"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Brutal7skull](/Brutal7skull) The idea of DFS is the same bro, but your approach has a better memory complexity than the slicing string. \\nNice one. But, \\n=> try to hide solution in spoil tab, cause we are discussing in \"public zone\"."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "Similar DFS \n\nAlgorithm:\n\n1. Sort it according to the length\n2. Convert words to set \n3. start iterating from last of the sorted words\n4. Make choice to take it or continue without taking it\n5. Keep count which will count the number of concatenated words\n6. Add it to result if count > 1\n       "
                    },
                    {
                        "username": "ajesk",
                        "content": "Just barely scraped by on this one... Word tree problems are still a bit of a weakness for me. Def revisiting this one when I understand it a tad better"
                    },
                    {
                        "username": "emirhanozlen",
                        "content": "A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\\n\\nInput\\nwords =\\n[\"cat\",\"catcat\"]\\nExpected\\n[\"catcat\"]\\n\\ncat does not exist twice, so isn\\'t this description a bit misleading?\\n"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think this problem should be medium."
                    },
                    {
                        "username": "ashishb97",
                        "content": "Testcase 5) \nThe word 'naturalized'  can be concatenated by words 'naturalize' and 'ed' (as per the rule).\nBut the expected array doesn't contain that word. am I missing something here? "
                    },
                    {
                        "username": "ashishb97",
                        "content": "[@Random_Letters](/Random_Letters)  But in Testcase 4)\\nit has allowed \\'bilt\\' because of \\'lt\\', \\'il\\' and \\'b\\'. (\\'i\\', \\'l\\', \\'t\\' were not in the list)"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "that would give \"naturalizeed\""
                    }
                ]
            },
            {
                "id": 1777042,
                "content": [
                    {
                        "username": "mahendrakergaurav",
                        "content": "Can someone explain what the answer should be in the last test case where its an empty string"
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Then use TreeMap, to avoid checking null when using floorEntry and ceilingEntry, add MAX_VALUE and MIN_VALUE to the tree. When get the intervals, use subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) to exclude these two extreme values."
                    },
                    {
                        "username": "PankajVP",
                        "content": "Failing on a test case:[\"a\",\"b\",\"ab\",\"abc\"]\\nMy codes Output:\\n[\"ab\",\"abc\"]\\nExpected Output:\\n[\"ab\"]\\n\\nWhy it\\'s not taking abc?\\nabc is composed of two shorter elements in an array, \\'a\\' and \\'b\\'."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "\"comprised entirely\" as you see in the question, in your case \"c\" is missing."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Why my code is Showing TLE: \nI sort the array and removed duplicates may that is the issue .. plss help me guide me how can i put some conditions so that Duplicate elements are not pushed into the array.\n\nclass Solution {\npublic:\n\n    vector<string> ans;\n\n    void help(int ind,string word,vector<string>words,int len)\n    {\n\n        int wordlen=word.length();\n        if(wordlen==0)\n        {\n            ans.push_back(words[ind]);\n            return;\n        }\n\n        for(int i=0;i<len;i++)\n        {\n            if(i!=ind)\n            {\n                int swlen=words[i].length();\n                if(wordlen>=swlen)\n                {\n                    string temp=word.substr(0,swlen);\n                    if(words[i]==temp)\n                    {\n                        // cout<<ind<<\" \"<<i<<\" \"<<word<<endl;\n                        help(ind,word.substr(swlen),words,len);\n                    }\n                }\n            }\n            \n        }\n        \n    }\n\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words)\n    {\n        int len=words.size();\n        // cout<<len<<endl;\n        for(int i=0;i<len;i++)\n        {\n            help(i,words[i],words,len);\n        }\n        std::sort(ans.begin(), ans.end());\n        ans.erase(std::unique(ans.begin(), ans.end()), ans.end());\n        return ans;    \n    }\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "try to pass arguments with reference\\n"
                    },
                    {
                        "username": "michaelmandich",
                        "content": "I\\'m getting a time limit exceeded. any  way I could fix this? it worked on 6/42\\nmy attempted solution below\\n||\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        // program will go through each word, and then see if the beginning substring is part of \\n        // another word, if it is, it will then see if there is another word (if not the same word,\\n        // that composes the remainder)\\n        // it will do so first by checking the length of the remaining letters, seeing if each word \\n        // will even fit, if so it will test the number of letters its being compared to , if it \\n        // matches then the remaining substring will be tested against all words. if it makes it \\n        // all the way to the end of the word, the word is flagged correct. if the current word  \\n        // fits,it will continue on and check all potential trees to see if one combo works. \\n    //  main function just runs through the list of words and calls the  recursive function, which is doing most of the heavy lifting.\\n    \\n    List<String> Concats = new ArrayList<String>();\\n        for(int currentWord = 0; currentWord<words.length ; currentWord++){\\n            if (isConcat(words,currentWord, words[currentWord]) == true){\\n                Concats.add(words[currentWord]);\\n            }\\n        }\\n        return Concats;\\n    }\\n\\n    // first if statement catches whether it\\'s checking itself within the list, and whether it will fit\\n    // second is to see if the word combonation in question is the end of the word, if so returns True\\n    // third sees if it fits within the current section, if not --- example: cat and cat of \"cats\" and \"cat\"\\n    public boolean isConcat(String[] listOfWords, int skip, String word){\\n        for(int i = 0; i<listOfWords.length;i++){\\n            if ((listOfWords[i]==null)||(i == skip)||(listOfWords[i].length()>word.length())){\\n                continue;\\n            }\\n            if (word.equals(listOfWords[i])){\\n                return true;\\n            }\\n            if ((word.substring(0,(listOfWords[i].length()))).equals(listOfWords[i])){\\n                if ((isConcat(listOfWords, skip, word.substring(listOfWords[i].length()))) == true){\\n                    return true;\\n                }\\n                continue; \\n            }\\n        }\\n        return false; \\n    }\\n}\\n\\n||"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Yongbi",
                        "content": "At first I think it should be a hard Trie-dict problem, then I run a dry test with \n`words = [\"cat\",\"catcatcat\"]` the expected output is: `[\"catcatcat\"]` it does consider the repeated word!!! That moment I breathed a sigh of relief. \n\nTIP! Just try a DFS for a set of given words. Everything _left_ is on you.\n`#Sets use hashing to perform look ups which makes them way faster than lists!`\n\nI'm pretty lazy to write the solution as usual. Below is not a solution, just one of approaches:\n\n```\n        def DFScheckstring(string=\"\", another argument):\n            for i in range(len(string)):                \n                 do something.. return True\n            return False\n        \n        dic, ans = set(words), []\n        for word in dic:             \n            if DFScheckstring(word): ans.append(word)\n        return ans  \n```\n"
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "[@Yongbi](/Yongbi)  Gotcha, Thank you"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Brutal7skull](/Brutal7skull) The idea of DFS is the same bro, but your approach has a better memory complexity than the slicing string. \\nNice one. But, \\n=> try to hide solution in spoil tab, cause we are discussing in \"public zone\"."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "Similar DFS \n\nAlgorithm:\n\n1. Sort it according to the length\n2. Convert words to set \n3. start iterating from last of the sorted words\n4. Make choice to take it or continue without taking it\n5. Keep count which will count the number of concatenated words\n6. Add it to result if count > 1\n       "
                    },
                    {
                        "username": "ajesk",
                        "content": "Just barely scraped by on this one... Word tree problems are still a bit of a weakness for me. Def revisiting this one when I understand it a tad better"
                    },
                    {
                        "username": "emirhanozlen",
                        "content": "A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\\n\\nInput\\nwords =\\n[\"cat\",\"catcat\"]\\nExpected\\n[\"catcat\"]\\n\\ncat does not exist twice, so isn\\'t this description a bit misleading?\\n"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think this problem should be medium."
                    },
                    {
                        "username": "ashishb97",
                        "content": "Testcase 5) \nThe word 'naturalized'  can be concatenated by words 'naturalize' and 'ed' (as per the rule).\nBut the expected array doesn't contain that word. am I missing something here? "
                    },
                    {
                        "username": "ashishb97",
                        "content": "[@Random_Letters](/Random_Letters)  But in Testcase 4)\\nit has allowed \\'bilt\\' because of \\'lt\\', \\'il\\' and \\'b\\'. (\\'i\\', \\'l\\', \\'t\\' were not in the list)"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "that would give \"naturalizeed\""
                    }
                ]
            },
            {
                "id": 1776937,
                "content": [
                    {
                        "username": "mahendrakergaurav",
                        "content": "Can someone explain what the answer should be in the last test case where its an empty string"
                    },
                    {
                        "username": "XiaoChow",
                        "content": "Then use TreeMap, to avoid checking null when using floorEntry and ceilingEntry, add MAX_VALUE and MIN_VALUE to the tree. When get the intervals, use subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) to exclude these two extreme values."
                    },
                    {
                        "username": "PankajVP",
                        "content": "Failing on a test case:[\"a\",\"b\",\"ab\",\"abc\"]\\nMy codes Output:\\n[\"ab\",\"abc\"]\\nExpected Output:\\n[\"ab\"]\\n\\nWhy it\\'s not taking abc?\\nabc is composed of two shorter elements in an array, \\'a\\' and \\'b\\'."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "\"comprised entirely\" as you see in the question, in your case \"c\" is missing."
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "Why my code is Showing TLE: \nI sort the array and removed duplicates may that is the issue .. plss help me guide me how can i put some conditions so that Duplicate elements are not pushed into the array.\n\nclass Solution {\npublic:\n\n    vector<string> ans;\n\n    void help(int ind,string word,vector<string>words,int len)\n    {\n\n        int wordlen=word.length();\n        if(wordlen==0)\n        {\n            ans.push_back(words[ind]);\n            return;\n        }\n\n        for(int i=0;i<len;i++)\n        {\n            if(i!=ind)\n            {\n                int swlen=words[i].length();\n                if(wordlen>=swlen)\n                {\n                    string temp=word.substr(0,swlen);\n                    if(words[i]==temp)\n                    {\n                        // cout<<ind<<\" \"<<i<<\" \"<<word<<endl;\n                        help(ind,word.substr(swlen),words,len);\n                    }\n                }\n            }\n            \n        }\n        \n    }\n\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words)\n    {\n        int len=words.size();\n        // cout<<len<<endl;\n        for(int i=0;i<len;i++)\n        {\n            help(i,words[i],words,len);\n        }\n        std::sort(ans.begin(), ans.end());\n        ans.erase(std::unique(ans.begin(), ans.end()), ans.end());\n        return ans;    \n    }\n};"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Akash_Yadav25",
                        "content": "try to pass arguments with reference\\n"
                    },
                    {
                        "username": "michaelmandich",
                        "content": "I\\'m getting a time limit exceeded. any  way I could fix this? it worked on 6/42\\nmy attempted solution below\\n||\\nclass Solution {\\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\\n        // program will go through each word, and then see if the beginning substring is part of \\n        // another word, if it is, it will then see if there is another word (if not the same word,\\n        // that composes the remainder)\\n        // it will do so first by checking the length of the remaining letters, seeing if each word \\n        // will even fit, if so it will test the number of letters its being compared to , if it \\n        // matches then the remaining substring will be tested against all words. if it makes it \\n        // all the way to the end of the word, the word is flagged correct. if the current word  \\n        // fits,it will continue on and check all potential trees to see if one combo works. \\n    //  main function just runs through the list of words and calls the  recursive function, which is doing most of the heavy lifting.\\n    \\n    List<String> Concats = new ArrayList<String>();\\n        for(int currentWord = 0; currentWord<words.length ; currentWord++){\\n            if (isConcat(words,currentWord, words[currentWord]) == true){\\n                Concats.add(words[currentWord]);\\n            }\\n        }\\n        return Concats;\\n    }\\n\\n    // first if statement catches whether it\\'s checking itself within the list, and whether it will fit\\n    // second is to see if the word combonation in question is the end of the word, if so returns True\\n    // third sees if it fits within the current section, if not --- example: cat and cat of \"cats\" and \"cat\"\\n    public boolean isConcat(String[] listOfWords, int skip, String word){\\n        for(int i = 0; i<listOfWords.length;i++){\\n            if ((listOfWords[i]==null)||(i == skip)||(listOfWords[i].length()>word.length())){\\n                continue;\\n            }\\n            if (word.equals(listOfWords[i])){\\n                return true;\\n            }\\n            if ((word.substring(0,(listOfWords[i].length()))).equals(listOfWords[i])){\\n                if ((isConcat(listOfWords, skip, word.substring(listOfWords[i].length()))) == true){\\n                    return true;\\n                }\\n                continue; \\n            }\\n        }\\n        return false; \\n    }\\n}\\n\\n||"
                    },
                    {
                        "username": "Yongbi",
                        "content": "unordered_set is faster than look up in list ?! "
                    },
                    {
                        "username": "Yongbi",
                        "content": "At first I think it should be a hard Trie-dict problem, then I run a dry test with \n`words = [\"cat\",\"catcatcat\"]` the expected output is: `[\"catcatcat\"]` it does consider the repeated word!!! That moment I breathed a sigh of relief. \n\nTIP! Just try a DFS for a set of given words. Everything _left_ is on you.\n`#Sets use hashing to perform look ups which makes them way faster than lists!`\n\nI'm pretty lazy to write the solution as usual. Below is not a solution, just one of approaches:\n\n```\n        def DFScheckstring(string=\"\", another argument):\n            for i in range(len(string)):                \n                 do something.. return True\n            return False\n        \n        dic, ans = set(words), []\n        for word in dic:             \n            if DFScheckstring(word): ans.append(word)\n        return ans  \n```\n"
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "[@Yongbi](/Yongbi)  Gotcha, Thank you"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Brutal7skull](/Brutal7skull) The idea of DFS is the same bro, but your approach has a better memory complexity than the slicing string. \\nNice one. But, \\n=> try to hide solution in spoil tab, cause we are discussing in \"public zone\"."
                    },
                    {
                        "username": "Brutal7skull",
                        "content": "Similar DFS \n\nAlgorithm:\n\n1. Sort it according to the length\n2. Convert words to set \n3. start iterating from last of the sorted words\n4. Make choice to take it or continue without taking it\n5. Keep count which will count the number of concatenated words\n6. Add it to result if count > 1\n       "
                    },
                    {
                        "username": "ajesk",
                        "content": "Just barely scraped by on this one... Word tree problems are still a bit of a weakness for me. Def revisiting this one when I understand it a tad better"
                    },
                    {
                        "username": "emirhanozlen",
                        "content": "A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\\n\\nInput\\nwords =\\n[\"cat\",\"catcat\"]\\nExpected\\n[\"catcat\"]\\n\\ncat does not exist twice, so isn\\'t this description a bit misleading?\\n"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think this problem should be medium."
                    },
                    {
                        "username": "ashishb97",
                        "content": "Testcase 5) \nThe word 'naturalized'  can be concatenated by words 'naturalize' and 'ed' (as per the rule).\nBut the expected array doesn't contain that word. am I missing something here? "
                    },
                    {
                        "username": "ashishb97",
                        "content": "[@Random_Letters](/Random_Letters)  But in Testcase 4)\\nit has allowed \\'bilt\\' because of \\'lt\\', \\'il\\' and \\'b\\'. (\\'i\\', \\'l\\', \\'t\\' were not in the list)"
                    },
                    {
                        "username": "Random_Letters",
                        "content": "that would give \"naturalizeed\""
                    }
                ]
            },
            {
                "id": 1776928,
                "content": [
                    {
                        "username": "Dynamo_360",
                        "content": "class Solution {\\npublic:\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> children;\\n        bool isWord;\\n    };\\n\\n    TrieNode* root = new TrieNode();\\n\\n    void insert(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node->children.count(c)) {\\n                node->children[c] = new TrieNode();\\n            }\\n            node = node->children[c];\\n        }\\n        node->isWord = true;\\n    }\\n\\n    bool check(string word, int start, int count, TrieNode* node) {\\n        if (start == word.size()) {\\n            return count >= 2;\\n        }\\n        if (!node->children.count(word[start])) {\\n            return false;\\n        }\\n        TrieNode* next = node->children[word[start]];\\n        if (next->isWord && check(word, start + 1, count + 1, root)) {\\n            return true;\\n        }\\n        return check(word, start + 1, count, next);\\n    }\\n\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for (string word : words) {\\n            insert(word);\\n        }\\n        vector<string> result;\\n        for (string word : words) {\\n            if (check(word, 0, 0, root)) {\\n                result.push_back(word);\\n            }\\n        }\\n        return result;\\n    }\\n};\\nPARTIALLY ACCEPTED CAN ANYONE HELP ME WITH A LOGIC? "
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See my solution  https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "To visualize, go to:\\nhttps://www.cs.usfca.edu/~galles/visualization/Trie.html\\n\\nGive id \\'f1\\' to input box, \\'f2\\' to insert button, and \\'f3\\' to skip forward button.\\nTry following in console:\\n```js\\nfunction insert(s) {\\n    setTimeout(() => {\\n        document.getElementById(\"f1\").value=s;\\n        document.getElementById(\"f2\").click();\\n        document.getElementById(\"f3\").click();\\n    }, 1000);\\n\\n}\\n\\narr = [] // your input array\\n\\narr.forEach(insert\\n```"
                    },
                    {
                        "username": "godshiva",
                        "content": "I made the silliest mistake coding my TRIE.  I initially thought it was going to require UNIQUE words, so I stored the index of the completed words as a number or 0 if there was none, apparently forgetting that 0 is a valid index lol\\nALTHOUGH, when I realized words could repeat, a TRUE/FALSE made more sense. "
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "The question doesn\\'t mention that the order of the output matters."
                    },
                    {
                        "username": "vylv",
                        "content": "I am not have high beats rate on this problem but I feel like it\\'s not hard to find a solution to but I\\'ve run into a lot of medium problems and can\\'t find an answer."
                    },
                    {
                        "username": "tejasX",
                        "content": "Not really a hard one.\\nA basic DP."
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Is it just me or the test cases for this problem is not setup correctly? I pretty much passed with no memoizing or dp. A plain simple DFS and a set checking if a substring exists before each recursive call worked for me"
                    },
                    {
                        "username": "senkoustav72",
                        "content": "It is not accurate to mark this as a hard problem if the code is working with a unordered_set and doing a simple dfs over all the words. "
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Easy to follow and good explanation! \\nyoutube.com/watch?v=PY1LSBx-cNs"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    }
                ]
            },
            {
                "id": 1776892,
                "content": [
                    {
                        "username": "Dynamo_360",
                        "content": "class Solution {\\npublic:\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> children;\\n        bool isWord;\\n    };\\n\\n    TrieNode* root = new TrieNode();\\n\\n    void insert(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node->children.count(c)) {\\n                node->children[c] = new TrieNode();\\n            }\\n            node = node->children[c];\\n        }\\n        node->isWord = true;\\n    }\\n\\n    bool check(string word, int start, int count, TrieNode* node) {\\n        if (start == word.size()) {\\n            return count >= 2;\\n        }\\n        if (!node->children.count(word[start])) {\\n            return false;\\n        }\\n        TrieNode* next = node->children[word[start]];\\n        if (next->isWord && check(word, start + 1, count + 1, root)) {\\n            return true;\\n        }\\n        return check(word, start + 1, count, next);\\n    }\\n\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for (string word : words) {\\n            insert(word);\\n        }\\n        vector<string> result;\\n        for (string word : words) {\\n            if (check(word, 0, 0, root)) {\\n                result.push_back(word);\\n            }\\n        }\\n        return result;\\n    }\\n};\\nPARTIALLY ACCEPTED CAN ANYONE HELP ME WITH A LOGIC? "
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See my solution  https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "To visualize, go to:\\nhttps://www.cs.usfca.edu/~galles/visualization/Trie.html\\n\\nGive id \\'f1\\' to input box, \\'f2\\' to insert button, and \\'f3\\' to skip forward button.\\nTry following in console:\\n```js\\nfunction insert(s) {\\n    setTimeout(() => {\\n        document.getElementById(\"f1\").value=s;\\n        document.getElementById(\"f2\").click();\\n        document.getElementById(\"f3\").click();\\n    }, 1000);\\n\\n}\\n\\narr = [] // your input array\\n\\narr.forEach(insert\\n```"
                    },
                    {
                        "username": "godshiva",
                        "content": "I made the silliest mistake coding my TRIE.  I initially thought it was going to require UNIQUE words, so I stored the index of the completed words as a number or 0 if there was none, apparently forgetting that 0 is a valid index lol\\nALTHOUGH, when I realized words could repeat, a TRUE/FALSE made more sense. "
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "The question doesn\\'t mention that the order of the output matters."
                    },
                    {
                        "username": "vylv",
                        "content": "I am not have high beats rate on this problem but I feel like it\\'s not hard to find a solution to but I\\'ve run into a lot of medium problems and can\\'t find an answer."
                    },
                    {
                        "username": "tejasX",
                        "content": "Not really a hard one.\\nA basic DP."
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Is it just me or the test cases for this problem is not setup correctly? I pretty much passed with no memoizing or dp. A plain simple DFS and a set checking if a substring exists before each recursive call worked for me"
                    },
                    {
                        "username": "senkoustav72",
                        "content": "It is not accurate to mark this as a hard problem if the code is working with a unordered_set and doing a simple dfs over all the words. "
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Easy to follow and good explanation! \\nyoutube.com/watch?v=PY1LSBx-cNs"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    }
                ]
            },
            {
                "id": 1776867,
                "content": [
                    {
                        "username": "Dynamo_360",
                        "content": "class Solution {\\npublic:\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> children;\\n        bool isWord;\\n    };\\n\\n    TrieNode* root = new TrieNode();\\n\\n    void insert(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node->children.count(c)) {\\n                node->children[c] = new TrieNode();\\n            }\\n            node = node->children[c];\\n        }\\n        node->isWord = true;\\n    }\\n\\n    bool check(string word, int start, int count, TrieNode* node) {\\n        if (start == word.size()) {\\n            return count >= 2;\\n        }\\n        if (!node->children.count(word[start])) {\\n            return false;\\n        }\\n        TrieNode* next = node->children[word[start]];\\n        if (next->isWord && check(word, start + 1, count + 1, root)) {\\n            return true;\\n        }\\n        return check(word, start + 1, count, next);\\n    }\\n\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for (string word : words) {\\n            insert(word);\\n        }\\n        vector<string> result;\\n        for (string word : words) {\\n            if (check(word, 0, 0, root)) {\\n                result.push_back(word);\\n            }\\n        }\\n        return result;\\n    }\\n};\\nPARTIALLY ACCEPTED CAN ANYONE HELP ME WITH A LOGIC? "
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See my solution  https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "To visualize, go to:\\nhttps://www.cs.usfca.edu/~galles/visualization/Trie.html\\n\\nGive id \\'f1\\' to input box, \\'f2\\' to insert button, and \\'f3\\' to skip forward button.\\nTry following in console:\\n```js\\nfunction insert(s) {\\n    setTimeout(() => {\\n        document.getElementById(\"f1\").value=s;\\n        document.getElementById(\"f2\").click();\\n        document.getElementById(\"f3\").click();\\n    }, 1000);\\n\\n}\\n\\narr = [] // your input array\\n\\narr.forEach(insert\\n```"
                    },
                    {
                        "username": "godshiva",
                        "content": "I made the silliest mistake coding my TRIE.  I initially thought it was going to require UNIQUE words, so I stored the index of the completed words as a number or 0 if there was none, apparently forgetting that 0 is a valid index lol\\nALTHOUGH, when I realized words could repeat, a TRUE/FALSE made more sense. "
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "The question doesn\\'t mention that the order of the output matters."
                    },
                    {
                        "username": "vylv",
                        "content": "I am not have high beats rate on this problem but I feel like it\\'s not hard to find a solution to but I\\'ve run into a lot of medium problems and can\\'t find an answer."
                    },
                    {
                        "username": "tejasX",
                        "content": "Not really a hard one.\\nA basic DP."
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Is it just me or the test cases for this problem is not setup correctly? I pretty much passed with no memoizing or dp. A plain simple DFS and a set checking if a substring exists before each recursive call worked for me"
                    },
                    {
                        "username": "senkoustav72",
                        "content": "It is not accurate to mark this as a hard problem if the code is working with a unordered_set and doing a simple dfs over all the words. "
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Easy to follow and good explanation! \\nyoutube.com/watch?v=PY1LSBx-cNs"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    }
                ]
            },
            {
                "id": 1776855,
                "content": [
                    {
                        "username": "Dynamo_360",
                        "content": "class Solution {\\npublic:\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> children;\\n        bool isWord;\\n    };\\n\\n    TrieNode* root = new TrieNode();\\n\\n    void insert(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node->children.count(c)) {\\n                node->children[c] = new TrieNode();\\n            }\\n            node = node->children[c];\\n        }\\n        node->isWord = true;\\n    }\\n\\n    bool check(string word, int start, int count, TrieNode* node) {\\n        if (start == word.size()) {\\n            return count >= 2;\\n        }\\n        if (!node->children.count(word[start])) {\\n            return false;\\n        }\\n        TrieNode* next = node->children[word[start]];\\n        if (next->isWord && check(word, start + 1, count + 1, root)) {\\n            return true;\\n        }\\n        return check(word, start + 1, count, next);\\n    }\\n\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for (string word : words) {\\n            insert(word);\\n        }\\n        vector<string> result;\\n        for (string word : words) {\\n            if (check(word, 0, 0, root)) {\\n                result.push_back(word);\\n            }\\n        }\\n        return result;\\n    }\\n};\\nPARTIALLY ACCEPTED CAN ANYONE HELP ME WITH A LOGIC? "
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See my solution  https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "To visualize, go to:\\nhttps://www.cs.usfca.edu/~galles/visualization/Trie.html\\n\\nGive id \\'f1\\' to input box, \\'f2\\' to insert button, and \\'f3\\' to skip forward button.\\nTry following in console:\\n```js\\nfunction insert(s) {\\n    setTimeout(() => {\\n        document.getElementById(\"f1\").value=s;\\n        document.getElementById(\"f2\").click();\\n        document.getElementById(\"f3\").click();\\n    }, 1000);\\n\\n}\\n\\narr = [] // your input array\\n\\narr.forEach(insert\\n```"
                    },
                    {
                        "username": "godshiva",
                        "content": "I made the silliest mistake coding my TRIE.  I initially thought it was going to require UNIQUE words, so I stored the index of the completed words as a number or 0 if there was none, apparently forgetting that 0 is a valid index lol\\nALTHOUGH, when I realized words could repeat, a TRUE/FALSE made more sense. "
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "The question doesn\\'t mention that the order of the output matters."
                    },
                    {
                        "username": "vylv",
                        "content": "I am not have high beats rate on this problem but I feel like it\\'s not hard to find a solution to but I\\'ve run into a lot of medium problems and can\\'t find an answer."
                    },
                    {
                        "username": "tejasX",
                        "content": "Not really a hard one.\\nA basic DP."
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Is it just me or the test cases for this problem is not setup correctly? I pretty much passed with no memoizing or dp. A plain simple DFS and a set checking if a substring exists before each recursive call worked for me"
                    },
                    {
                        "username": "senkoustav72",
                        "content": "It is not accurate to mark this as a hard problem if the code is working with a unordered_set and doing a simple dfs over all the words. "
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Easy to follow and good explanation! \\nyoutube.com/watch?v=PY1LSBx-cNs"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    }
                ]
            },
            {
                "id": 1776793,
                "content": [
                    {
                        "username": "Dynamo_360",
                        "content": "class Solution {\\npublic:\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> children;\\n        bool isWord;\\n    };\\n\\n    TrieNode* root = new TrieNode();\\n\\n    void insert(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node->children.count(c)) {\\n                node->children[c] = new TrieNode();\\n            }\\n            node = node->children[c];\\n        }\\n        node->isWord = true;\\n    }\\n\\n    bool check(string word, int start, int count, TrieNode* node) {\\n        if (start == word.size()) {\\n            return count >= 2;\\n        }\\n        if (!node->children.count(word[start])) {\\n            return false;\\n        }\\n        TrieNode* next = node->children[word[start]];\\n        if (next->isWord && check(word, start + 1, count + 1, root)) {\\n            return true;\\n        }\\n        return check(word, start + 1, count, next);\\n    }\\n\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for (string word : words) {\\n            insert(word);\\n        }\\n        vector<string> result;\\n        for (string word : words) {\\n            if (check(word, 0, 0, root)) {\\n                result.push_back(word);\\n            }\\n        }\\n        return result;\\n    }\\n};\\nPARTIALLY ACCEPTED CAN ANYONE HELP ME WITH A LOGIC? "
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See my solution  https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "To visualize, go to:\\nhttps://www.cs.usfca.edu/~galles/visualization/Trie.html\\n\\nGive id \\'f1\\' to input box, \\'f2\\' to insert button, and \\'f3\\' to skip forward button.\\nTry following in console:\\n```js\\nfunction insert(s) {\\n    setTimeout(() => {\\n        document.getElementById(\"f1\").value=s;\\n        document.getElementById(\"f2\").click();\\n        document.getElementById(\"f3\").click();\\n    }, 1000);\\n\\n}\\n\\narr = [] // your input array\\n\\narr.forEach(insert\\n```"
                    },
                    {
                        "username": "godshiva",
                        "content": "I made the silliest mistake coding my TRIE.  I initially thought it was going to require UNIQUE words, so I stored the index of the completed words as a number or 0 if there was none, apparently forgetting that 0 is a valid index lol\\nALTHOUGH, when I realized words could repeat, a TRUE/FALSE made more sense. "
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "The question doesn\\'t mention that the order of the output matters."
                    },
                    {
                        "username": "vylv",
                        "content": "I am not have high beats rate on this problem but I feel like it\\'s not hard to find a solution to but I\\'ve run into a lot of medium problems and can\\'t find an answer."
                    },
                    {
                        "username": "tejasX",
                        "content": "Not really a hard one.\\nA basic DP."
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Is it just me or the test cases for this problem is not setup correctly? I pretty much passed with no memoizing or dp. A plain simple DFS and a set checking if a substring exists before each recursive call worked for me"
                    },
                    {
                        "username": "senkoustav72",
                        "content": "It is not accurate to mark this as a hard problem if the code is working with a unordered_set and doing a simple dfs over all the words. "
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Easy to follow and good explanation! \\nyoutube.com/watch?v=PY1LSBx-cNs"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    }
                ]
            },
            {
                "id": 1776665,
                "content": [
                    {
                        "username": "Dynamo_360",
                        "content": "class Solution {\\npublic:\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> children;\\n        bool isWord;\\n    };\\n\\n    TrieNode* root = new TrieNode();\\n\\n    void insert(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node->children.count(c)) {\\n                node->children[c] = new TrieNode();\\n            }\\n            node = node->children[c];\\n        }\\n        node->isWord = true;\\n    }\\n\\n    bool check(string word, int start, int count, TrieNode* node) {\\n        if (start == word.size()) {\\n            return count >= 2;\\n        }\\n        if (!node->children.count(word[start])) {\\n            return false;\\n        }\\n        TrieNode* next = node->children[word[start]];\\n        if (next->isWord && check(word, start + 1, count + 1, root)) {\\n            return true;\\n        }\\n        return check(word, start + 1, count, next);\\n    }\\n\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for (string word : words) {\\n            insert(word);\\n        }\\n        vector<string> result;\\n        for (string word : words) {\\n            if (check(word, 0, 0, root)) {\\n                result.push_back(word);\\n            }\\n        }\\n        return result;\\n    }\\n};\\nPARTIALLY ACCEPTED CAN ANYONE HELP ME WITH A LOGIC? "
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See my solution  https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "To visualize, go to:\\nhttps://www.cs.usfca.edu/~galles/visualization/Trie.html\\n\\nGive id \\'f1\\' to input box, \\'f2\\' to insert button, and \\'f3\\' to skip forward button.\\nTry following in console:\\n```js\\nfunction insert(s) {\\n    setTimeout(() => {\\n        document.getElementById(\"f1\").value=s;\\n        document.getElementById(\"f2\").click();\\n        document.getElementById(\"f3\").click();\\n    }, 1000);\\n\\n}\\n\\narr = [] // your input array\\n\\narr.forEach(insert\\n```"
                    },
                    {
                        "username": "godshiva",
                        "content": "I made the silliest mistake coding my TRIE.  I initially thought it was going to require UNIQUE words, so I stored the index of the completed words as a number or 0 if there was none, apparently forgetting that 0 is a valid index lol\\nALTHOUGH, when I realized words could repeat, a TRUE/FALSE made more sense. "
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "The question doesn\\'t mention that the order of the output matters."
                    },
                    {
                        "username": "vylv",
                        "content": "I am not have high beats rate on this problem but I feel like it\\'s not hard to find a solution to but I\\'ve run into a lot of medium problems and can\\'t find an answer."
                    },
                    {
                        "username": "tejasX",
                        "content": "Not really a hard one.\\nA basic DP."
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Is it just me or the test cases for this problem is not setup correctly? I pretty much passed with no memoizing or dp. A plain simple DFS and a set checking if a substring exists before each recursive call worked for me"
                    },
                    {
                        "username": "senkoustav72",
                        "content": "It is not accurate to mark this as a hard problem if the code is working with a unordered_set and doing a simple dfs over all the words. "
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Easy to follow and good explanation! \\nyoutube.com/watch?v=PY1LSBx-cNs"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    }
                ]
            },
            {
                "id": 1776658,
                "content": [
                    {
                        "username": "Dynamo_360",
                        "content": "class Solution {\\npublic:\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> children;\\n        bool isWord;\\n    };\\n\\n    TrieNode* root = new TrieNode();\\n\\n    void insert(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node->children.count(c)) {\\n                node->children[c] = new TrieNode();\\n            }\\n            node = node->children[c];\\n        }\\n        node->isWord = true;\\n    }\\n\\n    bool check(string word, int start, int count, TrieNode* node) {\\n        if (start == word.size()) {\\n            return count >= 2;\\n        }\\n        if (!node->children.count(word[start])) {\\n            return false;\\n        }\\n        TrieNode* next = node->children[word[start]];\\n        if (next->isWord && check(word, start + 1, count + 1, root)) {\\n            return true;\\n        }\\n        return check(word, start + 1, count, next);\\n    }\\n\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for (string word : words) {\\n            insert(word);\\n        }\\n        vector<string> result;\\n        for (string word : words) {\\n            if (check(word, 0, 0, root)) {\\n                result.push_back(word);\\n            }\\n        }\\n        return result;\\n    }\\n};\\nPARTIALLY ACCEPTED CAN ANYONE HELP ME WITH A LOGIC? "
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See my solution  https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "To visualize, go to:\\nhttps://www.cs.usfca.edu/~galles/visualization/Trie.html\\n\\nGive id \\'f1\\' to input box, \\'f2\\' to insert button, and \\'f3\\' to skip forward button.\\nTry following in console:\\n```js\\nfunction insert(s) {\\n    setTimeout(() => {\\n        document.getElementById(\"f1\").value=s;\\n        document.getElementById(\"f2\").click();\\n        document.getElementById(\"f3\").click();\\n    }, 1000);\\n\\n}\\n\\narr = [] // your input array\\n\\narr.forEach(insert\\n```"
                    },
                    {
                        "username": "godshiva",
                        "content": "I made the silliest mistake coding my TRIE.  I initially thought it was going to require UNIQUE words, so I stored the index of the completed words as a number or 0 if there was none, apparently forgetting that 0 is a valid index lol\\nALTHOUGH, when I realized words could repeat, a TRUE/FALSE made more sense. "
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "The question doesn\\'t mention that the order of the output matters."
                    },
                    {
                        "username": "vylv",
                        "content": "I am not have high beats rate on this problem but I feel like it\\'s not hard to find a solution to but I\\'ve run into a lot of medium problems and can\\'t find an answer."
                    },
                    {
                        "username": "tejasX",
                        "content": "Not really a hard one.\\nA basic DP."
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Is it just me or the test cases for this problem is not setup correctly? I pretty much passed with no memoizing or dp. A plain simple DFS and a set checking if a substring exists before each recursive call worked for me"
                    },
                    {
                        "username": "senkoustav72",
                        "content": "It is not accurate to mark this as a hard problem if the code is working with a unordered_set and doing a simple dfs over all the words. "
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Easy to follow and good explanation! \\nyoutube.com/watch?v=PY1LSBx-cNs"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    }
                ]
            },
            {
                "id": 1776628,
                "content": [
                    {
                        "username": "Dynamo_360",
                        "content": "class Solution {\\npublic:\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> children;\\n        bool isWord;\\n    };\\n\\n    TrieNode* root = new TrieNode();\\n\\n    void insert(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node->children.count(c)) {\\n                node->children[c] = new TrieNode();\\n            }\\n            node = node->children[c];\\n        }\\n        node->isWord = true;\\n    }\\n\\n    bool check(string word, int start, int count, TrieNode* node) {\\n        if (start == word.size()) {\\n            return count >= 2;\\n        }\\n        if (!node->children.count(word[start])) {\\n            return false;\\n        }\\n        TrieNode* next = node->children[word[start]];\\n        if (next->isWord && check(word, start + 1, count + 1, root)) {\\n            return true;\\n        }\\n        return check(word, start + 1, count, next);\\n    }\\n\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for (string word : words) {\\n            insert(word);\\n        }\\n        vector<string> result;\\n        for (string word : words) {\\n            if (check(word, 0, 0, root)) {\\n                result.push_back(word);\\n            }\\n        }\\n        return result;\\n    }\\n};\\nPARTIALLY ACCEPTED CAN ANYONE HELP ME WITH A LOGIC? "
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See my solution  https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "To visualize, go to:\\nhttps://www.cs.usfca.edu/~galles/visualization/Trie.html\\n\\nGive id \\'f1\\' to input box, \\'f2\\' to insert button, and \\'f3\\' to skip forward button.\\nTry following in console:\\n```js\\nfunction insert(s) {\\n    setTimeout(() => {\\n        document.getElementById(\"f1\").value=s;\\n        document.getElementById(\"f2\").click();\\n        document.getElementById(\"f3\").click();\\n    }, 1000);\\n\\n}\\n\\narr = [] // your input array\\n\\narr.forEach(insert\\n```"
                    },
                    {
                        "username": "godshiva",
                        "content": "I made the silliest mistake coding my TRIE.  I initially thought it was going to require UNIQUE words, so I stored the index of the completed words as a number or 0 if there was none, apparently forgetting that 0 is a valid index lol\\nALTHOUGH, when I realized words could repeat, a TRUE/FALSE made more sense. "
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "The question doesn\\'t mention that the order of the output matters."
                    },
                    {
                        "username": "vylv",
                        "content": "I am not have high beats rate on this problem but I feel like it\\'s not hard to find a solution to but I\\'ve run into a lot of medium problems and can\\'t find an answer."
                    },
                    {
                        "username": "tejasX",
                        "content": "Not really a hard one.\\nA basic DP."
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Is it just me or the test cases for this problem is not setup correctly? I pretty much passed with no memoizing or dp. A plain simple DFS and a set checking if a substring exists before each recursive call worked for me"
                    },
                    {
                        "username": "senkoustav72",
                        "content": "It is not accurate to mark this as a hard problem if the code is working with a unordered_set and doing a simple dfs over all the words. "
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Easy to follow and good explanation! \\nyoutube.com/watch?v=PY1LSBx-cNs"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    }
                ]
            },
            {
                "id": 1776627,
                "content": [
                    {
                        "username": "Dynamo_360",
                        "content": "class Solution {\\npublic:\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> children;\\n        bool isWord;\\n    };\\n\\n    TrieNode* root = new TrieNode();\\n\\n    void insert(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node->children.count(c)) {\\n                node->children[c] = new TrieNode();\\n            }\\n            node = node->children[c];\\n        }\\n        node->isWord = true;\\n    }\\n\\n    bool check(string word, int start, int count, TrieNode* node) {\\n        if (start == word.size()) {\\n            return count >= 2;\\n        }\\n        if (!node->children.count(word[start])) {\\n            return false;\\n        }\\n        TrieNode* next = node->children[word[start]];\\n        if (next->isWord && check(word, start + 1, count + 1, root)) {\\n            return true;\\n        }\\n        return check(word, start + 1, count, next);\\n    }\\n\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for (string word : words) {\\n            insert(word);\\n        }\\n        vector<string> result;\\n        for (string word : words) {\\n            if (check(word, 0, 0, root)) {\\n                result.push_back(word);\\n            }\\n        }\\n        return result;\\n    }\\n};\\nPARTIALLY ACCEPTED CAN ANYONE HELP ME WITH A LOGIC? "
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See my solution  https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "To visualize, go to:\\nhttps://www.cs.usfca.edu/~galles/visualization/Trie.html\\n\\nGive id \\'f1\\' to input box, \\'f2\\' to insert button, and \\'f3\\' to skip forward button.\\nTry following in console:\\n```js\\nfunction insert(s) {\\n    setTimeout(() => {\\n        document.getElementById(\"f1\").value=s;\\n        document.getElementById(\"f2\").click();\\n        document.getElementById(\"f3\").click();\\n    }, 1000);\\n\\n}\\n\\narr = [] // your input array\\n\\narr.forEach(insert\\n```"
                    },
                    {
                        "username": "godshiva",
                        "content": "I made the silliest mistake coding my TRIE.  I initially thought it was going to require UNIQUE words, so I stored the index of the completed words as a number or 0 if there was none, apparently forgetting that 0 is a valid index lol\\nALTHOUGH, when I realized words could repeat, a TRUE/FALSE made more sense. "
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "The question doesn\\'t mention that the order of the output matters."
                    },
                    {
                        "username": "vylv",
                        "content": "I am not have high beats rate on this problem but I feel like it\\'s not hard to find a solution to but I\\'ve run into a lot of medium problems and can\\'t find an answer."
                    },
                    {
                        "username": "tejasX",
                        "content": "Not really a hard one.\\nA basic DP."
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Is it just me or the test cases for this problem is not setup correctly? I pretty much passed with no memoizing or dp. A plain simple DFS and a set checking if a substring exists before each recursive call worked for me"
                    },
                    {
                        "username": "senkoustav72",
                        "content": "It is not accurate to mark this as a hard problem if the code is working with a unordered_set and doing a simple dfs over all the words. "
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Easy to follow and good explanation! \\nyoutube.com/watch?v=PY1LSBx-cNs"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    }
                ]
            },
            {
                "id": 1776572,
                "content": [
                    {
                        "username": "Dynamo_360",
                        "content": "class Solution {\\npublic:\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> children;\\n        bool isWord;\\n    };\\n\\n    TrieNode* root = new TrieNode();\\n\\n    void insert(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node->children.count(c)) {\\n                node->children[c] = new TrieNode();\\n            }\\n            node = node->children[c];\\n        }\\n        node->isWord = true;\\n    }\\n\\n    bool check(string word, int start, int count, TrieNode* node) {\\n        if (start == word.size()) {\\n            return count >= 2;\\n        }\\n        if (!node->children.count(word[start])) {\\n            return false;\\n        }\\n        TrieNode* next = node->children[word[start]];\\n        if (next->isWord && check(word, start + 1, count + 1, root)) {\\n            return true;\\n        }\\n        return check(word, start + 1, count, next);\\n    }\\n\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        for (string word : words) {\\n            insert(word);\\n        }\\n        vector<string> result;\\n        for (string word : words) {\\n            if (check(word, 0, 0, root)) {\\n                result.push_back(word);\\n            }\\n        }\\n        return result;\\n    }\\n};\\nPARTIALLY ACCEPTED CAN ANYONE HELP ME WITH A LOGIC? "
                    },
                    {
                        "username": "muralivr8_",
                        "content": "See my solution  https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "To visualize, go to:\\nhttps://www.cs.usfca.edu/~galles/visualization/Trie.html\\n\\nGive id \\'f1\\' to input box, \\'f2\\' to insert button, and \\'f3\\' to skip forward button.\\nTry following in console:\\n```js\\nfunction insert(s) {\\n    setTimeout(() => {\\n        document.getElementById(\"f1\").value=s;\\n        document.getElementById(\"f2\").click();\\n        document.getElementById(\"f3\").click();\\n    }, 1000);\\n\\n}\\n\\narr = [] // your input array\\n\\narr.forEach(insert\\n```"
                    },
                    {
                        "username": "godshiva",
                        "content": "I made the silliest mistake coding my TRIE.  I initially thought it was going to require UNIQUE words, so I stored the index of the completed words as a number or 0 if there was none, apparently forgetting that 0 is a valid index lol\\nALTHOUGH, when I realized words could repeat, a TRUE/FALSE made more sense. "
                    },
                    {
                        "username": "iamfaizankhalid",
                        "content": "The question doesn\\'t mention that the order of the output matters."
                    },
                    {
                        "username": "vylv",
                        "content": "I am not have high beats rate on this problem but I feel like it\\'s not hard to find a solution to but I\\'ve run into a lot of medium problems and can\\'t find an answer."
                    },
                    {
                        "username": "tejasX",
                        "content": "Not really a hard one.\\nA basic DP."
                    },
                    {
                        "username": "HTmLH4x0R",
                        "content": "Is it just me or the test cases for this problem is not setup correctly? I pretty much passed with no memoizing or dp. A plain simple DFS and a set checking if a substring exists before each recursive call worked for me"
                    },
                    {
                        "username": "senkoustav72",
                        "content": "It is not accurate to mark this as a hard problem if the code is working with a unordered_set and doing a simple dfs over all the words. "
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Easy to follow and good explanation! \\nyoutube.com/watch?v=PY1LSBx-cNs"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    }
                ]
            },
            {
                "id": 1776393,
                "content": [
                    {
                        "username": "ydnl",
                        "content": "Any idea for O(L*N) solution?\\nL=words.length\\nN=words[i].length"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a word and check if a substring of it `[0:i]` is presented in the words set."
                    },
                    {
                        "username": "santanusen",
                        "content": "Man, I just solved a hard question without help! Is this a hard question then?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This one is kind of Medium-Hard problem"
                    },
                    {
                        "username": "palakons",
                        "content": "oh.. \"entirely\"..."
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not.\\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "         \\n         def Test_reding_locations(self,text_words)->None:\\n    s,ans=set(self,text_words),[]\\n    def additions_string_word(self,string_s):\\n        if self.string_s in s:\\n           return True\\n        for i in range(len(self,string_s)):\\n            if string_s[:i] in s and additions_string_word(self,string_s[i:]):\\n               return True\\n        return False\\n    for word in self,text_words:\\n        for i in range(1,len(word)):\\n            if word[:i] in s and additions_string_word(word[i:]):\\n                ans.append(word)\\n                break\\n    return ans"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "see a Trie solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "so, why this one is considered difficult? b/c of lots of code or rarely used Trie data structure? or else?"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "used `pen and paper`, it enhanced the way to think towards the solution of this problem.\\nThough it seems `medium` level problem to me coz the code is small, and the approach matches with that of problem description."
                    },
                    {
                        "username": "rvd2222",
                        "content": "`class Solution {\\npublic:\\n    struct TrieNode {\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n};\\n\\n// Trie class\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string word) {\\n        TrieNode* curr = root;\\n        for (char c : word) {\\n            if (curr->children.find(c) == curr->children.end()) {\\n                curr->children[c] = new TrieNode();\\n            }\\n            curr = curr->children[c];\\n        }\\n        curr->isWord = true;\\n    }\\n};\\n\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    Trie trie;\\n    for (string word : words) {\\n        trie.insert(word);\\n    }\\n    vector<string> res;\\n    for (string word : words) {\\n        if (dfs(trie.root, word, 0, 0,trie)) {\\n            res.push_back(word);\\n        }\\n    }\\n    return res;\\n}\\n\\nbool dfs(TrieNode* curr, string& word, int idx, int count, Trie& trie) {\\n    if (idx == word.size()) {\\n        return count > 1;\\n    }\\n    if (curr->children.find(word[idx]) == curr->children.end()) {\\n        return false;\\n    }\\n    curr = curr->children[word[idx]];\\n    if (curr->isWord) {\\n        if (dfs(trie.root, word, idx + 1, count + 1,trie)) {\\n            return true;\\n        }\\n    }\\n    return dfs(curr, word, idx + 1, count,trie);\\n}\\n\\n\\n\\n};`\\n\\nwhat is probem in this code"
                    }
                ]
            },
            {
                "id": 1776386,
                "content": [
                    {
                        "username": "ydnl",
                        "content": "Any idea for O(L*N) solution?\\nL=words.length\\nN=words[i].length"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a word and check if a substring of it `[0:i]` is presented in the words set."
                    },
                    {
                        "username": "santanusen",
                        "content": "Man, I just solved a hard question without help! Is this a hard question then?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This one is kind of Medium-Hard problem"
                    },
                    {
                        "username": "palakons",
                        "content": "oh.. \"entirely\"..."
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not.\\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "         \\n         def Test_reding_locations(self,text_words)->None:\\n    s,ans=set(self,text_words),[]\\n    def additions_string_word(self,string_s):\\n        if self.string_s in s:\\n           return True\\n        for i in range(len(self,string_s)):\\n            if string_s[:i] in s and additions_string_word(self,string_s[i:]):\\n               return True\\n        return False\\n    for word in self,text_words:\\n        for i in range(1,len(word)):\\n            if word[:i] in s and additions_string_word(word[i:]):\\n                ans.append(word)\\n                break\\n    return ans"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "see a Trie solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "so, why this one is considered difficult? b/c of lots of code or rarely used Trie data structure? or else?"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "used `pen and paper`, it enhanced the way to think towards the solution of this problem.\\nThough it seems `medium` level problem to me coz the code is small, and the approach matches with that of problem description."
                    },
                    {
                        "username": "rvd2222",
                        "content": "`class Solution {\\npublic:\\n    struct TrieNode {\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n};\\n\\n// Trie class\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string word) {\\n        TrieNode* curr = root;\\n        for (char c : word) {\\n            if (curr->children.find(c) == curr->children.end()) {\\n                curr->children[c] = new TrieNode();\\n            }\\n            curr = curr->children[c];\\n        }\\n        curr->isWord = true;\\n    }\\n};\\n\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    Trie trie;\\n    for (string word : words) {\\n        trie.insert(word);\\n    }\\n    vector<string> res;\\n    for (string word : words) {\\n        if (dfs(trie.root, word, 0, 0,trie)) {\\n            res.push_back(word);\\n        }\\n    }\\n    return res;\\n}\\n\\nbool dfs(TrieNode* curr, string& word, int idx, int count, Trie& trie) {\\n    if (idx == word.size()) {\\n        return count > 1;\\n    }\\n    if (curr->children.find(word[idx]) == curr->children.end()) {\\n        return false;\\n    }\\n    curr = curr->children[word[idx]];\\n    if (curr->isWord) {\\n        if (dfs(trie.root, word, idx + 1, count + 1,trie)) {\\n            return true;\\n        }\\n    }\\n    return dfs(curr, word, idx + 1, count,trie);\\n}\\n\\n\\n\\n};`\\n\\nwhat is probem in this code"
                    }
                ]
            },
            {
                "id": 1776366,
                "content": [
                    {
                        "username": "ydnl",
                        "content": "Any idea for O(L*N) solution?\\nL=words.length\\nN=words[i].length"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a word and check if a substring of it `[0:i]` is presented in the words set."
                    },
                    {
                        "username": "santanusen",
                        "content": "Man, I just solved a hard question without help! Is this a hard question then?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This one is kind of Medium-Hard problem"
                    },
                    {
                        "username": "palakons",
                        "content": "oh.. \"entirely\"..."
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not.\\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "         \\n         def Test_reding_locations(self,text_words)->None:\\n    s,ans=set(self,text_words),[]\\n    def additions_string_word(self,string_s):\\n        if self.string_s in s:\\n           return True\\n        for i in range(len(self,string_s)):\\n            if string_s[:i] in s and additions_string_word(self,string_s[i:]):\\n               return True\\n        return False\\n    for word in self,text_words:\\n        for i in range(1,len(word)):\\n            if word[:i] in s and additions_string_word(word[i:]):\\n                ans.append(word)\\n                break\\n    return ans"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "see a Trie solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "so, why this one is considered difficult? b/c of lots of code or rarely used Trie data structure? or else?"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "used `pen and paper`, it enhanced the way to think towards the solution of this problem.\\nThough it seems `medium` level problem to me coz the code is small, and the approach matches with that of problem description."
                    },
                    {
                        "username": "rvd2222",
                        "content": "`class Solution {\\npublic:\\n    struct TrieNode {\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n};\\n\\n// Trie class\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string word) {\\n        TrieNode* curr = root;\\n        for (char c : word) {\\n            if (curr->children.find(c) == curr->children.end()) {\\n                curr->children[c] = new TrieNode();\\n            }\\n            curr = curr->children[c];\\n        }\\n        curr->isWord = true;\\n    }\\n};\\n\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    Trie trie;\\n    for (string word : words) {\\n        trie.insert(word);\\n    }\\n    vector<string> res;\\n    for (string word : words) {\\n        if (dfs(trie.root, word, 0, 0,trie)) {\\n            res.push_back(word);\\n        }\\n    }\\n    return res;\\n}\\n\\nbool dfs(TrieNode* curr, string& word, int idx, int count, Trie& trie) {\\n    if (idx == word.size()) {\\n        return count > 1;\\n    }\\n    if (curr->children.find(word[idx]) == curr->children.end()) {\\n        return false;\\n    }\\n    curr = curr->children[word[idx]];\\n    if (curr->isWord) {\\n        if (dfs(trie.root, word, idx + 1, count + 1,trie)) {\\n            return true;\\n        }\\n    }\\n    return dfs(curr, word, idx + 1, count,trie);\\n}\\n\\n\\n\\n};`\\n\\nwhat is probem in this code"
                    }
                ]
            },
            {
                "id": 1776360,
                "content": [
                    {
                        "username": "ydnl",
                        "content": "Any idea for O(L*N) solution?\\nL=words.length\\nN=words[i].length"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a word and check if a substring of it `[0:i]` is presented in the words set."
                    },
                    {
                        "username": "santanusen",
                        "content": "Man, I just solved a hard question without help! Is this a hard question then?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This one is kind of Medium-Hard problem"
                    },
                    {
                        "username": "palakons",
                        "content": "oh.. \"entirely\"..."
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not.\\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "         \\n         def Test_reding_locations(self,text_words)->None:\\n    s,ans=set(self,text_words),[]\\n    def additions_string_word(self,string_s):\\n        if self.string_s in s:\\n           return True\\n        for i in range(len(self,string_s)):\\n            if string_s[:i] in s and additions_string_word(self,string_s[i:]):\\n               return True\\n        return False\\n    for word in self,text_words:\\n        for i in range(1,len(word)):\\n            if word[:i] in s and additions_string_word(word[i:]):\\n                ans.append(word)\\n                break\\n    return ans"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "see a Trie solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "so, why this one is considered difficult? b/c of lots of code or rarely used Trie data structure? or else?"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "used `pen and paper`, it enhanced the way to think towards the solution of this problem.\\nThough it seems `medium` level problem to me coz the code is small, and the approach matches with that of problem description."
                    },
                    {
                        "username": "rvd2222",
                        "content": "`class Solution {\\npublic:\\n    struct TrieNode {\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n};\\n\\n// Trie class\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string word) {\\n        TrieNode* curr = root;\\n        for (char c : word) {\\n            if (curr->children.find(c) == curr->children.end()) {\\n                curr->children[c] = new TrieNode();\\n            }\\n            curr = curr->children[c];\\n        }\\n        curr->isWord = true;\\n    }\\n};\\n\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    Trie trie;\\n    for (string word : words) {\\n        trie.insert(word);\\n    }\\n    vector<string> res;\\n    for (string word : words) {\\n        if (dfs(trie.root, word, 0, 0,trie)) {\\n            res.push_back(word);\\n        }\\n    }\\n    return res;\\n}\\n\\nbool dfs(TrieNode* curr, string& word, int idx, int count, Trie& trie) {\\n    if (idx == word.size()) {\\n        return count > 1;\\n    }\\n    if (curr->children.find(word[idx]) == curr->children.end()) {\\n        return false;\\n    }\\n    curr = curr->children[word[idx]];\\n    if (curr->isWord) {\\n        if (dfs(trie.root, word, idx + 1, count + 1,trie)) {\\n            return true;\\n        }\\n    }\\n    return dfs(curr, word, idx + 1, count,trie);\\n}\\n\\n\\n\\n};`\\n\\nwhat is probem in this code"
                    }
                ]
            },
            {
                "id": 1776235,
                "content": [
                    {
                        "username": "ydnl",
                        "content": "Any idea for O(L*N) solution?\\nL=words.length\\nN=words[i].length"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a word and check if a substring of it `[0:i]` is presented in the words set."
                    },
                    {
                        "username": "santanusen",
                        "content": "Man, I just solved a hard question without help! Is this a hard question then?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This one is kind of Medium-Hard problem"
                    },
                    {
                        "username": "palakons",
                        "content": "oh.. \"entirely\"..."
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not.\\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "         \\n         def Test_reding_locations(self,text_words)->None:\\n    s,ans=set(self,text_words),[]\\n    def additions_string_word(self,string_s):\\n        if self.string_s in s:\\n           return True\\n        for i in range(len(self,string_s)):\\n            if string_s[:i] in s and additions_string_word(self,string_s[i:]):\\n               return True\\n        return False\\n    for word in self,text_words:\\n        for i in range(1,len(word)):\\n            if word[:i] in s and additions_string_word(word[i:]):\\n                ans.append(word)\\n                break\\n    return ans"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "see a Trie solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "so, why this one is considered difficult? b/c of lots of code or rarely used Trie data structure? or else?"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "used `pen and paper`, it enhanced the way to think towards the solution of this problem.\\nThough it seems `medium` level problem to me coz the code is small, and the approach matches with that of problem description."
                    },
                    {
                        "username": "rvd2222",
                        "content": "`class Solution {\\npublic:\\n    struct TrieNode {\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n};\\n\\n// Trie class\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string word) {\\n        TrieNode* curr = root;\\n        for (char c : word) {\\n            if (curr->children.find(c) == curr->children.end()) {\\n                curr->children[c] = new TrieNode();\\n            }\\n            curr = curr->children[c];\\n        }\\n        curr->isWord = true;\\n    }\\n};\\n\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    Trie trie;\\n    for (string word : words) {\\n        trie.insert(word);\\n    }\\n    vector<string> res;\\n    for (string word : words) {\\n        if (dfs(trie.root, word, 0, 0,trie)) {\\n            res.push_back(word);\\n        }\\n    }\\n    return res;\\n}\\n\\nbool dfs(TrieNode* curr, string& word, int idx, int count, Trie& trie) {\\n    if (idx == word.size()) {\\n        return count > 1;\\n    }\\n    if (curr->children.find(word[idx]) == curr->children.end()) {\\n        return false;\\n    }\\n    curr = curr->children[word[idx]];\\n    if (curr->isWord) {\\n        if (dfs(trie.root, word, idx + 1, count + 1,trie)) {\\n            return true;\\n        }\\n    }\\n    return dfs(curr, word, idx + 1, count,trie);\\n}\\n\\n\\n\\n};`\\n\\nwhat is probem in this code"
                    }
                ]
            },
            {
                "id": 1776227,
                "content": [
                    {
                        "username": "ydnl",
                        "content": "Any idea for O(L*N) solution?\\nL=words.length\\nN=words[i].length"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a word and check if a substring of it `[0:i]` is presented in the words set."
                    },
                    {
                        "username": "santanusen",
                        "content": "Man, I just solved a hard question without help! Is this a hard question then?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This one is kind of Medium-Hard problem"
                    },
                    {
                        "username": "palakons",
                        "content": "oh.. \"entirely\"..."
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not.\\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "         \\n         def Test_reding_locations(self,text_words)->None:\\n    s,ans=set(self,text_words),[]\\n    def additions_string_word(self,string_s):\\n        if self.string_s in s:\\n           return True\\n        for i in range(len(self,string_s)):\\n            if string_s[:i] in s and additions_string_word(self,string_s[i:]):\\n               return True\\n        return False\\n    for word in self,text_words:\\n        for i in range(1,len(word)):\\n            if word[:i] in s and additions_string_word(word[i:]):\\n                ans.append(word)\\n                break\\n    return ans"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "see a Trie solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "so, why this one is considered difficult? b/c of lots of code or rarely used Trie data structure? or else?"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "used `pen and paper`, it enhanced the way to think towards the solution of this problem.\\nThough it seems `medium` level problem to me coz the code is small, and the approach matches with that of problem description."
                    },
                    {
                        "username": "rvd2222",
                        "content": "`class Solution {\\npublic:\\n    struct TrieNode {\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n};\\n\\n// Trie class\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string word) {\\n        TrieNode* curr = root;\\n        for (char c : word) {\\n            if (curr->children.find(c) == curr->children.end()) {\\n                curr->children[c] = new TrieNode();\\n            }\\n            curr = curr->children[c];\\n        }\\n        curr->isWord = true;\\n    }\\n};\\n\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    Trie trie;\\n    for (string word : words) {\\n        trie.insert(word);\\n    }\\n    vector<string> res;\\n    for (string word : words) {\\n        if (dfs(trie.root, word, 0, 0,trie)) {\\n            res.push_back(word);\\n        }\\n    }\\n    return res;\\n}\\n\\nbool dfs(TrieNode* curr, string& word, int idx, int count, Trie& trie) {\\n    if (idx == word.size()) {\\n        return count > 1;\\n    }\\n    if (curr->children.find(word[idx]) == curr->children.end()) {\\n        return false;\\n    }\\n    curr = curr->children[word[idx]];\\n    if (curr->isWord) {\\n        if (dfs(trie.root, word, idx + 1, count + 1,trie)) {\\n            return true;\\n        }\\n    }\\n    return dfs(curr, word, idx + 1, count,trie);\\n}\\n\\n\\n\\n};`\\n\\nwhat is probem in this code"
                    }
                ]
            },
            {
                "id": 1776115,
                "content": [
                    {
                        "username": "ydnl",
                        "content": "Any idea for O(L*N) solution?\\nL=words.length\\nN=words[i].length"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a word and check if a substring of it `[0:i]` is presented in the words set."
                    },
                    {
                        "username": "santanusen",
                        "content": "Man, I just solved a hard question without help! Is this a hard question then?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This one is kind of Medium-Hard problem"
                    },
                    {
                        "username": "palakons",
                        "content": "oh.. \"entirely\"..."
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not.\\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "         \\n         def Test_reding_locations(self,text_words)->None:\\n    s,ans=set(self,text_words),[]\\n    def additions_string_word(self,string_s):\\n        if self.string_s in s:\\n           return True\\n        for i in range(len(self,string_s)):\\n            if string_s[:i] in s and additions_string_word(self,string_s[i:]):\\n               return True\\n        return False\\n    for word in self,text_words:\\n        for i in range(1,len(word)):\\n            if word[:i] in s and additions_string_word(word[i:]):\\n                ans.append(word)\\n                break\\n    return ans"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "see a Trie solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "so, why this one is considered difficult? b/c of lots of code or rarely used Trie data structure? or else?"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "used `pen and paper`, it enhanced the way to think towards the solution of this problem.\\nThough it seems `medium` level problem to me coz the code is small, and the approach matches with that of problem description."
                    },
                    {
                        "username": "rvd2222",
                        "content": "`class Solution {\\npublic:\\n    struct TrieNode {\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n};\\n\\n// Trie class\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string word) {\\n        TrieNode* curr = root;\\n        for (char c : word) {\\n            if (curr->children.find(c) == curr->children.end()) {\\n                curr->children[c] = new TrieNode();\\n            }\\n            curr = curr->children[c];\\n        }\\n        curr->isWord = true;\\n    }\\n};\\n\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    Trie trie;\\n    for (string word : words) {\\n        trie.insert(word);\\n    }\\n    vector<string> res;\\n    for (string word : words) {\\n        if (dfs(trie.root, word, 0, 0,trie)) {\\n            res.push_back(word);\\n        }\\n    }\\n    return res;\\n}\\n\\nbool dfs(TrieNode* curr, string& word, int idx, int count, Trie& trie) {\\n    if (idx == word.size()) {\\n        return count > 1;\\n    }\\n    if (curr->children.find(word[idx]) == curr->children.end()) {\\n        return false;\\n    }\\n    curr = curr->children[word[idx]];\\n    if (curr->isWord) {\\n        if (dfs(trie.root, word, idx + 1, count + 1,trie)) {\\n            return true;\\n        }\\n    }\\n    return dfs(curr, word, idx + 1, count,trie);\\n}\\n\\n\\n\\n};`\\n\\nwhat is probem in this code"
                    }
                ]
            },
            {
                "id": 1775979,
                "content": [
                    {
                        "username": "ydnl",
                        "content": "Any idea for O(L*N) solution?\\nL=words.length\\nN=words[i].length"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a word and check if a substring of it `[0:i]` is presented in the words set."
                    },
                    {
                        "username": "santanusen",
                        "content": "Man, I just solved a hard question without help! Is this a hard question then?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This one is kind of Medium-Hard problem"
                    },
                    {
                        "username": "palakons",
                        "content": "oh.. \"entirely\"..."
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not.\\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "         \\n         def Test_reding_locations(self,text_words)->None:\\n    s,ans=set(self,text_words),[]\\n    def additions_string_word(self,string_s):\\n        if self.string_s in s:\\n           return True\\n        for i in range(len(self,string_s)):\\n            if string_s[:i] in s and additions_string_word(self,string_s[i:]):\\n               return True\\n        return False\\n    for word in self,text_words:\\n        for i in range(1,len(word)):\\n            if word[:i] in s and additions_string_word(word[i:]):\\n                ans.append(word)\\n                break\\n    return ans"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "see a Trie solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "so, why this one is considered difficult? b/c of lots of code or rarely used Trie data structure? or else?"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "used `pen and paper`, it enhanced the way to think towards the solution of this problem.\\nThough it seems `medium` level problem to me coz the code is small, and the approach matches with that of problem description."
                    },
                    {
                        "username": "rvd2222",
                        "content": "`class Solution {\\npublic:\\n    struct TrieNode {\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n};\\n\\n// Trie class\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string word) {\\n        TrieNode* curr = root;\\n        for (char c : word) {\\n            if (curr->children.find(c) == curr->children.end()) {\\n                curr->children[c] = new TrieNode();\\n            }\\n            curr = curr->children[c];\\n        }\\n        curr->isWord = true;\\n    }\\n};\\n\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    Trie trie;\\n    for (string word : words) {\\n        trie.insert(word);\\n    }\\n    vector<string> res;\\n    for (string word : words) {\\n        if (dfs(trie.root, word, 0, 0,trie)) {\\n            res.push_back(word);\\n        }\\n    }\\n    return res;\\n}\\n\\nbool dfs(TrieNode* curr, string& word, int idx, int count, Trie& trie) {\\n    if (idx == word.size()) {\\n        return count > 1;\\n    }\\n    if (curr->children.find(word[idx]) == curr->children.end()) {\\n        return false;\\n    }\\n    curr = curr->children[word[idx]];\\n    if (curr->isWord) {\\n        if (dfs(trie.root, word, idx + 1, count + 1,trie)) {\\n            return true;\\n        }\\n    }\\n    return dfs(curr, word, idx + 1, count,trie);\\n}\\n\\n\\n\\n};`\\n\\nwhat is probem in this code"
                    }
                ]
            },
            {
                "id": 1775940,
                "content": [
                    {
                        "username": "ydnl",
                        "content": "Any idea for O(L*N) solution?\\nL=words.length\\nN=words[i].length"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a word and check if a substring of it `[0:i]` is presented in the words set."
                    },
                    {
                        "username": "santanusen",
                        "content": "Man, I just solved a hard question without help! Is this a hard question then?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This one is kind of Medium-Hard problem"
                    },
                    {
                        "username": "palakons",
                        "content": "oh.. \"entirely\"..."
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not.\\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "         \\n         def Test_reding_locations(self,text_words)->None:\\n    s,ans=set(self,text_words),[]\\n    def additions_string_word(self,string_s):\\n        if self.string_s in s:\\n           return True\\n        for i in range(len(self,string_s)):\\n            if string_s[:i] in s and additions_string_word(self,string_s[i:]):\\n               return True\\n        return False\\n    for word in self,text_words:\\n        for i in range(1,len(word)):\\n            if word[:i] in s and additions_string_word(word[i:]):\\n                ans.append(word)\\n                break\\n    return ans"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "see a Trie solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "so, why this one is considered difficult? b/c of lots of code or rarely used Trie data structure? or else?"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "used `pen and paper`, it enhanced the way to think towards the solution of this problem.\\nThough it seems `medium` level problem to me coz the code is small, and the approach matches with that of problem description."
                    },
                    {
                        "username": "rvd2222",
                        "content": "`class Solution {\\npublic:\\n    struct TrieNode {\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n};\\n\\n// Trie class\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string word) {\\n        TrieNode* curr = root;\\n        for (char c : word) {\\n            if (curr->children.find(c) == curr->children.end()) {\\n                curr->children[c] = new TrieNode();\\n            }\\n            curr = curr->children[c];\\n        }\\n        curr->isWord = true;\\n    }\\n};\\n\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    Trie trie;\\n    for (string word : words) {\\n        trie.insert(word);\\n    }\\n    vector<string> res;\\n    for (string word : words) {\\n        if (dfs(trie.root, word, 0, 0,trie)) {\\n            res.push_back(word);\\n        }\\n    }\\n    return res;\\n}\\n\\nbool dfs(TrieNode* curr, string& word, int idx, int count, Trie& trie) {\\n    if (idx == word.size()) {\\n        return count > 1;\\n    }\\n    if (curr->children.find(word[idx]) == curr->children.end()) {\\n        return false;\\n    }\\n    curr = curr->children[word[idx]];\\n    if (curr->isWord) {\\n        if (dfs(trie.root, word, idx + 1, count + 1,trie)) {\\n            return true;\\n        }\\n    }\\n    return dfs(curr, word, idx + 1, count,trie);\\n}\\n\\n\\n\\n};`\\n\\nwhat is probem in this code"
                    }
                ]
            },
            {
                "id": 1775927,
                "content": [
                    {
                        "username": "ydnl",
                        "content": "Any idea for O(L*N) solution?\\nL=words.length\\nN=words[i].length"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a word and check if a substring of it `[0:i]` is presented in the words set."
                    },
                    {
                        "username": "santanusen",
                        "content": "Man, I just solved a hard question without help! Is this a hard question then?"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This one is kind of Medium-Hard problem"
                    },
                    {
                        "username": "palakons",
                        "content": "oh.. \"entirely\"..."
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "For those doing the January challenge, this is the first word tree question, and they start with a hard.\\nSo a tip is to make a \"tree\" made out of the characters of the words. Each level of the tree has the ith character of each word. And mark at each level if a word has ended there or not.\\nAfter you make this tree, then it is a medium dp question to check if a word is made up of words."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "         \\n         def Test_reding_locations(self,text_words)->None:\\n    s,ans=set(self,text_words),[]\\n    def additions_string_word(self,string_s):\\n        if self.string_s in s:\\n           return True\\n        for i in range(len(self,string_s)):\\n            if string_s[:i] in s and additions_string_word(self,string_s[i:]):\\n               return True\\n        return False\\n    for word in self,text_words:\\n        for i in range(1,len(word)):\\n            if word[:i] in s and additions_string_word(word[i:]):\\n                ans.append(word)\\n                break\\n    return ans"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "see a Trie solution https://leetcode.com/problems/concatenated-words/solutions/3104267/c-trie-solution-easy-fast-solution/"
                    },
                    {
                        "username": "c4tdog",
                        "content": "so, why this one is considered difficult? b/c of lots of code or rarely used Trie data structure? or else?"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "used `pen and paper`, it enhanced the way to think towards the solution of this problem.\\nThough it seems `medium` level problem to me coz the code is small, and the approach matches with that of problem description."
                    },
                    {
                        "username": "rvd2222",
                        "content": "`class Solution {\\npublic:\\n    struct TrieNode {\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n};\\n\\n// Trie class\\nclass Trie {\\npublic:\\n    TrieNode* root;\\n\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string word) {\\n        TrieNode* curr = root;\\n        for (char c : word) {\\n            if (curr->children.find(c) == curr->children.end()) {\\n                curr->children[c] = new TrieNode();\\n            }\\n            curr = curr->children[c];\\n        }\\n        curr->isWord = true;\\n    }\\n};\\n\\nvector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n    Trie trie;\\n    for (string word : words) {\\n        trie.insert(word);\\n    }\\n    vector<string> res;\\n    for (string word : words) {\\n        if (dfs(trie.root, word, 0, 0,trie)) {\\n            res.push_back(word);\\n        }\\n    }\\n    return res;\\n}\\n\\nbool dfs(TrieNode* curr, string& word, int idx, int count, Trie& trie) {\\n    if (idx == word.size()) {\\n        return count > 1;\\n    }\\n    if (curr->children.find(word[idx]) == curr->children.end()) {\\n        return false;\\n    }\\n    curr = curr->children[word[idx]];\\n    if (curr->isWord) {\\n        if (dfs(trie.root, word, idx + 1, count + 1,trie)) {\\n            return true;\\n        }\\n    }\\n    return dfs(curr, word, idx + 1, count,trie);\\n}\\n\\n\\n\\n};`\\n\\nwhat is probem in this code"
                    }
                ]
            }
        ]
    }
]