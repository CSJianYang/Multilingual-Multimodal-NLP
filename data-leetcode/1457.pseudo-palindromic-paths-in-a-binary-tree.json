[
    {
        "title": "Maximum Number of Vowels in a Substring of Given Length",
        "question_content": "Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k.\nVowel letters in English are 'a', 'e', 'i', 'o', and 'u'.\n&nbsp;\nExample 1:\n\nInput: s = \"abciiidef\", k = 3\nOutput: 3\nExplanation: The substring \"iii\" contains 3 vowel letters.\n\nExample 2:\n\nInput: s = \"aeiou\", k = 2\nOutput: 2\nExplanation: Any substring of length 2 contains 2 vowels.\n\nExample 3:\n\nInput: s = \"leetcode\", k = 3\nOutput: 2\nExplanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts consists of lowercase English letters.\n\t1 <= k <= s.length",
        "solutions": [
            {
                "id": 648370,
                "title": "c-sliding-window",
                "content": "Just a simple sliding window pattern: count vowels moving in and out of window, and keep track of the maximum.\\n\\n```cpp\\nint vowels[26] = {1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1};\\nint maxVowels(string s, int k) {\\n    int max_vow = 0;\\n    for (auto i = 0, cur_vow = 0; i < s.size(); ++i) {\\n        cur_vow += vowels[s[i] - \\'a\\'];\\n        if (i >= k)\\n            cur_vow -= vowels[s[i - k] - \\'a\\'];\\n        max_vow = max(max_vow, cur_vow);\\n    }\\n    return max_vow;\\n}\\n```\\n\\n**Complexity Analysis**\\n- Time: O(n), we do through the string exactly once.\\n- Memory: O(1).",
                "solutionTags": [],
                "code": "```cpp\\nint vowels[26] = {1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1};\\nint maxVowels(string s, int k) {\\n    int max_vow = 0;\\n    for (auto i = 0, cur_vow = 0; i < s.size(); ++i) {\\n        cur_vow += vowels[s[i] - \\'a\\'];\\n        if (i >= k)\\n            cur_vow -= vowels[s[i - k] - \\'a\\'];\\n        max_vow = max(max_vow, cur_vow);\\n    }\\n    return max_vow;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 648559,
                "title": "java-python-3-slide-window-o-n-codes",
                "content": "Maintain a sliding window of size `k`, `(i - k, i]`, and count in/out the vowels inside/outside during sliding;\\n\\n```java\\n    public int maxVowels(String s, int k) {\\n        int ans = 0;\\n        // Set<Character> vowels = new HashSet<>(Arrays.asList(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'));\\n        var vowels = Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'); // Java 11 Collection factory method, credit to @Sithis\\n        for (int i = 0, winCnt = 0; i < s.length(); ++i) {\\n            if (vowels.contains(s.charAt(i))) {\\n                ++winCnt; \\n            }\\n            if (i >= k && vowels.contains(s.charAt(i - k))) {\\n                --winCnt;\\n            }\\n            ans = Math.max(winCnt, ans);\\n        }\\n        return ans;\\n    }\\n```\\n\\n```python\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        ans = cnt = 0\\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                cnt += 1\\n            if i >= k and s[i - k] in vowels:\\n                cnt -= 1\\n            ans  = max(cnt, ans)\\n        return ans    \\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = s.length()`.",
                "solutionTags": [],
                "code": "```java\\n    public int maxVowels(String s, int k) {\\n        int ans = 0;\\n        // Set<Character> vowels = new HashSet<>(Arrays.asList(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'));\\n        var vowels = Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'); // Java 11 Collection factory method, credit to @Sithis\\n        for (int i = 0, winCnt = 0; i < s.length(); ++i) {\\n            if (vowels.contains(s.charAt(i))) {\\n                ++winCnt; \\n            }\\n            if (i >= k && vowels.contains(s.charAt(i - k))) {\\n                --winCnt;\\n            }\\n            ans = Math.max(winCnt, ans);\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        ans = cnt = 0\\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                cnt += 1\\n            if i >= k and s[i - k] in vowels:\\n                cnt -= 1\\n            ans  = max(cnt, ans)\\n        return ans    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 648458,
                "title": "c-py3-explained-w-diagram-sliding-window",
                "content": "# **Idea and Approach**\\nThe basic idea to solve this kind of problem is to create a window of the given size and keep on moving it till the end while maintaining the count of the vowels we *gain* and *lose* in this transition.\\n\\nBelow is the implementation and steps explained through diagram:\\n\\n* Traverse through all the elements of the first window and keep track of the vowels.\\n![image](https://assets.leetcode.com/users/luctivud/image_1590301154.png)\\n\\n\\n* Move the window to the right side without changing the size.\\n* Decrement the count in currentCount if any vowel is removed from the left side during transition\\n* Increase if vowel is added from the right side.\\n![image](https://assets.leetcode.com/users/luctivud/image_1590301197.png)\\n\\n\\n* The answer will be the maximum of all the counts encountered while moving the window.\\n![image](https://assets.leetcode.com/users/luctivud/image_1590301178.png)\\n\\n\\n# **Python 3 Code**\\n\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        # Maximum vowels i.e. ans\\n        ans: int = 0\\n            \\n        # Vowels in current window\\n        currCount: int = 0\\n            \\n        # String of vowels\\n        vowels: str = \"aeiou\"\\n            \\n        # Using sliding window technique to \\n        # calculate number of vowels in each window and \\n        # update the count\\n        for i, v in enumerate(s):\\n            if i >= k:\\n                if s[i-k] in vowels:\\n                    currCount -= 1\\n            if s[i] in vowels:\\n                currCount += 1\\n            ans = max(currCount, ans)\\n        return ans\\n```\\n\\n# **C++ Code**\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        \\n        // Store current count of vowels in currCount\\n        // and maximum currCount occurred in ans\\n        int currCount = 0;\\n        int ans = 0;\\n        \\n        // An array to mark all the vowels\\' position to true\\n        // for checking whether the char is vowel or not\\n        bool vowels[26] = {false};\\n        vowels[0] = vowels[4] = vowels[8] = vowels[14] = vowels[20] = true;\\n        \\n        // Sliding window implementation\\n        for (int i=0; i < s.length(); i++) {\\n            \\n            // if any vowel is removed from left-> decrement\\n            if (i >= k and vowels[s[i-k]-\\'a\\']) {\\n                currCount -= 1;\\n            }\\n            \\n            // if any vowel is inserted from right-> increment\\n            if (vowels[s[i]-\\'a\\']) {\\n                currCount += 1;\\n            }\\n            \\n            // Store maximum occurence of currCount in ans\\n            ans = max (ans, currCount);\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```\\n# **Complexity Analysis**:\\nTime Complexity: **O(n)**\\nSpace : O(1)\\n\\n*Plz Upvote if you like it.*",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        # Maximum vowels i.e. ans\\n        ans: int = 0\\n            \\n        # Vowels in current window\\n        currCount: int = 0\\n            \\n        # String of vowels\\n        vowels: str = \"aeiou\"\\n            \\n        # Using sliding window technique to \\n        # calculate number of vowels in each window and \\n        # update the count\\n        for i, v in enumerate(s):\\n            if i >= k:\\n                if s[i-k] in vowels:\\n                    currCount -= 1\\n            if s[i] in vowels:\\n                currCount += 1\\n            ans = max(currCount, ans)\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        \\n        // Store current count of vowels in currCount\\n        // and maximum currCount occurred in ans\\n        int currCount = 0;\\n        int ans = 0;\\n        \\n        // An array to mark all the vowels\\' position to true\\n        // for checking whether the char is vowel or not\\n        bool vowels[26] = {false};\\n        vowels[0] = vowels[4] = vowels[8] = vowels[14] = vowels[20] = true;\\n        \\n        // Sliding window implementation\\n        for (int i=0; i < s.length(); i++) {\\n            \\n            // if any vowel is removed from left-> decrement\\n            if (i >= k and vowels[s[i-k]-\\'a\\']) {\\n                currCount -= 1;\\n            }\\n            \\n            // if any vowel is inserted from right-> increment\\n            if (vowels[s[i]-\\'a\\']) {\\n                currCount += 1;\\n            }\\n            \\n            // Store maximum occurence of currCount in ans\\n            ans = max (ans, currCount);\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487283,
                "title": "c-easy-explanation-generic-sliding-window-approach",
                "content": "# Approach\\nTo solve this We use `Start` and `End` Pointer which determines the window of Size K\\n\\nCheck each upcoming character whether it is a vowel or not and update the temp count accordingly\\n\\nIf the `window size == k+1 ` then increment the start pointer , if character at start pointer is a vowel then decrease the temp count\\n\\nFinally store max ans in each window of size k\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Helper function to check if a character is a vowel\\n    bool isVowel(char c){\\n        char t = tolower(c);\\n        return t == \\'a\\' or t == \\'e\\' or t==\\'i\\' or t==\\'o\\' or t==\\'u\\';\\n    }\\n    \\n    int maxVowels(string s, int k) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = 0;\\n\\n        int ans = 0;  // Initialize the maximum number of vowels to 0\\n        int temp = 0;  // Initialize a temporary count of vowels in the current window\\n\\n        // Loop through the string with a sliding window approach\\n        while(end < n){\\n            // If the current character is a vowel, increment the temporary count\\n            if(isVowel(s[end])){\\n               temp++;\\n           }\\n          \\n           // If the window size is equal to k+1, slide the window by moving the start pointer\\n           if(end-start == k ){\\n               if(isVowel(s[start])){\\n                   temp--;  // Decrement the temporary count if the first character in the window is a vowel\\n               }\\n               start++;  \\n           }\\n           \\n           ans = max(ans, temp);  // Update the maximum number of vowels found so far\\n           end++;  // Move the end pointer to expand the window\\n        }\\n        \\n        return ans; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to check if a character is a vowel\\n    bool isVowel(char c){\\n        char t = tolower(c);\\n        return t == \\'a\\' or t == \\'e\\' or t==\\'i\\' or t==\\'o\\' or t==\\'u\\';\\n    }\\n    \\n    int maxVowels(string s, int k) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = 0;\\n\\n        int ans = 0;  // Initialize the maximum number of vowels to 0\\n        int temp = 0;  // Initialize a temporary count of vowels in the current window\\n\\n        // Loop through the string with a sliding window approach\\n        while(end < n){\\n            // If the current character is a vowel, increment the temporary count\\n            if(isVowel(s[end])){\\n               temp++;\\n           }\\n          \\n           // If the window size is equal to k+1, slide the window by moving the start pointer\\n           if(end-start == k ){\\n               if(isVowel(s[start])){\\n                   temp--;  // Decrement the temporary count if the first character in the window is a vowel\\n               }\\n               start++;  \\n           }\\n           \\n           ans = max(ans, temp);  // Update the maximum number of vowels found so far\\n           end++;  // Move the end pointer to expand the window\\n        }\\n        \\n        return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487875,
                "title": "java-simple-solution-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks to find the maximum number of vowels in any sub-string of length k in the given string s. To solve the problem, the solution uses a sliding window approach. We keep a window of size k and slide it through the string s to calculate the count of vowels in the current window. We maintain the maximum count of vowels found so far, which is the required answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize the variables n, maxVowels, and count to 0. n is the length of the input string s, maxVowels will store the maximum number of vowels found so far, and count will store the number of vowels in the current window of size k.\\n\\nCreate an array vowels of size 128 to store the count of vowels for each character. Set the value of vowels[\\'a\\'], vowels[\\'e\\'], vowels[\\'i\\'], vowels[\\'o\\'], and vowels[\\'u\\'] to 1, and for all other characters, the value is 0.\\n\\nIterate from i = 0 to k-1 and calculate the number of vowels in the first window of size k. Update the count variable to store the number of vowels in the current window.\\n\\nSet the value of maxVowels to count, as this is the maximum number of vowels in any sub-string of length k that ends at the kth position.\\n\\nIterate from i = k to n-1, sliding the window of size k through the input string s. Update the count variable by subtracting the count of the first character in the previous window and adding the count of the last character in the current window.\\n\\nUpdate the maxVowels variable to store the maximum count of vowels found so far.\\n\\nIf the value of maxVowels equals k, we have found a sub-string that contains all k vowels, and we can return k.\\n\\nFinally, return the value of maxVowels as the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int n = s.length();\\n        int maxVowels = 0;\\n        int count = 0;\\n\\n        int[] vowels = new int[128];\\n        vowels[\\'a\\'] = 1;\\n        vowels[\\'e\\'] = 1;\\n        vowels[\\'i\\'] = 1;\\n        vowels[\\'o\\'] = 1;\\n        vowels[\\'u\\'] = 1;\\n\\n        for (int i = 0; i < k; i++) {\\n            count += vowels[s.charAt(i)];\\n        }\\n\\n        maxVowels = count;\\n        for (int i = k; i < n; i++) {\\n            count += vowels[s.charAt(i)] - vowels[s.charAt(i - k)];\\n            maxVowels = Math.max(maxVowels, count);\\n            //System.out.println(Arrays.toString(vowels));\\n            if (maxVowels == k) {\\n                return maxVowels; \\n            }\\n        }\\n        return maxVowels;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int n = s.length();\\n        int maxVowels = 0;\\n        int count = 0;\\n\\n        int[] vowels = new int[128];\\n        vowels[\\'a\\'] = 1;\\n        vowels[\\'e\\'] = 1;\\n        vowels[\\'i\\'] = 1;\\n        vowels[\\'o\\'] = 1;\\n        vowels[\\'u\\'] = 1;\\n\\n        for (int i = 0; i < k; i++) {\\n            count += vowels[s.charAt(i)];\\n        }\\n\\n        maxVowels = count;\\n        for (int i = k; i < n; i++) {\\n            count += vowels[s.charAt(i)] - vowels[s.charAt(i - k)];\\n            maxVowels = Math.max(maxVowels, count);\\n            //System.out.println(Arrays.toString(vowels));\\n            if (maxVowels == k) {\\n                return maxVowels; \\n            }\\n        }\\n        return maxVowels;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653707,
                "title": "java-100-faster-o-n-time-o-1-space-sliding-window",
                "content": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int vowel = 0;\\n        for(int i =0; i< k; i++)\\n            if(isVowel(s.charAt(i))) vowel++;\\n        int max = vowel;\\n        for(int i = k; i < s.length(); i++){\\n            if(isVowel(s.charAt(i))) vowel++;\\n            if(isVowel(s.charAt(i-k))) vowel--;\\n            max = Math.max(max, vowel);\\n        }\\n        return max;\\n    }\\n    private boolean isVowel(char c){\\n        if((c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')) return true;\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int maxVowels(String s, int k) {\\n        int vowel = 0;\\n        for(int i =0; i< k; i++)\\n            if(isVowel(s.charAt(i))) vowel++;\\n        int max = vowel;\\n        for(int i = k; i < s.length(); i++){\\n            if(isVowel(s.charAt(i))) vowel++;\\n            if(isVowel(s.charAt(i-k))) vowel--;\\n            max = Math.max(max, vowel);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 648272,
                "title": "java-straight-forward-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public static boolean check(char ch) {\\n        return (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' | ch == \\'o\\' || ch == \\'u\\');\\n    }\\n    public int maxVowels(String s, int k) {\\n        int max = 0, n = s.length();\\n        int count = 0;\\n        for(int i = 0; i < k; i++) {\\n            if(check(s.charAt(i))) count++;\\n        }\\n        max = count;\\n\\t\\t// build first window size k\\n        for(int  i = k; i < n; i++) {\\n\\t\\t\\t// remove the contribution of the (i - k)th character which is no longer in the window\\n            if(check(s.charAt(i - k))) count--;\\n\\t\\t\\t// add the contribution of the current character\\n            if(check(s.charAt(i))) count++;\\n\\t\\t\\t// update max at for each window of size k\\n            max = Math.max(max, count);\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static boolean check(char ch) {\\n        return (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' | ch == \\'o\\' || ch == \\'u\\');\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3488221,
                "title": "efficient-java-solution-for-finding-maximum-number-of-vowels-in-substring-of-given-length",
                "content": "# Intuition\\nThe problem requires us to find the substring of length k in the given string s that contains the maximum number of vowels. We can use a sliding window approach to solve this problem efficiently.\\n\\nIn a sliding window approach, we consider a window of fixed size and move it through the string, one character at a time. We maintain some state related to the current window (e.g., the sum of elements in the window) and update this state as we move the window. \\n\\n# Approach\\nWe initialize two variables, maxVowels and windowVowels, to zero. maxVowels will hold the maximum number of vowels found in a substring of length k, and windowVowels will hold the number of vowels in the current window.\\n\\nWe create a set vowels that contains all the vowels. We will use this set to check if a character is a vowel.\\n\\nWe count the number of vowels in the first window of length k by iterating over the first k characters of s. If a character is a vowel, we increment windowVowels. We also set maxVowels to windowVowels, since this is the maximum number of vowels found so far.\\n\\nWe slide the window one character to the right at a time. For each new character, we update windowVowels by subtracting the number of vowels that just left the window (i.e., the character that was k characters ago) and adding the number of vowels that just entered the window (i.e., the current character). We also update maxVowels if windowVowels is greater than maxVowels.\\n\\nFinally, we return maxVowels.\\n\\nHere\\'s an example to illustrate how the sliding window approach works:\\n\\nSuppose s = \"leetcodeisawesome\" and k = 5. We want to find the substring of length k = 5 in s that contains the maximum number of vowels.\\n\\nWe start with the first window of length k, which is \"leetc\". There are two vowels (e and e) in this window, so we set maxVowels and windowVowels to 2.\\n\\nWe slide the window one character to the right to get the next window, which is \"eetco\". We subtract the vowel that just left the window (l) and add the vowel that just entered the window (o). There are still two vowels (e and e) in this window, so we don\\'t update maxVowels.\\n\\nWe slide the window one character to the right again to get the next window, which is \"etcoi\". We subtract the vowel that just left the window (e) and add the vowel that just entered the window (i). There are still two vowels (e and i) in this window, so we don\\'t update maxVowels.\\n\\nWe continue sliding the window one character to the right at a time and updating windowVowels and `max\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int maxVowels = 0;\\n        int windowVowels = 0;\\n        \\n        Set<Character> vowels = new HashSet<>();\\n        vowels.add(\\'a\\');\\n        vowels.add(\\'e\\');\\n        vowels.add(\\'i\\');\\n        vowels.add(\\'o\\');\\n        vowels.add(\\'u\\');\\n        // Count the number of vowels in the first window\\n        for (int i = 0; i < k; i++) {\\n            if (vowels.contains(s.charAt(i))) {\\n                windowVowels++;\\n            }\\n        }\\n        maxVowels = windowVowels;\\n        // Slide the window and update the maximum number of vowels\\n        for (int i = k; i < s.length(); i++) {\\n            if (vowels.contains(s.charAt(i - k))) {\\n                windowVowels--;\\n            }\\n            if (vowels.contains(s.charAt(i))) {\\n                windowVowels++;\\n            }\\n            maxVowels = Math.max(maxVowels, windowVowels);\\n        }\\n        \\n        return maxVowels;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int maxVowels = 0;\\n        int windowVowels = 0;\\n        \\n        Set<Character> vowels = new HashSet<>();\\n        vowels.add(\\'a\\');\\n        vowels.add(\\'e\\');\\n        vowels.add(\\'i\\');\\n        vowels.add(\\'o\\');\\n        vowels.add(\\'u\\');\\n        // Count the number of vowels in the first window\\n        for (int i = 0; i < k; i++) {\\n            if (vowels.contains(s.charAt(i))) {\\n                windowVowels++;\\n            }\\n        }\\n        maxVowels = windowVowels;\\n        // Slide the window and update the maximum number of vowels\\n        for (int i = k; i < s.length(); i++) {\\n            if (vowels.contains(s.charAt(i - k))) {\\n                windowVowels--;\\n            }\\n            if (vowels.contains(s.charAt(i))) {\\n                windowVowels++;\\n            }\\n            maxVowels = Math.max(maxVowels, windowVowels);\\n        }\\n        \\n        return maxVowels;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487688,
                "title": "python-short-and-clean-code",
                "content": "# Intuition\\nUse `cnt` to count the number of vowels in the window with the size of `k`. \\nAnd`ans` is the maximum of `cnt`.\\n\\n# Approach\\nWhen moving the window, check whether `s[i-k]` and `s[i]` are vowels.  And remember to update `ans`.\\n\\nNote : maximum of `ans` is `k`, we can break if `ans` == `k`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = frozenset(\"aeiou\")\\n        cnt = ans = sum(s[i] in vowels for i in range(k))\\n        if ans != k:\\n            for i in range(k, len(s)):\\n                cnt += (s[i] in vowels) - (s[i - k] in vowels)\\n                if (ans := max(cnt, ans)) == k:\\n                    break\\n        return ans\\n```\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = frozenset(\"aeiou\")\\n        cnt = ans = sum(s[i] in vowels for i in range(k))\\n        if ans != k:\\n            for i in range(k, len(s)):\\n                cnt += (s[i] in vowels) - (s[i - k] in vowels)\\n                ans = max(cnt, ans)\\n        return ans\\n```\\n\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = frozenset(\"aeiou\")\\n        cnt = ans = sum(s[i] in vowels for i in range(k))\\n        for i in range(k, len(s)):\\n            cnt += (s[i] in vowels) - (s[i - k] in vowels)\\n            ans = max(cnt, ans)\\n        return ans\\n```\\n\\n# Related Problems Solutions\\n1. [2090. K Radius Subarray Averages](https://leetcode.com/problems/k-radius-subarray-averages/solutions/3659083/python-short-and-clean-code-sliding-window/)\\n\\n\\n**THX for reading. \\nI would appreciate it very much if you would upvote this.**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = frozenset(\"aeiou\")\\n        cnt = ans = sum(s[i] in vowels for i in range(k))\\n        if ans != k:\\n            for i in range(k, len(s)):\\n                cnt += (s[i] in vowels) - (s[i - k] in vowels)\\n                if (ans := max(cnt, ans)) == k:\\n                    break\\n        return ans\\n```\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = frozenset(\"aeiou\")\\n        cnt = ans = sum(s[i] in vowels for i in range(k))\\n        if ans != k:\\n            for i in range(k, len(s)):\\n                cnt += (s[i] in vowels) - (s[i - k] in vowels)\\n                ans = max(cnt, ans)\\n        return ans\\n```\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = frozenset(\"aeiou\")\\n        cnt = ans = sum(s[i] in vowels for i in range(k))\\n        for i in range(k, len(s)):\\n            cnt += (s[i] in vowels) - (s[i - k] in vowels)\\n            ans = max(cnt, ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486544,
                "title": "java-sliding-window-8-lines-clean-simple",
                "content": "# Intuition\\nUse a sliding window of fixed size `k`, starting from index `0` till index `n-1-k`. Compute the count of vowels within the sliding window at each index, and keep track of the maximum value across all the windows.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private boolean isVowel(char c) {\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n  }\\n\\n  public int maxVowels(String s, int k) {\\n    int cnt = 0, max = 0;\\n\\n    for (var i=0; i < s.length(); i++) {\\n      if (isVowel(s.charAt(i))) cnt++;\\n      if (i >= k && isVowel(s.charAt(i-k))) cnt--;\\n      \\n      max = Math.max(max, cnt);\\n    }\\n    return max;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n  private boolean isVowel(char c) {\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n  }\\n\\n  public int maxVowels(String s, int k) {\\n    int cnt = 0, max = 0;\\n\\n    for (var i=0; i < s.length(); i++) {\\n      if (isVowel(s.charAt(i))) cnt++;\\n      if (i >= k && isVowel(s.charAt(i-k))) cnt--;\\n      \\n      max = Math.max(max, cnt);\\n    }\\n    return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488146,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this code is to find the maximum number of vowels in any substring of length k in the given string s. To achieve this, we first create a HashSet of vowels, which will allow us to quickly check if a given character is a vowel or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we initialize a variable vcount to 0 and iterate over the first k characters of s, counting the number of vowels in this substring. This gives us the initial value of vcount.\\n\\nNext, we initialize three variables: max to vcount (since this is the maximum number of vowels seen so far), left to 0, and right to k-1 (since these are the indices of the current substring we are examining).\\n\\nWe then enter a while loop that will continue as long as right is less than the length of the string minus 1 (i.e., there are still substrings of length k that we haven\\'t examined yet). Inside the loop, we first check if the character at index left is a vowel; if it is, we decrement vcount (since this vowel is no longer part of the current substring). We then increment left and right to move the substring to the right by one character. Finally, we check if the character at index right is a vowel; if it is, we increment vcount (since this vowel is now part of the current substring). We update max to be the maximum of its current value and vcount, since this gives us the maximum number of vowels seen in any substring so far.\\n\\nOnce the loop finishes, we return max as the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        List<Character> v = Arrays.asList(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\');\\n        Set<Character> vowels = new HashSet<Character>(v);\\n\\n        int vcount =0;\\n        for(int i=0 ;i<k; i++){\\n            if(vowels.contains(s.charAt(i))) vcount++;\\n        }\\n\\n        int max = vcount;\\n        int left =0;\\n        int right = k-1;\\n        while(right<s.length()-1){\\n            if(vowels.contains(s.charAt(left))) vcount--;\\n            left++;\\n            right++;\\n            if(vowels.contains(s.charAt(right))) vcount++;\\n            max = Math.max(max, vcount);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        List<Character> v = Arrays.asList(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\');\\n        Set<Character> vowels = new HashSet<Character>(v);\\n\\n        int vcount =0;\\n        for(int i=0 ;i<k; i++){\\n            if(vowels.contains(s.charAt(i))) vcount++;\\n        }\\n\\n        int max = vcount;\\n        int left =0;\\n        int right = k-1;\\n        while(right<s.length()-1){\\n            if(vowels.contains(s.charAt(left))) vcount--;\\n            left++;\\n            right++;\\n            if(vowels.contains(s.charAt(right))) vcount++;\\n            max = Math.max(max, vcount);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486946,
                "title": "c-easy-solution-of-unordered-map-and-sliding-window",
                "content": "## **\\u2705\\u2705C++ Easy Solution of Unordered Map and Sliding window**\\n# **Please Upvote as it really motivates me**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n=s.size(),ans=0,cur=0;\\n        unordered_map<char,int>m;\\n        m[\\'a\\']++,m[\\'e\\']++,m[\\'i\\']++,m[\\'o\\']++,m[\\'u\\']++;\\n        for(int i=0;i<n;i++){\\n            if(i<k){\\n                cur+=m.count(s[i]);\\n            }\\n            else{\\n                cur+=m.count(s[i])-m.count(s[i-k]);\\n            }\\n            ans=max(ans,cur);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n=s.size(),ans=0,cur=0;\\n        unordered_map<char,int>m;\\n        m[\\'a\\']++,m[\\'e\\']++,m[\\'i\\']++,m[\\'o\\']++,m[\\'u\\']++;\\n        for(int i=0;i<n;i++){\\n            if(i<k){\\n                cur+=m.count(s[i]);\\n            }\\n            else{\\n                cur+=m.count(s[i])-m.count(s[i-k]);\\n            }\\n            ans=max(ans,cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648314,
                "title": "c-concise-solution-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        map<int, int> vow;\\n        vow[\\'a\\'] = 1;vow[\\'e\\'] = 1;vow[\\'i\\'] = 1;vow[\\'o\\'] = 1;vow[\\'u\\'] = 1;\\n        int ans = 0, cnt = 0;\\n        for(int i = 0; i < s.size(); ++i) {\\n            cnt += vow[s[i]];\\n            if(i >= k)\\n                cnt -= vow[s[i-k]];\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        map<int, int> vow;\\n        vow[\\'a\\'] = 1;vow[\\'e\\'] = 1;vow[\\'i\\'] = 1;vow[\\'o\\'] = 1;vow[\\'u\\'] = 1;\\n        int ans = 0, cnt = 0;\\n        for(int i = 0; i < s.size(); ++i) {\\n            cnt += vow[s[i]];\\n            if(i >= k)\\n                cnt -= vow[s[i-k]];\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648309,
                "title": "python3-easy-sliding-window",
                "content": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        res = j = vowels = 0\\n        for i, c in enumerate(s):\\n            vowels += c in \\'aeiou\\' \\n            if i - j + 1 > k:\\n                vowels -= s[j] in \\'aeiou\\'\\n                j += 1    \\n            if i - j + 1 == k:    \\n                res = max(res, vowels)\\n        return res \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        res = j = vowels = 0\\n        for i, c in enumerate(s):\\n            vowels += c in \\'aeiou\\' \\n            if i - j + 1 > k:\\n                vowels -= s[j] in \\'aeiou\\'\\n                j += 1    \\n            if i - j + 1 == k:    \\n                res = max(res, vowels)\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487120,
                "title": "short-and-concise-python-solution-sliding-window",
                "content": "# Code\\n```python3\\ndef maxVowels(self, s: str, k: int) -> int:\\n    VOWELS = \"aeiou\"\\n    window = res = 0\\n    for r in range(len(s)):\\n        window += s[r] in VOWELS\\n        if r >= k:\\n            window -= s[r - k] in VOWELS\\n        res = max(res, window)\\n    return res\\n```\\n\\n* `window` keeps track of how many vowels are in the current window.\\n* `res` keeps track of the maximum number of vowels that we have seen in a window.\\n* `if r >= k` condition helps restrict window size to `k`.\\n\\n[Prepping for an interview? Jump to the interview tips section.](#in-an-interview)\\n\\n# Intuition\\n\\n> Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k.\\n\\nThe words **\"substring\"** and **\"with length k\"** hints a sliding window solution. When moving from a new window `[i, i + k]` to `[i + 1, i + k + 1]`, it\\'s easy to calculate the number of vowels in the new window: we only need to consider the number of vowels in the current window and the characters at index `i` and `i + k + 1`.\\n\\n*(Please ignore the next paragraph if you\\'re only preparing for interviews. See **Interview** section for more hints.)*\\nChecking all substrings will likely cause TLE, because the length of the string is at most `10^5`, and `k` could be up to `10^5`. Doing a simple multiplication gives `10^10` (not accurate, more of an upper bound). Assuming a machine processes `10^6` operations per second, processing `10^10` operations takes `10^4` seconds (or, ~2 hours and 47 minutes).\\n\\n# Complexity\\n- Time complexity: `O(n)`, where `n` is the length of `s`.\\n\\n- Space complexity: `O(1)`\\n\\n# In an Interview?\\n\\n1. **Ask clarifying questions.** *e.g.,*\\n* Is the string `s` only containing lower case letters? If not, how to handle special characters?\\n* Are vowels case sensitive?\\n* Can `k` be 0? Can `k` be larger than the size of the string `s`?\\n* What happens if there is an empty string being passed in?\\n\\n2. **Do not make assumptions about the input; unless otherwise given.** *e.g.,*\\n* \"How will the input be given? Can I assume that it will be passed in as an array?\"\\n\\n3. **Start by mentioning the brute-force solution.** *e.g.,*\\n* \"The easiest way is to iterate over the string `s` and check every substring of size `k`. This will take `O(nk)` runtime, where `n` is the length of `s`.\\n\\n4. **Move on to the optimized solution.** *e.g.,*\\n* \"If we calculate the number of vowels for every substring of size `k`, we are doing a lot of repeated work. We can minimze this repeated work by using the result from a \\'previous\\' substring.\"\\n\\n5. **Think about how the data looks like; write some test cases.**\\n* Pass in an empty string, if applicable;\\n* Pass in `k=0`, if applicable;\\n* Pass in a string `s` with special characters, if applicable;\\n* ...\\n\\n**I appreciate your upvote! This helps good posts to be seen by more people, and motivates me to write more. Thanks for your time!**",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```python3\\ndef maxVowels(self, s: str, k: int) -> int:\\n    VOWELS = \"aeiou\"\\n    window = res = 0\\n    for r in range(len(s)):\\n        window += s[r] in VOWELS\\n        if r >= k:\\n            window -= s[r - k] in VOWELS\\n        res = max(res, window)\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3486912,
                "title": "easiest-sliding-window-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor a window of length k, we are keeping track of count of vowels in count variable.\\nFor each window, we are calculating the max/(maxi in our code) value of vowel count, and returning the answer at end.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is how each iteration will look like.\\n![2.png](https://assets.leetcode.com/users/images/e13589b3-1275-428a-84a2-34eeba94f4bb_1683254981.145182.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\nO(N)\\n```\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nO(1)\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(char c){\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\')return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        int ans=0;\\n        int count=0;\\n        for(int i=0;i<k;i++){\\n            if(check(s[i]))count++;\\n        }\\n        ans=count;\\n        int i=0,j=k;\\n        while(j<s.size()){\\n            if(check(s[j]))count++;\\n            if(check(s[i]))count--;\\n            ans=max(ans,count);\\n            j++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nO(N)\\n```\n```\\nO(1)\\n```\n```\\nclass Solution {\\npublic:\\n    bool check(char c){\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\')return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        int ans=0;\\n        int count=0;\\n        for(int i=0;i<k;i++){\\n            if(check(s[i]))count++;\\n        }\\n        ans=count;\\n        int i=0,j=k;\\n        while(j<s.size()){\\n            if(check(s[j]))count++;\\n            if(check(s[i]))count--;\\n            ans=max(ans,count);\\n            j++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504290,
                "title": "python3-simple-soluton",
                "content": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        x = 0\\n        for i in range(k):\\n            if s[i] in (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'):\\n                x += 1\\n        ans = x\\n        for i in range(k,len(s)):\\n            if s[i] in (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'):\\n                x += 1\\n            if s[i-k] in (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'):\\n                x -= 1\\n            ans = max(ans,x)\\n        return ans\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        x = 0\\n        for i in range(k):\\n            if s[i] in (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'):\\n                x += 1\\n        ans = x\\n        for i in range(k,len(s)):\\n            if s[i] in (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'):\\n                x += 1\\n            if s[i-k] in (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'):\\n                x -= 1\\n            ans = max(ans,x)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490026,
                "title": "sliding-window-implemented-in-o-n-k-c-solution",
                "content": "# **Approach:**\\nFirst, we take the count of the vowels in the \"k\" size window than move the window ahead by one and check the new symbol is vowel or not, if it is a vowel than increment count. Also, check the one alphabet which we let go from left if if that was vowel or not.\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:    \\n    int maxVowels(string str, int k) {\\n        \\n        int n=str.size(), count=0;\\n        for( int i=0 ; i<n&&i<k ; i++ ){\\n            \\n            if( str[i]==\\'a\\' or str[i]==\\'e\\' or str[i]==\\'i\\' or str[i]==\\'o\\' or str[i]==\\'u\\' ){\\n                cout << str[i] << \" \" ;\\n                count+=1;\\n            }\\n        }\\n        \\n        int maxval = count;\\n\\n        \\n        for( int i=1 ; i<n-k+1 ; i++ ){\\n            if( str[i-1]==\\'a\\' or str[i-1]==\\'e\\' or str[i-1]==\\'i\\' or str[i-1]==\\'o\\' or str[i-1]==\\'u\\' ){\\n                count-=1;\\n            } \\n            if( str[i+k-1]==\\'a\\' or str[i+k-1]==\\'e\\' or str[i+k-1]==\\'i\\' or str[i+k-1]==\\'o\\' or str[i+k-1]==\\'u\\'){\\n                count+=1;\\n            }\\n            maxval = max( maxval, count );\\n        }\\n        return maxval;\\n    }\\n};\\n```\\nIf you\\'ve made it here, please upvote.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int maxVowels(string str, int k) {\\n        \\n        int n=str.size(), count=0;\\n        for( int i=0 ; i<n&&i<k ; i++ ){\\n            \\n            if( str[i]==\\'a\\' or str[i]==\\'e\\' or str[i]==\\'i\\' or str[i]==\\'o\\' or str[i]==\\'u\\' ){\\n                cout << str[i] << \" \" ;\\n                count+=1;\\n            }\\n        }\\n        \\n        int maxval = count;\\n\\n        \\n        for( int i=1 ; i<n-k+1 ; i++ ){\\n            if( str[i-1]==\\'a\\' or str[i-1]==\\'e\\' or str[i-1]==\\'i\\' or str[i-1]==\\'o\\' or str[i-1]==\\'u\\' ){\\n                count-=1;\\n            } \\n            if( str[i+k-1]==\\'a\\' or str[i+k-1]==\\'e\\' or str[i+k-1]==\\'i\\' or str[i+k-1]==\\'o\\' or str[i+k-1]==\\'u\\'){\\n                count+=1;\\n            }\\n            maxval = max( maxval, count );\\n        }\\n        return maxval;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3488127,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "# Intuition\\n- Sliding Window Concept\\n- Select subsequent substring and count vowels in it.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First we will select first substring of length and count number of vowels in it.\\n- Then, we are going select next window. On moving to next window, we are going to remove first charcter of last substring and add next charcter. \\n- For example: if string s = \"aabcdee\", k = 3, first substring is \"aab\", no. of vowels(say vow) is 2, next substring is \"abc\", ie we have removed first \\'a\\' from substring \"aab\" and added (0+k)th element ie \\'c\\'. Now, on removing \\'a\\', vow = vow - 1 = 1, and adding \\'c\\' will not affect vow. Similarly we check through the string.\\nCode goes like : \\n    1. Run a for loop from i = 0 to k-1, calculate vow(i.e., no. of vowels).\\n    2. Run another for loop from i = 0 to n-k, if(s[i] is vowel) then vow is decreased by 1. Check if(s[i+k] is vowel) vow is increased by 1.\\n    3. Keep track of highest value of vow.\\n    4. Return answer\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n = s.size(), vow = 0, ans;\\n        for(int i = 0; i < k; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\')\\n                vow++;\\n        }\\n        ans = vow;\\n        for(int i = 0; i < n-k; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\') vow--;\\n            if(s[i+k] == \\'a\\' || s[i+k] == \\'e\\' || s[i+k] == \\'i\\' || s[i+k] == \\'o\\' || s[i+k] == \\'u\\') \\n                vow++;\\n            ans = max(ans, vow);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n = s.size(), vow = 0, ans;\\n        for(int i = 0; i < k; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\')\\n                vow++;\\n        }\\n        ans = vow;\\n        for(int i = 0; i < n-k; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\') vow--;\\n            if(s[i+k] == \\'a\\' || s[i+k] == \\'e\\' || s[i+k] == \\'i\\' || s[i+k] == \\'o\\' || s[i+k] == \\'u\\') \\n                vow++;\\n            ans = max(ans, vow);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487122,
                "title": "java-easy-solution-beginner-friendly-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code implements a sliding window approach to find the maximum number of vowels in a substring of length k in a given string. It uses a variable sum to keep track of the number of vowels in the current window and updates it at each step by adding the vowel count of the new character and subtracting the vowel count of the character that has just left the window. It also keeps track of the maximum sum seen so far in a variable ans and returns it at the end of the loop.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n![download (15).jfif](https://assets.leetcode.com/users/images/98d5121b-bd68-45d5-88cf-963020d28768_1683259142.9221802.jpeg)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ? 1 : 0;\\n    }\\n    public int maxVowels(String s, int k) {\\n        int sum = 0, ans = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i < k)\\n                sum += isVowel(s.charAt(i));\\n            else {\\n                sum += isVowel(s.charAt(i));\\n                sum -= isVowel(s.charAt(i - k));\\n            }\\n            if (ans < sum)\\n                ans = sum;\\n            if (ans == k)\\n                return k;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ? 1 : 0;\\n    }\\n    public int maxVowels(String s, int k) {\\n        int sum = 0, ans = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i < k)\\n                sum += isVowel(s.charAt(i));\\n            else {\\n                sum += isVowel(s.charAt(i));\\n                sum -= isVowel(s.charAt(i - k));\\n            }\\n            if (ans < sum)\\n                ans = sum;\\n            if (ans == k)\\n                return k;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698949,
                "title": "javascript-sliding-window-explained-possible-early-exit",
                "content": "```\\nvar maxVowels = function(s, k) {\\n    let vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n    let maxCount = 0;\\n    let start = 0; // the left edge of the window\\n    let count = 0; // count of vowels for current substring\\n\\t// expanding the right edge of the window one character at a time\\n    for (let end = 0; end < s.length; end++) {\\n\\t    // increment count of vowels for current substring if the current character is present in vowels array\\n        if (vowels.includes(s[end])) {\\n            count +=1;\\n        }\\n        // if substring is longer than K, let\\'s shrink the window by moving left edge\\n        if (end - start + 1 > k) {\\n\\t\\t\\t// reduce the current count by one if the character on the left edge is vowel\\n            if(vowels.includes(s[start])) {\\n                count -=1;\\n            }\\n\\t\\t\\t//shrinking the left edge of the window\\n            start +=1;\\n        }\\n\\t\\t// checking if current count is larger than current maximum count\\n        maxCount = Math.max(maxCount, count)\\n\\t\\t// if maxCount is equal to K, no need to check further, it is the max possible count\\n        if (maxCount == k) return maxCount;\\n    }\\n    return maxCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar maxVowels = function(s, k) {\\n    let vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n    let maxCount = 0;\\n    let start = 0; // the left edge of the window\\n    let count = 0; // count of vowels for current substring\\n\\t// expanding the right edge of the window one character at a time\\n    for (let end = 0; end < s.length; end++) {\\n\\t    // increment count of vowels for current substring if the current character is present in vowels array\\n        if (vowels.includes(s[end])) {\\n            count +=1;\\n        }\\n        // if substring is longer than K, let\\'s shrink the window by moving left edge\\n        if (end - start + 1 > k) {\\n\\t\\t\\t// reduce the current count by one if the character on the left edge is vowel\\n            if(vowels.includes(s[start])) {\\n                count -=1;\\n            }\\n\\t\\t\\t//shrinking the left edge of the window\\n            start +=1;\\n        }\\n\\t\\t// checking if current count is larger than current maximum count\\n        maxCount = Math.max(maxCount, count)\\n\\t\\t// if maxCount is equal to K, no need to check further, it is the max possible count\\n        if (maxCount == k) return maxCount;\\n    }\\n    return maxCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248940,
                "title": "my-o-n-soln-c-begineer-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) \\n    {\\n        queue<char> q;\\n        int cnt=0;\\n        int maxi=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            q.push(s[i]);\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' ||s[i]==\\'i\\' ||s[i]==\\'o\\' ||s[i]==\\'u\\' )\\n            {\\n                cnt++;\\n            }\\n            if(q.size()==k)\\n            {\\n                maxi=max(maxi,cnt);\\n                char c= q.front();\\n                if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' ||c==\\'o\\' ||c==\\'u\\')\\n                {\\n                    cnt--;\\n                }\\n                q.pop();\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) \\n    {\\n        queue<char> q;\\n        int cnt=0;\\n        int maxi=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            q.push(s[i]);\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' ||s[i]==\\'i\\' ||s[i]==\\'o\\' ||s[i]==\\'u\\' )\\n            {\\n                cnt++;\\n            }\\n            if(q.size()==k)\\n            {\\n                maxi=max(maxi,cnt);\\n                char c= q.front();\\n                if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' ||c==\\'o\\' ||c==\\'u\\')\\n                {\\n                    cnt--;\\n                }\\n                q.pop();\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487756,
                "title": "java-o-n-solution-with-explanation",
                "content": "# Please upvote if you like it :)\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery time check a character is vowel or not.If it is a vowel then increase your count of vowel.When the substring size is greater than or equal to given value **k** you can find max vowels in the substring in each pass, after that find the first character of the substring is vowel or not.If it is vowel then decrease the count of vowel for the next pass.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Example str = \"abciiidef\" k=\\'3\\'\\n- when our pointer at \\'c\\' the index value is 2 & substring is \"abc\" now number of vowels are 1.\\n- Now before going to next pass we have to check the first character of our substring is vowel or not.Our substring is \"abc\" our first character is \\'a\\' it is vowel so we have to decrease the count of vowel by one.Now our vowel count is 0. \\n- In next step our substring is \"bci\" number of vowels are now 1 because we have vowel at \\'3rd\\' index i.e \\'i\\'.\\n- We have to follow the above step till end of the string , we get max vowels of substring as \\'3\\' i.e \"iii\".\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n    boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n    public int maxVowels(String s, int k) {\\n        int maxVowels = 0;\\n        int vowels = 0;\\n        for(int i = 0;i<s.length();i++) {\\n            if(isVowel(s.charAt(i))) vowels++;\\n            if((i+1)>=k) { //When the substring length is >=k then only we should start finding the max vowels.\\n                maxVowels = Math.max(maxVowels,vowels);\\n                if(i-(k-1)>=0) { //To check first character is vowel or not\\n                    if(isVowel(s.charAt(i-(k-1)))) vowels--;\\n                }\\n            }\\n        }\\n        return maxVowels;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n    public int maxVowels(String s, int k) {\\n        int maxVowels = 0;\\n        int vowels = 0;\\n        for(int i = 0;i<s.length();i++) {\\n            if(isVowel(s.charAt(i))) vowels++;\\n            if((i+1)>=k) { //When the substring length is >=k then only we should start finding the max vowels.\\n                maxVowels = Math.max(maxVowels,vowels);\\n                if(i-(k-1)>=0) { //To check first character is vowel or not\\n                    if(isVowel(s.charAt(i-(k-1)))) vowels--;\\n                }\\n            }\\n        }\\n        return maxVowels;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215394,
                "title": "sliding-window-aditya-verma-s-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- SLIDING WINDOW\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The given code implements a sliding window approach to find the maximum number of vowels in a substring of length k in the given string s.\\n\\n- The main idea is to use two pointers, i and j, to represent the left and right endpoints of the sliding window, respectively. The variable count is used to keep track of the number of vowels in the current window. The variable maxNo is used to store the maximum number of vowels seen so far in any window of size k.\\n\\n- The loop starts with both pointers i and j at the beginning of the string. The code then checks if the current character at j is a vowel or not. If it is a vowel, the count is incremented.\\n\\n- Next, the code checks if the size of the current window is less than k. If it is, then we move the j pointer to the right and continue.\\n\\n- When the window size becomes equal to k, we check if the current count of vowels is greater than the maxNo seen so far. If it is, then we update maxNo. We also check if the left endpoint of the window, s[i], is a vowel or not. If it is a vowel, then we decrement the count by 1.\\n\\n- We then move both the pointers i and j one step to the right and continue the loop until we have processed all the substrings of length k in the string.\\n\\n- Finally, we return the maxNo as the maximum number of vowels seen in any substring of length k in the given string s.\\n\\n# Complexity\\nTime complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The time complexity of the given algorithm is O(n), where n is the length of the input string s. This is because we traverse the string s only once using the two pointers i and j, and at each step, we perform constant time operations such as comparing characters and updating variables.\\n\\nSpace complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity of the given algorithm is O(1), as we use only a constant amount of extra space to store the variables i, j, count, and maxNo. We do not use any extra data structures to store the characters of the input string or the substrings of length k. Therefore, the space complexity does not depend on the size of the input string or the length of the substring k.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) \\n    {\\n        int n = s.size();\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        int maxNo = INT_MIN;\\n\\n        while(j < n)\\n        {\\n            if(s[j] == \\'a\\'||s[j] == \\'e\\'||s[j] == \\'i\\'||s[j] == \\'o\\'||s[j] == \\'u\\' )\\n                count++;\\n\\n            if(j - i + 1 < k)\\n                j++;\\n\\n            else if(j - i + 1 == k)\\n            {\\n                maxNo = max(count, maxNo);\\n\\n                if(s[i] == \\'a\\'||s[i] == \\'e\\'||s[i] == \\'i\\'||s[i] == \\'o\\'||s[i] == \\'u\\')\\n                    count--;\\n\\n                j++;\\n                i++;    \\n            }        \\n        }\\n        return maxNo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) \\n    {\\n        int n = s.size();\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        int maxNo = INT_MIN;\\n\\n        while(j < n)\\n        {\\n            if(s[j] == \\'a\\'||s[j] == \\'e\\'||s[j] == \\'i\\'||s[j] == \\'o\\'||s[j] == \\'u\\' )\\n                count++;\\n\\n            if(j - i + 1 < k)\\n                j++;\\n\\n            else if(j - i + 1 == k)\\n            {\\n                maxNo = max(count, maxNo);\\n\\n                if(s[i] == \\'a\\'||s[i] == \\'e\\'||s[i] == \\'i\\'||s[i] == \\'o\\'||s[i] == \\'u\\')\\n                    count--;\\n\\n                j++;\\n                i++;    \\n            }        \\n        }\\n        return maxNo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489535,
                "title": "o-n-time-and-o-1-space-py",
                "content": "# Approach\\nSliding Window\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        def vow(n):\\n            return n==\\'a\\' or n==\\'e\\' or n==\\'i\\' or n==\\'o\\' or n==\\'u\\'\\n        ans=0\\n        for i in range(k):\\n            if vow(s[i]):\\n                ans+=1\\n        m_ans=ans\\n        for i in range(k,len(s),1):\\n            if vow(s[i-k]):ans-=1\\n            if vow(s[i]):ans+=1\\n            m_ans=max(ans,m_ans)\\n        return m_ans\\n\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        def vow(n):\\n            return n==\\'a\\' or n==\\'e\\' or n==\\'i\\' or n==\\'o\\' or n==\\'u\\'\\n        ans=0\\n        for i in range(k):\\n            if vow(s[i]):\\n                ans+=1\\n        m_ans=ans\\n        for i in range(k,len(s),1):\\n            if vow(s[i-k]):ans-=1\\n            if vow(s[i]):ans+=1\\n            m_ans=max(ans,m_ans)\\n        return m_ans\\n\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487862,
                "title": "c-easy-explanation-o-n-time",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code finds the maximum number of vowels in any k-length substring of a given string `s`. The approach used in the code is a sliding window technique:\\n\\n1. Initialize an unordered_map `uno` to count the number of vowels in the first k characters of the string `s`.\\n2. Sum up the number of vowels in the first k characters of `s`.\\n3. Use a sliding window to find the maximum number of vowels in any k-length substring of `s`:\\n   - Initialize two pointers, `start` and `end`, to the first and `k`th characters of `s`, respectively.\\n   - While `end` is less than the length of `s`, do the following:\\n     - Update the number of vowels in the current k-length substring by:\\n       - Setting a variable `local` to the previous vowel count.\\n       - Removing the first character from the current substring `a` and adding the next character from `s`.\\n       - Checking if the first and last characters of the substring `a` are vowels:\\n         - If the last character is a vowel, increment `local` if the first character is not a vowel.\\n         - If the last character is not a vowel, decrement `local` if the first character is a vowel.\\n       - Update the previous vowel count to the current vowel count by setting `pre` to `local`.\\n     - Update the maximum vowel count found so far by setting `count` to the maximum of `count` and `local`.\\n     - Move the sliding window by incrementing `start` and `end`.\\n4. Return the maximum vowel count found.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n=s.size();\\n        unordered_map<char,int> uno;\\n        string a=s.substr(0,k);\\n        // Count the number of vowels in the first k characters\\n        for(auto i:a)\\n        {\\n            if(i==\\'a\\' ||i==\\'e\\' || i==\\'i\\' || i==\\'o\\' || i==\\'u\\' )\\n            {\\n                uno[i]++;\\n            }\\n        }\\n        int count=0;\\n        // Sum up the number of vowels in the first k characters\\n        for(auto i:uno)\\n        {\\n            count += i.second;\\n        }\\n\\n        int start=0;\\n        int end=k;\\n        int pre=count;\\n\\n        // Use sliding window to find the maximum number of vowels in any k-length substring of s\\n        while(end<n)\\n        {\\n            // Update the number of vowels in the current k-length substring\\n            int local=pre;\\n            // Remove the first character from the substring\\n            a.erase(0,1);\\n            // Add the next character to the substring\\n            a += s[end];\\n            // Check if the first and last characters of the substring are vowels\\n            if(s[end]==\\'a\\' ||s[end]==\\'e\\' || s[end]==\\'i\\' || s[end]==\\'o\\' || s[end]==\\'u\\')\\n            {\\n                // If the first character was not a vowel, increment the vowel count\\n                if(!(s[start]==\\'a\\' ||s[start]==\\'e\\' || s[start]==\\'i\\' || s[start]==\\'o\\' || s[start]==\\'u\\'))\\n                {\\n                    local++;\\n                }\\n            }\\n            else\\n            {\\n                // If the first character was a vowel, decrement the vowel count\\n                if((s[start]==\\'a\\' ||s[start]==\\'e\\' || s[start]==\\'i\\' || s[start]==\\'o\\' || s[start]==\\'u\\'))\\n                {\\n                    local--;\\n                }\\n            }\\n            // Update the previous vowel count to the current vowel count\\n            pre=local;\\n            // Update the maximum vowel count found so far\\n            count=max(local,count);\\n            // Move the sliding window by one character\\n            start++;\\n            end++;\\n        }    \\n        // Return the maximum vowel count found\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n=s.size();\\n        unordered_map<char,int> uno;\\n        string a=s.substr(0,k);\\n        // Count the number of vowels in the first k characters\\n        for(auto i:a)\\n        {\\n            if(i==\\'a\\' ||i==\\'e\\' || i==\\'i\\' || i==\\'o\\' || i==\\'u\\' )\\n            {\\n                uno[i]++;\\n            }\\n        }\\n        int count=0;\\n        // Sum up the number of vowels in the first k characters\\n        for(auto i:uno)\\n        {\\n            count += i.second;\\n        }\\n\\n        int start=0;\\n        int end=k;\\n        int pre=count;\\n\\n        // Use sliding window to find the maximum number of vowels in any k-length substring of s\\n        while(end<n)\\n        {\\n            // Update the number of vowels in the current k-length substring\\n            int local=pre;\\n            // Remove the first character from the substring\\n            a.erase(0,1);\\n            // Add the next character to the substring\\n            a += s[end];\\n            // Check if the first and last characters of the substring are vowels\\n            if(s[end]==\\'a\\' ||s[end]==\\'e\\' || s[end]==\\'i\\' || s[end]==\\'o\\' || s[end]==\\'u\\')\\n            {\\n                // If the first character was not a vowel, increment the vowel count\\n                if(!(s[start]==\\'a\\' ||s[start]==\\'e\\' || s[start]==\\'i\\' || s[start]==\\'o\\' || s[start]==\\'u\\'))\\n                {\\n                    local++;\\n                }\\n            }\\n            else\\n            {\\n                // If the first character was a vowel, decrement the vowel count\\n                if((s[start]==\\'a\\' ||s[start]==\\'e\\' || s[start]==\\'i\\' || s[start]==\\'o\\' || s[start]==\\'u\\'))\\n                {\\n                    local--;\\n                }\\n            }\\n            // Update the previous vowel count to the current vowel count\\n            pre=local;\\n            // Update the maximum vowel count found so far\\n            count=max(local,count);\\n            // Move the sliding window by one character\\n            start++;\\n            end++;\\n        }    \\n        // Return the maximum vowel count found\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487175,
                "title": "js-ts-sets-sliding-windows-and-early-returns-beats-97-92-runtime-91-67-memory",
                "content": "# Intuition\\nSets, Sliding Windows, and Early Returns. Oh my!\\n\\n# Approach\\n\\n1. For simplicity and speed, we place the vowels in a `Set`. \\n2. Using a `for` loop, we get the initial `max` number of vowels in the first window. We set the `current` to `max` before continuing.\\n3. From there, we use the sliding window technique (see code comments) to determine the number of vowels in any given window.\\n4. We set the `max` if the `current` number is greater.\\n\\nWe attempt to return at multiple points in the code if `max` or `current` have hit `k`, seeing as there\\'s no point in continuing. \\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nfunction maxVowels(s: string, k: number): number {\\n  const vowels = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'])\\n\\n  let max = 0 // Max number of vowels in any window\\n  let current = 0 // Number of vowels in the current window\\n\\n  // Count the total number of vowels from the first window\\n  for (let i = 0; i < k; i++) {\\n    if (vowels.has(s[i])) max++\\n  }\\n  \\n  if (max === k) return max // Return if the `k` is hit\\n\\n  current = max // Set the current to the max\\n\\n  // Sliding window technique\\n  for (let i = 1; i <= s.length - k; i++) {\\n    if (vowels.has(s[i - 1])) current-- // Remove the left-most vowel\\n    if (vowels.has(s[i + k - 1])) current++ // Add the right-most vowel\\n\\n    if (current === k) return current // Return if the `k` is hit\\n    if (current > max) max = current // Set `max` to the `current` value, if greater\\n  }\\n\\n  return max\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction maxVowels(s: string, k: number): number {\\n  const vowels = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'])\\n\\n  let max = 0 // Max number of vowels in any window\\n  let current = 0 // Number of vowels in the current window\\n\\n  // Count the total number of vowels from the first window\\n  for (let i = 0; i < k; i++) {\\n    if (vowels.has(s[i])) max++\\n  }\\n  \\n  if (max === k) return max // Return if the `k` is hit\\n\\n  current = max // Set the current to the max\\n\\n  // Sliding window technique\\n  for (let i = 1; i <= s.length - k; i++) {\\n    if (vowels.has(s[i - 1])) current-- // Remove the left-most vowel\\n    if (vowels.has(s[i + k - 1])) current++ // Add the right-most vowel\\n\\n    if (current === k) return current // Return if the `k` is hit\\n    if (current > max) max = current // Set `max` to the `current` value, if greater\\n  }\\n\\n  return max\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486820,
                "title": "easy-java-solution-using-char-array-o-n-time",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\nn is size to string\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int count = 0;\\n        char arr[] = s.toCharArray();\\n        for(int i = 0; i<k; i++){\\n            if(arr[i] == \\'a\\' || arr[i] == \\'e\\' || arr[i] == \\'i\\' || arr[i] == \\'o\\' || arr[i] == \\'u\\')\\n                count++;\\n        }\\n        int max = count;\\n        for(int i = k; i<arr.length; i++){\\n            if(arr[i] == \\'a\\' || arr[i] == \\'e\\' || arr[i] == \\'i\\' || arr[i] == \\'o\\' || arr[i] == \\'u\\')\\n                count++;\\n            if(arr[i-k] == \\'a\\' || arr[i-k] == \\'e\\' || arr[i-k] == \\'i\\' || arr[i-k] == \\'o\\' || arr[i-k] == \\'u\\')\\n                count--;\\n            max = Math.max(count, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int count = 0;\\n        char arr[] = s.toCharArray();\\n        for(int i = 0; i<k; i++){\\n            if(arr[i] == \\'a\\' || arr[i] == \\'e\\' || arr[i] == \\'i\\' || arr[i] == \\'o\\' || arr[i] == \\'u\\')\\n                count++;\\n        }\\n        int max = count;\\n        for(int i = k; i<arr.length; i++){\\n            if(arr[i] == \\'a\\' || arr[i] == \\'e\\' || arr[i] == \\'i\\' || arr[i] == \\'o\\' || arr[i] == \\'u\\')\\n                count++;\\n            if(arr[i-k] == \\'a\\' || arr[i-k] == \\'e\\' || arr[i-k] == \\'i\\' || arr[i-k] == \\'o\\' || arr[i-k] == \\'u\\')\\n                count--;\\n            max = Math.max(count, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 828324,
                "title": "simple-c-code-beating-97",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int i=0,maxsum=0,sum=0,l=0;\\n        while(k--)\\n            if(isvovel(s[i++])) sum++;\\n        maxsum=sum;\\n        while(i<s.length()){\\n            if(isvovel(s[l++])) sum--;\\n            if(isvovel(s[i++])) sum++;\\n            maxsum= maxsum>sum ? maxsum: sum;\\n        }\\n        return maxsum;\\n    }\\n    bool isvovel(char ch){\\n        if(ch==\\'a\\'|| ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\') return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int i=0,maxsum=0,sum=0,l=0;\\n        while(k--)\\n            if(isvovel(s[i++])) sum++;\\n        maxsum=sum;\\n        while(i<s.length()){\\n            if(isvovel(s[l++])) sum--;\\n            if(isvovel(s[i++])) sum++;\\n            maxsum= maxsum>sum ? maxsum: sum;\\n        }\\n        return maxsum;\\n    }\\n    bool isvovel(char ch){\\n        if(ch==\\'a\\'|| ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\') return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911945,
                "title": "java-simple-solution-beginner-friendly-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this solution, we employ a `sliding window` approach of a fixed size k, which slides from index 0 to index` n-1-k` within the given string. At each position of the window, we calculate the count of vowels contained within the window and continuously monitor the maximum count across all windows.\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int currentVowelCount = 0, maxVowelCount = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (isVowel(s.charAt(i))) \\n                currentVowelCount++;\\n            if (i >= k && isVowel(s.charAt(i - k))) \\n                currentVowelCount--;\\n            maxVowelCount = Math.max(maxVowelCount, currentVowelCount);\\n        }\\n        return maxVowelCount;\\n    }\\n\\n    boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int currentVowelCount = 0, maxVowelCount = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (isVowel(s.charAt(i))) \\n                currentVowelCount++;\\n            if (i >= k && isVowel(s.charAt(i - k))) \\n                currentVowelCount--;\\n            maxVowelCount = Math.max(maxVowelCount, currentVowelCount);\\n        }\\n        return maxVowelCount;\\n    }\\n\\n    boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489684,
                "title": "sliding-window-easiest-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink about the logic of what\\'s happening in the sliding window approach each time when we move move further.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Sliding window\\n* keep track of number of vowels present in each k window and store the maximum count \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int isvowel(char ch)\\n    {\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\')\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n    int maxVowels(string s, int k) {\\n        \\n        int i;\\n        int curr_vow = 0;\\n        int max_vow = 0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            curr_vow += isvowel(s[i]);\\n            if(i>=k)\\n            {\\n                curr_vow -= isvowel(s[i-k]);\\n            }\\n            max_vow = max(max_vow,curr_vow);\\n        }\\n        return max_vow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int isvowel(char ch)\\n    {\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\')\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n    int maxVowels(string s, int k) {\\n        \\n        int i;\\n        int curr_vow = 0;\\n        int max_vow = 0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            curr_vow += isvowel(s[i]);\\n            if(i>=k)\\n            {\\n                curr_vow -= isvowel(s[i-k]);\\n            }\\n            max_vow = max(max_vow,curr_vow);\\n        }\\n        return max_vow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489565,
                "title": "c-easy-o-n-explaination",
                "content": "# Intuition\\n- We just have to maintain the k size window. \\n- Maintain the count of vowels present in the window.\\n- And take out the maximum from every window. \\n- Everytime we add one character and remove one character.\\n\\n# Approach\\n- To decrease the time complexity we need to solve the problem in linear time. \\n- Everytime we add and remove one character to form a window of k size.\\n- If removed character is vowel : then -1 from the vowel count.\\n- If added character is vowel : then +1 to the vowel count.\\n\\n\\n# Optimal Code \\n- Linear Time Complexity : O(n) \\n```\\nclass Solution {\\npublic:\\n\\n    bool isVowel( char c ){\\n        if( c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ) return true;\\n        return false;\\n    }\\n\\n    int maxVowels(string s, int k) {\\n        \\n        int maxi = 0;\\n        int tmp = 0;\\n\\n        // count the number of vowels in first k size window \\n        for( int i=0 ; i<k ; i++ ){\\n            if( isVowel(s[i])) tmp++;\\n        }\\n\\n        maxi = max( maxi, tmp );\\n\\n        // add one character and remove one character from the window \\n        // if the removed character is vowel -1 from the vowel count \\n        // if the added character is vowel +1 in the vowel count \\n        for( int i=k ; i<s.size() ; i++ ){\\n\\n            if( isVowel(s[i-k]) ) tmp -= 1;\\n\\n            if( tmp < 0 ) tmp = 0;\\n\\n            if( isVowel(s[i]) ) tmp += 1;\\n\\n            maxi = max( maxi, tmp );\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```\\n# Brute Force Solution \\n- Time Limit Exceeded\\n- Test Cases Passed : 102/108\\n- Worst Time complexity: O(n^2) > 10^5 (Required)\\n```\\nclass Solution {\\npublic:\\n\\n    bool isVowel( char c ){\\n        if( c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ) return true;\\n        return false;\\n    }\\n\\n    int maxVowels(string s, int k) {\\n        \\n        int maxi = 0;\\n\\n        for( int i=0 ; i<=s.size()-k ; i++ ){\\n\\n            int tmp = 0;\\n\\n            for( int j=i ; j<i+k ; j++ ){\\n\\n                if( isVowel(s[j]) ) tmp++;\\n            }\\n\\n            maxi = max( maxi, tmp );\\n\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isVowel( char c ){\\n        if( c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ) return true;\\n        return false;\\n    }\\n\\n    int maxVowels(string s, int k) {\\n        \\n        int maxi = 0;\\n        int tmp = 0;\\n\\n        // count the number of vowels in first k size window \\n        for( int i=0 ; i<k ; i++ ){\\n            if( isVowel(s[i])) tmp++;\\n        }\\n\\n        maxi = max( maxi, tmp );\\n\\n        // add one character and remove one character from the window \\n        // if the removed character is vowel -1 from the vowel count \\n        // if the added character is vowel +1 in the vowel count \\n        for( int i=k ; i<s.size() ; i++ ){\\n\\n            if( isVowel(s[i-k]) ) tmp -= 1;\\n\\n            if( tmp < 0 ) tmp = 0;\\n\\n            if( isVowel(s[i]) ) tmp += 1;\\n\\n            maxi = max( maxi, tmp );\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    bool isVowel( char c ){\\n        if( c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\' ) return true;\\n        return false;\\n    }\\n\\n    int maxVowels(string s, int k) {\\n        \\n        int maxi = 0;\\n\\n        for( int i=0 ; i<=s.size()-k ; i++ ){\\n\\n            int tmp = 0;\\n\\n            for( int j=i ; j<i+k ; j++ ){\\n\\n                if( isVowel(s[j]) ) tmp++;\\n            }\\n\\n            maxi = max( maxi, tmp );\\n\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488765,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll we need to do is to count number of vowels in every substring and find the maximum number of vowels that can be present in substring of size k.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstep 1: initialize pointers i, j where i indicates start of window and j represents end. ALso store vowels in a list \"vowels\".\\n```\\ni, j = 0, 0\\nvowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\nc = 0\\n```\\nc is a vairiable that holds current count of vowels in present substring\\n\\nstep 2: Now we will iterate thorugh the string and check the count of vowels within the window of size k.\\n\\nstep 3: Until the window size k, \"j\" will increment at the same time check the s[j] is vowels or not. if so add 1 to c.\\n\\n```\\nif j-i<k:\\n    if s[j] in vowels:\\n        c+=1\\n    j+=1\\n```\\n\\nstep 4: If window size reaches k, then we will remove the 1st element in window and add new element by increment j and decrement i.\\nbefore that check s[i] is vowel. if so decrement c value and also.\\n```\\nelse:\\n    if s[i] in vowels:\\n        c-=1\\n    i+=1\\n```\\nstep 5: check current window vowel count is higher than max vowel count, if so update the max vowel count.\\n```\\nvows = max(vows, c)\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        vows = 0\\n        n = len(s)\\n        i = 0\\n        j = 0\\n        c = 0\\n        while j<n:\\n            if j-i<k:\\n                if s[j] in vowels:\\n                    c+=1\\n                j+=1\\n            else:\\n                if s[i] in vowels:\\n                    c-=1\\n                i+=1\\n            vows = max(vows, c)\\n        return vows\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\ni, j = 0, 0\\nvowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\nc = 0\\n```\n```\\nif j-i<k:\\n    if s[j] in vowels:\\n        c+=1\\n    j+=1\\n```\n```\\nelse:\\n    if s[i] in vowels:\\n        c-=1\\n    i+=1\\n```\n```\\nvows = max(vows, c)\\n```\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        vows = 0\\n        n = len(s)\\n        i = 0\\n        j = 0\\n        c = 0\\n        while j<n:\\n            if j-i<k:\\n                if s[j] in vowels:\\n                    c+=1\\n                j+=1\\n            else:\\n                if s[i] in vowels:\\n                    c-=1\\n                i+=1\\n            vows = max(vows, c)\\n        return vows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487837,
                "title": "java-sliding-window-o-n-hashing-90",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int[] vowels;\\n \\n   \\n    public int maxVowels(String s, int k) {\\n        \\n        int maxLen = 0;\\n        \\n        vowels = new int[26];\\n    vowels[\\'a\\' - \\'a\\']++;\\n    vowels[\\'e\\' - \\'a\\']++;\\n    vowels[\\'i\\' - \\'a\\']++;\\n    vowels[\\'o\\' - \\'a\\']++;\\n    vowels[\\'u\\' - \\'a\\']++;\\n       \\n       int vCnt = 0,l = 0;\\n        for(int i = 0;i < s.length();i++)\\n        {\\n             \\n             char c  = s.charAt(i);\\n             vCnt += (vowels[c - \\'a\\'] != 0)? 1 : 0;\\n             if(i >= k - 1)\\n             {\\n     \\n            maxLen = Math.max(maxLen,vCnt);\\n             \\n             if(vowels[s.charAt(l++) - \\'a\\'] != 0) vCnt--;\\n\\n             }\\n        }\\n\\n        return maxLen;\\n    }\\n\\n \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    int[] vowels;\\n \\n   \\n    public int maxVowels(String s, int k) {\\n        \\n        int maxLen = 0;\\n        \\n        vowels = new int[26];\\n    vowels[\\'a\\' - \\'a\\']++;\\n    vowels[\\'e\\' - \\'a\\']++;\\n    vowels[\\'i\\' - \\'a\\']++;\\n    vowels[\\'o\\' - \\'a\\']++;\\n    vowels[\\'u\\' - \\'a\\']++;\\n       \\n       int vCnt = 0,l = 0;\\n        for(int i = 0;i < s.length();i++)\\n        {\\n             \\n             char c  = s.charAt(i);\\n             vCnt += (vowels[c - \\'a\\'] != 0)? 1 : 0;\\n             if(i >= k - 1)\\n             {\\n     \\n            maxLen = Math.max(maxLen,vCnt);\\n             \\n             if(vowels[s.charAt(l++) - \\'a\\'] != 0) vCnt--;\\n\\n             }\\n        }\\n\\n        return maxLen;\\n    }\\n\\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487665,
                "title": "very-easy-intutive-code-sliding-window-in-c-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int i,j,c=0,vc=0,m=0;\\n        int n=s.size();\\n\\n        for(i=0;i<k;i++)\\n        {\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\')\\n            vc+=1;\\n        }\\n        m=vc;\\n        \\n\\n        for(i=k;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\')\\n            vc++;\\n            if(s[i-k]==\\'a\\'||s[i-k]==\\'e\\'||s[i-k]==\\'i\\'||s[i-k]==\\'o\\'||s[i-k]==\\'u\\')\\n            vc-=1;\\n\\n            m=max(vc,m);\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int i,j,c=0,vc=0,m=0;\\n        int n=s.size();\\n\\n        for(i=0;i<k;i++)\\n        {\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\')\\n            vc+=1;\\n        }\\n        m=vc;\\n        \\n\\n        for(i=k;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\')\\n            vc++;\\n            if(s[i-k]==\\'a\\'||s[i-k]==\\'e\\'||s[i-k]==\\'i\\'||s[i-k]==\\'o\\'||s[i-k]==\\'u\\')\\n            vc-=1;\\n\\n            m=max(vc,m);\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487398,
                "title": "c-easy-approach-without-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nasf\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int isVowel(char c){\\n        if(c==\\'a\\'||c==\\'e\\'||c==\\'i\\'||c==\\'o\\'||c==\\'u\\') return 1;\\n        return 0;\\n    }\\n    int maxVowels(string s, int k) {\\n        int max=0;\\n        int c=0;\\n        for(int i=0;i<k;i++){\\n            if(isVowel(s[i])==1) c++;\\n        }\\n        cout<<c<<endl;\\n        int i=0;\\n        max=c;\\n        int j=k;\\n        while(j<s.size()){\\n            c=c+isVowel(s[j++])-isVowel(s[i++]);\\n            cout<<c<<endl;\\n            if(c==k) return k;\\n            if(c>max) max=c;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int isVowel(char c){\\n        if(c==\\'a\\'||c==\\'e\\'||c==\\'i\\'||c==\\'o\\'||c==\\'u\\') return 1;\\n        return 0;\\n    }\\n    int maxVowels(string s, int k) {\\n        int max=0;\\n        int c=0;\\n        for(int i=0;i<k;i++){\\n            if(isVowel(s[i])==1) c++;\\n        }\\n        cout<<c<<endl;\\n        int i=0;\\n        max=c;\\n        int j=k;\\n        while(j<s.size()){\\n            c=c+isVowel(s[j++])-isVowel(s[i++]);\\n            cout<<c<<endl;\\n            if(c==k) return k;\\n            if(c>max) max=c;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 652924,
                "title": "javascript-easy-to-understand-3-solutions-from-96ms-to-64ms",
                "content": "## SOLUTION 1\\n\\nIt\\'s straight forward to think about using the sliding window algorithm to solve this problem.\\n\\nIn solution 1, we use a set to determine whether the char is a vowel. And then do the calculation.\\n\\n```js\\nconst maxVowels = (s, k) => {\\n  const VOWEL = new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']);\\n  let max = 0;\\n  for (let i = 0; i < k; ++i) {\\n    VOWEL.has(s[i]) && ++max;\\n  }\\n  for (let i = 0, cur = max; i < s.length - k; ++i) {\\n    VOWEL.has(s[i]) && --cur;\\n    VOWEL.has(s[i + k]) && ++cur;\\n    cur > max && (max = cur);\\n  }\\n  return max;\\n};\\n```\\n\\n## SOLUTION 2\\n\\nIn solution 2, we use a fixed-length `Uint8Array` to improve the performance.\\n\\nWe init the weight value first, and then in the movements of slide window, we don\\'t need to check but just calculation.\\n\\n```js\\nconst maxVowels = (s, k) => {\\n  const weight = new Uint8Array(123);\\n  let max = 0;\\n  weight[97] = weight[101] = weight[105] = weight[111] = weight[117] = 1;\\n  for (let i = 0; i < k; ++i) {\\n    max += weight[s.charCodeAt(i)];\\n  }\\n  for (let i = 0, cur = max; i < s.length - k; ++i) {\\n    cur += weight[s.charCodeAt(i + k)] - weight[s.charCodeAt(i)];\\n    cur > max && (max = cur);\\n  }\\n  return max;\\n};\\n```\\n\\n## SOLUTION 3\\n\\nTo avoid using too much extra space, we could use an int32 value to store the weight since the count of lower case English letters is less than 32.\\n\\nAnd by the way, we need to use bit operations to get the weight from that int32 value.\\n\\n```js\\nconst maxVowels = (s, k) => {\\n  const BASE = 97;\\n  const weight = 1065233; // 1 + (1 << 4) + (1 << 8) + (1 << 14) + (1 << 20);\\n  let max = 0;\\n  for (let i = 0; i < k; ++i) {\\n    max += weight >> (s.charCodeAt(i) - BASE) & 1;\\n  }\\n  for (let i = 0, cur = max; i < s.length - k; ++i) {\\n    cur += (weight >> (s.charCodeAt(i + k) - BASE) & 1) - (weight >> (s.charCodeAt(i) - BASE) & 1);\\n    cur > max && (max = cur);\\n  }\\n  return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst maxVowels = (s, k) => {\\n  const VOWEL = new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']);\\n  let max = 0;\\n  for (let i = 0; i < k; ++i) {\\n    VOWEL.has(s[i]) && ++max;\\n  }\\n  for (let i = 0, cur = max; i < s.length - k; ++i) {\\n    VOWEL.has(s[i]) && --cur;\\n    VOWEL.has(s[i + k]) && ++cur;\\n    cur > max && (max = cur);\\n  }\\n  return max;\\n};\\n```\n```js\\nconst maxVowels = (s, k) => {\\n  const weight = new Uint8Array(123);\\n  let max = 0;\\n  weight[97] = weight[101] = weight[105] = weight[111] = weight[117] = 1;\\n  for (let i = 0; i < k; ++i) {\\n    max += weight[s.charCodeAt(i)];\\n  }\\n  for (let i = 0, cur = max; i < s.length - k; ++i) {\\n    cur += weight[s.charCodeAt(i + k)] - weight[s.charCodeAt(i)];\\n    cur > max && (max = cur);\\n  }\\n  return max;\\n};\\n```\n```js\\nconst maxVowels = (s, k) => {\\n  const BASE = 97;\\n  const weight = 1065233; // 1 + (1 << 4) + (1 << 8) + (1 << 14) + (1 << 20);\\n  let max = 0;\\n  for (let i = 0; i < k; ++i) {\\n    max += weight >> (s.charCodeAt(i) - BASE) & 1;\\n  }\\n  for (let i = 0, cur = max; i < s.length - k; ++i) {\\n    cur += (weight >> (s.charCodeAt(i + k) - BASE) & 1) - (weight >> (s.charCodeAt(i) - BASE) & 1);\\n    cur > max && (max = cur);\\n  }\\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 648714,
                "title": "simple-java-o-n-dynamic-programming-is-there-a-better-approach",
                "content": "```\\nclass Solution {\\n\\t    public int maxVowels(String s, int k) {\\n            \\n\\t        String V = \"aeiou\";\\n\\t        char[] t = s.toCharArray();\\n\\t        int n = t.length;\\n\\t        int[] dp= new int[n+1];\\n            \\n            \\n\\t        for(int i = 0;i < n;i++){\\n\\t        \\tdp[i+1] = dp[i] + (V.indexOf(t[i]) >= 0 ? 1 : 0);\\n\\t        }\\n            \\n\\t        int ans = 0;\\n            \\n            \\n\\t        for(int i = k;i <= n;i++){\\n\\t        \\tans = Math.max(ans, dp[i] - dp[i-k]);\\n\\t        }\\n            \\n            \\n\\t        return ans;\\n\\t    }\\n\\t}\\n\\t",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\t    public int maxVowels(String s, int k) {\\n            \\n\\t        String V = \"aeiou\";\\n\\t        char[] t = s.toCharArray();\\n\\t        int n = t.length;\\n\\t        int[] dp= new int[n+1];\\n            \\n            \\n\\t        for(int i = 0;i < n;i++){\\n\\t        \\tdp[i+1] = dp[i] + (V.indexOf(t[i]) >= 0 ? 1 : 0);\\n\\t        }",
                "codeTag": "Java"
            },
            {
                "id": 3513100,
                "title": "most-optimized-c-easy-to-understand",
                "content": "count vowels all in all substrings\\nmaintain a sliding window for size k\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int x = 0,ans = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(i<k-1){\\n                if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'){\\n                    x++;\\n                }\\n            }else{\\n                if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'){\\n                    x++;\\n                }\\n                ans = max(ans,x);\\n                if(s[i-k+1]==\\'a\\'||s[i-k+1]==\\'e\\'||s[i-k+1]==\\'i\\'||s[i-k+1]==\\'o\\'||s[i-k+1]==\\'u\\'){\\n                    x--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int x = 0,ans = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(i<k-1){\\n                if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'){\\n                    x++;\\n                }\\n            }else{\\n                if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'){\\n                    x++;\\n                }\\n                ans = max(ans,x);\\n                if(s[i-k+1]==\\'a\\'||s[i-k+1]==\\'e\\'||s[i-k+1]==\\'i\\'||s[i-k+1]==\\'o\\'||s[i-k+1]==\\'u\\'){\\n                    x--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490017,
                "title": "simple-java-beats-100-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the maximum number of vowels in any sub-string of length k.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use a method similiar to how we calculate **the sum of sub-arrays of size k**. We have to use two-pointer approach here.\\n\\n**We subtract previous element and add next element to the current sum.**\\n\\nSimilarly, we substract previous vowel and add next vowel to current substring.\\n\\n    1. Initializie i, j from 0.\\n    2. Increment j while j < k and count vowels in that sub-string.\\n    3. Save this count in any variable, say \\'vowel\\'.\\n    4. In next loop, increment i and j by 1 to maintain a sub-string of length k.\\n    5. If ith character was vowel then decrement \\'vowel\\' and \\n       if jth character is a vowel then increment \\'vowel\\' count.\\n\\n    6. Save the maximum value of vowel in a variable, say max.    \\n    7. Finally, return the max.\\n**Follow the code below to understand the solution.**\\n\\n          **If this solution helped you, give it an up-vote to help others** \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n\\n//      Initialize i and j from 0.\\n        int i = 0;\\n        int j = 0;\\n\\n//      vowel is vowel count in current substring.\\n//      max is the maximum vowel in any substring.\\n        int vowels = 0;\\n        int max = 0;\\n\\n//      we need ch variable to store ith and jth character.\\n        char ch;\\n\\n//      Iterate while we get a substring of length k.\\n        while(j < k)\\n        {\\n            ch = s.charAt(j);\\n\\n            //if ch is a vowel, then increase vowels count.\\n            \\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n                vowels++;\\n            j++;\\n        }\\n//      we assume that the first substring has maximum vowels.\\n        max = vowels;\\n\\n//      Now j is equal to k.\\n\\n//      Iterate while j < string length.        \\n        while(j < s.length())\\n        {\\n            //ch stores ith character, (initially i = 0)\\n            ch = s.charAt(i);\\n\\n            //if ch is a vowel then decrement vowel count.\\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n                vowels--;\\n\\n            //ch stores the new jth character.\\n            ch = s.charAt(j);\\n            \\n            //if ch is vowel then \\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n                vowels++;\\n\\n//          store the maximum vowel count in the max.\\n            max = Math.max(max, vowels);\\n            \\n//          Increment i and j variables.\\n            i++;\\n            j++;\\n        }\\n\\n//      Finally, return the max variable.\\n        return max;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n\\n//      Initialize i and j from 0.\\n        int i = 0;\\n        int j = 0;\\n\\n//      vowel is vowel count in current substring.\\n//      max is the maximum vowel in any substring.\\n        int vowels = 0;\\n        int max = 0;\\n\\n//      we need ch variable to store ith and jth character.\\n        char ch;\\n\\n//      Iterate while we get a substring of length k.\\n        while(j < k)\\n        {\\n            ch = s.charAt(j);\\n\\n            //if ch is a vowel, then increase vowels count.\\n            \\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n                vowels++;\\n            j++;\\n        }\\n//      we assume that the first substring has maximum vowels.\\n        max = vowels;\\n\\n//      Now j is equal to k.\\n\\n//      Iterate while j < string length.        \\n        while(j < s.length())\\n        {\\n            //ch stores ith character, (initially i = 0)\\n            ch = s.charAt(i);\\n\\n            //if ch is a vowel then decrement vowel count.\\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n                vowels--;\\n\\n            //ch stores the new jth character.\\n            ch = s.charAt(j);\\n            \\n            //if ch is vowel then \\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n                vowels++;\\n\\n//          store the maximum vowel count in the max.\\n            max = Math.max(max, vowels);\\n            \\n//          Increment i and j variables.\\n            i++;\\n            j++;\\n        }\\n\\n//      Finally, return the max variable.\\n        return max;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489012,
                "title": "golang",
                "content": "# Intuition\\n\\u0414\\u043E\\u0441\\u0442\\u0430\\u0442\\u043E\\u0447\\u043D\\u043E \\u043F\\u0440\\u043E\\u0441\\u0442\\u0430\\u044F \\u0437\\u0430\\u0434\\u0430\\u0447\\u0430, \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C \\u0441\\u0432\\u043E\\u0435\\u0433\\u043E \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F \\u0438 \\u043E\\u0431\\u044A\\u044F\\u0441\\u043D\\u0435\\u043D\\u0438\\u0435 \\u043E\\u0441\\u0442\\u0430\\u0432\\u043B\\u044E \\u043D\\u0438\\u0436\\u0435!\\n\\n\\u0414\\u0430\\u043D\\u043D\\u0430\\u044F \\u0437\\u0430\\u0434\\u0430\\u0447\\u0430 \\u0441\\u043E\\u0441\\u0442\\u043E\\u0438\\u0442 \\u0432 \\u0442\\u043E\\u043C, \\u0447\\u0442\\u043E\\u0431\\u044B \\u043D\\u0430\\u0439\\u0442\\u0438 \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0432 \\u043F\\u043E\\u0434\\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 \\u0434\\u043B\\u0438\\u043D\\u044B k \\u0432 \\u0437\\u0430\\u0434\\u0430\\u043D\\u043D\\u043E\\u0439 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 s.\\n# Approach\\n\\n#### \\u041C\\u0435\\u0442\\u043E\\u0434 \\u0441\\u043A\\u043E\\u043B\\u044C\\u0437\\u044F\\u0449\\u0435\\u0433\\u043E \\u043E\\u043A\\u043D\\u0430\\n\\u041C\\u0435\\u0442\\u043E\\u0434 \\u0441\\u043A\\u043E\\u043B\\u044C\\u0437\\u044F\\u0449\\u0435\\u0433\\u043E \\u043E\\u043A\\u043D\\u0430 **(sliding window)** - \\u044D\\u0442\\u043E \\u043E\\u0434\\u0438\\u043D \\u0438\\u0437 \\u043F\\u043E\\u0434\\u0445\\u043E\\u0434\\u043E\\u0432 \\u0434\\u043B\\u044F \\u043E\\u0431\\u0440\\u0430\\u0431\\u043E\\u0442\\u043A\\u0438 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445 \\u0432 \\u043F\\u0440\\u043E\\u0433\\u0440\\u0430\\u043C\\u043C\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u0438\\u0438. \\u041E\\u043D \\u0437\\u0430\\u043A\\u043B\\u044E\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0432 \\u0441\\u043E\\u0437\\u0434\\u0430\\u043D\\u0438\\u0438 \\u043E\\u043A\\u043D\\u0430 \\u0444\\u0438\\u043A\\u0441\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0433\\u043E \\u0440\\u0430\\u0437\\u043C\\u0435\\u0440\\u0430 \\u0438 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043E\\u0432\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u043C \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445 \\u0432\\u043D\\u0443\\u0442\\u0440\\u0438 \\u044D\\u0442\\u043E\\u0433\\u043E \\u043E\\u043A\\u043D\\u0430.\\n\\n\\u0412 \\u043A\\u043E\\u043D\\u0442\\u0435\\u043A\\u0441\\u0442\\u0435 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0438 \\u043D\\u0430\\u0445\\u043E\\u0436\\u0434\\u0435\\u043D\\u0438\\u044F \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0433\\u043E \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u0430 \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0432 \\u043F\\u043E\\u0434\\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 \\u0434\\u043B\\u0438\\u043D\\u044B **k** \\u0432 \\u0437\\u0430\\u0434\\u0430\\u043D\\u043D\\u043E\\u0439 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0435, \\u043C\\u0435\\u0442\\u043E\\u0434 \\u0441\\u043A\\u043E\\u043B\\u044C\\u0437\\u044F\\u0449\\u0435\\u0433\\u043E \\u043E\\u043A\\u043D\\u0430 \\u043C\\u043E\\u0436\\u0435\\u0442 \\u0431\\u044B\\u0442\\u044C \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u043D \\u0441\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0438\\u043C \\u043E\\u0431\\u0440\\u0430\\u0437\\u043E\\u043C:\\n\\n1. \\u0421\\u043E\\u0437\\u0434\\u0430\\u0442\\u044C \\u043E\\u043A\\u043D\\u043E \\u0440\\u0430\\u0437\\u043C\\u0435\\u0440\\u043E\\u043C **k** \\u0438 \\u043F\\u043E\\u043C\\u0435\\u0441\\u0442\\u0438\\u0442\\u044C \\u0435\\u0433\\u043E \\u0432 \\u043D\\u0430\\u0447\\u0430\\u043B\\u043E \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438.\\n2. \\u041F\\u043E\\u0441\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0432\\u043D\\u0443\\u0442\\u0440\\u0438 \\u043E\\u043A\\u043D\\u0430.\\n3. \\u0421\\u0434\\u0432\\u0438\\u043D\\u0443\\u0442\\u044C \\u043E\\u043A\\u043D\\u043E \\u043D\\u0430 \\u043E\\u0434\\u043D\\u0443 \\u043F\\u043E\\u0437\\u0438\\u0446\\u0438\\u044E \\u0432\\u043F\\u0440\\u0430\\u0432\\u043E \\u0438 \\u043E\\u0431\\u043D\\u043E\\u0432\\u0438\\u0442\\u044C \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0432\\u043D\\u0443\\u0442\\u0440\\u0438 \\u043E\\u043A\\u043D\\u0430.\\n4. \\u041F\\u0440\\u043E\\u0434\\u043E\\u043B\\u0436\\u0430\\u0442\\u044C \\u0441\\u0434\\u0432\\u0438\\u0433\\u0430\\u0442\\u044C \\u043E\\u043A\\u043D\\u043E \\u0438 \\u043E\\u0431\\u043D\\u043E\\u0432\\u043B\\u044F\\u0442\\u044C \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0434\\u043E \\u0442\\u0435\\u0445 \\u043F\\u043E\\u0440, \\u043F\\u043E\\u043A\\u0430 \\u043E\\u043A\\u043D\\u043E \\u043D\\u0435 \\u0434\\u043E\\u0439\\u0434\\u0435\\u0442 \\u0434\\u043E \\u043A\\u043E\\u043D\\u0446\\u0430 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438.\\n5. \\u0417\\u0430\\u043F\\u043E\\u043C\\u043D\\u0438\\u0442\\u044C \\u043F\\u043E\\u0437\\u0438\\u0446\\u0438\\u044E \\u043D\\u0430\\u0447\\u0430\\u043B\\u0430 \\u043E\\u043A\\u043D\\u0430, \\u0432 \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0439 \\u0431\\u044B\\u043B\\u043E \\u043D\\u0430\\u0439\\u0434\\u0435\\u043D\\u043E \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432.\\n\\n\\u0422\\u0430\\u043A\\u0438\\u043C \\u043E\\u0431\\u0440\\u0430\\u0437\\u043E\\u043C, \\u043C\\u044B \\u043C\\u043E\\u0436\\u0435\\u043C \\u043D\\u0430\\u0445\\u043E\\u0434\\u0438\\u0442\\u044C \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0432 \\u043F\\u043E\\u0434\\u0441\\u0442\\u0440\\u043E\\u043A\\u0430\\u0445 \\u0434\\u043B\\u0438\\u043D\\u044B **k**, \\u043F\\u0440\\u043E\\u0445\\u043E\\u0434\\u044F \\u0432\\u0441\\u044E \\u0441\\u0442\\u0440\\u043E\\u043A\\u0443 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043E\\u0434\\u0438\\u043D \\u0440\\u0430\\u0437, \\u0447\\u0442\\u043E \\u0437\\u043D\\u0430\\u0447\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E \\u0443\\u0441\\u043A\\u043E\\u0440\\u044F\\u0435\\u0442 \\u043F\\u0440\\u043E\\u0446\\u0435\\u0441\\u0441.\\n\\n#### \\u0410\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F \\u0437\\u0430\\u0434\\u0430\\u0447\\u0438 \\u0441\\u043E\\u0441\\u0442\\u043E\\u0438\\u0442 \\u0438\\u0437 \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u0438\\u0445 \\u0448\\u0430\\u0433\\u043E\\u0432:\\n1. \\u0421\\u043E\\u0437\\u0434\\u0430\\u043D\\u0438\\u0435 \\u043C\\u0430\\u043F\\u044B **vowels**, \\u043A\\u043E\\u0442\\u043E\\u0440\\u0430\\u044F \\u0441\\u043E\\u0434\\u0435\\u0440\\u0436\\u0438\\u0442 \\u0432\\u0441\\u0435 \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0435 \\u0431\\u0443\\u043A\\u0432\\u044B \\u0430\\u043D\\u0433\\u043B\\u0438\\u0439\\u0441\\u043A\\u043E\\u0433\\u043E \\u0430\\u043B\\u0444\\u0430\\u0432\\u0438\\u0442\\u0430;\\n2. \\u0421\\u043E\\u0437\\u0434\\u0430\\u043D\\u0438\\u0435 \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E\\u0439 **n**, \\u043A\\u043E\\u0442\\u043E\\u0440\\u0430\\u044F \\u0441\\u043E\\u0434\\u0435\\u0440\\u0436\\u0438\\u0442 \\u0434\\u043B\\u0438\\u043D\\u0443 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 **s**;\\n3. \\u0421\\u043E\\u0437\\u0434\\u0430\\u043D\\u0438\\u0435 \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u044B\\u0445 **maxCount** \\u0438 **currCount**, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u0431\\u0443\\u0434\\u0443\\u0442 \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C\\u0441\\u044F \\u0434\\u043B\\u044F \\u0445\\u0440\\u0430\\u043D\\u0435\\u043D\\u0438\\u044F \\u043D\\u0430\\u0438\\u0431\\u043E\\u043B\\u044C\\u0448\\u0435\\u0433\\u043E \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u0430 \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0438 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u0430 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0438\\u0445 \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0441\\u043E\\u043E\\u0442\\u0432\\u0435\\u0442\\u0441\\u0442\\u0432\\u0435\\u043D\\u043D\\u043E;\\n4. \\u0418\\u0442\\u0435\\u0440\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043F\\u043E \\u043F\\u0435\\u0440\\u0432\\u044B\\u043C **k** \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0430\\u043C \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 **s** \\u0438 \\u0443\\u0432\\u0435\\u043B\\u0438\\u0447\\u0435\\u043D\\u0438\\u0435 \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E\\u0439 **currCount**, \\u0435\\u0441\\u043B\\u0438 \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B \\u044F\\u0432\\u043B\\u044F\\u0435\\u0442\\u0441\\u044F \\u0433\\u043B\\u0430\\u0441\\u043D\\u043E\\u0439 \\u0431\\u0443\\u043A\\u0432\\u043E\\u0439;\\n5. \\u041F\\u0440\\u0438\\u0441\\u0432\\u043E\\u0435\\u043D\\u0438\\u0435 \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E\\u0439 **maxCount** \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u044F **currCount**;\\n6. \\u0418\\u0442\\u0435\\u0440\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043F\\u043E \\u043E\\u0441\\u0442\\u0430\\u0432\\u0448\\u0435\\u0439\\u0441\\u044F \\u0447\\u0430\\u0441\\u0442\\u0438 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 **s** **(\\u043E\\u0442 k \\u0434\\u043E \\u043A\\u043E\\u043D\\u0446\\u0430)** \\u0441 \\u043F\\u043E\\u043C\\u043E\\u0449\\u044C\\u044E \\u0434\\u0432\\u0443\\u0445 \\u0443\\u043A\\u0430\\u0437\\u0430\\u0442\\u0435\\u043B\\u0435\\u0439 **(i \\u0438 i+k-1)**;\\n7. \\u0415\\u0441\\u043B\\u0438 \\u043F\\u0435\\u0440\\u0432\\u044B\\u0439 \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B \\u0438\\u0437 \\u0440\\u0430\\u0441\\u0441\\u043C\\u0430\\u0442\\u0440\\u0438\\u0432\\u0430\\u0435\\u043C\\u043E\\u0433\\u043E \\u0434\\u0438\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D\\u0430 \\u044F\\u0432\\u043B\\u044F\\u0435\\u0442\\u0441\\u044F \\u0433\\u043B\\u0430\\u0441\\u043D\\u043E\\u0439 \\u0431\\u0443\\u043A\\u0432\\u043E\\u0439, \\u0442\\u043E \\u0443\\u043C\\u0435\\u043D\\u044C\\u0448\\u0430\\u0435\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 **currCount** \\u043D\\u0430 **1**;\\n8. \\u0415\\u0441\\u043B\\u0438 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u0438\\u0439 \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B \\u0438\\u0437 \\u0440\\u0430\\u0441\\u0441\\u043C\\u0430\\u0442\\u0440\\u0438\\u0432\\u0430\\u0435\\u043C\\u043E\\u0433\\u043E \\u0434\\u0438\\u0430\\u043F\\u0430\\u0437\\u043E\\u043D\\u0430 \\u044F\\u0432\\u043B\\u044F\\u0435\\u0442\\u0441\\u044F \\u0433\\u043B\\u0430\\u0441\\u043D\\u043E\\u0439 \\u0431\\u0443\\u043A\\u0432\\u043E\\u0439, \\u0442\\u043E \\u0443\\u0432\\u0435\\u043B\\u0438\\u0447\\u0438\\u0432\\u0430\\u0435\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 **currCount** \\u043D\\u0430 **1**;\\n9. \\u0415\\u0441\\u043B\\u0438 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 **currCount** \\u043E\\u043A\\u0430\\u0437\\u0430\\u043B\\u043E\\u0441\\u044C \\u0431\\u043E\\u043B\\u044C\\u0448\\u0438\\u043C, \\u0447\\u0435\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 **maxCount**, \\u0442\\u043E \\u043F\\u0440\\u0438\\u0441\\u0432\\u0430\\u0438\\u0432\\u0430\\u0435\\u043C \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E\\u0439 **maxCount** \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 **currCount**;\\n10. \\u0412\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 **maxCount**.\\n\\n#### \\u0414\\u0430\\u0432\\u0430\\u0439 \\u0440\\u0430\\u0441\\u0441\\u043C\\u043E\\u0442\\u0440\\u0438\\u043C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B \\u0444\\u0443\\u043D\\u043A\\u0446\\u0438\\u0438 maxVowels \\u043D\\u0430 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 \"leetcode\" \\u0438 \\u0434\\u043B\\u0438\\u043D\\u0435 k = 3:\\n**\\u0418\\u0442\\u0435\\u0440\\u0430\\u0446\\u0438\\u044F 1:**\\n**s = \"leetcode\", k = 3**\\ncurrCount = 2 (\\u044D\\u0442\\u043E \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0432 \\u043F\\u043E\\u0434\\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 \"lee\")\\nmaxCount = 2 (\\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u043D\\u0430 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0439 \\u043C\\u043E\\u043C\\u0435\\u043D\\u0442)\\n\\n**\\u0418\\u0442\\u0435\\u0440\\u0430\\u0446\\u0438\\u044F 2:**\\n**s = \"leetcode\", k = 3**\\ncurrCount = 2 (\\u044D\\u0442\\u043E \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0432 \\u043F\\u043E\\u0434\\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 \"eet\")\\nmaxCount = 2 (\\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u043D\\u0430 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0439 \\u043C\\u043E\\u043C\\u0435\\u043D\\u0442)\\n\\n**\\u0418\\u0442\\u0435\\u0440\\u0430\\u0446\\u0438\\u044F 3:**\\n**s = \"leetcode\", k = 3**\\ncurrCount = 1 (\\u044D\\u0442\\u043E \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0432 \\u043F\\u043E\\u0434\\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 \"etc\")\\nmaxCount = 2 (\\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u043D\\u0430 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0439 \\u043C\\u043E\\u043C\\u0435\\u043D\\u0442)\\n\\n**\\u0418\\u0442\\u0435\\u0440\\u0430\\u0446\\u0438\\u044F 4:**\\n**s = \"leetcode\", k = 3**\\ncurrCount = 1 (\\u044D\\u0442\\u043E \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0432 \\u043F\\u043E\\u0434\\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 \"tco\")\\nmaxCount = 2 (\\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u043D\\u0430 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0439 \\u043C\\u043E\\u043C\\u0435\\u043D\\u0442)\\n\\n**\\u0418\\u0442\\u0435\\u0440\\u0430\\u0446\\u0438\\u044F 5:**\\n**s = \"leetcode\", k = 3**\\ncurrCount = 1 (\\u044D\\u0442\\u043E \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0432 \\u043F\\u043E\\u0434\\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 \"cod\")\\nmaxCount = 2 (\\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u043D\\u0430 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0439 \\u043C\\u043E\\u043C\\u0435\\u043D\\u0442)\\n\\n\\u041C\\u044B \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u043B\\u0438 \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0433\\u043B\\u0430\\u0441\\u043D\\u044B\\u0445 \\u0440\\u0430\\u0432\\u043D\\u043E\\u0435 2.\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nfunc maxVowels(s string, k int) int {\\n\\n\\tn, maxCount := len(s), 0\\n\\tvowels := map[byte]bool{\\n\\t\\t\\'a\\': true,\\n\\t\\t\\'e\\': true,\\n\\t\\t\\'i\\': true,\\n\\t\\t\\'o\\': true,\\n\\t\\t\\'u\\': true,\\n\\t}\\n\\n\\tcurrCount := 0\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tif vowels[s[i]] {\\n\\t\\t\\tcurrCount++\\n\\t\\t}\\n\\t}\\n\\n\\tmaxCount = currCount\\n\\n\\tfor i := 1; i <= n-k; i++ {\\n\\t\\tif vowels[s[i-1]] {\\n\\t\\t\\tcurrCount--\\n\\t\\t}\\n\\t\\tif vowels[s[i+k-1]] {\\n\\t\\t\\tcurrCount++\\n\\t\\t}\\n\\t\\tif currCount > maxCount {\\n\\t\\t\\tmaxCount = currCount\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxCount\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nfunc maxVowels(s string, k int) int {\\n\\n\\tn, maxCount := len(s), 0\\n\\tvowels := map[byte]bool{\\n\\t\\t\\'a\\': true,\\n\\t\\t\\'e\\': true,\\n\\t\\t\\'i\\': true,\\n\\t\\t\\'o\\': true,\\n\\t\\t\\'u\\': true,\\n\\t}\\n\\n\\tcurrCount := 0\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tif vowels[s[i]] {\\n\\t\\t\\tcurrCount++\\n\\t\\t}\\n\\t}\\n\\n\\tmaxCount = currCount\\n\\n\\tfor i := 1; i <= n-k; i++ {\\n\\t\\tif vowels[s[i-1]] {\\n\\t\\t\\tcurrCount--\\n\\t\\t}\\n\\t\\tif vowels[s[i+k-1]] {\\n\\t\\t\\tcurrCount++\\n\\t\\t}\\n\\t\\tif currCount > maxCount {\\n\\t\\t\\tmaxCount = currCount\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxCount\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3488620,
                "title": "java-full-explaination-comments-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Its a Window Sliding Questions\\nHere\\'s the intuition behind the code:**\\n1. Initialize \\'vowelCount\\' and \\'maxCount\\' variables to keep track of the current vowel count and the maximum vowel count encountered so far, respectively.\\n2. The first \\'for\\' loop iterates from 0 to \\'k\\' (exclusive) to count the number of vowels in the first substring of length \\'k\\'. It calls the \\'isVowel\\' function to check if each character is a vowel and increments \\'vowelCount\\' accordingly.\\n3. Update \\'maxCount\\' by taking the maximum between \\'maxCount\\' and \\'vowelCount\\'. This is done to keep track of the maximum vowel count encountered so far.\\n4. The second \\'for\\' loop starts from \\'k\\' and iterates through the remaining characters in the string \\'s\\'. It checks if the previous character (i-k) was a vowel and decrements \\'vowelCount\\' accordingly. Then it checks if the current character (i) is a vowel and increments \\'vowelCount\\' if it is.\\n5. Again, update \\'maxCount\\' by taking the maximum between \\'maxCount\\' and \\'vowelCount\\'. This is done to update the maximum vowel count if the current substring has a higher count than the previous substrings.\\n6. Finally, return \\'maxCount\\' as the result, which represents the maximum vowel count found in any substring of length \\'k\\' within the given string \\'s\\'.\\n\\nNote :- The code efficiently maintains the vowel count by subtracting the count of the oldest character in the sliding window (i-k) and adding the count of the newest character (i). By keeping track of the maximum vowel count encountered, it avoids unnecessary computations when the maximum count is already equal to \\'k\\'.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int vowelCount = 0;\\n        int maxCount = 0;\\n        //to count the number of vowels in the first substring of length \\'k\\'\\n        for(int i = 0 ;i < k ; i ++){\\n            if(isVowel(s.charAt(i))){\\n                vowelCount ++;\\n            }\\n        }\\n        maxCount = Math.max(maxCount,vowelCount);\\n        for(int i = k; i < s.length(); i ++){\\n            //to avoids unnecessary computations when the maximum count is already equal to \\'k\\'.\\n            if(maxCount == k){\\n                return maxCount;\\n            }\\n            //to remove the first element from substring so that we can move our sliding boundary one step forward\\n            if(isVowel(s.charAt(i-k))){\\n                vowelCount--;\\n            }\\n            //adding new element into the sliding boundary\\n            if(isVowel(s.charAt(i))){\\n                vowelCount++;\\n            }\\n            //to keep track of maxCount\\n            maxCount = Math.max(maxCount,vowelCount);\\n        }\\n        return maxCount;\\n    }\\n    //it return true if the character is vowel\\n    public boolean isVowel(char ch){\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int vowelCount = 0;\\n        int maxCount = 0;\\n        //to count the number of vowels in the first substring of length \\'k\\'\\n        for(int i = 0 ;i < k ; i ++){\\n            if(isVowel(s.charAt(i))){\\n                vowelCount ++;\\n            }\\n        }\\n        maxCount = Math.max(maxCount,vowelCount);\\n        for(int i = k; i < s.length(); i ++){\\n            //to avoids unnecessary computations when the maximum count is already equal to \\'k\\'.\\n            if(maxCount == k){\\n                return maxCount;\\n            }\\n            //to remove the first element from substring so that we can move our sliding boundary one step forward\\n            if(isVowel(s.charAt(i-k))){\\n                vowelCount--;\\n            }\\n            //adding new element into the sliding boundary\\n            if(isVowel(s.charAt(i))){\\n                vowelCount++;\\n            }\\n            //to keep track of maxCount\\n            maxCount = Math.max(maxCount,vowelCount);\\n        }\\n        return maxCount;\\n    }\\n    //it return true if the character is vowel\\n    public boolean isVowel(char ch){\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488531,
                "title": "solution-using-sliding-window-approach-c-solution-time-and-space-complexity-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe approach is intuitive as we are simply counting the number of vowels in each substring of length k and keeping track of the maximum count seen so far. By using the sliding window technique, we can optimize the solution by reusing the count of the first character in the previous substring and only updating the count of the new character that entered the window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to this problem is to iterate over all the substrings of length k in the given string s. For each substring, we count the number of vowels and keep track of the maximum number of vowels seen so far. Finally, we return the maximum count of vowels seen in any substring.\\n\\nWe can optimize this approach by using sliding window technique. We can count the number of vowels in the first substring of length k and keep track of the maximum count seen so far. Then, we move the window by 1 character at a time, and for each new substring, we subtract the vowel count of the first character that is no longer part of the window, and add the vowel count of the new character that just entered the window. We update the maximum count seen so far at each step.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N):\\nThe time complexity of this approach is O(n), where n is the length of the string s. This is because we are iterating over all substrings of length k, and there can be at most n-k+1 such substrings. Within each iteration, we are checking if each character is a vowel, which takes constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1):\\nThe space complexity of this approach is O(1), as we are only using constant amount of extra space to store the counts of vowels and the maximum count seen so far. We are not using any extra data structures that depend on the length of the string s or the length of the substring k.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n    int n = s.size();\\n    int maxCount = 0, count = 0;\\n    for (int i = 0; i < k; i++) {\\n        if (s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\') {\\n            count++;\\n        }\\n    }\\n    maxCount = count;\\n    for (int i = k; i < n; i++) {\\n        if (s[i-k] == \\'a\\' || s[i-k] == \\'e\\' || s[i-k] == \\'i\\' || s[i-k] == \\'o\\' || s[i-k] == \\'u\\') {\\n            count--;\\n        }\\n        if (s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\') {\\n            count++;\\n        }\\n        maxCount = max(maxCount, count);\\n    }\\n    return maxCount;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n    int n = s.size();\\n    int maxCount = 0, count = 0;\\n    for (int i = 0; i < k; i++) {\\n        if (s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\') {\\n            count++;\\n        }\\n    }\\n    maxCount = count;\\n    for (int i = k; i < n; i++) {\\n        if (s[i-k] == \\'a\\' || s[i-k] == \\'e\\' || s[i-k] == \\'i\\' || s[i-k] == \\'o\\' || s[i-k] == \\'u\\') {\\n            count--;\\n        }\\n        if (s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\') {\\n            count++;\\n        }\\n        maxCount = max(maxCount, count);\\n    }\\n    return maxCount;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487971,
                "title": "easiest-java-solution-in-o-n-sliding-window",
                "content": "# Intuition\\nJust keep count of all vovels in window k\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirstly count the number of vavels on first k length of string.\\nThen iterate from kth index to last character and check i-kth character and ith character.\\nIf ith character is vovel increase the count by one.\\nIf i-kth character is vovel then decrease the count by one.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int n = s.length();\\n        int ans = 0;\\n        int count = 0;\\n        for(int i=0;i<n && i<k;i++){\\n            if(s.charAt(i)==\\'a\\' || s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){\\n                count++;\\n            }\\n        }\\n        ans = count;\\n        for(int i=k;i<n;i++){\\n            if(s.charAt(i)==\\'a\\' || s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){\\n                count++;\\n            }\\n            if(s.charAt(i-k)==\\'a\\' || s.charAt(i-k)==\\'e\\' || s.charAt(i-k)==\\'i\\' || s.charAt(i-k)==\\'o\\' || s.charAt(i-k)==\\'u\\'){\\n                count--;\\n            }\\n            if(count> ans) ans = count;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int n = s.length();\\n        int ans = 0;\\n        int count = 0;\\n        for(int i=0;i<n && i<k;i++){\\n            if(s.charAt(i)==\\'a\\' || s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){\\n                count++;\\n            }\\n        }\\n        ans = count;\\n        for(int i=k;i<n;i++){\\n            if(s.charAt(i)==\\'a\\' || s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){\\n                count++;\\n            }\\n            if(s.charAt(i-k)==\\'a\\' || s.charAt(i-k)==\\'e\\' || s.charAt(i-k)==\\'i\\' || s.charAt(i-k)==\\'o\\' || s.charAt(i-k)==\\'u\\'){\\n                count--;\\n            }\\n            if(count> ans) ans = count;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487789,
                "title": "easy-js-solution-beats-97-online-submissions",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxVowels = function(s, k) {\\n    let c=0;;\\n    let maxCount=0;\\n    let i = 0, j = 0;\\n    while(i < k){\\n        if(checkString(s[i++])){\\n            c++\\n        }\\n    }\\n    maxCount=Math.max(maxCount,c)\\n    while(i < s.length){\\n        if(checkString(s[j++])){\\n            c--\\n        }\\n        if(checkString(s[i++])){\\n            c++\\n        }\\n       maxCount=Math.max(maxCount,c)\\n    }\\n    return maxCount\\n};\\nconst checkString = (ch)=>{\\n    if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'){\\n        return true\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxVowels = function(s, k) {\\n    let c=0;;\\n    let maxCount=0;\\n    let i = 0, j = 0;\\n    while(i < k){\\n        if(checkString(s[i++])){\\n            c++\\n        }\\n    }\\n    maxCount=Math.max(maxCount,c)\\n    while(i < s.length){\\n        if(checkString(s[j++])){\\n            c--\\n        }\\n        if(checkString(s[i++])){\\n            c++\\n        }\\n       maxCount=Math.max(maxCount,c)\\n    }\\n    return maxCount\\n};\\nconst checkString = (ch)=>{\\n    if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'){\\n        return true\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3487586,
                "title": "cpp-easy-approach-sliding-window-and-prefix-sum",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isvowel(char ch) { return (ch == \\'a\\') || (ch == \\'e\\') ||(ch == \\'i\\') ||(ch == \\'o\\') ||(ch == \\'u\\'); }\\n    int maxVowels(string s, int k) {\\n        vector<int>pre(s.length()+1,0);\\n        pre[0]=isvowel(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            pre[i]+=pre[i-1]+isvowel(s[i]);\\n        }\\n\\n        int i=0,j=k-1;\\n        int ans=0;\\n        while(j<s.length())\\n        {\\n            ans=max(ans,pre[j]-pre[i]+isvowel(s[i]));\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isvowel(char ch) { return (ch == \\'a\\') || (ch == \\'e\\') ||(ch == \\'i\\') ||(ch == \\'o\\') ||(ch == \\'u\\'); }\\n    int maxVowels(string s, int k) {\\n        vector<int>pre(s.length()+1,0);\\n        pre[0]=isvowel(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            pre[i]+=pre[i-1]+isvowel(s[i]);\\n        }\\n\\n        int i=0,j=k-1;\\n        int ans=0;\\n        while(j<s.length())\\n        {\\n            ans=max(ans,pre[j]-pre[i]+isvowel(s[i]));\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486905,
                "title": "simple-solution-with-using-only-1loop-includes-method",
                "content": "**Made by** Seeker Of Miracle\\n\\n# Approach\\n1. Initialize a vowel array with all the vowels (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\').\\n2. Initialize variables maxCount and count to 0.\\n3. Iterate through each character in the input string s.\\n4. If the current character is a vowel, increment count by 1.\\n5. If the current character is not a vowel or we have reached the end of the string, check if count is greater than maxCount.\\n6. If count is greater than maxCount, update maxCount to count.\\n7. Reset count to 0.\\n8. Return maxCount.\\n# Complexity\\n- Time complexity:o(n)\\n\\n- Space complexity:o(1)\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxVowels = function(s, k) {\\n    let maxCount=0,count=0;\\n    const vowel=[\\'a\\',\"e\", \"i\", \"o\", \"u\"]\\n    for(let i=0;i<s.length;i++)\\n    {\\n        if(vowel.includes(s[i]))   count++\\n\\n        if(i>=k && vowel.includes(s[i-k])) count--\\n\\n        if(count==k)\\n        return k;\\n\\n        if(maxCount<count)\\n        maxCount=count\\n    }\\n    return maxCount\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxVowels = function(s, k) {\\n    let maxCount=0,count=0;\\n    const vowel=[\\'a\\',\"e\", \"i\", \"o\", \"u\"]\\n    for(let i=0;i<s.length;i++)\\n    {\\n        if(vowel.includes(s[i]))   count++\\n\\n        if(i>=k && vowel.includes(s[i-k])) count--\\n\\n        if(count==k)\\n        return k;\\n\\n        if(maxCount<count)\\n        maxCount=count\\n    }\\n    return maxCount\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486697,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        best=0\\n        count=0\\n        for i,x in enumerate(s):\\n            if x in \"aeiou\":\\n                count+=1\\n\\n            if i>=k and s[i-k] in \"aeiou\":\\n                count-=1\\n\\n            best=max(best,count)\\n\\n        return best            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        best=0\\n        count=0\\n        for i,x in enumerate(s):\\n            if x in \"aeiou\":\\n                count+=1\\n\\n            if i>=k and s[i-k] in \"aeiou\":\\n                count-=1\\n\\n            best=max(best,count)\\n\\n        return best            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486667,
                "title": "functional-rust-iterators-fold-100-faster-one-pass-no-extra-memory-used",
                "content": "# Intuition\\nRust iterators + fold()\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfn is_vowel(ch: u8) -> bool {\\n    match ch {\\n        105 | 111 | 97 | 117 | 101 => true,\\n        _ => false,\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn max_vowels(s: String, k: i32) -> i32 {\\n        let s = s.as_bytes();\\n        let k = k as usize;\\n        let count: usize = s.iter().take(k).filter(|&x| is_vowel(*x)).count();\\n        s.iter()\\n         .skip(k)\\n         .zip(s.iter())\\n         .fold(\\n             (count, count),\\n             |a, x| {\\n                 let (max, count) = a;\\n                 let (cur, left) = x;\\n                 match (is_vowel(*left), is_vowel(*cur)) {\\n                     (false, true) => (max.max(count + 1), count + 1),\\n                     (true, false) => (max, count - 1),\\n                     _ => (max, count),\\n                 }\\n             }\\n         ).0 as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn is_vowel(ch: u8) -> bool {\\n    match ch {\\n        105 | 111 | 97 | 117 | 101 => true,\\n        _ => false,\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn max_vowels(s: String, k: i32) -> i32 {\\n        let s = s.as_bytes();\\n        let k = k as usize;\\n        let count: usize = s.iter().take(k).filter(|&x| is_vowel(*x)).count();\\n        s.iter()\\n         .skip(k)\\n         .zip(s.iter())\\n         .fold(\\n             (count, count),\\n             |a, x| {\\n                 let (max, count) = a;\\n                 let (cur, left) = x;\\n                 match (is_vowel(*left), is_vowel(*cur)) {\\n                     (false, true) => (max.max(count + 1), count + 1),\\n                     (true, false) => (max, count - 1),\\n                     _ => (max, count),\\n                 }\\n             }\\n         ).0 as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486565,
                "title": "c-easy-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool c(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\')return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        int ans=0;\\n        int mx=0;\\n        for(int i=0;i<k;i++){\\n            if(c(s[i]))mx++;\\n        }\\n        ans=mx;\\n        int j=k,i=0;\\n        while(j<s.size()){\\n            if(c(s[j]))mx++;\\n            if(c(s[i]))mx--;\\n            ans=max(ans,mx);\\n            j++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/6b5c4f4c-e79e-4532-80ff-900d5094f407_1683245981.899174.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool c(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\')return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        int ans=0;\\n        int mx=0;\\n        for(int i=0;i<k;i++){\\n            if(c(s[i]))mx++;\\n        }\\n        ans=mx;\\n        int j=k,i=0;\\n        while(j<s.size()){\\n            if(c(s[j]))mx++;\\n            if(c(s[i]))mx--;\\n            ans=max(ans,mx);\\n            j++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486530,
                "title": "daily-leetcoding-challenge-may-day-5",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sliding Window\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3067867,
                "title": "easy-js-solution-with-explaination",
                "content": "# Intuition\\nusing Concept of fixed sliding window.\\n\\n# Approach\\n1. Make a function which will check if a character is vowel or not. \\n2. Declare required variables. max for storing maximum, count for the currnt count.\\n3. First for loop will run till k to count all the vowels in our window.\\n4. Second Loop will start from k and we will just move window one char ahead checking if its a vowel if yes count increases. we will also check the leaving element is it vowel or not if it is vowel we will decrease the count to keep the count consistent. \\n5. We will check if count is greater than max. \\n6. return max.\\n\\nHope you like the answer, Upvote if you like it motivates me to write more answers.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction check(s){\\n    if(s==\"a\" ||s==\"e\"||s==\"i\"||s==\"o\"||s==\"u\"){\\n        return true\\n    }\\n    return false\\n}\\nvar maxVowels = function(s, k) {\\n    let max =0, count=0; \\n    for(let i=0;i<k;i++){\\n        if(check(s[i])){\\n            count++\\n        }\\n\\n    }\\n    max = count\\n    for(let i=k; i<s.length; i++){\\n        if(check(s[i])){\\n            count++\\n        }\\n        if(check(s[i-k])){\\n            count--\\n        }\\n        max = Math.max(max, count)\\n    }\\n    return max\\n\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nfunction check(s){\\n    if(s==\"a\" ||s==\"e\"||s==\"i\"||s==\"o\"||s==\"u\"){\\n        return true\\n    }\\n    return false\\n}\\nvar maxVowels = function(s, k) {\\n    let max =0, count=0; \\n    for(let i=0;i<k;i++){\\n        if(check(s[i])){\\n            count++\\n        }\\n\\n    }\\n    max = count\\n    for(let i=k; i<s.length; i++){\\n        if(check(s[i])){\\n            count++\\n        }\\n        if(check(s[i-k])){\\n            count--\\n        }\\n        max = Math.max(max, count)\\n    }\\n    return max\\n\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795853,
                "title": "c-sliding-window-easy",
                "content": "class Solution {\\npublic:\\n    \\n\\tint maxVowels(string s, int k) {\\n        int n = s.size();\\n        int i = 0,j = 0,x = 0,c = 0;\\n        while(j<n){\\n            if(s[j]==\\'a\\' || s[j]==\\'e\\' || s[j]==\\'i\\' || s[j]==\\'o\\' || s[j]==\\'u\\'){\\n                x++;\\n            }\\n            if(j-i+1<k) j++;\\n            else if(j-i+1==k){\\n                c = max(c,x);\\n                if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                    x--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tint maxVowels(string s, int k) {\\n        int n = s.size();\\n        int i = 0,j = 0,x = 0,c = 0;\\n        while(j<n){\\n            if(s[j]==\\'a\\' || s[j]==\\'e\\' || s[j]==\\'i\\' || s[j]==\\'o\\' || s[j]==\\'u\\'){\\n                x++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 659593,
                "title": "java-simple-sliding-window",
                "content": "```\\n    public int maxVowels(String s, int k) {\\n        Set<Character> st = Set.of(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\');\\n        int res = 0;\\n        for (int l = 0, r = 0, cnt = 0; r < s.length(); r++) {\\n            if (st.contains(s.charAt(r))) cnt++;\\n            if (r >= k && st.contains(s.charAt(l++))) cnt--;\\n            res = Math.max(res, cnt);\\n            if (res == k) return res;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxVowels(String s, int k) {\\n        Set<Character> st = Set.of(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\');\\n        int res = 0;\\n        for (int l = 0, r = 0, cnt = 0; r < s.length(); r++) {\\n            if (st.contains(s.charAt(r))) cnt++;\\n            if (r >= k && st.contains(s.charAt(l++))) cnt--;\\n            res = Math.max(res, cnt);\\n            if (res == k) return res;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 657618,
                "title": "java-sliding-window-o-n-time-complexity",
                "content": "```\\nclass Solution {\\n\\t\\n\\tprivate boolean isVowel(char vowel) {\\n\\t\\treturn vowel == \\'a\\' || vowel == \\'e\\' || vowel == \\'i\\' || vowel == \\'o\\' || vowel== \\'u\\';\\n\\t}\\n \\n\\tpublic int maxVowels(String s, int k) {\\n \\n\\t\\tint maxLen = 0;\\n\\t\\tfor(int i = 0, count = 0; i < s.length(); ++i) {\\n\\t\\t\\tif(isVowel(s.charAt(i))) ++count;\\n            maxLen = Math.max(maxLen, count);\\n\\t\\t\\tif(i >= k - 1 && isVowel(s.charAt(i - k + 1))) -- count;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn maxLen;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tprivate boolean isVowel(char vowel) {\\n\\t\\treturn vowel == \\'a\\' || vowel == \\'e\\' || vowel == \\'i\\' || vowel == \\'o\\' || vowel== \\'u\\';\\n\\t}\\n \\n\\tpublic int maxVowels(String s, int k) {\\n \\n\\t\\tint maxLen = 0;\\n\\t\\tfor(int i = 0, count = 0; i < s.length(); ++i) {\\n\\t\\t\\tif(isVowel(s.charAt(i))) ++count;\\n            maxLen = Math.max(maxLen, count);\\n\\t\\t\\tif(i >= k - 1 && isVowel(s.charAt(i - k + 1))) -- count;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn maxLen;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648777,
                "title": "java-sliding-window",
                "content": "```\\npublic int maxVowels(String s, int k) {\\n\\tSet<Character> set = new HashSet<>();\\n\\tset.add(\\'a\\');set.add(\\'e\\');set.add(\\'i\\');set.add(\\'o\\');set.add(\\'u\\');\\n\\tint[] count = new int[26]; //character count\\n\\tint max = 0, currentVowels = 0;\\n\\tfor (int right = 0; right < s.length(); right++) {\\n\\t\\tif(set.contains(s.charAt(right)))  currentVowels++; //Add (right) th char\\n\\t\\tif(right >= k && set.contains(s.charAt(right - k))) currentVowels--; // Remove (left-1) th char\\n\\t\\tmax = Math.max(currentVowels, max);\\n\\t}\\n\\treturn max;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxVowels(String s, int k) {\\n\\tSet<Character> set = new HashSet<>();\\n\\tset.add(\\'a\\');set.add(\\'e\\');set.add(\\'i\\');set.add(\\'o\\');set.add(\\'u\\');\\n\\tint[] count = new int[26]; //character count\\n\\tint max = 0, currentVowels = 0;\\n\\tfor (int right = 0; right < s.length(); right++) {\\n\\t\\tif(set.contains(s.charAt(right)))  currentVowels++; //Add (right) th char\\n\\t\\tif(right >= k && set.contains(s.charAt(right - k))) currentVowels--; // Remove (left-1) th char\\n\\t\\tmax = Math.max(currentVowels, max);\\n\\t}\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4003024,
                "title": "python3-sliding-window-fixed-size-o-n-time-o-1-space",
                "content": "# Intuition\\nThe question asks us to do something in a subarray of size `k`. This is quite standard with **Sliding Window** - *fixed size* problems, where `k` is the fixed size of the window.\\n\\n### What is a Sliding Window of fixed size ?\\n> The fixed-size sliding window technique is a computer science algorithm that uses a predefined window size that remains constant throughout the problem-solving process. The window size is usually stated in the problem, for example, \"find the highest sum of three contiguous numbers in the following array\". The window size will be three, and the action will be summing and comparing. \\n> \\n> The fixed-size sliding window technique is often used to deal with problems involving subarrays of a fixed size. These problems may include finding the maximum or minimum sum of consecutive `k` elements in an array. \\n\\n# Approach\\nThe idea behind having a fixed sliding window is to maintain two pointers that are k apart from each other and fit a certain constraint.\\n\\n1. Keep two pointers `l`, `r` which we will use to expand/close window of size k. We also want to have the vowels as a `hashset` that will ive us constant time lookup.\\n2. Use a for loop to expand the right side of the window.\\n3. At each position, check if the size of the current window is > k. If yes, we will close the left side of the window by incrementing l by 1. Keep in mind we will also need to decrement vowel count if the place where `l` is currently is a vowel\\n4. The window will keep expanding towards right as we are using a regualr for loop to maintain and move `r`. At each step, we will see if char at index r `s[r]` is a vowel. If true, we will increment `vowelCount` by one. We will also check and update `maxCount` to check if we found a window with max vowel count.\\n\\n# Complexity\\n- Time complexity:\\nO(N) - We traverse the array only once\\n\\n- Space complexity:\\nO(1) - Extra space to keep vowels and the 3 variables is constant\\n\\n# Code\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'])\\n        l, vowelCount, maxCount = 0, 0, 0\\n\\n        for r in range(len(s)):\\n\\n            # close window\\n            if r - l + 1 > k:\\n                if s[l] in vowels:\\n                    vowelCount -= 1\\n                l += 1\\n\\n            # open window\\n            if s[r] in vowels:\\n                    vowelCount += 1\\n                    maxCount = max(maxCount, vowelCount)\\n        return maxCount\\n        \\n```\\n\\n\\n#### Note:\\nPlease leave a comment if you think something is incorrect. \\n\\n\\uD83D\\uDC4D **Upvote if you like the approach.** \\n",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'])\\n        l, vowelCount, maxCount = 0, 0, 0\\n\\n        for r in range(len(s)):\\n\\n            # close window\\n            if r - l + 1 > k:\\n                if s[l] in vowels:\\n                    vowelCount -= 1\\n                l += 1\\n\\n            # open window\\n            if s[r] in vowels:\\n                    vowelCount += 1\\n                    maxCount = max(maxCount, vowelCount)\\n        return maxCount\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880517,
                "title": "straightforward-and-fast-99-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want the maximum count of any k-length substring of s. A sliding window seems appropriate.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nReplace each of the characters in s with an int value: 1 for vowels, 0 otherwise (s will now be a list of ints). After that, the sum of all the elements of a k-length slice will be the count of vowels in that slice.\\n\\nWe\\'ll return the maximum sum of any k-length slice (window) on s. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO($$n$$) for an n-character string as we traverse s once to make the list of 1 and 0 values, and again to find the maximum sum of k consecutive elements.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO($$n$$). The list of 1\\'s and 0\\'s has length n for n input characters. Even though we replace the original s with the list of ints, that list is newly created (by a list comprehension) and doesn\\'t allow the input string to be garbage collected as it still exists in the caller\\'s scope.\\n\\n# Code\\n```\\n# Constant Dictionary of characters: vowels are 1, others are 0 (default)\\nVOWELS = defaultdict(int)\\nVOWELS[\\'a\\'] = VOWELS[\\'e\\'] = VOWELS[\\'i\\'] = VOWELS[\\'o\\'] = VOWELS[\\'u\\'] = 1\\n\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        \\'\\'\\'\\n        Replace characters in s with an int value: 1 for vowels, 0 otherwise.\\n        We\\'ll return the maximum sum of any k-length window on s. \\n        \\'\\'\\'\\n        s = [VOWELS[c] for c in s]\\n        max_count = count = sum(s[:k])      # Both counts hold the initial sum\\n        for i in range(len(s) - k):         # Advance the window\\n            count += s[i + k] - s[i]        # Adjust the count\\n            if count > max_count:           # Keep the higher count\\n                max_count = count\\n        return max_count\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\n# Constant Dictionary of characters: vowels are 1, others are 0 (default)\\nVOWELS = defaultdict(int)\\nVOWELS[\\'a\\'] = VOWELS[\\'e\\'] = VOWELS[\\'i\\'] = VOWELS[\\'o\\'] = VOWELS[\\'u\\'] = 1\\n\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        \\'\\'\\'\\n        Replace characters in s with an int value: 1 for vowels, 0 otherwise.\\n        We\\'ll return the maximum sum of any k-length window on s. \\n        \\'\\'\\'\\n        s = [VOWELS[c] for c in s]\\n        max_count = count = sum(s[:k])      # Both counts hold the initial sum\\n        for i in range(len(s) - k):         # Advance the window\\n            count += s[i + k] - s[i]        # Adjust the count\\n            if count > max_count:           # Keep the higher count\\n                max_count = count\\n        return max_count\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694201,
                "title": "tc-o-n-sc-o-1-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsliding Window\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char s){\\n        if(s == \\'a\\' ||s == \\'e\\' ||s == \\'i\\' ||s == \\'o\\' ||s == \\'u\\') return true;\\n        return false;\\n    }\\n\\n    int maxVowels(string s, int k) {\\n        int ans = 0;\\n        int vowelCount = 0;\\n        for(int i =0;i<k;i++){\\n            if(isVowel(s[i])){\\n                vowelCount++;\\n            }\\n        }\\n        int i = k;\\n        int n = s.size();\\n        ans = vowelCount;\\n        while(i<n){\\n            if(isVowel(s[i-k])) vowelCount--;\\n            if(isVowel(s[i])) vowelCount++;\\n            ans = max(ans,vowelCount);\\n            i++;\\n        }\\n        \\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char s){\\n        if(s == \\'a\\' ||s == \\'e\\' ||s == \\'i\\' ||s == \\'o\\' ||s == \\'u\\') return true;\\n        return false;\\n    }\\n\\n    int maxVowels(string s, int k) {\\n        int ans = 0;\\n        int vowelCount = 0;\\n        for(int i =0;i<k;i++){\\n            if(isVowel(s[i])){\\n                vowelCount++;\\n            }\\n        }\\n        int i = k;\\n        int n = s.size();\\n        ans = vowelCount;\\n        while(i<n){\\n            if(isVowel(s[i-k])) vowelCount--;\\n            if(isVowel(s[i])) vowelCount++;\\n            ans = max(ans,vowelCount);\\n            i++;\\n        }\\n        \\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681671,
                "title": "o-n-explained-python-java-solution-faster-than-90-using-set-very-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are using the property of HashSet which guarantee us that element in our Set in O(1) time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are creating Set that will contain all vowel letters. Go through k first letters and update count if it\\'s needed. Than by using sliding windows technique we are getting right answer. Adventages of this solution is that we can easily update vowels set(adding uppercase vowel letters) by not affecting the main code. This solution is more generic.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java solution\\n```\\nclass Solution {\\n    Set<Character> vowelsSet = Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\');\\n    public int maxVowels(String s, int k) {\\n        var vowelsCount = 0;\\n\\n        for (var i = 0; i < k; ++i) {\\n            if (vowelsSet.contains(s.charAt(i))) {\\n                ++vowelsCount;\\n            }\\n        }\\n        var res = vowelsCount;\\n        for (var i = k; i < s.length(); ++i) {\\n            if (vowelsSet.contains(s.charAt(i))) {\\n                ++vowelsCount;\\n            }\\n            if (vowelsSet.contains(s.charAt(i-k))) {\\n                --vowelsCount;\\n            }\\n            res = Math.max(res, vowelsCount);\\n        }\\n        return res;\\n    }\\n}\\n```\\n# Python solution\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        curr_count = 0\\n        for i in range(k):\\n            if s[i] in vowels:\\n                curr_count += 1\\n        \\n        res = curr_count\\n\\n        for i in range(k, len(s)):\\n            if s[i] in vowels:\\n                curr_count += 1\\n            if s[i-k] in vowels:\\n                curr_count -= 1\\n            res = max(res, curr_count)\\n        return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    Set<Character> vowelsSet = Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\');\\n    public int maxVowels(String s, int k) {\\n        var vowelsCount = 0;\\n\\n        for (var i = 0; i < k; ++i) {\\n            if (vowelsSet.contains(s.charAt(i))) {\\n                ++vowelsCount;\\n            }\\n        }\\n        var res = vowelsCount;\\n        for (var i = k; i < s.length(); ++i) {\\n            if (vowelsSet.contains(s.charAt(i))) {\\n                ++vowelsCount;\\n            }\\n            if (vowelsSet.contains(s.charAt(i-k))) {\\n                --vowelsCount;\\n            }\\n            res = Math.max(res, vowelsCount);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        curr_count = 0\\n        for i in range(k):\\n            if s[i] in vowels:\\n                curr_count += 1\\n        \\n        res = curr_count\\n\\n        for i in range(k, len(s)):\\n            if s[i] in vowels:\\n                curr_count += 1\\n            if s[i-k] in vowels:\\n                curr_count -= 1\\n            res = max(res, curr_count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493014,
                "title": "was-beating-100-java-6ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolution must be simple and straightforward to avoid any inefficiency.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nchar -> isVowel mapping using simple array.\\nExclude any other idle or duplicated operation.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic int maxVowels(String s, int k) {\\n\\tboolean[] vowels = new boolean[\\'z\\' + 1];\\n\\t\\tvowels[\\'u\\'] = true;\\n\\t\\tvowels[\\'e\\'] = true;\\n\\t\\tvowels[\\'i\\'] = true;\\n\\t\\tvowels[\\'o\\'] = true;\\n\\t\\tvowels[\\'a\\'] = true;\\n\\n\\tchar[] chars = s.toCharArray();\\n\\tint r = 0, maxN = 0;\\n\\tfor (;r < k; r++)\\n\\t\\tif (vowels[chars[r]])\\n\\t\\t\\tmaxN++;\\n\\n\\tint len = s.length(), l = 0, n = maxN;\\n\\tfor (;r < len; l++, r++) {\\n\\t\\tif (vowels[chars[l]])\\n\\t\\t\\tn--;\\n\\t\\tif (vowels[chars[r]])\\n\\t\\t\\tn++;\\n\\t\\tif (n > maxN)\\n\\t\\t\\tmaxN = n;\\n\\t}\\n\\treturn maxN;\\n}\\n\\n}\\n```\\n[Submission Detail](https://leetcode.com/submissions/detail/945450700).\\n\\nP.S. Upgraded to [4-ms solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3493619/beats-100-java-solutions-4-ms-runtime).",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\npublic int maxVowels(String s, int k) {\\n\\tboolean[] vowels = new boolean[\\'z\\' + 1];\\n\\t\\tvowels[\\'u\\'] = true;\\n\\t\\tvowels[\\'e\\'] = true;\\n\\t\\tvowels[\\'i\\'] = true;\\n\\t\\tvowels[\\'o\\'] = true;\\n\\t\\tvowels[\\'a\\'] = true;\\n\\n\\tchar[] chars = s.toCharArray();\\n\\tint r = 0, maxN = 0;\\n\\tfor (;r < k; r++)\\n\\t\\tif (vowels[chars[r]])\\n\\t\\t\\tmaxN++;\\n\\n\\tint len = s.length(), l = 0, n = maxN;\\n\\tfor (;r < len; l++, r++) {\\n\\t\\tif (vowels[chars[l]])\\n\\t\\t\\tn--;\\n\\t\\tif (vowels[chars[r]])\\n\\t\\t\\tn++;\\n\\t\\tif (n > maxN)\\n\\t\\t\\tmaxN = n;\\n\\t}\\n\\treturn maxN;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490517,
                "title": "c-solution-easy-sliding-window-explained",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isV(char c){  // Just for checking if the char is vowel or not\\n        return (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'); \\n    }\\n    int maxVowels(string s, int k) {\\n        int ans=0;\\n        for(int i=0,no=0;i<s.length();i++){\\n            if(i >= k && isV(s[i-k]))   no--; // I our window exceed the k that means we remove the last element i.e. if it\\'s vowel then we decrease the no(Current vowel in window)\\n            if(isV(s[i]))   no++;  // now we check if the current char is vowel or not. if its is we increase the no\\n            ans = max(ans,no);  // We take the maximum of the vowels in the any window\\n        }        \\n        return ans;\\n    }\\n};\\n```\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/079cde0c-5a80-4fd8-8afd-79ab413641e2_1683311237.3900177.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isV(char c){  // Just for checking if the char is vowel or not\\n        return (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'); \\n    }\\n    int maxVowels(string s, int k) {\\n        int ans=0;\\n        for(int i=0,no=0;i<s.length();i++){\\n            if(i >= k && isV(s[i-k]))   no--; // I our window exceed the k that means we remove the last element i.e. if it\\'s vowel then we decrease the no(Current vowel in window)\\n            if(isV(s[i]))   no++;  // now we check if the current char is vowel or not. if its is we increase the no\\n            ans = max(ans,no);  // We take the maximum of the vowels in the any window\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490347,
                "title": "sliding-window-golang-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ where n is the length of the string\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ because we are using constant space.\\n\\n\\n# Code\\n```\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc maxVowels(s string, k int) int {\\n    vowels := map[rune]bool{\\'a\\': true, \\'e\\': true, \\'i\\': true, \\'o\\': true, \\'u\\': true}\\n    count := 0\\n\\n    for i := 0; i < k; i++ {\\n        if vowels[rune(s[i])] {\\n            count++\\n        }\\n    }\\n\\n    ans := count\\n\\n    for i := k; i < len(s); i++ {\\n        if vowels[rune(s[i])] {\\n            count++\\n        }\\n        if vowels[rune(s[i-k])] {\\n            count--\\n        }\\n\\n        ans = max(ans, count)\\n    }\\n\\n    return ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc maxVowels(s string, k int) int {\\n    vowels := map[rune]bool{\\'a\\': true, \\'e\\': true, \\'i\\': true, \\'o\\': true, \\'u\\': true}\\n    count := 0\\n\\n    for i := 0; i < k; i++ {\\n        if vowels[rune(s[i])] {\\n            count++\\n        }\\n    }\\n\\n    ans := count\\n\\n    for i := k; i < len(s); i++ {\\n        if vowels[rune(s[i])] {\\n            count++\\n        }\\n        if vowels[rune(s[i-k])] {\\n            count--\\n        }\\n\\n        ans = max(ans, count)\\n    }\\n\\n    return ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489989,
                "title": "simple-sliding-window-technique-java",
                "content": "# Sliding Window Technique : \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Instruction : Read and trace the code properly... you\\'ll get the Intuition of the problem.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int ans = Integer.MIN_VALUE;\\n        int count = 0;\\n        for(int i = 0;i<k;i++)\\n        {\\n            char c = s.charAt(i);\\n            if(\"aeiou\".indexOf(c)!=-1)\\n            {\\n                count++;\\n            }\\n        }\\n        ans = Math.max(ans,count);\\n        for(int i = k;i<s.length();i++)\\n        {\\n            if(\"aeiou\".indexOf(s.charAt(i-k))!=-1)\\n            {\\n                count--;\\n            }\\n            if(\"aeiou\".indexOf(s.charAt(i))!=-1)\\n            {\\n                count++;\\n            }\\n            ans = Math.max(ans,count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int ans = Integer.MIN_VALUE;\\n        int count = 0;\\n        for(int i = 0;i<k;i++)\\n        {\\n            char c = s.charAt(i);\\n            if(\"aeiou\".indexOf(c)!=-1)\\n            {\\n                count++;\\n            }\\n        }\\n        ans = Math.max(ans,count);\\n        for(int i = k;i<s.length();i++)\\n        {\\n            if(\"aeiou\".indexOf(s.charAt(i-k))!=-1)\\n            {\\n                count--;\\n            }\\n            if(\"aeiou\".indexOf(s.charAt(i))!=-1)\\n            {\\n                count++;\\n            }\\n            ans = Math.max(ans,count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489206,
                "title": "maxvowels-in-k-substring-python-beats-97-on-runtime",
                "content": "# Intuition\\nWhile the question asks what\\'s the maximum across all the substrings, iterating over each substring will be inefficient. Two adjacent substrings, `s[i:(i+k)]` and `s[(i+1):(i+k+1)]`, have a significant overlap of $k-1$ characters. This means if we do any kind of check or operation on all the characters in a substring, we\\'ll have done that same check or operation on all the overlapping the characters previously.\\n\\nOnce we\\'ve done our check or operation on the initial substring, `s[0:k]`, in any subsequent substrings all that matters to us is whether the character that\\'s left the substring was a vowel and whether the character that\\'s new to the substring is a vowel.\\n\\nWe can also avoid double-checking whether a character is a vowel (first when it enters the substring and again when it leaves) by checking whether each character is a vowel once at the start.\\n\\n# Approach\\n\\n1. Create a boolean list indicating whether each character in `s` is a vowel.\\n\\n2. Count how many vowels are in the initial $k$-substring, `s[0:k]` to initalise a running total of vowels and an initial maximum.\\n\\n3. For each subsequent substring:\\n\\n    1. If the character that\\'s no longer in the substring was a vowel, decrease our running total by one.\\n    \\n    2. If the character new to the substring is a vowel, increase our running total by one.\\n    \\n    3. Update our maximum if our running total exceeds the current maximum.\\n    \\n4. If at any point the running total is equal to the length of the substring, we return $k$; it\\'s not possible to have $k+1$ vowels in only $k$ characters.\\n\\n\\n# Complexity\\nWe do $n$ inclusion checks to produce `isVowel`, each of which is $O(1)$ on average [[1]](https://wiki.python.org/moin/TimeComplexity). There are also at most $2n - k - 1$ binary operations and $3n-3k$ comparisons. This means our **time complexity is $O(n)$**.\\n\\nWe create a new boolean vector of length $n$ plus two additional integer variables. This means our **space complexity is $O(n)$**.\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        \"\"\"\\n        Takes a string s and an integer k as inputs, and then\\n        returns the maximum number of vowels that appear in\\n        any substring of s with length k.\\n        \"\"\"\\n        # do all the inclusion checks once at the start\\n        isVowel = [c in {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'} for c in s]\\n        # get initial number (which is also initial max)\\n        maxVowels = nowVowels = sum(isVowel[:k])\\n        # highest possible is substring of all vowels\\n        if maxVowels == k: return k\\n        # iterate over remaining characters\\n        for i in range(k,len(s)):\\n            # check if character leaving substring is vowel\\n            if isVowel[i-k]: nowVowels -=1\\n            # check if character entering substring is vowel\\n            if isVowel[i]: nowVowels += 1\\n            # check if found a new maximum\\n            if nowVowels > maxVowels: maxVowels = nowVowels\\n            # check if reached highest possible\\n            if maxVowels == k: return k\\n        # if never reached highest possible, return max\\n        return maxVowels\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        \"\"\"\\n        Takes a string s and an integer k as inputs, and then\\n        returns the maximum number of vowels that appear in\\n        any substring of s with length k.\\n        \"\"\"\\n        # do all the inclusion checks once at the start\\n        isVowel = [c in {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'} for c in s]\\n        # get initial number (which is also initial max)\\n        maxVowels = nowVowels = sum(isVowel[:k])\\n        # highest possible is substring of all vowels\\n        if maxVowels == k: return k\\n        # iterate over remaining characters\\n        for i in range(k,len(s)):\\n            # check if character leaving substring is vowel\\n            if isVowel[i-k]: nowVowels -=1\\n            # check if character entering substring is vowel\\n            if isVowel[i]: nowVowels += 1\\n            # check if found a new maximum\\n            if nowVowels > maxVowels: maxVowels = nowVowels\\n            # check if reached highest possible\\n            if maxVowels == k: return k\\n        # if never reached highest possible, return max\\n        return maxVowels\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488941,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(char c)\\n    {\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\')return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) \\n    {\\n        int ans=0;\\n        int count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(check(s[i]))count++;\\n        }\\n        ans=count;\\n        int i=0,j=k;\\n        while(j<s.size())\\n        {\\n            if(check(s[j]))count++;\\n            if(check(s[i]))count--;\\n            ans=max(ans,count);\\n            j++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(char c)\\n    {\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\')return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) \\n    {\\n        int ans=0;\\n        int count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(check(s[i]))count++;\\n        }\\n        ans=count;\\n        int i=0,j=k;\\n        while(j<s.size())\\n        {\\n            if(check(s[j]))count++;\\n            if(check(s[i]))count--;\\n            ans=max(ans,count);\\n            j++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488590,
                "title": "easy-o-n-tc-o-1-sc-sliding-window-c-solution-you-should-look-once",
                "content": "> [# Intuition]()\\nSliding Window\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust increase the count when vowel encounters in current window and decrease cnt when a vowel released by window, and maximise ans in each iteration.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int ans = 0, cnt = 0, n = s.length();\\n        unordered_map<char, bool> mp;\\n        mp[\\'a\\'] = mp[\\'e\\'] = mp[\\'i\\'] = mp[\\'o\\'] = mp[\\'u\\'] = 1;\\n        for(int i = 0; i< n; ++i)\\n        {\\n            if(mp.count(s[i])) ++cnt;\\n            if(i>=k && mp.count(s[i-k])) --cnt;\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int ans = 0, cnt = 0, n = s.length();\\n        unordered_map<char, bool> mp;\\n        mp[\\'a\\'] = mp[\\'e\\'] = mp[\\'i\\'] = mp[\\'o\\'] = mp[\\'u\\'] = 1;\\n        for(int i = 0; i< n; ++i)\\n        {\\n            if(mp.count(s[i])) ++cnt;\\n            if(i>=k && mp.count(s[i-k])) --cnt;\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488338,
                "title": "bhai-tere-liye-hi-hai-easy-c-sliding",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf you know the Sliding Window Technique then ```jake solve karo  na yaha kya karne aaye ho``` and If you don\\'t then read below\\uD83D\\uDC47\\uD83D\\uDC47:\\n\\n1. Just calculate the number of vowels (count) for the first ```k``` char of string.\\n2. Now store it in a new variable ```max_val```(this the window size).\\n3. Iterate over string from i=k to i<n.\\n4. Every time check s[i-k] is vowel or not, if it is the count-- and check s[i] also if it is vowel then count++.\\n5. Store max of count in ```max_val```.\\n6. Return it.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n=s.size();\\n        int count=0;\\n        char x;\\n\\n        for(int i=0;i<k;i++){\\n            x = s[i];\\n            if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\' || x==\\'o\\' || x==\\'u\\') count++;\\n        }\\n\\n        int max_val = count;\\n\\n        for(int i=k;i<n;i++){\\n            x = s[i-k];\\n            if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\' || x==\\'o\\' || x==\\'u\\') count--;\\n            \\n            x = s[i];\\n            if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\' || x==\\'o\\' || x==\\'u\\') count++;\\n\\n            max_val = max(max_val, count);\\n        }\\n\\n        return max_val;\\n    }\\n};\\n```\\n\\n![please upvote.png](https://assets.leetcode.com/users/images/d3233765-9c64-4959-b78e-70570317566a_1683275278.4116118.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```jake solve karo  na yaha kya karne aaye ho```\n```k```\n```max_val```\n```max_val```\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n=s.size();\\n        int count=0;\\n        char x;\\n\\n        for(int i=0;i<k;i++){\\n            x = s[i];\\n            if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\' || x==\\'o\\' || x==\\'u\\') count++;\\n        }\\n\\n        int max_val = count;\\n\\n        for(int i=k;i<n;i++){\\n            x = s[i-k];\\n            if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\' || x==\\'o\\' || x==\\'u\\') count--;\\n            \\n            x = s[i];\\n            if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\' || x==\\'o\\' || x==\\'u\\') count++;\\n\\n            max_val = max(max_val, count);\\n        }\\n\\n        return max_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487984,
                "title": "swift-easy-linear-solution",
                "content": "# Intuition\\nSliding window: \\n1) map string of chars to array of `1`(for vowel) and `0`(for other)\\n2) calculate `1`(vowels) from 0 to k\\n3) from k to end subtract old value `array[i - k]` and add new value `array[i]`\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    func maxVowels(_ s: String, _ k: Int) -> Int {\\n        \\n        var array: [Int] = s.map { [\"a\",\"e\",\"i\",\"o\",\"u\"].contains($0) ? 1 : 0 }\\n        var count = array.prefix(k).reduce(0, +)\\n\\n        if array.count <= k { return count }\\n        var maxCount = count\\n        for i in (k..<array.count) {\\n            count = count - array[i - k] + array[i]\\n            maxCount = max(maxCount, count)\\n        } \\n        return maxCount\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxVowels(_ s: String, _ k: Int) -> Int {\\n        \\n        var array: [Int] = s.map { [\"a\",\"e\",\"i\",\"o\",\"u\"].contains($0) ? 1 : 0 }\\n        var count = array.prefix(k).reduce(0, +)\\n\\n        if array.count <= k { return count }\\n        var maxCount = count\\n        for i in (k..<array.count) {\\n            count = count - array[i - k] + array[i]\\n            maxCount = max(maxCount, count)\\n        } \\n        return maxCount\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487419,
                "title": "python-short-1-liner-functional-programming",
                "content": "# Approach\\n1. Maintain 2 strings, `s_start` and `s_end`, where `s_start` is `k` characters behind of `s_end`, i.e when `s_end[i] = s[i]` and `s_start[i] = s[i - k]`.\\n\\n2. To achieve this, set `s_end` to `s` and prepend a consonant `k` times to `s_start`.\\n    Example:\\n    ```python\\n    s_end = s\\n    s_start = chain(repeat(\\'z\\', k), s) # (Avoiding string addition)\\n    ```\\n\\n3. Loop through the strings one character pair at a time using `zip(s_start, s_end)`.\\n    This gives the ends of the current sliding window.\\n\\n4. Keep a running `count` of vowels, and for each window pair `[a, b]`, slide the window to drop `a` and include `b` and update the count.\\n    `count = count - (a is vowel) + (b is vowel)`.\\n\\n5. Return the `max` of all counts.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the length of s`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        return max(accumulate(\\n            zip(chain(repeat(\\'z\\', k), s), s),\\n            lambda a, x: a - (x[0] in \\'aeiou\\') + (x[1] in \\'aeiou\\'),\\n            initial=0,\\n        ))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Sliding Window"
                ],
                "code": "```python\\n    s_end = s\\n    s_start = chain(repeat(\\'z\\', k), s) # (Avoiding string addition)\\n    ```\n```python\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        return max(accumulate(\\n            zip(chain(repeat(\\'z\\', k), s), s),\\n            lambda a, x: a - (x[0] in \\'aeiou\\') + (x[1] in \\'aeiou\\'),\\n            initial=0,\\n        ))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487371,
                "title": "very-easy-and-simple-solution-almost-looks-like-with-editorial-version-of-solution-but-in-js",
                "content": "\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxVowels = function(s, k) {\\n    let array = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n    let count = 0\\n    for(let i = 0; i < k; i++) {\\n        if(array.includes(s[i])) {\\n            count++\\n        }\\n    }\\n    let max = count\\n    for(let i = k; i < s.length; i++) {\\n        if(array.includes(s[i])) {\\n            count++\\n        }\\n        if(array.includes(s[i - k])) {\\n            count--\\n        }\\n        max = Math.max(max, count)\\n    }\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxVowels = function(s, k) {\\n    let array = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n    let count = 0\\n    for(let i = 0; i < k; i++) {\\n        if(array.includes(s[i])) {\\n            count++\\n        }\\n    }\\n    let max = count\\n    for(let i = k; i < s.length; i++) {\\n        if(array.includes(s[i])) {\\n            count++\\n        }\\n        if(array.includes(s[i - k])) {\\n            count--\\n        }\\n        max = Math.max(max, count)\\n    }\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3487339,
                "title": "optimal-solution-using-sliding-window-clean-well-defined-and-well-explained-code",
                "content": "\\n\\n# Approach\\nThe idea is to use a sliding window of length k to iterate through the string and count the number of vowels in each substring of length k. We initialize maxVowels and currVowels to 0, and then iterate through the first k characters of the string to count the number of vowels. We update maxVowels to be the maximum of maxVowels and currVowels.\\n\\nThen, we iterate through the rest of the string using a sliding window of length k. At each step, we subtract the count of the vowel that is leaving the window (i.e., the vowel at position i-k) and add the count of the vowel that is entering the window (i.e., the vowel at position i). We update maxVowels to be the maximum of maxVowels and currVowels at each step. Finally, we return maxVowels.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int maxVowels = 0, currVowels = 0;\\n        for(int i = 0; i < k; i++) {\\n            if(isVowel(s[i])) currVowels++;\\n        }\\n        maxVowels = currVowels;\\n        for(int i = k; i < s.length(); i++) {\\n            if(isVowel(s[i-k])) currVowels--;\\n            if(isVowel(s[i])) currVowels++;\\n            maxVowels = max(maxVowels, currVowels);\\n        }\\n        return maxVowels;\\n    }\\n    \\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int maxVowels = 0, currVowels = 0;\\n        for(int i = 0; i < k; i++) {\\n            if(isVowel(s[i])) currVowels++;\\n        }\\n        maxVowels = currVowels;\\n        for(int i = k; i < s.length(); i++) {\\n            if(isVowel(s[i-k])) currVowels--;\\n            if(isVowel(s[i])) currVowels++;\\n            maxVowels = max(maxVowels, currVowels);\\n        }\\n        return maxVowels;\\n    }\\n    \\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487214,
                "title": "simple-c-solution-with-explanation-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic intuition that comes in mind to iterate for k size and keep count of vowel in first window then from that position start sliding the window check the incoming and outgoing element form the window and in each iteration keep updating the answer count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Created a function to check for vowel characters.\\n- `ans` having the final answer, `n` for the size of string, `temp` to store the count of each window.\\n- Iterate firstly for first window and have a starting count.\\n- Updata `ans` then iterate in string from that position and check whether the incoming character is vowel or not, also check for outgoing character.\\n- Updata the `ans` in each k size window.\\n- Return `ans`;\\n# IF YOU LIKE THE SOLUTION PLEASE UPVOTE \\uD83D\\uDE07\\uD83D\\uDE42\\n# Complexity\\n- Time complexity:`O(N)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool checkVowel(char x){\\n        if(x == \\'a\\'||x == \\'e\\'||x == \\'i\\'||x == \\'o\\'||x == \\'u\\')    return true;\\n        return false;\\n    }\\npublic:\\n    int maxVowels(string s, int k) {\\n        int ans = 0, n = s.length(), temp = 0;\\n        for(int i = 0; i<n && i<k; i++){\\n            if(checkVowel(s[i]))    temp++;\\n        }\\n        ans = max(ans,temp);\\n        for(int i=k; i<n; i++){\\n            if(checkVowel(s[i]))    temp++;\\n            if(checkVowel(s[i-k]))  temp--;\\n            ans = max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool checkVowel(char x){\\n        if(x == \\'a\\'||x == \\'e\\'||x == \\'i\\'||x == \\'o\\'||x == \\'u\\')    return true;\\n        return false;\\n    }\\npublic:\\n    int maxVowels(string s, int k) {\\n        int ans = 0, n = s.length(), temp = 0;\\n        for(int i = 0; i<n && i<k; i++){\\n            if(checkVowel(s[i]))    temp++;\\n        }\\n        ans = max(ans,temp);\\n        for(int i=k; i<n; i++){\\n            if(checkVowel(s[i]))    temp++;\\n            if(checkVowel(s[i-k]))  temp--;\\n            ans = max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487004,
                "title": "simple-c-solution-easy-to-read",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxVowels(string s, int k) {\\n       int result = 0;\\n       int count =0;\\n       for(int i = 0; i < k; i++)\\n       {\\n            if(isVowel(s[i]))\\n                count++;\\n       }\\n       result = count;\\n       for(int j = k; j < s.Length; j++)\\n       {\\n            if(isVowel(s[j-k]))\\n                count--;\\n            if(isVowel(s[j]))\\n                count++;\\n            result = Math.Max(result, count);\\n       }\\n       return result;\\n    }\\n     public bool isVowel(char c)\\n    {\\n        return (c==\\'a\\') || (c==\\'e\\') || (c==\\'i\\') || (c==\\'o\\') || (c==\\'u\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxVowels(string s, int k) {\\n       int result = 0;\\n       int count =0;\\n       for(int i = 0; i < k; i++)\\n       {\\n            if(isVowel(s[i]))\\n                count++;\\n       }\\n       result = count;\\n       for(int j = k; j < s.Length; j++)\\n       {\\n            if(isVowel(s[j-k]))\\n                count--;\\n            if(isVowel(s[j]))\\n                count++;\\n            result = Math.Max(result, count);\\n       }\\n       return result;\\n    }\\n     public bool isVowel(char c)\\n    {\\n        return (c==\\'a\\') || (c==\\'e\\') || (c==\\'i\\') || (c==\\'o\\') || (c==\\'u\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486941,
                "title": "java-solution-for-number-of-vowels-in-a-substring-of-given-length-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given solution traverses the input string s and counts the number of vowels in a sliding window of size k. At each index i, it checks if the character s[i-k] that is going out of the window is a vowel and decrements the count accordingly. It then checks if the character s[i] that is coming into the window is a vowel and increments the count accordingly. Finally, it keeps track of the maximum count seen so far and returns it as the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use a sliding window of size k to iterate over all substrings of s with length k, while keeping track of the count of vowels in the current substring. We start with the first k characters of s and count the number of vowels. Then, we slide the window one character to the right and update the vowel count by subtracting the vowel count of the character that just went out of the window (if it was a vowel) and adding the vowel count of the character that just came into the window (if it is a vowel). We repeat this process until we reach the end of s, and return the maximum vowel count that we encountered during the process.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of s, since we only iterate over s once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), since we only use a constant amount of extra memory to store the vowel count and the maximum count.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) \\n    {\\n        int maxCount = 0;\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) \\n        {\\n            char c = s.charAt(i);\\n            if (isVowel(c)) \\n            {\\n                count++;\\n            }\\n            if (i >= k && isVowel(s.charAt(i - k))) \\n            {\\n                count--;\\n            }\\n            maxCount = Math.max(maxCount, count);\\n        }\\n        return maxCount;\\n    }\\n    private boolean isVowel(char c) \\n    {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) \\n    {\\n        int maxCount = 0;\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) \\n        {\\n            char c = s.charAt(i);\\n            if (isVowel(c)) \\n            {\\n                count++;\\n            }\\n            if (i >= k && isVowel(s.charAt(i - k))) \\n            {\\n                count--;\\n            }\\n            maxCount = Math.max(maxCount, count);\\n        }\\n        return maxCount;\\n    }\\n    private boolean isVowel(char c) \\n    {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326143,
                "title": "java-easy-sliding-window",
                "content": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int max=0,cnt=0;\\n        for(int i=0,j=0;j<s.length();j++){\\n            if(j-i+1<k){\\n                if(s.charAt(j)==\\'a\\' ||s.charAt(j)==\\'e\\' || s.charAt(j)==\\'i\\' || s.charAt(j)==\\'o\\' || s.charAt(j)==\\'u\\' ){\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                if(s.charAt(j)==\\'a\\' ||s.charAt(j)==\\'e\\' || s.charAt(j)==\\'i\\' || s.charAt(j)==\\'o\\' || s.charAt(j)==\\'u\\'){\\n                    cnt++;\\n                }\\n                max=Math.max(max,cnt);\\n                if(s.charAt(i)==\\'a\\' ||s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){\\n                    cnt--;\\n                }\\n                i++;\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int max=0,cnt=0;\\n        for(int i=0,j=0;j<s.length();j++){\\n            if(j-i+1<k){\\n                if(s.charAt(j)==\\'a\\' ||s.charAt(j)==\\'e\\' || s.charAt(j)==\\'i\\' || s.charAt(j)==\\'o\\' || s.charAt(j)==\\'u\\' ){\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                if(s.charAt(j)==\\'a\\' ||s.charAt(j)==\\'e\\' || s.charAt(j)==\\'i\\' || s.charAt(j)==\\'o\\' || s.charAt(j)==\\'u\\'){\\n                    cnt++;\\n                }\\n                max=Math.max(max,cnt);\\n                if(s.charAt(i)==\\'a\\' ||s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){\\n                    cnt--;\\n                }\\n                i++;\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485108,
                "title": "brute-force-to-optimal-approach-thought-process",
                "content": "Hi Everyone,\\n\\nLet us try to move from ***Brute Force Solution to an Optimal Solution*** to understand the completeness of our approach. I will try to explain the thought process behind each appraoch, and have added the code below for reference. Feel free to point out any improvements. \\n\\nOptimal Solution uses *Sliding Window Approach* - I will try to explain it step by step.\\n\\n-----------**Brute Force Approach** - **This clears 99/106 test cases and then leads to TLE**------------\\n\\nThe steps have been marked below as well as in code for understanding.\\n\\n* **STEP 1** : In this, we can traverse over the array and generate all the substrings of length *k* and store them in an array named ***arr*** . Since we are traversing the entire array, the arrays generated at the last may not be of size k. We will handle this situation later.\\n\\n* **STEP 2** : After this, we can traverse over the new array containing all the substrings, and put a condition that if length of the substring == k, we can iterate over this again and count the number of vowels inside it, which we can store it in another array named as ***arr1***.\\n\\n* **STEP 3** : Now, we can simply return the maximum value inside arr1, which is the maximum number of vowels in a substring of size k. If arr1 is empty, we can return 0.\\n\\n***Complexity Analysis*** : \\n\\n ***Time Complexity  - O(N^2)***\\n ***Space Complexity  - O(N)***\\n \\n \\n\\n**Here is the code for Brute Force Approach** : \\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        \\n        n = len(s)\\n       \\n        #STEP 1\\n        arr = []\\n        for i in range(0, n):\\n                arr.append(s[i : i + k])\\n        \\n        vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\\n        arr1 = []\\n        \\n\\t\\t#STEP 2\\n        for i in arr:\\n            count = 0 \\n            if len(i) == k:\\n                for j in i:\\n                    if j in vowels:\\n                        count += 1 \\n                arr1.append(count)\\n        \\n\\t\\t#STEP 3\\n        if len(arr1) != 0:\\n            value = max(arr1)\\n            return value\\n        else:\\n            return 0\\n```\\n\\n\\n--------------**Optimal Approach** - Help taken from Discussions - Clears all test cases-----------------\\n\\nVery often, I have seen that optimising the solution requires use of certain observations which we did not use in our Brute Force solution. One of them could be : **We know that maximum number of vowels can never be greater than k as all substrings of length k are only being considered**.  Now, our main concern is to move from O(N^2) Time Complexity to something more optimal, or in simple words, we have to get rid of two nested loops. Let us see Step by Step on what can be done.\\n\\n* First, let us store the number of vowels in the first substring of length k, that is, substring starting from 0th index and till (k-1)th index and store it in a variable named ***count*** \\n\\n*  After this, let us inititalise a variable named ***max_vowel_count*** to count, which will keep the value of maximum number of vowels in a substring of length k.\\n\\n*   Now, we will slide by 1 unit, that is, we will iterate from kth index till the last. (Slide by 1 unit because earlier, we traversed from 0th index till (n-1)th index \\n\\n* Now, we can simply assign and deassign and continue moving by 1 unit each.  \\n\\nNote : It is taking time for me to entirely absorb this approach but slowly and steadily, I will try to explain this approach in even simpler words. ***Dry running the given code will be helpful***\\n\\n\\n***Complexity Analysis*** : \\n\\n***Time Complexity - O(N)\\nSpace Complexity - O(1)***\\n\\n\\n\\n**Here is the code for Optimal Approach** : \\n\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n \\n        n = len(s)\\n        \\n        vowels = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' }\\n        count = 0 \\n        # Step 1 : We will find number of vowels in the first substring of length k : from 0th index till (k-1)th index\\n        for i in range(0, k):\\n            if s[i] in vowels:\\n                count += 1\\n        \\n        \\n        # record for maximum vowel count in substring\\n        max_vowel_count = count\\n        \\n        \\n        # sliding window of size k\\n        # starts from k and window from [0, k-1] inclusive is already considered\\n        for tail_index in range(k, n):\\n            \\n            head_index = tail_index - k\\n            head_char, tail_char = s[head_index], s[tail_index]\\n            \\n            if head_char in vowels:\\n                count -= 1\\n                \\n            if tail_char in vowels:\\n                count += 1\\n                \\n            max_vowel_count = max(max_vowel_count, count)\\n            \\n        \\n        return max_vowel_count\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        \\n        n = len(s)\\n       \\n        #STEP 1\\n        arr = []\\n        for i in range(0, n):\\n                arr.append(s[i : i + k])\\n        \\n        vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\\n        arr1 = []\\n        \\n\\t\\t#STEP 2\\n        for i in arr:\\n            count = 0 \\n            if len(i) == k:\\n                for j in i:\\n                    if j in vowels:\\n                        count += 1 \\n                arr1.append(count)\\n        \\n\\t\\t#STEP 3\\n        if len(arr1) != 0:\\n            value = max(arr1)\\n            return value\\n        else:\\n            return 0\\n```\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n \\n        n = len(s)\\n        \\n        vowels = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' }\\n        count = 0 \\n        # Step 1 : We will find number of vowels in the first substring of length k : from 0th index till (k-1)th index\\n        for i in range(0, k):\\n            if s[i] in vowels:\\n                count += 1\\n        \\n        \\n        # record for maximum vowel count in substring\\n        max_vowel_count = count\\n        \\n        \\n        # sliding window of size k\\n        # starts from k and window from [0, k-1] inclusive is already considered\\n        for tail_index in range(k, n):\\n            \\n            head_index = tail_index - k\\n            head_char, tail_char = s[head_index], s[tail_index]\\n            \\n            if head_char in vowels:\\n                count -= 1\\n                \\n            if tail_char in vowels:\\n                count += 1\\n                \\n            max_vowel_count = max(max_vowel_count, count)\\n            \\n        \\n        return max_vowel_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187285,
                "title": "c-solution-sliding-window-aditya-verma-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        return (c==\\'a\\' || c==\\'e\\' || c==\\'i\\' ||c==\\'o\\' ||c==\\'u\\');\\n    }\\n    int maxVowels(string s, int k) {\\n        int i=0,j=0;\\n        int numVowels =0;\\n        int maxm=0;\\n        while(j<s.size()){\\n            // increase the count of vowels, if the character pointing at j is a vowel\\n            if(isVowel(s[j]))\\n                numVowels++;\\n            // increase the window size\\n            if(j-i+1<k)\\n                j++;\\n            // if the window size hits, check if the current number of vowels is maximum\\n            else if(j-i+1 == k){\\n                maxm=max(maxm,numVowels);\\n                if(isVowel(s[i]))\\n                    numVowels--;// remove the calculation for the character pointing at i, if it is a vowel\\n                i++;\\n                j++;\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        return (c==\\'a\\' || c==\\'e\\' || c==\\'i\\' ||c==\\'o\\' ||c==\\'u\\');\\n    }\\n    int maxVowels(string s, int k) {\\n        int i=0,j=0;\\n        int numVowels =0;\\n        int maxm=0;\\n        while(j<s.size()){\\n            // increase the count of vowels, if the character pointing at j is a vowel\\n            if(isVowel(s[j]))\\n                numVowels++;\\n            // increase the window size\\n            if(j-i+1<k)\\n                j++;\\n            // if the window size hits, check if the current number of vowels is maximum\\n            else if(j-i+1 == k){\\n                maxm=max(maxm,numVowels);\\n                if(isVowel(s[i]))\\n                    numVowels--;// remove the calculation for the character pointing at i, if it is a vowel\\n                i++;\\n                j++;\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693510,
                "title": "c-sliding-window",
                "content": "class Solution {\\n```\\npublic:\\n    int maxVowels(string s, int k) {\\n        int count = 0;\\n        int j = 0;\\n        int ans = 0, res = 0;\\n        for(int i=0; i< s.size(); i++){\\n            count++;                                // count characters\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                ans++;\\n            }\\n            res = max(res, ans);\\n\\t\\t\\twhile(count>=k && j< s.size()){\\n                count--;\\n                if(s[j]==\\'a\\' || s[j]==\\'e\\' || s[j]==\\'i\\' || s[j]==\\'o\\' || s[j]==\\'u\\'){\\n                    ans--;                                                                 \\n                }\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n```\\npublic:\\n    int maxVowels(string s, int k) {\\n        int count = 0;\\n        int j = 0;\\n        int ans = 0, res = 0;\\n        for(int i=0; i< s.size(); i++){\\n            count++;                                // count characters\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 670258,
                "title": "o-n-solution-in-python3-using-suffix-array",
                "content": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        suffix = []\\n        result = 0\\n        vowels = set(\"aeiou\")\\n        if s[0] in vowels:\\n            suffix.append(1)\\n        else:\\n            suffix.append(0)\\n        length = len(s)\\n        for i in range(1,length):\\n            if s[i] in vowels:\\n                suffix.append(1+suffix[-1])\\n            else:\\n                suffix.append(suffix[-1])\\n        if length==k:\\n            return suffix[-1]\\n        maximum = 0\\n        for i in range(length-k+1):\\n            if i==0:\\n                maximum = max(maximum,suffix[i+(k-1)])\\n            else:\\n                maximum = max(maximum,suffix[i+(k-1)]-suffix[i-1])\\n        return maximum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        suffix = []\\n        result = 0\\n        vowels = set(\"aeiou\")\\n        if s[0] in vowels:\\n            suffix.append(1)\\n        else:\\n            suffix.append(0)\\n        length = len(s)\\n        for i in range(1,length):\\n            if s[i] in vowels:\\n                suffix.append(1+suffix[-1])\\n            else:\\n                suffix.append(suffix[-1])\\n        if length==k:\\n            return suffix[-1]\\n        maximum = 0\\n        for i in range(length-k+1):\\n            if i==0:\\n                maximum = max(maximum,suffix[i+(k-1)])\\n            else:\\n                maximum = max(maximum,suffix[i+(k-1)]-suffix[i-1])\\n        return maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649196,
                "title": "java-sliding-window-o-n-solution-easy-to-understand",
                "content": "```\\nprivate boolean isVowel(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'){\\n                return true;\\n            }\\n        return false;\\n    }\\n    public int maxVowels(String s, int k) {\\n        if(s.length()==0)\\n            return 0;\\n        int res=0;//response to return\\n        char st=s.charAt(0);//starting character in our window of size k\\n        char en=s.charAt(k-1);//ending character in our window\\n        int ans=0;//no. of vowels in current substring\\n        for(int i=0;i<k;i++){\\n            if(isVowel(s.charAt(i))){\\n                ans++;\\n            }\\n        }\\n        res=Math.max(res,ans);//update res if current ans is bigger\\n        for(int i=k;i<s.length();i++){//loop on remaining n-k elements to find a better substring\\n            char ch=s.charAt(i);\\n            if(isVowel(st)){// if starting char of prev window is a vowel, decrease count\\n                ans--;\\n            }\\n            if(isVowel(ch)){// if curr char is vowel, increase count\\n                ans++;\\n            }\\n\\t\\t\\t// update window\\n            st=s.charAt(i-k+1);\\n            en=s.charAt(i);\\n            res=Math.max(res,ans);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nprivate boolean isVowel(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'){\\n                return true;\\n            }\\n        return false;\\n    }\\n    public int maxVowels(String s, int k) {\\n        if(s.length()==0)\\n            return 0;\\n        int res=0;//response to return\\n        char st=s.charAt(0);//starting character in our window of size k\\n        char en=s.charAt(k-1);//ending character in our window\\n        int ans=0;//no. of vowels in current substring\\n        for(int i=0;i<k;i++){\\n            if(isVowel(s.charAt(i))){\\n                ans++;\\n            }\\n        }\\n        res=Math.max(res,ans);//update res if current ans is bigger\\n        for(int i=k;i<s.length();i++){//loop on remaining n-k elements to find a better substring\\n            char ch=s.charAt(i);\\n            if(isVowel(st)){// if starting char of prev window is a vowel, decrease count\\n                ans--;\\n            }\\n            if(isVowel(ch)){// if curr char is vowel, increase count\\n                ans++;\\n            }\\n\\t\\t\\t// update window\\n            st=s.charAt(i-k+1);\\n            en=s.charAt(i);\\n            res=Math.max(res,ans);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 648790,
                "title": "c-concise-code",
                "content": "```\\npublic class Solution\\n{\\n    private HashSet<char> vowels = new HashSet<char>() { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n    public int MaxVowels(string s, int k)\\n    {\\n        int res = 0, len = 0, start = 0, end = 0;\\n        while (end < s.Length)\\n        {\\n            if (vowels.Contains(s[end++]))\\n                len++;\\n            if (end - start > k && vowels.Contains(s[start++]))\\n                len--;\\n            res = Math.Max(res, len);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    private HashSet<char> vowels = new HashSet<char>() { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n    public int MaxVowels(string s, int k)\\n    {\\n        int res = 0, len = 0, start = 0, end = 0;\\n        while (end < s.Length)\\n        {\\n            if (vowels.Contains(s[end++]))\\n                len++;\\n            if (end - start > k && vowels.Contains(s[start++]))\\n                len--;\\n            res = Math.Max(res, len);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648451,
                "title": "python-sliding-window-simple-solution-one-pass",
                "content": "```\\ndef maxVowels(self, s: str, k: int) -> int:\\n\\tvowels = \\'aeiou\\'\\n\\tn = len(s)\\n\\tif n < k: \\n\\t\\treturn -1\\n\\n\\tres = 0\\n\\tfor i in range(k): \\n\\t\\tres += 1 if s[i] in vowels else 0\\n\\n\\tcurr = res \\n\\tfor i in range(k, n): \\n\\t\\tcurr += ((1 if s[i] in vowels else 0) - (1 if s[i-k] in vowels else 0))\\n\\t\\tres = max(res, curr) \\n\\n\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\ndef maxVowels(self, s: str, k: int) -> int:\\n\\tvowels = \\'aeiou\\'\\n\\tn = len(s)\\n\\tif n < k: \\n\\t\\treturn -1\\n\\n\\tres = 0\\n\\tfor i in range(k): \\n\\t\\tres += 1 if s[i] in vowels else 0\\n\\n\\tcurr = res \\n\\tfor i in range(k, n): \\n\\t\\tcurr += ((1 if s[i] in vowels else 0) - (1 if s[i-k] in vowels else 0))\\n\\t\\tres = max(res, curr) \\n\\n\\treturn res",
                "codeTag": "Python3"
            },
            {
                "id": 4031885,
                "title": "maximum-number-of-vowels-in-a-substring-of-given-length-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(char c)\\n    {\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\')return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) \\n    {\\n        int ans=0;\\n        int count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(check(s[i]))count++;\\n        }\\n        ans=count;\\n        int i=0,j=k;\\n        while(j<s.size())\\n        {\\n            if(check(s[j]))count++;\\n            if(check(s[i]))count--;\\n            ans=max(ans,count);\\n            j++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(char c)\\n    {\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\')return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) \\n    {\\n        int ans=0;\\n        int count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(check(s[i]))count++;\\n        }\\n        ans=count;\\n        int i=0,j=k;\\n        while(j<s.size())\\n        {\\n            if(check(s[j]))count++;\\n            if(check(s[i]))count--;\\n            ans=max(ans,count);\\n            j++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774524,
                "title": "easy-to-understand-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int vowel = 0;\\n        for(int i=0;i<k;i++) {\\n            if(isVowel(s.charAt(i))) vowel++;\\n        }\\n        int max = vowel;\\n        for(int i=k;i<s.length();i++) {\\n            if(isVowel(s.charAt(i))) vowel++;\\n            if(isVowel(s.charAt(i-k))) vowel--;\\n            max = Math.max(max,vowel);\\n        }\\n        return max;\\n    }\\n    public boolean isVowel(char ch) {\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int vowel = 0;\\n        for(int i=0;i<k;i++) {\\n            if(isVowel(s.charAt(i))) vowel++;\\n        }\\n        int max = vowel;\\n        for(int i=k;i<s.length();i++) {\\n            if(isVowel(s.charAt(i))) vowel++;\\n            if(isVowel(s.charAt(i-k))) vowel--;\\n            max = Math.max(max,vowel);\\n        }\\n        return max;\\n    }\\n    public boolean isVowel(char ch) {\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755426,
                "title": "python-solution-sliding-window-beats-91-36-in-memory",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n\\n        start = 0\\n        end = 0\\n        n = len(s)\\n        max_num = 0\\n        count=0\\n\\n        while k >= (end-start) and end <n:\\n            if s[end] in vowels:\\n                count+=1\\n                max_num = max(max_num,count)\\n            if k==(end-start+1):\\n                if s[start] in vowels:\\n                    count-=1\\n                start+=1\\n            end+=1\\n        return max_num\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n\\n        start = 0\\n        end = 0\\n        n = len(s)\\n        max_num = 0\\n        count=0\\n\\n        while k >= (end-start) and end <n:\\n            if s[end] in vowels:\\n                count+=1\\n                max_num = max(max_num,count)\\n            if k==(end-start+1):\\n                if s[start] in vowels:\\n                    count-=1\\n                start+=1\\n            end+=1\\n        return max_num\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728518,
                "title": "efficient-solution-using-sliding-window",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nWe are given a string s and an integer k. We need to find the maximum number of vowels in any substring of length k in the given string. We will use the sliding window technique to solve this problem. The sliding window is like a moving frame of fixed length (k) that slides through the string.\\n# Approach\\n1. Initialize a string vowel containing all the vowel characters.\\n1. Convert the input string s to a character array for easy access to individual characters.\\n1. Initialize variables max and count to keep track of the maximum count and current count of vowels, respectively.\\n1. Count the number of vowels in the first k characters of the string.\\n1. If k is greater than or equal to the length of the string, return the current count since the whole string is considered a substring.\\n1. Initialize two pointers, start and end, to represent the start and end indices of the sliding window.\\n1. Slide the window by incrementing start and end one step at a time.\\n1. Decrement the count if the character at the start of the window is a vowel and increment the count if the character at the end of the window is a vowel.\\n1. Update the maximum count whenever a new maximum is found.\\n1. Repeat steps 7-9 until the end of the string is reached.\\n1. Return the maximum count as the result.\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is $$O(n)$$, where n is the length of the input string. We slide the window through the string once, and the operations inside the loop take constant time.\\n\\n- Space complexity:\\nThe space complexity of your solution is $$O(n)$$, where n is the length of the input string s. This is because you are converting the string to a char array, which requires additional space to store the characters\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        // Define the string of vowels\\n        String vowel = \"aeiouAEIOU\";\\n\\n        // Convert the input string to a character array\\n        char[] word = s.toCharArray();\\n\\n        // Initialize variables to track maximum count and current count of vowels\\n        int max = 0;\\n        int count = 0;\\n\\n        // Count the vowels in the first k characters\\n        for (int i = 0; i < k; i++) {\\n            if (vowel.indexOf(word[i]) != -1) {\\n                count++;\\n            }\\n        }\\n\\n        // If k is greater than or equal to the length of the string, return the current count\\n        if (k >= word.length) {\\n            return count;\\n        }\\n\\n        // Initialize pointers for sliding window\\n        int start = 0;\\n        int end = k;\\n\\n        // Update the maximum count with the initial count\\n        max = Math.max(max, count);\\n\\n        // Slide the window and update the count of vowels\\n        while (end < word.length) {\\n            // Decrement count if the character at the start of the window is a vowel\\n            if (vowel.indexOf(word[start++]) != -1) {\\n                count--;\\n            }\\n\\n            // Increment count if the character at the end of the window is a vowel\\n            if (vowel.indexOf(word[end++]) != -1) {\\n                count++;\\n            }\\n\\n            // Update the maximum count\\n            max = Math.max(max, count);\\n        }\\n\\n        // Return the maximum count of vowels\\n        return max;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def maxVowels(self, s, k):\\n        # Define the vowels\\n        vowel = \"aeiouAEIOU\"\\n\\n        # Convert the input string to a list of characters\\n        word = list(s)\\n\\n        # Initialize variables\\n        max_count = 0\\n        count = 0\\n\\n        # Iterate over the first k characters\\n        for i in range(k):\\n            # Check if the character is a vowel\\n            if word[i] in vowel:\\n                count += 1\\n\\n        # If k is greater than or equal to the length of the string, return the current count\\n        if k >= len(word):\\n            return count\\n\\n        # Set the start and end indices for the sliding window\\n        start = 0\\n        end = k\\n\\n        # Update the maximum count\\n        max_count = max(max_count, count)\\n\\n        # Slide the window through the remaining characters\\n        while end < len(word):\\n            # Check if the character at the start index is a vowel and decrement the count if necessary\\n            if word[start] in vowel:\\n                count -= 1\\n\\n            # Check if the character at the end index is a vowel and increment the count if necessary\\n            if word[end] in vowel:\\n                count += 1\\n\\n            # Update the maximum count\\n            max_count = max(max_count, count)\\n\\n            # Move the window by incrementing the start and end indices\\n            start += 1\\n            end += 1\\n\\n        # Return the maximum count\\n        return max_count\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        // Define the vowels\\n        string vowel = \"aeiouAEIOU\";\\n\\n        // Convert the input string to a character array\\n        const char* word = s.c_str();\\n\\n        // Initialize variables\\n        int max_count = 0;\\n        int count = 0;\\n\\n        // Iterate over the first k characters\\n        for (int i = 0; i < k; i++) {\\n            // Check if the character is a vowel\\n            if (vowel.find(word[i]) != string::npos) {\\n                count++;\\n            }\\n        }\\n\\n        // If k is greater than or equal to the length of the string, return the current count\\n        if (k >= s.length()) {\\n            return count;\\n        }\\n\\n        // Set the start and end indices for the sliding window\\n        int start = 0;\\n        int end = k;\\n\\n        // Update the maximum count\\n        max_count = max(max_count, count);\\n\\n        // Slide the window through the remaining characters\\n        while (end < s.length()) {\\n            // Check if the character at the start index is a vowel and decrement the count if necessary\\n            if (vowel.find(word[start]) != string::npos) {\\n                count--;\\n            }\\n\\n            // Check if the character at the end index is a vowel and increment the count if necessary\\n            if (vowel.find(word[end]) != string::npos) {\\n                count++;\\n            }\\n\\n            // Update the maximum count\\n            max_count = max(max_count, count);\\n\\n            // Move the window by incrementing the start and end indices\\n            start++;\\n            end++;\\n        }\\n\\n        // Return the maximum count\\n        return max_count;\\n    }\\n};\\n\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/e1bd93a0-9cc1-4654-8db2-43bf4fef8ea5_1688664287.6243436.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String",
                    "Sliding Window"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        // Define the string of vowels\\n        String vowel = \"aeiouAEIOU\";\\n\\n        // Convert the input string to a character array\\n        char[] word = s.toCharArray();\\n\\n        // Initialize variables to track maximum count and current count of vowels\\n        int max = 0;\\n        int count = 0;\\n\\n        // Count the vowels in the first k characters\\n        for (int i = 0; i < k; i++) {\\n            if (vowel.indexOf(word[i]) != -1) {\\n                count++;\\n            }\\n        }\\n\\n        // If k is greater than or equal to the length of the string, return the current count\\n        if (k >= word.length) {\\n            return count;\\n        }\\n\\n        // Initialize pointers for sliding window\\n        int start = 0;\\n        int end = k;\\n\\n        // Update the maximum count with the initial count\\n        max = Math.max(max, count);\\n\\n        // Slide the window and update the count of vowels\\n        while (end < word.length) {\\n            // Decrement count if the character at the start of the window is a vowel\\n            if (vowel.indexOf(word[start++]) != -1) {\\n                count--;\\n            }\\n\\n            // Increment count if the character at the end of the window is a vowel\\n            if (vowel.indexOf(word[end++]) != -1) {\\n                count++;\\n            }\\n\\n            // Update the maximum count\\n            max = Math.max(max, count);\\n        }\\n\\n        // Return the maximum count of vowels\\n        return max;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def maxVowels(self, s, k):\\n        # Define the vowels\\n        vowel = \"aeiouAEIOU\"\\n\\n        # Convert the input string to a list of characters\\n        word = list(s)\\n\\n        # Initialize variables\\n        max_count = 0\\n        count = 0\\n\\n        # Iterate over the first k characters\\n        for i in range(k):\\n            # Check if the character is a vowel\\n            if word[i] in vowel:\\n                count += 1\\n\\n        # If k is greater than or equal to the length of the string, return the current count\\n        if k >= len(word):\\n            return count\\n\\n        # Set the start and end indices for the sliding window\\n        start = 0\\n        end = k\\n\\n        # Update the maximum count\\n        max_count = max(max_count, count)\\n\\n        # Slide the window through the remaining characters\\n        while end < len(word):\\n            # Check if the character at the start index is a vowel and decrement the count if necessary\\n            if word[start] in vowel:\\n                count -= 1\\n\\n            # Check if the character at the end index is a vowel and increment the count if necessary\\n            if word[end] in vowel:\\n                count += 1\\n\\n            # Update the maximum count\\n            max_count = max(max_count, count)\\n\\n            # Move the window by incrementing the start and end indices\\n            start += 1\\n            end += 1\\n\\n        # Return the maximum count\\n        return max_count\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        // Define the vowels\\n        string vowel = \"aeiouAEIOU\";\\n\\n        // Convert the input string to a character array\\n        const char* word = s.c_str();\\n\\n        // Initialize variables\\n        int max_count = 0;\\n        int count = 0;\\n\\n        // Iterate over the first k characters\\n        for (int i = 0; i < k; i++) {\\n            // Check if the character is a vowel\\n            if (vowel.find(word[i]) != string::npos) {\\n                count++;\\n            }\\n        }\\n\\n        // If k is greater than or equal to the length of the string, return the current count\\n        if (k >= s.length()) {\\n            return count;\\n        }\\n\\n        // Set the start and end indices for the sliding window\\n        int start = 0;\\n        int end = k;\\n\\n        // Update the maximum count\\n        max_count = max(max_count, count);\\n\\n        // Slide the window through the remaining characters\\n        while (end < s.length()) {\\n            // Check if the character at the start index is a vowel and decrement the count if necessary\\n            if (vowel.find(word[start]) != string::npos) {\\n                count--;\\n            }\\n\\n            // Check if the character at the end index is a vowel and increment the count if necessary\\n            if (vowel.find(word[end]) != string::npos) {\\n                count++;\\n            }\\n\\n            // Update the maximum count\\n            max_count = max(max_count, count);\\n\\n            // Move the window by incrementing the start and end indices\\n            start++;\\n            end++;\\n        }\\n\\n        // Return the maximum count\\n        return max_count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685518,
                "title": "go-solution-great-explanation-and-full-description",
                "content": "# Intuition\\nThe problem asks for the maximum number of vowels that can be found in a substring of the given string `s` of length `k`. This can be solved by using a sliding window approach where we slide a window of length `k` through the string and keep track of the number of vowels in the window.\\n\\n# Approach\\nWe initialize two pointers `l` and `r` to `0`, a variable `sumVow` to keep track of the number of vowels in the current window, and a variable `result` to store the maximum number of vowels found so far.\\n\\nWe then start a loop where we move the right pointer `r` through the string. If the current character is a vowel and `sumVow` is less than `k`, we increment `sumVow`.\\n\\nOnce the window size exceeds `k`, we move the left pointer `l` to the right. If the character at `l` is a vowel, we decrement `sumVow`.\\n\\nAfter each iteration, we update `result` to be the maximum of `result` and `sumVow`.\\n\\nFinally, we return `result`, which is the maximum number of vowels that can be found in a substring of length `k`.\\n\\n# Complexity\\n- Time complexity: The time complexity for this algorithm is O(n), where `n` is the length of `s`. This is because we perform a single pass over the `s`.\\n\\n- Space complexity: The space complexity is O(1), as we use a constant amount of space to store the pointers, `sumVow`, and `result`.\\n\\n# Code\\n```\\n\\nfunc maxVowels(s string, k int) int {\\n\\tvar r, l, sumVow, result int\\n\\tfor ; r < len(s); r++ {\\n\\t\\tif isVowel(s[r]) && sumVow < k {\\n\\t\\t\\tsumVow++\\n\\t\\t}\\n\\t\\tfor r-l >= k {\\n\\t\\t\\tif isVowel(s[l]) {\\n\\t\\t\\t\\tsumVow--\\n\\t\\t\\t}\\n\\t\\t\\tl++\\n\\t\\t}\\n\\t\\tresult = max(result, sumVow)\\n\\t}\\n\\treturn result\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc isVowel(ch byte) bool {\\n\\tswitch ch {\\n\\tcase \\'a\\':\\n\\t\\treturn true\\n\\tcase \\'e\\':\\n\\t\\treturn true\\n\\tcase \\'i\\':\\n\\t\\treturn true\\n\\tcase \\'o\\':\\n\\t\\treturn true\\n\\tcase \\'u\\':\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\n\\nfunc maxVowels(s string, k int) int {\\n\\tvar r, l, sumVow, result int\\n\\tfor ; r < len(s); r++ {\\n\\t\\tif isVowel(s[r]) && sumVow < k {\\n\\t\\t\\tsumVow++\\n\\t\\t}\\n\\t\\tfor r-l >= k {\\n\\t\\t\\tif isVowel(s[l]) {\\n\\t\\t\\t\\tsumVow--\\n\\t\\t\\t}\\n\\t\\t\\tl++\\n\\t\\t}\\n\\t\\tresult = max(result, sumVow)\\n\\t}\\n\\treturn result\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc isVowel(ch byte) bool {\\n\\tswitch ch {\\n\\tcase \\'a\\':\\n\\t\\treturn true\\n\\tcase \\'e\\':\\n\\t\\treturn true\\n\\tcase \\'i\\':\\n\\t\\treturn true\\n\\tcase \\'o\\':\\n\\t\\treturn true\\n\\tcase \\'u\\':\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3610614,
                "title": "easy-implementation-of-sliding-window-algorithm",
                "content": "# Approach\\nCalculate the vowelCount in the first window - substring(0, k)\\nOn each iteration - decrement vowelCount if left window char is vowel and incremenet vowelCount if rightWindow char is vowel\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\nConstant space complexity - hashset with size 5 to store all the vowels and two variables for storing max vowelCount value and current vowelCount value. Constant space complexity can be considered as - $$O(1)$$\\n# Code\\n```\\nclass Solution {\\n\\n    private val vowels = hashSetOf(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n\\n        fun maxVowels(string: String, count: Int): Int {\\n        var max = string.substring(0, count).count { vowels.contains(it) }\\n        var current = max\\n        for (i in 1 .. string.lastIndex.minus(count - 1)) {\\n            if (string[i - 1] in vowels) {\\n                current--\\n            }\\n            if (string[i + count - 1] in vowels) {\\n                current++\\n            }\\n            if (current > max) {\\n                max = current\\n            }\\n        }\\n        return max\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\n    private val vowels = hashSetOf(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n\\n        fun maxVowels(string: String, count: Int): Int {\\n        var max = string.substring(0, count).count { vowels.contains(it) }\\n        var current = max\\n        for (i in 1 .. string.lastIndex.minus(count - 1)) {\\n            if (string[i - 1] in vowels) {\\n                current--\\n            }\\n            if (string[i + count - 1] in vowels) {\\n                current++\\n            }\\n            if (current > max) {\\n                max = current\\n            }\\n        }\\n        return max\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561182,
                "title": "99-87-beats-java-sliding-window",
                "content": "# Approach\\nSliding Window\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n   \\n     public int maxVowels(String s, int k) {\\n        \\n        byte vowel[]=new byte[\\'z\\'+1];\\n        vowel[\\'a\\']=1;\\n        vowel[\\'e\\']=1;\\n        vowel[\\'i\\']=1;\\n        vowel[\\'o\\']=1;\\n        vowel[\\'u\\']=1;\\n\\n\\n        char c[]=s.toCharArray();\\n        int count=0;\\n        int l=s.length();\\n        for(int i=0;i<k;i++)\\n        {\\n            \\n            count+=vowel[c[i]];\\n        }\\n        int res=count;\\n        for(int i=k;i<l;i++)\\n        {\\n            int p=vowel[c[i-k]];\\n            int q=vowel[c[i]];\\n            count+=q-p;\\n    \\n            if(res<count)\\n            {\\n                res=count;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n   \\n     public int maxVowels(String s, int k) {\\n        \\n        byte vowel[]=new byte[\\'z\\'+1];\\n        vowel[\\'a\\']=1;\\n        vowel[\\'e\\']=1;\\n        vowel[\\'i\\']=1;\\n        vowel[\\'o\\']=1;\\n        vowel[\\'u\\']=1;\\n\\n\\n        char c[]=s.toCharArray();\\n        int count=0;\\n        int l=s.length();\\n        for(int i=0;i<k;i++)\\n        {\\n            \\n            count+=vowel[c[i]];\\n        }\\n        int res=count;\\n        for(int i=k;i<l;i++)\\n        {\\n            int p=vowel[c[i-k]];\\n            int q=vowel[c[i]];\\n            count+=q-p;\\n    \\n            if(res<count)\\n            {\\n                res=count;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524811,
                "title": "1456-maximum-number-of-vowels-in-a-substring-of-given-length",
                "content": "class Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int ans = 0, cnt = 0, n = s.size(), i = 0;\\n        unordered_set<char> v = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n\\n        for(int j=0; j<n; j++) {\\n            if(v.find(s[j]) != v.end()) cnt++;\\n            if(j - i + 1 == k) {\\n                ans = max(ans, cnt);\\n                if(v.find(s[i]) != v.end()) cnt--;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int ans = 0, cnt = 0, n = s.size(), i = 0;\\n        unordered_set<char> v = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}",
                "codeTag": "Java"
            },
            {
                "id": 3494953,
                "title": "c-easy-explanation-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nTo solve this We use curr variable which determines the window of Size K\\n\\nCheck each upcoming character whether it is a vowel or not and update the curr count accordingly\\n\\nIf the window size == k+1 then increment the i pointer , if character at start pointer is a vowel then decrease the curr count\\n\\nFinally store max ans in each window of size k\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int vowels[26] = {1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1};\\n    int maxVowels(string s, int k) {\\n        int n=s.size();\\n        int maxi=0;\\n\\n       for(int i=0, curr=0;i<n;i++)\\n       {\\n           curr+=vowels[s[i]-\\'a\\'];\\n           if(i>=k)\\n            curr-=vowels[s[i-k]-\\'a\\'];\\n\\n            maxi=max(maxi,curr);\\n       }\\n       return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int vowels[26] = {1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1};\\n    int maxVowels(string s, int k) {\\n        int n=s.size();\\n        int maxi=0;\\n\\n       for(int i=0, curr=0;i<n;i++)\\n       {\\n           curr+=vowels[s[i]-\\'a\\'];\\n           if(i>=k)\\n            curr-=vowels[s[i-k]-\\'a\\'];\\n\\n            maxi=max(maxi,curr);\\n       }\\n       return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493619,
                "title": "was-beating-100-java-solutions-4-ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolution must be simple and straightforward to avoid any inefficiency.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nchar -> isVowel mapping using simple array.\\nboolean type [from previous solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3493014/was-beating-100-java-6ms-runtime) replaced by byte to reduce branching operations.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic int maxVowels(String s, int k) {\\n\\tbyte[] isVowel = new byte[\\'z\\' + 1];\\n\\t\\tisVowel[\\'a\\'] = 1;\\n\\t\\tisVowel[\\'e\\'] = 1;\\n\\t\\tisVowel[\\'i\\'] = 1;\\n\\t\\tisVowel[\\'o\\'] = 1;\\n\\t\\tisVowel[\\'u\\'] = 1;\\n\\n\\tchar[] chars = s.toCharArray();\\n\\tint r = 0, max = 0;\\n\\twhile (r < k)\\n\\t\\tmax += isVowel[chars[r++]];\\n\\n\\tint l = 0, n = max;\\n\\twhile (r < chars.length) {\\n\\t\\tn += isVowel[chars[r++]] - isVowel[chars[l++]];\\n\\t\\tif (n > max)\\n\\t\\t\\tmax = n;\\n\\t}\\n\\treturn max;\\n}\\n\\n}\\n```\\n[Submission Detail](https://leetcode.com/submissions/detail/945880006)\\n\\nP.S. Upgraded to the [3-ms solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3518754/beats-100-java-solutions-simple-3-ms-runtime).",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\npublic int maxVowels(String s, int k) {\\n\\tbyte[] isVowel = new byte[\\'z\\' + 1];\\n\\t\\tisVowel[\\'a\\'] = 1;\\n\\t\\tisVowel[\\'e\\'] = 1;\\n\\t\\tisVowel[\\'i\\'] = 1;\\n\\t\\tisVowel[\\'o\\'] = 1;\\n\\t\\tisVowel[\\'u\\'] = 1;\\n\\n\\tchar[] chars = s.toCharArray();\\n\\tint r = 0, max = 0;\\n\\twhile (r < k)\\n\\t\\tmax += isVowel[chars[r++]];\\n\\n\\tint l = 0, n = max;\\n\\twhile (r < chars.length) {\\n\\t\\tn += isVowel[chars[r++]] - isVowel[chars[l++]];\\n\\t\\tif (n > max)\\n\\t\\t\\tmax = n;\\n\\t}\\n\\treturn max;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490829,
                "title": "solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n___\\n    Sliding window:\\n    -\\n    \\uD83C\\uDF88For a window of length k, we are keeping track of count of vowels in local variable.\\n    \\uD83C\\uDF88For each window, we are calculating the max value of vowel count, and returning the answer at end.\\n___\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        unordered_set<char> vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        int end = 0;\\n        int v = 0;\\n        while(end < k) {\\n            if(vowel.count(s[end]) > 0) ++v;\\n            ++end;\\n        }\\n        \\n        int res = v;\\n        // sliding widnow invariant: [end -k, k) is the window and it has v vowels\\n        while(end < s.size()) {\\n            if(vowel.count(s[end - k]) > 0) --v;\\n            if(vowel.count(s[end]) > 0) {\\n                ++v;\\n                res = max(res, v);\\n            }\\n            ++end;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        unordered_set<char> vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        int end = 0;\\n        int v = 0;\\n        while(end < k) {\\n            if(vowel.count(s[end]) > 0) ++v;\\n            ++end;\\n        }\\n        \\n        int res = v;\\n        // sliding widnow invariant: [end -k, k) is the window and it has v vowels\\n        while(end < s.size()) {\\n            if(vowel.count(s[end - k]) > 0) --v;\\n            if(vowel.count(s[end]) > 0) {\\n                ++v;\\n                res = max(res, v);\\n            }\\n            ++end;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490735,
                "title": "easy-solution-sliding-window-approach-c-o-n",
                "content": "# Intuition\\nSince, we are given with a fixed value of k so we can use sliding window here. What sliding window actually is?\\nWe take 2 pointer whose difference should be equal to K. when that is the case then we cal the maximum and increment the previous pointer. \\n\\n# Approach\\nHere I have taken 2 pointer i and j. Both are initailized to 0.\\nAfter, that I ran a for loop for(j->n) (which is the size of the string). \\n\\nEach time when the char is equal to a vowel then I increment the value of count by one.\\n\\nNow when the difference of j-i+1 becames equal to k, at that moment I cal the maximum of the two counters which I have used \\nmaxi = max(maxi, count); \\nI also need to increase the value of i to check for entire array. Along with that count-- if i was at a vowel.two\\n\\n# Complexity\\n- Time complexity:\\nThis Algorithm has Time Complexity if O(N).\\n\\n- Space complexity:\\nConstant Space Complexity O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool vowel(char a){\\n        if(a == \\'a\\' || a == \\'e\\' || a == \\'i\\' || a == \\'o\\' || a == \\'u\\')\\n        return 1;\\n        else return 0;\\n    }\\n    int maxVowels(string s, int k) {\\n        int maxi = 0;\\n        int count = 0;\\n        int i = 0;\\n        int n = s.size();\\n        for(int j = 0; j<n; j++){\\n            if(vowel(s[j])) count++;\\n            if(j-i+1 == k){\\n                maxi = max(maxi, count);\\n                if(vowel(s[i])) count--;\\n                i++;\\n            } \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool vowel(char a){\\n        if(a == \\'a\\' || a == \\'e\\' || a == \\'i\\' || a == \\'o\\' || a == \\'u\\')\\n        return 1;\\n        else return 0;\\n    }\\n    int maxVowels(string s, int k) {\\n        int maxi = 0;\\n        int count = 0;\\n        int i = 0;\\n        int n = s.size();\\n        for(int j = 0; j<n; j++){\\n            if(vowel(s[j])) count++;\\n            if(j-i+1 == k){\\n                maxi = max(maxi, count);\\n                if(vowel(s[i])) count--;\\n                i++;\\n            } \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490306,
                "title": "very-easy-to-understand-beginner-friendly-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGeneric sliding Window problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst created a window of size and k and moved the window until it reaches the end of the string. Check the next character if it is a vowel, if it is a vowel increment the counter of the vowels and now to maintain the size of the window, remove one element from the last. \\nCheck if it is a vowel, if it is then decrement the counter.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(char ch){\\n        vector<char> vow = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        for(int j = 0; j< vow.size(); j++){\\n            if(ch == vow[j]) return true;\\n        }\\n        return false;\\n    }\\n    int maxVowels(string s, int k) {\\n    \\n        int cnt = 0;\\n        for(int i = 0; i< k; i++){\\n            if(check(s[i])) cnt++;\\n        }\\n        int ans = cnt;\\n        int j = k, i = 0;\\n        while(j < s.length()){\\n            if(check(s[j])){\\n                cnt++;\\n            }\\n            if(check(s[i])){\\n                cnt--;\\n            }\\n            ans = max(cnt, ans);\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(char ch){\\n        vector<char> vow = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        for(int j = 0; j< vow.size(); j++){\\n            if(ch == vow[j]) return true;\\n        }\\n        return false;\\n    }\\n    int maxVowels(string s, int k) {\\n    \\n        int cnt = 0;\\n        for(int i = 0; i< k; i++){\\n            if(check(s[i])) cnt++;\\n        }\\n        int ans = cnt;\\n        int j = k, i = 0;\\n        while(j < s.length()){\\n            if(check(s[j])){\\n                cnt++;\\n            }\\n            if(check(s[i])){\\n                cnt--;\\n            }\\n            ans = max(cnt, ans);\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490296,
                "title": "fast-readable-c-solution-and-a-faster-bitmask-solution",
                "content": "# Intuition\\nThe intuition to solving this problem is to use a sliding window of size k. Count the number of vowels in the initial window, then subtract and vowels that fall outside of the window each iteration and add any new vowels that come into the window.\\n\\n# Approach\\nThere are two ways I solved this problem. One is more simple to think about and one is faster. The more simple to think about version is to create a hash set that contains all vowel letters. Each iteration check if `s[i]` is in the hash set, if it is add it to the running total. On each iteration after the first `k` iterations check `s[i-k]` to see if it is in the set. If it is in the set subtract `1` from the running total.\\nThe improved version to this is the same approach, but to use a bitmask to check if the current `char` is a vowel instead of looking it up in the hash set. This improves runtime marginally (it has the same time complexity) since computers are much better at performing bitwise operations.\\n\\n# Complexity\\n- Time complexity:\\n*O(n)*\\n\\n- Space complexity:\\n*O(1)*\\n\\n# Code\\n## Hashset solution\\n```cpp\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        unordered_set<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        int max_total = 0;\\n        int running_total = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            running_total += vowels.find(s[i]) != vowels.end() ? 1 : 0;\\n            if (i - k >= 0) {\\n                running_total -= vowels.find(s[i - k]) != vowels.end() ? 1 : 0;\\n            }\\n            max_total = max(max_total, running_total);\\n        }\\n        return max_total;\\n    }\\n};\\n```\\n\\n## Bitwise solution\\n```cpp\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        auto is_vowel = [](char c) {\\n            static const uint32_t b1 = 0x208222;\\n            static const uint8_t b2 = 0x1f;\\n            static const uint8_t b3 = 0x1;\\n            return (b1 >> (c & b2)) & b3; \\n        };\\n        int running_total = 0;\\n        int max_total = 0;\\n        for(int i = 0, j = i - k; i < s.size(); ++i, ++j){\\n            running_total += is_vowel(s[i]);\\n            if (i >= k) {\\n                running_total -= is_vowel(s[j]);\\n            }\\n            max_total = max(max_total, running_total); \\n        }\\n\\n        return max_total;\\n    };\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        unordered_set<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        int max_total = 0;\\n        int running_total = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            running_total += vowels.find(s[i]) != vowels.end() ? 1 : 0;\\n            if (i - k >= 0) {\\n                running_total -= vowels.find(s[i - k]) != vowels.end() ? 1 : 0;\\n            }\\n            max_total = max(max_total, running_total);\\n        }\\n        return max_total;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        auto is_vowel = [](char c) {\\n            static const uint32_t b1 = 0x208222;\\n            static const uint8_t b2 = 0x1f;\\n            static const uint8_t b3 = 0x1;\\n            return (b1 >> (c & b2)) & b3; \\n        };\\n        int running_total = 0;\\n        int max_total = 0;\\n        for(int i = 0, j = i - k; i < s.size(); ++i, ++j){\\n            running_total += is_vowel(s[i]);\\n            if (i >= k) {\\n                running_total -= is_vowel(s[j]);\\n            }\\n            max_total = max(max_total, running_total); \\n        }\\n\\n        return max_total;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490142,
                "title": "maximum-number-of-vowel-in-a-substring-of-given-length-using-window-sliding-in-tc-o-n-sc-o-1",
                "content": "# Intuition\\nTaking Length k and by sliding window updating max count of vowel in that length of substring.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\nSliding Window\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//fuction checks if that char present in substring is vowel or not.\\n    int isvowel(char a)\\n        {\\n           return (a==\\'a\\' || a==\\'e\\' || a==\\'i\\' || a==\\'o\\' || a==\\'u\\')?1:0;\\n        }\\n    int maxVowels(string s, int k) {\\n        //sliding window \\n        int left=0,right=0,result=0,window=0;\\n        //checking in lenght of k substring\\n        for(;right<k;right++)\\n        {\\n            window+=isvowel(s[right]);\\n        }\\n\\n        result=window;\\n\\n        //checking untill we reached last of the substring of given length\\n        while(right<s.length())\\n        {\\n            //in loop we need to increment left and right pointer.\\n            //removing left s[0] and adding s[0] from right to check next substring formed.\\n            window-=isvowel(s[left++]);\\n            window+=isvowel(s[right++]);\\n            //storing maximum count of vowel in our result till we get.\\n            result=max(result,window);\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//fuction checks if that char present in substring is vowel or not.\\n    int isvowel(char a)\\n        {\\n           return (a==\\'a\\' || a==\\'e\\' || a==\\'i\\' || a==\\'o\\' || a==\\'u\\')?1:0;\\n        }\\n    int maxVowels(string s, int k) {\\n        //sliding window \\n        int left=0,right=0,result=0,window=0;\\n        //checking in lenght of k substring\\n        for(;right<k;right++)\\n        {\\n            window+=isvowel(s[right]);\\n        }\\n\\n        result=window;\\n\\n        //checking untill we reached last of the substring of given length\\n        while(right<s.length())\\n        {\\n            //in loop we need to increment left and right pointer.\\n            //removing left s[0] and adding s[0] from right to check next substring formed.\\n            window-=isvowel(s[left++]);\\n            window+=isvowel(s[right++]);\\n            //storing maximum count of vowel in our result till we get.\\n            result=max(result,window);\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489843,
                "title": "c-beginner-friendly-o-n-easy-to-understand-check-the-previous-and-the-next-element",
                "content": "\\n# Approach\\n- Create a sub string of length K from the 0th index and count the number of vowels in it.\\n- After that just check traverse the whole string and add elements one by one while checking if they are vowels.\\n- Delete the count of the previous element if it was a vowel by using a pointer.\\n- Return the max count.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n\\n\\n        int count=0;\\n\\n        string s1=s.substr(0,k);\\n        for(char x:s1){\\n            if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\'|| x==\\'o\\'|| x==\\'u\\'){\\n                count++;       \\n            }\\n        }\\n        if(count==k){\\n            return k;\\n        }\\n\\n        int maxcount=count;\\n        int j=0;\\n\\n        for(int i=k;i<s.size();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\'|| s[i]==\\'o\\'|| s[i]==\\'u\\'){\\n                count++;       \\n            }\\n            if(s[j]==\\'a\\' || s[j]==\\'e\\' || s[j]==\\'i\\'|| s[j]==\\'o\\'|| s[j]==\\'u\\'){\\n                count--;       \\n            }\\n            j++;\\n            maxcount=max(maxcount,count);\\n            if(maxcount==k){\\n                return maxcount;\\n            }\\n        }\\n\\n        return maxcount;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n\\n\\n        int count=0;\\n\\n        string s1=s.substr(0,k);\\n        for(char x:s1){\\n            if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\'|| x==\\'o\\'|| x==\\'u\\'){\\n                count++;       \\n            }\\n        }\\n        if(count==k){\\n            return k;\\n        }\\n\\n        int maxcount=count;\\n        int j=0;\\n\\n        for(int i=k;i<s.size();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\'|| s[i]==\\'o\\'|| s[i]==\\'u\\'){\\n                count++;       \\n            }\\n            if(s[j]==\\'a\\' || s[j]==\\'e\\' || s[j]==\\'i\\'|| s[j]==\\'o\\'|| s[j]==\\'u\\'){\\n                count--;       \\n            }\\n            j++;\\n            maxcount=max(maxcount,count);\\n            if(maxcount==k){\\n                return maxcount;\\n            }\\n        }\\n\\n        return maxcount;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489796,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        unordered_set<char> vowels{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        int cnt = 0;\\n        for (int i = 0; i < k; i++) cnt += vowels.count(s[i]);\\n        int ans = cnt;\\n        for (int i = k; i < s.length(); i++) {\\n            cnt += vowels.count(s[i]) - vowels.count(s[i - k]);\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        unordered_set<char> vowels{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        int cnt = 0;\\n        for (int i = 0; i < k; i++) cnt += vowels.count(s[i]);\\n        int ans = cnt;\\n        for (int i = k; i < s.length(); i++) {\\n            cnt += vowels.count(s[i]) - vowels.count(s[i - k]);\\n            ans = max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489664,
                "title": "java-solution-using-sliding-window-with-comments",
                "content": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        \\n        int ans=0,cnt=0;\\n        \\n        for(int i=0;i<k;i++){   // first  count vowel in first window (size of window will be of k)\\n            char ch = s.charAt(i);\\n            if(isVowel(ch))cnt++;\\n        }\\n        ans = cnt;\\n        \\n        for(int i=k;i<s.length();i++){\\n            char currentChar = s.charAt(i); \\n            char previousChar = s.charAt(i-k);\\n            if(isVowel(currentChar))cnt++;   // if our current character is vowel then increment cnt\\n            if(isVowel(previousChar))cnt--;  // if our previous character is  vowel then decrement cnt because we loose our one vowel\\n            ans = Math.max(ans,cnt);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    public boolean isVowel(Character c){\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        \\n        int ans=0,cnt=0;\\n        \\n        for(int i=0;i<k;i++){   // first  count vowel in first window (size of window will be of k)\\n            char ch = s.charAt(i);\\n            if(isVowel(ch))cnt++;\\n        }\\n        ans = cnt;\\n        \\n        for(int i=k;i<s.length();i++){\\n            char currentChar = s.charAt(i); \\n            char previousChar = s.charAt(i-k);\\n            if(isVowel(currentChar))cnt++;   // if our current character is vowel then increment cnt\\n            if(isVowel(previousChar))cnt--;  // if our previous character is  vowel then decrement cnt because we loose our one vowel\\n            ans = Math.max(ans,cnt);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    public boolean isVowel(Character c){\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489284,
                "title": "solving-using-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        res=0\\n        fin_res=0\\n        for i in range(len(s)):\\n            if(s[i] in \\'aeiou\\'):res+=1\\n            if(i-k>=0):\\n                if(s[i-k] in \\'aeiou\\'):\\n                    res-=1\\n            fin_res=max(res,fin_res)\\n        return fin_res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        res=0\\n        fin_res=0\\n        for i in range(len(s)):\\n            if(s[i] in \\'aeiou\\'):res+=1\\n            if(i-k>=0):\\n                if(s[i-k] in \\'aeiou\\'):\\n                    res-=1\\n            fin_res=max(res,fin_res)\\n        return fin_res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489268,
                "title": "java-solution-sliding-window",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int maxVowels = 0;\\n        int vowelsOfPreviousSubstring = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            if(isVowel(s.charAt(i))) {\\n                maxVowels++;\\n            }\\n        }\\n\\n        vowelsOfPreviousSubstring = maxVowels;\\n\\n        for(int start = 1, end = k; end < s.length(); start++, end++) {\\n            int vowelsInCurrentSubstring = vowelsOfPreviousSubstring;\\n\\n            if(isVowel(s.charAt(start-1))) {\\n                vowelsInCurrentSubstring--;\\n            }\\n\\n            if(isVowel(s.charAt(end))) {\\n                vowelsInCurrentSubstring++;\\n            }\\n\\n            vowelsOfPreviousSubstring = vowelsInCurrentSubstring;\\n            maxVowels = Math.max(maxVowels, vowelsInCurrentSubstring);\\n        }\\n\\n        return maxVowels;\\n    }\\n\\n    private boolean isVowel(char ch) {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int maxVowels = 0;\\n        int vowelsOfPreviousSubstring = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            if(isVowel(s.charAt(i))) {\\n                maxVowels++;\\n            }\\n        }\\n\\n        vowelsOfPreviousSubstring = maxVowels;\\n\\n        for(int start = 1, end = k; end < s.length(); start++, end++) {\\n            int vowelsInCurrentSubstring = vowelsOfPreviousSubstring;\\n\\n            if(isVowel(s.charAt(start-1))) {\\n                vowelsInCurrentSubstring--;\\n            }\\n\\n            if(isVowel(s.charAt(end))) {\\n                vowelsInCurrentSubstring++;\\n            }\\n\\n            vowelsOfPreviousSubstring = vowelsInCurrentSubstring;\\n            maxVowels = Math.max(maxVowels, vowelsInCurrentSubstring);\\n        }\\n\\n        return maxVowels;\\n    }\\n\\n    private boolean isVowel(char ch) {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489009,
                "title": "simple-and-easy-python-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowel, count = 0, 0\\n        for i in range(k):\\n            c = s[i]\\n            if c in [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']:\\n                count += 1\\n        if count > vowel:\\n            vowel = count\\n        for i in range(k, len(s)):\\n            c = s[i]\\n            ch = s[i-k]\\n            if c in [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']:\\n                count += 1\\n            if ch in [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']:\\n                count -= 1\\n            if count >= k:\\n                return k\\n            if count > vowel:\\n                vowel = count\\n        return vowel\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowel, count = 0, 0\\n        for i in range(k):\\n            c = s[i]\\n            if c in [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']:\\n                count += 1\\n        if count > vowel:\\n            vowel = count\\n        for i in range(k, len(s)):\\n            c = s[i]\\n            ch = s[i-k]\\n            if c in [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']:\\n                count += 1\\n            if ch in [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']:\\n                count -= 1\\n            if count >= k:\\n                return k\\n            if count > vowel:\\n                vowel = count\\n        return vowel\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488946,
                "title": "sliding-window-solution-tc-o-n-sc-o-1",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use a sliding window approach.\\nWe should consider all possible substrings of length $$k$$ of $$s$$ one by one. We can slide a window of size $$k$$ through the string and at each position, count the number of vowels in the window. We can then keep track of the maximum count of vowels seen so far.\\n# Complexity\\n- Time complexity: O(n), where n is the length of $$s$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: constant or O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    bool isVowel(char c) {\\n        return (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\');\\n    }\\n\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n = s.length();\\n        int count = 0, maxCount = 0;\\n\\n        // count the number of vowels in the first window of length k\\n        for (int i = 0; i < k; i++)\\n            if (isVowel(s[i])) count++;\\n        maxCount = count;\\n\\n        // slide the window through the string and count the number of vowels in each window\\n        for (int i = k; i < n; i++) {\\n            if (isVowel(s[i])) count++;\\n            if (isVowel(s[i-k])) count--;\\n            maxCount = max(maxCount, count);\\n        }\\n        \\n        return maxCount;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\n    bool isVowel(char c) {\\n        return (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\');\\n    }\\n\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n = s.length();\\n        int count = 0, maxCount = 0;\\n\\n        // count the number of vowels in the first window of length k\\n        for (int i = 0; i < k; i++)\\n            if (isVowel(s[i])) count++;\\n        maxCount = count;\\n\\n        // slide the window through the string and count the number of vowels in each window\\n        for (int i = k; i < n; i++) {\\n            if (isVowel(s[i])) count++;\\n            if (isVowel(s[i-k])) count--;\\n            maxCount = max(maxCount, count);\\n        }\\n        \\n        return maxCount;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488937,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(char c)\\n    {\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\')return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) \\n    {\\n        int ans=0;\\n        int count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(check(s[i]))count++;\\n        }\\n        ans=count;\\n        int i=0,j=k;\\n        while(j<s.size())\\n        {\\n            if(check(s[j]))count++;\\n            if(check(s[i]))count--;\\n            ans=max(ans,count);\\n            j++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(char c)\\n    {\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\')return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) \\n    {\\n        int ans=0;\\n        int count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(check(s[i]))count++;\\n        }\\n        ans=count;\\n        int i=0,j=k;\\n        while(j<s.size())\\n        {\\n            if(check(s[j]))count++;\\n            if(check(s[i]))count--;\\n            ans=max(ans,count);\\n            j++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488934,
                "title": "easy-to-understand-solution",
                "content": "```\\nconst VOWELS = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxVowels = function(s, k) {\\n    let max = 0;\\n    let counter = 0;\\n\\n    // go through the string, but the last index should be s.length - k, \\n    // as i represents the start index of the substring with length k\"\\n    for (let i = 0; i < s.length - k + 1; i++) {\\n\\n        // if it\\'s the start of the string, then we need to define our counter for the first time\\n        // so we won\\'t need to calculate it over and over again later\\n        if (i === 0) {\\n            for (let j = 0; j < k; j++) {\\n                if (VOWELS.includes(s[j])){\\n                    counter++;\\n                }\\n            }\\n        // if it\\'s the rest of the string, then we just update the counter by analyzing \\n        // the removed first character of the string and the last added character\\n        } else {\\n            // if the removed first character was vowel then we decrease counter\\n            if (VOWELS.includes(s[i - 1])) {\\n                counter--;\\n            }\\n            // if the last added character is vowel then we increase counter\\n            if (VOWELS.includes(s[i + k - 1])) {\\n                counter++;\\n            }\\n        }\\n\\n        // if the counter is greater than the max, we update the max value\\n        if (counter > max) {\\n            max = counter; \\n        }\\n        // if the max value is equal to k, we return the result, as the max value cannot be greater than k.\\n        if (max === k) {\\n            return max;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst VOWELS = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxVowels = function(s, k) {\\n    let max = 0;\\n    let counter = 0;\\n\\n    // go through the string, but the last index should be s.length - k, \\n    // as i represents the start index of the substring with length k\"\\n    for (let i = 0; i < s.length - k + 1; i++) {\\n\\n        // if it\\'s the start of the string, then we need to define our counter for the first time\\n        // so we won\\'t need to calculate it over and over again later\\n        if (i === 0) {\\n            for (let j = 0; j < k; j++) {\\n                if (VOWELS.includes(s[j])){\\n                    counter++;\\n                }\\n            }\\n        // if it\\'s the rest of the string, then we just update the counter by analyzing \\n        // the removed first character of the string and the last added character\\n        } else {\\n            // if the removed first character was vowel then we decrease counter\\n            if (VOWELS.includes(s[i - 1])) {\\n                counter--;\\n            }\\n            // if the last added character is vowel then we increase counter\\n            if (VOWELS.includes(s[i + k - 1])) {\\n                counter++;\\n            }\\n        }\\n\\n        // if the counter is greater than the max, we update the max value\\n        if (counter > max) {\\n            max = counter; \\n        }\\n        // if the max value is equal to k, we return the result, as the max value cannot be greater than k.\\n        if (max === k) {\\n            return max;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3488816,
                "title": "python-solution-explained-in-detail-solved-using-sliding-window-concept",
                "content": "It is an excellent question to understand the concept of sliding window. Well, at very first try, I solved the question using naive approach that is count vowels for each substring of length `k` and update `maximum_vowel` counter, if a substring has more number of vowels than previously encountered substrings. But, soon after 1st submission I got an TLE error, because there was a `nested if` which made the time complexity of the solution: $$O(k*n)$$.\\nThus Optimization was required.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo, for next approach i thought of creating a window string of length `k`, and update it on each iteration, and update the `count_vowels` and `maximum_vowels` accordingly, but in this way also updating the window everytime adds overhead to the solution which again results in TLE\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThus, now to solve this, imagine a substring of the given string of length k from index 0, lets call it as sub_string1, thus `sub_string1 = s[i:k]`, we will count the number of vowels in it and store its value in `maximum_vowel`.\\nNow moving to next substring what we would do is actually include `s[k]` in the `sub_string1` and remove `s[0]` from `sub_string1`, thus we get our next substring and so on, but here we dont need to actually traverse throught the whole new substring to count the updated value of `count_vowels`.\\nInstead we can check that the character we are removing from substring to get the next substring is a vowel than we will decrease the `count_vowels` by 1 and if the character we are adding to get the next substring is a vowel we will increase the `count_vowels` by 1.\\nwe will keep on doing this until we reach the end of the given string.\\nNote: In the given code, the sub_string is denoted as window to make help visualize the concept of Sliding Window.\\n# Complexity\\n- Time complexity: $$O(n)$$ because we traverse the given string once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nHere, space complexity will be of $$O(k)$$, which is the length of window, The `count_vowels` and `maximum_vowels` variables occupy constant space, so they do not contribute to the overall space complexity of the code.\\n# Code\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        count_vowels = 0\\n        maximum_vowels = 0\\n        window = [0,k]\\n        for i in window:\\n            if i in \"aeiou\":\\n                count_vowels+=1\\n        maximum_vowels = max(maximum_vowels,count_vowels)\\n        j = 0\\n        for i in range(k, len(s)):\\n            if s[i] in \"aeiou\":\\n                count_vowels+=1\\n            if s[j] in \"aeiou\":\\n                count_vowels-=1\\n            j+=1\\n\\n            maximum_vowels = max(maximum_vowels,count_vowels)\\n            \\n        return maximum_vowels\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        count_vowels = 0\\n        maximum_vowels = 0\\n        window = [0,k]\\n        for i in window:\\n            if i in \"aeiou\":\\n                count_vowels+=1\\n        maximum_vowels = max(maximum_vowels,count_vowels)\\n        j = 0\\n        for i in range(k, len(s)):\\n            if s[i] in \"aeiou\":\\n                count_vowels+=1\\n            if s[j] in \"aeiou\":\\n                count_vowels-=1\\n            j+=1\\n\\n            maximum_vowels = max(maximum_vowels,count_vowels)\\n            \\n        return maximum_vowels\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488733,
                "title": "sliding-window-and-naive-approach-in-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        # Sliding Window\\n        vowels = \\'aeiou\\'\\n        \\n        # Take the initial substring to make a note of initial number of vowels\\n        s1 = s[:k]\\n        currVowels, maxVowels = 0, 0\\n        for i in s1:\\n            if i in vowels:\\n                currVowels += 1\\n        # If the number of vowels are equal to k, we cannot get any higher, so we return it\\n        if currVowels == k:\\n            return k\\n        # Else, keep track of the highest number of vowels            \\n        if currVowels > maxVowels:\\n            maxVowels = currVowels\\n        i = 1\\n\\n        # Increase the sliding window one by one until last k characters of the string\\n        while i < len(s)-k+1:\\n            # Decrease current number of vowels if the removed character is a vowel\\n            if s[i-1] in vowels:\\n                currVowels -= 1\\n            # Increase current number of vowels if the added character is a vowel\\n            if s[i+k-1] in vowels:\\n                currVowels += 1\\n            \\n            # If the number of vowels are equal to k, we cannot get any higher, so we return it\\n            if currVowels == k:\\n                return k\\n            # Else, keep track of the highest number of vowels            \\n            if currVowels > maxVowels:\\n                maxVowels = currVowels\\n\\n            i += 1\\n        return maxVowels\\n\\n        \\'\\'\\'\\n        # Naive Approach - 96/106\\n        vowels, maxVowels = \\'aeiou\\', 0\\n        for i in range(len(s)-k+1):\\n            # Get the substring\\n            s1 = s[i:i+k]\\n            # Check number of vowels\\n            numOfVowels = 0\\n            for i in s1:\\n                if i in vowels:\\n                    numOfVowels+=1\\n            # If the number of vowels are equal to k, we cannot get any higher, so we return it\\n            if numOfVowels == k:\\n                return k\\n            # Else, keep track of the highest number of vowels\\n            if numOfVowels > maxVowels:\\n                maxVowels = numOfVowels\\n        return maxVowels\\n        \\'\\'\\'\\n```\\n\\n\\n                ```Please Upvote if you like my content.```\\n\\n.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        # Sliding Window\\n        vowels = \\'aeiou\\'\\n        \\n        # Take the initial substring to make a note of initial number of vowels\\n        s1 = s[:k]\\n        currVowels, maxVowels = 0, 0\\n        for i in s1:\\n            if i in vowels:\\n                currVowels += 1\\n        # If the number of vowels are equal to k, we cannot get any higher, so we return it\\n        if currVowels == k:\\n            return k\\n        # Else, keep track of the highest number of vowels            \\n        if currVowels > maxVowels:\\n            maxVowels = currVowels\\n        i = 1\\n\\n        # Increase the sliding window one by one until last k characters of the string\\n        while i < len(s)-k+1:\\n            # Decrease current number of vowels if the removed character is a vowel\\n            if s[i-1] in vowels:\\n                currVowels -= 1\\n            # Increase current number of vowels if the added character is a vowel\\n            if s[i+k-1] in vowels:\\n                currVowels += 1\\n            \\n            # If the number of vowels are equal to k, we cannot get any higher, so we return it\\n            if currVowels == k:\\n                return k\\n            # Else, keep track of the highest number of vowels            \\n            if currVowels > maxVowels:\\n                maxVowels = currVowels\\n\\n            i += 1\\n        return maxVowels\\n\\n        \\'\\'\\'\\n        # Naive Approach - 96/106\\n        vowels, maxVowels = \\'aeiou\\', 0\\n        for i in range(len(s)-k+1):\\n            # Get the substring\\n            s1 = s[i:i+k]\\n            # Check number of vowels\\n            numOfVowels = 0\\n            for i in s1:\\n                if i in vowels:\\n                    numOfVowels+=1\\n            # If the number of vowels are equal to k, we cannot get any higher, so we return it\\n            if numOfVowels == k:\\n                return k\\n            # Else, keep track of the highest number of vowels\\n            if numOfVowels > maxVowels:\\n                maxVowels = numOfVowels\\n        return maxVowels\\n        \\'\\'\\'\\n```\n```Please Upvote if you like my content.```",
                "codeTag": "Java"
            },
            {
                "id": 3488703,
                "title": "sliding-window-using-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n  In this question we need to find the maximum vowel , and the sliding window technique is a powerful approach to solve a wide range of problems where we need to find a maximum or minimum value in a substring of a given size.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers left and right to the beginning of the     string s.\\n\\n    Calculate the vowel count for the first k characters in the string.\\n\\n2. Initialize a variable \"max_vowel\" to the vowel count of the first k characters.\\n\\n3. Move the window one character to the right by incrementing left and right pointers and updating the vowel count of the window.\\n\\n4. Update \"max_vowel\" if the current vowel count is greater than the maximum seen so far.\\n\\n5. Repeat step 4 and 5 until the end of the string is reached.\\n\\n6. Return the maximum vowel count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  The time complexity of the above code is O(n) as we are iterating over the string only once. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) as we are only using a constant amount of extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n = s.size();\\n        int max_vowel = 0 ; \\n        int vowel_count = 0 ; \\n        int right = 0 , left = 0 ; \\n\\n        while(right< n ){\\n            if(right - left < k ){\\n                if(s[right] ==\\'a\\'|| s[right] == \\'e\\' || s[right] ==\\'i\\' || s[right] ==\\'o\\' ||s[right] ==\\'u\\'){\\n                    vowel_count++;}\\n\\n                 right++;\\n            } else \\n                   {\\n                max_vowel = max(max_vowel , vowel_count);\\n                if(s[left] ==\\'a\\'|| s[left] == \\'e\\' || s[left] ==\\'i\\' || s[left] ==\\'o\\' ||s[left] ==\\'u\\')vowel_count--;\\n                left++;\\n            }\\n            \\n        }\\n\\n       return max(max_vowel , vowel_count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n = s.size();\\n        int max_vowel = 0 ; \\n        int vowel_count = 0 ; \\n        int right = 0 , left = 0 ; \\n\\n        while(right< n ){\\n            if(right - left < k ){\\n                if(s[right] ==\\'a\\'|| s[right] == \\'e\\' || s[right] ==\\'i\\' || s[right] ==\\'o\\' ||s[right] ==\\'u\\'){\\n                    vowel_count++;}\\n\\n                 right++;\\n            } else \\n                   {\\n                max_vowel = max(max_vowel , vowel_count);\\n                if(s[left] ==\\'a\\'|| s[left] == \\'e\\' || s[left] ==\\'i\\' || s[left] ==\\'o\\' ||s[left] ==\\'u\\')vowel_count--;\\n                left++;\\n            }\\n            \\n        }\\n\\n       return max(max_vowel , vowel_count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488664,
                "title": "solving-the-problem-using-sliding-window-c-and-java",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n       int vowel = 0, count = 0;\\n        \\n        // Initialize cumulative vowel count for the first k characters\\n        for (int i = 0; i < k; i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n                vowel++;\\n            }\\n        }\\n        count = vowel;\\n        \\n        // Update cumulative vowel count for each subsequent window of size k\\n        for (int i = k; i < s.length(); i++) {\\n            char c1 = s.charAt(i-k), c2 = s.charAt(i);\\n            if (c1 == \\'a\\' || c1 == \\'e\\' || c1 == \\'i\\' || c1 == \\'o\\' || c1 == \\'u\\') {\\n                vowel--;\\n            }\\n            if (c2 == \\'a\\' || c2 == \\'e\\' || c2 == \\'i\\' || c2 == \\'o\\' || c2 == \\'u\\') {\\n                vowel++;\\n            }\\n            count = Math.max(count, vowel);\\n        }\\n        \\n        return count;\\n    \\n        \\n    }\\n}\\n```\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n        int vowel = 0, count = 0;\\n        \\n        // Initialize cumulative vowel count for the first k characters\\n        for (int i = 0; i < k; i++) {\\n            char c = s[i];\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n                vowel++;\\n            }\\n        }\\n        count = vowel;\\n        \\n        // Update cumulative vowel count for each subsequent window of size k\\n        for (int i = k; i < s.length(); i++) {\\n            char c1 = s[i-k], c2 = s[i];\\n            if (c1 == \\'a\\' || c1 == \\'e\\' || c1 == \\'i\\' || c1 == \\'o\\' || c1 == \\'u\\') {\\n                vowel--;\\n            }\\n            if (c2 == \\'a\\' || c2 == \\'e\\' || c2 == \\'i\\' || c2 == \\'o\\' || c2 == \\'u\\') {\\n                vowel++;\\n            }\\n            count = max(count, vowel);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n       int vowel = 0, count = 0;\\n        \\n        // Initialize cumulative vowel count for the first k characters\\n        for (int i = 0; i < k; i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n                vowel++;\\n            }\\n        }\\n        count = vowel;\\n        \\n        // Update cumulative vowel count for each subsequent window of size k\\n        for (int i = k; i < s.length(); i++) {\\n            char c1 = s.charAt(i-k), c2 = s.charAt(i);\\n            if (c1 == \\'a\\' || c1 == \\'e\\' || c1 == \\'i\\' || c1 == \\'o\\' || c1 == \\'u\\') {\\n                vowel--;\\n            }\\n            if (c2 == \\'a\\' || c2 == \\'e\\' || c2 == \\'i\\' || c2 == \\'o\\' || c2 == \\'u\\') {\\n                vowel++;\\n            }\\n            count = Math.max(count, vowel);\\n        }\\n        \\n        return count;\\n    \\n        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n        int vowel = 0, count = 0;\\n        \\n        // Initialize cumulative vowel count for the first k characters\\n        for (int i = 0; i < k; i++) {\\n            char c = s[i];\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') {\\n                vowel++;\\n            }\\n        }\\n        count = vowel;\\n        \\n        // Update cumulative vowel count for each subsequent window of size k\\n        for (int i = k; i < s.length(); i++) {\\n            char c1 = s[i-k], c2 = s[i];\\n            if (c1 == \\'a\\' || c1 == \\'e\\' || c1 == \\'i\\' || c1 == \\'o\\' || c1 == \\'u\\') {\\n                vowel--;\\n            }\\n            if (c2 == \\'a\\' || c2 == \\'e\\' || c2 == \\'i\\' || c2 == \\'o\\' || c2 == \\'u\\') {\\n                vowel++;\\n            }\\n            count = max(count, vowel);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3488382,
                "title": "c-easy-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake a window of k substrings. calculate the vowels present in it using the vowel count from previous window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- first calculate the number of vowels in first k size window and store it in c\\n- then slide the window upto (n-k) `first index of last possible window ` by stepsize of 1\\n- If the letter we eleminated while sliding is a vowel then make c=c-1\\n- Else if the new letter included in the window is a vowel then make c=c+1\\n- make ans as the maximum between ans and c\\n- return ans\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c){\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\') return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        int ans=INT_MIN; int c=0;\\n        int n=s.length();\\n        for(int i=0;i<k;i++) if(isVowel(s[i])) c++;\\n        ans=max(ans,c);\\n        for(int i=1;i<n-k+1;i++){\\n            if(isVowel(s[i-1])) c--;\\n            if(isVowel(s[i+k-1])) c++;\\n            ans=max(ans,c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c){\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\') return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        int ans=INT_MIN; int c=0;\\n        int n=s.length();\\n        for(int i=0;i<k;i++) if(isVowel(s[i])) c++;\\n        ans=max(ans,c);\\n        for(int i=1;i<n-k+1;i++){\\n            if(isVowel(s[i-1])) c--;\\n            if(isVowel(s[i+k-1])) c++;\\n            ans=max(ans,c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488218,
                "title": "1456-maximum-number-of-vowels-in-a-substring-of-given-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given a string \\'s\\' and an integer \\'k\\'. We need to find the maximum number of vowels in any substring of \\'s\\' with length \\'k\\'. We can use a sliding window approach to solve this problem. We can initialize a window of size \\'k\\' at the beginning of the string and move it to the right one character at a time. At each step, we can count the number of vowels in the current window and update the maximum number of vowels seen so far.\\n\\n---\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we need to find all the substrings of length k in the given string s and then count the number of vowels in each substring. We will return the maximum count of vowels found among all the substrings.\\n\\n1. First, we will define a function to count the number of vowels in a given string. This function will take a string as input and return the count of vowels in the string.\\n2. Next, we will loop through all the substrings of length k in the given string s using a sliding window approach.\\n3. For each substring, we will count the number of vowels using the function defined in step 1.\\n4. We will keep track of the maximum count of vowels found among all the substrings.\\n5. Finally, we will return the maximum count of vowels found among all the substrings.\\n\\n---\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n), where n is the length of the input string. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1), since we only use a constant amount of space to store the variables.\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char& c){\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n    \\n    int maxVowels(string s, int k) {\\n        int n = s.size();\\n        int maxct = 0;\\n        int ct = 0;\\n        \\n        // Count vowels in first substring of length k\\n        for (int i = 0; i < k; i++) {\\n            if (isVowel(s[i])) {\\n                ct++;\\n            }\\n        }\\n        maxct = ct;\\n        \\n        // Slide the window of size k over the string s\\n        for (int i = k; i < n; i++) {\\n            // Subtract the count of vowel at the start of the previous window\\n            if (isVowel(s[i - k])) {\\n                ct--;\\n            }\\n            // Add the count of vowel at the end of the current window\\n            if (isVowel(s[i])) {\\n                ct++;\\n            }\\n            // Update the maximum count of vowels found so far\\n            maxct = max(maxct, ct);\\n        }\\n        return maxct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char& c){\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n    \\n    int maxVowels(string s, int k) {\\n        int n = s.size();\\n        int maxct = 0;\\n        int ct = 0;\\n        \\n        // Count vowels in first substring of length k\\n        for (int i = 0; i < k; i++) {\\n            if (isVowel(s[i])) {\\n                ct++;\\n            }\\n        }\\n        maxct = ct;\\n        \\n        // Slide the window of size k over the string s\\n        for (int i = k; i < n; i++) {\\n            // Subtract the count of vowel at the start of the previous window\\n            if (isVowel(s[i - k])) {\\n                ct--;\\n            }\\n            // Add the count of vowel at the end of the current window\\n            if (isVowel(s[i])) {\\n                ct++;\\n            }\\n            // Update the maximum count of vowels found so far\\n            maxct = max(maxct, ct);\\n        }\\n        return maxct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488182,
                "title": "it-does-run-simple-code-explanation",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k.\\n\\nVowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\\n\\n```\\nInput: s = \"abciiidef\", k = 3\\nOutput: 3\\nExplanation: The substring \"iii\" contains 3 vowel letters.\\n```\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function maxVowels takes a string str and an integer k as input and returns the maximum number of vowels in any substring of length k in the input string.\\n\\nThe code initializes a counter variable cnt to zero and a maximum count variable ans to zero.\\n\\nThe code creates a set s containing all the vowels (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\').\\n\\nThe code checks the first k characters of the input string and counts the number of vowels in that substring. This count is stored in the cnt variable and compared with the current maximum count ans. If cnt is greater than ans, ans is updated to cnt.\\n\\nThe code enters a loop that processes the remaining characters of the input string.\\n\\nIn each iteration of the loop, the code removes the leftmost character of the current substring (at position i) from the count cnt if it is a vowel.\\n\\nThe code then adds the next character in the string (at position j) to the count cnt if it is a vowel.\\n\\nThe code updates the maximum count ans if cnt is greater than ans.\\nFinally, the function returns the maximum count ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the length of the input string str.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string str, int k) {\\n       int cnt = 0, ans=0, n=str.length();\\n       set<char> s;\\n       s.insert(\\'a\\');s.insert(\\'e\\');s.insert(\\'i\\');s.insert(\\'o\\');s.insert(\\'u\\');\\n       int j;\\n       for(j=0; j<k; j++)\\n       {\\n           if(s.count(str[j])!=0)\\n           cnt++;\\n       }\\n       ans=max(ans,cnt);\\n       int i=0;\\n       while(j<n)\\n       {\\n         if(s.count(str[i])!=0)\\n         cnt--;\\n         if(s.count(str[j])!=0)\\n         cnt++;\\n         i++;\\n         j++;\\n         ans = max(ans,cnt);\\n       }\\n       return ans;\\n    }\\n};\\n```\\n![coderuns.jpeg](https://assets.leetcode.com/users/images/34704108-41e5-4c36-8ac7-c57dc7c1330a_1683272420.67118.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nInput: s = \"abciiidef\", k = 3\\nOutput: 3\\nExplanation: The substring \"iii\" contains 3 vowel letters.\\n```\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string str, int k) {\\n       int cnt = 0, ans=0, n=str.length();\\n       set<char> s;\\n       s.insert(\\'a\\');s.insert(\\'e\\');s.insert(\\'i\\');s.insert(\\'o\\');s.insert(\\'u\\');\\n       int j;\\n       for(j=0; j<k; j++)\\n       {\\n           if(s.count(str[j])!=0)\\n           cnt++;\\n       }\\n       ans=max(ans,cnt);\\n       int i=0;\\n       while(j<n)\\n       {\\n         if(s.count(str[i])!=0)\\n         cnt--;\\n         if(s.count(str[j])!=0)\\n         cnt++;\\n         i++;\\n         j++;\\n         ans = max(ans,cnt);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488167,
                "title": "best-window-shift-problem-in-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        mx_cnt = cur_cnt = 0\\n        vows = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'])        \\n        for i in range(k):\\n            if (s[i] in vows):\\n                cur_cnt += 1\\n        if cur_cnt == k:\\n            return k\\n        \\n        mx_cnt = cur_cnt\\n\\n        for i in range(k,len(s)):\\n            if s[i-k] in vows:\\n               cur_cnt -= 1\\n            if s[i] in vows:\\n                cur_cnt += 1\\n            mx_cnt = max(mx_cnt,cur_cnt)\\n            if mx_cnt == k:\\n                return k\\n\\n        return mx_cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        mx_cnt = cur_cnt = 0\\n        vows = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'])        \\n        for i in range(k):\\n            if (s[i] in vows):\\n                cur_cnt += 1\\n        if cur_cnt == k:\\n            return k\\n        \\n        mx_cnt = cur_cnt\\n\\n        for i in range(k,len(s)):\\n            if s[i-k] in vows:\\n               cur_cnt -= 1\\n            if s[i] in vows:\\n                cur_cnt += 1\\n            mx_cnt = max(mx_cnt,cur_cnt)\\n            if mx_cnt == k:\\n                return k\\n\\n        return mx_cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487970,
                "title": "easy-sliding-window-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake one unordered_map and insert first k characters with their frequency. While inserting keep checking if the character is vowel or not, if yes then increae count. update ans variable (max(ans, count)). Now start another loop from k to n and decrease the frequency of 0\\'th character and if it is vowel then decrease the count variable by 1. Insert the kth character and increase the count if it is a vowel, update ans. Then return the ans.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool isVowel(char x){\\n        if(x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\')\\n            return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        unordered_map<char, int> mp;\\n        int n = s.size();\\n        int ans = INT_MIN, count = 0;\\n        for(int i=0;i<k;i++){\\n            mp[s[i]]++;\\n            if(isVowel(s[i]))\\n                count++;\\n        }\\n        int p =0;\\n        for(int i=k;i<n;i++){\\n            ans = max(ans, count);\\n            mp[s[p]]--;\\n            if(isVowel(s[p]))\\n                count--;\\n            mp[s[i]]++;\\n            if(isVowel(s[i]))\\n                count++;\\n            p++;\\n        }\\n        ans = max(ans, count);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool isVowel(char x){\\n        if(x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\')\\n            return true;\\n        return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        unordered_map<char, int> mp;\\n        int n = s.size();\\n        int ans = INT_MIN, count = 0;\\n        for(int i=0;i<k;i++){\\n            mp[s[i]]++;\\n            if(isVowel(s[i]))\\n                count++;\\n        }\\n        int p =0;\\n        for(int i=k;i<n;i++){\\n            ans = max(ans, count);\\n            mp[s[p]]--;\\n            if(isVowel(s[p]))\\n                count--;\\n            mp[s[i]]++;\\n            if(isVowel(s[i]))\\n                count++;\\n            p++;\\n        }\\n        ans = max(ans, count);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487965,
                "title": "c-easy-solution-using-sliding-window-t-c-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVovel(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\')return true;\\n        return false;\\n    }\\n\\n    int maxVowels(string s, int k) {\\n\\n        int ans = 0;\\n        int cnt =0;\\n\\n        for(int i = 0 ; i < k ; i++){\\n            if(isVovel(s[i]))cnt++;\\n        }\\n        \\n        if(cnt == k)return k;\\n\\n        ans = max(ans,cnt);\\n\\n        for(int i = k ; i<s.length(); i++){\\n            if(isVovel(s[i-k]))cnt--;\\n            if(isVovel(s[i]))cnt++;\\n            ans = max(ans,cnt);\\n            if(cnt==k)return k;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVovel(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\')return true;\\n        return false;\\n    }\\n\\n    int maxVowels(string s, int k) {\\n\\n        int ans = 0;\\n        int cnt =0;\\n\\n        for(int i = 0 ; i < k ; i++){\\n            if(isVovel(s[i]))cnt++;\\n        }\\n        \\n        if(cnt == k)return k;\\n\\n        ans = max(ans,cnt);\\n\\n        for(int i = k ; i<s.length(); i++){\\n            if(isVovel(s[i-k]))cnt--;\\n            if(isVovel(s[i]))cnt++;\\n            ans = max(ans,cnt);\\n            if(cnt==k)return k;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487833,
                "title": "c-pure-implementation-using-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int res=0;\\n        map<char,int> mp;\\n        for(int i=0;i<k;i++){\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\'){\\n                mp[s[i]]++;\\n            }\\n        }\\n        res=max(res,mp[\\'a\\']+mp[\\'e\\']+mp[\\'i\\']+mp[\\'o\\']+mp[\\'u\\']);\\n        int j=0;\\n        for(int i=k;i<(int)s.size();i++){\\n            mp[s[j]]--;\\n            mp[s[j]]=max(0,mp[s[j]]);\\n            mp[s[i]]++;\\n            res=max(res,mp[\\'a\\']+mp[\\'e\\']+mp[\\'i\\']+mp[\\'o\\']+mp[\\'u\\']);\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int res=0;\\n        map<char,int> mp;\\n        for(int i=0;i<k;i++){\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\'){\\n                mp[s[i]]++;\\n            }\\n        }\\n        res=max(res,mp[\\'a\\']+mp[\\'e\\']+mp[\\'i\\']+mp[\\'o\\']+mp[\\'u\\']);\\n        int j=0;\\n        for(int i=k;i<(int)s.size();i++){\\n            mp[s[j]]--;\\n            mp[s[j]]=max(0,mp[s[j]]);\\n            mp[s[i]]++;\\n            res=max(res,mp[\\'a\\']+mp[\\'e\\']+mp[\\'i\\']+mp[\\'o\\']+mp[\\'u\\']);\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487786,
                "title": "simple-sliding-window-with-80-beats-easy-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Sliding Window\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a window of size k and count number of Vowels in that.\\n2. save the result in a Variable.\\n3. slide the window and update Answer with respect to first window element and last window element.\\n4. return max of answer\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        ans=0\\n        r=0\\n        for i in range(k):\\n            if s[i] in \"aeiou\":\\n                ans+=1\\n        r=ans\\n        for i in range(k,len(s)):\\n            if s[i-k] in \"aeiou\":\\n                ans-=1\\n            if s[i] in \"aeiou\":\\n                ans+=1\\n            r=max(r,ans)\\n        return r\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        ans=0\\n        r=0\\n        for i in range(k):\\n            if s[i] in \"aeiou\":\\n                ans+=1\\n        r=ans\\n        for i in range(k,len(s)):\\n            if s[i-k] in \"aeiou\":\\n                ans-=1\\n            if s[i] in \"aeiou\":\\n                ans+=1\\n            r=max(r,ans)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487590,
                "title": "easy-simple-and-concise-c-code-7ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    bool isVowel(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\'|| ch==\\'o\\' || ch==\\'u\\')return true;\\n        return false;\\n    }\\npublic:\\n    int maxVowels(string s, int k) {\\n        int count =0, n= s.size();\\n        for(int i=0;i<k;i++){\\n            if(isVowel(s[i])) count++;\\n        }\\n        int maxi = count ;\\n        for(int i=k;i<n;i++){\\n            if(isVowel(s[i])) count++;\\n            if(isVowel(s[i-k]))count--;\\n            maxi = max(maxi, count);\\n        }\\n        return maxi;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    bool isVowel(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\'|| ch==\\'o\\' || ch==\\'u\\')return true;\\n        return false;\\n    }\\npublic:\\n    int maxVowels(string s, int k) {\\n        int count =0, n= s.size();\\n        for(int i=0;i<k;i++){\\n            if(isVowel(s[i])) count++;\\n        }\\n        int maxi = count ;\\n        for(int i=k;i<n;i++){\\n            if(isVowel(s[i])) count++;\\n            if(isVowel(s[i-k]))count--;\\n            maxi = max(maxi, count);\\n        }\\n        return maxi;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487399,
                "title": "sliding-window-using-cpp",
                "content": "![UPvote.jpg](https://assets.leetcode.com/users/images/9ae406a1-6878-4d76-83f7-d9899a7e929c_1683263352.7406516.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count(char i){\\n      if(i==\\'a\\'||i==\\'e\\'||i==\\'i\\'||i==\\'o\\'||i==\\'u\\') return 1;\\n      return 0;\\n    }\\n    int maxVowels(string s, int k) {\\n      int mv = 0,cv = 0;\\n      for(int i =0;i<s.size();i++){\\n        cv += count(s[i]);\\n        if(i>=k) cv -= count(s[i-k]);\\n        mv = max(mv,cv);\\n      }\\n      return mv;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(char i){\\n      if(i==\\'a\\'||i==\\'e\\'||i==\\'i\\'||i==\\'o\\'||i==\\'u\\') return 1;\\n      return 0;\\n    }\\n    int maxVowels(string s, int k) {\\n      int mv = 0,cv = 0;\\n      for(int i =0;i<s.size();i++){\\n        cv += count(s[i]);\\n        if(i>=k) cv -= count(s[i-k]);\\n        mv = max(mv,cv);\\n      }\\n      return mv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487125,
                "title": "simple-python3-solution-upto-98-faster-o-n-explained-commented",
                "content": "# Approach\\nWe Store 1 or 0 in a vow_num_list in in place of a vowel or consonant respectively.\\n\\nWe keep track of left most element using a (pointer ind).\\n\\nWe count the number of vowels and store the max count in max_vow.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        # Checklist of vowels\\n        vow = {\\'a\\':1,\\'e\\':2,\\'i\\':3,\\'o\\':4,\\'u\\':5}  \\n\\n        # We keep a list respective to s where:\\n        # If s[i] is a vowel we append 1 else 0\\n        vow_num_list = []\\n        max_vow = 0\\n        for i in range(k):    # First we do it with k letters.\\n            if s[i] in vow:\\n                vow_num_list.append(1)\\n            else:\\n                vow_num_list.append(0)\\n    \\n        # check the count of vowels and store in max_vow\\n        count = sum(vow_num_list)\\n        if max_vow < count:\\n            max_vow = count\\n\\n        # We need this index value to keep track of  \\n        # left most element we count in our vow_num_list \\n        ind = 0\\n        \\n        # Now we check for the rest of the element in s\\n        for i in range(k,len(s)):\\n            \\n            # Similar to popleft() but instead just decrement the count \\n            # as we keep track of left most element \\n            if vow_num_list[ind] == 1:\\n                count -= 1\\n            ind += 1\\n\\n            # As we check new element s[i] we append 1 to list \\n            if s[i] in vow:\\n                vow_num_list.append(1)\\n                count += 1\\n            else:\\n                vow_num_list.append(0)\\n            \\n            # check the count of vowels and store in max_vow\\n            if max_vow < count:\\n                max_vow = count\\n            \\n        return max_vow\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        # Checklist of vowels\\n        vow = {\\'a\\':1,\\'e\\':2,\\'i\\':3,\\'o\\':4,\\'u\\':5}  \\n\\n        # We keep a list respective to s where:\\n        # If s[i] is a vowel we append 1 else 0\\n        vow_num_list = []\\n        max_vow = 0\\n        for i in range(k):    # First we do it with k letters.\\n            if s[i] in vow:\\n                vow_num_list.append(1)\\n            else:\\n                vow_num_list.append(0)\\n    \\n        # check the count of vowels and store in max_vow\\n        count = sum(vow_num_list)\\n        if max_vow < count:\\n            max_vow = count\\n\\n        # We need this index value to keep track of  \\n        # left most element we count in our vow_num_list \\n        ind = 0\\n        \\n        # Now we check for the rest of the element in s\\n        for i in range(k,len(s)):\\n            \\n            # Similar to popleft() but instead just decrement the count \\n            # as we keep track of left most element \\n            if vow_num_list[ind] == 1:\\n                count -= 1\\n            ind += 1\\n\\n            # As we check new element s[i] we append 1 to list \\n            if s[i] in vow:\\n                vow_num_list.append(1)\\n                count += 1\\n            else:\\n                vow_num_list.append(0)\\n            \\n            # check the count of vowels and store in max_vow\\n            if max_vow < count:\\n                max_vow = count\\n            \\n        return max_vow\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487108,
                "title": "java-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int length = s.length();\\n        if(length<k) return 0;\\n        int count = 0;\\n        \\n        for(int i=0;i<k;i++){\\n            if(isVowel(s.charAt(i))) count++;    \\n        }\\n\\n        int max = count;\\n\\n        int end = k-1;\\n        int start = 0;\\n        \\n        while(end<length-1){\\n            if(isVowel(s.charAt(start)) && count>0) count--;\\n            if(isVowel(s.charAt(end+1))) count++;\\n            start++;\\n            end++;\\n            max = Math.max(count,max);\\n        }\\n\\n        return max;\\n\\n    }\\n\\n\\n    public boolean isVowel(Character c){\\n        return (c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int length = s.length();\\n        if(length<k) return 0;\\n        int count = 0;\\n        \\n        for(int i=0;i<k;i++){\\n            if(isVowel(s.charAt(i))) count++;    \\n        }\\n\\n        int max = count;\\n\\n        int end = k-1;\\n        int start = 0;\\n        \\n        while(end<length-1){\\n            if(isVowel(s.charAt(start)) && count>0) count--;\\n            if(isVowel(s.charAt(end+1))) count++;\\n            start++;\\n            end++;\\n            max = Math.max(count,max);\\n        }\\n\\n        return max;\\n\\n    }\\n\\n\\n    public boolean isVowel(Character c){\\n        return (c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487011,
                "title": "easiest-solution-using-javascript",
                "content": "\\n# JavaScript Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxVowels = function(s, k) {\\n    let vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n    let maxCount = 0;\\n    let start = 0;\\n    let count = 0;\\n    for (let end = 0; end < s.length; end++) {\\n        if (vowels.includes(s[end])) {\\n            count +=1;\\n        }\\n        if (end - start + 1 > k) {\\n            if(vowels.includes(s[start])) {\\n                count -=1;\\n            }\\n            start +=1;\\n        }\\n        maxCount = Math.max(maxCount, count)\\n        if (maxCount == k) return maxCount;\\n    }\\n    return maxCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxVowels = function(s, k) {\\n    let vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'];\\n    let maxCount = 0;\\n    let start = 0;\\n    let count = 0;\\n    for (let end = 0; end < s.length; end++) {\\n        if (vowels.includes(s[end])) {\\n            count +=1;\\n        }\\n        if (end - start + 1 > k) {\\n            if(vowels.includes(s[start])) {\\n                count -=1;\\n            }\\n            start +=1;\\n        }\\n        maxCount = Math.max(maxCount, count)\\n        if (maxCount == k) return maxCount;\\n    }\\n    return maxCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486937,
                "title": "easy-c-sliding-window-solution",
                "content": "# Intuition\\nAfter Seeing this problem concept of Sliding Window has came in my mind.\\nhere we are given window size of k\\n# Approach\\nhere we have traversed through every window of size k\\nwe can use here map to keep the count of vowels .and simetaneously delete the elements of previous window when moving for new window.\\n# Complexity\\n- Time complexity:\\nO(n+k)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n= s.size();\\n        map<char,int> mp;\\n        for(int i=0;i<k;i++){\\n            mp[s[i]]++;\\n        }\\n        int res= mp[\\'a\\']+mp[\\'e\\']+mp[\\'i\\']+mp[\\'o\\']+mp[\\'u\\'];\\n        int c=0;\\n        for(int i=k;i<n;i++){\\n            mp[s[i]]++;\\n            mp[s[c]]--;\\n            if(mp[s[c]]==0){\\n                mp.erase(s[c]);\\n            }\\n            c++;\\n            res= max(res,mp[\\'a\\']+mp[\\'e\\']+mp[\\'i\\']+mp[\\'o\\']+mp[\\'u\\']);\\n        }\\n        return res;\\n    }\\n};\\n// If Found Helpful please upvote....\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int n= s.size();\\n        map<char,int> mp;\\n        for(int i=0;i<k;i++){\\n            mp[s[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3486878,
                "title": "c-sliding-window-faster-easy-to-understand",
                "content": "* ***Sliding Window***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for checking vowel \\n    \\n    bool is_vowel(char c)\\n    {\\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int maxVowels(string str, int k) {\\n        \\n        int n = str.size();\\n        \\n        int count_vowel = 0;\\n        \\n        // traverse over the str\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < k)\\n            {\\n                if(is_vowel(str[i]))\\n                {\\n                    count_vowel++;\\n                }\\n            }\\n            else\\n            {\\n                // update maxi\\n                \\n                maxi = max(maxi, count_vowel);\\n                \\n                if(is_vowel(str[i]))\\n                {\\n                    count_vowel++;\\n                }\\n                \\n                if(is_vowel(str[i - k]))\\n                {\\n                    count_vowel--;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, count_vowel);\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for checking vowel \\n    \\n    bool is_vowel(char c)\\n    {\\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int maxVowels(string str, int k) {\\n        \\n        int n = str.size();\\n        \\n        int count_vowel = 0;\\n        \\n        // traverse over the str\\n        \\n        int maxi = INT_MIN;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < k)\\n            {\\n                if(is_vowel(str[i]))\\n                {\\n                    count_vowel++;\\n                }\\n            }\\n            else\\n            {\\n                // update maxi\\n                \\n                maxi = max(maxi, count_vowel);\\n                \\n                if(is_vowel(str[i]))\\n                {\\n                    count_vowel++;\\n                }\\n                \\n                if(is_vowel(str[i - k]))\\n                {\\n                    count_vowel--;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, count_vowel);\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486708,
                "title": "damn-easy-basic-sliding-window-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isvowel(char ch)\\n{\\n    if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n    return true;\\n    return false;\\n}\\n    int maxVowels(string s, int k) {\\n       int i=0,j=0;\\n       int n=s.size();\\n       int vowel=0;\\n       int ans=INT_MIN;\\n       while(j<n) \\n       {\\n           if(isvowel(s[j]))\\n           {\\n               vowel++;\\n           }\\n           if(j-i+1==k)\\n           {\\n               ans=max(ans,vowel);\\n              if(isvowel(s[i]))\\n              {\\n                  vowel--;\\n              }\\n              i++;\\n           }\\n           j++;\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isvowel(char ch)\\n{\\n    if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n    return true;\\n    return false;\\n}\\n    int maxVowels(string s, int k) {\\n       int i=0,j=0;\\n       int n=s.size();\\n       int vowel=0;\\n       int ans=INT_MIN;\\n       while(j<n) \\n       {\\n           if(isvowel(s[j]))\\n           {\\n               vowel++;\\n           }\\n           if(j-i+1==k)\\n           {\\n               ans=max(ans,vowel);\\n              if(isvowel(s[i]))\\n              {\\n                  vowel--;\\n              }\\n              i++;\\n           }\\n           j++;\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443736,
                "title": "sliding-window-c",
                "content": "`Please Upvote If you Like !!!`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int mx = 0;\\n        for(int i=0;i<k;i++) {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\') mx++;\\n        }\\n        int ans = mx;\\n        for(int i=k;i<s.size();i++) {\\n            int j = i-k;\\n            if(s[j]==\\'a\\' or s[j]==\\'e\\' or s[j]==\\'i\\' or s[j]==\\'o\\' or s[j]==\\'u\\') mx--;\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\') mx++;\\n            ans = max(ans,mx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int mx = 0;\\n        for(int i=0;i<k;i++) {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\') mx++;\\n        }\\n        int ans = mx;\\n        for(int i=k;i<s.size();i++) {\\n            int j = i-k;\\n            if(s[j]==\\'a\\' or s[j]==\\'e\\' or s[j]==\\'i\\' or s[j]==\\'o\\' or s[j]==\\'u\\') mx--;\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\') mx++;\\n            ans = max(ans,mx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324738,
                "title": "easy-c-clean-code-sliding-window-fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n   use sliding window technique and assume a counter for counting vowels in the given size of window and store its max size in ans variable.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n       o(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      o(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int ans = 0, count = 0, j = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\') {\\n                count++;\\n            }\\n            if(i >= k) {\\n                if(s[j] == \\'a\\' || s[j] == \\'e\\' || s[j] == \\'i\\' || s[j] == \\'o\\' || s[j] == \\'u\\') {\\n                    count--;\\n                }\\n                j++;\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int ans = 0, count = 0, j = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\') {\\n                count++;\\n            }\\n            if(i >= k) {\\n                if(s[j] == \\'a\\' || s[j] == \\'e\\' || s[j] == \\'i\\' || s[j] == \\'o\\' || s[j] == \\'u\\') {\\n                    count--;\\n                }\\n                j++;\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323198,
                "title": "c-o-n-time-o-1-space-5-lines-only",
                "content": "**Intuition**\\n- Sliding window\\n- For a window of length `k`, we are keeping track of count of vowels in `local` variable\\n- For each window, we are calculating the `max value` of vowel count, and returning the answer at end\\n\\n**Code**\\n```c++\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int count = 0, counting = 0;\\n        unordered_set<char> bag = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        for (int i = 0, local = 0; i < s.size(); i++) {\\n            local += bag.count(s[i]);\\n            if (i - k >= 0) local -= bag.count(s[i-k]);\\n            count = max(count, local);\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int count = 0, counting = 0;\\n        unordered_set<char> bag = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        for (int i = 0, local = 0; i < s.size(); i++) {\\n            local += bag.count(s[i]);\\n            if (i - k >= 0) local -= bag.count(s[i-k]);\\n            count = max(count, local);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878029,
                "title": "python-93-10-faster-sliding-window-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        i,c,m,n=0,0,0,len(s)\\n        for j in range(n):\\n            if s[j] in \\'aeiou\\':\\n                c+=1\\n            if j-i+1==k:\\n                m=max(m,c)\\n                if s[i] in \\'aeiou\\':\\n                    c-=1\\n                i+=1\\n        return m\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        i,c,m,n=0,0,0,len(s)\\n        for j in range(n):\\n            if s[j] in \\'aeiou\\':\\n                c+=1\\n            if j-i+1==k:\\n                m=max(m,c)\\n                if s[i] in \\'aeiou\\':\\n                    c-=1\\n                i+=1\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865245,
                "title": "o-n-time-and-o-1-space-easy-solution-c",
                "content": "# Intuition\\nAditya vermas concept of sliding window \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst I took two pointer i and j both starting from begining only.took two var counter c to count current vowel counts and var m which will store over all maximum count than iterating them over the string for string length if *j th index* has the vowel increase counter till window size of k isnt formed, once window size is reached check if current vowel count is max or not update m. \\n<b>most imp</b> if your ith element is vowel you must decrement the counter and than continue your window size\\nat last return m.<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int c=0,m=0;\\n        int i=0,j=0;\\n        while(j<s.length()){\\n            if(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\')\\n            c++;\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                m=max(c,m);\\n                if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\')\\n                c--;\\n                i++;j++;\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int c=0,m=0;\\n        int i=0,j=0;\\n        while(j<s.length()){\\n            if(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\')\\n            c++;\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                m=max(c,m);\\n                if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\')\\n                c--;\\n                i++;j++;\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779134,
                "title": "cpp-c-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int ans=0,curr=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\')\\n            curr++;\\n        }\\n        ans = max(ans,curr);\\n        for(int i=k;i<s.length();i++)\\n        {\\n            if(( s[i]==\\'a\\'  ||  s[i]==\\'e\\'  ||  s[i]==\\'i\\'  ||  s[i]==\\'o\\'  ||  s[i]==\\'u\\' )  &&  (  s[i-k]!=\\'a\\'  &&  s[i-k]!=\\'e\\'  &&  s[i-k]!=\\'i\\'  &&  s[i-k]!=\\'o\\'  &&  s[i-k]!=\\'u\\' ))\\n            curr++;\\n            else if((s[i]!=\\'a\\' && s[i]!=\\'e\\' && s[i]!=\\'i\\'  &&  s[i]!=\\'o\\'  &&  s[i]!=\\'u\\')  &&  (s[i-k]==\\'a\\'  ||  s[i-k]==\\'e\\'  ||  s[i-k]==\\'i\\'  ||  s[i-k]==\\'o\\'  ||  s[i-k]==\\'u\\'))\\n            curr--;\\n            ans = max(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        int ans=0,curr=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\')\\n            curr++;\\n        }\\n        ans = max(ans,curr);\\n        for(int i=k;i<s.length();i++)\\n        {\\n            if(( s[i]==\\'a\\'  ||  s[i]==\\'e\\'  ||  s[i]==\\'i\\'  ||  s[i]==\\'o\\'  ||  s[i]==\\'u\\' )  &&  (  s[i-k]!=\\'a\\'  &&  s[i-k]!=\\'e\\'  &&  s[i-k]!=\\'i\\'  &&  s[i-k]!=\\'o\\'  &&  s[i-k]!=\\'u\\' ))\\n            curr++;\\n            else if((s[i]!=\\'a\\' && s[i]!=\\'e\\' && s[i]!=\\'i\\'  &&  s[i]!=\\'o\\'  &&  s[i]!=\\'u\\')  &&  (s[i-k]==\\'a\\'  ||  s[i-k]==\\'e\\'  ||  s[i-k]==\\'i\\'  ||  s[i-k]==\\'o\\'  ||  s[i-k]==\\'u\\'))\\n            curr--;\\n            ans = max(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737083,
                "title": "java-tle-to-optimized-approach",
                "content": "# TLE approach -->\\n\\n```\\nclass Solution {\\n    public boolean isVowel(char ch){\\n        return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n    public int countFunc(String s){\\n        int count = 0;\\n        for(char c : s.toCharArray()){\\n            if(isVowel(c)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int maxVowels(String s, int k) {\\n        int max = 0, i = 0;\\n        while(i<=s.length() - k){\\n            String generator = s.substring(i, i+k);\\n            int vowelCounter = countFunc(generator);\\n            max = Math.max(max, vowelCounter);\\n            i++;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n\\n# Working approach-->\\n```\\nclass Solution {\\n    public boolean isVowel(char ch){\\n        return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n    public int maxVowels(String s, int k) {\\n        int max = 0, i = 0, counter = 0;\\n        String generator = s.substring(i, i+k);\\n        for(char c : generator.toCharArray()){\\n            if(isVowel(c)){\\n                counter++;\\n            }\\n        }\\n        max = Math.max(counter, max);\\n        while(i < s.length() - k){\\n            if(isVowel(generator.charAt(0))){\\n                counter--;\\n            }\\n            i++;\\n            generator = s.substring(i, i+k);\\n            if(isVowel(generator.charAt(generator.length()-1))){\\n                counter++;\\n            }\\n            max = Math.max(counter, max);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n# Please upvote if you like the approach and comment if you could suggest a better approach as it\\'s runtime is showing quite high",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isVowel(char ch){\\n        return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n    public int countFunc(String s){\\n        int count = 0;\\n        for(char c : s.toCharArray()){\\n            if(isVowel(c)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    public int maxVowels(String s, int k) {\\n        int max = 0, i = 0;\\n        while(i<=s.length() - k){\\n            String generator = s.substring(i, i+k);\\n            int vowelCounter = countFunc(generator);\\n            max = Math.max(max, vowelCounter);\\n            i++;\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isVowel(char ch){\\n        return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n    public int maxVowels(String s, int k) {\\n        int max = 0, i = 0, counter = 0;\\n        String generator = s.substring(i, i+k);\\n        for(char c : generator.toCharArray()){\\n            if(isVowel(c)){\\n                counter++;\\n            }\\n        }\\n        max = Math.max(counter, max);\\n        while(i < s.length() - k){\\n            if(isVowel(generator.charAt(0))){\\n                counter--;\\n            }\\n            i++;\\n            generator = s.substring(i, i+k);\\n            if(isVowel(generator.charAt(generator.length()-1))){\\n                counter++;\\n            }\\n            max = Math.max(counter, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512948,
                "title": "sliding-window-prefix-sum-easy-c-implementation",
                "content": "class Solution {\\npublic:\\n\\n    int maxVowels(string s, int k) {\\n        int n=s.size();\\n        int a[n];\\n        for(int i=0;i<n;i++)\\n        {\\n             if(s[i]==\\'a\\' ||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\')\\n                 a[i]=1;\\n            else\\n                a[i]=0;\\n        }\\n        int pre[n+1];\\n        pre[0]=0;\\n        for(int i=1;i<n+1;i++)\\n        {\\n            pre[i]=pre[i-1]+a[i-1];\\n        }\\n        int ans=0;\\n        int i=0,j=k;\\n        while(j<n+1)\\n        {\\n            int len=pre[j]-pre[i];\\n            ans=max(ans,len);\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxVowels(string s, int k) {\\n        int n=s.size();\\n        int a[n];\\n        for(int i=0;i<n;i++)\\n        {\\n             if(s[i]==\\'a\\' ||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\')\\n                 a[i]=1;\\n            else\\n                a[i]=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1290850,
                "title": "python-3-one-line-faster-than-100-of-other-submissions",
                "content": "# Two lines\\n\\nInstead of the typical sliding window:\\n1. Transform `s` into an array where a vowel is a `1` and a non-vowel is a `0`\\n2. Build an accumulation array of these values ... and pad a `0` at the beginning of it\\n3. Then perform the sliding window\\n\\nBecause we\\'re only performing the vowel logic in one pass, we save a boatload of processing.\\n\\nAlso, utilizing `map` for the vowel logic AND the sliding window runs the slow parts of the code in CPython.\\n\\n```python\\nclass Solution:\\n  def maxVowels(self, s: str, k: int) -> int:\\n    X = [*accumulate(map(set(\\'aeiou\\').__contains__, s), initial=0)]\\n    return max(map(sub, X[k:], X))\\n```\\n\\n# In one line\\n\\n```python\\nclass Solution:\\n  def maxVowels(self, s: str, k: int) -> int:\\n    return max(map(sub, (X := [*accumulate(map(set(\\'aeiou\\').__contains__, s), initial=0)])[k:], X))\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a978785f-0e7e-4e72-adef-d4edd487dafb_1624398892.8983383.png)\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def maxVowels(self, s: str, k: int) -> int:\\n    X = [*accumulate(map(set(\\'aeiou\\').__contains__, s), initial=0)]\\n    return max(map(sub, X[k:], X))\\n```\n```python\\nclass Solution:\\n  def maxVowels(self, s: str, k: int) -> int:\\n    return max(map(sub, (X := [*accumulate(map(set(\\'aeiou\\').__contains__, s), initial=0)])[k:], X))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210283,
                "title": "c-solution",
                "content": "```\\n    string s1=\"aeiou\";\\n    map<char,int>m;\\n    \\n int maxVowels(string s, int k) {\\n     for(int i=0;i<5;i++){\\n        m[s1[i]]++;\\n    }     \\n   int n=s.size();\\n   \\n   int sum=0; \\n        \\n      int a=0;\\n   for(int i=0;i<k;i++){\\n       if(m[s[i]]>0){\\n           a++;\\n       }\\n    }\\n   \\n    sum=max(sum,a);\\n     int b=0;\\n   for(int i=k;i<n;i++){\\n       if(m[s[i]]>0){\\n           a++;\\n       }\\n       if(m[s[b]]>0){\\n           a--;\\n       }\\n       b++;\\n     sum=max(sum,a);  \\n   }  \\n     \\n     return sum;\\n  } \\n```",
                "solutionTags": [],
                "code": "```\\n    string s1=\"aeiou\";\\n    map<char,int>m;\\n    \\n int maxVowels(string s, int k) {\\n     for(int i=0;i<5;i++){\\n        m[s1[i]]++;\\n    }     \\n   int n=s.size();\\n   \\n   int sum=0; \\n        \\n      int a=0;\\n   for(int i=0;i<k;i++){\\n       if(m[s[i]]>0){\\n           a++;\\n       }\\n    }\\n   \\n    sum=max(sum,a);\\n     int b=0;\\n   for(int i=k;i<n;i++){\\n       if(m[s[i]]>0){\\n           a++;\\n       }\\n       if(m[s[b]]>0){\\n           a--;\\n       }\\n       b++;\\n     sum=max(sum,a);  \\n   }  \\n     \\n     return sum;\\n  } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1169774,
                "title": "javascript-faster-than-98-80-of-javascript-online-submissions",
                "content": "```\\nvar maxVowels = function (s, k) {\\n    let best = 0, count = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (\"aeiou\".includes(s[i])) count++;\\n        if (i >= k && \"aeiou\".includes(s[i - k])) count--;\\n        best = Math.max(best, count);\\n    }\\n    return best;\\n};\\n```\\n\\nRuntime: 88 ms, faster than 98.80% of JavaScript online submissions for Maximum Number of Vowels in a Substring of Given Length.\\nMemory Usage: 41.6 MB, less than 91.57% of JavaScript online submissions for Maximum Number of Vowels in a Substring of Given Length.",
                "solutionTags": [],
                "code": "```\\nvar maxVowels = function (s, k) {\\n    let best = 0, count = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (\"aeiou\".includes(s[i])) count++;\\n        if (i >= k && \"aeiou\".includes(s[i - k])) count--;\\n        best = Math.max(best, count);\\n    }\\n    return best;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166993,
                "title": "sliding-window-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        \\n        int c=0,i=0,max=0;\\n        \\n        \\n        for( ; i<k ; i++)\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\'|| s[i] == \\'o\\' || s[i] == \\'u\\' ) c++;\\n\\n        max=c;\\n      \\n        \\n        for( ; i<s.length() ; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\'|| s[i] == \\'o\\' || s[i] == \\'u\\' ) c++;\\n            if(s[i-k] == \\'a\\' || s[i-k] == \\'e\\' || s[i-k] == \\'i\\'|| s[i-k] == \\'o\\' || s[i-k] == \\'u\\' ) c--;\\n            if(max<c)\\n                max=c;\\n            \\n            \\n        }\\n        \\n        return max;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n        \\n        int c=0,i=0,max=0;\\n        \\n        \\n        for( ; i<k ; i++)\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\'|| s[i] == \\'o\\' || s[i] == \\'u\\' ) c++;\\n\\n        max=c;\\n      \\n        \\n        for( ; i<s.length() ; i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\'|| s[i] == \\'o\\' || s[i] == \\'u\\' ) c++;\\n            if(s[i-k] == \\'a\\' || s[i-k] == \\'e\\' || s[i-k] == \\'i\\'|| s[i-k] == \\'o\\' || s[i-k] == \\'u\\' ) c--;\\n            if(max<c)\\n                max=c;\\n            \\n            \\n        }\\n        \\n        return max;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127928,
                "title": "sliding-window-o-n-solution",
                "content": "JAVA CODE IS:\\n# \\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n      Set<Character>vowel=Set.of(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\');\\n      int i=0,count=0,res=0;\\n      char arr[]=s.toCharArray();  \\n      for(int j=0;j<arr.length;j++){\\n          if(vowel.contains(s.charAt(j))) count++;\\n          while(j-i+1>k)\\n              if(vowel.contains(s.charAt(i++))) count--;\\n         res=Math.max(res,count);   \\n      }\\n        return res;\\n    }\\n}\\n```\\nTIME : O(n)\\nSPACE : O(n)\\n***PLEASE,UPVOTE IF THIS IS HELPFUL***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n      Set<Character>vowel=Set.of(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\');\\n      int i=0,count=0,res=0;\\n      char arr[]=s.toCharArray();  \\n      for(int j=0;j<arr.length;j++){\\n          if(vowel.contains(s.charAt(j))) count++;\\n          while(j-i+1>k)\\n              if(vowel.contains(s.charAt(i++))) count--;\\n         res=Math.max(res,count);   \\n      }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075818,
                "title": "java-sliding-window-beats-98-7ms-o-s-length",
                "content": "\\n    public int maxVowels(String s, int k) {\\n        int ptr1 = 0, ptr2 = 0, ans = 0, count = 0, len = s.length(), size = 0;\\n\\n\\t\\twhile (size < k - 1) {\\n\\t\\t\\tsize++;\\n\\t\\t\\tchar ch = s.charAt(ptr1);\\n\\t\\t\\tif (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\tptr1++;\\n\\t\\t}\\n\\n\\t\\twhile (ptr1 < len) {\\n\\n\\t\\t\\t// acquire\\n\\t\\t\\tsize++;\\n\\t\\t\\tchar ch = s.charAt(ptr1);\\n\\t\\t\\tif (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\tptr1++;\\n\\n\\t\\t\\tans = Math.max(ans, count);\\n\\t\\t\\t// release\\n\\t\\t\\tch = s.charAt(ptr2);\\n\\t\\t\\tsize--;\\n\\t\\t\\tptr2++;\\n\\t\\t\\tif (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n\\t\\t\\t\\tcount--;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int maxVowels(String s, int k) {\\n        int ptr1 = 0, ptr2 = 0, ans = 0, count = 0, len = s.length(), size = 0;\\n\\n\\t\\twhile (size < k - 1) {\\n\\t\\t\\tsize++;\\n\\t\\t\\tchar ch = s.charAt(ptr1);\\n\\t\\t\\tif (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\tptr1++;\\n\\t\\t}\\n\\n\\t\\twhile (ptr1 < len) {\\n\\n\\t\\t\\t// acquire\\n\\t\\t\\tsize++;\\n\\t\\t\\tchar ch = s.charAt(ptr1);\\n\\t\\t\\tif (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\tptr1++;\\n\\n\\t\\t\\tans = Math.max(ans, count);\\n\\t\\t\\t// release\\n\\t\\t\\tch = s.charAt(ptr2);\\n\\t\\t\\tsize--;\\n\\t\\t\\tptr2++;\\n\\t\\t\\tif (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n\\t\\t\\t\\tcount--;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1006135,
                "title": "python-easy-to-undestand-sliding-window-using-deque",
                "content": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n        curr, counts, ans = collections.deque(), 0, 0\\n        for a in s:\\n            if a in vowels:\\n                counts += 1\\n            curr.append(a)\\n            if len(curr) == k:\\n                ans = max(ans, counts)\\n                if curr[0] in vowels:\\n                    counts -= 1\\n                curr.popleft()\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n        curr, counts, ans = collections.deque(), 0, 0\\n        for a in s:\\n            if a in vowels:\\n                counts += 1\\n            curr.append(a)\\n            if len(curr) == k:\\n                ans = max(ans, counts)\\n                if curr[0] in vowels:\\n                    counts -= 1\\n                curr.popleft()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773413,
                "title": "clean-c-solution-sliding-window",
                "content": "```\\nbool isVowel(char c){\\n\\tif(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n\\t\\treturn true;\\n\\treturn false;\\n}\\nint maxVowels(string s, int k) {\\n\\tint maxCount = 0, c = 0;\\n\\tfor(int i=0; i < k; i++){\\n\\t\\tif(isVowel(s[i]))\\n\\t\\t\\tc++;\\n\\t}\\n\\tmaxCount = max(maxCount, c);\\n\\tfor(int i=k; i < s.size(); i++){\\n\\t\\tif(isVowel(s[i-k]))\\n\\t\\t\\tc--;\\n\\t\\tif(isVowel(s[i]))\\n\\t\\t\\tc++;\\n\\t\\tmaxCount = max(c, maxCount);\\n\\t}\\n\\n\\treturn maxCount;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isVowel(char c){\\n\\tif(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n\\t\\treturn true;\\n\\treturn false;\\n}\\nint maxVowels(string s, int k) {\\n\\tint maxCount = 0, c = 0;\\n\\tfor(int i=0; i < k; i++){\\n\\t\\tif(isVowel(s[i]))\\n\\t\\t\\tc++;\\n\\t}\\n\\tmaxCount = max(maxCount, c);\\n\\tfor(int i=k; i < s.size(); i++){\\n\\t\\tif(isVowel(s[i-k]))\\n\\t\\t\\tc--;\\n\\t\\tif(isVowel(s[i]))\\n\\t\\t\\tc++;\\n\\t\\tmaxCount = max(c, maxCount);\\n\\t}\\n\\n\\treturn maxCount;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 689792,
                "title": "python-o-n-by-sliding-window-w-comment",
                "content": "Maintain a sliding window of size k to update max vowel count\\n\\n---\\n\\n**Implementation** by sliding window:\\n\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        \\n        vowels = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' }\\n        \\n        substring = s[:k]\\n        \\n        vowel_count = sum( 1 for char in substring if char in vowels )\\n        \\n        # record for max vowel count in substring\\n        max_vowel_count = vowel_count\\n        \\n        \\n        # sliding window of size k\\n        for tail_index in range(k, len(s)):\\n            \\n            head_index = tail_index - k\\n            head_char, tail_char = s[head_index], s[tail_index]\\n            \\n            if head_char in vowels:\\n                vowel_count -= 1\\n                \\n            if tail_char in vowels:\\n                vowel_count += 1\\n                \\n            max_vowel_count = max( max_vowel_count, vowel_count)\\n            \\n        \\n        return max_vowel_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        \\n        vowels = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' }\\n        \\n        substring = s[:k]\\n        \\n        vowel_count = sum( 1 for char in substring if char in vowels )\\n        \\n        # record for max vowel count in substring\\n        max_vowel_count = vowel_count\\n        \\n        \\n        # sliding window of size k\\n        for tail_index in range(k, len(s)):\\n            \\n            head_index = tail_index - k\\n            head_char, tail_char = s[head_index], s[tail_index]\\n            \\n            if head_char in vowels:\\n                vowel_count -= 1\\n                \\n            if tail_char in vowels:\\n                vowel_count += 1\\n                \\n            max_vowel_count = max( max_vowel_count, vowel_count)\\n            \\n        \\n        return max_vowel_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649879,
                "title": "rust-sliding-window-4ms",
                "content": "A simple sliding window pattern: count vowels moving in and out of window with size `k`, and keep track of the maximum.\\n\\n```rust\\nimpl Solution {\\n    pub fn is_vowel(c: char) -> bool{\\n        [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'].iter().any(|&_c| c == _c)\\n    }\\n    pub fn max_vowels(s: String, k: i32) -> i32 {\\n        let k = k as usize;\\n        let mut res = 0; \\n        let mut cnt = 0; \\n        let cs = s.chars().collect::<Vec<_>>();\\n        for (i, c) in s.chars().enumerate() {\\n            if Self::is_vowel(c) { cnt +=1 ; }\\n            if i >= k && Self::is_vowel(cs[i-k]) { cnt -= 1;}\\n            res = max(res, cnt);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_vowel(c: char) -> bool{\\n        [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'].iter().any(|&_c| c == _c)\\n    }\\n    pub fn max_vowels(s: String, k: i32) -> i32 {\\n        let k = k as usize;\\n        let mut res = 0; \\n        let mut cnt = 0; \\n        let cs = s.chars().collect::<Vec<_>>();\\n        for (i, c) in s.chars().enumerate() {\\n            if Self::is_vowel(c) { cnt +=1 ; }\\n            if i >= k && Self::is_vowel(cs[i-k]) { cnt -= 1;}\\n            res = max(res, cnt);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 649266,
                "title": "c-sliding-window",
                "content": "**Intuition:**\\n\\nCount the vowel in first window of length k and then keep on moving the window to the right. Check the character moving out the window.\\nIf outgoing character is vowel, reduce the count.  Add one to count if new incoming character is vowel.\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\npublic:\\n    int maxVowels(string s, int k) {\\n        \\n        int n = s.length();\\n        \\n        int i = 0, vcount = 0;\\n        for (i = 0; i < k; i++) {\\n            if (isVowel(s[i]))\\n                vcount++;\\n        }\\n        \\n        int res = vcount;\\n        for (; i < n; i++) {\\n            if (isVowel(s[i-k]))\\n                vcount--;\\n            if (isVowel(s[i]))\\n                vcount++;\\n            res = max(res, vcount);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\npublic:\\n    int maxVowels(string s, int k) {\\n        \\n        int n = s.length();\\n        \\n        int i = 0, vcount = 0;\\n        for (i = 0; i < k; i++) {\\n            if (isVowel(s[i]))\\n                vcount++;\\n        }\\n        \\n        int res = vcount;\\n        for (; i < n; i++) {\\n            if (isVowel(s[i-k]))\\n                vcount--;\\n            if (isVowel(s[i]))\\n                vcount++;\\n            res = max(res, vcount);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648857,
                "title": "c-sliding-window-with-simple-pruning",
                "content": "Solution 1:\\n```\\nclass Solution {// Sliding Window\\npublic://Time/Space: O(N); O(1)\\n    int maxVowels(string_view s, int k) {\\n        static int dict[26]={1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1};\\n        int ans = 0;\\n        for(int i = 0, cnt = 0; i < s.size() && ans < k; i++){   // ans < k is pruning          \\n            if(dict[s[i] - \\'a\\']) ans = max(ans, ++cnt);            \\n            if(i >= k - 1 && dict[s[i -k + 1]  - \\'a\\']) cnt--;            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nSolution 2:\\n```\\nclass Solution {// Sliding Window\\npublic://Time/Space: O(N); O(1)\\n    int maxVowels(string s, int k) {\\n        unordered_set<char> dict{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int ans = 0;\\n        for(int i = 0, cnt = 0; i < s.size() && ans < k; i++){  // ans < k is pruning \\n            if(dict.count(s[i])) cnt++;\\n            if(i >= k - 1) ans = max(ans, cnt);\\n            if(i >= k - 1 && dict.count(s[i -k + 1])) cnt--;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {// Sliding Window\\npublic://Time/Space: O(N); O(1)\\n    int maxVowels(string_view s, int k) {\\n        static int dict[26]={1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1};\\n        int ans = 0;\\n        for(int i = 0, cnt = 0; i < s.size() && ans < k; i++){   // ans < k is pruning          \\n            if(dict[s[i] - \\'a\\']) ans = max(ans, ++cnt);            \\n            if(i >= k - 1 && dict[s[i -k + 1]  - \\'a\\']) cnt--;            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {// Sliding Window\\npublic://Time/Space: O(N); O(1)\\n    int maxVowels(string s, int k) {\\n        unordered_set<char> dict{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int ans = 0;\\n        for(int i = 0, cnt = 0; i < s.size() && ans < k; i++){  // ans < k is pruning \\n            if(dict.count(s[i])) cnt++;\\n            if(i >= k - 1) ans = max(ans, cnt);\\n            if(i >= k - 1 && dict.count(s[i -k + 1])) cnt--;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648378,
                "title": "clean-python-3-sliding-window",
                "content": "Time: `O(N)`\\nSpace: `O(1)`\\n```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = set(\\'aeiou\\')\\n        count, m = 0, 0\\n        for i, c in enumerate(s):\\n            count += (c in vowels)\\n            if i >= k: count -= (s[i-k] in vowels)\\n            m = max(m, count)\\n        return m\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxVowels(self, s: str, k: int) -> int:\\n        vowels = set(\\'aeiou\\')\\n        count, m = 0, 0\\n        for i, c in enumerate(s):\\n            count += (c in vowels)\\n            if i >= k: count -= (s[i-k] in vowels)\\n            m = max(m, count)\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648336,
                "title": "c-simple-sliding-window-solution",
                "content": "```\\nint maxVowels(string s, int k) {\\n    int n = s.size();\\n    int left = 0; int count = 0; int res = 0;\\n    for(int right = 0; right < n; ++right) {\\n        while (right - left + 1 > k) {\\n            if (isVowel(s[left])) count--;\\n            left++;\\n        }\\n        if (isVowel(s[right])) count++;\\n        res = max(res, count);\\n    }\\n    return res;\\n}\\nbool isVowel(char ch) {\\n    return ch == \\'a\\' || ch == \\'i\\' || ch == \\'u\\' || ch == \\'e\\' || ch == \\'o\\';\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint maxVowels(string s, int k) {\\n    int n = s.size();\\n    int left = 0; int count = 0; int res = 0;\\n    for(int right = 0; right < n; ++right) {\\n        while (right - left + 1 > k) {\\n            if (isVowel(s[left])) count--;\\n            left++;\\n        }\\n        if (isVowel(s[right])) count++;\\n        res = max(res, count);\\n    }\\n    return res;\\n}\\nbool isVowel(char ch) {\\n    return ch == \\'a\\' || ch == \\'i\\' || ch == \\'u\\' || ch == \\'e\\' || ch == \\'o\\';\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051068,
                "title": "java-solution-o-n-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int i = 1;\\n        int j = k;\\n        int max = 0;\\n        int count = 0;\\n        HashSet<Character> hs = new HashSet<>();\\n\\n        hs.add(\\'a\\');\\n        hs.add(\\'e\\');\\n        hs.add(\\'i\\');\\n        hs.add(\\'o\\');\\n        hs.add(\\'u\\');\\n\\n        for(int l = 0; l < k; l++)\\n            if(hs.contains(s.charAt(l)))\\n                count++;\\n\\n        max = count;\\n\\n        while(j < s.length()){\\n            if(hs.contains(s.charAt(i-1)))\\n                count--;\\n            if(hs.contains(s.charAt(j)))\\n                count++;\\n            \\n            i++;\\n            j++;\\n            max = Math.max(count, max);\\n        }\\n\\n        return max;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxVowels(String s, int k) {\\n        int i = 1;\\n        int j = k;\\n        int max = 0;\\n        int count = 0;\\n        HashSet<Character> hs = new HashSet<>();\\n\\n        hs.add(\\'a\\');\\n        hs.add(\\'e\\');\\n        hs.add(\\'i\\');\\n        hs.add(\\'o\\');\\n        hs.add(\\'u\\');\\n\\n        for(int l = 0; l < k; l++)\\n            if(hs.contains(s.charAt(l)))\\n                count++;\\n\\n        max = count;\\n\\n        while(j < s.length()){\\n            if(hs.contains(s.charAt(i-1)))\\n                count--;\\n            if(hs.contains(s.charAt(j)))\\n                count++;\\n            \\n            i++;\\n            j++;\\n            max = Math.max(count, max);\\n        }\\n\\n        return max;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1882755,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1882742,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1883138,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1882727,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1573805,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1882776,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1883045,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1750787,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1882979,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1883593,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1882755,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1882742,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1883138,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1882727,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1573805,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1882776,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1883045,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1750787,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1882979,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1883593,
                "content": [
                    {
                        "username": "yshrini",
                        "content": "### Rule Of Thumb:\n`Counting in substring` ==  `Sliding Window` Problem"
                    },
                    {
                        "username": "naga_k",
                        "content": "is this too easy or am i getting better?"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "It\\'s easier because you are getting better!"
                    },
                    {
                        "username": "Casardo",
                        "content": "[@psionl0](/psionl0) The more I leetcode, the easier it is to identify patterns. But I wonder how long I would take to figure this out some years ago haha"
                    },
                    {
                        "username": "abhishek8933",
                        "content": "you are getting better day by day man just keep up the hard work!! "
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "It\\'s easier. Even I coded in 5 min "
                    },
                    {
                        "username": "jaiyadav",
                        "content": "It\\'s easy bro"
                    },
                    {
                        "username": "barvin04",
                        "content": "You are getting better, champ!  \\uD83D\\uDCAA"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Casardo](/Casardo) It looks like you have mastered the sliding window too."
                    },
                    {
                        "username": "Casardo",
                        "content": "maybe both xD"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "\"Time Limit Exceeded\"\n\ns = \n\n^^ \nI even added \"if s == None:\n                          return None\"\n\nEdit: It also says 106/106 testcases passed but stops me here :( I want my hit of dopamine, dang it"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@njalgo](/njalgo) Understood. Thanks for pointing that out :)"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Got it! Thanks :)"
                    },
                    {
                        "username": "njalgo",
                        "content": "[@coderGtm](/coderGtm) Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(nkk) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "njalgo",
                        "content": "Try to differentiate between Brute force solution and Sliding Window. Brute force will cause TLE because its time complexity will be O(n*k*k) however Sliding Window solution will run in O(n)."
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) Your code isn't optimized. For each iteration of the for loop you are counting the number of vowels in the window from scratch. Refer to my [solution](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3486544/java-sliding-window-8-lines-clean-simple/). You'll see that we don't need to go through all the elements in the window each time. We just need to check the first and last element for each iteration of `i`."
                    },
                    {
                        "username": "wuheuuu65",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) i\\'ve tried, it didn\\'t work"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Sure\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if s == None:\n            return 0\n        ans = 0\n        for i in range(len(s)-k+1):\n            window = s[i:i+k]\n            vovels = 0\n            vovels += window.count('a')\n            vovels += window.count('e')\n            vovels += window.count('i')\n            vovels += window.count('o')\n            vovels += window.count('u')\n            if vovels > ans:\n                ans = vovels\n\n        return ans\n```\n\nAlthough now it passed once after a few hours....but trying again gives TLE.\nStrange but my streak got saved : )"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) If there wasn\\'t 106/106 passed cases my money would be on me screwing up something but everything being passed makes it weird. Gonna report. Cheers."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "[@emrecoltu](/emrecoltu) maybe try reporting a bug? As the constraints say s.length should at-least be 1. A test case could be broken. \nRust doesn't have that test case, and a custom case with `s=` or `s=\"\"` fails as Invalid Testcase."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "[@pratyushchoudhary57](/pratyushchoudhary57) I tried both, neither worked."
                    },
                    {
                        "username": "pratyushchoudhary57",
                        "content": "Did you try returning 0 instead of None?"
                    },
                    {
                        "username": "emrecoltu",
                        "content": "I\\'m having the same problem. Tried many tweaks but still 106/106 passed hits TLE with \"s=\""
                    },
                    {
                        "username": "judgementdey",
                        "content": "[@coderGtm](/coderGtm) can you post your solution code here?"
                    },
                    {
                        "username": "coderGtm",
                        "content": "[@judgementdey](/judgementdey) Tried comparing both (even trimmed version of string) but still shows TLE...even after passing 106/106 test cases"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@judgementdey](/judgementdey) s is null/None I believe. If it were an empty string it would be s = \"\", but it just says s ="
                    },
                    {
                        "username": "judgementdey",
                        "content": "Is s null or an empty string in the test cae?"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "I was worried about tackling a difficult problem, but I'm grateful that LeetCode presented a manageable challenge this time. thank you!!!\nEdit: I know what's waiting for us tomorrow, but let's celebrate what we have now."
                    },
                    {
                        "username": "Jobababa",
                        "content": "so much cheerful"
                    },
                    {
                        "username": "xu932",
                        "content": "it is a straight forward rolling window with no tricks"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "i did that but am getting TLE"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I have a straightforward implementation but it is double counting lol. Not that simple."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Should have been easy "
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This should be easy so that more people can approach it. Many people just see the medium tag and assume its too hard for them, while this is actually and easy question."
                    },
                    {
                        "username": "_teh_",
                        "content": "[@anubhavanand](/anubhavanand) sliding window is easy the real challenge for beginners is the \"Time Limit Exceeded\" one"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "I agree, but sliding window approach would be medium easy for beginners"
                    },
                    {
                        "username": "ajinkode",
                        "content": "A typical Sliding Window problem."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s a \"getting started\" with sliding window problems"
                    },
                    {
                        "username": "dtaskara",
                        "content": "Someone explain me please why \"weallloveyou\" is 4 vowels ? But \"rhythms\" is 0 vowels ? \\n\\nFrom task description:\\n\"Vowel letters in English are \\'a\\', \\'e\\', \\'i\\', \\'o\\', and \\'u\\'.\""
                    },
                    {
                        "username": "harsh_na710",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) how weallloveyou has 4 vowel length in obtained subset "
                    },
                    {
                        "username": "dtaskara",
                        "content": "[@chiragsanghvi18](/chiragsanghvi18) thank you ,it was my mistake ,i confused length of substring"
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "if you check the last substring of \"weallloveyou\" i.e. \"loveyou\" you will find 4 vowels, \"o\",\"e\",\"o\",\"u\"\\nand in rhythms there are no vowels at all at any place, so 0 vowels."
                    },
                    {
                        "username": "StopNGo",
                        "content": "JS/TS: using RegExp('a|e|i|o|u','g') leads to the Time Limit Exceeded error in the 102nd (from 106) test case.\nJust in case :)"
                    },
                    {
                        "username": "dineshreddy0521",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1897058,
                "content": [
                    {
                        "username": "Ayushas1525",
                        "content": "Can anybody tell me  that how s=\"weallloveyou\" and k=7 has ouput 4?\\n"
                    },
                    {
                        "username": "Jaga-11",
                        "content": "[@kunjanvaghela](/kunjanvaghela) \\nI encountered with this issue ,try to traverse with this as range \\n```\\n for(int i=0;i<=s.length()-k;i++){\\n}\\n```"
                    },
                    {
                        "username": "kunjanvaghela",
                        "content": "k is substring length. So in the substring \\'loveyou\\', there are 4 vowels [o,e,o,u].\\nNote that we have to check for maximum number of vowels in substring of given length only for the input string s."
                    },
                    {
                        "username": "parmarrinila2002",
                        "content": "Same bruh, I am also not getting that testcase."
                    },
                    {
                        "username": "macrescu",
                        "content": "The \"hard\" part of this one is making it in a single for loop."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "its a straight forward, sliding window question.\\n5 easy questions in a row or am I becoming good coder?"
                    },
                    {
                        "username": "swapedoc",
                        "content": "I was getting memory limit exceeded for my implementation as I was passing the string by value in function to check if its a vowel . Lesson there: Always pass string by reference when doing read only operations atleast. a 10k size string when passed by value , exceeds 1-8MB memory of stack and you will get Memory limit exceeded error"
                    },
                    {
                        "username": "verticalcow",
                        "content": "it do be slidy windoh"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "This felt super easy, and I am sure we are going to have a \"Hard\" tomorrow. Leetcode never fails us :)"
                    },
                    {
                        "username": "eric1152001",
                        "content": "I used closure instead of for loop, and regex to check but still reach Time Limit Exceeded at testcase 102. Any other ways could I try? Thank you"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Try a two pointer sliding window approach."
                    },
                    {
                        "username": "natitati",
                        "content": "Brace yourself guys... Hard graph dp problem coming tommorow"
                    },
                    {
                        "username": "ikorpse",
                        "content": "tasks on weekend are going to be brutal"
                    },
                    {
                        "username": "layyy",
                        "content": "Should have written easy for this problem"
                    }
                ]
            },
            {
                "id": 1883621,
                "content": [
                    {
                        "username": "Ayushas1525",
                        "content": "Can anybody tell me  that how s=\"weallloveyou\" and k=7 has ouput 4?\\n"
                    },
                    {
                        "username": "Jaga-11",
                        "content": "[@kunjanvaghela](/kunjanvaghela) \\nI encountered with this issue ,try to traverse with this as range \\n```\\n for(int i=0;i<=s.length()-k;i++){\\n}\\n```"
                    },
                    {
                        "username": "kunjanvaghela",
                        "content": "k is substring length. So in the substring \\'loveyou\\', there are 4 vowels [o,e,o,u].\\nNote that we have to check for maximum number of vowels in substring of given length only for the input string s."
                    },
                    {
                        "username": "parmarrinila2002",
                        "content": "Same bruh, I am also not getting that testcase."
                    },
                    {
                        "username": "macrescu",
                        "content": "The \"hard\" part of this one is making it in a single for loop."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "its a straight forward, sliding window question.\\n5 easy questions in a row or am I becoming good coder?"
                    },
                    {
                        "username": "swapedoc",
                        "content": "I was getting memory limit exceeded for my implementation as I was passing the string by value in function to check if its a vowel . Lesson there: Always pass string by reference when doing read only operations atleast. a 10k size string when passed by value , exceeds 1-8MB memory of stack and you will get Memory limit exceeded error"
                    },
                    {
                        "username": "verticalcow",
                        "content": "it do be slidy windoh"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "This felt super easy, and I am sure we are going to have a \"Hard\" tomorrow. Leetcode never fails us :)"
                    },
                    {
                        "username": "eric1152001",
                        "content": "I used closure instead of for loop, and regex to check but still reach Time Limit Exceeded at testcase 102. Any other ways could I try? Thank you"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Try a two pointer sliding window approach."
                    },
                    {
                        "username": "natitati",
                        "content": "Brace yourself guys... Hard graph dp problem coming tommorow"
                    },
                    {
                        "username": "ikorpse",
                        "content": "tasks on weekend are going to be brutal"
                    },
                    {
                        "username": "layyy",
                        "content": "Should have written easy for this problem"
                    }
                ]
            },
            {
                "id": 1882948,
                "content": [
                    {
                        "username": "Ayushas1525",
                        "content": "Can anybody tell me  that how s=\"weallloveyou\" and k=7 has ouput 4?\\n"
                    },
                    {
                        "username": "Jaga-11",
                        "content": "[@kunjanvaghela](/kunjanvaghela) \\nI encountered with this issue ,try to traverse with this as range \\n```\\n for(int i=0;i<=s.length()-k;i++){\\n}\\n```"
                    },
                    {
                        "username": "kunjanvaghela",
                        "content": "k is substring length. So in the substring \\'loveyou\\', there are 4 vowels [o,e,o,u].\\nNote that we have to check for maximum number of vowels in substring of given length only for the input string s."
                    },
                    {
                        "username": "parmarrinila2002",
                        "content": "Same bruh, I am also not getting that testcase."
                    },
                    {
                        "username": "macrescu",
                        "content": "The \"hard\" part of this one is making it in a single for loop."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "its a straight forward, sliding window question.\\n5 easy questions in a row or am I becoming good coder?"
                    },
                    {
                        "username": "swapedoc",
                        "content": "I was getting memory limit exceeded for my implementation as I was passing the string by value in function to check if its a vowel . Lesson there: Always pass string by reference when doing read only operations atleast. a 10k size string when passed by value , exceeds 1-8MB memory of stack and you will get Memory limit exceeded error"
                    },
                    {
                        "username": "verticalcow",
                        "content": "it do be slidy windoh"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "This felt super easy, and I am sure we are going to have a \"Hard\" tomorrow. Leetcode never fails us :)"
                    },
                    {
                        "username": "eric1152001",
                        "content": "I used closure instead of for loop, and regex to check but still reach Time Limit Exceeded at testcase 102. Any other ways could I try? Thank you"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Try a two pointer sliding window approach."
                    },
                    {
                        "username": "natitati",
                        "content": "Brace yourself guys... Hard graph dp problem coming tommorow"
                    },
                    {
                        "username": "ikorpse",
                        "content": "tasks on weekend are going to be brutal"
                    },
                    {
                        "username": "layyy",
                        "content": "Should have written easy for this problem"
                    }
                ]
            },
            {
                "id": 1997228,
                "content": [
                    {
                        "username": "Ayushas1525",
                        "content": "Can anybody tell me  that how s=\"weallloveyou\" and k=7 has ouput 4?\\n"
                    },
                    {
                        "username": "Jaga-11",
                        "content": "[@kunjanvaghela](/kunjanvaghela) \\nI encountered with this issue ,try to traverse with this as range \\n```\\n for(int i=0;i<=s.length()-k;i++){\\n}\\n```"
                    },
                    {
                        "username": "kunjanvaghela",
                        "content": "k is substring length. So in the substring \\'loveyou\\', there are 4 vowels [o,e,o,u].\\nNote that we have to check for maximum number of vowels in substring of given length only for the input string s."
                    },
                    {
                        "username": "parmarrinila2002",
                        "content": "Same bruh, I am also not getting that testcase."
                    },
                    {
                        "username": "macrescu",
                        "content": "The \"hard\" part of this one is making it in a single for loop."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "its a straight forward, sliding window question.\\n5 easy questions in a row or am I becoming good coder?"
                    },
                    {
                        "username": "swapedoc",
                        "content": "I was getting memory limit exceeded for my implementation as I was passing the string by value in function to check if its a vowel . Lesson there: Always pass string by reference when doing read only operations atleast. a 10k size string when passed by value , exceeds 1-8MB memory of stack and you will get Memory limit exceeded error"
                    },
                    {
                        "username": "verticalcow",
                        "content": "it do be slidy windoh"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "This felt super easy, and I am sure we are going to have a \"Hard\" tomorrow. Leetcode never fails us :)"
                    },
                    {
                        "username": "eric1152001",
                        "content": "I used closure instead of for loop, and regex to check but still reach Time Limit Exceeded at testcase 102. Any other ways could I try? Thank you"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Try a two pointer sliding window approach."
                    },
                    {
                        "username": "natitati",
                        "content": "Brace yourself guys... Hard graph dp problem coming tommorow"
                    },
                    {
                        "username": "ikorpse",
                        "content": "tasks on weekend are going to be brutal"
                    },
                    {
                        "username": "layyy",
                        "content": "Should have written easy for this problem"
                    }
                ]
            },
            {
                "id": 1979351,
                "content": [
                    {
                        "username": "Ayushas1525",
                        "content": "Can anybody tell me  that how s=\"weallloveyou\" and k=7 has ouput 4?\\n"
                    },
                    {
                        "username": "Jaga-11",
                        "content": "[@kunjanvaghela](/kunjanvaghela) \\nI encountered with this issue ,try to traverse with this as range \\n```\\n for(int i=0;i<=s.length()-k;i++){\\n}\\n```"
                    },
                    {
                        "username": "kunjanvaghela",
                        "content": "k is substring length. So in the substring \\'loveyou\\', there are 4 vowels [o,e,o,u].\\nNote that we have to check for maximum number of vowels in substring of given length only for the input string s."
                    },
                    {
                        "username": "parmarrinila2002",
                        "content": "Same bruh, I am also not getting that testcase."
                    },
                    {
                        "username": "macrescu",
                        "content": "The \"hard\" part of this one is making it in a single for loop."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "its a straight forward, sliding window question.\\n5 easy questions in a row or am I becoming good coder?"
                    },
                    {
                        "username": "swapedoc",
                        "content": "I was getting memory limit exceeded for my implementation as I was passing the string by value in function to check if its a vowel . Lesson there: Always pass string by reference when doing read only operations atleast. a 10k size string when passed by value , exceeds 1-8MB memory of stack and you will get Memory limit exceeded error"
                    },
                    {
                        "username": "verticalcow",
                        "content": "it do be slidy windoh"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "This felt super easy, and I am sure we are going to have a \"Hard\" tomorrow. Leetcode never fails us :)"
                    },
                    {
                        "username": "eric1152001",
                        "content": "I used closure instead of for loop, and regex to check but still reach Time Limit Exceeded at testcase 102. Any other ways could I try? Thank you"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Try a two pointer sliding window approach."
                    },
                    {
                        "username": "natitati",
                        "content": "Brace yourself guys... Hard graph dp problem coming tommorow"
                    },
                    {
                        "username": "ikorpse",
                        "content": "tasks on weekend are going to be brutal"
                    },
                    {
                        "username": "layyy",
                        "content": "Should have written easy for this problem"
                    }
                ]
            },
            {
                "id": 1883709,
                "content": [
                    {
                        "username": "Ayushas1525",
                        "content": "Can anybody tell me  that how s=\"weallloveyou\" and k=7 has ouput 4?\\n"
                    },
                    {
                        "username": "Jaga-11",
                        "content": "[@kunjanvaghela](/kunjanvaghela) \\nI encountered with this issue ,try to traverse with this as range \\n```\\n for(int i=0;i<=s.length()-k;i++){\\n}\\n```"
                    },
                    {
                        "username": "kunjanvaghela",
                        "content": "k is substring length. So in the substring \\'loveyou\\', there are 4 vowels [o,e,o,u].\\nNote that we have to check for maximum number of vowels in substring of given length only for the input string s."
                    },
                    {
                        "username": "parmarrinila2002",
                        "content": "Same bruh, I am also not getting that testcase."
                    },
                    {
                        "username": "macrescu",
                        "content": "The \"hard\" part of this one is making it in a single for loop."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "its a straight forward, sliding window question.\\n5 easy questions in a row or am I becoming good coder?"
                    },
                    {
                        "username": "swapedoc",
                        "content": "I was getting memory limit exceeded for my implementation as I was passing the string by value in function to check if its a vowel . Lesson there: Always pass string by reference when doing read only operations atleast. a 10k size string when passed by value , exceeds 1-8MB memory of stack and you will get Memory limit exceeded error"
                    },
                    {
                        "username": "verticalcow",
                        "content": "it do be slidy windoh"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "This felt super easy, and I am sure we are going to have a \"Hard\" tomorrow. Leetcode never fails us :)"
                    },
                    {
                        "username": "eric1152001",
                        "content": "I used closure instead of for loop, and regex to check but still reach Time Limit Exceeded at testcase 102. Any other ways could I try? Thank you"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Try a two pointer sliding window approach."
                    },
                    {
                        "username": "natitati",
                        "content": "Brace yourself guys... Hard graph dp problem coming tommorow"
                    },
                    {
                        "username": "ikorpse",
                        "content": "tasks on weekend are going to be brutal"
                    },
                    {
                        "username": "layyy",
                        "content": "Should have written easy for this problem"
                    }
                ]
            },
            {
                "id": 1883678,
                "content": [
                    {
                        "username": "Ayushas1525",
                        "content": "Can anybody tell me  that how s=\"weallloveyou\" and k=7 has ouput 4?\\n"
                    },
                    {
                        "username": "Jaga-11",
                        "content": "[@kunjanvaghela](/kunjanvaghela) \\nI encountered with this issue ,try to traverse with this as range \\n```\\n for(int i=0;i<=s.length()-k;i++){\\n}\\n```"
                    },
                    {
                        "username": "kunjanvaghela",
                        "content": "k is substring length. So in the substring \\'loveyou\\', there are 4 vowels [o,e,o,u].\\nNote that we have to check for maximum number of vowels in substring of given length only for the input string s."
                    },
                    {
                        "username": "parmarrinila2002",
                        "content": "Same bruh, I am also not getting that testcase."
                    },
                    {
                        "username": "macrescu",
                        "content": "The \"hard\" part of this one is making it in a single for loop."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "its a straight forward, sliding window question.\\n5 easy questions in a row or am I becoming good coder?"
                    },
                    {
                        "username": "swapedoc",
                        "content": "I was getting memory limit exceeded for my implementation as I was passing the string by value in function to check if its a vowel . Lesson there: Always pass string by reference when doing read only operations atleast. a 10k size string when passed by value , exceeds 1-8MB memory of stack and you will get Memory limit exceeded error"
                    },
                    {
                        "username": "verticalcow",
                        "content": "it do be slidy windoh"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "This felt super easy, and I am sure we are going to have a \"Hard\" tomorrow. Leetcode never fails us :)"
                    },
                    {
                        "username": "eric1152001",
                        "content": "I used closure instead of for loop, and regex to check but still reach Time Limit Exceeded at testcase 102. Any other ways could I try? Thank you"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Try a two pointer sliding window approach."
                    },
                    {
                        "username": "natitati",
                        "content": "Brace yourself guys... Hard graph dp problem coming tommorow"
                    },
                    {
                        "username": "ikorpse",
                        "content": "tasks on weekend are going to be brutal"
                    },
                    {
                        "username": "layyy",
                        "content": "Should have written easy for this problem"
                    }
                ]
            },
            {
                "id": 1883492,
                "content": [
                    {
                        "username": "Ayushas1525",
                        "content": "Can anybody tell me  that how s=\"weallloveyou\" and k=7 has ouput 4?\\n"
                    },
                    {
                        "username": "Jaga-11",
                        "content": "[@kunjanvaghela](/kunjanvaghela) \\nI encountered with this issue ,try to traverse with this as range \\n```\\n for(int i=0;i<=s.length()-k;i++){\\n}\\n```"
                    },
                    {
                        "username": "kunjanvaghela",
                        "content": "k is substring length. So in the substring \\'loveyou\\', there are 4 vowels [o,e,o,u].\\nNote that we have to check for maximum number of vowels in substring of given length only for the input string s."
                    },
                    {
                        "username": "parmarrinila2002",
                        "content": "Same bruh, I am also not getting that testcase."
                    },
                    {
                        "username": "macrescu",
                        "content": "The \"hard\" part of this one is making it in a single for loop."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "its a straight forward, sliding window question.\\n5 easy questions in a row or am I becoming good coder?"
                    },
                    {
                        "username": "swapedoc",
                        "content": "I was getting memory limit exceeded for my implementation as I was passing the string by value in function to check if its a vowel . Lesson there: Always pass string by reference when doing read only operations atleast. a 10k size string when passed by value , exceeds 1-8MB memory of stack and you will get Memory limit exceeded error"
                    },
                    {
                        "username": "verticalcow",
                        "content": "it do be slidy windoh"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "This felt super easy, and I am sure we are going to have a \"Hard\" tomorrow. Leetcode never fails us :)"
                    },
                    {
                        "username": "eric1152001",
                        "content": "I used closure instead of for loop, and regex to check but still reach Time Limit Exceeded at testcase 102. Any other ways could I try? Thank you"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Try a two pointer sliding window approach."
                    },
                    {
                        "username": "natitati",
                        "content": "Brace yourself guys... Hard graph dp problem coming tommorow"
                    },
                    {
                        "username": "ikorpse",
                        "content": "tasks on weekend are going to be brutal"
                    },
                    {
                        "username": "layyy",
                        "content": "Should have written easy for this problem"
                    }
                ]
            },
            {
                "id": 1883114,
                "content": [
                    {
                        "username": "Ayushas1525",
                        "content": "Can anybody tell me  that how s=\"weallloveyou\" and k=7 has ouput 4?\\n"
                    },
                    {
                        "username": "Jaga-11",
                        "content": "[@kunjanvaghela](/kunjanvaghela) \\nI encountered with this issue ,try to traverse with this as range \\n```\\n for(int i=0;i<=s.length()-k;i++){\\n}\\n```"
                    },
                    {
                        "username": "kunjanvaghela",
                        "content": "k is substring length. So in the substring \\'loveyou\\', there are 4 vowels [o,e,o,u].\\nNote that we have to check for maximum number of vowels in substring of given length only for the input string s."
                    },
                    {
                        "username": "parmarrinila2002",
                        "content": "Same bruh, I am also not getting that testcase."
                    },
                    {
                        "username": "macrescu",
                        "content": "The \"hard\" part of this one is making it in a single for loop."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "its a straight forward, sliding window question.\\n5 easy questions in a row or am I becoming good coder?"
                    },
                    {
                        "username": "swapedoc",
                        "content": "I was getting memory limit exceeded for my implementation as I was passing the string by value in function to check if its a vowel . Lesson there: Always pass string by reference when doing read only operations atleast. a 10k size string when passed by value , exceeds 1-8MB memory of stack and you will get Memory limit exceeded error"
                    },
                    {
                        "username": "verticalcow",
                        "content": "it do be slidy windoh"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "This felt super easy, and I am sure we are going to have a \"Hard\" tomorrow. Leetcode never fails us :)"
                    },
                    {
                        "username": "eric1152001",
                        "content": "I used closure instead of for loop, and regex to check but still reach Time Limit Exceeded at testcase 102. Any other ways could I try? Thank you"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Try a two pointer sliding window approach."
                    },
                    {
                        "username": "natitati",
                        "content": "Brace yourself guys... Hard graph dp problem coming tommorow"
                    },
                    {
                        "username": "ikorpse",
                        "content": "tasks on weekend are going to be brutal"
                    },
                    {
                        "username": "layyy",
                        "content": "Should have written easy for this problem"
                    }
                ]
            },
            {
                "id": 1883038,
                "content": [
                    {
                        "username": "Ayushas1525",
                        "content": "Can anybody tell me  that how s=\"weallloveyou\" and k=7 has ouput 4?\\n"
                    },
                    {
                        "username": "Jaga-11",
                        "content": "[@kunjanvaghela](/kunjanvaghela) \\nI encountered with this issue ,try to traverse with this as range \\n```\\n for(int i=0;i<=s.length()-k;i++){\\n}\\n```"
                    },
                    {
                        "username": "kunjanvaghela",
                        "content": "k is substring length. So in the substring \\'loveyou\\', there are 4 vowels [o,e,o,u].\\nNote that we have to check for maximum number of vowels in substring of given length only for the input string s."
                    },
                    {
                        "username": "parmarrinila2002",
                        "content": "Same bruh, I am also not getting that testcase."
                    },
                    {
                        "username": "macrescu",
                        "content": "The \"hard\" part of this one is making it in a single for loop."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "its a straight forward, sliding window question.\\n5 easy questions in a row or am I becoming good coder?"
                    },
                    {
                        "username": "swapedoc",
                        "content": "I was getting memory limit exceeded for my implementation as I was passing the string by value in function to check if its a vowel . Lesson there: Always pass string by reference when doing read only operations atleast. a 10k size string when passed by value , exceeds 1-8MB memory of stack and you will get Memory limit exceeded error"
                    },
                    {
                        "username": "verticalcow",
                        "content": "it do be slidy windoh"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "This felt super easy, and I am sure we are going to have a \"Hard\" tomorrow. Leetcode never fails us :)"
                    },
                    {
                        "username": "eric1152001",
                        "content": "I used closure instead of for loop, and regex to check but still reach Time Limit Exceeded at testcase 102. Any other ways could I try? Thank you"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "Try a two pointer sliding window approach."
                    },
                    {
                        "username": "natitati",
                        "content": "Brace yourself guys... Hard graph dp problem coming tommorow"
                    },
                    {
                        "username": "ikorpse",
                        "content": "tasks on weekend are going to be brutal"
                    },
                    {
                        "username": "layyy",
                        "content": "Should have written easy for this problem"
                    }
                ]
            },
            {
                "id": 1882795,
                "content": [
                    {
                        "username": "gadmo",
                        "content": "level is clearly not medium "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "is it possible to do with dynamic programming if the given s.length is only 10^4"
                    },
                    {
                        "username": "namandt",
                        "content": "sliding window inherently dynamic in sense"
                    },
                    {
                        "username": "Casardo",
                        "content": "shouldnt it be easy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not unless you are familiar with the sliding window approach."
                    },
                    {
                        "username": "jekatigr",
                        "content": "Pattern broken!\\n\\neasy-easy-easy-medium-~hard~-hard-hard"
                    },
                    {
                        "username": "partTime",
                        "content": "why this gives TLE\n\nbool isvowel(char ch){\n     return ch=='a' || ch=='e' || ch == 'i' || ch =='o'|| ch== 'u';\n }\n    int maxVowels(string s, int k) {\n        queue<char>q;\n     int count = 0;\n        //process first k size window\n        for(int i= 0;i<k;i++){\n            if(isvowel(s[i])){\n                count++;\n            }       \n         q.push(s[i]);\n        }\n          int maxi =INT_MIN;\n          maxi = max(maxi,count);\n          count = 0;\n          for(int i = k;i<s.length();i++){\n               q.pop();\n               q.push(s[i]);\n               int k1 = k;\n             while(!q.empty() and k--){\n               char ch = q.front();\n               if(isvowel(ch)){\n                   count++;\n               }\n               q.pop();\n               q.push(ch); \n           }\n           k = k1;\n           maxi = max(maxi,count);\n           count = 0;\n\n          }       \n         // process\n\nreturn maxi;\n    }\n}; \n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "C#: I think I wrote really optimized code but I have Time Limit Exceeded. Passed 99/106. Any help appreciated.\\n```    \\n    public int MaxVowels(string s, int k) {\\n        int max = 0;\\n        int curr = 0;\\n        Func<char, int> vowels = c=>(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')?1:0;\\n \\n        for (int i = 0; i < k; ++i) {\\n            curr+=vowels(s[i]);\\n        }\\n        max = curr;\\n        \\n        for (int i = k; i < s.Count(); ++i) {\\n           curr+=vowels(s[i]);\\n           curr-=vowels(s[i-k]);\\n           if (curr>max) max=curr;\\n        }\\n        return max;\\n    }\\n```"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Ok I found it. Apparently .Count() takes much longer that .Length.\\nThat was it. Crazy."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "should be Easy instead of Medium"
                    },
                    {
                        "username": "parth33998",
                        "content": "class Solution {\\n\\n    public boolean isVowel(Character ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maxVowels(String s, int k) {\\n\\n        int i=0; \\n        int j=0;\\n\\n        int max=0;\\n        int count=0;\\n\\n        while(j<s.length())\\n        {\\n                if(isVowel(s.charAt(j)))\\n                count++;\\n        }\\n        while(j-i+1>k)\\n        {\\n            if(isVowel(s.charAt(i)))\\n            \\n                count--;\\n                i++;\\n                j++;\\n            \\n        }\\n        max= Math.max(count,max);\\n        j++;\\n\\n\\n        return max;\\n        \\n    }\\n}\\n\\n\\n\\nIts showing TLE ......\\n\\nAnyone ? correct me where i went wrong. "
                    },
                    {
                        "username": "Jobababa",
                        "content": "Can you describe more about what you want to do with both while-loops?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I thought I\\'m the only one who thinks that this problem is too easy. But we are just getting better so keep it up cheers to all leetcoders\\uD83C\\uDF7B"
                    },
                    {
                        "username": "cycv5",
                        "content": "This one is an easy question but on the harder end. \\nSimilar to [643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/description/)"
                    }
                ]
            },
            {
                "id": 1882791,
                "content": [
                    {
                        "username": "gadmo",
                        "content": "level is clearly not medium "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "is it possible to do with dynamic programming if the given s.length is only 10^4"
                    },
                    {
                        "username": "namandt",
                        "content": "sliding window inherently dynamic in sense"
                    },
                    {
                        "username": "Casardo",
                        "content": "shouldnt it be easy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not unless you are familiar with the sliding window approach."
                    },
                    {
                        "username": "jekatigr",
                        "content": "Pattern broken!\\n\\neasy-easy-easy-medium-~hard~-hard-hard"
                    },
                    {
                        "username": "partTime",
                        "content": "why this gives TLE\n\nbool isvowel(char ch){\n     return ch=='a' || ch=='e' || ch == 'i' || ch =='o'|| ch== 'u';\n }\n    int maxVowels(string s, int k) {\n        queue<char>q;\n     int count = 0;\n        //process first k size window\n        for(int i= 0;i<k;i++){\n            if(isvowel(s[i])){\n                count++;\n            }       \n         q.push(s[i]);\n        }\n          int maxi =INT_MIN;\n          maxi = max(maxi,count);\n          count = 0;\n          for(int i = k;i<s.length();i++){\n               q.pop();\n               q.push(s[i]);\n               int k1 = k;\n             while(!q.empty() and k--){\n               char ch = q.front();\n               if(isvowel(ch)){\n                   count++;\n               }\n               q.pop();\n               q.push(ch); \n           }\n           k = k1;\n           maxi = max(maxi,count);\n           count = 0;\n\n          }       \n         // process\n\nreturn maxi;\n    }\n}; \n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "C#: I think I wrote really optimized code but I have Time Limit Exceeded. Passed 99/106. Any help appreciated.\\n```    \\n    public int MaxVowels(string s, int k) {\\n        int max = 0;\\n        int curr = 0;\\n        Func<char, int> vowels = c=>(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')?1:0;\\n \\n        for (int i = 0; i < k; ++i) {\\n            curr+=vowels(s[i]);\\n        }\\n        max = curr;\\n        \\n        for (int i = k; i < s.Count(); ++i) {\\n           curr+=vowels(s[i]);\\n           curr-=vowels(s[i-k]);\\n           if (curr>max) max=curr;\\n        }\\n        return max;\\n    }\\n```"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Ok I found it. Apparently .Count() takes much longer that .Length.\\nThat was it. Crazy."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "should be Easy instead of Medium"
                    },
                    {
                        "username": "parth33998",
                        "content": "class Solution {\\n\\n    public boolean isVowel(Character ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maxVowels(String s, int k) {\\n\\n        int i=0; \\n        int j=0;\\n\\n        int max=0;\\n        int count=0;\\n\\n        while(j<s.length())\\n        {\\n                if(isVowel(s.charAt(j)))\\n                count++;\\n        }\\n        while(j-i+1>k)\\n        {\\n            if(isVowel(s.charAt(i)))\\n            \\n                count--;\\n                i++;\\n                j++;\\n            \\n        }\\n        max= Math.max(count,max);\\n        j++;\\n\\n\\n        return max;\\n        \\n    }\\n}\\n\\n\\n\\nIts showing TLE ......\\n\\nAnyone ? correct me where i went wrong. "
                    },
                    {
                        "username": "Jobababa",
                        "content": "Can you describe more about what you want to do with both while-loops?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I thought I\\'m the only one who thinks that this problem is too easy. But we are just getting better so keep it up cheers to all leetcoders\\uD83C\\uDF7B"
                    },
                    {
                        "username": "cycv5",
                        "content": "This one is an easy question but on the harder end. \\nSimilar to [643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/description/)"
                    }
                ]
            },
            {
                "id": 1882764,
                "content": [
                    {
                        "username": "gadmo",
                        "content": "level is clearly not medium "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "is it possible to do with dynamic programming if the given s.length is only 10^4"
                    },
                    {
                        "username": "namandt",
                        "content": "sliding window inherently dynamic in sense"
                    },
                    {
                        "username": "Casardo",
                        "content": "shouldnt it be easy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not unless you are familiar with the sliding window approach."
                    },
                    {
                        "username": "jekatigr",
                        "content": "Pattern broken!\\n\\neasy-easy-easy-medium-~hard~-hard-hard"
                    },
                    {
                        "username": "partTime",
                        "content": "why this gives TLE\n\nbool isvowel(char ch){\n     return ch=='a' || ch=='e' || ch == 'i' || ch =='o'|| ch== 'u';\n }\n    int maxVowels(string s, int k) {\n        queue<char>q;\n     int count = 0;\n        //process first k size window\n        for(int i= 0;i<k;i++){\n            if(isvowel(s[i])){\n                count++;\n            }       \n         q.push(s[i]);\n        }\n          int maxi =INT_MIN;\n          maxi = max(maxi,count);\n          count = 0;\n          for(int i = k;i<s.length();i++){\n               q.pop();\n               q.push(s[i]);\n               int k1 = k;\n             while(!q.empty() and k--){\n               char ch = q.front();\n               if(isvowel(ch)){\n                   count++;\n               }\n               q.pop();\n               q.push(ch); \n           }\n           k = k1;\n           maxi = max(maxi,count);\n           count = 0;\n\n          }       \n         // process\n\nreturn maxi;\n    }\n}; \n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "C#: I think I wrote really optimized code but I have Time Limit Exceeded. Passed 99/106. Any help appreciated.\\n```    \\n    public int MaxVowels(string s, int k) {\\n        int max = 0;\\n        int curr = 0;\\n        Func<char, int> vowels = c=>(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')?1:0;\\n \\n        for (int i = 0; i < k; ++i) {\\n            curr+=vowels(s[i]);\\n        }\\n        max = curr;\\n        \\n        for (int i = k; i < s.Count(); ++i) {\\n           curr+=vowels(s[i]);\\n           curr-=vowels(s[i-k]);\\n           if (curr>max) max=curr;\\n        }\\n        return max;\\n    }\\n```"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Ok I found it. Apparently .Count() takes much longer that .Length.\\nThat was it. Crazy."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "should be Easy instead of Medium"
                    },
                    {
                        "username": "parth33998",
                        "content": "class Solution {\\n\\n    public boolean isVowel(Character ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maxVowels(String s, int k) {\\n\\n        int i=0; \\n        int j=0;\\n\\n        int max=0;\\n        int count=0;\\n\\n        while(j<s.length())\\n        {\\n                if(isVowel(s.charAt(j)))\\n                count++;\\n        }\\n        while(j-i+1>k)\\n        {\\n            if(isVowel(s.charAt(i)))\\n            \\n                count--;\\n                i++;\\n                j++;\\n            \\n        }\\n        max= Math.max(count,max);\\n        j++;\\n\\n\\n        return max;\\n        \\n    }\\n}\\n\\n\\n\\nIts showing TLE ......\\n\\nAnyone ? correct me where i went wrong. "
                    },
                    {
                        "username": "Jobababa",
                        "content": "Can you describe more about what you want to do with both while-loops?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I thought I\\'m the only one who thinks that this problem is too easy. But we are just getting better so keep it up cheers to all leetcoders\\uD83C\\uDF7B"
                    },
                    {
                        "username": "cycv5",
                        "content": "This one is an easy question but on the harder end. \\nSimilar to [643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/description/)"
                    }
                ]
            },
            {
                "id": 1882746,
                "content": [
                    {
                        "username": "gadmo",
                        "content": "level is clearly not medium "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "is it possible to do with dynamic programming if the given s.length is only 10^4"
                    },
                    {
                        "username": "namandt",
                        "content": "sliding window inherently dynamic in sense"
                    },
                    {
                        "username": "Casardo",
                        "content": "shouldnt it be easy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not unless you are familiar with the sliding window approach."
                    },
                    {
                        "username": "jekatigr",
                        "content": "Pattern broken!\\n\\neasy-easy-easy-medium-~hard~-hard-hard"
                    },
                    {
                        "username": "partTime",
                        "content": "why this gives TLE\n\nbool isvowel(char ch){\n     return ch=='a' || ch=='e' || ch == 'i' || ch =='o'|| ch== 'u';\n }\n    int maxVowels(string s, int k) {\n        queue<char>q;\n     int count = 0;\n        //process first k size window\n        for(int i= 0;i<k;i++){\n            if(isvowel(s[i])){\n                count++;\n            }       \n         q.push(s[i]);\n        }\n          int maxi =INT_MIN;\n          maxi = max(maxi,count);\n          count = 0;\n          for(int i = k;i<s.length();i++){\n               q.pop();\n               q.push(s[i]);\n               int k1 = k;\n             while(!q.empty() and k--){\n               char ch = q.front();\n               if(isvowel(ch)){\n                   count++;\n               }\n               q.pop();\n               q.push(ch); \n           }\n           k = k1;\n           maxi = max(maxi,count);\n           count = 0;\n\n          }       \n         // process\n\nreturn maxi;\n    }\n}; \n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "C#: I think I wrote really optimized code but I have Time Limit Exceeded. Passed 99/106. Any help appreciated.\\n```    \\n    public int MaxVowels(string s, int k) {\\n        int max = 0;\\n        int curr = 0;\\n        Func<char, int> vowels = c=>(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')?1:0;\\n \\n        for (int i = 0; i < k; ++i) {\\n            curr+=vowels(s[i]);\\n        }\\n        max = curr;\\n        \\n        for (int i = k; i < s.Count(); ++i) {\\n           curr+=vowels(s[i]);\\n           curr-=vowels(s[i-k]);\\n           if (curr>max) max=curr;\\n        }\\n        return max;\\n    }\\n```"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Ok I found it. Apparently .Count() takes much longer that .Length.\\nThat was it. Crazy."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "should be Easy instead of Medium"
                    },
                    {
                        "username": "parth33998",
                        "content": "class Solution {\\n\\n    public boolean isVowel(Character ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maxVowels(String s, int k) {\\n\\n        int i=0; \\n        int j=0;\\n\\n        int max=0;\\n        int count=0;\\n\\n        while(j<s.length())\\n        {\\n                if(isVowel(s.charAt(j)))\\n                count++;\\n        }\\n        while(j-i+1>k)\\n        {\\n            if(isVowel(s.charAt(i)))\\n            \\n                count--;\\n                i++;\\n                j++;\\n            \\n        }\\n        max= Math.max(count,max);\\n        j++;\\n\\n\\n        return max;\\n        \\n    }\\n}\\n\\n\\n\\nIts showing TLE ......\\n\\nAnyone ? correct me where i went wrong. "
                    },
                    {
                        "username": "Jobababa",
                        "content": "Can you describe more about what you want to do with both while-loops?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I thought I\\'m the only one who thinks that this problem is too easy. But we are just getting better so keep it up cheers to all leetcoders\\uD83C\\uDF7B"
                    },
                    {
                        "username": "cycv5",
                        "content": "This one is an easy question but on the harder end. \\nSimilar to [643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/description/)"
                    }
                ]
            },
            {
                "id": 2038433,
                "content": [
                    {
                        "username": "gadmo",
                        "content": "level is clearly not medium "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "is it possible to do with dynamic programming if the given s.length is only 10^4"
                    },
                    {
                        "username": "namandt",
                        "content": "sliding window inherently dynamic in sense"
                    },
                    {
                        "username": "Casardo",
                        "content": "shouldnt it be easy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not unless you are familiar with the sliding window approach."
                    },
                    {
                        "username": "jekatigr",
                        "content": "Pattern broken!\\n\\neasy-easy-easy-medium-~hard~-hard-hard"
                    },
                    {
                        "username": "partTime",
                        "content": "why this gives TLE\n\nbool isvowel(char ch){\n     return ch=='a' || ch=='e' || ch == 'i' || ch =='o'|| ch== 'u';\n }\n    int maxVowels(string s, int k) {\n        queue<char>q;\n     int count = 0;\n        //process first k size window\n        for(int i= 0;i<k;i++){\n            if(isvowel(s[i])){\n                count++;\n            }       \n         q.push(s[i]);\n        }\n          int maxi =INT_MIN;\n          maxi = max(maxi,count);\n          count = 0;\n          for(int i = k;i<s.length();i++){\n               q.pop();\n               q.push(s[i]);\n               int k1 = k;\n             while(!q.empty() and k--){\n               char ch = q.front();\n               if(isvowel(ch)){\n                   count++;\n               }\n               q.pop();\n               q.push(ch); \n           }\n           k = k1;\n           maxi = max(maxi,count);\n           count = 0;\n\n          }       \n         // process\n\nreturn maxi;\n    }\n}; \n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "C#: I think I wrote really optimized code but I have Time Limit Exceeded. Passed 99/106. Any help appreciated.\\n```    \\n    public int MaxVowels(string s, int k) {\\n        int max = 0;\\n        int curr = 0;\\n        Func<char, int> vowels = c=>(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')?1:0;\\n \\n        for (int i = 0; i < k; ++i) {\\n            curr+=vowels(s[i]);\\n        }\\n        max = curr;\\n        \\n        for (int i = k; i < s.Count(); ++i) {\\n           curr+=vowels(s[i]);\\n           curr-=vowels(s[i-k]);\\n           if (curr>max) max=curr;\\n        }\\n        return max;\\n    }\\n```"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Ok I found it. Apparently .Count() takes much longer that .Length.\\nThat was it. Crazy."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "should be Easy instead of Medium"
                    },
                    {
                        "username": "parth33998",
                        "content": "class Solution {\\n\\n    public boolean isVowel(Character ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maxVowels(String s, int k) {\\n\\n        int i=0; \\n        int j=0;\\n\\n        int max=0;\\n        int count=0;\\n\\n        while(j<s.length())\\n        {\\n                if(isVowel(s.charAt(j)))\\n                count++;\\n        }\\n        while(j-i+1>k)\\n        {\\n            if(isVowel(s.charAt(i)))\\n            \\n                count--;\\n                i++;\\n                j++;\\n            \\n        }\\n        max= Math.max(count,max);\\n        j++;\\n\\n\\n        return max;\\n        \\n    }\\n}\\n\\n\\n\\nIts showing TLE ......\\n\\nAnyone ? correct me where i went wrong. "
                    },
                    {
                        "username": "Jobababa",
                        "content": "Can you describe more about what you want to do with both while-loops?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I thought I\\'m the only one who thinks that this problem is too easy. But we are just getting better so keep it up cheers to all leetcoders\\uD83C\\uDF7B"
                    },
                    {
                        "username": "cycv5",
                        "content": "This one is an easy question but on the harder end. \\nSimilar to [643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/description/)"
                    }
                ]
            },
            {
                "id": 2038067,
                "content": [
                    {
                        "username": "gadmo",
                        "content": "level is clearly not medium "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "is it possible to do with dynamic programming if the given s.length is only 10^4"
                    },
                    {
                        "username": "namandt",
                        "content": "sliding window inherently dynamic in sense"
                    },
                    {
                        "username": "Casardo",
                        "content": "shouldnt it be easy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not unless you are familiar with the sliding window approach."
                    },
                    {
                        "username": "jekatigr",
                        "content": "Pattern broken!\\n\\neasy-easy-easy-medium-~hard~-hard-hard"
                    },
                    {
                        "username": "partTime",
                        "content": "why this gives TLE\n\nbool isvowel(char ch){\n     return ch=='a' || ch=='e' || ch == 'i' || ch =='o'|| ch== 'u';\n }\n    int maxVowels(string s, int k) {\n        queue<char>q;\n     int count = 0;\n        //process first k size window\n        for(int i= 0;i<k;i++){\n            if(isvowel(s[i])){\n                count++;\n            }       \n         q.push(s[i]);\n        }\n          int maxi =INT_MIN;\n          maxi = max(maxi,count);\n          count = 0;\n          for(int i = k;i<s.length();i++){\n               q.pop();\n               q.push(s[i]);\n               int k1 = k;\n             while(!q.empty() and k--){\n               char ch = q.front();\n               if(isvowel(ch)){\n                   count++;\n               }\n               q.pop();\n               q.push(ch); \n           }\n           k = k1;\n           maxi = max(maxi,count);\n           count = 0;\n\n          }       \n         // process\n\nreturn maxi;\n    }\n}; \n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "C#: I think I wrote really optimized code but I have Time Limit Exceeded. Passed 99/106. Any help appreciated.\\n```    \\n    public int MaxVowels(string s, int k) {\\n        int max = 0;\\n        int curr = 0;\\n        Func<char, int> vowels = c=>(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')?1:0;\\n \\n        for (int i = 0; i < k; ++i) {\\n            curr+=vowels(s[i]);\\n        }\\n        max = curr;\\n        \\n        for (int i = k; i < s.Count(); ++i) {\\n           curr+=vowels(s[i]);\\n           curr-=vowels(s[i-k]);\\n           if (curr>max) max=curr;\\n        }\\n        return max;\\n    }\\n```"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Ok I found it. Apparently .Count() takes much longer that .Length.\\nThat was it. Crazy."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "should be Easy instead of Medium"
                    },
                    {
                        "username": "parth33998",
                        "content": "class Solution {\\n\\n    public boolean isVowel(Character ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maxVowels(String s, int k) {\\n\\n        int i=0; \\n        int j=0;\\n\\n        int max=0;\\n        int count=0;\\n\\n        while(j<s.length())\\n        {\\n                if(isVowel(s.charAt(j)))\\n                count++;\\n        }\\n        while(j-i+1>k)\\n        {\\n            if(isVowel(s.charAt(i)))\\n            \\n                count--;\\n                i++;\\n                j++;\\n            \\n        }\\n        max= Math.max(count,max);\\n        j++;\\n\\n\\n        return max;\\n        \\n    }\\n}\\n\\n\\n\\nIts showing TLE ......\\n\\nAnyone ? correct me where i went wrong. "
                    },
                    {
                        "username": "Jobababa",
                        "content": "Can you describe more about what you want to do with both while-loops?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I thought I\\'m the only one who thinks that this problem is too easy. But we are just getting better so keep it up cheers to all leetcoders\\uD83C\\uDF7B"
                    },
                    {
                        "username": "cycv5",
                        "content": "This one is an easy question but on the harder end. \\nSimilar to [643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/description/)"
                    }
                ]
            },
            {
                "id": 1998952,
                "content": [
                    {
                        "username": "gadmo",
                        "content": "level is clearly not medium "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "is it possible to do with dynamic programming if the given s.length is only 10^4"
                    },
                    {
                        "username": "namandt",
                        "content": "sliding window inherently dynamic in sense"
                    },
                    {
                        "username": "Casardo",
                        "content": "shouldnt it be easy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not unless you are familiar with the sliding window approach."
                    },
                    {
                        "username": "jekatigr",
                        "content": "Pattern broken!\\n\\neasy-easy-easy-medium-~hard~-hard-hard"
                    },
                    {
                        "username": "partTime",
                        "content": "why this gives TLE\n\nbool isvowel(char ch){\n     return ch=='a' || ch=='e' || ch == 'i' || ch =='o'|| ch== 'u';\n }\n    int maxVowels(string s, int k) {\n        queue<char>q;\n     int count = 0;\n        //process first k size window\n        for(int i= 0;i<k;i++){\n            if(isvowel(s[i])){\n                count++;\n            }       \n         q.push(s[i]);\n        }\n          int maxi =INT_MIN;\n          maxi = max(maxi,count);\n          count = 0;\n          for(int i = k;i<s.length();i++){\n               q.pop();\n               q.push(s[i]);\n               int k1 = k;\n             while(!q.empty() and k--){\n               char ch = q.front();\n               if(isvowel(ch)){\n                   count++;\n               }\n               q.pop();\n               q.push(ch); \n           }\n           k = k1;\n           maxi = max(maxi,count);\n           count = 0;\n\n          }       \n         // process\n\nreturn maxi;\n    }\n}; \n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "C#: I think I wrote really optimized code but I have Time Limit Exceeded. Passed 99/106. Any help appreciated.\\n```    \\n    public int MaxVowels(string s, int k) {\\n        int max = 0;\\n        int curr = 0;\\n        Func<char, int> vowels = c=>(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')?1:0;\\n \\n        for (int i = 0; i < k; ++i) {\\n            curr+=vowels(s[i]);\\n        }\\n        max = curr;\\n        \\n        for (int i = k; i < s.Count(); ++i) {\\n           curr+=vowels(s[i]);\\n           curr-=vowels(s[i-k]);\\n           if (curr>max) max=curr;\\n        }\\n        return max;\\n    }\\n```"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Ok I found it. Apparently .Count() takes much longer that .Length.\\nThat was it. Crazy."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "should be Easy instead of Medium"
                    },
                    {
                        "username": "parth33998",
                        "content": "class Solution {\\n\\n    public boolean isVowel(Character ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maxVowels(String s, int k) {\\n\\n        int i=0; \\n        int j=0;\\n\\n        int max=0;\\n        int count=0;\\n\\n        while(j<s.length())\\n        {\\n                if(isVowel(s.charAt(j)))\\n                count++;\\n        }\\n        while(j-i+1>k)\\n        {\\n            if(isVowel(s.charAt(i)))\\n            \\n                count--;\\n                i++;\\n                j++;\\n            \\n        }\\n        max= Math.max(count,max);\\n        j++;\\n\\n\\n        return max;\\n        \\n    }\\n}\\n\\n\\n\\nIts showing TLE ......\\n\\nAnyone ? correct me where i went wrong. "
                    },
                    {
                        "username": "Jobababa",
                        "content": "Can you describe more about what you want to do with both while-loops?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I thought I\\'m the only one who thinks that this problem is too easy. But we are just getting better so keep it up cheers to all leetcoders\\uD83C\\uDF7B"
                    },
                    {
                        "username": "cycv5",
                        "content": "This one is an easy question but on the harder end. \\nSimilar to [643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/description/)"
                    }
                ]
            },
            {
                "id": 1994248,
                "content": [
                    {
                        "username": "gadmo",
                        "content": "level is clearly not medium "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "is it possible to do with dynamic programming if the given s.length is only 10^4"
                    },
                    {
                        "username": "namandt",
                        "content": "sliding window inherently dynamic in sense"
                    },
                    {
                        "username": "Casardo",
                        "content": "shouldnt it be easy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not unless you are familiar with the sliding window approach."
                    },
                    {
                        "username": "jekatigr",
                        "content": "Pattern broken!\\n\\neasy-easy-easy-medium-~hard~-hard-hard"
                    },
                    {
                        "username": "partTime",
                        "content": "why this gives TLE\n\nbool isvowel(char ch){\n     return ch=='a' || ch=='e' || ch == 'i' || ch =='o'|| ch== 'u';\n }\n    int maxVowels(string s, int k) {\n        queue<char>q;\n     int count = 0;\n        //process first k size window\n        for(int i= 0;i<k;i++){\n            if(isvowel(s[i])){\n                count++;\n            }       \n         q.push(s[i]);\n        }\n          int maxi =INT_MIN;\n          maxi = max(maxi,count);\n          count = 0;\n          for(int i = k;i<s.length();i++){\n               q.pop();\n               q.push(s[i]);\n               int k1 = k;\n             while(!q.empty() and k--){\n               char ch = q.front();\n               if(isvowel(ch)){\n                   count++;\n               }\n               q.pop();\n               q.push(ch); \n           }\n           k = k1;\n           maxi = max(maxi,count);\n           count = 0;\n\n          }       \n         // process\n\nreturn maxi;\n    }\n}; \n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "C#: I think I wrote really optimized code but I have Time Limit Exceeded. Passed 99/106. Any help appreciated.\\n```    \\n    public int MaxVowels(string s, int k) {\\n        int max = 0;\\n        int curr = 0;\\n        Func<char, int> vowels = c=>(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')?1:0;\\n \\n        for (int i = 0; i < k; ++i) {\\n            curr+=vowels(s[i]);\\n        }\\n        max = curr;\\n        \\n        for (int i = k; i < s.Count(); ++i) {\\n           curr+=vowels(s[i]);\\n           curr-=vowels(s[i-k]);\\n           if (curr>max) max=curr;\\n        }\\n        return max;\\n    }\\n```"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Ok I found it. Apparently .Count() takes much longer that .Length.\\nThat was it. Crazy."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "should be Easy instead of Medium"
                    },
                    {
                        "username": "parth33998",
                        "content": "class Solution {\\n\\n    public boolean isVowel(Character ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maxVowels(String s, int k) {\\n\\n        int i=0; \\n        int j=0;\\n\\n        int max=0;\\n        int count=0;\\n\\n        while(j<s.length())\\n        {\\n                if(isVowel(s.charAt(j)))\\n                count++;\\n        }\\n        while(j-i+1>k)\\n        {\\n            if(isVowel(s.charAt(i)))\\n            \\n                count--;\\n                i++;\\n                j++;\\n            \\n        }\\n        max= Math.max(count,max);\\n        j++;\\n\\n\\n        return max;\\n        \\n    }\\n}\\n\\n\\n\\nIts showing TLE ......\\n\\nAnyone ? correct me where i went wrong. "
                    },
                    {
                        "username": "Jobababa",
                        "content": "Can you describe more about what you want to do with both while-loops?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I thought I\\'m the only one who thinks that this problem is too easy. But we are just getting better so keep it up cheers to all leetcoders\\uD83C\\uDF7B"
                    },
                    {
                        "username": "cycv5",
                        "content": "This one is an easy question but on the harder end. \\nSimilar to [643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/description/)"
                    }
                ]
            },
            {
                "id": 1987117,
                "content": [
                    {
                        "username": "gadmo",
                        "content": "level is clearly not medium "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "is it possible to do with dynamic programming if the given s.length is only 10^4"
                    },
                    {
                        "username": "namandt",
                        "content": "sliding window inherently dynamic in sense"
                    },
                    {
                        "username": "Casardo",
                        "content": "shouldnt it be easy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not unless you are familiar with the sliding window approach."
                    },
                    {
                        "username": "jekatigr",
                        "content": "Pattern broken!\\n\\neasy-easy-easy-medium-~hard~-hard-hard"
                    },
                    {
                        "username": "partTime",
                        "content": "why this gives TLE\n\nbool isvowel(char ch){\n     return ch=='a' || ch=='e' || ch == 'i' || ch =='o'|| ch== 'u';\n }\n    int maxVowels(string s, int k) {\n        queue<char>q;\n     int count = 0;\n        //process first k size window\n        for(int i= 0;i<k;i++){\n            if(isvowel(s[i])){\n                count++;\n            }       \n         q.push(s[i]);\n        }\n          int maxi =INT_MIN;\n          maxi = max(maxi,count);\n          count = 0;\n          for(int i = k;i<s.length();i++){\n               q.pop();\n               q.push(s[i]);\n               int k1 = k;\n             while(!q.empty() and k--){\n               char ch = q.front();\n               if(isvowel(ch)){\n                   count++;\n               }\n               q.pop();\n               q.push(ch); \n           }\n           k = k1;\n           maxi = max(maxi,count);\n           count = 0;\n\n          }       \n         // process\n\nreturn maxi;\n    }\n}; \n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "C#: I think I wrote really optimized code but I have Time Limit Exceeded. Passed 99/106. Any help appreciated.\\n```    \\n    public int MaxVowels(string s, int k) {\\n        int max = 0;\\n        int curr = 0;\\n        Func<char, int> vowels = c=>(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')?1:0;\\n \\n        for (int i = 0; i < k; ++i) {\\n            curr+=vowels(s[i]);\\n        }\\n        max = curr;\\n        \\n        for (int i = k; i < s.Count(); ++i) {\\n           curr+=vowels(s[i]);\\n           curr-=vowels(s[i-k]);\\n           if (curr>max) max=curr;\\n        }\\n        return max;\\n    }\\n```"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Ok I found it. Apparently .Count() takes much longer that .Length.\\nThat was it. Crazy."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "should be Easy instead of Medium"
                    },
                    {
                        "username": "parth33998",
                        "content": "class Solution {\\n\\n    public boolean isVowel(Character ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maxVowels(String s, int k) {\\n\\n        int i=0; \\n        int j=0;\\n\\n        int max=0;\\n        int count=0;\\n\\n        while(j<s.length())\\n        {\\n                if(isVowel(s.charAt(j)))\\n                count++;\\n        }\\n        while(j-i+1>k)\\n        {\\n            if(isVowel(s.charAt(i)))\\n            \\n                count--;\\n                i++;\\n                j++;\\n            \\n        }\\n        max= Math.max(count,max);\\n        j++;\\n\\n\\n        return max;\\n        \\n    }\\n}\\n\\n\\n\\nIts showing TLE ......\\n\\nAnyone ? correct me where i went wrong. "
                    },
                    {
                        "username": "Jobababa",
                        "content": "Can you describe more about what you want to do with both while-loops?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I thought I\\'m the only one who thinks that this problem is too easy. But we are just getting better so keep it up cheers to all leetcoders\\uD83C\\uDF7B"
                    },
                    {
                        "username": "cycv5",
                        "content": "This one is an easy question but on the harder end. \\nSimilar to [643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/description/)"
                    }
                ]
            },
            {
                "id": 1947305,
                "content": [
                    {
                        "username": "gadmo",
                        "content": "level is clearly not medium "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "is it possible to do with dynamic programming if the given s.length is only 10^4"
                    },
                    {
                        "username": "namandt",
                        "content": "sliding window inherently dynamic in sense"
                    },
                    {
                        "username": "Casardo",
                        "content": "shouldnt it be easy?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not unless you are familiar with the sliding window approach."
                    },
                    {
                        "username": "jekatigr",
                        "content": "Pattern broken!\\n\\neasy-easy-easy-medium-~hard~-hard-hard"
                    },
                    {
                        "username": "partTime",
                        "content": "why this gives TLE\n\nbool isvowel(char ch){\n     return ch=='a' || ch=='e' || ch == 'i' || ch =='o'|| ch== 'u';\n }\n    int maxVowels(string s, int k) {\n        queue<char>q;\n     int count = 0;\n        //process first k size window\n        for(int i= 0;i<k;i++){\n            if(isvowel(s[i])){\n                count++;\n            }       \n         q.push(s[i]);\n        }\n          int maxi =INT_MIN;\n          maxi = max(maxi,count);\n          count = 0;\n          for(int i = k;i<s.length();i++){\n               q.pop();\n               q.push(s[i]);\n               int k1 = k;\n             while(!q.empty() and k--){\n               char ch = q.front();\n               if(isvowel(ch)){\n                   count++;\n               }\n               q.pop();\n               q.push(ch); \n           }\n           k = k1;\n           maxi = max(maxi,count);\n           count = 0;\n\n          }       \n         // process\n\nreturn maxi;\n    }\n}; \n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "C#: I think I wrote really optimized code but I have Time Limit Exceeded. Passed 99/106. Any help appreciated.\\n```    \\n    public int MaxVowels(string s, int k) {\\n        int max = 0;\\n        int curr = 0;\\n        Func<char, int> vowels = c=>(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')?1:0;\\n \\n        for (int i = 0; i < k; ++i) {\\n            curr+=vowels(s[i]);\\n        }\\n        max = curr;\\n        \\n        for (int i = k; i < s.Count(); ++i) {\\n           curr+=vowels(s[i]);\\n           curr-=vowels(s[i-k]);\\n           if (curr>max) max=curr;\\n        }\\n        return max;\\n    }\\n```"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Ok I found it. Apparently .Count() takes much longer that .Length.\\nThat was it. Crazy."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "should be Easy instead of Medium"
                    },
                    {
                        "username": "parth33998",
                        "content": "class Solution {\\n\\n    public boolean isVowel(Character ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maxVowels(String s, int k) {\\n\\n        int i=0; \\n        int j=0;\\n\\n        int max=0;\\n        int count=0;\\n\\n        while(j<s.length())\\n        {\\n                if(isVowel(s.charAt(j)))\\n                count++;\\n        }\\n        while(j-i+1>k)\\n        {\\n            if(isVowel(s.charAt(i)))\\n            \\n                count--;\\n                i++;\\n                j++;\\n            \\n        }\\n        max= Math.max(count,max);\\n        j++;\\n\\n\\n        return max;\\n        \\n    }\\n}\\n\\n\\n\\nIts showing TLE ......\\n\\nAnyone ? correct me where i went wrong. "
                    },
                    {
                        "username": "Jobababa",
                        "content": "Can you describe more about what you want to do with both while-loops?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I thought I\\'m the only one who thinks that this problem is too easy. But we are just getting better so keep it up cheers to all leetcoders\\uD83C\\uDF7B"
                    },
                    {
                        "username": "cycv5",
                        "content": "This one is an easy question but on the harder end. \\nSimilar to [643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/description/)"
                    }
                ]
            },
            {
                "id": 1931673,
                "content": [
                    {
                        "username": "Shashank2707",
                        "content": "C++ Simple and real optimized solution Time complexity O(n) and Space complexity O(1). Without using any extra space. \\n\\n\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n        return true;\\n       return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        \\n        int count = 0,maxcount = 0;\\n        for(int i=0;i<k;i++)\\n        {\\n           if(isVowel(s[i]))\\n           count++;\\n        }\\n        maxcount = count;\\n\\n        for(int i=0;i<s.length() - k; i++)\\n        {\\n            if(!isVowel(s[i]) && isVowel(s[i+k]))\\n            {\\n                count = count + 1;\\n            }\\n            else if(isVowel(s[i]) && !isVowel(s[i+k]))\\n            {\\n                count = count - 1;\\n            }\\n            else{\\n                \\n                count = count;\\n            }\\n            maxcount = max(maxcount,count);\\n        }\\n        return maxcount;\\n    }\\n};\\n"
                    },
                    {
                        "username": "TeoMeo",
                        "content": "Finally got a medium with no hints"
                    },
                    {
                        "username": "sainath81061",
                        "content": "//using program in c#...\\npublic class Solution {\\n    public int MaxVowels(string s, int k) {\\n        int i,count=0,max=0;\\n\\n       for(i=0;i< s.Length;i++){\\n           count = count + IsVowel(s[i]);\\n           if(i >= k){\\n               count = count - IsVowel(s[i - k]);               \\n           }\\n           max = Math.Max(max , count);\\n       }\\n       return max;\\n    }\\n    public int IsVowel(char ch){\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rahpuser",
                        "content": "Somebody knows why the \"beats %\" change if I just resubmit the same code.. it changes kind of randomly, somethings go up and sometimes go down, I don\\'t think that a lot of people is pushing new versions, I suspect that the run is not fully isolated or regular each time.. anybody knows ? I\\'m starting to think that that metrics is worthless.. do you know a tool that calculate big O notation based on code ? "
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "Standard problem of fixed sized sliding window ,\ntraverse , if finding  vowels maintain the count .\nmain observation is what would you do with count when window size is exceeded .\ngood problem for practice \n"
                    },
                    {
                        "username": "macrescu",
                        "content": "I just do not get how can I get pass the 102nd (from 106) test at which it says the time limit exceeded. I use only one for loop."
                    },
                    {
                        "username": "StopNGo",
                        "content": "Probably you are using some standard search/match function that of course has its own loops"
                    },
                    {
                        "username": "RDX0160",
                        "content": "I\\'m getting a runtime error, but the code runs on my IDE?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Any Idea why I am getting this error ?\\n`process exited with Signal SIGSEGV` \\n"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "I\\'ll concur that I\\'m surprised this is in the Medium category, but judging from a lot of comments in the discussion it may just be that for a lot of us we might be particularly good at sliding window problems.  I am always happy when I see them come up as Mediums.\\n\\nFor those that are struggling, don\\'t forget you need to update two values as you slide over the word, not one."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Is it just me or anyone else getting crash report while adding more test case using the source ?"
                    }
                ]
            },
            {
                "id": 1928898,
                "content": [
                    {
                        "username": "Shashank2707",
                        "content": "C++ Simple and real optimized solution Time complexity O(n) and Space complexity O(1). Without using any extra space. \\n\\n\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n        return true;\\n       return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        \\n        int count = 0,maxcount = 0;\\n        for(int i=0;i<k;i++)\\n        {\\n           if(isVowel(s[i]))\\n           count++;\\n        }\\n        maxcount = count;\\n\\n        for(int i=0;i<s.length() - k; i++)\\n        {\\n            if(!isVowel(s[i]) && isVowel(s[i+k]))\\n            {\\n                count = count + 1;\\n            }\\n            else if(isVowel(s[i]) && !isVowel(s[i+k]))\\n            {\\n                count = count - 1;\\n            }\\n            else{\\n                \\n                count = count;\\n            }\\n            maxcount = max(maxcount,count);\\n        }\\n        return maxcount;\\n    }\\n};\\n"
                    },
                    {
                        "username": "TeoMeo",
                        "content": "Finally got a medium with no hints"
                    },
                    {
                        "username": "sainath81061",
                        "content": "//using program in c#...\\npublic class Solution {\\n    public int MaxVowels(string s, int k) {\\n        int i,count=0,max=0;\\n\\n       for(i=0;i< s.Length;i++){\\n           count = count + IsVowel(s[i]);\\n           if(i >= k){\\n               count = count - IsVowel(s[i - k]);               \\n           }\\n           max = Math.Max(max , count);\\n       }\\n       return max;\\n    }\\n    public int IsVowel(char ch){\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rahpuser",
                        "content": "Somebody knows why the \"beats %\" change if I just resubmit the same code.. it changes kind of randomly, somethings go up and sometimes go down, I don\\'t think that a lot of people is pushing new versions, I suspect that the run is not fully isolated or regular each time.. anybody knows ? I\\'m starting to think that that metrics is worthless.. do you know a tool that calculate big O notation based on code ? "
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "Standard problem of fixed sized sliding window ,\ntraverse , if finding  vowels maintain the count .\nmain observation is what would you do with count when window size is exceeded .\ngood problem for practice \n"
                    },
                    {
                        "username": "macrescu",
                        "content": "I just do not get how can I get pass the 102nd (from 106) test at which it says the time limit exceeded. I use only one for loop."
                    },
                    {
                        "username": "StopNGo",
                        "content": "Probably you are using some standard search/match function that of course has its own loops"
                    },
                    {
                        "username": "RDX0160",
                        "content": "I\\'m getting a runtime error, but the code runs on my IDE?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Any Idea why I am getting this error ?\\n`process exited with Signal SIGSEGV` \\n"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "I\\'ll concur that I\\'m surprised this is in the Medium category, but judging from a lot of comments in the discussion it may just be that for a lot of us we might be particularly good at sliding window problems.  I am always happy when I see them come up as Mediums.\\n\\nFor those that are struggling, don\\'t forget you need to update two values as you slide over the word, not one."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Is it just me or anyone else getting crash report while adding more test case using the source ?"
                    }
                ]
            },
            {
                "id": 1899979,
                "content": [
                    {
                        "username": "Shashank2707",
                        "content": "C++ Simple and real optimized solution Time complexity O(n) and Space complexity O(1). Without using any extra space. \\n\\n\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n        return true;\\n       return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        \\n        int count = 0,maxcount = 0;\\n        for(int i=0;i<k;i++)\\n        {\\n           if(isVowel(s[i]))\\n           count++;\\n        }\\n        maxcount = count;\\n\\n        for(int i=0;i<s.length() - k; i++)\\n        {\\n            if(!isVowel(s[i]) && isVowel(s[i+k]))\\n            {\\n                count = count + 1;\\n            }\\n            else if(isVowel(s[i]) && !isVowel(s[i+k]))\\n            {\\n                count = count - 1;\\n            }\\n            else{\\n                \\n                count = count;\\n            }\\n            maxcount = max(maxcount,count);\\n        }\\n        return maxcount;\\n    }\\n};\\n"
                    },
                    {
                        "username": "TeoMeo",
                        "content": "Finally got a medium with no hints"
                    },
                    {
                        "username": "sainath81061",
                        "content": "//using program in c#...\\npublic class Solution {\\n    public int MaxVowels(string s, int k) {\\n        int i,count=0,max=0;\\n\\n       for(i=0;i< s.Length;i++){\\n           count = count + IsVowel(s[i]);\\n           if(i >= k){\\n               count = count - IsVowel(s[i - k]);               \\n           }\\n           max = Math.Max(max , count);\\n       }\\n       return max;\\n    }\\n    public int IsVowel(char ch){\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rahpuser",
                        "content": "Somebody knows why the \"beats %\" change if I just resubmit the same code.. it changes kind of randomly, somethings go up and sometimes go down, I don\\'t think that a lot of people is pushing new versions, I suspect that the run is not fully isolated or regular each time.. anybody knows ? I\\'m starting to think that that metrics is worthless.. do you know a tool that calculate big O notation based on code ? "
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "Standard problem of fixed sized sliding window ,\ntraverse , if finding  vowels maintain the count .\nmain observation is what would you do with count when window size is exceeded .\ngood problem for practice \n"
                    },
                    {
                        "username": "macrescu",
                        "content": "I just do not get how can I get pass the 102nd (from 106) test at which it says the time limit exceeded. I use only one for loop."
                    },
                    {
                        "username": "StopNGo",
                        "content": "Probably you are using some standard search/match function that of course has its own loops"
                    },
                    {
                        "username": "RDX0160",
                        "content": "I\\'m getting a runtime error, but the code runs on my IDE?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Any Idea why I am getting this error ?\\n`process exited with Signal SIGSEGV` \\n"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "I\\'ll concur that I\\'m surprised this is in the Medium category, but judging from a lot of comments in the discussion it may just be that for a lot of us we might be particularly good at sliding window problems.  I am always happy when I see them come up as Mediums.\\n\\nFor those that are struggling, don\\'t forget you need to update two values as you slide over the word, not one."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Is it just me or anyone else getting crash report while adding more test case using the source ?"
                    }
                ]
            },
            {
                "id": 1884040,
                "content": [
                    {
                        "username": "Shashank2707",
                        "content": "C++ Simple and real optimized solution Time complexity O(n) and Space complexity O(1). Without using any extra space. \\n\\n\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n        return true;\\n       return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        \\n        int count = 0,maxcount = 0;\\n        for(int i=0;i<k;i++)\\n        {\\n           if(isVowel(s[i]))\\n           count++;\\n        }\\n        maxcount = count;\\n\\n        for(int i=0;i<s.length() - k; i++)\\n        {\\n            if(!isVowel(s[i]) && isVowel(s[i+k]))\\n            {\\n                count = count + 1;\\n            }\\n            else if(isVowel(s[i]) && !isVowel(s[i+k]))\\n            {\\n                count = count - 1;\\n            }\\n            else{\\n                \\n                count = count;\\n            }\\n            maxcount = max(maxcount,count);\\n        }\\n        return maxcount;\\n    }\\n};\\n"
                    },
                    {
                        "username": "TeoMeo",
                        "content": "Finally got a medium with no hints"
                    },
                    {
                        "username": "sainath81061",
                        "content": "//using program in c#...\\npublic class Solution {\\n    public int MaxVowels(string s, int k) {\\n        int i,count=0,max=0;\\n\\n       for(i=0;i< s.Length;i++){\\n           count = count + IsVowel(s[i]);\\n           if(i >= k){\\n               count = count - IsVowel(s[i - k]);               \\n           }\\n           max = Math.Max(max , count);\\n       }\\n       return max;\\n    }\\n    public int IsVowel(char ch){\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rahpuser",
                        "content": "Somebody knows why the \"beats %\" change if I just resubmit the same code.. it changes kind of randomly, somethings go up and sometimes go down, I don\\'t think that a lot of people is pushing new versions, I suspect that the run is not fully isolated or regular each time.. anybody knows ? I\\'m starting to think that that metrics is worthless.. do you know a tool that calculate big O notation based on code ? "
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "Standard problem of fixed sized sliding window ,\ntraverse , if finding  vowels maintain the count .\nmain observation is what would you do with count when window size is exceeded .\ngood problem for practice \n"
                    },
                    {
                        "username": "macrescu",
                        "content": "I just do not get how can I get pass the 102nd (from 106) test at which it says the time limit exceeded. I use only one for loop."
                    },
                    {
                        "username": "StopNGo",
                        "content": "Probably you are using some standard search/match function that of course has its own loops"
                    },
                    {
                        "username": "RDX0160",
                        "content": "I\\'m getting a runtime error, but the code runs on my IDE?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Any Idea why I am getting this error ?\\n`process exited with Signal SIGSEGV` \\n"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "I\\'ll concur that I\\'m surprised this is in the Medium category, but judging from a lot of comments in the discussion it may just be that for a lot of us we might be particularly good at sliding window problems.  I am always happy when I see them come up as Mediums.\\n\\nFor those that are struggling, don\\'t forget you need to update two values as you slide over the word, not one."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Is it just me or anyone else getting crash report while adding more test case using the source ?"
                    }
                ]
            },
            {
                "id": 1883991,
                "content": [
                    {
                        "username": "Shashank2707",
                        "content": "C++ Simple and real optimized solution Time complexity O(n) and Space complexity O(1). Without using any extra space. \\n\\n\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n        return true;\\n       return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        \\n        int count = 0,maxcount = 0;\\n        for(int i=0;i<k;i++)\\n        {\\n           if(isVowel(s[i]))\\n           count++;\\n        }\\n        maxcount = count;\\n\\n        for(int i=0;i<s.length() - k; i++)\\n        {\\n            if(!isVowel(s[i]) && isVowel(s[i+k]))\\n            {\\n                count = count + 1;\\n            }\\n            else if(isVowel(s[i]) && !isVowel(s[i+k]))\\n            {\\n                count = count - 1;\\n            }\\n            else{\\n                \\n                count = count;\\n            }\\n            maxcount = max(maxcount,count);\\n        }\\n        return maxcount;\\n    }\\n};\\n"
                    },
                    {
                        "username": "TeoMeo",
                        "content": "Finally got a medium with no hints"
                    },
                    {
                        "username": "sainath81061",
                        "content": "//using program in c#...\\npublic class Solution {\\n    public int MaxVowels(string s, int k) {\\n        int i,count=0,max=0;\\n\\n       for(i=0;i< s.Length;i++){\\n           count = count + IsVowel(s[i]);\\n           if(i >= k){\\n               count = count - IsVowel(s[i - k]);               \\n           }\\n           max = Math.Max(max , count);\\n       }\\n       return max;\\n    }\\n    public int IsVowel(char ch){\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rahpuser",
                        "content": "Somebody knows why the \"beats %\" change if I just resubmit the same code.. it changes kind of randomly, somethings go up and sometimes go down, I don\\'t think that a lot of people is pushing new versions, I suspect that the run is not fully isolated or regular each time.. anybody knows ? I\\'m starting to think that that metrics is worthless.. do you know a tool that calculate big O notation based on code ? "
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "Standard problem of fixed sized sliding window ,\ntraverse , if finding  vowels maintain the count .\nmain observation is what would you do with count when window size is exceeded .\ngood problem for practice \n"
                    },
                    {
                        "username": "macrescu",
                        "content": "I just do not get how can I get pass the 102nd (from 106) test at which it says the time limit exceeded. I use only one for loop."
                    },
                    {
                        "username": "StopNGo",
                        "content": "Probably you are using some standard search/match function that of course has its own loops"
                    },
                    {
                        "username": "RDX0160",
                        "content": "I\\'m getting a runtime error, but the code runs on my IDE?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Any Idea why I am getting this error ?\\n`process exited with Signal SIGSEGV` \\n"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "I\\'ll concur that I\\'m surprised this is in the Medium category, but judging from a lot of comments in the discussion it may just be that for a lot of us we might be particularly good at sliding window problems.  I am always happy when I see them come up as Mediums.\\n\\nFor those that are struggling, don\\'t forget you need to update two values as you slide over the word, not one."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Is it just me or anyone else getting crash report while adding more test case using the source ?"
                    }
                ]
            },
            {
                "id": 1883956,
                "content": [
                    {
                        "username": "Shashank2707",
                        "content": "C++ Simple and real optimized solution Time complexity O(n) and Space complexity O(1). Without using any extra space. \\n\\n\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n        return true;\\n       return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        \\n        int count = 0,maxcount = 0;\\n        for(int i=0;i<k;i++)\\n        {\\n           if(isVowel(s[i]))\\n           count++;\\n        }\\n        maxcount = count;\\n\\n        for(int i=0;i<s.length() - k; i++)\\n        {\\n            if(!isVowel(s[i]) && isVowel(s[i+k]))\\n            {\\n                count = count + 1;\\n            }\\n            else if(isVowel(s[i]) && !isVowel(s[i+k]))\\n            {\\n                count = count - 1;\\n            }\\n            else{\\n                \\n                count = count;\\n            }\\n            maxcount = max(maxcount,count);\\n        }\\n        return maxcount;\\n    }\\n};\\n"
                    },
                    {
                        "username": "TeoMeo",
                        "content": "Finally got a medium with no hints"
                    },
                    {
                        "username": "sainath81061",
                        "content": "//using program in c#...\\npublic class Solution {\\n    public int MaxVowels(string s, int k) {\\n        int i,count=0,max=0;\\n\\n       for(i=0;i< s.Length;i++){\\n           count = count + IsVowel(s[i]);\\n           if(i >= k){\\n               count = count - IsVowel(s[i - k]);               \\n           }\\n           max = Math.Max(max , count);\\n       }\\n       return max;\\n    }\\n    public int IsVowel(char ch){\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rahpuser",
                        "content": "Somebody knows why the \"beats %\" change if I just resubmit the same code.. it changes kind of randomly, somethings go up and sometimes go down, I don\\'t think that a lot of people is pushing new versions, I suspect that the run is not fully isolated or regular each time.. anybody knows ? I\\'m starting to think that that metrics is worthless.. do you know a tool that calculate big O notation based on code ? "
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "Standard problem of fixed sized sliding window ,\ntraverse , if finding  vowels maintain the count .\nmain observation is what would you do with count when window size is exceeded .\ngood problem for practice \n"
                    },
                    {
                        "username": "macrescu",
                        "content": "I just do not get how can I get pass the 102nd (from 106) test at which it says the time limit exceeded. I use only one for loop."
                    },
                    {
                        "username": "StopNGo",
                        "content": "Probably you are using some standard search/match function that of course has its own loops"
                    },
                    {
                        "username": "RDX0160",
                        "content": "I\\'m getting a runtime error, but the code runs on my IDE?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Any Idea why I am getting this error ?\\n`process exited with Signal SIGSEGV` \\n"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "I\\'ll concur that I\\'m surprised this is in the Medium category, but judging from a lot of comments in the discussion it may just be that for a lot of us we might be particularly good at sliding window problems.  I am always happy when I see them come up as Mediums.\\n\\nFor those that are struggling, don\\'t forget you need to update two values as you slide over the word, not one."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Is it just me or anyone else getting crash report while adding more test case using the source ?"
                    }
                ]
            },
            {
                "id": 1883896,
                "content": [
                    {
                        "username": "Shashank2707",
                        "content": "C++ Simple and real optimized solution Time complexity O(n) and Space complexity O(1). Without using any extra space. \\n\\n\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n        return true;\\n       return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        \\n        int count = 0,maxcount = 0;\\n        for(int i=0;i<k;i++)\\n        {\\n           if(isVowel(s[i]))\\n           count++;\\n        }\\n        maxcount = count;\\n\\n        for(int i=0;i<s.length() - k; i++)\\n        {\\n            if(!isVowel(s[i]) && isVowel(s[i+k]))\\n            {\\n                count = count + 1;\\n            }\\n            else if(isVowel(s[i]) && !isVowel(s[i+k]))\\n            {\\n                count = count - 1;\\n            }\\n            else{\\n                \\n                count = count;\\n            }\\n            maxcount = max(maxcount,count);\\n        }\\n        return maxcount;\\n    }\\n};\\n"
                    },
                    {
                        "username": "TeoMeo",
                        "content": "Finally got a medium with no hints"
                    },
                    {
                        "username": "sainath81061",
                        "content": "//using program in c#...\\npublic class Solution {\\n    public int MaxVowels(string s, int k) {\\n        int i,count=0,max=0;\\n\\n       for(i=0;i< s.Length;i++){\\n           count = count + IsVowel(s[i]);\\n           if(i >= k){\\n               count = count - IsVowel(s[i - k]);               \\n           }\\n           max = Math.Max(max , count);\\n       }\\n       return max;\\n    }\\n    public int IsVowel(char ch){\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rahpuser",
                        "content": "Somebody knows why the \"beats %\" change if I just resubmit the same code.. it changes kind of randomly, somethings go up and sometimes go down, I don\\'t think that a lot of people is pushing new versions, I suspect that the run is not fully isolated or regular each time.. anybody knows ? I\\'m starting to think that that metrics is worthless.. do you know a tool that calculate big O notation based on code ? "
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "Standard problem of fixed sized sliding window ,\ntraverse , if finding  vowels maintain the count .\nmain observation is what would you do with count when window size is exceeded .\ngood problem for practice \n"
                    },
                    {
                        "username": "macrescu",
                        "content": "I just do not get how can I get pass the 102nd (from 106) test at which it says the time limit exceeded. I use only one for loop."
                    },
                    {
                        "username": "StopNGo",
                        "content": "Probably you are using some standard search/match function that of course has its own loops"
                    },
                    {
                        "username": "RDX0160",
                        "content": "I\\'m getting a runtime error, but the code runs on my IDE?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Any Idea why I am getting this error ?\\n`process exited with Signal SIGSEGV` \\n"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "I\\'ll concur that I\\'m surprised this is in the Medium category, but judging from a lot of comments in the discussion it may just be that for a lot of us we might be particularly good at sliding window problems.  I am always happy when I see them come up as Mediums.\\n\\nFor those that are struggling, don\\'t forget you need to update two values as you slide over the word, not one."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Is it just me or anyone else getting crash report while adding more test case using the source ?"
                    }
                ]
            },
            {
                "id": 1883880,
                "content": [
                    {
                        "username": "Shashank2707",
                        "content": "C++ Simple and real optimized solution Time complexity O(n) and Space complexity O(1). Without using any extra space. \\n\\n\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n        return true;\\n       return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        \\n        int count = 0,maxcount = 0;\\n        for(int i=0;i<k;i++)\\n        {\\n           if(isVowel(s[i]))\\n           count++;\\n        }\\n        maxcount = count;\\n\\n        for(int i=0;i<s.length() - k; i++)\\n        {\\n            if(!isVowel(s[i]) && isVowel(s[i+k]))\\n            {\\n                count = count + 1;\\n            }\\n            else if(isVowel(s[i]) && !isVowel(s[i+k]))\\n            {\\n                count = count - 1;\\n            }\\n            else{\\n                \\n                count = count;\\n            }\\n            maxcount = max(maxcount,count);\\n        }\\n        return maxcount;\\n    }\\n};\\n"
                    },
                    {
                        "username": "TeoMeo",
                        "content": "Finally got a medium with no hints"
                    },
                    {
                        "username": "sainath81061",
                        "content": "//using program in c#...\\npublic class Solution {\\n    public int MaxVowels(string s, int k) {\\n        int i,count=0,max=0;\\n\\n       for(i=0;i< s.Length;i++){\\n           count = count + IsVowel(s[i]);\\n           if(i >= k){\\n               count = count - IsVowel(s[i - k]);               \\n           }\\n           max = Math.Max(max , count);\\n       }\\n       return max;\\n    }\\n    public int IsVowel(char ch){\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rahpuser",
                        "content": "Somebody knows why the \"beats %\" change if I just resubmit the same code.. it changes kind of randomly, somethings go up and sometimes go down, I don\\'t think that a lot of people is pushing new versions, I suspect that the run is not fully isolated or regular each time.. anybody knows ? I\\'m starting to think that that metrics is worthless.. do you know a tool that calculate big O notation based on code ? "
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "Standard problem of fixed sized sliding window ,\ntraverse , if finding  vowels maintain the count .\nmain observation is what would you do with count when window size is exceeded .\ngood problem for practice \n"
                    },
                    {
                        "username": "macrescu",
                        "content": "I just do not get how can I get pass the 102nd (from 106) test at which it says the time limit exceeded. I use only one for loop."
                    },
                    {
                        "username": "StopNGo",
                        "content": "Probably you are using some standard search/match function that of course has its own loops"
                    },
                    {
                        "username": "RDX0160",
                        "content": "I\\'m getting a runtime error, but the code runs on my IDE?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Any Idea why I am getting this error ?\\n`process exited with Signal SIGSEGV` \\n"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "I\\'ll concur that I\\'m surprised this is in the Medium category, but judging from a lot of comments in the discussion it may just be that for a lot of us we might be particularly good at sliding window problems.  I am always happy when I see them come up as Mediums.\\n\\nFor those that are struggling, don\\'t forget you need to update two values as you slide over the word, not one."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Is it just me or anyone else getting crash report while adding more test case using the source ?"
                    }
                ]
            },
            {
                "id": 1883783,
                "content": [
                    {
                        "username": "Shashank2707",
                        "content": "C++ Simple and real optimized solution Time complexity O(n) and Space complexity O(1). Without using any extra space. \\n\\n\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n        return true;\\n       return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        \\n        int count = 0,maxcount = 0;\\n        for(int i=0;i<k;i++)\\n        {\\n           if(isVowel(s[i]))\\n           count++;\\n        }\\n        maxcount = count;\\n\\n        for(int i=0;i<s.length() - k; i++)\\n        {\\n            if(!isVowel(s[i]) && isVowel(s[i+k]))\\n            {\\n                count = count + 1;\\n            }\\n            else if(isVowel(s[i]) && !isVowel(s[i+k]))\\n            {\\n                count = count - 1;\\n            }\\n            else{\\n                \\n                count = count;\\n            }\\n            maxcount = max(maxcount,count);\\n        }\\n        return maxcount;\\n    }\\n};\\n"
                    },
                    {
                        "username": "TeoMeo",
                        "content": "Finally got a medium with no hints"
                    },
                    {
                        "username": "sainath81061",
                        "content": "//using program in c#...\\npublic class Solution {\\n    public int MaxVowels(string s, int k) {\\n        int i,count=0,max=0;\\n\\n       for(i=0;i< s.Length;i++){\\n           count = count + IsVowel(s[i]);\\n           if(i >= k){\\n               count = count - IsVowel(s[i - k]);               \\n           }\\n           max = Math.Max(max , count);\\n       }\\n       return max;\\n    }\\n    public int IsVowel(char ch){\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rahpuser",
                        "content": "Somebody knows why the \"beats %\" change if I just resubmit the same code.. it changes kind of randomly, somethings go up and sometimes go down, I don\\'t think that a lot of people is pushing new versions, I suspect that the run is not fully isolated or regular each time.. anybody knows ? I\\'m starting to think that that metrics is worthless.. do you know a tool that calculate big O notation based on code ? "
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "Standard problem of fixed sized sliding window ,\ntraverse , if finding  vowels maintain the count .\nmain observation is what would you do with count when window size is exceeded .\ngood problem for practice \n"
                    },
                    {
                        "username": "macrescu",
                        "content": "I just do not get how can I get pass the 102nd (from 106) test at which it says the time limit exceeded. I use only one for loop."
                    },
                    {
                        "username": "StopNGo",
                        "content": "Probably you are using some standard search/match function that of course has its own loops"
                    },
                    {
                        "username": "RDX0160",
                        "content": "I\\'m getting a runtime error, but the code runs on my IDE?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Any Idea why I am getting this error ?\\n`process exited with Signal SIGSEGV` \\n"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "I\\'ll concur that I\\'m surprised this is in the Medium category, but judging from a lot of comments in the discussion it may just be that for a lot of us we might be particularly good at sliding window problems.  I am always happy when I see them come up as Mediums.\\n\\nFor those that are struggling, don\\'t forget you need to update two values as you slide over the word, not one."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Is it just me or anyone else getting crash report while adding more test case using the source ?"
                    }
                ]
            },
            {
                "id": 1883640,
                "content": [
                    {
                        "username": "Shashank2707",
                        "content": "C++ Simple and real optimized solution Time complexity O(n) and Space complexity O(1). Without using any extra space. \\n\\n\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n        return true;\\n       return false;\\n    }\\n    int maxVowels(string s, int k) {\\n        \\n        int count = 0,maxcount = 0;\\n        for(int i=0;i<k;i++)\\n        {\\n           if(isVowel(s[i]))\\n           count++;\\n        }\\n        maxcount = count;\\n\\n        for(int i=0;i<s.length() - k; i++)\\n        {\\n            if(!isVowel(s[i]) && isVowel(s[i+k]))\\n            {\\n                count = count + 1;\\n            }\\n            else if(isVowel(s[i]) && !isVowel(s[i+k]))\\n            {\\n                count = count - 1;\\n            }\\n            else{\\n                \\n                count = count;\\n            }\\n            maxcount = max(maxcount,count);\\n        }\\n        return maxcount;\\n    }\\n};\\n"
                    },
                    {
                        "username": "TeoMeo",
                        "content": "Finally got a medium with no hints"
                    },
                    {
                        "username": "sainath81061",
                        "content": "//using program in c#...\\npublic class Solution {\\n    public int MaxVowels(string s, int k) {\\n        int i,count=0,max=0;\\n\\n       for(i=0;i< s.Length;i++){\\n           count = count + IsVowel(s[i]);\\n           if(i >= k){\\n               count = count - IsVowel(s[i - k]);               \\n           }\\n           max = Math.Max(max , count);\\n       }\\n       return max;\\n    }\\n    public int IsVowel(char ch){\\n        if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "rahpuser",
                        "content": "Somebody knows why the \"beats %\" change if I just resubmit the same code.. it changes kind of randomly, somethings go up and sometimes go down, I don\\'t think that a lot of people is pushing new versions, I suspect that the run is not fully isolated or regular each time.. anybody knows ? I\\'m starting to think that that metrics is worthless.. do you know a tool that calculate big O notation based on code ? "
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "Standard problem of fixed sized sliding window ,\ntraverse , if finding  vowels maintain the count .\nmain observation is what would you do with count when window size is exceeded .\ngood problem for practice \n"
                    },
                    {
                        "username": "macrescu",
                        "content": "I just do not get how can I get pass the 102nd (from 106) test at which it says the time limit exceeded. I use only one for loop."
                    },
                    {
                        "username": "StopNGo",
                        "content": "Probably you are using some standard search/match function that of course has its own loops"
                    },
                    {
                        "username": "RDX0160",
                        "content": "I\\'m getting a runtime error, but the code runs on my IDE?"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Any Idea why I am getting this error ?\\n`process exited with Signal SIGSEGV` \\n"
                    },
                    {
                        "username": "MrBeverage",
                        "content": "I\\'ll concur that I\\'m surprised this is in the Medium category, but judging from a lot of comments in the discussion it may just be that for a lot of us we might be particularly good at sliding window problems.  I am always happy when I see them come up as Mediums.\\n\\nFor those that are struggling, don\\'t forget you need to update two values as you slide over the word, not one."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Is it just me or anyone else getting crash report while adding more test case using the source ?"
                    }
                ]
            },
            {
                "id": 1883611,
                "content": [
                    {
                        "username": "juleshwar",
                        "content": "### Testcases I tested with\n```\n\"abciiidef\"\n3\n\"aeiou\"\n2\n\"leetcode\"\n3\n\"aeiuo\"\n5\n\"smaoortooo\"\n7\n\"ooookaushdikuashas\"\n4\n\"singasong\"\n1\n\"singasong\"\n2\n\"abciiidef\"\n9\n\"a\"\n1\n\"ab\"\n1\n\"ba\"\n1\n```"
                    },
                    {
                        "username": "beresnw",
                        "content": "I need help. where I did wrong. The test fails, returns \"Time Limit Exceeded\" :(\n\nl = len(s)\n        max_number, number = 0, 0\n        for i in range(l):\n            number = 0\n            for m in range(i, i + k):\n                if m + 1 <= l:\n                    if s[m] in 'aeiou':\n                        number += 1\n                max_number = max(max_number, number) \n        return max_number"
                    },
                    {
                        "username": "beresnw",
                        "content": "[@macrescu](/macrescu) hm, thank u. remember it for the future"
                    },
                    {
                        "username": "macrescu",
                        "content": "You have 2 for loops, that is why. Try to do it only with only one."
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "People who found this problem too easy can attempt Maximum White Tiles Covered By Carpet. Its part of similar questions of this question."
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "class Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n       int n=s.size();\\n       int j=0;\\n       int l=k;\\n       int count=0;\\n        while(j<n && l<n){\\n             int c=0;\\n           for(int i=j;i<l;i++){\\n              if(s[i]==\\'a\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                   c++;\\n               }\\n            }\\n           count=max(count,c);\\n           j++;\\n           l++;\\n\\n        }\\n        return count;\\n     }\\n};\\n\\n\\nDoes anyone know why this code is not working ?"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@Krishrx](/Krishrx) thank you :)"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616)  Keep a variable to store the number of vowels in the previous substring and from that try to compute the vowel count for current window.\nThere is a slight change you need to make [@Pankhuri Srivastava](/pankhurishrivastava)\nCheck out my Solution its in java but you'll understand \nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488395/simple-self-understandable-java-code-o-n/?orderBy=most_votes\nLet me know if you have any doubts :)"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616) i am using two loops that\\'s why its getting TLE. i think we have to optimize the code."
                    },
                    {
                        "username": "tiwaridiwakar616",
                        "content": "[@Krishrx](/Krishrx) how can we tackle that TLE"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Pankhuri Srivastava](/pankhurishrivastava)The while condition should be  while(l<=n) now the code works\nbut still you'll get a TLE !"
                    },
                    {
                        "username": "Krishrx",
                        "content": "For the first time solving POTD 5 days in a row :)"
                    },
                    {
                        "username": "shashwat963",
                        "content": "this problem can be solved using sliding window algorithm.\\nfor complete explaination with visuals check out my solution-https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488278/c-with-image-explanation-100-faster-and-95-less-memory-using-sliding-window-algorithm/"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how to use sliding window method for long string ..i got TimeLimit Exceeded 102/106 cases passed .\\npls Let me know"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Have u actually adopted sliding window? I don't see how else u'd get TLE. Are you counting the number of vowels from scratch every time u get a new window? If u just add the incoming letter and remove the outgoing letter you should get AC."
                    },
                    {
                        "username": "judgementdey",
                        "content": "You must be doing some sub optimal operation in your code. Sliding window by itself as a concept works fine to solve this problem."
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Can someone tell is it good to write a code with more lines , or the same code in few lines .\nwell I am not a expert but  I see people writing short codes , should I also develop  a habit of writing code in fewer lines , or is it enough to focus on only Time and space complexity"
                    },
                    {
                        "username": "judgementdey",
                        "content": "Focus on optimizing time and space complexity first. Short code is only for better readability. It is an added bonus if you can write short and simple code, but is not an absolute necessity to succeed in interviews."
                    },
                    {
                        "username": "Mjashwanth",
                        "content": "Every time check a character is vowel or not.If it is a vowel then increase your count of vowel.When the substring size is greater than or equal to given value k you can find max vowels in the substring in each pass, after that find the first character of the substring is vowel or not.If it is vowel then decrease the count of vowel for the next pass.\\n\\nApproach\\nExample str = \"abciiidef\" k=\\'3\\'\\nwhen our pointer at \\'c\\' the index value is 2 & substring is \"abc\" now number of vowels are 1.\\nNow before going to next pass we have to check the first character of our substring is vowel or not.Our substring is \"abc\" our first character is \\'a\\' it is vowel so we have to decrease the count of vowel by one.Now our vowel count is 0.\\nIn next step our substring is \"bci\" number of vowels are now 1 because we have vowel at \\'3rd\\' index i.e \\'i\\'.\\nWe have to follow the above step till end of the string , we get max vowels of substring as \\'3\\' i.e \"iii\"."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Leet code is simply changing the tag of question to medium this week, while the questions are still easy in daily challenge.\\nMINDGAME!"
                    }
                ]
            },
            {
                "id": 1883590,
                "content": [
                    {
                        "username": "juleshwar",
                        "content": "### Testcases I tested with\n```\n\"abciiidef\"\n3\n\"aeiou\"\n2\n\"leetcode\"\n3\n\"aeiuo\"\n5\n\"smaoortooo\"\n7\n\"ooookaushdikuashas\"\n4\n\"singasong\"\n1\n\"singasong\"\n2\n\"abciiidef\"\n9\n\"a\"\n1\n\"ab\"\n1\n\"ba\"\n1\n```"
                    },
                    {
                        "username": "beresnw",
                        "content": "I need help. where I did wrong. The test fails, returns \"Time Limit Exceeded\" :(\n\nl = len(s)\n        max_number, number = 0, 0\n        for i in range(l):\n            number = 0\n            for m in range(i, i + k):\n                if m + 1 <= l:\n                    if s[m] in 'aeiou':\n                        number += 1\n                max_number = max(max_number, number) \n        return max_number"
                    },
                    {
                        "username": "beresnw",
                        "content": "[@macrescu](/macrescu) hm, thank u. remember it for the future"
                    },
                    {
                        "username": "macrescu",
                        "content": "You have 2 for loops, that is why. Try to do it only with only one."
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "People who found this problem too easy can attempt Maximum White Tiles Covered By Carpet. Its part of similar questions of this question."
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "class Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n       int n=s.size();\\n       int j=0;\\n       int l=k;\\n       int count=0;\\n        while(j<n && l<n){\\n             int c=0;\\n           for(int i=j;i<l;i++){\\n              if(s[i]==\\'a\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                   c++;\\n               }\\n            }\\n           count=max(count,c);\\n           j++;\\n           l++;\\n\\n        }\\n        return count;\\n     }\\n};\\n\\n\\nDoes anyone know why this code is not working ?"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@Krishrx](/Krishrx) thank you :)"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616)  Keep a variable to store the number of vowels in the previous substring and from that try to compute the vowel count for current window.\nThere is a slight change you need to make [@Pankhuri Srivastava](/pankhurishrivastava)\nCheck out my Solution its in java but you'll understand \nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488395/simple-self-understandable-java-code-o-n/?orderBy=most_votes\nLet me know if you have any doubts :)"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616) i am using two loops that\\'s why its getting TLE. i think we have to optimize the code."
                    },
                    {
                        "username": "tiwaridiwakar616",
                        "content": "[@Krishrx](/Krishrx) how can we tackle that TLE"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Pankhuri Srivastava](/pankhurishrivastava)The while condition should be  while(l<=n) now the code works\nbut still you'll get a TLE !"
                    },
                    {
                        "username": "Krishrx",
                        "content": "For the first time solving POTD 5 days in a row :)"
                    },
                    {
                        "username": "shashwat963",
                        "content": "this problem can be solved using sliding window algorithm.\\nfor complete explaination with visuals check out my solution-https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488278/c-with-image-explanation-100-faster-and-95-less-memory-using-sliding-window-algorithm/"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how to use sliding window method for long string ..i got TimeLimit Exceeded 102/106 cases passed .\\npls Let me know"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Have u actually adopted sliding window? I don't see how else u'd get TLE. Are you counting the number of vowels from scratch every time u get a new window? If u just add the incoming letter and remove the outgoing letter you should get AC."
                    },
                    {
                        "username": "judgementdey",
                        "content": "You must be doing some sub optimal operation in your code. Sliding window by itself as a concept works fine to solve this problem."
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Can someone tell is it good to write a code with more lines , or the same code in few lines .\nwell I am not a expert but  I see people writing short codes , should I also develop  a habit of writing code in fewer lines , or is it enough to focus on only Time and space complexity"
                    },
                    {
                        "username": "judgementdey",
                        "content": "Focus on optimizing time and space complexity first. Short code is only for better readability. It is an added bonus if you can write short and simple code, but is not an absolute necessity to succeed in interviews."
                    },
                    {
                        "username": "Mjashwanth",
                        "content": "Every time check a character is vowel or not.If it is a vowel then increase your count of vowel.When the substring size is greater than or equal to given value k you can find max vowels in the substring in each pass, after that find the first character of the substring is vowel or not.If it is vowel then decrease the count of vowel for the next pass.\\n\\nApproach\\nExample str = \"abciiidef\" k=\\'3\\'\\nwhen our pointer at \\'c\\' the index value is 2 & substring is \"abc\" now number of vowels are 1.\\nNow before going to next pass we have to check the first character of our substring is vowel or not.Our substring is \"abc\" our first character is \\'a\\' it is vowel so we have to decrease the count of vowel by one.Now our vowel count is 0.\\nIn next step our substring is \"bci\" number of vowels are now 1 because we have vowel at \\'3rd\\' index i.e \\'i\\'.\\nWe have to follow the above step till end of the string , we get max vowels of substring as \\'3\\' i.e \"iii\"."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Leet code is simply changing the tag of question to medium this week, while the questions are still easy in daily challenge.\\nMINDGAME!"
                    }
                ]
            },
            {
                "id": 1883390,
                "content": [
                    {
                        "username": "juleshwar",
                        "content": "### Testcases I tested with\n```\n\"abciiidef\"\n3\n\"aeiou\"\n2\n\"leetcode\"\n3\n\"aeiuo\"\n5\n\"smaoortooo\"\n7\n\"ooookaushdikuashas\"\n4\n\"singasong\"\n1\n\"singasong\"\n2\n\"abciiidef\"\n9\n\"a\"\n1\n\"ab\"\n1\n\"ba\"\n1\n```"
                    },
                    {
                        "username": "beresnw",
                        "content": "I need help. where I did wrong. The test fails, returns \"Time Limit Exceeded\" :(\n\nl = len(s)\n        max_number, number = 0, 0\n        for i in range(l):\n            number = 0\n            for m in range(i, i + k):\n                if m + 1 <= l:\n                    if s[m] in 'aeiou':\n                        number += 1\n                max_number = max(max_number, number) \n        return max_number"
                    },
                    {
                        "username": "beresnw",
                        "content": "[@macrescu](/macrescu) hm, thank u. remember it for the future"
                    },
                    {
                        "username": "macrescu",
                        "content": "You have 2 for loops, that is why. Try to do it only with only one."
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "People who found this problem too easy can attempt Maximum White Tiles Covered By Carpet. Its part of similar questions of this question."
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "class Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n       int n=s.size();\\n       int j=0;\\n       int l=k;\\n       int count=0;\\n        while(j<n && l<n){\\n             int c=0;\\n           for(int i=j;i<l;i++){\\n              if(s[i]==\\'a\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                   c++;\\n               }\\n            }\\n           count=max(count,c);\\n           j++;\\n           l++;\\n\\n        }\\n        return count;\\n     }\\n};\\n\\n\\nDoes anyone know why this code is not working ?"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@Krishrx](/Krishrx) thank you :)"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616)  Keep a variable to store the number of vowels in the previous substring and from that try to compute the vowel count for current window.\nThere is a slight change you need to make [@Pankhuri Srivastava](/pankhurishrivastava)\nCheck out my Solution its in java but you'll understand \nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488395/simple-self-understandable-java-code-o-n/?orderBy=most_votes\nLet me know if you have any doubts :)"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616) i am using two loops that\\'s why its getting TLE. i think we have to optimize the code."
                    },
                    {
                        "username": "tiwaridiwakar616",
                        "content": "[@Krishrx](/Krishrx) how can we tackle that TLE"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Pankhuri Srivastava](/pankhurishrivastava)The while condition should be  while(l<=n) now the code works\nbut still you'll get a TLE !"
                    },
                    {
                        "username": "Krishrx",
                        "content": "For the first time solving POTD 5 days in a row :)"
                    },
                    {
                        "username": "shashwat963",
                        "content": "this problem can be solved using sliding window algorithm.\\nfor complete explaination with visuals check out my solution-https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488278/c-with-image-explanation-100-faster-and-95-less-memory-using-sliding-window-algorithm/"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how to use sliding window method for long string ..i got TimeLimit Exceeded 102/106 cases passed .\\npls Let me know"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Have u actually adopted sliding window? I don't see how else u'd get TLE. Are you counting the number of vowels from scratch every time u get a new window? If u just add the incoming letter and remove the outgoing letter you should get AC."
                    },
                    {
                        "username": "judgementdey",
                        "content": "You must be doing some sub optimal operation in your code. Sliding window by itself as a concept works fine to solve this problem."
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Can someone tell is it good to write a code with more lines , or the same code in few lines .\nwell I am not a expert but  I see people writing short codes , should I also develop  a habit of writing code in fewer lines , or is it enough to focus on only Time and space complexity"
                    },
                    {
                        "username": "judgementdey",
                        "content": "Focus on optimizing time and space complexity first. Short code is only for better readability. It is an added bonus if you can write short and simple code, but is not an absolute necessity to succeed in interviews."
                    },
                    {
                        "username": "Mjashwanth",
                        "content": "Every time check a character is vowel or not.If it is a vowel then increase your count of vowel.When the substring size is greater than or equal to given value k you can find max vowels in the substring in each pass, after that find the first character of the substring is vowel or not.If it is vowel then decrease the count of vowel for the next pass.\\n\\nApproach\\nExample str = \"abciiidef\" k=\\'3\\'\\nwhen our pointer at \\'c\\' the index value is 2 & substring is \"abc\" now number of vowels are 1.\\nNow before going to next pass we have to check the first character of our substring is vowel or not.Our substring is \"abc\" our first character is \\'a\\' it is vowel so we have to decrease the count of vowel by one.Now our vowel count is 0.\\nIn next step our substring is \"bci\" number of vowels are now 1 because we have vowel at \\'3rd\\' index i.e \\'i\\'.\\nWe have to follow the above step till end of the string , we get max vowels of substring as \\'3\\' i.e \"iii\"."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Leet code is simply changing the tag of question to medium this week, while the questions are still easy in daily challenge.\\nMINDGAME!"
                    }
                ]
            },
            {
                "id": 1883341,
                "content": [
                    {
                        "username": "juleshwar",
                        "content": "### Testcases I tested with\n```\n\"abciiidef\"\n3\n\"aeiou\"\n2\n\"leetcode\"\n3\n\"aeiuo\"\n5\n\"smaoortooo\"\n7\n\"ooookaushdikuashas\"\n4\n\"singasong\"\n1\n\"singasong\"\n2\n\"abciiidef\"\n9\n\"a\"\n1\n\"ab\"\n1\n\"ba\"\n1\n```"
                    },
                    {
                        "username": "beresnw",
                        "content": "I need help. where I did wrong. The test fails, returns \"Time Limit Exceeded\" :(\n\nl = len(s)\n        max_number, number = 0, 0\n        for i in range(l):\n            number = 0\n            for m in range(i, i + k):\n                if m + 1 <= l:\n                    if s[m] in 'aeiou':\n                        number += 1\n                max_number = max(max_number, number) \n        return max_number"
                    },
                    {
                        "username": "beresnw",
                        "content": "[@macrescu](/macrescu) hm, thank u. remember it for the future"
                    },
                    {
                        "username": "macrescu",
                        "content": "You have 2 for loops, that is why. Try to do it only with only one."
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "People who found this problem too easy can attempt Maximum White Tiles Covered By Carpet. Its part of similar questions of this question."
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "class Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n       int n=s.size();\\n       int j=0;\\n       int l=k;\\n       int count=0;\\n        while(j<n && l<n){\\n             int c=0;\\n           for(int i=j;i<l;i++){\\n              if(s[i]==\\'a\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                   c++;\\n               }\\n            }\\n           count=max(count,c);\\n           j++;\\n           l++;\\n\\n        }\\n        return count;\\n     }\\n};\\n\\n\\nDoes anyone know why this code is not working ?"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@Krishrx](/Krishrx) thank you :)"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616)  Keep a variable to store the number of vowels in the previous substring and from that try to compute the vowel count for current window.\nThere is a slight change you need to make [@Pankhuri Srivastava](/pankhurishrivastava)\nCheck out my Solution its in java but you'll understand \nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488395/simple-self-understandable-java-code-o-n/?orderBy=most_votes\nLet me know if you have any doubts :)"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616) i am using two loops that\\'s why its getting TLE. i think we have to optimize the code."
                    },
                    {
                        "username": "tiwaridiwakar616",
                        "content": "[@Krishrx](/Krishrx) how can we tackle that TLE"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Pankhuri Srivastava](/pankhurishrivastava)The while condition should be  while(l<=n) now the code works\nbut still you'll get a TLE !"
                    },
                    {
                        "username": "Krishrx",
                        "content": "For the first time solving POTD 5 days in a row :)"
                    },
                    {
                        "username": "shashwat963",
                        "content": "this problem can be solved using sliding window algorithm.\\nfor complete explaination with visuals check out my solution-https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488278/c-with-image-explanation-100-faster-and-95-less-memory-using-sliding-window-algorithm/"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how to use sliding window method for long string ..i got TimeLimit Exceeded 102/106 cases passed .\\npls Let me know"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Have u actually adopted sliding window? I don't see how else u'd get TLE. Are you counting the number of vowels from scratch every time u get a new window? If u just add the incoming letter and remove the outgoing letter you should get AC."
                    },
                    {
                        "username": "judgementdey",
                        "content": "You must be doing some sub optimal operation in your code. Sliding window by itself as a concept works fine to solve this problem."
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Can someone tell is it good to write a code with more lines , or the same code in few lines .\nwell I am not a expert but  I see people writing short codes , should I also develop  a habit of writing code in fewer lines , or is it enough to focus on only Time and space complexity"
                    },
                    {
                        "username": "judgementdey",
                        "content": "Focus on optimizing time and space complexity first. Short code is only for better readability. It is an added bonus if you can write short and simple code, but is not an absolute necessity to succeed in interviews."
                    },
                    {
                        "username": "Mjashwanth",
                        "content": "Every time check a character is vowel or not.If it is a vowel then increase your count of vowel.When the substring size is greater than or equal to given value k you can find max vowels in the substring in each pass, after that find the first character of the substring is vowel or not.If it is vowel then decrease the count of vowel for the next pass.\\n\\nApproach\\nExample str = \"abciiidef\" k=\\'3\\'\\nwhen our pointer at \\'c\\' the index value is 2 & substring is \"abc\" now number of vowels are 1.\\nNow before going to next pass we have to check the first character of our substring is vowel or not.Our substring is \"abc\" our first character is \\'a\\' it is vowel so we have to decrease the count of vowel by one.Now our vowel count is 0.\\nIn next step our substring is \"bci\" number of vowels are now 1 because we have vowel at \\'3rd\\' index i.e \\'i\\'.\\nWe have to follow the above step till end of the string , we get max vowels of substring as \\'3\\' i.e \"iii\"."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Leet code is simply changing the tag of question to medium this week, while the questions are still easy in daily challenge.\\nMINDGAME!"
                    }
                ]
            },
            {
                "id": 1883336,
                "content": [
                    {
                        "username": "juleshwar",
                        "content": "### Testcases I tested with\n```\n\"abciiidef\"\n3\n\"aeiou\"\n2\n\"leetcode\"\n3\n\"aeiuo\"\n5\n\"smaoortooo\"\n7\n\"ooookaushdikuashas\"\n4\n\"singasong\"\n1\n\"singasong\"\n2\n\"abciiidef\"\n9\n\"a\"\n1\n\"ab\"\n1\n\"ba\"\n1\n```"
                    },
                    {
                        "username": "beresnw",
                        "content": "I need help. where I did wrong. The test fails, returns \"Time Limit Exceeded\" :(\n\nl = len(s)\n        max_number, number = 0, 0\n        for i in range(l):\n            number = 0\n            for m in range(i, i + k):\n                if m + 1 <= l:\n                    if s[m] in 'aeiou':\n                        number += 1\n                max_number = max(max_number, number) \n        return max_number"
                    },
                    {
                        "username": "beresnw",
                        "content": "[@macrescu](/macrescu) hm, thank u. remember it for the future"
                    },
                    {
                        "username": "macrescu",
                        "content": "You have 2 for loops, that is why. Try to do it only with only one."
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "People who found this problem too easy can attempt Maximum White Tiles Covered By Carpet. Its part of similar questions of this question."
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "class Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n       int n=s.size();\\n       int j=0;\\n       int l=k;\\n       int count=0;\\n        while(j<n && l<n){\\n             int c=0;\\n           for(int i=j;i<l;i++){\\n              if(s[i]==\\'a\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                   c++;\\n               }\\n            }\\n           count=max(count,c);\\n           j++;\\n           l++;\\n\\n        }\\n        return count;\\n     }\\n};\\n\\n\\nDoes anyone know why this code is not working ?"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@Krishrx](/Krishrx) thank you :)"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616)  Keep a variable to store the number of vowels in the previous substring and from that try to compute the vowel count for current window.\nThere is a slight change you need to make [@Pankhuri Srivastava](/pankhurishrivastava)\nCheck out my Solution its in java but you'll understand \nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488395/simple-self-understandable-java-code-o-n/?orderBy=most_votes\nLet me know if you have any doubts :)"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616) i am using two loops that\\'s why its getting TLE. i think we have to optimize the code."
                    },
                    {
                        "username": "tiwaridiwakar616",
                        "content": "[@Krishrx](/Krishrx) how can we tackle that TLE"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Pankhuri Srivastava](/pankhurishrivastava)The while condition should be  while(l<=n) now the code works\nbut still you'll get a TLE !"
                    },
                    {
                        "username": "Krishrx",
                        "content": "For the first time solving POTD 5 days in a row :)"
                    },
                    {
                        "username": "shashwat963",
                        "content": "this problem can be solved using sliding window algorithm.\\nfor complete explaination with visuals check out my solution-https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488278/c-with-image-explanation-100-faster-and-95-less-memory-using-sliding-window-algorithm/"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how to use sliding window method for long string ..i got TimeLimit Exceeded 102/106 cases passed .\\npls Let me know"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Have u actually adopted sliding window? I don't see how else u'd get TLE. Are you counting the number of vowels from scratch every time u get a new window? If u just add the incoming letter and remove the outgoing letter you should get AC."
                    },
                    {
                        "username": "judgementdey",
                        "content": "You must be doing some sub optimal operation in your code. Sliding window by itself as a concept works fine to solve this problem."
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Can someone tell is it good to write a code with more lines , or the same code in few lines .\nwell I am not a expert but  I see people writing short codes , should I also develop  a habit of writing code in fewer lines , or is it enough to focus on only Time and space complexity"
                    },
                    {
                        "username": "judgementdey",
                        "content": "Focus on optimizing time and space complexity first. Short code is only for better readability. It is an added bonus if you can write short and simple code, but is not an absolute necessity to succeed in interviews."
                    },
                    {
                        "username": "Mjashwanth",
                        "content": "Every time check a character is vowel or not.If it is a vowel then increase your count of vowel.When the substring size is greater than or equal to given value k you can find max vowels in the substring in each pass, after that find the first character of the substring is vowel or not.If it is vowel then decrease the count of vowel for the next pass.\\n\\nApproach\\nExample str = \"abciiidef\" k=\\'3\\'\\nwhen our pointer at \\'c\\' the index value is 2 & substring is \"abc\" now number of vowels are 1.\\nNow before going to next pass we have to check the first character of our substring is vowel or not.Our substring is \"abc\" our first character is \\'a\\' it is vowel so we have to decrease the count of vowel by one.Now our vowel count is 0.\\nIn next step our substring is \"bci\" number of vowels are now 1 because we have vowel at \\'3rd\\' index i.e \\'i\\'.\\nWe have to follow the above step till end of the string , we get max vowels of substring as \\'3\\' i.e \"iii\"."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Leet code is simply changing the tag of question to medium this week, while the questions are still easy in daily challenge.\\nMINDGAME!"
                    }
                ]
            },
            {
                "id": 1883267,
                "content": [
                    {
                        "username": "juleshwar",
                        "content": "### Testcases I tested with\n```\n\"abciiidef\"\n3\n\"aeiou\"\n2\n\"leetcode\"\n3\n\"aeiuo\"\n5\n\"smaoortooo\"\n7\n\"ooookaushdikuashas\"\n4\n\"singasong\"\n1\n\"singasong\"\n2\n\"abciiidef\"\n9\n\"a\"\n1\n\"ab\"\n1\n\"ba\"\n1\n```"
                    },
                    {
                        "username": "beresnw",
                        "content": "I need help. where I did wrong. The test fails, returns \"Time Limit Exceeded\" :(\n\nl = len(s)\n        max_number, number = 0, 0\n        for i in range(l):\n            number = 0\n            for m in range(i, i + k):\n                if m + 1 <= l:\n                    if s[m] in 'aeiou':\n                        number += 1\n                max_number = max(max_number, number) \n        return max_number"
                    },
                    {
                        "username": "beresnw",
                        "content": "[@macrescu](/macrescu) hm, thank u. remember it for the future"
                    },
                    {
                        "username": "macrescu",
                        "content": "You have 2 for loops, that is why. Try to do it only with only one."
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "People who found this problem too easy can attempt Maximum White Tiles Covered By Carpet. Its part of similar questions of this question."
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "class Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n       int n=s.size();\\n       int j=0;\\n       int l=k;\\n       int count=0;\\n        while(j<n && l<n){\\n             int c=0;\\n           for(int i=j;i<l;i++){\\n              if(s[i]==\\'a\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                   c++;\\n               }\\n            }\\n           count=max(count,c);\\n           j++;\\n           l++;\\n\\n        }\\n        return count;\\n     }\\n};\\n\\n\\nDoes anyone know why this code is not working ?"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@Krishrx](/Krishrx) thank you :)"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616)  Keep a variable to store the number of vowels in the previous substring and from that try to compute the vowel count for current window.\nThere is a slight change you need to make [@Pankhuri Srivastava](/pankhurishrivastava)\nCheck out my Solution its in java but you'll understand \nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488395/simple-self-understandable-java-code-o-n/?orderBy=most_votes\nLet me know if you have any doubts :)"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616) i am using two loops that\\'s why its getting TLE. i think we have to optimize the code."
                    },
                    {
                        "username": "tiwaridiwakar616",
                        "content": "[@Krishrx](/Krishrx) how can we tackle that TLE"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Pankhuri Srivastava](/pankhurishrivastava)The while condition should be  while(l<=n) now the code works\nbut still you'll get a TLE !"
                    },
                    {
                        "username": "Krishrx",
                        "content": "For the first time solving POTD 5 days in a row :)"
                    },
                    {
                        "username": "shashwat963",
                        "content": "this problem can be solved using sliding window algorithm.\\nfor complete explaination with visuals check out my solution-https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488278/c-with-image-explanation-100-faster-and-95-less-memory-using-sliding-window-algorithm/"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how to use sliding window method for long string ..i got TimeLimit Exceeded 102/106 cases passed .\\npls Let me know"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Have u actually adopted sliding window? I don't see how else u'd get TLE. Are you counting the number of vowels from scratch every time u get a new window? If u just add the incoming letter and remove the outgoing letter you should get AC."
                    },
                    {
                        "username": "judgementdey",
                        "content": "You must be doing some sub optimal operation in your code. Sliding window by itself as a concept works fine to solve this problem."
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Can someone tell is it good to write a code with more lines , or the same code in few lines .\nwell I am not a expert but  I see people writing short codes , should I also develop  a habit of writing code in fewer lines , or is it enough to focus on only Time and space complexity"
                    },
                    {
                        "username": "judgementdey",
                        "content": "Focus on optimizing time and space complexity first. Short code is only for better readability. It is an added bonus if you can write short and simple code, but is not an absolute necessity to succeed in interviews."
                    },
                    {
                        "username": "Mjashwanth",
                        "content": "Every time check a character is vowel or not.If it is a vowel then increase your count of vowel.When the substring size is greater than or equal to given value k you can find max vowels in the substring in each pass, after that find the first character of the substring is vowel or not.If it is vowel then decrease the count of vowel for the next pass.\\n\\nApproach\\nExample str = \"abciiidef\" k=\\'3\\'\\nwhen our pointer at \\'c\\' the index value is 2 & substring is \"abc\" now number of vowels are 1.\\nNow before going to next pass we have to check the first character of our substring is vowel or not.Our substring is \"abc\" our first character is \\'a\\' it is vowel so we have to decrease the count of vowel by one.Now our vowel count is 0.\\nIn next step our substring is \"bci\" number of vowels are now 1 because we have vowel at \\'3rd\\' index i.e \\'i\\'.\\nWe have to follow the above step till end of the string , we get max vowels of substring as \\'3\\' i.e \"iii\"."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Leet code is simply changing the tag of question to medium this week, while the questions are still easy in daily challenge.\\nMINDGAME!"
                    }
                ]
            },
            {
                "id": 1883218,
                "content": [
                    {
                        "username": "juleshwar",
                        "content": "### Testcases I tested with\n```\n\"abciiidef\"\n3\n\"aeiou\"\n2\n\"leetcode\"\n3\n\"aeiuo\"\n5\n\"smaoortooo\"\n7\n\"ooookaushdikuashas\"\n4\n\"singasong\"\n1\n\"singasong\"\n2\n\"abciiidef\"\n9\n\"a\"\n1\n\"ab\"\n1\n\"ba\"\n1\n```"
                    },
                    {
                        "username": "beresnw",
                        "content": "I need help. where I did wrong. The test fails, returns \"Time Limit Exceeded\" :(\n\nl = len(s)\n        max_number, number = 0, 0\n        for i in range(l):\n            number = 0\n            for m in range(i, i + k):\n                if m + 1 <= l:\n                    if s[m] in 'aeiou':\n                        number += 1\n                max_number = max(max_number, number) \n        return max_number"
                    },
                    {
                        "username": "beresnw",
                        "content": "[@macrescu](/macrescu) hm, thank u. remember it for the future"
                    },
                    {
                        "username": "macrescu",
                        "content": "You have 2 for loops, that is why. Try to do it only with only one."
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "People who found this problem too easy can attempt Maximum White Tiles Covered By Carpet. Its part of similar questions of this question."
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "class Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n       int n=s.size();\\n       int j=0;\\n       int l=k;\\n       int count=0;\\n        while(j<n && l<n){\\n             int c=0;\\n           for(int i=j;i<l;i++){\\n              if(s[i]==\\'a\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                   c++;\\n               }\\n            }\\n           count=max(count,c);\\n           j++;\\n           l++;\\n\\n        }\\n        return count;\\n     }\\n};\\n\\n\\nDoes anyone know why this code is not working ?"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@Krishrx](/Krishrx) thank you :)"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616)  Keep a variable to store the number of vowels in the previous substring and from that try to compute the vowel count for current window.\nThere is a slight change you need to make [@Pankhuri Srivastava](/pankhurishrivastava)\nCheck out my Solution its in java but you'll understand \nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488395/simple-self-understandable-java-code-o-n/?orderBy=most_votes\nLet me know if you have any doubts :)"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616) i am using two loops that\\'s why its getting TLE. i think we have to optimize the code."
                    },
                    {
                        "username": "tiwaridiwakar616",
                        "content": "[@Krishrx](/Krishrx) how can we tackle that TLE"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Pankhuri Srivastava](/pankhurishrivastava)The while condition should be  while(l<=n) now the code works\nbut still you'll get a TLE !"
                    },
                    {
                        "username": "Krishrx",
                        "content": "For the first time solving POTD 5 days in a row :)"
                    },
                    {
                        "username": "shashwat963",
                        "content": "this problem can be solved using sliding window algorithm.\\nfor complete explaination with visuals check out my solution-https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488278/c-with-image-explanation-100-faster-and-95-less-memory-using-sliding-window-algorithm/"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how to use sliding window method for long string ..i got TimeLimit Exceeded 102/106 cases passed .\\npls Let me know"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Have u actually adopted sliding window? I don't see how else u'd get TLE. Are you counting the number of vowels from scratch every time u get a new window? If u just add the incoming letter and remove the outgoing letter you should get AC."
                    },
                    {
                        "username": "judgementdey",
                        "content": "You must be doing some sub optimal operation in your code. Sliding window by itself as a concept works fine to solve this problem."
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Can someone tell is it good to write a code with more lines , or the same code in few lines .\nwell I am not a expert but  I see people writing short codes , should I also develop  a habit of writing code in fewer lines , or is it enough to focus on only Time and space complexity"
                    },
                    {
                        "username": "judgementdey",
                        "content": "Focus on optimizing time and space complexity first. Short code is only for better readability. It is an added bonus if you can write short and simple code, but is not an absolute necessity to succeed in interviews."
                    },
                    {
                        "username": "Mjashwanth",
                        "content": "Every time check a character is vowel or not.If it is a vowel then increase your count of vowel.When the substring size is greater than or equal to given value k you can find max vowels in the substring in each pass, after that find the first character of the substring is vowel or not.If it is vowel then decrease the count of vowel for the next pass.\\n\\nApproach\\nExample str = \"abciiidef\" k=\\'3\\'\\nwhen our pointer at \\'c\\' the index value is 2 & substring is \"abc\" now number of vowels are 1.\\nNow before going to next pass we have to check the first character of our substring is vowel or not.Our substring is \"abc\" our first character is \\'a\\' it is vowel so we have to decrease the count of vowel by one.Now our vowel count is 0.\\nIn next step our substring is \"bci\" number of vowels are now 1 because we have vowel at \\'3rd\\' index i.e \\'i\\'.\\nWe have to follow the above step till end of the string , we get max vowels of substring as \\'3\\' i.e \"iii\"."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Leet code is simply changing the tag of question to medium this week, while the questions are still easy in daily challenge.\\nMINDGAME!"
                    }
                ]
            },
            {
                "id": 1883199,
                "content": [
                    {
                        "username": "juleshwar",
                        "content": "### Testcases I tested with\n```\n\"abciiidef\"\n3\n\"aeiou\"\n2\n\"leetcode\"\n3\n\"aeiuo\"\n5\n\"smaoortooo\"\n7\n\"ooookaushdikuashas\"\n4\n\"singasong\"\n1\n\"singasong\"\n2\n\"abciiidef\"\n9\n\"a\"\n1\n\"ab\"\n1\n\"ba\"\n1\n```"
                    },
                    {
                        "username": "beresnw",
                        "content": "I need help. where I did wrong. The test fails, returns \"Time Limit Exceeded\" :(\n\nl = len(s)\n        max_number, number = 0, 0\n        for i in range(l):\n            number = 0\n            for m in range(i, i + k):\n                if m + 1 <= l:\n                    if s[m] in 'aeiou':\n                        number += 1\n                max_number = max(max_number, number) \n        return max_number"
                    },
                    {
                        "username": "beresnw",
                        "content": "[@macrescu](/macrescu) hm, thank u. remember it for the future"
                    },
                    {
                        "username": "macrescu",
                        "content": "You have 2 for loops, that is why. Try to do it only with only one."
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "People who found this problem too easy can attempt Maximum White Tiles Covered By Carpet. Its part of similar questions of this question."
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "class Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n       int n=s.size();\\n       int j=0;\\n       int l=k;\\n       int count=0;\\n        while(j<n && l<n){\\n             int c=0;\\n           for(int i=j;i<l;i++){\\n              if(s[i]==\\'a\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                   c++;\\n               }\\n            }\\n           count=max(count,c);\\n           j++;\\n           l++;\\n\\n        }\\n        return count;\\n     }\\n};\\n\\n\\nDoes anyone know why this code is not working ?"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@Krishrx](/Krishrx) thank you :)"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616)  Keep a variable to store the number of vowels in the previous substring and from that try to compute the vowel count for current window.\nThere is a slight change you need to make [@Pankhuri Srivastava](/pankhurishrivastava)\nCheck out my Solution its in java but you'll understand \nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488395/simple-self-understandable-java-code-o-n/?orderBy=most_votes\nLet me know if you have any doubts :)"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616) i am using two loops that\\'s why its getting TLE. i think we have to optimize the code."
                    },
                    {
                        "username": "tiwaridiwakar616",
                        "content": "[@Krishrx](/Krishrx) how can we tackle that TLE"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Pankhuri Srivastava](/pankhurishrivastava)The while condition should be  while(l<=n) now the code works\nbut still you'll get a TLE !"
                    },
                    {
                        "username": "Krishrx",
                        "content": "For the first time solving POTD 5 days in a row :)"
                    },
                    {
                        "username": "shashwat963",
                        "content": "this problem can be solved using sliding window algorithm.\\nfor complete explaination with visuals check out my solution-https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488278/c-with-image-explanation-100-faster-and-95-less-memory-using-sliding-window-algorithm/"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how to use sliding window method for long string ..i got TimeLimit Exceeded 102/106 cases passed .\\npls Let me know"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Have u actually adopted sliding window? I don't see how else u'd get TLE. Are you counting the number of vowels from scratch every time u get a new window? If u just add the incoming letter and remove the outgoing letter you should get AC."
                    },
                    {
                        "username": "judgementdey",
                        "content": "You must be doing some sub optimal operation in your code. Sliding window by itself as a concept works fine to solve this problem."
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Can someone tell is it good to write a code with more lines , or the same code in few lines .\nwell I am not a expert but  I see people writing short codes , should I also develop  a habit of writing code in fewer lines , or is it enough to focus on only Time and space complexity"
                    },
                    {
                        "username": "judgementdey",
                        "content": "Focus on optimizing time and space complexity first. Short code is only for better readability. It is an added bonus if you can write short and simple code, but is not an absolute necessity to succeed in interviews."
                    },
                    {
                        "username": "Mjashwanth",
                        "content": "Every time check a character is vowel or not.If it is a vowel then increase your count of vowel.When the substring size is greater than or equal to given value k you can find max vowels in the substring in each pass, after that find the first character of the substring is vowel or not.If it is vowel then decrease the count of vowel for the next pass.\\n\\nApproach\\nExample str = \"abciiidef\" k=\\'3\\'\\nwhen our pointer at \\'c\\' the index value is 2 & substring is \"abc\" now number of vowels are 1.\\nNow before going to next pass we have to check the first character of our substring is vowel or not.Our substring is \"abc\" our first character is \\'a\\' it is vowel so we have to decrease the count of vowel by one.Now our vowel count is 0.\\nIn next step our substring is \"bci\" number of vowels are now 1 because we have vowel at \\'3rd\\' index i.e \\'i\\'.\\nWe have to follow the above step till end of the string , we get max vowels of substring as \\'3\\' i.e \"iii\"."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Leet code is simply changing the tag of question to medium this week, while the questions are still easy in daily challenge.\\nMINDGAME!"
                    }
                ]
            },
            {
                "id": 1883126,
                "content": [
                    {
                        "username": "juleshwar",
                        "content": "### Testcases I tested with\n```\n\"abciiidef\"\n3\n\"aeiou\"\n2\n\"leetcode\"\n3\n\"aeiuo\"\n5\n\"smaoortooo\"\n7\n\"ooookaushdikuashas\"\n4\n\"singasong\"\n1\n\"singasong\"\n2\n\"abciiidef\"\n9\n\"a\"\n1\n\"ab\"\n1\n\"ba\"\n1\n```"
                    },
                    {
                        "username": "beresnw",
                        "content": "I need help. where I did wrong. The test fails, returns \"Time Limit Exceeded\" :(\n\nl = len(s)\n        max_number, number = 0, 0\n        for i in range(l):\n            number = 0\n            for m in range(i, i + k):\n                if m + 1 <= l:\n                    if s[m] in 'aeiou':\n                        number += 1\n                max_number = max(max_number, number) \n        return max_number"
                    },
                    {
                        "username": "beresnw",
                        "content": "[@macrescu](/macrescu) hm, thank u. remember it for the future"
                    },
                    {
                        "username": "macrescu",
                        "content": "You have 2 for loops, that is why. Try to do it only with only one."
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "People who found this problem too easy can attempt Maximum White Tiles Covered By Carpet. Its part of similar questions of this question."
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "class Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n       int n=s.size();\\n       int j=0;\\n       int l=k;\\n       int count=0;\\n        while(j<n && l<n){\\n             int c=0;\\n           for(int i=j;i<l;i++){\\n              if(s[i]==\\'a\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                   c++;\\n               }\\n            }\\n           count=max(count,c);\\n           j++;\\n           l++;\\n\\n        }\\n        return count;\\n     }\\n};\\n\\n\\nDoes anyone know why this code is not working ?"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@Krishrx](/Krishrx) thank you :)"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616)  Keep a variable to store the number of vowels in the previous substring and from that try to compute the vowel count for current window.\nThere is a slight change you need to make [@Pankhuri Srivastava](/pankhurishrivastava)\nCheck out my Solution its in java but you'll understand \nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488395/simple-self-understandable-java-code-o-n/?orderBy=most_votes\nLet me know if you have any doubts :)"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616) i am using two loops that\\'s why its getting TLE. i think we have to optimize the code."
                    },
                    {
                        "username": "tiwaridiwakar616",
                        "content": "[@Krishrx](/Krishrx) how can we tackle that TLE"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Pankhuri Srivastava](/pankhurishrivastava)The while condition should be  while(l<=n) now the code works\nbut still you'll get a TLE !"
                    },
                    {
                        "username": "Krishrx",
                        "content": "For the first time solving POTD 5 days in a row :)"
                    },
                    {
                        "username": "shashwat963",
                        "content": "this problem can be solved using sliding window algorithm.\\nfor complete explaination with visuals check out my solution-https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488278/c-with-image-explanation-100-faster-and-95-less-memory-using-sliding-window-algorithm/"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how to use sliding window method for long string ..i got TimeLimit Exceeded 102/106 cases passed .\\npls Let me know"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Have u actually adopted sliding window? I don't see how else u'd get TLE. Are you counting the number of vowels from scratch every time u get a new window? If u just add the incoming letter and remove the outgoing letter you should get AC."
                    },
                    {
                        "username": "judgementdey",
                        "content": "You must be doing some sub optimal operation in your code. Sliding window by itself as a concept works fine to solve this problem."
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Can someone tell is it good to write a code with more lines , or the same code in few lines .\nwell I am not a expert but  I see people writing short codes , should I also develop  a habit of writing code in fewer lines , or is it enough to focus on only Time and space complexity"
                    },
                    {
                        "username": "judgementdey",
                        "content": "Focus on optimizing time and space complexity first. Short code is only for better readability. It is an added bonus if you can write short and simple code, but is not an absolute necessity to succeed in interviews."
                    },
                    {
                        "username": "Mjashwanth",
                        "content": "Every time check a character is vowel or not.If it is a vowel then increase your count of vowel.When the substring size is greater than or equal to given value k you can find max vowels in the substring in each pass, after that find the first character of the substring is vowel or not.If it is vowel then decrease the count of vowel for the next pass.\\n\\nApproach\\nExample str = \"abciiidef\" k=\\'3\\'\\nwhen our pointer at \\'c\\' the index value is 2 & substring is \"abc\" now number of vowels are 1.\\nNow before going to next pass we have to check the first character of our substring is vowel or not.Our substring is \"abc\" our first character is \\'a\\' it is vowel so we have to decrease the count of vowel by one.Now our vowel count is 0.\\nIn next step our substring is \"bci\" number of vowels are now 1 because we have vowel at \\'3rd\\' index i.e \\'i\\'.\\nWe have to follow the above step till end of the string , we get max vowels of substring as \\'3\\' i.e \"iii\"."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Leet code is simply changing the tag of question to medium this week, while the questions are still easy in daily challenge.\\nMINDGAME!"
                    }
                ]
            },
            {
                "id": 1883091,
                "content": [
                    {
                        "username": "juleshwar",
                        "content": "### Testcases I tested with\n```\n\"abciiidef\"\n3\n\"aeiou\"\n2\n\"leetcode\"\n3\n\"aeiuo\"\n5\n\"smaoortooo\"\n7\n\"ooookaushdikuashas\"\n4\n\"singasong\"\n1\n\"singasong\"\n2\n\"abciiidef\"\n9\n\"a\"\n1\n\"ab\"\n1\n\"ba\"\n1\n```"
                    },
                    {
                        "username": "beresnw",
                        "content": "I need help. where I did wrong. The test fails, returns \"Time Limit Exceeded\" :(\n\nl = len(s)\n        max_number, number = 0, 0\n        for i in range(l):\n            number = 0\n            for m in range(i, i + k):\n                if m + 1 <= l:\n                    if s[m] in 'aeiou':\n                        number += 1\n                max_number = max(max_number, number) \n        return max_number"
                    },
                    {
                        "username": "beresnw",
                        "content": "[@macrescu](/macrescu) hm, thank u. remember it for the future"
                    },
                    {
                        "username": "macrescu",
                        "content": "You have 2 for loops, that is why. Try to do it only with only one."
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "People who found this problem too easy can attempt Maximum White Tiles Covered By Carpet. Its part of similar questions of this question."
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "class Solution {\\npublic:\\n    int maxVowels(string s, int k) {\\n       int n=s.size();\\n       int j=0;\\n       int l=k;\\n       int count=0;\\n        while(j<n && l<n){\\n             int c=0;\\n           for(int i=j;i<l;i++){\\n              if(s[i]==\\'a\\'|| s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                   c++;\\n               }\\n            }\\n           count=max(count,c);\\n           j++;\\n           l++;\\n\\n        }\\n        return count;\\n     }\\n};\\n\\n\\nDoes anyone know why this code is not working ?"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@Krishrx](/Krishrx) thank you :)"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616)  Keep a variable to store the number of vowels in the previous substring and from that try to compute the vowel count for current window.\nThere is a slight change you need to make [@Pankhuri Srivastava](/pankhurishrivastava)\nCheck out my Solution its in java but you'll understand \nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488395/simple-self-understandable-java-code-o-n/?orderBy=most_votes\nLet me know if you have any doubts :)"
                    },
                    {
                        "username": "pankhurishrivastava",
                        "content": "[@tiwaridiwakar616](/tiwaridiwakar616) i am using two loops that\\'s why its getting TLE. i think we have to optimize the code."
                    },
                    {
                        "username": "tiwaridiwakar616",
                        "content": "[@Krishrx](/Krishrx) how can we tackle that TLE"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Pankhuri Srivastava](/pankhurishrivastava)The while condition should be  while(l<=n) now the code works\nbut still you'll get a TLE !"
                    },
                    {
                        "username": "Krishrx",
                        "content": "For the first time solving POTD 5 days in a row :)"
                    },
                    {
                        "username": "shashwat963",
                        "content": "this problem can be solved using sliding window algorithm.\\nfor complete explaination with visuals check out my solution-https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3488278/c-with-image-explanation-100-faster-and-95-less-memory-using-sliding-window-algorithm/"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "how to use sliding window method for long string ..i got TimeLimit Exceeded 102/106 cases passed .\\npls Let me know"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "Have u actually adopted sliding window? I don't see how else u'd get TLE. Are you counting the number of vowels from scratch every time u get a new window? If u just add the incoming letter and remove the outgoing letter you should get AC."
                    },
                    {
                        "username": "judgementdey",
                        "content": "You must be doing some sub optimal operation in your code. Sliding window by itself as a concept works fine to solve this problem."
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Can someone tell is it good to write a code with more lines , or the same code in few lines .\nwell I am not a expert but  I see people writing short codes , should I also develop  a habit of writing code in fewer lines , or is it enough to focus on only Time and space complexity"
                    },
                    {
                        "username": "judgementdey",
                        "content": "Focus on optimizing time and space complexity first. Short code is only for better readability. It is an added bonus if you can write short and simple code, but is not an absolute necessity to succeed in interviews."
                    },
                    {
                        "username": "Mjashwanth",
                        "content": "Every time check a character is vowel or not.If it is a vowel then increase your count of vowel.When the substring size is greater than or equal to given value k you can find max vowels in the substring in each pass, after that find the first character of the substring is vowel or not.If it is vowel then decrease the count of vowel for the next pass.\\n\\nApproach\\nExample str = \"abciiidef\" k=\\'3\\'\\nwhen our pointer at \\'c\\' the index value is 2 & substring is \"abc\" now number of vowels are 1.\\nNow before going to next pass we have to check the first character of our substring is vowel or not.Our substring is \"abc\" our first character is \\'a\\' it is vowel so we have to decrease the count of vowel by one.Now our vowel count is 0.\\nIn next step our substring is \"bci\" number of vowels are now 1 because we have vowel at \\'3rd\\' index i.e \\'i\\'.\\nWe have to follow the above step till end of the string , we get max vowels of substring as \\'3\\' i.e \"iii\"."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "Leet code is simply changing the tag of question to medium this week, while the questions are still easy in daily challenge.\\nMINDGAME!"
                    }
                ]
            },
            {
                "id": 1883065,
                "content": [
                    {
                        "username": "pushpendra3000",
                        "content": "In the question is explicitly mentioned that length of substring should be of length k. However, in the testcases, it is also counting substrings whose length is less than k.\\n\\nPlease correct this. "
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "there cannot be a substring with length < k that has more vowels than a the max substring of length k..."
                    },
                    {
                        "username": "Peet_code",
                        "content": "it\\'s medium  easy problem"
                    },
                    {
                        "username": "dineshkumar_1708",
                        "content": "what would be the required TC ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "O(n)"
                    },
                    {
                        "username": "Xoxo_szn",
                        "content": "Medium Question on a change,  I think I\\'m getting better :)"
                    },
                    {
                        "username": "rrabbi",
                        "content": "Tried the naïve approach but did not pass the 102nd test case haha\nGot to know about the sliding window algorithm for the first time through discussion, pretty straight forward from there!"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "LC gods have shown mercy this week"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Looks like easy problem under sliding window\n```String         CurrentVowelCount\nabciiidef      0 //initially\nabc            0+1(a)\n bci           1+1(i) -1(a)=1\n  cii          1+1(i) =2\n   iii         2+1(i) =3    (maximum -> Answer)\n    iid        3-1(i) =2\n     ide       2-1(i)+1(e) =2\n      def      2-1(i) =1  ```\n\nPlease try to solve yourself first and can refer hint and solution to the problem:\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3487005/easy-java-sliding-window-approach/"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "leetcode will put bigger hard problems on month end..."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "#### Leetcode Planning Big for this Weekend!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "EASY Sliding Window. No trick applied. It works with simple and intuitive approach "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use Sliding window."
                    }
                ]
            },
            {
                "id": 1883053,
                "content": [
                    {
                        "username": "pushpendra3000",
                        "content": "In the question is explicitly mentioned that length of substring should be of length k. However, in the testcases, it is also counting substrings whose length is less than k.\\n\\nPlease correct this. "
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "there cannot be a substring with length < k that has more vowels than a the max substring of length k..."
                    },
                    {
                        "username": "Peet_code",
                        "content": "it\\'s medium  easy problem"
                    },
                    {
                        "username": "dineshkumar_1708",
                        "content": "what would be the required TC ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "O(n)"
                    },
                    {
                        "username": "Xoxo_szn",
                        "content": "Medium Question on a change,  I think I\\'m getting better :)"
                    },
                    {
                        "username": "rrabbi",
                        "content": "Tried the naïve approach but did not pass the 102nd test case haha\nGot to know about the sliding window algorithm for the first time through discussion, pretty straight forward from there!"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "LC gods have shown mercy this week"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Looks like easy problem under sliding window\n```String         CurrentVowelCount\nabciiidef      0 //initially\nabc            0+1(a)\n bci           1+1(i) -1(a)=1\n  cii          1+1(i) =2\n   iii         2+1(i) =3    (maximum -> Answer)\n    iid        3-1(i) =2\n     ide       2-1(i)+1(e) =2\n      def      2-1(i) =1  ```\n\nPlease try to solve yourself first and can refer hint and solution to the problem:\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3487005/easy-java-sliding-window-approach/"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "leetcode will put bigger hard problems on month end..."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "#### Leetcode Planning Big for this Weekend!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "EASY Sliding Window. No trick applied. It works with simple and intuitive approach "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use Sliding window."
                    }
                ]
            },
            {
                "id": 1883051,
                "content": [
                    {
                        "username": "pushpendra3000",
                        "content": "In the question is explicitly mentioned that length of substring should be of length k. However, in the testcases, it is also counting substrings whose length is less than k.\\n\\nPlease correct this. "
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "there cannot be a substring with length < k that has more vowels than a the max substring of length k..."
                    },
                    {
                        "username": "Peet_code",
                        "content": "it\\'s medium  easy problem"
                    },
                    {
                        "username": "dineshkumar_1708",
                        "content": "what would be the required TC ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "O(n)"
                    },
                    {
                        "username": "Xoxo_szn",
                        "content": "Medium Question on a change,  I think I\\'m getting better :)"
                    },
                    {
                        "username": "rrabbi",
                        "content": "Tried the naïve approach but did not pass the 102nd test case haha\nGot to know about the sliding window algorithm for the first time through discussion, pretty straight forward from there!"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "LC gods have shown mercy this week"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Looks like easy problem under sliding window\n```String         CurrentVowelCount\nabciiidef      0 //initially\nabc            0+1(a)\n bci           1+1(i) -1(a)=1\n  cii          1+1(i) =2\n   iii         2+1(i) =3    (maximum -> Answer)\n    iid        3-1(i) =2\n     ide       2-1(i)+1(e) =2\n      def      2-1(i) =1  ```\n\nPlease try to solve yourself first and can refer hint and solution to the problem:\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3487005/easy-java-sliding-window-approach/"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "leetcode will put bigger hard problems on month end..."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "#### Leetcode Planning Big for this Weekend!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "EASY Sliding Window. No trick applied. It works with simple and intuitive approach "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use Sliding window."
                    }
                ]
            },
            {
                "id": 1882988,
                "content": [
                    {
                        "username": "pushpendra3000",
                        "content": "In the question is explicitly mentioned that length of substring should be of length k. However, in the testcases, it is also counting substrings whose length is less than k.\\n\\nPlease correct this. "
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "there cannot be a substring with length < k that has more vowels than a the max substring of length k..."
                    },
                    {
                        "username": "Peet_code",
                        "content": "it\\'s medium  easy problem"
                    },
                    {
                        "username": "dineshkumar_1708",
                        "content": "what would be the required TC ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "O(n)"
                    },
                    {
                        "username": "Xoxo_szn",
                        "content": "Medium Question on a change,  I think I\\'m getting better :)"
                    },
                    {
                        "username": "rrabbi",
                        "content": "Tried the naïve approach but did not pass the 102nd test case haha\nGot to know about the sliding window algorithm for the first time through discussion, pretty straight forward from there!"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "LC gods have shown mercy this week"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Looks like easy problem under sliding window\n```String         CurrentVowelCount\nabciiidef      0 //initially\nabc            0+1(a)\n bci           1+1(i) -1(a)=1\n  cii          1+1(i) =2\n   iii         2+1(i) =3    (maximum -> Answer)\n    iid        3-1(i) =2\n     ide       2-1(i)+1(e) =2\n      def      2-1(i) =1  ```\n\nPlease try to solve yourself first and can refer hint and solution to the problem:\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3487005/easy-java-sliding-window-approach/"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "leetcode will put bigger hard problems on month end..."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "#### Leetcode Planning Big for this Weekend!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "EASY Sliding Window. No trick applied. It works with simple and intuitive approach "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use Sliding window."
                    }
                ]
            },
            {
                "id": 1882942,
                "content": [
                    {
                        "username": "pushpendra3000",
                        "content": "In the question is explicitly mentioned that length of substring should be of length k. However, in the testcases, it is also counting substrings whose length is less than k.\\n\\nPlease correct this. "
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "there cannot be a substring with length < k that has more vowels than a the max substring of length k..."
                    },
                    {
                        "username": "Peet_code",
                        "content": "it\\'s medium  easy problem"
                    },
                    {
                        "username": "dineshkumar_1708",
                        "content": "what would be the required TC ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "O(n)"
                    },
                    {
                        "username": "Xoxo_szn",
                        "content": "Medium Question on a change,  I think I\\'m getting better :)"
                    },
                    {
                        "username": "rrabbi",
                        "content": "Tried the naïve approach but did not pass the 102nd test case haha\nGot to know about the sliding window algorithm for the first time through discussion, pretty straight forward from there!"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "LC gods have shown mercy this week"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Looks like easy problem under sliding window\n```String         CurrentVowelCount\nabciiidef      0 //initially\nabc            0+1(a)\n bci           1+1(i) -1(a)=1\n  cii          1+1(i) =2\n   iii         2+1(i) =3    (maximum -> Answer)\n    iid        3-1(i) =2\n     ide       2-1(i)+1(e) =2\n      def      2-1(i) =1  ```\n\nPlease try to solve yourself first and can refer hint and solution to the problem:\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3487005/easy-java-sliding-window-approach/"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "leetcode will put bigger hard problems on month end..."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "#### Leetcode Planning Big for this Weekend!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "EASY Sliding Window. No trick applied. It works with simple and intuitive approach "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use Sliding window."
                    }
                ]
            },
            {
                "id": 1882907,
                "content": [
                    {
                        "username": "pushpendra3000",
                        "content": "In the question is explicitly mentioned that length of substring should be of length k. However, in the testcases, it is also counting substrings whose length is less than k.\\n\\nPlease correct this. "
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "there cannot be a substring with length < k that has more vowels than a the max substring of length k..."
                    },
                    {
                        "username": "Peet_code",
                        "content": "it\\'s medium  easy problem"
                    },
                    {
                        "username": "dineshkumar_1708",
                        "content": "what would be the required TC ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "O(n)"
                    },
                    {
                        "username": "Xoxo_szn",
                        "content": "Medium Question on a change,  I think I\\'m getting better :)"
                    },
                    {
                        "username": "rrabbi",
                        "content": "Tried the naïve approach but did not pass the 102nd test case haha\nGot to know about the sliding window algorithm for the first time through discussion, pretty straight forward from there!"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "LC gods have shown mercy this week"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Looks like easy problem under sliding window\n```String         CurrentVowelCount\nabciiidef      0 //initially\nabc            0+1(a)\n bci           1+1(i) -1(a)=1\n  cii          1+1(i) =2\n   iii         2+1(i) =3    (maximum -> Answer)\n    iid        3-1(i) =2\n     ide       2-1(i)+1(e) =2\n      def      2-1(i) =1  ```\n\nPlease try to solve yourself first and can refer hint and solution to the problem:\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3487005/easy-java-sliding-window-approach/"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "leetcode will put bigger hard problems on month end..."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "#### Leetcode Planning Big for this Weekend!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "EASY Sliding Window. No trick applied. It works with simple and intuitive approach "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use Sliding window."
                    }
                ]
            },
            {
                "id": 1882898,
                "content": [
                    {
                        "username": "pushpendra3000",
                        "content": "In the question is explicitly mentioned that length of substring should be of length k. However, in the testcases, it is also counting substrings whose length is less than k.\\n\\nPlease correct this. "
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "there cannot be a substring with length < k that has more vowels than a the max substring of length k..."
                    },
                    {
                        "username": "Peet_code",
                        "content": "it\\'s medium  easy problem"
                    },
                    {
                        "username": "dineshkumar_1708",
                        "content": "what would be the required TC ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "O(n)"
                    },
                    {
                        "username": "Xoxo_szn",
                        "content": "Medium Question on a change,  I think I\\'m getting better :)"
                    },
                    {
                        "username": "rrabbi",
                        "content": "Tried the naïve approach but did not pass the 102nd test case haha\nGot to know about the sliding window algorithm for the first time through discussion, pretty straight forward from there!"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "LC gods have shown mercy this week"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Looks like easy problem under sliding window\n```String         CurrentVowelCount\nabciiidef      0 //initially\nabc            0+1(a)\n bci           1+1(i) -1(a)=1\n  cii          1+1(i) =2\n   iii         2+1(i) =3    (maximum -> Answer)\n    iid        3-1(i) =2\n     ide       2-1(i)+1(e) =2\n      def      2-1(i) =1  ```\n\nPlease try to solve yourself first and can refer hint and solution to the problem:\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3487005/easy-java-sliding-window-approach/"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "leetcode will put bigger hard problems on month end..."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "#### Leetcode Planning Big for this Weekend!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "EASY Sliding Window. No trick applied. It works with simple and intuitive approach "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use Sliding window."
                    }
                ]
            },
            {
                "id": 1882868,
                "content": [
                    {
                        "username": "pushpendra3000",
                        "content": "In the question is explicitly mentioned that length of substring should be of length k. However, in the testcases, it is also counting substrings whose length is less than k.\\n\\nPlease correct this. "
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "there cannot be a substring with length < k that has more vowels than a the max substring of length k..."
                    },
                    {
                        "username": "Peet_code",
                        "content": "it\\'s medium  easy problem"
                    },
                    {
                        "username": "dineshkumar_1708",
                        "content": "what would be the required TC ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "O(n)"
                    },
                    {
                        "username": "Xoxo_szn",
                        "content": "Medium Question on a change,  I think I\\'m getting better :)"
                    },
                    {
                        "username": "rrabbi",
                        "content": "Tried the naïve approach but did not pass the 102nd test case haha\nGot to know about the sliding window algorithm for the first time through discussion, pretty straight forward from there!"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "LC gods have shown mercy this week"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Looks like easy problem under sliding window\n```String         CurrentVowelCount\nabciiidef      0 //initially\nabc            0+1(a)\n bci           1+1(i) -1(a)=1\n  cii          1+1(i) =2\n   iii         2+1(i) =3    (maximum -> Answer)\n    iid        3-1(i) =2\n     ide       2-1(i)+1(e) =2\n      def      2-1(i) =1  ```\n\nPlease try to solve yourself first and can refer hint and solution to the problem:\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3487005/easy-java-sliding-window-approach/"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "leetcode will put bigger hard problems on month end..."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "#### Leetcode Planning Big for this Weekend!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "EASY Sliding Window. No trick applied. It works with simple and intuitive approach "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use Sliding window."
                    }
                ]
            },
            {
                "id": 1882858,
                "content": [
                    {
                        "username": "pushpendra3000",
                        "content": "In the question is explicitly mentioned that length of substring should be of length k. However, in the testcases, it is also counting substrings whose length is less than k.\\n\\nPlease correct this. "
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "there cannot be a substring with length < k that has more vowels than a the max substring of length k..."
                    },
                    {
                        "username": "Peet_code",
                        "content": "it\\'s medium  easy problem"
                    },
                    {
                        "username": "dineshkumar_1708",
                        "content": "what would be the required TC ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "O(n)"
                    },
                    {
                        "username": "Xoxo_szn",
                        "content": "Medium Question on a change,  I think I\\'m getting better :)"
                    },
                    {
                        "username": "rrabbi",
                        "content": "Tried the naïve approach but did not pass the 102nd test case haha\nGot to know about the sliding window algorithm for the first time through discussion, pretty straight forward from there!"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "LC gods have shown mercy this week"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Looks like easy problem under sliding window\n```String         CurrentVowelCount\nabciiidef      0 //initially\nabc            0+1(a)\n bci           1+1(i) -1(a)=1\n  cii          1+1(i) =2\n   iii         2+1(i) =3    (maximum -> Answer)\n    iid        3-1(i) =2\n     ide       2-1(i)+1(e) =2\n      def      2-1(i) =1  ```\n\nPlease try to solve yourself first and can refer hint and solution to the problem:\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3487005/easy-java-sliding-window-approach/"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "leetcode will put bigger hard problems on month end..."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "#### Leetcode Planning Big for this Weekend!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "EASY Sliding Window. No trick applied. It works with simple and intuitive approach "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use Sliding window."
                    }
                ]
            },
            {
                "id": 1882821,
                "content": [
                    {
                        "username": "pushpendra3000",
                        "content": "In the question is explicitly mentioned that length of substring should be of length k. However, in the testcases, it is also counting substrings whose length is less than k.\\n\\nPlease correct this. "
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "there cannot be a substring with length < k that has more vowels than a the max substring of length k..."
                    },
                    {
                        "username": "Peet_code",
                        "content": "it\\'s medium  easy problem"
                    },
                    {
                        "username": "dineshkumar_1708",
                        "content": "what would be the required TC ?"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "O(n)"
                    },
                    {
                        "username": "Xoxo_szn",
                        "content": "Medium Question on a change,  I think I\\'m getting better :)"
                    },
                    {
                        "username": "rrabbi",
                        "content": "Tried the naïve approach but did not pass the 102nd test case haha\nGot to know about the sliding window algorithm for the first time through discussion, pretty straight forward from there!"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "LC gods have shown mercy this week"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Looks like easy problem under sliding window\n```String         CurrentVowelCount\nabciiidef      0 //initially\nabc            0+1(a)\n bci           1+1(i) -1(a)=1\n  cii          1+1(i) =2\n   iii         2+1(i) =3    (maximum -> Answer)\n    iid        3-1(i) =2\n     ide       2-1(i)+1(e) =2\n      def      2-1(i) =1  ```\n\nPlease try to solve yourself first and can refer hint and solution to the problem:\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3487005/easy-java-sliding-window-approach/"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "leetcode will put bigger hard problems on month end..."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "#### Leetcode Planning Big for this Weekend!"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "EASY Sliding Window. No trick applied. It works with simple and intuitive approach "
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Use Sliding window."
                    }
                ]
            }
        ]
    },
    {
        "title": "Pseudo-Palindromic Paths in a Binary Tree",
        "question_content": "<p>Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be <strong>pseudo-palindromic</strong> if at least one permutation of the node values in the path is a palindrome.</p>\n\n<p><em>Return the number of <strong>pseudo-palindromic</strong> paths going from the root node to leaf nodes.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/05/06/palindromic_paths_1.png\" style=\"width: 300px; height: 201px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [2,3,1,3,1,null,1]\n<strong>Output:</strong> 2 \n<strong>Explanation:</strong> The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/05/07/palindromic_paths_2.png\" style=\"width: 300px; height: 314px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> root = [2,1,1,1,3,null,null,null,null,null,1]\n<strong>Output:</strong> 1 \n<strong>Explanation:</strong> The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [9]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 9</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 648534,
                "title": "java-c-python-at-most-one-odd-occurrence",
                "content": "# **Intuition**\\nThe necessar and suffisant condition of pseudo-palindromic,\\nis that at most one digit has odd occurrence.\\n<br>\\n\\n# **Solution 1: Use Array**\\nRecursively iterate all paths from root to leaves,\\ncount the occurrence of each digits in an **array**.\\nAt the leaf node, check if at most one digit has odd occurrence.\\n\\nTime `O(NK)`\\nSpace `O(K + H)`\\nwhere K is the number of different elements,\\n`H` is the height.\\nIn this problem, `K = 9`\\n<br>\\n\\n# **Solution 2: Use HashSet**\\nRecursively iterate all paths from root to leaves,\\ncount the occurrence of each digits in an **hashset**.\\n\\nWhenever meet an element, toggle it in the set:\\nIf set contains it, remove it.\\nIf set donesn\\'t contain it, add it.\\n\\nAt the leaf node, check if the size of set <= 1.\\n\\nTime `O(N)`\\nSpace `O(K + H)`\\n<br>\\n\\n\\n# **Solution 3: Use an integer**\\nRecursively iterate all paths from root to leaves,\\ncount the occurrence of each digits in an **integer**.\\n\\nUse this integer as a bit mask.\\nAlso c++, we can use bitmask directly.\\n\\nWhenever meet an element,\\ntoggle the corresponding bit using `^` operation.\\n\\n\\nAt the leaf node,\\ncheck if the count has only one bit that is 1.\\n\\nWe use lowbit to help count this.\\nGoogle it if you don\\'t know.\\n\\nTime `O(N)`\\nSpace `O(K + H)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n\\n    private int dfs(TreeNode root, int count) {\\n        if (root == null) return 0;\\n        count ^= 1 << (root.val - 1);\\n        int res = dfs(root.left, count) + dfs(root.right, count);\\n        if (root.left == root.right && (count & (count - 1)) == 0) res++;\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int pseudoPalindromicPaths(TreeNode* root, int count = 0) {\\n        if (!root) return 0;\\n        count ^= 1 << (root->val - 1);\\n        int res = pseudoPalindromicPaths(root->left, count) + pseudoPalindromicPaths(root->right, count);\\n        if (root->left == root->right && (count & (count - 1)) == 0) res++;\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def pseudoPalindromicPaths(self, root, count = 0):\\n        if not root: return 0\\n        count ^= 1 << (root.val - 1)\\n        res = self.pseudoPalindromicPaths(root.left, count) + self.pseudoPalindromicPaths(root.right, count)\\n        if root.left == root.right:\\n            if count & (count - 1) == 0:\\n                res += 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n\\n    private int dfs(TreeNode root, int count) {\\n        if (root == null) return 0;\\n        count ^= 1 << (root.val - 1);\\n        int res = dfs(root.left, count) + dfs(root.right, count);\\n        if (root.left == root.right && (count & (count - 1)) == 0) res++;\\n        return res;\\n    }\\n```\n```cpp\\n    int pseudoPalindromicPaths(TreeNode* root, int count = 0) {\\n        if (!root) return 0;\\n        count ^= 1 << (root->val - 1);\\n        int res = pseudoPalindromicPaths(root->left, count) + pseudoPalindromicPaths(root->right, count);\\n        if (root->left == root->right && (count & (count - 1)) == 0) res++;\\n        return res;\\n    }\\n```\n```py\\n    def pseudoPalindromicPaths(self, root, count = 0):\\n        if not root: return 0\\n        count ^= 1 << (root.val - 1)\\n        res = self.pseudoPalindromicPaths(root.left, count) + self.pseudoPalindromicPaths(root.right, count)\\n        if root.left == root.right:\\n            if count & (count - 1) == 0:\\n                res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 648517,
                "title": "palindrome-property-trick-java-solution-explained",
                "content": "Note that we maintain a count array of size 9 (numbers 1 to 9).\\nThe array stores the count of each number in the tree path from root to leaf.\\n\\n**Steps** - \\n\\t- Traverse the tree from root to all the path. Normal tree traversal.\\n\\tKeep track of count of all the numbers in every path from root to leaf. \\n\\t- When we reach the leaf, we have to check if current path is pseudo random palindrome or not.\\n**Trick**\\n- We know that in palindrome,every number occurs **even** number of times .\\n- But  in odd length palindrome, **only** one number can occur odd number of times.\\nWe have used that property in **isPalindrome** method to check if numbers are pseudo palindrome or not.\\n```\\nclass Solution {\\n    int result = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] map = new int[10];\\n        findPesudoPalindromUtil(root,map);\\n        return result;\\n    }\\n    \\n    void findPesudoPalindromUtil(TreeNode root,int[] map){\\n       \\n        if(root == null){\\n            return;\\n        }\\n         map[root.val] = map[root.val]+1;\\n         if(root.left == null && root.right == null){\\n             if(isPalindrome(map))\\n                result++;\\n        }\\n       \\n        findPesudoPalindromUtil(root.left,map);\\n        findPesudoPalindromUtil(root.right,map);\\n        //backtrack\\n        map[root.val] = map[root.val]-1;\\n       \\n        \\n    }\\n    boolean isPalindrome(int[] map){\\n        int miss = 0;\\n        for(int i=0;i<=9;i++){\\n            if(map[i] % 2 != 0)\\n                miss++;\\n            if(miss > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] map = new int[10];\\n        findPesudoPalindromUtil(root,map);\\n        return result;\\n    }\\n    \\n    void findPesudoPalindromUtil(TreeNode root,int[] map){\\n       \\n        if(root == null){\\n            return;\\n        }\\n         map[root.val] = map[root.val]+1;\\n         if(root.left == null && root.right == null){\\n             if(isPalindrome(map))\\n                result++;\\n        }\\n       \\n        findPesudoPalindromUtil(root.left,map);\\n        findPesudoPalindromUtil(root.right,map);\\n        //backtrack\\n        map[root.val] = map[root.val]-1;\\n       \\n        \\n    }\\n    boolean isPalindrome(int[] map){\\n        int miss = 0;\\n        for(int i=0;i<=9;i++){\\n            if(map[i] % 2 != 0)\\n                miss++;\\n            if(miss > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573237,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n**C++**\\n\\n```cpp\\n// Time Complexity: O(N) where N is the number of nodes\\n// Space Complexity: O(H) where H is the tree height\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    // the idea is that there is at most one digit with odd frequency in pseudo-palindromic path\\n    // e.g. [2, 3, 3] - digit 2 has odd frequency\\n    // e.g. [9] - digit 9 has odd frequency\\n    // so that the digit with odd frequency can be put in the middle, e.g. 323, 9, etc\\n\\t// e.g. [2,2] - or no digit with odd frequency\\n\\t\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        preorder(root, 0);\\n        return ans;\\n    }\\n    \\n    // if you don\\'t know preorder traversal, try 144. Binary Tree Preorder Traversal first\\n    // Problem Link: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n    // Explanation Link: https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/2549333/LeetCode-The-Hard-Way-DFS-or-Pre-Order-or-Explained-Line-By-Line\\n    void preorder(TreeNode* node, int cnt) {\\n        // preorder traversal step 1: if node is null, then return\\n        if (node == NULL) return;\\n        // preorder traversal step 2: do something with node value here\\n        \\n        // first let\\'s understand what (x << y) means \\n        // (x << y): shifting `x` `y` bits to the left\\n        // e.g. 1 << 0 = 1 (shift 0 bit - stay as it is)\\n        // e.g. 1 << 1 = 0b10 (shift 1 bit - becomes 2)\\n        // e.g. 1 << 2 = 0b100 (shift 2 bits to the left - becomes 4)\\n        // you may find that (1 << n) is actually just power of 2. i.e. 2 ^ n\\n        \\n        // second let\\'s understand three properties of XOR\\n        // 1. XOR is self-inverse which means x ^ x = 0 (number XOR number evaluates to 0)\\n        // 2. 0 is identity element which means x ^ 0 = x (number XOR 0 remains unchanged)\\n        // 3. XOR is commutative, which means x ^ y = y ^ x (order doesn\\'t matter)\\n        \\n        // we can use (1 << i) to set the appearance of digit i\\n        // but how to count the odd frequency? \\n        // we can use above XOR properties to achieve the following \\n        // if the i-bit is set, then digit i has an odd frequency\\n        // how? remember XOR property #1, #2, and #3?\\n        // if a digit appears even number of times, the bit at the end will be 0. (x ^ x = 0)\\n        // if a digit appears odd number of times, the bit at the will be 1. (x ^ x ^ x = (x ^ x) ^ x = 0 ^ x = x)\\n        cnt ^= (1 << node->val);\\n        // do something at the leaf\\n        if (!node->left && !node->right) {\\n            // if i-bit is set in `cnt`, that means digit `i` has an odd frequency\\n            // therefore, the number of 1 in `cnt` = the number of digits with an odd frequency\\n            // however, we only want at most one digit that has an odd frequency\\n            // we can use a bit trick (n & (n - 1)) to remove the rightmost set bit.\\n            // e.g. \\n            // n     n     n - 1  n & (n - 1)\\n            // --   ----   ----   -------\\n            //  0   0000   0111    0000\\n            //  1   0001   0000    0000\\n            //  2   0010   0001    0000\\n            //  3   0011   0010    0010\\n            //  4   0100   0011    0000\\n            //  5   0101   0100    0100\\n            //  6   0110   0101    0100\\n            //  7   0111   0110    0110\\n            //  8   1000   0111    0000 \\n            //  9   1001   1000    1000\\n            // 10   1010   1001    1000\\n            // 11   1011   1010    1010\\n            // 12   1100   1011    1000\\n            // 13   1101   1100    1100\\n            // 14   1110   1101    1100\\n            // 15   1111   1110    1110\\n            \\n            // if the result is 0, that means we have at most one digit that has an odd frequncy \\n            // hence, add one to ans\\n\\t\\t\\t// alternatively, you can use __builtin_popcount(cnt) <= 1 to check\\n            ans += (cnt & (cnt - 1)) == 0;\\n        }\\n        // preorder traversal step 3: traverse the left node\\n        preorder(node->left, cnt);\\n        // preorder traversal step 4: traverse the right node\\n        preorder(node->right, cnt);\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```py\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode], cnt = 0) -> int:\\n        if not root: return 0\\n        cnt ^= 1 << (root.val - 1)\\n        if root.left is None and root.right is None:\\n            return 1 if cnt & (cnt - 1) == 0 else 0\\n        return self.pseudoPalindromicPaths(root.left, cnt) + self.pseudoPalindromicPaths(root.right, cnt)\\n```\\n\\n**Go**\\n\\n```go\\nfunc numberOfOnes(n int) int{\\n   res := 0\\n   for n > 0 {\\n      res += n & 1\\n      n >>= 1\\n   }\\n   return res\\n}\\n\\nfunc preorder(root *TreeNode, cnt int) int {\\n    if root == nil { return 0 }\\n    cnt ^= (1 << root.Val)\\n    if root.Left == nil && root.Right == nil && numberOfOnes(cnt) <= 1  { return 1 }\\n    return preorder(root.Left, cnt) + preorder(root.Right, cnt)\\n}\\n\\nfunc pseudoPalindromicPaths (root *TreeNode) int {\\n    return preorder(root, 0)\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\n// Time Complexity: O(N) where N is the number of nodes\\n// Space Complexity: O(H) where H is the tree height\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    // the idea is that there is at most one digit with odd frequency in pseudo-palindromic path\\n    // e.g. [2, 3, 3] - digit 2 has odd frequency\\n    // e.g. [9] - digit 9 has odd frequency\\n    // so that the digit with odd frequency can be put in the middle, e.g. 323, 9, etc\\n\\t// e.g. [2,2] - or no digit with odd frequency\\n\\t\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        preorder(root, 0);\\n        return ans;\\n    }\\n    \\n    // if you don\\'t know preorder traversal, try 144. Binary Tree Preorder Traversal first\\n    // Problem Link: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n    // Explanation Link: https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/2549333/LeetCode-The-Hard-Way-DFS-or-Pre-Order-or-Explained-Line-By-Line\\n    void preorder(TreeNode* node, int cnt) {\\n        // preorder traversal step 1: if node is null, then return\\n        if (node == NULL) return;\\n        // preorder traversal step 2: do something with node value here\\n        \\n        // first let\\'s understand what (x << y) means \\n        // (x << y): shifting `x` `y` bits to the left\\n        // e.g. 1 << 0 = 1 (shift 0 bit - stay as it is)\\n        // e.g. 1 << 1 = 0b10 (shift 1 bit - becomes 2)\\n        // e.g. 1 << 2 = 0b100 (shift 2 bits to the left - becomes 4)\\n        // you may find that (1 << n) is actually just power of 2. i.e. 2 ^ n\\n        \\n        // second let\\'s understand three properties of XOR\\n        // 1. XOR is self-inverse which means x ^ x = 0 (number XOR number evaluates to 0)\\n        // 2. 0 is identity element which means x ^ 0 = x (number XOR 0 remains unchanged)\\n        // 3. XOR is commutative, which means x ^ y = y ^ x (order doesn\\'t matter)\\n        \\n        // we can use (1 << i) to set the appearance of digit i\\n        // but how to count the odd frequency? \\n        // we can use above XOR properties to achieve the following \\n        // if the i-bit is set, then digit i has an odd frequency\\n        // how? remember XOR property #1, #2, and #3?\\n        // if a digit appears even number of times, the bit at the end will be 0. (x ^ x = 0)\\n        // if a digit appears odd number of times, the bit at the will be 1. (x ^ x ^ x = (x ^ x) ^ x = 0 ^ x = x)\\n        cnt ^= (1 << node->val);\\n        // do something at the leaf\\n        if (!node->left && !node->right) {\\n            // if i-bit is set in `cnt`, that means digit `i` has an odd frequency\\n            // therefore, the number of 1 in `cnt` = the number of digits with an odd frequency\\n            // however, we only want at most one digit that has an odd frequency\\n            // we can use a bit trick (n & (n - 1)) to remove the rightmost set bit.\\n            // e.g. \\n            // n     n     n - 1  n & (n - 1)\\n            // --   ----   ----   -------\\n            //  0   0000   0111    0000\\n            //  1   0001   0000    0000\\n            //  2   0010   0001    0000\\n            //  3   0011   0010    0010\\n            //  4   0100   0011    0000\\n            //  5   0101   0100    0100\\n            //  6   0110   0101    0100\\n            //  7   0111   0110    0110\\n            //  8   1000   0111    0000 \\n            //  9   1001   1000    1000\\n            // 10   1010   1001    1000\\n            // 11   1011   1010    1010\\n            // 12   1100   1011    1000\\n            // 13   1101   1100    1100\\n            // 14   1110   1101    1100\\n            // 15   1111   1110    1110\\n            \\n            // if the result is 0, that means we have at most one digit that has an odd frequncy \\n            // hence, add one to ans\\n\\t\\t\\t// alternatively, you can use __builtin_popcount(cnt) <= 1 to check\\n            ans += (cnt & (cnt - 1)) == 0;\\n        }\\n        // preorder traversal step 3: traverse the left node\\n        preorder(node->left, cnt);\\n        // preorder traversal step 4: traverse the right node\\n        preorder(node->right, cnt);\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode], cnt = 0) -> int:\\n        if not root: return 0\\n        cnt ^= 1 << (root.val - 1)\\n        if root.left is None and root.right is None:\\n            return 1 if cnt & (cnt - 1) == 0 else 0\\n        return self.pseudoPalindromicPaths(root.left, cnt) + self.pseudoPalindromicPaths(root.right, cnt)\\n```\n```go\\nfunc numberOfOnes(n int) int{\\n   res := 0\\n   for n > 0 {\\n      res += n & 1\\n      n >>= 1\\n   }\\n   return res\\n}\\n\\nfunc preorder(root *TreeNode, cnt int) int {\\n    if root == nil { return 0 }\\n    cnt ^= (1 << root.Val)\\n    if root.Left == nil && root.Right == nil && numberOfOnes(cnt) <= 1  { return 1 }\\n    return preorder(root.Left, cnt) + preorder(root.Right, cnt)\\n}\\n\\nfunc pseudoPalindromicPaths (root *TreeNode) int {\\n    return preorder(root, 0)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991861,
                "title": "c-super-simple-easy-recursive-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root) {\\n        if (!root)\\n            return;\\n        \\n        m[root->val]++;\\n        \\n        // If we got to a leaf - check if the path can be a polindrome\\n        if (!root->left && !root->right) {\\n            int odd = 0;\\n            for (auto a : m)\\n                if (a.second % 2 == 1)\\n                    odd++;\\n\\n            if (odd <= 1)\\n                res++;\\n        }\\n        \\n        rec(root->left);\\n        rec(root->right);\\n        m[root->val]--;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        rec(root);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n    unordered_map<int, int> m;\\n};\\n```\\n**Like it? please upvote...\\nHave any comments? I\\'d love to hear!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(TreeNode* root) {\\n        if (!root)\\n            return;\\n        \\n        m[root->val]++;\\n        \\n        // If we got to a leaf - check if the path can be a polindrome\\n        if (!root->left && !root->right) {\\n            int odd = 0;\\n            for (auto a : m)\\n                if (a.second % 2 == 1)\\n                    odd++;\\n\\n            if (odd <= 1)\\n                res++;\\n        }\\n        \\n        rec(root->left);\\n        rec(root->right);\\n        m[root->val]--;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        rec(root);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n    unordered_map<int, int> m;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573170,
                "title": "python-dfs-set-with-explanation-easy-to-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        # traverse the tree, the set pairs maintains the number of each element\\n        # If you already have the same element in pairs, then remove it\\n        # Else, add it to pairs\\n\\n        # In the leaf, if the set is empty, then its an even palindrome.\\n        # In the leaf, if the set has 1 element , its an odd palindrome.\\n        # In th leaf, if the set has > 1 elements, its not a palindrome.\\n        \\n        def traverse(node, pairs):\\n            if not node:\\n                return 0\\n            \\n            if node.val in pairs:\\n                pairs.remove(node.val)\\n            else:\\n                pairs.add(node.val)\\n            \\n            if not node.left and not node.right:\\n                return 1 if len(pairs) <= 1 else 0\\n            \\n            # correct!!\\n            left = traverse(node.left, set(pairs))\\n            right = traverse(node.right, set(pairs))\\n            \\n            # wrong, becasue pairs will change after we traversed node.left or node.right!\\n            # left = traverse(node.left, pairs)\\n            # right = traverse(node.right, pairs)\\n            \\n            return left + right\\n        \\n        return traverse(root, set())",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        # traverse the tree, the set pairs maintains the number of each element\\n        # If you already have the same element in pairs, then remove it\\n        # Else, add it to pairs\\n\\n        # In the leaf, if the set is empty, then its an even palindrome.\\n        # In the leaf, if the set has 1 element , its an odd palindrome.\\n        # In th leaf, if the set has > 1 elements, its not a palindrome.\\n        \\n        def traverse(node, pairs):\\n            if not node:\\n                return 0\\n            \\n            if node.val in pairs:\\n                pairs.remove(node.val)\\n            else:\\n                pairs.add(node.val)\\n            \\n            if not node.left and not node.right:\\n                return 1 if len(pairs) <= 1 else 0\\n            \\n            # correct!!\\n            left = traverse(node.left, set(pairs))\\n            right = traverse(node.right, set(pairs))\\n            \\n            # wrong, becasue pairs will change after we traversed node.left or node.right!\\n            # left = traverse(node.left, pairs)\\n            # right = traverse(node.right, pairs)\\n            \\n            return left + right\\n        \\n        return traverse(root, set())",
                "codeTag": "Java"
            },
            {
                "id": 648304,
                "title": "c-dfs-bitvector",
                "content": "**Observation**\\nTo check if any permutaion of numbers can make a palindrome all we need to do is check if we have even count of all numbers and at max one odd count (for odd palindromes with a center with single number). eg: 121.\\nWe can easily do this by using a bit vector to store the parity of the counts of numbers (even or odd).\\nAll we need to do now is maintain this bit vector while traversing down the tree in a dfs fashion and check at leaf nodes if we can create a palindrome.\\nNote that XOR operation comes in handy in such cases, to flip the bits.\\n\\n**Solution**\\n```c++\\nclass Solution {\\npublic:\\n    int count=0;\\n    void dfs(TreeNode* root,int bitVec) {\\n        if(!root)\\n            return;\\n        if(!root->left&&!root->right) {  // Leaf node.\\n            count+=__builtin_popcount(bitVec^(1<<root->val))<=1;//Check if number of 1\\'s in the bit vector is <=1 (Only 1 odd number).\\n            return;\\n        }\\n        dfs(root->left,bitVec^(1<<root->val)),dfs(root->right,bitVec^(1<<root->val));\\t//DFS to the left and right node and updating the bit vector\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root,0);\\n        return count;\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(1)` for bit vector, `O(h)` for recursion stack where `h` is the height of the tree.\\nTime `O(n)`.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int count=0;\\n    void dfs(TreeNode* root,int bitVec) {\\n        if(!root)\\n            return;\\n        if(!root->left&&!root->right) {  // Leaf node.\\n            count+=__builtin_popcount(bitVec^(1<<root->val))<=1;//Check if number of 1\\'s in the bit vector is <=1 (Only 1 odd number).\\n            return;\\n        }\\n        dfs(root->left,bitVec^(1<<root->val)),dfs(root->right,bitVec^(1<<root->val));\\t//DFS to the left and right node and updating the bit vector\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root,0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573415,
                "title": "c-dfs-bit-manipulation-solution",
                "content": "**If you like it, please give a star, to my [Github](https://github.com/champmaniac/LeetCode) Repository and upvote this post.**\\n\\n**Intuition:**\\nSince we need to return the number of pseudo-palindromic paths going from the root node to leaf nodes, so we know that seeing tree problems, first thing that should hit our brain is? what is it? Yessss its **Recursion.**\\n\\n**Approach:**\\n* So first, **recursively** iterate all paths from **root** to **leaves**, and count the occurrence of each digits in an integer (**count**=0, initiallly).\\n* Will be using count as a **bit mask**.\\n* Whenever we meet an element, we just toggle the corresponding bit using **^**(`XOR`) operation.\\n* At the leaf node, we check if the count has only one bit that is 1, we use `lowbit` to count this.\\nBasically this thing :- `(count & (count - 1)) == 0)`\\n\\n**C++:**\\n```\\nclass Solution{\\npublic:\\n  int pseudoPalindromicPaths(TreeNode *root, int count = 0){\\n    // dfs way to find the number of pseudo palindromic paths\\n    if (!root)\\n      return 0;\\n    count ^= 1 << root->val;\\n    int res = pseudoPalindromicPaths(root->left, count) + pseudoPalindromicPaths(root->right, count);\\n    if (!root->left && !root->right && (count & (count - 1)) == 0)\\n      res++;\\n    return res;\\n  }\\n```\\n****\\n**Time Complexity:** **O(N)**\\n**Space Complexity:** **O(K+H)**\\n****\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n  int pseudoPalindromicPaths(TreeNode *root, int count = 0){\\n    // dfs way to find the number of pseudo palindromic paths\\n    if (!root)\\n      return 0;\\n    count ^= 1 << root->val;\\n    int res = pseudoPalindromicPaths(root->left, count) + pseudoPalindromicPaths(root->right, count);\\n    if (!root->left && !root->right && (count & (count - 1)) == 0)\\n      res++;\\n    return res;\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648345,
                "title": "java-dfs-set-recursion",
                "content": "Straight forward implementation with recursion. Did not want to iterate over int[9] at the leaf node...\\n\\n```\\npublic int pseudoPalindromicPaths (TreeNode root) {\\n        return canBePalindrome(root,new HashSet());\\n    }\\n    \\n    private int canBePalindrome(TreeNode node,Set<Integer> numbers){\\n        if(node==null) return 0;\\n        if(numbers.contains(node.val)){\\n            numbers.remove(node.val);\\n        }else{\\n            numbers.add(node.val);\\n        }\\n        if(node.left==null&& node.right==null){\\n            return numbers.size()<=1?1:0; // thanks to @MananS77\\n        }\\n        int left=canBePalindrome(node.left,new HashSet(numbers));\\n        int right=canBePalindrome(node.right,new HashSet(numbers));\\n        return left+right;\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\npublic int pseudoPalindromicPaths (TreeNode root) {\\n        return canBePalindrome(root,new HashSet());\\n    }\\n    \\n    private int canBePalindrome(TreeNode node,Set<Integer> numbers){\\n        if(node==null) return 0;\\n        if(numbers.contains(node.val)){\\n            numbers.remove(node.val);\\n        }else{\\n            numbers.add(node.val);\\n        }\\n        if(node.left==null&& node.right==null){\\n            return numbers.size()<=1?1:0; // thanks to @MananS77\\n        }\\n        int left=canBePalindrome(node.left,new HashSet(numbers));\\n        int right=canBePalindrome(node.right,new HashSet(numbers));\\n        return left+right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2432635,
                "title": "c-three-approaches-explained-easy-understanding",
                "content": "1) Approach using map(Brute Force)-We store the frequency of elements in map and whenever we reach leaf, we check if there are more than 1 elements with odd frequency \\nif yes, i.e. not a pseudo palindrome \\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void countPaths(TreeNode* root, unordered_map<int,int>&m){\\n        m[root->val]++;\\n        if(!root->left && !root->right){\\n            int count=0;\\n            for(auto it:m) {\\n                if(it.second%2!=0) count++;\\n            }\\n            if(count<=1) ans++;\\n            m[root->val]--;\\n            return ;\\n        }\\n        if(root->left) countPaths(root->left,m);\\n        if(root->right) countPaths(root->right,m);\\n        m[root->val]--;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        if(!root) return 0;\\n        unordered_map<int,int>m;\\n        countPaths(root,m);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n 2) Approach using set(Optimized the space used in map)-Whenever we encounter an element, we check if it is already in set,if yes we remove it from set \\nelse we insert it into set. Thus, set basically contains only those elements that have occurred odd no. of times yet. On reaching leaf, we check\\nif size of set<=1 i.e. it is a pseudo palindrome \\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    void countPaths(TreeNode* root, set<int>s){\\n        if(s.find(root->val)!=s.end()) s.erase(root->val);\\n        else s.insert(root->val);\\n        if(!root->left && !root->right) {\\n            if(s.size()<=1) ans++;\\n            return;\\n        }\\n        if(root->left) countPaths(root->left,s);\\n        if(root->right) countPaths(root->right,s);\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n       if(!root) return 0;\\n        set<int> s;\\n        countPaths(root,s);\\n        return ans;\\n    }\\n};\\n```\\n\\n3)Approach using XOR/Bit Manipulation (Not very intuitive, most optimal )- We need to store the frequency of digits from 1 to 9, so instead of using any \\nextra space, we store frequency of i in the ith bit(by 1<<i). We take a path variable initialised with 0 and whenever we encounter x, we XOR path with (1<<x)\\ni.e. now xth bit keeps juggling between 0 and 1, 0 whenever it has occurred even no. of times and 1 in case of odd. \\nAt the end , if there\\'s <=1 odd occuring no.s, then path will be power of 2 i.e. of the form 000000000 or 000100000(having single 1) .\\nOtherwise if there are more than 1 no.s occuring odd no. of times, it will be of the type 000100010(having multiple 1s). \\nSo, we use (path & (path-1)) ==0 to check if no. is power of 2 \\n```\\nclass Solution {\\npublic:\\n    int ans=0;    \\n    void countPaths(TreeNode* root, int path){\\n        path^=(1<<root->val);\\n        if(!root->left && !root->right){\\n            if((path & (path-1))==0) ans++;\\n            return;\\n        }\\n        if(root->left) countPaths(root->left,path);\\n        if(root->right) countPaths(root->right,path);\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n      if(!root) return 0;\\n        countPaths(root,0);\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you found this useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void countPaths(TreeNode* root, unordered_map<int,int>&m){\\n        m[root->val]++;\\n        if(!root->left && !root->right){\\n            int count=0;\\n            for(auto it:m) {\\n                if(it.second%2!=0) count++;\\n            }\\n            if(count<=1) ans++;\\n            m[root->val]--;\\n            return ;\\n        }\\n        if(root->left) countPaths(root->left,m);\\n        if(root->right) countPaths(root->right,m);\\n        m[root->val]--;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        if(!root) return 0;\\n        unordered_map<int,int>m;\\n        countPaths(root,m);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    void countPaths(TreeNode* root, set<int>s){\\n        if(s.find(root->val)!=s.end()) s.erase(root->val);\\n        else s.insert(root->val);\\n        if(!root->left && !root->right) {\\n            if(s.size()<=1) ans++;\\n            return;\\n        }\\n        if(root->left) countPaths(root->left,s);\\n        if(root->right) countPaths(root->right,s);\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n       if(!root) return 0;\\n        set<int> s;\\n        countPaths(root,s);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int ans=0;    \\n    void countPaths(TreeNode* root, int path){\\n        path^=(1<<root->val);\\n        if(!root->left && !root->right){\\n            if((path & (path-1))==0) ans++;\\n            return;\\n        }\\n        if(root->left) countPaths(root->left,path);\\n        if(root->right) countPaths(root->right,path);\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n      if(!root) return 0;\\n        countPaths(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648266,
                "title": "c-counting",
                "content": "We count how many of each digit we got in each path in the `cnt` array. A pseudo-palindromic path is when we have zero or one digit with the odd count.\\n\\nWe can track the number of `odds` as we increment and decrement count of each digit. It makes it a bit faster than scan the array when we reach each leaf.\\n\\n```cpp    \\nint cnt[10] = {};\\nint pseudoPalindromicPaths(TreeNode* n, int odds = 0, int res = 0) {\\n    if (n != nullptr) {\\n        odds += ++cnt[n->val] % 2 ? 1 : -1;\\n        if (n->left == n->right)\\n            res = odds < 2 ? 1 : 0;\\n        else\\n            res = pseudoPalindromicPaths(n->left, odds) \\n                + pseudoPalindromicPaths(n->right, odds);\\n        odds += --cnt[n->val] % 2 ? -1 : 1;\\n    }\\n    return res;\\n}\\n```\\n\\n**Complexity Analysis**\\n- Time: O(n), we do through the each tree node exactly once.\\n- Memory: O(h) for the recursion, where *h* is the height of the tree.",
                "solutionTags": [],
                "code": "```cpp    \\nint cnt[10] = {};\\nint pseudoPalindromicPaths(TreeNode* n, int odds = 0, int res = 0) {\\n    if (n != nullptr) {\\n        odds += ++cnt[n->val] % 2 ? 1 : -1;\\n        if (n->left == n->right)\\n            res = odds < 2 ? 1 : 0;\\n        else\\n            res = pseudoPalindromicPaths(n->left, odds) \\n                + pseudoPalindromicPaths(n->right, odds);\\n        odds += --cnt[n->val] % 2 ? -1 : 1;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 649959,
                "title": "python-o-n-time-and-o-k-h-space-dfs-preorder-traversal-explained",
                "content": "First note, that pseudo-palindromic path mean that it has all occurunces of digits even, may be except one: like 11223 can be written as 12321 and 111444 can not, because it has two digits with odd occurences. So, for each leaf we need to evaluate occurences of all digits and count it only if number of odd occurences is <=1.\\n\\nLet ```dict_freq``` be a frequences dictionary for digits, where we keep 0 if we meet digit even number of times and 1 if we meet digit odd number of times. Let ```Pal``` be a variable, which counts number of odd frequences in ```dict_freq```: we want to find all leafs, for which this value is <= 1.\\n\\nNow, what we do is simple dfs: preorder traversal. Because ```dict_freq``` is global variable and we change it in our recursion, we need to change back it values, when we go outside of recursion (note, that in some other solutions, which use bit manipulations, it is not necessary,  but here we need to do like this). Finally, because we do only O(1) operations for each node, we have O(n) time complexity. We have O(k+H) space complexity, where H is the height of tree and k is number of digits (here k = 9) to maintain implicit stack and ```dict_freq``` dictionary.\\n\\n\\n```\\nclass Solution:\\n    def dfs(self, root):\\n        if not root: return\\n        \\n        cur, pal = self.dict_freq[root.val], self.Pal\\n        \\n        self.Pal = self.Pal - 1 if cur == 1 else self.Pal + 1\\n        self.dict_freq[root.val] = (cur + 1) % 2\\n        \\n        if not root.left and not root.right and self.Pal <= 1:\\n            self.Res += 1\\n        \\n        self.dfs(root.left)\\n        self.dfs(root.right)\\n            \\n        self.Pal, self.dict_freq[root.val] = pal, cur\\n            \\n    def pseudoPalindromicPaths (self, root):\\n        self.dict_freq = defaultdict(int)\\n        self.Pal, self.Res = 0, 0\\n        self.dfs(root)\\n        return self.Res\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```dict_freq```\n```Pal```\n```dict_freq```\n```dict_freq```\n```dict_freq```\n```\\nclass Solution:\\n    def dfs(self, root):\\n        if not root: return\\n        \\n        cur, pal = self.dict_freq[root.val], self.Pal\\n        \\n        self.Pal = self.Pal - 1 if cur == 1 else self.Pal + 1\\n        self.dict_freq[root.val] = (cur + 1) % 2\\n        \\n        if not root.left and not root.right and self.Pal <= 1:\\n            self.Res += 1\\n        \\n        self.dfs(root.left)\\n        self.dfs(root.right)\\n            \\n        self.Pal, self.dict_freq[root.val] = pal, cur\\n            \\n    def pseudoPalindromicPaths (self, root):\\n        self.dict_freq = defaultdict(int)\\n        self.Pal, self.Res = 0, 0\\n        self.dfs(root)\\n        return self.Res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573276,
                "title": "java-dfs-and-bit-manipulation-100-faster-code-beginner-friendly",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    int ans = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        ans = 0;\\n        dfs(root, 0);\\n        return ans;\\n    }\\n    private void dfs(TreeNode root, int count) {\\n        if (root == null) return;\\n        count ^= 1 << (root.val - 1);\\n        dfs(root.left, count);\\n        dfs(root.right, count);\\n        if (root.left == null && root.right ==  null && (count & (count - 1)) == 0) ans++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        ans = 0;\\n        dfs(root, 0);\\n        return ans;\\n    }\\n    private void dfs(TreeNode root, int count) {\\n        if (root == null) return;\\n        count ^= 1 << (root.val - 1);\\n        dfs(root.left, count);\\n        dfs(root.right, count);\\n        if (root.left == null && root.right ==  null && (count & (count - 1)) == 0) ans++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648284,
                "title": "c-c-javascript-java-4-lines-bit-manipulation",
                "content": "Idea. Go from root to leaf, keep track of each value, in the end check if path is palindromic and return 1, otherwise - 0.\\n\\nAlgorithm\\n* Traverse tree from root to leaf, keep track of the current state (bit field)\\n* Current state has a bit set for each number we\\'ve seen odd number of times so far. So we just need to flip a bit for each number. This is achieved by doing `xor` on certain bit of the state.\\n*  In the end, if the path is palindrome state should be `0` or contain only one bit set. `n&(n-1)` - removes right most bit, so if after removing one bit state is not `0` this is not a palindrome.\\n\\nDetails\\n* Store current state as a bit field: `1 - 0001`, `2 - 0010`, `3 - 0100`, `4 - 1000`, `5 - 10000` and so on\\n* Values are in [1,9], so `integer` (32 bit) or even `short` (16 bit) is enough to store current state.\\n* Palindrome contains at most one odd characheter, others should be present even number of times\\n\\nC++\\n```\\nint pseudoPalindromicPaths (TreeNode* root, int c = 0) {\\n    if (root == nullptr) return 0;\\n    c ^= 1 << root->val; // toggle a bit for each number\\n    if (root->left == nullptr && root->right == nullptr) return c&(c - 1) ? 0 : 1; // return 1 when there\\'s at most one bit set\\n    return pseudoPalindromicPaths(root->left, c) + pseudoPalindromicPaths(root->right, c);\\n}\\n```\\n\\nC#\\n```\\npublic int PseudoPalindromicPaths (TreeNode root, int c = 0) {\\n    if (root == null) return 0;\\n    c ^= 1 << root.val; // toggle bit for each number\\n    if (root.left == null && root.right == null) return (c&(c - 1)) > 0 ? 0 : 1; // return 1 when there\\'s at most one bit set\\n    return PseudoPalindromicPaths(root.left, c) + PseudoPalindromicPaths(root.right, c);\\n}\\n```\\n\\nJavascript\\n```\\nvar pseudoPalindromicPaths  = function(root, c = 0) {\\n    if (!root) return 0;\\n    c ^= 1 << root.val; // toggle bit for each number\\n    if (!root.left && !root.right) return (c&(c - 1)) > 0 ? 0 : 1; // return 1 when there\\'s at most one bit set\\n    return pseudoPalindromicPaths(root.left, c) + pseudoPalindromicPaths(root.right, c);\\n};\\n```\\n\\nJavascript BFS\\n```\\nvar pseudoPalindromicPaths  = function(root) {\\n    if (!root) return 0;\\n    const q = []; let result = 0;\\n    q.push(root);\\n    root.c = 1 << root.val;\\n    while(q.length) {\\n        const cur = q.shift();\\n        if (cur.left) {\\n            cur.left.c = cur.c ^ (1 << cur.left.val);\\n            q.push(cur.left);\\n        }\\n        if (cur.right) {\\n            cur.right.c = cur.c ^ (1 << cur.right.val);\\n            q.push(cur.right);\\n        }\\n        if (!cur.left && ! cur.right) result += (cur.c & (cur.c - 1)) > 0 ? 0 : 1;\\n    }\\n    return result;\\n};\\n```\\n\\nJava\\n```\\npublic int pseudoPalindromicPaths (TreeNode root) {\\n    return pseudoPalindromicPaths(root, 0);\\n}\\nint pseudoPalindromicPaths (TreeNode root, int c) {\\n    if (root == null) return 0;\\n    c ^= 1 << root.val; // toggle bit for each number\\n    if (root.left == null && root.right == null) return (c&(c - 1)) > 0 ? 0 : 1; // return 1 when there\\'s at most one bit set\\n    return pseudoPalindromicPaths(root.left, c) + pseudoPalindromicPaths(root.right, c);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nint pseudoPalindromicPaths (TreeNode* root, int c = 0) {\\n    if (root == nullptr) return 0;\\n    c ^= 1 << root->val; // toggle a bit for each number\\n    if (root->left == nullptr && root->right == nullptr) return c&(c - 1) ? 0 : 1; // return 1 when there\\'s at most one bit set\\n    return pseudoPalindromicPaths(root->left, c) + pseudoPalindromicPaths(root->right, c);\\n}\\n```\n```\\npublic int PseudoPalindromicPaths (TreeNode root, int c = 0) {\\n    if (root == null) return 0;\\n    c ^= 1 << root.val; // toggle bit for each number\\n    if (root.left == null && root.right == null) return (c&(c - 1)) > 0 ? 0 : 1; // return 1 when there\\'s at most one bit set\\n    return PseudoPalindromicPaths(root.left, c) + PseudoPalindromicPaths(root.right, c);\\n}\\n```\n```\\nvar pseudoPalindromicPaths  = function(root, c = 0) {\\n    if (!root) return 0;\\n    c ^= 1 << root.val; // toggle bit for each number\\n    if (!root.left && !root.right) return (c&(c - 1)) > 0 ? 0 : 1; // return 1 when there\\'s at most one bit set\\n    return pseudoPalindromicPaths(root.left, c) + pseudoPalindromicPaths(root.right, c);\\n};\\n```\n```\\nvar pseudoPalindromicPaths  = function(root) {\\n    if (!root) return 0;\\n    const q = []; let result = 0;\\n    q.push(root);\\n    root.c = 1 << root.val;\\n    while(q.length) {\\n        const cur = q.shift();\\n        if (cur.left) {\\n            cur.left.c = cur.c ^ (1 << cur.left.val);\\n            q.push(cur.left);\\n        }\\n        if (cur.right) {\\n            cur.right.c = cur.c ^ (1 << cur.right.val);\\n            q.push(cur.right);\\n        }\\n        if (!cur.left && ! cur.right) result += (cur.c & (cur.c - 1)) > 0 ? 0 : 1;\\n    }\\n    return result;\\n};\\n```\n```\\npublic int pseudoPalindromicPaths (TreeNode root) {\\n    return pseudoPalindromicPaths(root, 0);\\n}\\nint pseudoPalindromicPaths (TreeNode root, int c) {\\n    if (root == null) return 0;\\n    c ^= 1 << root.val; // toggle bit for each number\\n    if (root.left == null && root.right == null) return (c&(c - 1)) > 0 ? 0 : 1; // return 1 when there\\'s at most one bit set\\n    return pseudoPalindromicPaths(root.left, c) + pseudoPalindromicPaths(root.right, c);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 648282,
                "title": "short-python-dfs-using-set-to-determine-palindrome",
                "content": "The idea is, as you traverse the tree, the set maintains if there is even count or odd count. How ?\\nIf you already have the same element in the set, then remove it. because this is a pair match.\\nElse, add it to the set.\\n\\nIn the leaf, if the set is empty, then its an even palindrome.\\nIn the leaf, if the set has 1 element , its an odd palindrome.\\nIn th leaf, if the set has > 1 elements, its not a palindrome.\\n\\n```\\ndef pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        def dfs(node, cur):\\n            if not node: return 0\\n            cur.remove(node.val) if node.val in cur else cur.add(node.val)\\n            res = 0\\n            if not node.left and not node.right:\\n                if len(cur) <= 1: res = 1\\n            else:\\n                res = res + dfs(node.left, cur) + dfs(node.right, cur)\\n            cur.remove(node.val) if node.val in cur else cur.add(node.val)\\n            return res\\n        return dfs(root, set())\\n```",
                "solutionTags": [],
                "code": "```\\ndef pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        def dfs(node, cur):\\n            if not node: return 0\\n            cur.remove(node.val) if node.val in cur else cur.add(node.val)\\n            res = 0\\n            if not node.left and not node.right:\\n                if len(cur) <= 1: res = 1\\n            else:\\n                res = res + dfs(node.left, cur) + dfs(node.right, cur)\\n            cur.remove(node.val) if node.val in cur else cur.add(node.val)\\n            return res\\n        return dfs(root, set())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2573232,
                "title": "dfs-easy-to-understand-c-code",
                "content": "* ***Using DFS***\\n\\n* ***Time Complexity :- O(N * Constant)***\\n\\n* ***Space Complexity :- O(Constant)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int count = 0;\\n    \\n    void dfs(TreeNode* root, vector<int> mp)\\n    {\\n        // base case\\n        \\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        \\n        // increment the count of the curr node\\'s val\\n        \\n        mp[root -> val]++;\\n        \\n        // if we reached the leaf node then count the no. of odd frequency, if odd frequency is more than 1 then palindrome is not possible\\n        \\n        if(root -> left == NULL && root -> right == NULL)\\n        {\\n            int odd_count = 0;\\n            \\n            for(auto x : mp)\\n            {\\n                if(x % 2)\\n                {\\n                    odd_count++;\\n                }\\n            }\\n            \\n            if(odd_count <= 1)\\n            {\\n                count++;\\n            }\\n            \\n            return;\\n        }\\n        \\n        // call for left subtree\\n       \\n        dfs(root -> left, mp);\\n        \\n        // call for right subtree\\n        \\n        dfs(root -> right, mp);\\n    }\\n\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        \\n        vector<int> mp(10, 0);\\n        \\n        dfs(root, mp);\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int count = 0;\\n    \\n    void dfs(TreeNode* root, vector<int> mp)\\n    {\\n        // base case\\n        \\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        \\n        // increment the count of the curr node\\'s val\\n        \\n        mp[root -> val]++;\\n        \\n        // if we reached the leaf node then count the no. of odd frequency, if odd frequency is more than 1 then palindrome is not possible\\n        \\n        if(root -> left == NULL && root -> right == NULL)\\n        {\\n            int odd_count = 0;\\n            \\n            for(auto x : mp)\\n            {\\n                if(x % 2)\\n                {\\n                    odd_count++;\\n                }\\n            }\\n            \\n            if(odd_count <= 1)\\n            {\\n                count++;\\n            }\\n            \\n            return;\\n        }\\n        \\n        // call for left subtree\\n       \\n        dfs(root -> left, mp);\\n        \\n        // call for right subtree\\n        \\n        dfs(root -> right, mp);\\n    }\\n\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        \\n        vector<int> mp(10, 0);\\n        \\n        dfs(root, mp);\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992293,
                "title": "python-2-solutions-easy-to-understand",
                "content": "**Solution 1: DFS + Straight forward**\\nIt\\'s quite evident that the path is pseudo-palindromic, if it has at most one digit with an odd frequency.\\n```python\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        def isPseudoPalindromic():\\n            odd = 0\\n            for i in range(10):\\n                if cnt[i] % 2 == 1:\\n                    odd += 1\\n            return odd <= 1\\n        \\n        def dfs(root):\\n            nonlocal ans\\n            if root == None: return\\n            cnt[root.val] += 1\\n            if root.left == None and root.right == None: # Is leaf node\\n                if isPseudoPalindromic():\\n                    ans += 1\\n                cnt[root.val] -= 1\\n                return\\n            dfs(root.left)\\n            dfs(root.right)\\n            cnt[root.val] -= 1\\n        \\n        cnt = [0] * 10\\n        ans = 0\\n        dfs(root)\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N * 10)`\\n- Space: `O(H)`\\n\\n**Solution 2: DFS + Bitmask**\\nIdea: We use bit position to store the frequency of digits from 0 to 9. We `XOR` bit position, the frequency of a digit is even if and only if the bit at that position is zero. A path forms a Pseudo-Palindromic if the frequency of all digits is even or only 1 digit have the odd frequency, by checking if  `path & (path-1)  ==  0`\\nWhy `path & (path-1) == 0`?\\n- If the frequency of all digits is even then `path = 0` ->  `path & (path-1) = 0`\\n- If only 1 digit have the odd frequency then `path is power of Two` -> `path & (path-1) = 0`\\n```python\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        def dfs(root, path):\\n            nonlocal ans\\n            if root == None: return\\n            path ^= (1 << root.val)\\n            if root.left == None and root.right == None: # Is leaf node\\n                if path & (path - 1) == 0: # If path has only 1 odd digit or path = 0\\n                    ans += 1\\n                return\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n        \\n        ans = 0\\n        dfs(root, 0)\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(H)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        def isPseudoPalindromic():\\n            odd = 0\\n            for i in range(10):\\n                if cnt[i] % 2 == 1:\\n                    odd += 1\\n            return odd <= 1\\n        \\n        def dfs(root):\\n            nonlocal ans\\n            if root == None: return\\n            cnt[root.val] += 1\\n            if root.left == None and root.right == None: # Is leaf node\\n                if isPseudoPalindromic():\\n                    ans += 1\\n                cnt[root.val] -= 1\\n                return\\n            dfs(root.left)\\n            dfs(root.right)\\n            cnt[root.val] -= 1\\n        \\n        cnt = [0] * 10\\n        ans = 0\\n        dfs(root)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        def dfs(root, path):\\n            nonlocal ans\\n            if root == None: return\\n            path ^= (1 << root.val)\\n            if root.left == None and root.right == None: # Is leaf node\\n                if path & (path - 1) == 0: # If path has only 1 odd digit or path = 0\\n                    ans += 1\\n                return\\n            dfs(root.left, path)\\n            dfs(root.right, path)\\n        \\n        ans = 0\\n        dfs(root, 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992104,
                "title": "c-dfs-backtracking-bitwise-solution-explained-100-time-98-space",
                "content": "Sweet example of a problem that can become rather easy once you have the experience and insight to break it into smaller bits.\\n\\nWe will declare a couple of variables as class variables to make our life easier:\\n* `res` will be our accumulator variable counting how many \"palindromable\" paths we find;\\n* `tmp` will allow us to build them as we go along.\\n\\nSince we know we will never get any empty tree, in our main function we can just first of all call `dfs(root)`.\\n\\n`dfs` is a function that receives only one parameter (and manipulates the two aforementioned class variables), `root`. Within it, we will:\\n* add `root` to `path`;\\n* check if the current node is a leaf and if so increase `res` if the current `path` is palindromable (more on it later on);\\n* call itself recursively on the `left` and `right` branch, provided they exist (so we can keep our invariant of assuming `root` will never be `NULL` in each successive call);\\n* backtrack, removing the current `root` from `path`.\\n\\nThe other helper function, `isPalindromable`, will receive itself only one parameter - `path` as populated in `dfs`.\\n\\nIn it we will declare 2 support variabless to check if a path can be turned into a palindrome or not:\\n* `check` is an array of 10 integers (I know we only needed `9`, but that saves a `-1` at each step, either now or when we build `path` - well worth a couple of extra bytes);\\n* `seenOdd`, a boolean to keep track of having already encountered a number with odd frequency (we can afford to have only one, if we put it in the middle of a palindrome, but no more than that).\\n\\nWe will then:\\n* populate `check` with the frequencies\\n* parse it; as mentioned, as soon as we find an odd number, we need to:\\n\\t* return `false` if we have already seen one;\\n\\t* turn `seenOdd` to `true` otherwise.\\n* If we go out of the loop safely, we can return `true`.\\n\\nOnce we are done running `dfs`, we can just return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int res = 0;\\n    vector<int> path;\\n    void dfs(TreeNode *root) {\\n        // updating path\\n        path.push_back(root->val);\\n        // checking when in a leaf\\n        if (!root->left && !root->right) res += isPalindromable(path);\\n        // exploring the branches\\n        if (root->left) dfs(root->left);\\n        if (root->right) dfs(root->right);\\n        // backtracking\\n        path.pop_back();\\n    }\\n    bool isPalindromable(vector<int> &path) {\\n        // support variables\\n        unsigned short check[10] = {};\\n        bool seenOdd = false;\\n        // populating check\\n        for (int n: path) check[n]++;\\n        // verifying if we have more than one odd\\n        for (int n: check) if (n % 2) {\\n            if (seenOdd) return false;\\n            seenOdd = true;\\n        }\\n        return true;\\n    }\\n    int pseudoPalindromicPaths(TreeNode *root) {\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\\n\\nWas I happy with it? Nah: time to dust off my bitwise-fu and improve a bit.\\n\\nI decided to turn `check` into `isPalindromable` to be just an `int`; for each number, we will XOR it with the matching bit from the right and in the end. we will just have to check if the number is a power of `2` (meaning we only had an odd frequency) or `0` (meanng no odd frequencies found at all).\\n\\nTo clarify with an example, let\\'s consider parsing the tree you can generate with `[2,1,1,1,3,null,null,null,null,null,1,2,4]` and the 2 longest paths you will get out of it: `{2,1,3,1,2}` and `{2,1,3,1,4}`. I highlighted them in red and blue respectively here:\\n\\n![image](https://assets.leetcode.com/users/images/55030120-ff08-4987-8e81-747b39ecbc7e_1609244067.9496357.png)\\n\\nNow, moving with the first, we will have as values of `check`:\\n\\n```cpp\\n0  // initial value\\n4  // after XORing 1 << 2 to it\\n6  // after XORing 1 << 1 to it\\n14 // after XORing 1 << 3 to it\\n12 // after XORing 1 << 1 to it\\n8  // after XORing 1 << 2 to it\\n```\\n\\nAnd since `8` is indeed a power of `2`, we return `true`!\\n\\nIf you try with the other path, you will see that you will get a final result of `28` (`== (2 << 2) + (2 << 3) + ( 2 << 4)`, definitely not a power of `2`, so we can return `false` :)\\n\\nThe improved code, which uses a bit less memory and let me gain about 16ms on average:\\n\\n```cpp\\n    bool isPalindromable(vector<int> &path) {\\n        // support variables\\n        int check = 0;\\n        // populating check\\n        for (int n: path) check ^= 1 << n;\\n        // verifying if we have more than one odd\\n        return !(check & (check - 1));\\n    }\\n```\\n\\nAt this point you might wonder \"hey, wait a moment - do I still need to waste precious CPU and bytes in carrying around a cumbersome vector of ints as a path?\".\\n\\nWell, I did actually ask that myself and decided to cut the middlemen (sorry vector and sorry helper function: I am sure you will be fondly remembered by posterity, but I had to get rid of you) and finally I came up with a much lighter, faster and more efficient version of my code, going down to another best time of 164ms:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int path;\\n    void dfs(TreeNode *root) {\\n        // updating path\\n        path ^= 1 << root->val;\\n        // checking when in a leaf\\n        if (!root->left && !root->right) res += !(path & (path - 1));\\n        // exploring the branches\\n        if (root->left) dfs(root->left);\\n        if (root->right) dfs(root->right);\\n        // backtracking\\n        path ^= 1 << root->val;\\n    }\\n    int pseudoPalindromicPaths(TreeNode *root) {\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int res = 0;\\n    vector<int> path;\\n    void dfs(TreeNode *root) {\\n        // updating path\\n        path.push_back(root->val);\\n        // checking when in a leaf\\n        if (!root->left && !root->right) res += isPalindromable(path);\\n        // exploring the branches\\n        if (root->left) dfs(root->left);\\n        if (root->right) dfs(root->right);\\n        // backtracking\\n        path.pop_back();\\n    }\\n    bool isPalindromable(vector<int> &path) {\\n        // support variables\\n        unsigned short check[10] = {};\\n        bool seenOdd = false;\\n        // populating check\\n        for (int n: path) check[n]++;\\n        // verifying if we have more than one odd\\n        for (int n: check) if (n % 2) {\\n            if (seenOdd) return false;\\n            seenOdd = true;\\n        }\\n        return true;\\n    }\\n    int pseudoPalindromicPaths(TreeNode *root) {\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\n```cpp\\n0  // initial value\\n4  // after XORing 1 << 2 to it\\n6  // after XORing 1 << 1 to it\\n14 // after XORing 1 << 3 to it\\n12 // after XORing 1 << 1 to it\\n8  // after XORing 1 << 2 to it\\n```\n```cpp\\n    bool isPalindromable(vector<int> &path) {\\n        // support variables\\n        int check = 0;\\n        // populating check\\n        for (int n: path) check ^= 1 << n;\\n        // verifying if we have more than one odd\\n        return !(check & (check - 1));\\n    }\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int path;\\n    void dfs(TreeNode *root) {\\n        // updating path\\n        path ^= 1 << root->val;\\n        // checking when in a leaf\\n        if (!root->left && !root->right) res += !(path & (path - 1));\\n        // exploring the branches\\n        if (root->left) dfs(root->left);\\n        if (root->right) dfs(root->right);\\n        // backtracking\\n        path ^= 1 << root->val;\\n    }\\n    int pseudoPalindromicPaths(TreeNode *root) {\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648538,
                "title": "java-python-3-2-similar-recursive-o-n-codes-w-brief-explanation-and-analysis",
                "content": "\\n1. Recurse from root to the leaves and count the frequencies of same numbers in each path; \\n2. If there is at most `1` odd frequency in a path, then it is a valid path.\\n\\n**Method 1:**\\n\\n```java\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return preorder(root, new int[10]);\\n    }\\n    private int preorder(TreeNode n, int[] count) {\\n        if (n == null)\\n            return 0;\\n        ++count[n.val];\\n        if (n.left == null && n.right == null) {\\n            int numOfOdd = 0;\\n            for (int c : count)\\n                numOfOdd += c % 2;\\n            return numOfOdd > 1 ? 0 : 1;\\n        }\\n        return preorder(n.left, count.clone()) + preorder(n.right, count.clone());               \\n    }\\n```\\n\\n```python\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        \\n        def preorder(node: TreeNode, cnt: List[int]) -> int:\\n            if not node:\\n                return 0\\n            cnt[node.val] += 1\\n            if node.left == node.right == None:\\n                return 1 if sum(c % 2 for c in cnt) < 2 else 0\\n            return preorder(node.left, cnt[:]) + preorder(node.right, cnt[:])\\n            \\n        return preorder(root, [0] * 10)\\n```\\n\\n----\\n\\n**Method 2:**\\n\\nUse the `0th` to `9th` bit s of a `int` to record the odd/even frequency in a path, since the numbers range from `0 ~ 9`;\\n\\n```java\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return preorder(root, 0);\\n    }\\n    private int preorder(TreeNode n, int cnt) {\\n        if (n == null) {\\n            return 0;\\n        }\\n        cnt ^= 1 << n.val;\\n        if (n.left == null && n.right == null) {\\n            return Integer.bitCount(cnt) > 1 ? 0 : 1;\\n        }\\n        return preorder(n.left, cnt) + preorder(n.right, cnt);       \\n    }\\n```\\n\\n\\n```python\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n\\t\\n        def preorder(node: TreeNode, cnt: int) -> int:\\n            if not node:\\n                return 0\\n            cnt ^= 1 << node.val\\n            if node.left == node.right == None:\\n                return 0 if bin(cnt).count(\\'1\\') > 1 else 1\\n            return preorder(node.left, cnt) + preorder(node.right, cnt)\\n            \\n        return preorder(root, 0)\\n```\\n\\n**Analysis:**\\n\\nTime and space: O(n), where n is totoal number of nodes in the tree.",
                "solutionTags": [],
                "code": "```java\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return preorder(root, new int[10]);\\n    }\\n    private int preorder(TreeNode n, int[] count) {\\n        if (n == null)\\n            return 0;\\n        ++count[n.val];\\n        if (n.left == null && n.right == null) {\\n            int numOfOdd = 0;\\n            for (int c : count)\\n                numOfOdd += c % 2;\\n            return numOfOdd > 1 ? 0 : 1;\\n        }\\n        return preorder(n.left, count.clone()) + preorder(n.right, count.clone());               \\n    }\\n```\n```python\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        \\n        def preorder(node: TreeNode, cnt: List[int]) -> int:\\n            if not node:\\n                return 0\\n            cnt[node.val] += 1\\n            if node.left == node.right == None:\\n                return 1 if sum(c % 2 for c in cnt) < 2 else 0\\n            return preorder(node.left, cnt[:]) + preorder(node.right, cnt[:])\\n            \\n        return preorder(root, [0] * 10)\\n```\n```java\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return preorder(root, 0);\\n    }\\n    private int preorder(TreeNode n, int cnt) {\\n        if (n == null) {\\n            return 0;\\n        }\\n        cnt ^= 1 << n.val;\\n        if (n.left == null && n.right == null) {\\n            return Integer.bitCount(cnt) > 1 ? 0 : 1;\\n        }\\n        return preorder(n.left, cnt) + preorder(n.right, cnt);       \\n    }\\n```\n```python\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n\\t\\n        def preorder(node: TreeNode, cnt: int) -> int:\\n            if not node:\\n                return 0\\n            cnt ^= 1 << node.val\\n            if node.left == node.right == None:\\n                return 0 if bin(cnt).count(\\'1\\') > 1 else 1\\n            return preorder(node.left, cnt) + preorder(node.right, cnt)\\n            \\n        return preorder(root, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2576551,
                "title": "easy-java-c-python-explained-with-video-beginner-friendly",
                "content": "**PLEASE LIKE AND COMMENT IF THIS SOLUTION HAS HELPED YOU**\\n\\n**VIDEO EXPLANATION OF SOLUTION:**\\nhttps://www.youtube.com/watch?v=spC68MStRRg&ab_channel=AlgoLock\\n\\n**SOLUTION: JAVA**\\n```java\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return parsePalinTree(root, new int[10]);\\n    }\\n    \\n    public int parsePalinTree(TreeNode root, int[] arr){\\n        \\n        int count = 0; \\n        arr[root.val]++;\\n        //Base Case: Reach a leaf node\\n        if(root.left == null && root.right == null){\\n            boolean isValidPath = isPalinDromePath(arr);\\n            if(isValidPath) count = 1;\\n        }\\n        // Left and right subtree: \\n        if(root.left != null) count += parsePalinTree(root.left, arr);\\n        if(root.right != null) count += parsePalinTree(root.right, arr);\\n            \\n        arr[root.val]--; \\n        return count; \\n    }\\n    \\n    public boolean isPalinDromePath(int[] arr){\\n        boolean firstOdd = true;\\n        int len = arr.length;\\n        for(int i = 0; i < len; i++){\\n            if(arr[i] % 2 == 1){\\n                if(!firstOdd) return false;\\n                firstOdd = false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**SOLUTION: C++**\\n```c++\\nclass Solution {\\npublic:\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        return calcPalindromicPaths(root, new int[10]{0}, 10);\\n    }\\n    \\n    int calcPalindromicPaths(TreeNode* root, int arr[], int len){\\n        \\n        if(root == NULL) return 0; \\n        \\n        int count = 0; \\n        arr[root->val]++;\\n        // Reached a leaf:\\n        if(root->left == NULL && root->right == NULL){\\n            if(isPalindromicPath(arr, 10)) count = 1;\\n        }\\n        // Left and Right paths\\n        if(root->left != NULL) count += calcPalindromicPaths(root->left, arr, len);\\n        if(root->right != NULL) count += calcPalindromicPaths(root->right, arr, len);\\n        \\n        arr[root->val]--; \\n        return count;\\n    }\\n    \\n    bool isPalindromicPath(int arr[], int len){\\n        \\n        bool sawFirstOdd = false;\\n        for(int i = 0; i < len; i++){\\n            if(arr[i] % 2 == 1){\\n                if(sawFirstOdd) return false;\\n                sawFirstOdd = true;\\n            }\\n        }\\n        cout << endl;\\n        return true;\\n    }\\n};\\n```\\n\\n**SOLUTION: PYTHON**\\n```python\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n                \\n        ## Function to check if current path has a permutation that\\'s a palindrome\\n        def isPalindromicPath(palinArr: [int]) -> bool:\\n            hasSeenFirstOdd: bool = False\\n            for i in range(0, len(palinArr)):\\n                if(palinArr[i] % 2 == 1):\\n                    if hasSeenFirstOdd: return False\\n                    hasSeenFirstOdd = True\\n            return True\\n    \\n        ## Wrapper for function that calculates the number of pseudo palindromic paths\\n        def calcPalindromicPaths(root: Optional[TreeNode], arr: [int]) -> int:\\n            \\n            count: int = 0\\n            if root == None: return 0\\n            arr[root.val] += 1\\n            \\n            ## Leaf Node: No children\\n            if(root.left == None and root.right == None):\\n                if(isPalindromicPath(arr)): count = 1\\n            \\n            if(root.left != None): count += calcPalindromicPaths(root.left, arr)\\n            if(root.right != None): count += calcPalindromicPaths(root.right, arr)\\n                \\n            arr[root.val] -= 1\\n            return count; \\n        \\n        \\n        dparr: [int] = [0] * 10\\n        return calcPalindromicPaths(root, dparr)\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```java\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return parsePalinTree(root, new int[10]);\\n    }\\n    \\n    public int parsePalinTree(TreeNode root, int[] arr){\\n        \\n        int count = 0; \\n        arr[root.val]++;\\n        //Base Case: Reach a leaf node\\n        if(root.left == null && root.right == null){\\n            boolean isValidPath = isPalinDromePath(arr);\\n            if(isValidPath) count = 1;\\n        }\\n        // Left and right subtree: \\n        if(root.left != null) count += parsePalinTree(root.left, arr);\\n        if(root.right != null) count += parsePalinTree(root.right, arr);\\n            \\n        arr[root.val]--; \\n        return count; \\n    }\\n    \\n    public boolean isPalinDromePath(int[] arr){\\n        boolean firstOdd = true;\\n        int len = arr.length;\\n        for(int i = 0; i < len; i++){\\n            if(arr[i] % 2 == 1){\\n                if(!firstOdd) return false;\\n                firstOdd = false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        return calcPalindromicPaths(root, new int[10]{0}, 10);\\n    }\\n    \\n    int calcPalindromicPaths(TreeNode* root, int arr[], int len){\\n        \\n        if(root == NULL) return 0; \\n        \\n        int count = 0; \\n        arr[root->val]++;\\n        // Reached a leaf:\\n        if(root->left == NULL && root->right == NULL){\\n            if(isPalindromicPath(arr, 10)) count = 1;\\n        }\\n        // Left and Right paths\\n        if(root->left != NULL) count += calcPalindromicPaths(root->left, arr, len);\\n        if(root->right != NULL) count += calcPalindromicPaths(root->right, arr, len);\\n        \\n        arr[root->val]--; \\n        return count;\\n    }\\n    \\n    bool isPalindromicPath(int arr[], int len){\\n        \\n        bool sawFirstOdd = false;\\n        for(int i = 0; i < len; i++){\\n            if(arr[i] % 2 == 1){\\n                if(sawFirstOdd) return false;\\n                sawFirstOdd = true;\\n            }\\n        }\\n        cout << endl;\\n        return true;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n                \\n        ## Function to check if current path has a permutation that\\'s a palindrome\\n        def isPalindromicPath(palinArr: [int]) -> bool:\\n            hasSeenFirstOdd: bool = False\\n            for i in range(0, len(palinArr)):\\n                if(palinArr[i] % 2 == 1):\\n                    if hasSeenFirstOdd: return False\\n                    hasSeenFirstOdd = True\\n            return True\\n    \\n        ## Wrapper for function that calculates the number of pseudo palindromic paths\\n        def calcPalindromicPaths(root: Optional[TreeNode], arr: [int]) -> int:\\n            \\n            count: int = 0\\n            if root == None: return 0\\n            arr[root.val] += 1\\n            \\n            ## Leaf Node: No children\\n            if(root.left == None and root.right == None):\\n                if(isPalindromicPath(arr)): count = 1\\n            \\n            if(root.left != None): count += calcPalindromicPaths(root.left, arr)\\n            if(root.right != None): count += calcPalindromicPaths(root.right, arr)\\n                \\n            arr[root.val] -= 1\\n            return count; \\n        \\n        \\n        dparr: [int] = [0] * 10\\n        return calcPalindromicPaths(root, dparr)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1666228,
                "title": "pseudo-palindromic-paths-in-a-binary-tree-java-solution-using-dfs",
                "content": "The solution to this question is very intuitive, we just need to write the code for Root to Leaf Paths and just check whether any permutation of that path can be a palindrome. For a permutation of a path to be a palindrome, it must satisfy one of the 2 conditions given below:\\n\\n**(i) If the number of nodes in the path is even, then the frequency of each node\\'s value in that path must be even.**\\n\\n**(ii) If the number of nodes in the path is odd, then the frequency of atmost one node\\'s value in that path must be odd.**\\n\\n```\\n\\tprivate List<Integer> curr = new ArrayList<>();  // To store the current path. This will be used to check the length of the path. You can use a variable in place of this.\\n    private int[] hm = new int[10];  // Given that 1 <= node.val <= 9, we will use this array as a frequency map.\\n    private int oc = 0, res = 0;  // oc for keeping odd number count, res for keeping palindromic path count. \\n    \\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n        helper(root);\\n        return res;\\n    }\\n    \\n    public void helper(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        \\n        curr.add(root.val);  // add the value of current node to the list\\n        hm[root.val]++;  // update the frequency of that value for the current path\\n        \\n        if(root.left == null && root.right == null){  // leaf node condition\\n            for(int i = 0; i < 10; i++){\\n                if(hm[i] != 0 && hm[i] % 2 == 1){  // count the numbers which have odd frequencies in the root to leaf path\\n                    oc++;\\n                }\\n            }\\n            \\n            if((curr.size() % 2 == 1 && oc == 1) || (curr.size() % 2 == 0 && oc == 0)){  // the same conditions as explained above\\n                res++;\\n            }\\n            oc = 0;  // reset odd count to 0 as we are done with this path\\n        }\\n        \\n        helper(root.left);\\n        helper(root.right);\\n        \\n        curr.remove(curr.size() - 1);  //remove the last node\\'s value while backtracking\\n        hm[root.val]--;  // reduce its frequency as we are going to find a new path now\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n\\tprivate List<Integer> curr = new ArrayList<>();  // To store the current path. This will be used to check the length of the path. You can use a variable in place of this.\\n    private int[] hm = new int[10];  // Given that 1 <= node.val <= 9, we will use this array as a frequency map.\\n    private int oc = 0, res = 0;  // oc for keeping odd number count, res for keeping palindromic path count. \\n    \\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n        helper(root);\\n        return res;\\n    }\\n    \\n    public void helper(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        \\n        curr.add(root.val);  // add the value of current node to the list\\n        hm[root.val]++;  // update the frequency of that value for the current path\\n        \\n        if(root.left == null && root.right == null){  // leaf node condition\\n            for(int i = 0; i < 10; i++){\\n                if(hm[i] != 0 && hm[i] % 2 == 1){  // count the numbers which have odd frequencies in the root to leaf path\\n                    oc++;\\n                }\\n            }\\n            \\n            if((curr.size() % 2 == 1 && oc == 1) || (curr.size() % 2 == 0 && oc == 0)){  // the same conditions as explained above\\n                res++;\\n            }\\n            oc = 0;  // reset odd count to 0 as we are done with this path\\n        }\\n        \\n        helper(root.left);\\n        helper(root.right);\\n        \\n        curr.remove(curr.size() - 1);  //remove the last node\\'s value while backtracking\\n        hm[root.val]--;  // reduce its frequency as we are going to find a new path now\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2573684,
                "title": "easy-as-traversal-with-explained-approach-step-by-step",
                "content": "```\\n/*\\n    Approach: TC-> O(K*N) ; here, K=9\\n    \\n    Using count array(of size 10 as tree contains value only from 1-9, so it will be easy to increase and decrease count of values) to store frequencies of every node value from root to leaf node\\n    Traverse to the leaf node and then using the count array check the path can be a palindrome or not, and then backtrack by redcuing the frequency in count array\\n    \\n    How to check the path can be a palindrome?\\n    If the total number of odd frequencies of any values in the count array is more than 1, then the path can never form a palindrome number\\n    \\n    EX:\\n    let\\'s path consist of value -> 2,3,3,2,3 \\n    count array becomes -> [0,0,2,3,0,0,0,0,0,0]\\n    there is only one odd frequencies(2->2 times, 3->3 times), so the path form a palindrome (eg, 2,3,3,3,2)\\n    \\n    let\\'s check another example\\n    path values -> 4,2,3,3,4,2,3,4\\n    count array will be -> [0,0,2,3,3,0,0,0,0,0]\\n    there are two odd frequencies (3->3 times, 4->3 times), so it can never form a palindrome\\n\\n*/\\nclass Solution {\\n    int count = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] list = new int[10];\\n        f(root,list);\\n        return count;\\n    }\\n    \\n    private void f(TreeNode root, int[] list){\\n        if(root == null) return;\\n        \\n        // If leaf node\\n        if(root.left==null && root.right==null) {\\n            // ++ leaf count \\n            list[root.val]++;\\n            \\n            // check, can form palindrome?\\n            if(isPal(list))count++;\\n            \\n            // backtrack\\n            list[root.val]--;\\n            return;\\n        }\\n        \\n        // ++ root value\\n        list[root.val]++;\\n        \\n        // traverse left and right child\\n        f(root.left, list);\\n        f(root.right,list);\\n        \\n        // back track\\n        list[root.val]--;\\n    }\\n    \\n    private boolean isPal(int[] list){\\n        int odds = 0;\\n        for(int e : list){\\n            if((e&1)==1) odds++;\\n            if(odds>1)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\n    Approach: TC-> O(K*N) ; here, K=9\\n    \\n    Using count array(of size 10 as tree contains value only from 1-9, so it will be easy to increase and decrease count of values) to store frequencies of every node value from root to leaf node\\n    Traverse to the leaf node and then using the count array check the path can be a palindrome or not, and then backtrack by redcuing the frequency in count array\\n    \\n    How to check the path can be a palindrome?\\n    If the total number of odd frequencies of any values in the count array is more than 1, then the path can never form a palindrome number\\n    \\n    EX:\\n    let\\'s path consist of value -> 2,3,3,2,3 \\n    count array becomes -> [0,0,2,3,0,0,0,0,0,0]\\n    there is only one odd frequencies(2->2 times, 3->3 times), so the path form a palindrome (eg, 2,3,3,3,2)\\n    \\n    let\\'s check another example\\n    path values -> 4,2,3,3,4,2,3,4\\n    count array will be -> [0,0,2,3,3,0,0,0,0,0]\\n    there are two odd frequencies (3->3 times, 4->3 times), so it can never form a palindrome\\n\\n*/\\nclass Solution {\\n    int count = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] list = new int[10];\\n        f(root,list);\\n        return count;\\n    }\\n    \\n    private void f(TreeNode root, int[] list){\\n        if(root == null) return;\\n        \\n        // If leaf node\\n        if(root.left==null && root.right==null) {\\n            // ++ leaf count \\n            list[root.val]++;\\n            \\n            // check, can form palindrome?\\n            if(isPal(list))count++;\\n            \\n            // backtrack\\n            list[root.val]--;\\n            return;\\n        }\\n        \\n        // ++ root value\\n        list[root.val]++;\\n        \\n        // traverse left and right child\\n        f(root.left, list);\\n        f(root.right,list);\\n        \\n        // back track\\n        list[root.val]--;\\n    }\\n    \\n    private boolean isPal(int[] list){\\n        int odds = 0;\\n        for(int e : list){\\n            if((e&1)==1) odds++;\\n            if(odds>1)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573899,
                "title": "c-2-solutions-recursive-iterative-and-bitmasking",
                "content": "### Solution 1: recursive\\n\\nTo decide of a path is a pseudo-palindromic we need to know if there is at most one odd count of digits. We can easily do this with XOR and bitmasking and use ```__builtin_popcount()```.\\n\\n```cpp\\n    int pseudoPalindromicPaths(TreeNode* root) {\\n        return dfs(root, 0);\\n    }\\n\\n    int dfs(TreeNode* node, int seen) {\\n        if (!node) return 0;\\n        \\n        seen ^= 1 << (node->val);\\n        \\n        if (!node->left && !node->right) {\\n            return __builtin_popcount(seen) < 2;\\n        }\\n        \\n        return dfs(node->left, seen) + dfs(node->right, seen);\\n    }\\n```\\n\\n### Solution 2: iterative\\n\\nSame idea, just iterative\\n\\n```cpp\\n    int pseudoPalindromicPaths(TreeNode* root) {\\n        if (!root) return 0;\\n        stack<pair<TreeNode*, int>> st;\\n        st.push({root, 0});\\n        int ans = 0;\\n        while (!empty(st)) {\\n            auto [node, seen] = st.top(); st.pop();\\n            seen ^= 1 << (node->val);\\n            if (!node->left && !node->right) {\\n                ans += __builtin_popcount(seen) < 2;\\n            }\\n            if (node->left) st.push({node->left, seen});\\n            if (node->right) st.push({node->right, seen});\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: O(n) we need to look at all the nodes\\n  * Space Complexity: O(h) where h is the height of the tree which ranges form O(log n) to O(n).  \\n\\n_As always: Feedback, comments, and question are welcome. Please upvote if you like this post_.\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```__builtin_popcount()```\n```cpp\\n    int pseudoPalindromicPaths(TreeNode* root) {\\n        return dfs(root, 0);\\n    }\\n\\n    int dfs(TreeNode* node, int seen) {\\n        if (!node) return 0;\\n        \\n        seen ^= 1 << (node->val);\\n        \\n        if (!node->left && !node->right) {\\n            return __builtin_popcount(seen) < 2;\\n        }\\n        \\n        return dfs(node->left, seen) + dfs(node->right, seen);\\n    }\\n```\n```cpp\\n    int pseudoPalindromicPaths(TreeNode* root) {\\n        if (!root) return 0;\\n        stack<pair<TreeNode*, int>> st;\\n        st.push({root, 0});\\n        int ans = 0;\\n        while (!empty(st)) {\\n            auto [node, seen] = st.top(); st.pop();\\n            seen ^= 1 << (node->val);\\n            if (!node->left && !node->right) {\\n                ans += __builtin_popcount(seen) < 2;\\n            }\\n            if (node->left) st.push({node->left, seen});\\n            if (node->right) st.push({node->right, seen});\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2573607,
                "title": "c-dfs-short-commented-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\n**TC** = O(N*constant)\\n\\n**INTUITION** = When a path is consider from root to any leaf node, count of occurences of nodes should be odd and shouldn\\'t be more than 1.\\nFor eg 2->3->3, count of 2=1 and 3=2, so there exists only a single element whose count is odd, therefore, it is a palindrome.\\nFor eg 2->3->3->2, count of 2=2 and 3=2, so there doesn\\'t exists a single node whose occurence is odd, therefore no palindrome exists.\\nFor eg 4->5->4->4->5, count of 4=3 and 5=2, since count of 4 is odd, therefore palindrome exists\\n\\n---------------------------------------------------------------------------------------------------------------------------------------------\\n\\t\\n\\tvoid solve(TreeNode* root, unordered_map<int,int>&mp, int &ans){\\n        \\n        if(!root) return;\\n        \\n        mp[root->val]++;                     //updating occurence of an element\\n        \\n        if(!root->left && !root->right){     //when we reached leaf node\\n            int c=0;                         //then we will count the number of elements whose occurence is odd\\n            for(auto it:mp){                 //if count of such elements is <=1, then we update ans\\n                if(it.second%2!=0) c++;      //For eg, 2->3->3 is a path so in map, occurences of 2=1 and 3=2\\n            }                                //In order to obatain a palindrome, there should be a single element present whose count of occurences is odd\\n            if(c<=1) ans++;                  //Hence, 2->3->3 is a plaindrome since it can be arranged to 3->2->3\\n        }\\n        \\n        solve(root->left,mp,ans);            //calling recursion of left and right subtree resp\\n        solve(root->right,mp,ans);\\n        \\n        mp[root->val]--;                     //backtrack, removing occurence of an element\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        \\n        unordered_map<int,int> mp;           //key=element, value=occurence\\n        int ans=0;\\n        solve(root,mp,ans);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\n**TC** = O(N*constant)\\n\\n**INTUITION** = When a path is consider from root to any leaf node, count of occurences of nodes should be odd and shouldn\\'t be more than 1.\\nFor eg 2->3->3, count of 2=1 and 3=2, so there exists only a single element whose count is odd, therefore, it is a palindrome.\\nFor eg 2->3->3->2, count of 2=2 and 3=2, so there doesn\\'t exists a single node whose occurence is odd, therefore no palindrome exists.\\nFor eg 4->5->4->4->5, count of 4=3 and 5=2, since count of 4 is odd, therefore palindrome exists\\n\\n---------------------------------------------------------------------------------------------------------------------------------------------\\n\\t\\n\\tvoid solve(TreeNode* root, unordered_map<int,int>&mp, int &ans){\\n        \\n        if(!root) return;\\n        \\n        mp[root->val]++;                     //updating occurence of an element\\n        \\n        if(!root->left && !root->right){     //when we reached leaf node\\n            int c=0;                         //then we will count the number of elements whose occurence is odd\\n            for(auto it:mp){                 //if count of such elements is <=1, then we update ans\\n                if(it.second%2!=0) c++;      //For eg, 2->3->3 is a path so in map, occurences of 2=1 and 3=2\\n            }                                //In order to obatain a palindrome, there should be a single element present whose count of occurences is odd\\n            if(c<=1) ans++;                  //Hence, 2->3->3 is a plaindrome since it can be arranged to 3->2->3\\n        }\\n        \\n        solve(root->left,mp,ans);            //calling recursion of left and right subtree resp\\n        solve(root->right,mp,ans);\\n        \\n        mp[root->val]--;                     //backtrack, removing occurence of an element\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        \\n        unordered_map<int,int> mp;           //key=element, value=occurence\\n        int ans=0;\\n        solve(root,mp,ans);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2573008,
                "title": "daily-leetcoding-challenge-september-day-14",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 992298,
                "title": "c-pseudo-palindromic-paths-in-a-binary-tree-recursion-w-bitset",
                "content": "\\n\\tclass Solution {\\n\\t\\t int ans = 0;\\n\\tpublic:\\n\\t\\tint pseudoPalindromicPaths(TreeNode* root) {\\n\\t\\t\\ttraverse(root, 0);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tvoid traverse(TreeNode* root, int bit) {\\n\\t\\t\\tif(!root) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n        \\n\\t\\t\\tbit ^= (1 << root->val);\\n\\t\\t\\tif(!root->left && !root->right) {\\n\\t\\t\\t\\tbitset<32> b(bit);\\n\\t\\t\\t\\tif(b.count() <= 1)\\n\\t\\t\\t\\t\\t++ans;\\n\\t\\t\\t}\\n\\t\\t\\ttraverse(root->left, bit);\\n\\t\\t\\ttraverse(root->right, bit);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t int ans = 0;\\n\\tpublic:\\n\\t\\tint pseudoPalindromicPaths(TreeNode* root) {\\n\\t\\t\\ttraverse(root, 0);\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2573988,
                "title": "c-two-approaches-with-comments-dfs",
                "content": "First approach stores the count of each value and checks iteratively on leaf node for possibility of a palindrome.\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int num[10] = {};\\n    void dfs(TreeNode* root){\\n        if(!root)\\n            return;\\n        ++num[root->val];\\n        dfs(root->left);        \\n        dfs(root->right);\\n        // If at leaf node.\\n        if((!root->left) && (!root->right)){ \\n            // Check if palindrome possible.\\n            int odd = 0;\\n            for(int i = 1; i < 10; ++i){\\n                if(num[i]&1)\\n                    ++odd;                \\n            }            \\n            if(odd<2)\\n                ++ans;            \\n        }\\n        //Remove the count as we have checked for that subtree.\\n        --num[root->val];        \\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```\\n\\nSecond Approach is using a variable and toggling its bits. For a leaf node only one bit should be toggled 1.\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int count = 0;\\n    void dfs(TreeNode* root){\\n        if(!root)\\n            return;\\n        //Toggle nth bit. XOR works as toggle\\n        count ^= 1 << (root->val-1);        \\n        dfs(root->left);        \\n        dfs(root->right);\\n        // If at leaf node, root->left == root->right == nullptr\\n        // count&(count-1) == 0 when it is power of two ,i.e., only one bit is toggle 1.\\n        if((root->left == root->right) && ((count&(count-1)) == 0))\\n            ++ans;\\n        \\n        //Remove the toggle as we have checked for that subtree.\\n        count ^= (1 << (root->val-1));\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int num[10] = {};\\n    void dfs(TreeNode* root){\\n        if(!root)\\n            return;\\n        ++num[root->val];\\n        dfs(root->left);        \\n        dfs(root->right);\\n        // If at leaf node.\\n        if((!root->left) && (!root->right)){ \\n            // Check if palindrome possible.\\n            int odd = 0;\\n            for(int i = 1; i < 10; ++i){\\n                if(num[i]&1)\\n                    ++odd;                \\n            }            \\n            if(odd<2)\\n                ++ans;            \\n        }\\n        //Remove the count as we have checked for that subtree.\\n        --num[root->val];        \\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int count = 0;\\n    void dfs(TreeNode* root){\\n        if(!root)\\n            return;\\n        //Toggle nth bit. XOR works as toggle\\n        count ^= 1 << (root->val-1);        \\n        dfs(root->left);        \\n        dfs(root->right);\\n        // If at leaf node, root->left == root->right == nullptr\\n        // count&(count-1) == 0 when it is power of two ,i.e., only one bit is toggle 1.\\n        if((root->left == root->right) && ((count&(count-1)) == 0))\\n            ++ans;\\n        \\n        //Remove the toggle as we have checked for that subtree.\\n        count ^= (1 << (root->val-1));\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573580,
                "title": "javascript-beats-90-in-september-2022",
                "content": "**a** is a palindrome\\n**ab** is *not* a palindrome\\n**aa** is a palindrome\\n**aab** is a pseduo-palindrome (rearrange to aba)\\n**aba** is a palindrome\\n**abba** is a palindrome\\n**aaba** is *not* a palindrome\\n**aaaa** is a palindrome\\n**aaaab** is a pseduo-palindrome\\n...\\n**aabbccxxxxy** is a pseduo-palindrome (rearrange to abcxxyxxbca) We know this because all but one letters have an even count:\\na: 2\\nb: 2\\nc: 2\\nx: 4\\ny: 1\\n\\nOr in otherwords we could say\\na: has even count\\nb: has even count\\nc: has even count\\nx: has even count\\ny: has odd count\\n\\nSo to solve the question we can do a simple pre-order traversal and maintain a Boolean array of size 10 which says if we have an even count of each digit. Everytim we hit a leaf node in our recursion we simply check to see if we have at most one digit with an odd count. This has O(n) time complexity.\\n\\n\\n```\\nvar pseudoPalindromicPaths  = function(root) {\\n  \\n  let count = 0;\\n  \\n  const digits = new Array(10).fill(true);\\n  \\n  const f = (node) => {\\n    \\n    if (!node) return;\\n    \\n    digits[node.val] = !digits[node.val];\\n    \\n    if (!node.left && !node.right) {\\n      if (digits.filter((num) => num === false).length <= 1) count += 1;\\n      digits[node.val] = !digits[node.val];\\n      return;\\n    }\\n    \\n    f(node.left);\\n    f(node.right);\\n    \\n    digits[node.val] = !digits[node.val];\\n  };\\n  \\n  f(root);\\n  \\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pseudoPalindromicPaths  = function(root) {\\n  \\n  let count = 0;\\n  \\n  const digits = new Array(10).fill(true);\\n  \\n  const f = (node) => {\\n    \\n    if (!node) return;\\n    \\n    digits[node.val] = !digits[node.val];\\n    \\n    if (!node.left && !node.right) {\\n      if (digits.filter((num) => num === false).length <= 1) count += 1;\\n      digits[node.val] = !digits[node.val];\\n      return;\\n    }\\n    \\n    f(node.left);\\n    f(node.right);\\n    \\n    digits[node.val] = !digits[node.val];\\n  };\\n  \\n  f(root);\\n  \\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2573105,
                "title": "daily-leetcode-solution-easy-c-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void preorderTraversal(TreeNode* root,vector<int> &path,int &cnt)\\n    {\\n        if(root==NULL)\\n            return;\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            path[root->val]++;\\n            int countOdd=0;\\n            for(int i=0;i<10;i++)\\n            {\\n                if(path[i]%2==1)\\n                    countOdd++;\\n            }\\n            if(countOdd<=1)\\n                cnt++;\\n            path[root->val]--;\\n            return;\\n        }\\n        path[root->val]++;\\n        if(root->left)\\n        {\\n        preorderTraversal(root->left,path,cnt);\\n        }\\n        if(root->right)\\n        {\\n        preorderTraversal(root->right,path,cnt);  \\n        }\\n        path[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> path(10,0);\\n        int cnt=0;\\n        preorderTraversal(root,path,cnt);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void preorderTraversal(TreeNode* root,vector<int> &path,int &cnt)\\n    {\\n        if(root==NULL)\\n            return;\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            path[root->val]++;\\n            int countOdd=0;\\n            for(int i=0;i<10;i++)\\n            {\\n                if(path[i]%2==1)\\n                    countOdd++;\\n            }\\n            if(countOdd<=1)\\n                cnt++;\\n            path[root->val]--;\\n            return;\\n        }\\n        path[root->val]++;\\n        if(root->left)\\n        {\\n        preorderTraversal(root->left,path,cnt);\\n        }\\n        if(root->right)\\n        {\\n        preorderTraversal(root->right,path,cnt);  \\n        }\\n        path[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> path(10,0);\\n        int cnt=0;\\n        preorderTraversal(root,path,cnt);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992004,
                "title": "python-bit-mask-beats-100",
                "content": "```python\\nclass Solution:\\n    def pseudoPalindromicPaths (self, node: TreeNode, mask = 0) -> int:\\n\\t\\t# mask has 9 spaces corresponding to 1 to 9 (0b xxxxxxxxx)\\n\\t\\t\\n        mask ^= 1 << node.val - 1\\n\\t\\t# e.g. val = 4 and current mask is 0b011000011\\n\\t\\t# the space 4 of mask is 0 -> change it to 1 (which means the current numbers of 4 is even)\\n\\t\\t# -> mask now is 0b011001011\\n\\t\\t# if that space is 1 then change it to 0 (the numbers of 4 is odd)\\n\\t\\t\\n        if node.left is None and node.right is None: return int((mask & -mask) == mask)\\n\\t\\t# a trick to check if mask is a power of 2 (which means mask contains 0 or 1 ones)\\n\\t    # if it does return 1 else 0\\n\\t\\t\\n        return (\\n\\t\\t\\tself.pseudoPalindromicPaths(node.left, mask) if node.left else 0\\n\\t\\t) + (\\n\\t\\t\\tself.pseudoPalindromicPaths(node.right, mask) if node.right else 0\\n\\t\\t)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```python\\nclass Solution:\\n    def pseudoPalindromicPaths (self, node: TreeNode, mask = 0) -> int:\\n\\t\\t# mask has 9 spaces corresponding to 1 to 9 (0b xxxxxxxxx)\\n\\t\\t\\n        mask ^= 1 << node.val - 1\\n\\t\\t# e.g. val = 4 and current mask is 0b011000011\\n\\t\\t# the space 4 of mask is 0 -> change it to 1 (which means the current numbers of 4 is even)\\n\\t\\t# -> mask now is 0b011001011\\n\\t\\t# if that space is 1 then change it to 0 (the numbers of 4 is odd)\\n\\t\\t\\n        if node.left is None and node.right is None: return int((mask & -mask) == mask)\\n\\t\\t# a trick to check if mask is a power of 2 (which means mask contains 0 or 1 ones)\\n\\t    # if it does return 1 else 0\\n\\t\\t\\n        return (\\n\\t\\t\\tself.pseudoPalindromicPaths(node.left, mask) if node.left else 0\\n\\t\\t) + (\\n\\t\\t\\tself.pseudoPalindromicPaths(node.right, mask) if node.right else 0\\n\\t\\t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648862,
                "title": "java-dfs-using-set",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        dfs(root, new HashSet<>());\\n        return count;\\n    }\\n    private void dfs(TreeNode node, Set<Integer> set) {\\n        if(node !=null) {\\n            if(set.contains(node.val)) set.remove(node.val); else set.add(node.val);\\n            if(node.left ==null && node.right == null) {\\n                if(set.size() <=1) count++;\\n            } else {\\n                dfs(node.left, new HashSet<>(set));\\n                dfs(node.right, new HashSet<>(set));                \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        dfs(root, new HashSet<>());\\n        return count;\\n    }\\n    private void dfs(TreeNode node, Set<Integer> set) {\\n        if(node !=null) {\\n            if(set.contains(node.val)) set.remove(node.val); else set.add(node.val);\\n            if(node.left ==null && node.right == null) {\\n                if(set.size() <=1) count++;\\n            } else {\\n                dfs(node.left, new HashSet<>(set));\\n                dfs(node.right, new HashSet<>(set));                \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575009,
                "title": "simple-backtracking-and-dfs",
                "content": "**Approach**\\n\\n* Evaluation is only when the current Node is NULL.\\n* Palindrome is changable that means **{3 ,2 ,2}**  is convertable to **{2 ,3 ,2}** *(Palindrome)*.\\n* For a sequence to be palindrome just check that **at most one number is to be there whos occurance is odd**.\\n\\n **Code**\\n```\\n#define ll int\\n#define l left\\n#define r right\\n#define s second\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    map<ll,ll> m;\\n    void helper(TreeNode* root){\\n        if(!root) return;\\n        m[root->val]+=1;\\n        if(!root->l and !root->r){\\n            int oddCount=0;\\n            for(auto it:m) oddCount+=(it.s%2!=0);\\n            ans+=(oddCount<=1);\\n        }\\n        if(root->left) helper(root->left);\\n        if(root->right) helper(root->right);\\n        m[root->val]-=1;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        if(!root) return 0;\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n#define ll int\\n#define l left\\n#define r right\\n#define s second\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    map<ll,ll> m;\\n    void helper(TreeNode* root){\\n        if(!root) return;\\n        m[root->val]+=1;\\n        if(!root->l and !root->r){\\n            int oddCount=0;\\n            for(auto it:m) oddCount+=(it.s%2!=0);\\n            ans+=(oddCount<=1);\\n        }\\n        if(root->left) helper(root->left);\\n        if(root->right) helper(root->right);\\n        m[root->val]-=1;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        if(!root) return 0;\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201843,
                "title": "java-solution-using-recursion",
                "content": "**Intuition**\\n\\nAtmost we can have one digit with odd frequency for the given number or path.\\n```\\nEg: 121 (frequency of 1 -> 2, 2 -> 1)\\n    2332 (frequency of 2 -> 2, 3 -> 2)\\n```\\n\\n**Explanation for bit manipulation:**\\n```\\n/*\\n-> Step 1:\\nHere we are keeping the frequency for every element from 0 - 9 in binary \\nrepresentation (from right - left) using left shift operation (1 << node.val)\\n(which means that it performs the left shift operation on \"001\" for root.val times \\nwhich makes it move to the position that we are keeping the count for \"node.val\")\\n\\nEg: (1 << 2) -> (001 << 2) -> (100)\\nhere node.val is 2, so by left shifting it by 2 times we are changing the position of 1 in (001) -> (100)\\nsaying that we have one \"2\" already in our path\\n\\ndigit :     9 8 7 6 5 4 3 2 1 0\\nfrequency : 0 0 0 0 0 0 0 1 0 0 (freq)\\n\\n-> Step 2:\\nHere we are performing \"xor\" operation on the step 1 result i.e., (1 << node.val)\\nThis xor operation is used for cancelling out even frequencies and adding \\nnew frequencies for the other numbers and keeping it in the \"freq\" variable.\\n(initially path = 0)\\n\\nxor table:\\n0 0 -> 0\\n0 1 -> 1\\n1 0 -> 1\\n1 1 -> 0\\n\\nEg:  \\n* lets consider the tree path \"233\"\\n\\nfor 2 -> path = 0 ^ (1 << 2) = 0 ^ 4 = (0000 ^ 0100) = 0100 (4) \\nfor 3 -> path = 4 ^ (1 << 3) = 4 ^ 8 = (0100 ^ 1000) = 1100 (12)\\nfor 3 -> path = 12 ^ (1 << 3) = 12 ^ 8 = (1100 ^ 1000) = 0100 (4)\\n\\nso for tree path \"233\" there is only one digit with odd frequency (freq - 0100). so it can be a palindrome\\n\\n* lets consider tree path \"231\"\\n\\nfor 2 -> path = 0 ^ (1 << 2) = 0 ^ 4 = (0000 ^ 0100) = 0100 (4) \\nfor 3 -> path = 4 ^ (1 << 3) = 4 ^ 8 = (0100 ^ 1000) = 1100 (12)\\nfor 1 -> path = 12 ^ (1 << 1) = 12 ^ 2 = (1100 ^ 0010) = 1110 (14)\\n\\nso for tree path \"231\" there are three digits that have odd frequency (freq - 1110). so it can\\'t be a palindrome\\n\\n-> Step - 3:\\nif the node is a leaf node, then we have to check the given path is valid palindrome or not.\\nhere we are using the freq and checking how many 1\\'s are there in the \"freq\" variable by using a simple trick\\n\\nIntuition -> if the bitwise and(&) for \"freq\" and \"(freq-1)\" is equal to 0, then the given path has only 1 digit atmost with odd frequency\\n\\nbitwise and (&) table:\\n0 0 -> 0\\n0 1 -> 0\\n1 0 -> 0\\n1 1 -> 1\\n\\nEg: \\nfreq = 4(100), freq-1 = 3(011)\\n=> (freq & (freq - 1)) = (100 & 011) = 0(000)\\n\\nfreq = 5(101), freq-1 = 4(100)\\n=> (freq & (freq - 1)) = (101 & 100) = 0(100)\\n\\nso if we have atmost one \"1\" in the freq then it will cancel out if we do the bitwise and operation\\nbetween freq and (freq-1).\\n\\n*/\\n```\\n\\n\\nSolution 1: (using bit manipulation)\\n```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return helper(root, 0);\\n    }\\n    \\n    public int helper(TreeNode node, int freq) {\\n        if (node == null) return 0;\\n        \\n        freq = freq ^ (1 << node.val);\\n        if (node.left == null && node.right == null) {\\n            return (freq & (freq - 1)) == 0 ? 1 : 0;\\n            // return Integer.bitCount(freq) <= 1 ? 1 : 0;\\n        }\\n        return helper(node.left, freq) + helper(node.right, freq);\\n    }\\n}\\n```\\n\\n\\nSolution 2: (using hashset)\\n```\\nclass Solution {\\n    int paths = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        helper(root, new HashSet());\\n        return paths;\\n    }\\n    public void helper(TreeNode node, Set<Integer> num) {\\n        if (node == null) return;\\n        \\n        if (num.contains(node.val)) {\\n            num.remove(node.val);\\n        } else {\\n            num.add(node.val);\\n        }\\n        if (node.left == null && node.right == null) {\\n            paths += num.size() <= 1 ? 1 : 0;\\n            return;\\n        }\\n        helper(node.left, new HashSet(num));\\n        helper(node.right, new HashSet(num));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nEg: 121 (frequency of 1 -> 2, 2 -> 1)\\n    2332 (frequency of 2 -> 2, 3 -> 2)\\n```\n```\\n/*\\n-> Step 1:\\nHere we are keeping the frequency for every element from 0 - 9 in binary \\nrepresentation (from right - left) using left shift operation (1 << node.val)\\n(which means that it performs the left shift operation on \"001\" for root.val times \\nwhich makes it move to the position that we are keeping the count for \"node.val\")\\n\\nEg: (1 << 2) -> (001 << 2) -> (100)\\nhere node.val is 2, so by left shifting it by 2 times we are changing the position of 1 in (001) -> (100)\\nsaying that we have one \"2\" already in our path\\n\\ndigit :     9 8 7 6 5 4 3 2 1 0\\nfrequency : 0 0 0 0 0 0 0 1 0 0 (freq)\\n\\n-> Step 2:\\nHere we are performing \"xor\" operation on the step 1 result i.e., (1 << node.val)\\nThis xor operation is used for cancelling out even frequencies and adding \\nnew frequencies for the other numbers and keeping it in the \"freq\" variable.\\n(initially path = 0)\\n\\nxor table:\\n0 0 -> 0\\n0 1 -> 1\\n1 0 -> 1\\n1 1 -> 0\\n\\nEg:  \\n* lets consider the tree path \"233\"\\n\\nfor 2 -> path = 0 ^ (1 << 2) = 0 ^ 4 = (0000 ^ 0100) = 0100 (4) \\nfor 3 -> path = 4 ^ (1 << 3) = 4 ^ 8 = (0100 ^ 1000) = 1100 (12)\\nfor 3 -> path = 12 ^ (1 << 3) = 12 ^ 8 = (1100 ^ 1000) = 0100 (4)\\n\\nso for tree path \"233\" there is only one digit with odd frequency (freq - 0100). so it can be a palindrome\\n\\n* lets consider tree path \"231\"\\n\\nfor 2 -> path = 0 ^ (1 << 2) = 0 ^ 4 = (0000 ^ 0100) = 0100 (4) \\nfor 3 -> path = 4 ^ (1 << 3) = 4 ^ 8 = (0100 ^ 1000) = 1100 (12)\\nfor 1 -> path = 12 ^ (1 << 1) = 12 ^ 2 = (1100 ^ 0010) = 1110 (14)\\n\\nso for tree path \"231\" there are three digits that have odd frequency (freq - 1110). so it can\\'t be a palindrome\\n\\n-> Step - 3:\\nif the node is a leaf node, then we have to check the given path is valid palindrome or not.\\nhere we are using the freq and checking how many 1\\'s are there in the \"freq\" variable by using a simple trick\\n\\nIntuition -> if the bitwise and(&) for \"freq\" and \"(freq-1)\" is equal to 0, then the given path has only 1 digit atmost with odd frequency\\n\\nbitwise and (&) table:\\n0 0 -> 0\\n0 1 -> 0\\n1 0 -> 0\\n1 1 -> 1\\n\\nEg: \\nfreq = 4(100), freq-1 = 3(011)\\n=> (freq & (freq - 1)) = (100 & 011) = 0(000)\\n\\nfreq = 5(101), freq-1 = 4(100)\\n=> (freq & (freq - 1)) = (101 & 100) = 0(100)\\n\\nso if we have atmost one \"1\" in the freq then it will cancel out if we do the bitwise and operation\\nbetween freq and (freq-1).\\n\\n*/\\n```\n```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return helper(root, 0);\\n    }\\n    \\n    public int helper(TreeNode node, int freq) {\\n        if (node == null) return 0;\\n        \\n        freq = freq ^ (1 << node.val);\\n        if (node.left == null && node.right == null) {\\n            return (freq & (freq - 1)) == 0 ? 1 : 0;\\n            // return Integer.bitCount(freq) <= 1 ? 1 : 0;\\n        }\\n        return helper(node.left, freq) + helper(node.right, freq);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int paths = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        helper(root, new HashSet());\\n        return paths;\\n    }\\n    public void helper(TreeNode node, Set<Integer> num) {\\n        if (node == null) return;\\n        \\n        if (num.contains(node.val)) {\\n            num.remove(node.val);\\n        } else {\\n            num.add(node.val);\\n        }\\n        if (node.left == null && node.right == null) {\\n            paths += num.size() <= 1 ? 1 : 0;\\n            return;\\n        }\\n        helper(node.left, new HashSet(num));\\n        helper(node.right, new HashSet(num));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734452,
                "title": "java-dfs-solution-using-bit-mask-100-in-14-lines",
                "content": "2 key takeaways:\\nUse a bit mask to keep track of odd or even number of digits accumulated, in bits 1-9, using XOR. (mask & (mask-1)) == 0 is a quick check to see if mask has only one bit set to 1.\\nCheck for palindrome property one a leaf node, that is a node with no children.\\n\\n```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n    public int dfs(TreeNode root, int mask) {\\n        if (root == null) return 0;\\n        mask = mask ^ (1 << root.val);\\n        if (root.left == null && root.right == null) {\\n            if (mask == 0 || (mask & (mask-1)) == 0) return 1;\\n            return 0;\\n        }\\n        return dfs(root.left, mask) + dfs(root.right, mask);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return dfs(root, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 659591,
                "title": "java-simple-recursion",
                "content": "```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        if (root == null) return 0;\\n        return dfs(root, \"\");\\n    }\\n    \\n    private int dfs(TreeNode node, String path) {\\n        if (node == null) return 0;\\n        if (node.left == null && node.right == null) return isPal(path + node.val) ? 1 : 0;\\n        return dfs(node.left, path + node.val) + dfs(node.right, path + node.val);\\n    }\\n    \\n    private boolean isPal(String s) {\\n        int m = s.length(), odd = 0;\\n        if (m == 0) return false;\\n        int[] cnt = new int[10];\\n        for (char c : s.toCharArray()) {\\n            cnt[c - \\'0\\']++;\\n        }\\n        for (int i = 0; i < cnt.length; i++) {\\n            odd += cnt[i] % 2 == 1 ? 1 : 0;\\n        }\\n        return odd == 0 || (m % 2 == 1 && odd == 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        if (root == null) return 0;\\n        return dfs(root, \"\");\\n    }\\n    \\n    private int dfs(TreeNode node, String path) {\\n        if (node == null) return 0;\\n        if (node.left == null && node.right == null) return isPal(path + node.val) ? 1 : 0;\\n        return dfs(node.left, path + node.val) + dfs(node.right, path + node.val);\\n    }\\n    \\n    private boolean isPal(String s) {\\n        int m = s.length(), odd = 0;\\n        if (m == 0) return false;\\n        int[] cnt = new int[10];\\n        for (char c : s.toCharArray()) {\\n            cnt[c - \\'0\\']++;\\n        }\\n        for (int i = 0; i < cnt.length; i++) {\\n            odd += cnt[i] % 2 == 1 ? 1 : 0;\\n        }\\n        return odd == 0 || (m % 2 == 1 && odd == 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648332,
                "title": "java-o-n-dfs-hashset-bitwise",
                "content": "**HashSet**\\nA palindrome has to have an even frequency for all digits, and at most one odd frequency (the middle digit). Because of this, a HashSet can be used to keep track of all the digits in the root -> node path that have an odd frequency. When a digit is encountered, it will be added to the set if the set doesn\\'t contain it, or it will be removed from the set if the set already contains it. If the current node is a leaf, then the size of the set has to be at most 1 in order for the path to be a permutation of a palindrome.\\n```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return search(root, new HashSet<>());\\n    }\\n    public int search(TreeNode tn, HashSet<Integer> set) {\\n        if (tn == null) {\\n            return 0;\\n        }\\n        \\n        if (set.contains(tn.val)) {\\n            set.remove(tn.val);\\n        } else {\\n            set.add(tn.val);\\n        }\\n        \\n        int res = 0;\\n        if (tn.left == null && tn.right == null && set.size() <= 1) {\\n            res++;\\n        }\\n        \\n        res += search(tn.left, set) + search(tn.right, set);\\n        if (set.contains(tn.val)) {\\n            set.remove(tn.val);\\n        } else {\\n            set.add(tn.val);\\n        }\\n        return res;\\n    }\\n}\\n```\\n**Bitwise**\\nInstead of the hashset, an int can be used to store the frequencies. To update, xor it by 2^val. Use Integer.bitCount() to find the number of odds.\\n```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return search(root, 0);\\n    }\\n    public int search(TreeNode tn, int i) {\\n        if (tn == null) {\\n            return 0;\\n        }\\n        i ^= 1 << tn.val;\\n        int res = 0;\\n        if (tn.left == null && tn.right == null && Integer.bitCount(i) <= 1) {\\n            res++;\\n        }\\n        res += search(tn.left, i) + search(tn.right, i);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return search(root, new HashSet<>());\\n    }\\n    public int search(TreeNode tn, HashSet<Integer> set) {\\n        if (tn == null) {\\n            return 0;\\n        }\\n        \\n        if (set.contains(tn.val)) {\\n            set.remove(tn.val);\\n        } else {\\n            set.add(tn.val);\\n        }\\n        \\n        int res = 0;\\n        if (tn.left == null && tn.right == null && set.size() <= 1) {\\n            res++;\\n        }\\n        \\n        res += search(tn.left, set) + search(tn.right, set);\\n        if (set.contains(tn.val)) {\\n            set.remove(tn.val);\\n        } else {\\n            set.add(tn.val);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        return search(root, 0);\\n    }\\n    public int search(TreeNode tn, int i) {\\n        if (tn == null) {\\n            return 0;\\n        }\\n        i ^= 1 << tn.val;\\n        int res = 0;\\n        if (tn.left == null && tn.right == null && Integer.bitCount(i) <= 1) {\\n            res++;\\n        }\\n        res += search(tn.left, i) + search(tn.right, i);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648259,
                "title": "python-dfs-bitmap",
                "content": "For a valid pseudo-palindromic, it should contain only one odd frequency digit.\\nThe order doesn\\'t matter. so we just need to consider the frequency.\\nEven the frequency doesn\\'t matter, we only need to consider it\\'s odd(1) or even(0).\\nSince there are only 9 possibile digits, we can use a bitmap to record the parity(odd or even) status  of each digit i at (i-1)th bit.\\nWe use dfs to traverse each path. At each node `x`, we update current status in `s` by `s ^= 1 << (x.val - 1)`.\\nSo when we each a leaf, we check its status. `s` should has no more than 1 bit set and be in `{0, 1, 2, 4, 8, 16, 32, 64, 128, 256}`.\\n```\\ndef pseudoPalindromicPaths(root):\\n    target = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256}\\n    def dfs(x, s):\\n        s ^= 1 << (x.val - 1)\\n        if not x.left and not x.right:\\n            return int(s in target)\\n        return (dfs(x.left, s) if x.left else 0) + (dfs(x.right, s) if x.right else 0)\\n    return dfs(root, 0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef pseudoPalindromicPaths(root):\\n    target = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256}\\n    def dfs(x, s):\\n        s ^= 1 << (x.val - 1)\\n        if not x.left and not x.right:\\n            return int(s in target)\\n        return (dfs(x.left, s) if x.left else 0) + (dfs(x.right, s) if x.right else 0)\\n    return dfs(root, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2575433,
                "title": "c-solution-dfs-counting",
                "content": "**Simple C++ Approach:**\\n1. Take an array of size 10 (for numbers from 0-9)\\n2. Iterate on tree, i did inordered traversal\\n3. The helper array will maintain count of every number from 0-9 in our path\\n4. If we are on root node and number of digits we got in our path occured odd times is more than 1 than return 0 because we cannot make pallindrome out of it.\\n5. Else return 1.\\n6. Total number of such paths is our answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int findAllPaths(TreeNode*root,vector<int>&helper){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        helper[root->val]+=1;\\n        if(!root->left&&!root->right){\\n            int odds=0;\\n            for(auto x:helper){\\n                if(x%2!=0) odds++;\\n            }\\n            //cout<<odds<<\" \"<<root->val<<endl;\\n            if(odds<=1){\\n                helper[root->val]-=1;\\n                return 1;\\n            }\\n        }\\n        int left=findAllPaths(root->left,helper);\\n        int right=findAllPaths(root->right,helper);\\n        helper[root->val]-=1;\\n        return left+right;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> helper(10,0);\\n        return findAllPaths(root,helper);\\n    }\\n};\\n```\\n**Thanks for watching, if liked, consider an upvote**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findAllPaths(TreeNode*root,vector<int>&helper){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        helper[root->val]+=1;\\n        if(!root->left&&!root->right){\\n            int odds=0;\\n            for(auto x:helper){\\n                if(x%2!=0) odds++;\\n            }\\n            //cout<<odds<<\" \"<<root->val<<endl;\\n            if(odds<=1){\\n                helper[root->val]-=1;\\n                return 1;\\n            }\\n        }\\n        int left=findAllPaths(root->left,helper);\\n        int right=findAllPaths(root->right,helper);\\n        helper[root->val]-=1;\\n        return left+right;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> helper(10,0);\\n        return findAllPaths(root,helper);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2574662,
                "title": "c-fast-solution-without-iterating-map-o-n-time-o-n-space",
                "content": "```\\n    unordered_map<int,int> freq;\\n    void inorder(TreeNode* root , int &ans , int odd)\\n    {\\n        if(root==NULL) return;\\n        if(freq[root->val]%2) odd--;\\n         freq[root->val]++;\\n        if(freq[root->val]%2) odd++;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            if(odd<=1) ans++;\\n             freq[root->val]--;\\n            return;\\n        }\\n        inorder(root->left,ans,odd);\\n        inorder(root->right,ans,odd);\\n        freq[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        int ans=0;\\n        inorder(root,ans,0);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    unordered_map<int,int> freq;\\n    void inorder(TreeNode* root , int &ans , int odd)\\n    {\\n        if(root==NULL) return;\\n        if(freq[root->val]%2) odd--;\\n         freq[root->val]++;\\n        if(freq[root->val]%2) odd++;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            if(odd<=1) ans++;\\n             freq[root->val]--;\\n            return;\\n        }\\n        inorder(root->left,ans,odd);\\n        inorder(root->right,ans,odd);\\n        freq[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        int ans=0;\\n        inorder(root,ans,0);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2574386,
                "title": "python-simple-dfs-fully-explained-and-commented",
                "content": "# Logic explanation\\nA palindrome is a word that is read the same if you read it left-to-right or right-to-left.\\nExamples:\\n\\nkayak.\\ndeified.\\nrotator.\\nrepaper.\\ndeed.\\n\\nIn the question we need to check whether a path from the root node to a leaf node is a palindrome, but the order of letters doesn\\'t matter.\\n\\nA word will be a palindrome if all the characters occur even amount of times, because you can place half of them in the beginning and half in the end. And you can afford to have 1 odd frequency character that will be placed in the middle.\\n\\nWith that observation, we can just DFS the tree and have a frequency counter (`freq`) that will count character occurences. And a `odd_freq_count` that will count how many odd frequencies we have.\\nWhenever we reach a leaf node, just check that the `odd_freq_count` is either 0 or 1, as we observed above.\\n\\n\\n```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        freq = defaultdict(int)\\n        \\n        def pal_count(node: Optional[TreeNode], odd_freq_count: int):\\n            if not node: return 0\\n            \\n            node_val = node.val\\n            \\n            # update frequency\\n            freq[node_val] += 1\\n            \\n            # if odd\\n            if freq[node_val] % 2 != 0:\\n                odd_freq_count += 1\\n            # otherwise even\\n            else:\\n                odd_freq_count -= 1\\n                \\n            # check whether leaf node\\n            if not node.left and not node.right:\\n                # backtrack\\n                freq[node_val] -= 1\\n                \\n                # if palindrome return 1\\n                if odd_freq_count <= 1:\\n                    return 1\\n                return 0\\n            \\n            # sum values from left and right subtrees\\n            ans = pal_count(node.left, odd_freq_count) + pal_count(node.right, odd_freq_count)\\n            \\n            # backtrack\\n            freq[node_val] -= 1\\n            \\n            return ans\\n            \\n            \\n        return pal_count(root, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        freq = defaultdict(int)\\n        \\n        def pal_count(node: Optional[TreeNode], odd_freq_count: int):\\n            if not node: return 0\\n            \\n            node_val = node.val\\n            \\n            # update frequency\\n            freq[node_val] += 1\\n            \\n            # if odd\\n            if freq[node_val] % 2 != 0:\\n                odd_freq_count += 1\\n            # otherwise even\\n            else:\\n                odd_freq_count -= 1\\n                \\n            # check whether leaf node\\n            if not node.left and not node.right:\\n                # backtrack\\n                freq[node_val] -= 1\\n                \\n                # if palindrome return 1\\n                if odd_freq_count <= 1:\\n                    return 1\\n                return 0\\n            \\n            # sum values from left and right subtrees\\n            ans = pal_count(node.left, odd_freq_count) + pal_count(node.right, odd_freq_count)\\n            \\n            # backtrack\\n            freq[node_val] -= 1\\n            \\n            return ans\\n            \\n            \\n        return pal_count(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574253,
                "title": "easy-recursion-set-o-n-explained-java-cpp-backtrack",
                "content": "This is an easy one! :) \\n\\nHow can we check if any permutation of a number is palindrome ? \\n```\\n1 2 3 2 1     Yes\\n1 2 2 1       Yes\\n1 1 1 1       Yes\\n1 2 1 1 2     No\\n```\\n\\n**Observations**\\nPalindrome contains numbers in pair, correct ?\\nIt can have atmost one single number which we can place in the middle ?  (1 2 **3** 2 1)\\n\\n**How can we achieve this ?**\\nWe can create a set - \\n* Everytime we come across a number which is already present in set (We have found a pair !!), we can remove it from set \\n* If a new number comes, we can add in set (A unique/single number as of this particular iteration)\\n* In the end, if our set becomes empty, means every number was in some pair (Palindrome!!)\\n* Or if the size of set is 1, means only one single number is left, it can be placed in the middle (Palindrome!!  eg ->  1 2 **3** 2 1 )\\n\\n\\n**Integrating this part with Tree Recursion**\\n\\nWe can access Path of Tree in any fashion, I have done this in Pre-Order\\n\\nComing across a node - \\n\\n**1st Step** :   null check \\n**2nd Step**:  Above logic for set -> Check if set already contains that node or not \\n```\\n  if(set.contains(root.val)) set.remove(root.val);\\n  else set.add(root.val);\\n```\\n**3rd Step**:  We need to check palindrome for every path of tree, means whenever we completes a path... i.e.  Whenever we come across a leaf node, right ?\\n\\n```\\nif(root.left == null && root.right == null){\\n            if(set.size() == 1 || set.isEmpty()) res++;\\n}\\n```\\n\\n**4th Step**:  Tree Treaversal (left and right subtrees)\\n```\\nutil(root.left, set);\\nutil(root.right, set);\\n```\\n**5th Step**:  *Backtracking Step* -> After accessing a particular path, when going back, we should discard the current no, right ? So, modify the set, right\\n\\n* Our set takes care of duplicate values\\n```\\n        2\\n\\t  /   \\\\\\n\\t 3      1\\n\\t/ \\\\      \\\\\\n   3   1      1\\n```\\n\\n* So, First path will be **(2 3 3)**\\n* After processing last 3 here, our set will contain **[2]** based on above logic (as we have two occurences of 3)\\n* So, while going back, we need to add a 3 in the set, because for the other path **(2 3 1)** this 3 will not be a duplicate value \\n* Now for the second path (2 3 1), while going back, our set will contain **[2 3 1]** (all uniques), so we can simply remove 1 from the set \\n\\n**So final logic comes as** : If set does not contains the value, add it in set, if it contains, remove it . \\n\\nThis sums up the question!\\n**Please do a dry-run for clear understanding!!**\\n\\nCode - \\n```\\nclass Solution {\\n    \\n    public int res = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        \\n        Set<Integer> set = new HashSet<>();\\n        util(root, set);\\n        return res;\\n    }\\n    \\n    public void util(TreeNode root, Set<Integer> set){\\n        if(root == null) return;\\n        \\n        if(set.contains(root.val)) set.remove(root.val);\\n        else set.add(root.val);\\n        \\n        if(root.left == null && root.right == null){\\n            if(set.size() == 1 || set.isEmpty()) res++;\\n        }\\n        \\n        util(root.left, set);\\n        util(root.right, set);\\n        \\n        if(set.contains(root.val)) set.remove(root.val);\\n        else set.add(root.val);\\n        \\n    }\\n    \\n}\\n```\\n\\nPlease, UPVOTE if you like! : ) \\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n1 2 3 2 1     Yes\\n1 2 2 1       Yes\\n1 1 1 1       Yes\\n1 2 1 1 2     No\\n```\n```\\n  if(set.contains(root.val)) set.remove(root.val);\\n  else set.add(root.val);\\n```\n```\\nif(root.left == null && root.right == null){\\n            if(set.size() == 1 || set.isEmpty()) res++;\\n}\\n```\n```\\nutil(root.left, set);\\nutil(root.right, set);\\n```\n```\\n        2\\n\\t  /   \\\\\\n\\t 3      1\\n\\t/ \\\\      \\\\\\n   3   1      1\\n```\n```\\nclass Solution {\\n    \\n    public int res = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        \\n        Set<Integer> set = new HashSet<>();\\n        util(root, set);\\n        return res;\\n    }\\n    \\n    public void util(TreeNode root, Set<Integer> set){\\n        if(root == null) return;\\n        \\n        if(set.contains(root.val)) set.remove(root.val);\\n        else set.add(root.val);\\n        \\n        if(root.left == null && root.right == null){\\n            if(set.size() == 1 || set.isEmpty()) res++;\\n        }\\n        \\n        util(root.left, set);\\n        util(root.right, set);\\n        \\n        if(set.contains(root.val)) set.remove(root.val);\\n        else set.add(root.val);\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573998,
                "title": "java-easy-fast-dfs-commented",
                "content": "Runtime: 11 ms, faster than 94.74% of Java online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\nMemory Usage: 67.9 MB, less than 97.95% of Java online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\n\\n**Idea of solution :**\\n1. create array **digits** for 10 digits and put into array digits from root.val\\n2. start dfs and retain digits in **digits** for path.  When we will in **leaf** - check : can we construct polindrome or not ? (if we have in **digits** more then 1 odd number - answer is obvious : NO)\\n```\\nclass Solution {\\n  private int digits[], ans;\\n  \\n  private void isPolindrome(){\\n    boolean odd = false;\\n    \\n    for(int n: digits)\\n      if( (n&1) == 1 )\\n        if(odd) return;\\n        else odd = true;\\n     \\n    ans++;\\n  }\\n  \\n  private void dfs(TreeNode root){\\n    digits[root.val]++;\\n    \\n    if(root.left == null && root.right == null) isPolindrome();\\n    if(root.left  != null) dfs(root.left);\\n    if(root.right != null) dfs(root.right);\\n    \\n    digits[root.val]--;\\n  }\\n    \\n  public int pseudoPalindromicPaths (TreeNode root) {\\n    digits = new int[10];\\n    ans = 0;\\n    \\n    dfs(root);\\n    return ans;\\n  }\\n}\\n```\\n\\n**HARD CODE version**\\nRuntime: 12 ms, faster than 90.94% of Java online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\nMemory Usage: 105.8 MB, less than 73.39% of Java online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\n```\\nclass Solution {\\n  private int digits = 0, ans = 0;\\n  \\n  private void isPolindrome(){\\n    int n = digits;\\n    n -= (n>>1) & 0x55555555;\\n    n = ((n>>2) & 0x33333333 ) + (n & 0x33333333);\\n    n = ((((n>>4) + n) & 0x0F0F0F0F) * 0x01010101) >> 24;\\n     \\n    if( (n&-2) == 0) ans++;\\n  }\\n  \\n  private void dfs(TreeNode root){\\n    int mask = 1 << root.val;\\n    digits ^= mask;\\n    \\n    if(root.left == null && root.right == null) isPolindrome();\\n    if(root.left  != null) dfs(root.left);\\n    if(root.right != null) dfs(root.right);\\n    \\n    digits ^= mask;\\n  }\\n    \\n  public int pseudoPalindromicPaths (TreeNode root) {\\n    dfs(root);\\n    return ans;\\n  }\\n}\\n```\\n**AND ALSO ...**\\nRuntime: 10 ms, faster than 97.08% of Java online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\nMemory Usage: 68.5 MB, less than 93.86% of Java online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\n```\\nclass Solution {\\n  private int d[] = new int[10], ans = 0;\\n  \\n  private void dfs(TreeNode root){\\n    d[root.val] ^= 1;\\n    \\n    if(root.left == null && root.right == null)\\n      if( ((d[0] + d[1] + d[2] + d[3] + d[4] + d[5] + d[6] + d[7] + d[8] + d[9])&-2) == 0) ans++;\\n    if(root.left  != null) dfs(root.left);\\n    if(root.right != null) dfs(root.right);\\n    \\n    d[root.val] ^= 1;\\n  }\\n    \\n  public int pseudoPalindromicPaths (TreeNode root) {\\n    dfs(root);\\n    return ans;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  private int digits[], ans;\\n  \\n  private void isPolindrome(){\\n    boolean odd = false;\\n    \\n    for(int n: digits)\\n      if( (n&1) == 1 )\\n        if(odd) return;\\n        else odd = true;\\n     \\n    ans++;\\n  }\\n  \\n  private void dfs(TreeNode root){\\n    digits[root.val]++;\\n    \\n    if(root.left == null && root.right == null) isPolindrome();\\n    if(root.left  != null) dfs(root.left);\\n    if(root.right != null) dfs(root.right);\\n    \\n    digits[root.val]--;\\n  }\\n    \\n  public int pseudoPalindromicPaths (TreeNode root) {\\n    digits = new int[10];\\n    ans = 0;\\n    \\n    dfs(root);\\n    return ans;\\n  }\\n}\\n```\n```\\nclass Solution {\\n  private int digits = 0, ans = 0;\\n  \\n  private void isPolindrome(){\\n    int n = digits;\\n    n -= (n>>1) & 0x55555555;\\n    n = ((n>>2) & 0x33333333 ) + (n & 0x33333333);\\n    n = ((((n>>4) + n) & 0x0F0F0F0F) * 0x01010101) >> 24;\\n     \\n    if( (n&-2) == 0) ans++;\\n  }\\n  \\n  private void dfs(TreeNode root){\\n    int mask = 1 << root.val;\\n    digits ^= mask;\\n    \\n    if(root.left == null && root.right == null) isPolindrome();\\n    if(root.left  != null) dfs(root.left);\\n    if(root.right != null) dfs(root.right);\\n    \\n    digits ^= mask;\\n  }\\n    \\n  public int pseudoPalindromicPaths (TreeNode root) {\\n    dfs(root);\\n    return ans;\\n  }\\n}\\n```\n```\\nclass Solution {\\n  private int d[] = new int[10], ans = 0;\\n  \\n  private void dfs(TreeNode root){\\n    d[root.val] ^= 1;\\n    \\n    if(root.left == null && root.right == null)\\n      if( ((d[0] + d[1] + d[2] + d[3] + d[4] + d[5] + d[6] + d[7] + d[8] + d[9])&-2) == 0) ans++;\\n    if(root.left  != null) dfs(root.left);\\n    if(root.right != null) dfs(root.right);\\n    \\n    d[root.val] ^= 1;\\n  }\\n    \\n  public int pseudoPalindromicPaths (TreeNode root) {\\n    dfs(root);\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573972,
                "title": "c-explained-solution-backtracking-map-implementation-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(TreeNode* root, map<int,int> &mp){\\n        if(root == NULL) return 0;\\n        if(root->left == NULL && root->right == NULL){\\n            mp[root->val]++;\\n            int x = 0; // keeping track of how many elements occur odd number of times\\n            for(auto it:mp){\\n                if(it.second % 2 != 0) x++; // checking odd occurrences\\n            }\\n            mp[root->val]--; // backtracking\\n            if(mp[root->val] == 0) mp.erase(root->val);\\n            if(x > 1) return 0; // if its a pallindrome then only one element can be in odd frequency\\n            return 1;\\n        }\\n        mp[root->val]++;\\n        int l = solve(root->left,mp); // calculating how many paths are valid in left subtree\\n        int r = solve(root->right,mp); // calculating how many paths are valid in right subtree\\n        mp[root->val]--; // backtracking\\n        if(mp[root->val] == 0) mp.erase(root->val); // removing from the map if frequency reaches 0\\n        return l + r; // returning all the possible cases from both the subtree\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        map<int,int> mp;\\n        return solve(root,mp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(TreeNode* root, map<int,int> &mp){\\n        if(root == NULL) return 0;\\n        if(root->left == NULL && root->right == NULL){\\n            mp[root->val]++;\\n            int x = 0; // keeping track of how many elements occur odd number of times\\n            for(auto it:mp){\\n                if(it.second % 2 != 0) x++; // checking odd occurrences\\n            }\\n            mp[root->val]--; // backtracking\\n            if(mp[root->val] == 0) mp.erase(root->val);\\n            if(x > 1) return 0; // if its a pallindrome then only one element can be in odd frequency\\n            return 1;\\n        }\\n        mp[root->val]++;\\n        int l = solve(root->left,mp); // calculating how many paths are valid in left subtree\\n        int r = solve(root->right,mp); // calculating how many paths are valid in right subtree\\n        mp[root->val]--; // backtracking\\n        if(mp[root->val] == 0) mp.erase(root->val); // removing from the map if frequency reaches 0\\n        return l + r; // returning all the possible cases from both the subtree\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        map<int,int> mp;\\n        return solve(root,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573797,
                "title": "easy-tree-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void solve(TreeNode* root, vector<int> mp){\\n        if(!root)return;\\n        if(!root->left and !root->right){\\n            int cnt = 0;\\n            mp[root->val]++;\\n            for(int i = 0;i<10;i++){\\n                if(mp[i]&1)cnt++;\\n            }\\n            mp[root->val]--;\\n            if(cnt<=1){\\n                ans++;\\n            }\\n            return;\\n        }\\n        mp[root->val]++;\\n        solve(root->left, mp);\\n        solve(root->right, mp);\\n        mp[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> mp(10);\\n        solve(root, mp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void solve(TreeNode* root, vector<int> mp){\\n        if(!root)return;\\n        if(!root->left and !root->right){\\n            int cnt = 0;\\n            mp[root->val]++;\\n            for(int i = 0;i<10;i++){\\n                if(mp[i]&1)cnt++;\\n            }\\n            mp[root->val]--;\\n            if(cnt<=1){\\n                ans++;\\n            }\\n            return;\\n        }\\n        mp[root->val]++;\\n        solve(root->left, mp);\\n        solve(root->right, mp);\\n        mp[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> mp(10);\\n        solve(root, mp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573460,
                "title": "c-solution-using-set-easy-counting",
                "content": "\\n    void rec(TreeNode* root, unordered_set<int>st,int &ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n\\t\\t//if we find the element in set it means it has already occured once so we remove it\\n\\t\\t//we want only that elements in set which occurs odd number of times, so we remove all even occurences.\\n        if(st.find(root->val)!=st.end())\\n        {\\n            st.erase(root->val);\\n        }\\n        else{\\n            st.insert(root->val);\\n        }\\n        if(root->left==NULL and root->right==NULL)\\n        {\\n\\t\\t//only those set will give us pallindrome if they have 1 or 0 elements occuring odd times\\n            if(st.size()<=1)\\n            {\\n                ans++;\\n            }\\n            return;\\n        }\\n        if(root->left) rec(root->left,st,ans);\\n        if(root->right) rec(root->right,st,ans);\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        unordered_set<int>st;\\n        int ans=0;\\n        rec(root,st,ans);\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Counting",
                    "Ordered Set"
                ],
                "code": "\\n    void rec(TreeNode* root, unordered_set<int>st,int &ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n\\t\\t//if we find the element in set it means it has already occured once so we remove it\\n\\t\\t//we want only that elements in set which occurs odd number of times, so we remove all even occurences.\\n        if(st.find(root->val)!=st.end())\\n        {\\n            st.erase(root->val);\\n        }\\n        else{\\n            st.insert(root->val);\\n        }\\n        if(root->left==NULL and root->right==NULL)\\n        {\\n\\t\\t//only those set will give us pallindrome if they have 1 or 0 elements occuring odd times\\n            if(st.size()<=1)\\n            {\\n                ans++;\\n            }\\n            return;\\n        }\\n        if(root->left) rec(root->left,st,ans);\\n        if(root->right) rec(root->right,st,ans);\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        unordered_set<int>st;\\n        int ans=0;\\n        rec(root,st,ans);\\n        return ans;\\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2573162,
                "title": "preorder-traversal-python-solution-using-mapping",
                "content": "```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        def pre(root,dic):\\n            if root is None:\\n                return 0\\n            if root.left is None and root.right is None:\\n                if root.val not in dic:\\n                    dic[root.val]=1\\n                else:\\n                    dic[root.val]+=1\\n                fg=0\\n                for i in dic:\\n                    if dic[i]%2==1 and fg==1:\\n                        return 0\\n                    if dic[i]%2==1:\\n                        fg=1\\n                return 1\\n            if root.val not in dic:\\n                dic[root.val]=1\\n            else:\\n                dic[root.val]+=1\\n            x=pre(root.left,dic)\\n            if root.left:\\n                dic[root.left.val]-=1\\n            y=pre(root.right,dic)\\n            if root.right:\\n                dic[root.right.val]-=1\\n            return x+y\\n        dic={}\\n        return pre(root,dic)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        def pre(root,dic):\\n            if root is None:\\n                return 0\\n            if root.left is None and root.right is None:\\n                if root.val not in dic:\\n                    dic[root.val]=1\\n                else:\\n                    dic[root.val]+=1\\n                fg=0\\n                for i in dic:\\n                    if dic[i]%2==1 and fg==1:\\n                        return 0\\n                    if dic[i]%2==1:\\n                        fg=1\\n                return 1\\n            if root.val not in dic:\\n                dic[root.val]=1\\n            else:\\n                dic[root.val]+=1\\n            x=pre(root.left,dic)\\n            if root.left:\\n                dic[root.left.val]-=1\\n            y=pre(root.right,dic)\\n            if root.right:\\n                dic[root.right.val]-=1\\n            return x+y\\n        dic={}\\n        return pre(root,dic)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936654,
                "title": "backtracking-and-hashmap-c",
                "content": "```\\nclass Solution {\\nmap<int,int>mp;\\nint count=0;\\npublic:\\n    void dfs(TreeNode* root)\\n    {\\n        int countodd=0;\\n        int counteven=0;\\n        if(root==NULL)\\n            return;\\n        else\\n            mp[root->val]++;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            for(auto it:mp)\\n            {\\n                if(it.second%2==0)\\n                    counteven+=it.second;\\n                else\\n                    countodd++;\\n            }\\n            if((counteven%2==0 && countodd==0)|| (counteven%2==0 && countodd==1))\\n                count++;\\n            \\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n        auto it=mp.find(root->val);\\n        it->second--;\\n        \\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nmap<int,int>mp;\\nint count=0;\\npublic:\\n    void dfs(TreeNode* root)\\n    {\\n        int countodd=0;\\n        int counteven=0;\\n        if(root==NULL)\\n            return;\\n        else\\n            mp[root->val]++;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            for(auto it:mp)\\n            {\\n                if(it.second%2==0)\\n                    counteven+=it.second;\\n                else\\n                    countodd++;\\n            }\\n            if((counteven%2==0 && countodd==0)|| (counteven%2==0 && countodd==1))\\n                count++;\\n            \\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n        auto it=mp.find(root->val);\\n        it->second--;\\n        \\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637171,
                "title": "c-recursion-backtacking",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans= 0 ; \\n    map<int,int>mp;\\n    void solve(TreeNode *root,int parity)\\n    {\\n        // base case \\n       \\n        if(root == nullptr)\\n        {\\n            return ; \\n        }\\n        mp[root->val]++;\\n        if(mp[root->val] % 2)\\n            parity++;\\n        else\\n            parity--;\\n         if(root->left == nullptr && root->right == nullptr)\\n        {\\n            if(parity <= 1)\\n              ans++;\\n           // return  ; \\n        }\\n        solve(root->left, parity);\\n        solve(root->right,parity );\\n        mp[root->val]--;\\n       \\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        \\n        if(!root)\\n            return 1 ;\\n        solve(root , 0) ; \\n        return ans ; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ans= 0 ; \\n    map<int,int>mp;\\n    void solve(TreeNode *root,int parity)\\n    {\\n        // base case \\n       \\n        if(root == nullptr)\\n        {\\n            return ; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 992152,
                "title": "pseudo-palindromic-paths-in-a-binary-tree-using-c-with-explanation",
                "content": "As the values of nodes are in range of 1 to 9 . So, we dont need to store all the values in a vector , to improve the space complexity we will just store how many 1\\'s , 2\\'s , 3\\'s ....... 9\\'s are present in current path , for which we need a vector of only size 10; \\nNow if more than 1 value is present in odd number then we can form a palindrome of it.\\nElse we can form a palindrome from it.\\n\\nI hope You will like it. For any doubt comment it.[](http://)\\nCode:-\\n\\n```\\n #define rep(i,a,b) for(lli i=a;i<b;i++)\\nclass Solution {\\npublic:\\n    vector<int> fre;               //<-------vector to store the values which are present in curent path--> \\n    int ans=0;                     //<-------store the answer---->\\n\\t\\n\\t//<------------------------DFS code starts------------->\\n    void dfs(TreeNode* node)\\n    {   if(node==NULL) return; \\n        int value=node->val;\\n         fre[value]++;   //<---storing the value of node in \"fre\" variable--->\\n          if((node->left==NULL) && (node->right==NULL))// That means it is leaf node\\n          {\\n              int c=0;\\n              rep(i,1,10){\\n                  c+=(fre[i]%2!=0);\\n              }\\n              if(c<=1) ans++;\\n         }\\n          if(node->left!=NULL)    { dfs(node->left); }\\n       \\n          if(node->right!=NULL)  { dfs(node->right); }\\n          \\n     fre[value]--;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        rep(i,0,10) fre.pb(0);\\n        dfs(root);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n #define rep(i,a,b) for(lli i=a;i<b;i++)\\nclass Solution {\\npublic:\\n    vector<int> fre;               //<-------vector to store the values which are present in curent path--> \\n    int ans=0;                     //<-------store the answer---->\\n\\t\\n\\t//<------------------------DFS code starts------------->\\n    void dfs(TreeNode* node)\\n    {   if(node==NULL) return; \\n        int value=node->val;\\n         fre[value]++;   //<---storing the value of node in \"fre\" variable--->\\n          if((node->left==NULL) && (node->right==NULL))// That means it is leaf node\\n          {\\n              int c=0;\\n              rep(i,1,10){\\n                  c+=(fre[i]%2!=0);\\n              }\\n              if(c<=1) ans++;\\n         }\\n          if(node->left!=NULL)    { dfs(node->left); }\\n       \\n          if(node->right!=NULL)  { dfs(node->right); }\\n          \\n     fre[value]--;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        rep(i,0,10) fre.pb(0);\\n        dfs(root);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691514,
                "title": "python-80-70",
                "content": "```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        \\n        self.ans = 0\\n        def helper(node, s=set()):\\n            s = set(s)\\n            if node.val in s:\\n                s.remove(node.val)\\n            else:\\n                s.add(node.val)\\n            if not node.left and not node.right:\\n                self.ans = self.ans if len(s) > 1 else self.ans + 1\\n            if node.left:\\n                helper(node.left, s)\\n            if node.right:\\n                helper(node.right, s)\\n        \\n        if not root:\\n            return 0\\n        helper(root)\\n        \\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        \\n        self.ans = 0\\n        def helper(node, s=set()):\\n            s = set(s)\\n            if node.val in s:\\n                s.remove(node.val)\\n            else:\\n                s.add(node.val)\\n            if not node.left and not node.right:\\n                self.ans = self.ans if len(s) > 1 else self.ans + 1\\n            if node.left:\\n                helper(node.left, s)\\n            if node.right:\\n                helper(node.right, s)\\n        \\n        if not root:\\n            return 0\\n        helper(root)\\n        \\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648898,
                "title": "figure-illustration-c-dfs-odd-frequency-count-and-4-line-solution",
                "content": "This is a interesting question with interesting trick: n&(n-1) to check at most one odd occurence of number.\\n\\nTo get some quick idea what is the trick, let\\'s check the following 3 examples illustrated in the table:\\n![image](https://assets.leetcode.com/users/codedayday/image_1590347110.png)\\n\\n\\n**Version 3: 4-line solution with comments**\\n```\\nclass Solution {\\npublic:\\n    int pseudoPalindromicPaths (TreeNode* root, int cnt = 0) {\\n        if(!root) return 0;                \\n        cnt ^= 1 << (root->val - 1); //Flips the (root.val-1)th bit, indicating the even/odd occurrence of corresponding bit\\n        if(root->left == root->right && (cnt & (cnt - 1)) == 0) return 1; //cnt & (cnt - 1) being 0 means at most 1 num has odd occurence\\n\\t\\t//if(!root->left && !root->right) return __builtin_popcount(cnt)<=1; //ok, in case the above-line is hard\\n        return pseudoPalindromicPaths(root->left, cnt) + pseudoPalindromicPaths(root->right, cnt);        \\n    }\\n};\\n```\\nCredit: The above version is inspired by @Lee215: https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/discuss/648534/JavaC%2B%2BPython-At-most-one-odd-occurrence\\n\\nIf you found the above solution hard to understand, please continue reading this post.\\nAfter all, I thought the following well before I understood and re-phrased the abovementioned version 3.\\n\\n\\n**version 1: count_if and Lambda function based solution**\\n```\\nclass Solution {// DFS + odd frequency count\\npublic: // Time/Space: O(N); O(N)\\n    int pseudoPalindromicPaths (TreeNode* root) {        \\n        vector<int> pathCnt(9);        \\n        return dfs(root, pathCnt);\\n    }\\n    \\nprivate:\\n    int dfs(TreeNode* root, vector<int> pathCnt) {\\n        int ans = 0;\\n        if(!root) return 0;        \\n        ++pathCnt[root->val - 1];        \\n        if(!root->left && !root->right)  //if at most 1 element of pathCnt shows up in current path, it can be palindromic and return true(1), otherwise false(0)\\n            return count_if(begin(pathCnt), end(pathCnt), [](auto e){return e%2 == 1;}) <= 1;\\n        ans += dfs(root->left, pathCnt);\\n        ans += dfs(root->right, pathCnt);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Version 2: straightforward function based solution**\\n```\\nclass Solution {\\npublic:\\n    int pseudoPalindromicPaths (TreeNode* root) {        \\n        vector<int> pathCnt(9);\\n        return dfs(root, pathCnt);\\n    }\\n    \\nprivate:\\n    int dfs(TreeNode* root, vector<int> pathCnt) {\\n        int ans = 0;\\n        if(!root) return 0;        \\n        ++pathCnt[root->val - 1];\\n        if(!root->left && !root->right) return isPalindrom(pathCnt);\\n        ans += dfs(root->left, pathCnt);\\n        ans += dfs(root->right, pathCnt);\\n        return ans;\\n    }\\n    \\n    bool isPalindrom(vector<int>& pathCnt){\\n        int cnt = 0;\\n        for(auto i: pathCnt) if(i % 2 == 1) cnt++;\\n        return cnt <= 1;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pseudoPalindromicPaths (TreeNode* root, int cnt = 0) {\\n        if(!root) return 0;                \\n        cnt ^= 1 << (root->val - 1); //Flips the (root.val-1)th bit, indicating the even/odd occurrence of corresponding bit\\n        if(root->left == root->right && (cnt & (cnt - 1)) == 0) return 1; //cnt & (cnt - 1) being 0 means at most 1 num has odd occurence\\n\\t\\t//if(!root->left && !root->right) return __builtin_popcount(cnt)<=1; //ok, in case the above-line is hard\\n        return pseudoPalindromicPaths(root->left, cnt) + pseudoPalindromicPaths(root->right, cnt);        \\n    }\\n};\\n```\n```\\nclass Solution {// DFS + odd frequency count\\npublic: // Time/Space: O(N); O(N)\\n    int pseudoPalindromicPaths (TreeNode* root) {        \\n        vector<int> pathCnt(9);        \\n        return dfs(root, pathCnt);\\n    }\\n    \\nprivate:\\n    int dfs(TreeNode* root, vector<int> pathCnt) {\\n        int ans = 0;\\n        if(!root) return 0;        \\n        ++pathCnt[root->val - 1];        \\n        if(!root->left && !root->right)  //if at most 1 element of pathCnt shows up in current path, it can be palindromic and return true(1), otherwise false(0)\\n            return count_if(begin(pathCnt), end(pathCnt), [](auto e){return e%2 == 1;}) <= 1;\\n        ans += dfs(root->left, pathCnt);\\n        ans += dfs(root->right, pathCnt);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int pseudoPalindromicPaths (TreeNode* root) {        \\n        vector<int> pathCnt(9);\\n        return dfs(root, pathCnt);\\n    }\\n    \\nprivate:\\n    int dfs(TreeNode* root, vector<int> pathCnt) {\\n        int ans = 0;\\n        if(!root) return 0;        \\n        ++pathCnt[root->val - 1];\\n        if(!root->left && !root->right) return isPalindrom(pathCnt);\\n        ans += dfs(root->left, pathCnt);\\n        ans += dfs(root->right, pathCnt);\\n        return ans;\\n    }\\n    \\n    bool isPalindrom(vector<int>& pathCnt){\\n        int cnt = 0;\\n        for(auto i: pathCnt) if(i % 2 == 1) cnt++;\\n        return cnt <= 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648780,
                "title": "python-easy-dfs-approach",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom collections import Counter as cc \\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        l=[]\\n        def dfs(node,s):\\n            if(node):\\n                s+=str(node.val)\\n                if(not node.left and not node.right):\\n                    l.append(s)\\n                dfs(node.left,s)\\n                dfs(node.right,s)\\n        \\n        dfs(root,\"\")\\n        c=0\\n        for i in l:\\n            if(sum(v%2 for v in cc(i).values())<2):\\n                c+=1\\n        return c\\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom collections import Counter as cc \\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        l=[]\\n        def dfs(node,s):\\n            if(node):\\n                s+=str(node.val)\\n                if(not node.left and not node.right):\\n                    l.append(s)\\n                dfs(node.left,s)\\n                dfs(node.right,s)\\n        \\n        dfs(root,\"\")\\n        c=0\\n        for i in l:\\n            if(sum(v%2 for v in cc(i).values())<2):\\n                c+=1\\n        return c\\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 648773,
                "title": "c-concise-code-bit-operation",
                "content": "```\\npublic int PseudoPalindromicPaths(TreeNode root)\\n{\\n\\treturn Helper(root, 0);\\n}\\n\\n//Since node Val is 1-9, we can use 9-bit binary number to represent the path.\\n//Use XOR to cancel out Val pairs.\\n//The path is palindrome if there is zero or one *1* left in bit, bit & (bit-1) can simplify the check. \\nprivate int Helper(TreeNode node, int bit)\\n{\\n\\tif (node == null)   \\n\\t\\treturn 0;\\n\\tbit ^= 1 << node.val; \\n\\tif(node.left == null && node.right == null)\\n\\t\\treturn (bit & (bit-1)) == 0 ? 1 : 0;\\n\\treturn Helper(node.left, bit) + Helper(node.right, bit);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int PseudoPalindromicPaths(TreeNode root)\\n{\\n\\treturn Helper(root, 0);\\n}\\n\\n//Since node Val is 1-9, we can use 9-bit binary number to represent the path.\\n//Use XOR to cancel out Val pairs.\\n//The path is palindrome if there is zero or one *1* left in bit, bit & (bit-1) can simplify the check. \\nprivate int Helper(TreeNode node, int bit)\\n{\\n\\tif (node == null)   \\n\\t\\treturn 0;\\n\\tbit ^= 1 << node.val; \\n\\tif(node.left == null && node.right == null)\\n\\t\\treturn (bit & (bit-1)) == 0 ? 1 : 0;\\n\\treturn Helper(node.left, bit) + Helper(node.right, bit);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 648720,
                "title": "python-dfs-solution-simple-easily-understood",
                "content": "```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        import collections\\n        def isAnagramOfPalindrome(nums):\\n            c = collections.Counter(nums)\\n            p = 0\\n            for k in c.keys():\\n                if( c[k] % 2 == 1 ):\\n                    p += 1\\n            return p <= 1\\n        \\n        def dfs(node, path):\\n            if not node:\\n                return\\n            if(not node.left and not node.right and isAnagramOfPalindrome(path+ [node.val])):\\n                self.ans += 1\\n            dfs(node.left, path + [node.val])\\n            dfs(node.right, path + [node.val])\\n        self.ans = 0\\n        dfs(root, [])\\n        return self.ans  \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        import collections\\n        def isAnagramOfPalindrome(nums):\\n            c = collections.Counter(nums)\\n            p = 0\\n            for k in c.keys():\\n                if( c[k] % 2 == 1 ):\\n                    p += 1\\n            return p <= 1\\n        \\n        def dfs(node, path):\\n            if not node:\\n                return\\n            if(not node.left and not node.right and isAnagramOfPalindrome(path+ [node.val])):\\n                self.ans += 1\\n            dfs(node.left, path + [node.val])\\n            dfs(node.right, path + [node.val])\\n        self.ans = 0\\n        dfs(root, [])\\n        return self.ans  \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548310,
                "title": "dfs-bit-mask-java",
                "content": "# Intuition\\n1. We use the parity variable to store the parity information for each node. We represent the parity as a bit mask, where each bit represents the count of a specific value (from 1 to 9) encountered in the path so far.\\n\\n2. During the depth-first search (dfs), we toggle the bit at the position of root.val in the parity variable. At each leaf node, we check if the parity has at most one bit set (using the condition (parity & (parity - 1)) == 0). If it does, then we increment the count variable.\\n\\n3. for a path to be rearranged into a palindrome, it can have at most one value with an odd count. This means that there can be at most one bit set to 1 in the parity variable. If there are more than one bits set, it indicates that there are multiple values with odd counts, which means the path cannot be rearranged to form a palindrome.\\n\\n# Code\\n```\\n// We use the parity variable to store the parity information for each node. We represent the parity as a bit mask, where each bit represents the count of a specific value (from 1 to 9) encountered in the path so far.\\n\\n// During the depth-first search (dfs), we toggle the bit at the position of root.val in the parity variable. At each leaf node, we check if the parity has at most one bit set (using the condition (parity & (parity - 1)) == 0). If it does, then we increment the count variable.\\n\\n// for a path to be rearranged into a palindrome, it can have at most one value with an odd count. This means that there can be at most one bit set to 1 in the parity variable. If there are more than one bits set, it indicates that there are multiple values with odd counts, which means the path cannot be rearranged to form a palindrome.\\nclass Solution {\\n    int count = 0;\\n    List<Integer> path = new ArrayList<>();\\n\\n    public int pseudoPalindromicPaths(TreeNode root) {\\n        dfs(root, 0);\\n        return count;\\n    }\\n\\n    public void dfs(TreeNode root, int parity) {\\n        if (root == null)\\n            return;\\n\\n        parity ^= (1 << root.val); // Toggle the bit at the position of root.val\\n\\n        // If it is a leaf node\\n        if (root.left == null && root.right == null) {\\n            if ((parity & (parity - 1)) == 0) { // Check if at most one bit is set\\n                count++;\\n            }\\n            return;\\n        }\\n\\n        dfs(root.left, parity);\\n        dfs(root.right, parity);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\n// We use the parity variable to store the parity information for each node. We represent the parity as a bit mask, where each bit represents the count of a specific value (from 1 to 9) encountered in the path so far.\\n\\n// During the depth-first search (dfs), we toggle the bit at the position of root.val in the parity variable. At each leaf node, we check if the parity has at most one bit set (using the condition (parity & (parity - 1)) == 0). If it does, then we increment the count variable.\\n\\n// for a path to be rearranged into a palindrome, it can have at most one value with an odd count. This means that there can be at most one bit set to 1 in the parity variable. If there are more than one bits set, it indicates that there are multiple values with odd counts, which means the path cannot be rearranged to form a palindrome.\\nclass Solution {\\n    int count = 0;\\n    List<Integer> path = new ArrayList<>();\\n\\n    public int pseudoPalindromicPaths(TreeNode root) {\\n        dfs(root, 0);\\n        return count;\\n    }\\n\\n    public void dfs(TreeNode root, int parity) {\\n        if (root == null)\\n            return;\\n\\n        parity ^= (1 << root.val); // Toggle the bit at the position of root.val\\n\\n        // If it is a leaf node\\n        if (root.left == null && root.right == null) {\\n            if ((parity & (parity - 1)) == 0) { // Check if at most one bit is set\\n                count++;\\n            }\\n            return;\\n        }\\n\\n        dfs(root.left, parity);\\n        dfs(root.right, parity);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576540,
                "title": "detailed-solution-with-explanation-line-by-line-cpp-backtracking-and-unordered-map-solution",
                "content": "**Complete beginner-friendly, easy to understand solution with line by line explanation with *unordered_map* and *backtracking.***  I will try to post my detailed solution of daily leetcoding challenge everyday in CPP. \\n```\\nclass Solution {\\n/*\\nIDEA: \\n1) Count number of occurences of each node in a path and map it in an uordered_map.\\n2) If a node has left and right children both as NULL, then we have to check if the \\n   permutation of path is palindrome or not.\\n        => Traverse through the map and check if the nodes frequency are multiple of 2.\\n        => Allow only one node to have odd frequency\\n3) We have to backtrack the frequency of nodes in our map, once we have considered it.\\n4) In case if a node has only children, when we encounter a NULL leaf node we simple have \\n   to return and do not computation.\\n*/\\n\\npublic:\\n    void solve(TreeNode* node, unordered_map<int, int>& path, int& res){\\n        \\n        //NULL child of a node only having 1 children\\n        if(node == NULL) return;\\n        \\n        //If we reach the last node i.e. one path is completed\\n        if(node->left == NULL && node->right == NULL){\\n            \\n            //Since we entered the base condition we have to manually increase \\n            //the frequency of the current leaf node in our map.\\n            ++path[node->val];\\n            \\n            //\\'allow\\' var will help us to have one node freq as odd.\\n            //\\'update\\' var will tell if the path is palindrome of not. If true, then only\\n            //final res value be incremented by 1.\\n            \\n            bool allow = true, update = true;\\n            \\n            for(auto i : path){\\n                if(i.second % 2 == 0) continue;\\n                \\n                //Only node is allowed to have odd frequency.\\n                if(i.second % 2 != 0 && allow) {\\n                    allow = false;\\n                    continue;\\n                }\\n                \\n                //If more than 1 nodes have odd frequency, then do not have palindromic\\n                //path, hence the res should not be updated.\\n                else {\\n                    update = false;\\n                    break;\\n                }\\n            }\\n            \\n            //If path is palindromic, update the res\\n            if(update) ++res;\\n            \\n            //Backtrack the current leaf node manually by decreasing its frequency in\\n            //the map.\\n            --path[node->val];\\n            return;\\n        }\\n        \\n        //Add the current node in the map and increase its frequency if already present\\n        ++path[node->val];\\n        \\n        solve(node->left, path, res);\\n        solve(node->right, path, res);\\n        \\n        //Once both the children of node is explored, decrease the freq of node by 1.\\n        --path[node->val];\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        int res = 0;\\n        unordered_map<int, int> path;\\n        solve(root, path, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n/*\\nIDEA: \\n1) Count number of occurences of each node in a path and map it in an uordered_map.\\n2) If a node has left and right children both as NULL, then we have to check if the \\n   permutation of path is palindrome or not.\\n        => Traverse through the map and check if the nodes frequency are multiple of 2.\\n        => Allow only one node to have odd frequency\\n3) We have to backtrack the frequency of nodes in our map, once we have considered it.\\n4) In case if a node has only children, when we encounter a NULL leaf node we simple have \\n   to return and do not computation.\\n*/\\n\\npublic:\\n    void solve(TreeNode* node, unordered_map<int, int>& path, int& res){\\n        \\n        //NULL child of a node only having 1 children\\n        if(node == NULL) return;\\n        \\n        //If we reach the last node i.e. one path is completed\\n        if(node->left == NULL && node->right == NULL){\\n            \\n            //Since we entered the base condition we have to manually increase \\n            //the frequency of the current leaf node in our map.\\n            ++path[node->val];\\n            \\n            //\\'allow\\' var will help us to have one node freq as odd.\\n            //\\'update\\' var will tell if the path is palindrome of not. If true, then only\\n            //final res value be incremented by 1.\\n            \\n            bool allow = true, update = true;\\n            \\n            for(auto i : path){\\n                if(i.second % 2 == 0) continue;\\n                \\n                //Only node is allowed to have odd frequency.\\n                if(i.second % 2 != 0 && allow) {\\n                    allow = false;\\n                    continue;\\n                }\\n                \\n                //If more than 1 nodes have odd frequency, then do not have palindromic\\n                //path, hence the res should not be updated.\\n                else {\\n                    update = false;\\n                    break;\\n                }\\n            }\\n            \\n            //If path is palindromic, update the res\\n            if(update) ++res;\\n            \\n            //Backtrack the current leaf node manually by decreasing its frequency in\\n            //the map.\\n            --path[node->val];\\n            return;\\n        }\\n        \\n        //Add the current node in the map and increase its frequency if already present\\n        ++path[node->val];\\n        \\n        solve(node->left, path, res);\\n        solve(node->right, path, res);\\n        \\n        //Once both the children of node is explored, decrease the freq of node by 1.\\n        --path[node->val];\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        int res = 0;\\n        unordered_map<int, int> path;\\n        solve(root, path, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576155,
                "title": "dfs-xor-java",
                "content": "```\\nclass Solution {\\n    int ans=0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        dfs(root,0);\\n        return ans;\\n    }\\n    void dfs(TreeNode root , int path){\\n        if(root == null)return ;\\n        \\n        path=path^(1<< root.val);\\n        if(root.left==null && root.right==null )if((path & (path-1))==0)ans++;\\n        dfs(root.left,path);\\n        dfs(root.right,path);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        dfs(root,0);\\n        return ans;\\n    }\\n    void dfs(TreeNode root , int path){\\n        if(root == null)return ;\\n        \\n        path=path^(1<< root.val);\\n        if(root.left==null && root.right==null )if((path & (path-1))==0)ans++;\\n        dfs(root.left,path);\\n        dfs(root.right,path);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576067,
                "title": "easy-to-understand-recursive-java-solution-using-dfs-and-bit-manipulation-93-faster-than-others",
                "content": "```\\nclass Solution {\\n    int ispalindromecount = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        ispalindromecount = 0;\\n        dfsearch(root, 0);\\n        return ispalindromecount;\\n    }\\n    \\n    public void dfsearch(TreeNode root, int count) {\\n        if (root == null) return;\\n        count ^= 1 << (root.val - 1);\\n        dfsearch(root.left, count);\\n        dfsearch(root.right, count);\\n        if (root.left == null && root.right ==  null && (count & (count - 1)) == 0) ispalindromecount++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int ispalindromecount = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        ispalindromecount = 0;\\n        dfsearch(root, 0);\\n        return ispalindromecount;\\n    }\\n    \\n    public void dfsearch(TreeNode root, int count) {\\n        if (root == null) return;\\n        count ^= 1 << (root.val - 1);\\n        dfsearch(root.left, count);\\n        dfsearch(root.right, count);\\n        if (root.left == null && root.right ==  null && (count & (count - 1)) == 0) ispalindromecount++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575830,
                "title": "simple-javascript-solution-faster-than-50",
                "content": "```\\nvar ans=0;\\nvar pseudoPalindromicPaths  = function(root) {\\n    ans = 0;\\n    let arr = new Array(10);\\n    for(let i=1;i<=9;i++) arr[i] = 0;\\n    fun(root,arr,0);\\n    return ans;\\n};\\n\\nfunction fun(node,arr,cnt){\\n    if(node === null) return;\\n    arr[node.val]++;cnt++;\\n    if(node.left === null && node.right === null){\\n        if(cnt&1){\\n            let f = 1;\\n            for(let i=1;i<=9;i++){\\n                if(arr[i]&1 && f===0){\\n                    arr[node.val]--;\\n                    cnt--;\\n                    return;\\n                }else if(arr[i]&1) f--;\\n            }\\n            ans++;\\n            cnt--;\\n            arr[node.val]--;\\n            return;\\n        }\\n        else{\\n            for(let i=1;i<=9;i++){\\n                if(arr[i]&1){\\n                    cnt--;\\n                    arr[node.val]--;\\n                    return;\\n                }\\n            }\\n            ans++;\\n            cnt--;\\n            arr[node.val]--;\\n            return;\\n        }\\n    }\\n    \\n    fun(node.left,arr,cnt);\\n    fun(node.right,arr,cnt);\\n    arr[node.val]--;\\n    cnt--;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar ans=0;\\nvar pseudoPalindromicPaths  = function(root) {\\n    ans = 0;\\n    let arr = new Array(10);\\n    for(let i=1;i<=9;i++) arr[i] = 0;\\n    fun(root,arr,0);\\n    return ans;\\n};\\n\\nfunction fun(node,arr,cnt){\\n    if(node === null) return;\\n    arr[node.val]++;cnt++;\\n    if(node.left === null && node.right === null){\\n        if(cnt&1){\\n            let f = 1;\\n            for(let i=1;i<=9;i++){\\n                if(arr[i]&1 && f===0){\\n                    arr[node.val]--;\\n                    cnt--;\\n                    return;\\n                }else if(arr[i]&1) f--;\\n            }\\n            ans++;\\n            cnt--;\\n            arr[node.val]--;\\n            return;\\n        }\\n        else{\\n            for(let i=1;i<=9;i++){\\n                if(arr[i]&1){\\n                    cnt--;\\n                    arr[node.val]--;\\n                    return;\\n                }\\n            }\\n            ans++;\\n            cnt--;\\n            arr[node.val]--;\\n            return;\\n        }\\n    }\\n    \\n    fun(node.left,arr,cnt);\\n    fun(node.right,arr,cnt);\\n    arr[node.val]--;\\n    cnt--;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575554,
                "title": "javascript-easy-to-understand-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar pseudoPalindromicPaths  = function(root) {\\n    if (!root.left && !root.right) {\\n        return 1;\\n    }\\n    \\n    let count = { count: 0 };\\n    process(root, {}, count);\\n    \\n    return count.count;\\n};\\n\\nfunction process(root, values, count) {\\n    if (root && !root.left && !root.right) {\\n        if (!values[root.val]) {\\n            values[root.val] = 0;\\n        }\\n        values[root.val] += 1;\\n        \\n        if (values[root.val] === 2) {\\n            delete(values[root.val]);\\n        }\\n        \\n        const length = Object.keys(values).length;\\n        if (length <= 1) {\\n            count.count += 1;\\n        }\\n        \\n        return;\\n    } else if (!root) {\\n        return;\\n    }\\n    \\n    if (!values[root.val]) {\\n        values[root.val] = 0;\\n    }\\n    values[root.val] += 1;\\n    \\n    if (values[root.val] === 2) {\\n        delete(values[root.val]);\\n    }\\n    \\n    process(root.left,  Object.assign({}, values), count);\\n    process(root.right, Object.assign({}, values), count);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar pseudoPalindromicPaths  = function(root) {\\n    if (!root.left && !root.right) {\\n        return 1;\\n    }\\n    \\n    let count = { count: 0 };\\n    process(root, {}, count);\\n    \\n    return count.count;\\n};\\n\\nfunction process(root, values, count) {\\n    if (root && !root.left && !root.right) {\\n        if (!values[root.val]) {\\n            values[root.val] = 0;\\n        }\\n        values[root.val] += 1;\\n        \\n        if (values[root.val] === 2) {\\n            delete(values[root.val]);\\n        }\\n        \\n        const length = Object.keys(values).length;\\n        if (length <= 1) {\\n            count.count += 1;\\n        }\\n        \\n        return;\\n    } else if (!root) {\\n        return;\\n    }\\n    \\n    if (!values[root.val]) {\\n        values[root.val] = 0;\\n    }\\n    values[root.val] += 1;\\n    \\n    if (values[root.val] === 2) {\\n        delete(values[root.val]);\\n    }\\n    \\n    process(root.left,  Object.assign({}, values), count);\\n    process(root.right, Object.assign({}, values), count);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575325,
                "title": "c-easy-to-understand-space-optimization-bactracking-one-liner-dfs",
                "content": "#### Brute-Force Approach : \\nWe have to first store the values of all nodes of any path from root node to leaf node and then check if that can be used to make a palindrome or not. If it is a palindrome then we can just add 1 to our answer. We have to do the same for every path and then return the final answer.\\n#### Palindrome Checking\\nFor this we can use a map/vector for storing values and for finding just we have to check the numbers having odd occurences. If there is more than one number having odd occurence in a path then it can\\'t be used to make a palindrome.\\nHow are we determing that At most one odd occurence in a path is required for palindrome ?? \\nIf there are all numbers having even number of occurences then the total elements in the path will be even and we can arrange them into a palindromic fashion. If there is one number having odd number of occurences then we can put that into middle and arrange the remaining numbers into a palindromic fashion, But if there is more than one number having odd occurences then we can\\'t make a palindrome out of that by any means.\\n#### Efficient Solution :\\nWe can do this without storing the whole path !! Yes You read it right. \\nWe will use the fact that either the occurence of number appearing in the path can be odd or even. \\nUsing a set will make our job easier for us. We will only store the numbers having odd occurences in a path. Initially all the occurences are 0, so our set is empty.\\nWhenever we counter a number for the path if it is already in the set we will remove that and if it is not in the set then we will insert it ninto the set.\\n**Time complexity** of this is **O(N)** : Number of Nodes in the tree\\n**Space Complexity** of this is **O(1)** : At max there can be 9 numbers in the set because the node value varies from 1 to 9 only.\\n```\\n\\t// Declaring a set which will store the occurences and a global answer variable.\\n\\t\\n\\tint ans = 0;\\n    set<int> s;\\n\\t\\n\\t// Toogle will insert a value in the set if its not already present and will remove otherwise.\\n\\t\\n    void toggle(TreeNode* root) {\\n        if(s.find(root->val)!= s.end()) s.erase(root->val);\\n        else s.insert(root->val);\\n    }\\n\\t\\n\\t// dfs function is the recursive calling of the function for all the nodes to get the path\\n\\t\\n    void dfs(TreeNode* root) {\\n        if(root == nullptr) return;\\n        toggle(root);    // Inserting the node into the path\\n        if(root->left == nullptr && root->right == nullptr) {\\n            if(s.size() < 2) ans++; \\n            toggle(root);    // Backtracking i.e. removing the node from path\\n            return;\\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n        toggle(root);     // Backtracking i.e. removing the node from path\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\n\\t// Declaring a set which will store the occurences and a global answer variable.\\n\\t\\n\\tint ans = 0;\\n    set<int> s;\\n\\t\\n\\t// Toogle will insert a value in the set if its not already present and will remove otherwise.\\n\\t\\n    void toggle(TreeNode* root) {\\n        if(s.find(root->val)!= s.end()) s.erase(root->val);\\n        else s.insert(root->val);\\n    }\\n\\t\\n\\t// dfs function is the recursive calling of the function for all the nodes to get the path\\n\\t\\n    void dfs(TreeNode* root) {\\n        if(root == nullptr) return;\\n        toggle(root);    // Inserting the node into the path\\n        if(root->left == nullptr && root->right == nullptr) {\\n            if(s.size() < 2) ans++; \\n            toggle(root);    // Backtracking i.e. removing the node from path\\n            return;\\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n        toggle(root);     // Backtracking i.e. removing the node from path\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2574636,
                "title": "easy-java-solution-hashing-hashmap",
                "content": "Using Array \\n```\\nclass Solution {\\n    private int count = 0;\\n    private int[] arr = new int[10];\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        countPalindromes(root);\\n        return count;\\n    }\\n    public void countPalindromes(TreeNode root) {\\n        arr[root.val]++;\\n        if(root.left != null) countPalindromes(root.left);\\n        if(root.right != null) countPalindromes(root.right);\\n        if(root.left == null && root.right == null) {\\n            if(canBePalindrome()) count++;\\n        }\\n        arr[root.val]--;\\n    }\\n    public boolean canBePalindrome() {\\n        int odd = 0;\\n        for(int i: arr) {\\n            if(i%2==1) odd++;\\n        }\\n        return odd <= 1;\\n    }\\n}\\n```\\n\\nUsing HashMap\\n```\\nclass Solution {\\n    private int count = 0;\\n    private HashMap<Integer, Integer> map = new HashMap<>();\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        countPalindromes(root);\\n        return count;\\n    }\\n    public void countPalindromes(TreeNode root) {\\n        boolean used = false;\\n        if(map.containsKey(root.val)) {\\n            map.remove(root.val);\\n        } else {\\n            used = true;\\n            map.put(root.val, 1);\\n        }\\n        if(root.left != null) countPalindromes(root.left);\\n        if(root.right != null) countPalindromes(root.right);\\n        if(root.left == null && root.right == null) {\\n            if(map.size() <= 1) count++;\\n        }\\n        if(used) {\\n            map.remove(root.val);\\n        } else {\\n            map.put(root.val, 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private int count = 0;\\n    private int[] arr = new int[10];\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        countPalindromes(root);\\n        return count;\\n    }\\n    public void countPalindromes(TreeNode root) {\\n        arr[root.val]++;\\n        if(root.left != null) countPalindromes(root.left);\\n        if(root.right != null) countPalindromes(root.right);\\n        if(root.left == null && root.right == null) {\\n            if(canBePalindrome()) count++;\\n        }\\n        arr[root.val]--;\\n    }\\n    public boolean canBePalindrome() {\\n        int odd = 0;\\n        for(int i: arr) {\\n            if(i%2==1) odd++;\\n        }\\n        return odd <= 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int count = 0;\\n    private HashMap<Integer, Integer> map = new HashMap<>();\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        countPalindromes(root);\\n        return count;\\n    }\\n    public void countPalindromes(TreeNode root) {\\n        boolean used = false;\\n        if(map.containsKey(root.val)) {\\n            map.remove(root.val);\\n        } else {\\n            used = true;\\n            map.put(root.val, 1);\\n        }\\n        if(root.left != null) countPalindromes(root.left);\\n        if(root.right != null) countPalindromes(root.right);\\n        if(root.left == null && root.right == null) {\\n            if(map.size() <= 1) count++;\\n        }\\n        if(used) {\\n            map.remove(root.val);\\n        } else {\\n            map.put(root.val, 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574525,
                "title": "java-dfs-bitmask-easy",
                "content": "```\\nclass Solution {\\n    private static int ans;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        ans = 0;\\n        solve(root, 0);\\n        return ans;\\n    }\\n    \\n    private static TreeNode solve(TreeNode node, int mask) {\\n        if (node == null) return null;\\n        mask = mask ^ (1 << node.val);\\n        TreeNode left = solve(node.left, mask);\\n        TreeNode right = solve(node.right, mask);\\n        if (left == null && right == null && noOfSetBits(mask) <= 1) ans++;\\n        return node;\\n    }\\n    \\n    private static int noOfSetBits(long x) {\\n        int cnt = 0;\\n        while (x != 0) {\\n            x = x & (x - 1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    private static int ans;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        ans = 0;\\n        solve(root, 0);\\n        return ans;\\n    }\\n    \\n    private static TreeNode solve(TreeNode node, int mask) {\\n        if (node == null) return null;\\n        mask = mask ^ (1 << node.val);\\n        TreeNode left = solve(node.left, mask);\\n        TreeNode right = solve(node.right, mask);\\n        if (left == null && right == null && noOfSetBits(mask) <= 1) ans++;\\n        return node;\\n    }\\n    \\n    private static int noOfSetBits(long x) {\\n        int cnt = 0;\\n        while (x != 0) {\\n            x = x & (x - 1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574408,
                "title": "easy-bit-manipulation-xor-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void fn(TreeNode *node, int path, int &ans) {\\n        if (!node) return;\\n        path = path ^ (1 << node->val);\\n        if (!node->left && !node->right) {\\n            if ((path & (path-1)) == 0) ans++;\\n        }\\n        fn(node->left, path, ans);\\n        fn(node->right, path, ans);\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        int ans = 0;\\n        fn(root, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fn(TreeNode *node, int path, int &ans) {\\n        if (!node) return;\\n        path = path ^ (1 << node->val);\\n        if (!node->left && !node->right) {\\n            if ((path & (path-1)) == 0) ans++;\\n        }\\n        fn(node->left, path, ans);\\n        fn(node->right, path, ans);\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        int ans = 0;\\n        fn(root, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574162,
                "title": "rust-iterative-dfs-with-comments",
                "content": "I\\'m sure the official solution does a better job of explaining the algorithm, but anyway - iterate over the tree, keeping track of the frequencies of the node values as we go. If we hit a leaf, we check if the frequencies contain at most one odd value, since we can form a palindrome with even pairs or all even except one odd in the middle of the palindrome.\\n\\nI really wanted to do an iterative implementation out of this. So I keep track of whether the frequencies are odd or even using a bit array (`odds`) as a part of the iteration state. When I encounter a leaf, I add to `rez`, the count of pseudo-palindromic paths, if `odds` has less than two bits set, as explained above.\\n\\nImplementation notes:\\n* You are really free to chose BFS if you would prefer that, but I prefer DFS since it becomes a bit less verbose.\\n* I usually argue that we should use move semantics for tree iteration problems on LeetCode, since it is more efficient than cloning. Recently, a solution that I made where I used this reasoning was downvoted, and that made me think about that choice. As explained in the Rust Book, `RefCell` follows the inner mutability pattern, which relies on run-time borrow checking instead of compile-time checking. This means that when you hand a `RefCell` to a function, the function is free to mutate the underlying variable. When we use move semantics and `take` nodes, we are mutating the tree. One might argue that it is not good programming practice to mutate the input. I would lean towards the side that says that this is the same as if we would have been handed a `&mut`, i.e. we can mutate it, and therefore the caller should make no assumptions that we won\\'t mutate it. If we were not allowed to mutate, it would be better to enforce this by handing us a tree of `Rc`s without `RefCell`s instead. Anyway, with this said, I went for a non-destructive solution today. :)\\n* Counting the number of bits is an operation that can be done in one instruction on modern x86 processors, so it\\'s as efficient or more efficient, and clearer, than using manual bit twiddling.\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn pseudo_palindromic_paths (root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut stack = vec![(root.unwrap(), 0u16)];\\n        let mut rez = 0;\\n\\n        while let Some((node_rc, mut odds)) = stack.pop() {\\n            let node_ref = node_rc.borrow();\\n            odds ^= 1 << node_ref.val;\\n            match (node_ref.left.clone(), node_ref.right.clone()) {\\n                (None, None) => if odds.count_ones() < 2 { rez += 1 },\\n                (None, Some(right)) => stack.push((right, odds)),\\n                (Some(left), None) => stack.push((left, odds)),\\n                (Some(left), Some(right)) => { \\n                    stack.push((left, odds)); stack.push((right, odds));\\n                },\\n            }\\n        }\\n\\n        rez\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn pseudo_palindromic_paths (root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut stack = vec![(root.unwrap(), 0u16)];\\n        let mut rez = 0;\\n\\n        while let Some((node_rc, mut odds)) = stack.pop() {\\n            let node_ref = node_rc.borrow();\\n            odds ^= 1 << node_ref.val;\\n            match (node_ref.left.clone(), node_ref.right.clone()) {\\n                (None, None) => if odds.count_ones() < 2 { rez += 1 },\\n                (None, Some(right)) => stack.push((right, odds)),\\n                (Some(left), None) => stack.push((left, odds)),\\n                (Some(left), Some(right)) => { \\n                    stack.push((left, odds)); stack.push((right, odds));\\n                },\\n            }\\n        }\\n\\n        rez\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2574040,
                "title": "explained-from-memory-limit-exceeded-approach-to-optimal-notes-image",
                "content": "![image](https://assets.leetcode.com/users/images/bc1f4367-643d-4cfb-b72f-c3c2e0352546_1663136728.8759415.jpeg)\\n\\n\\n**Failed approch**\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void isPali(string s){\\n        vector<int> v(10,0);\\n        for(auto ch : s)\\n            v[ch-\\'0\\']++;\\n        \\n        int mismatch =0 ;\\n        \\n        for(auto f : v){\\n            mismatch += (f % 2);\\n        }\\n        \\n        int n = s.size();\\n        if(n & 1 ){\\n            if(mismatch <= 1) ans++;\\n        } \\n        else{\\n            if(mismatch == 0) ans++;\\n        }\\n        return ;        \\n    }\\n    void pre(TreeNode* root, string path){\\n        if(!root) return ;\\n        \\n        path.push_back(\\'0\\' + root->val);\\n        if(!root->left && !root->right) \\n        {\\n            isPali(path);\\n            path.pop_back();\\n            return;    \\n        }    \\n        pre(root->left, path);\\n        pre(root->right, path);\\n        path.pop_back();\\n    }\\n    \\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        string path;\\n        pre(root,path);\\n        return ans;\\n    }\\n};\\n```\\n**Better -- suboptimal one**\\n\\n```\\nint ans =0;\\n    void fun(TreeNode* root , vector<int>& freq){\\n        if(!root) return ;\\n        freq[root->val]++;\\n        \\n        if(!root->left && !root->right){\\n            // So now I will check if that\\'s palidrome or not\\n            int mismatch = 0;\\n            for(int i =0 ;i<10;i++)\\n                mismatch += (freq[i] % 2);\\n            \\n            if(mismatch <= 1) ans++;\\n            \\n        }\\n        else{\\n            fun(root->left, freq);\\n            fun(root->right,freq);\\n        }\\n        freq[root->val]--;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> freq(10,0);\\n        fun(root, freq);\\n        return ans;\\n    }\\n```\\n**Using BItset**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    void fun(TreeNode* root, int & ans, bitset<10> & freq){\\n        if(!root) return ;\\n        freq.flip(root->val);\\n        if(!root->left && ! root->right){\\n            if(freq.count() <= 1) \\n                ans++;\\n        }\\n        else{\\n            fun(root->left, ans, freq);\\n            fun(root->right, ans, freq);\\n        }\\n        freq.flip(root->val);\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        bitset<10> bset(0);\\n        int ans =0 ;\\n        fun(root, ans, bset);\\n        return ans;\\n    }\\n};\\n```\\n**Optimal -- Bit manipulation**\\n```\\nint pseudoPalindromicPaths (TreeNode* root, int c = 0) {\\n        if(!root) return 0;\\n        c ^= (1 << root->val );\\n        int res  =  pseudoPalindromicPaths(root->left, c) + pseudoPalindromicPaths(root->right, c);\\n    \\n        if(!root->left && !root->right && (c & (c-1)) == 0 ) res++;\\n        \\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void isPali(string s){\\n        vector<int> v(10,0);\\n        for(auto ch : s)\\n            v[ch-\\'0\\']++;\\n        \\n        int mismatch =0 ;\\n        \\n        for(auto f : v){\\n            mismatch += (f % 2);\\n        }\\n        \\n        int n = s.size();\\n        if(n & 1 ){\\n            if(mismatch <= 1) ans++;\\n        } \\n        else{\\n            if(mismatch == 0) ans++;\\n        }\\n        return ;        \\n    }\\n    void pre(TreeNode* root, string path){\\n        if(!root) return ;\\n        \\n        path.push_back(\\'0\\' + root->val);\\n        if(!root->left && !root->right) \\n        {\\n            isPali(path);\\n            path.pop_back();\\n            return;    \\n        }    \\n        pre(root->left, path);\\n        pre(root->right, path);\\n        path.pop_back();\\n    }\\n    \\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        string path;\\n        pre(root,path);\\n        return ans;\\n    }\\n};\\n```\n```\\nint ans =0;\\n    void fun(TreeNode* root , vector<int>& freq){\\n        if(!root) return ;\\n        freq[root->val]++;\\n        \\n        if(!root->left && !root->right){\\n            // So now I will check if that\\'s palidrome or not\\n            int mismatch = 0;\\n            for(int i =0 ;i<10;i++)\\n                mismatch += (freq[i] % 2);\\n            \\n            if(mismatch <= 1) ans++;\\n            \\n        }\\n        else{\\n            fun(root->left, freq);\\n            fun(root->right,freq);\\n        }\\n        freq[root->val]--;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> freq(10,0);\\n        fun(root, freq);\\n        return ans;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n\\n    void fun(TreeNode* root, int & ans, bitset<10> & freq){\\n        if(!root) return ;\\n        freq.flip(root->val);\\n        if(!root->left && ! root->right){\\n            if(freq.count() <= 1) \\n                ans++;\\n        }\\n        else{\\n            fun(root->left, ans, freq);\\n            fun(root->right, ans, freq);\\n        }\\n        freq.flip(root->val);\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        bitset<10> bset(0);\\n        int ans =0 ;\\n        fun(root, ans, bset);\\n        return ans;\\n    }\\n};\\n```\n```\\nint pseudoPalindromicPaths (TreeNode* root, int c = 0) {\\n        if(!root) return 0;\\n        c ^= (1 << root->val );\\n        int res  =  pseudoPalindromicPaths(root->left, c) + pseudoPalindromicPaths(root->right, c);\\n    \\n        if(!root->left && !root->right && (c & (c-1)) == 0 ) res++;\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574025,
                "title": "c-simple-solution-using-map-time-complexity-0-nk",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int,int>mp;\\n    int res=0;\\n    void helper(TreeNode*root){\\n\\n        if(root==NULL)return;\\n        \\n        mp[root->val]++;   //store the occrence of every integer into the map\\n        \\n        if(!root->left &&!root->right){\\n            int oct=0;               //count the number of integers whose occerence is odd\\n            for(auto&it:mp){\\n                if((it.second)%2==1)oct++;\\n                \\n                if(oct>1)break;    //if more than one integer have odd occurence then they cant make palindrome\\n\\n            }\\n            \\n            if(oct<=1)res++;    //if there is only one or zero elment whose occurence is odd then they make pseudo palindrome\\n        }\\n\\n        helper(root->left);\\n        helper(root->right);\\n        mp[root->val]--;          //as we insert every integer now after this we backtack that remove that integer from map\\n       \\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        \\n        helper(root);\\n        return res;\\n        \\n    }\\n};\\n```\\n\\ntime complexity=0(nk)\\nn->no. of nodes\\nk->total different intergers (here k=9)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int,int>mp;\\n    int res=0;\\n    void helper(TreeNode*root){\\n\\n        if(root==NULL)return;\\n        \\n        mp[root->val]++;   //store the occrence of every integer into the map\\n        \\n        if(!root->left &&!root->right){\\n            int oct=0;               //count the number of integers whose occerence is odd\\n            for(auto&it:mp){\\n                if((it.second)%2==1)oct++;\\n                \\n                if(oct>1)break;    //if more than one integer have odd occurence then they cant make palindrome\\n\\n            }\\n            \\n            if(oct<=1)res++;    //if there is only one or zero elment whose occurence is odd then they make pseudo palindrome\\n        }\\n\\n        helper(root->left);\\n        helper(root->right);\\n        mp[root->val]--;          //as we insert every integer now after this we backtack that remove that integer from map\\n       \\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        \\n        helper(root);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573536,
                "title": "python-easy-great-explanation-bit-manipulation",
                "content": "Xor of  Same Numbers = 0\\nso, In a path from root node to leaf, There are\\n\\n2 Possible Cases of Palindrome\\n\\n1) Even number of Node Values in a Path e.g [ 2,4,6,4,2,6 ] -> \\ncount of 2 :  2, count of 4 : 2 , count 6 : 2\\nso, the XOR would be 0.\\n2) Or  Even Number of Values and a single ODD Value e.g [2,4,6,9,6,4,2]\\ncount of 2 :  2, count of 4 : 2 , count 6 : 2, count 9 : 1\\nThe XOR would be Number itself i.e 9\\n\\nBut, If we directly take XOR of Numbers , we wouldn\\'t be sure in case of ODD Palindrome\\nthat if that path has only single odd count value.\\n\\nSo, We decide to take **XOR with Power of 2**\\n\\nThen What will happen:\\n\\nTaking Example : A PATH having Nodes - > [4,8,4]\\nCurrent XOR = 0\\n1) Taking 1st node value 4\\nXOR with 2 power 4  -> which is 16 ( in Binary 00010000 )\\n2) Taking 2st node value 8\\nXOR with 2 power 8  -> which is 272 ( in Binary 100010000 )\\n3) Lastly Taking 3rd node value 4\\nXOR with 2 power 4 -> which is 256 ( in Binary 100000000 )\\n\\nSee that the Only 1 bit is SET ( i.e 1 ) -> So ,we can say that the path is a ODD Palindrome.\\n\\nIt wouldn\\'t had been the case with Other Path Values\\nTaking Path e.g [4,8,5,4]\\nXOR of all the POWER of 2 with the above node values in Binary is  100100000\\nYou can see that More than 1 bit is SET.\\n\\nAnd Now, to check that the Current XOR is a POWER of 2 : \\nUse AND Operator with the XOR with XOR-1\\n\\nBCOZ \\n1000000000\\n0111111111\\n\\nwould make that 0.\\nThus, Verifying that XOR is a Power of 2\\n\\n```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        ans = 0\\n        rxor = 0\\n        \\n        def traverse(node,rxor):\\n            nonlocal ans\\n            rxor = rxor ^ 1<<node.val\\n\\t\\t\\t\\n            # If it is a Leaf Node (Both Child would be None )\\n\\t\\t\\tif node.left == None and node.right == None:\\n                \\n\\t\\t\\t\\tif  rxor == 0: ans += 1\\n\\t\\t\\t\\telif rxor & (rxor-1) == 0 : ans += 1\\n\\t\\t\\t\\treturn\\n\\n            if node.left : traverse(node.left,rxor)\\n            if node.right: traverse(node.right,rxor)\\n            \\n        traverse(root,rxor)\\n        return ans\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        ans = 0\\n        rxor = 0\\n        \\n        def traverse(node,rxor):\\n            nonlocal ans\\n            rxor = rxor ^ 1<<node.val\\n\\t\\t\\t\\n            # If it is a Leaf Node (Both Child would be None )\\n\\t\\t\\tif node.left == None and node.right == None:\\n                \\n\\t\\t\\t\\tif  rxor == 0: ans += 1\\n\\t\\t\\t\\telif rxor & (rxor-1) == 0 : ans += 1\\n\\t\\t\\t\\treturn\\n\\n            if node.left : traverse(node.left,rxor)\\n            if node.right: traverse(node.right,rxor)\\n            \\n        traverse(root,rxor)\\n        return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2573297,
                "title": "c-easy-straight-solution-beginner-friendly",
                "content": "# **Please Share and Upvote if it helped You this motivates me alot . Thanks for Support**\\n```\\nclass Solution {\\npublic:\\n    int isPalindrome(vector<int>&arr){\\n        int n=arr.size();\\n        int sum=0;\\n        int one=0,zero=0;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]%2){\\n                one++;\\n            }\\n            else{\\n                zero++;\\n            }\\n            sum+=arr[i];\\n        }\\n        if(sum%2==0){\\n            return one==0;\\n        }\\n        return one==1;\\n    }\\n    int rec(TreeNode*root,vector<int>arr){\\n        // cout<<root->val<<endl;\\n        if(!root->left&&!root->right){\\n            arr[root->val]++;\\n            \\n            int ans=isPalindrome(arr);\\n            // cout<<ans<<endl;\\n            return ans;\\n        }\\n        int val=0;\\n        arr[root->val]++;\\n        if(root->left){\\n            val+=rec(root->left,arr);\\n        }\\n        if(root->right){\\n            val+=rec(root->right,arr);\\n        }\\n        return val;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        if(!root->left&&!root->right)\\n            return 1;\\n        \\n        vector<int>arr(10,0);\\n        \\n        int ans=rec(root,arr);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPalindrome(vector<int>&arr){\\n        int n=arr.size();\\n        int sum=0;\\n        int one=0,zero=0;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]%2){\\n                one++;\\n            }\\n            else{\\n                zero++;\\n            }\\n            sum+=arr[i];\\n        }\\n        if(sum%2==0){\\n            return one==0;\\n        }\\n        return one==1;\\n    }\\n    int rec(TreeNode*root,vector<int>arr){\\n        // cout<<root->val<<endl;\\n        if(!root->left&&!root->right){\\n            arr[root->val]++;\\n            \\n            int ans=isPalindrome(arr);\\n            // cout<<ans<<endl;\\n            return ans;\\n        }\\n        int val=0;\\n        arr[root->val]++;\\n        if(root->left){\\n            val+=rec(root->left,arr);\\n        }\\n        if(root->right){\\n            val+=rec(root->right,arr);\\n        }\\n        return val;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        if(!root->left&&!root->right)\\n            return 1;\\n        \\n        vector<int>arr(10,0);\\n        \\n        int ans=rec(root,arr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2573172,
                "title": "c-easy-to-understand-o-n-bitmask-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int get(TreeNode* root, int mask){\\n        if(root == NULL)return 0;\\n        // if root->val has occured odd times set to even times\\n        // else if root->val has occured even times set to odd times\\n        int k = 1 << root->val;\\n        mask = mask ^ k;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            // if leaf node check how many numbers has occured odd times\\n            // if odd occurence are zero or one return true else false\\n            if(mask == 0)return 1;\\n            mask = mask & (mask-1);\\n            if(mask == 0)return 1;\\n            return 0;\\n        }\\n        \\n        return get(root->left, mask) + get(root->right, mask) ;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        int mask = 0;\\n        // zero means every number has occured even times\\n      return  get(root, mask);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int get(TreeNode* root, int mask){\\n        if(root == NULL)return 0;\\n        // if root->val has occured odd times set to even times\\n        // else if root->val has occured even times set to odd times\\n        int k = 1 << root->val;\\n        mask = mask ^ k;\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            // if leaf node check how many numbers has occured odd times\\n            // if odd occurence are zero or one return true else false\\n            if(mask == 0)return 1;\\n            mask = mask & (mask-1);\\n            if(mask == 0)return 1;\\n            return 0;\\n        }\\n        \\n        return get(root->left, mask) + get(root->right, mask) ;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        int mask = 0;\\n        // zero means every number has occured even times\\n      return  get(root, mask);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573133,
                "title": "javascript-solution",
                "content": "```\\nvar pseudoPalindromicPaths  = function(root) {\\n    let res = { count : 0 };\\n    let counter = new Array(10).fill(0);\\n\\t\\n    dfs(root, res, counter);\\n    return res.count;\\n};\\n\\nconst isValid = (nums) => {\\n    let odd = 0;\\n    for (let n of nums) {\\n        if (n > 0 && n % 2 === 1)\\n            odd++;\\n    }\\n    return odd < 2;\\n}\\n\\nconst dfs = (root, res, counter) => {\\n    if (!root) return;\\n    \\n    counter[root.val]++;\\n    \\n    if (!root.left && !root.right) {\\n        if (isValid(counter)) res.count += 1;\\n        return;\\n    }\\n    \\n    dfs(root.left, res, counter);\\n    root.left && counter[root.left.val]--;\\n    \\n    dfs(root.right, res, counter);\\n    root.right && counter[root.right.val]--;\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pseudoPalindromicPaths  = function(root) {\\n    let res = { count : 0 };\\n    let counter = new Array(10).fill(0);\\n\\t\\n    dfs(root, res, counter);\\n    return res.count;\\n};\\n\\nconst isValid = (nums) => {\\n    let odd = 0;\\n    for (let n of nums) {\\n        if (n > 0 && n % 2 === 1)\\n            odd++;\\n    }\\n    return odd < 2;\\n}\\n\\nconst dfs = (root, res, counter) => {\\n    if (!root) return;\\n    \\n    counter[root.val]++;\\n    \\n    if (!root.left && !root.right) {\\n        if (isValid(counter)) res.count += 1;\\n        return;\\n    }\\n    \\n    dfs(root.left, res, counter);\\n    root.left && counter[root.left.val]--;\\n    \\n    dfs(root.right, res, counter);\\n    root.right && counter[root.right.val]--;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1952229,
                "title": "c-beginners-friendly-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    bool check(vector<int> &map)\\n    {\\n        int odd = 0;\\n        for(auto count:map)\\n        {\\n            if(count&1)\\n                odd++;\\n        }\\n        return odd<=1;\\n    }\\n    void solve(TreeNode *root,vector<int> &map)\\n    {\\n        if(!root)\\n            return;\\n        if(!root->left and !root->right)\\n        {\\n            map[root->val]++;\\n            ans += check(map);\\n            map[root->val]--;\\n            return;\\n        }\\n        map[root->val]++;\\n        solve(root->left,map);\\n        solve(root->right,map);\\n        map[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> map(10,0);\\n        solve(root,map);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    bool check(vector<int> &map)\\n    {\\n        int odd = 0;\\n        for(auto count:map)\\n        {\\n            if(count&1)\\n                odd++;\\n        }\\n        return odd<=1;\\n    }\\n    void solve(TreeNode *root,vector<int> &map)\\n    {\\n        if(!root)\\n            return;\\n        if(!root->left and !root->right)\\n        {\\n            map[root->val]++;\\n            ans += check(map);\\n            map[root->val]--;\\n            return;\\n        }\\n        map[root->val]++;\\n        solve(root->left,map);\\n        solve(root->right,map);\\n        map[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> map(10,0);\\n        solve(root,map);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634396,
                "title": "c-dfs-backtracking-map",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int ans = 0;\\n    \\n    bool isPalindromePossible(){\\n        if(mp.size()==1) return true;\\n        int odd_cnt = 0;\\n        \\n        for(auto it = mp.begin(); it!=mp.end(); it++){\\n            if(it->second % 2 != 0) odd_cnt++;\\n        }\\n        \\n        if(odd_cnt > 1) return false;\\n        return true;\\n        \\n    }\\n    \\n    void solve(TreeNode* root){\\n        if(root==NULL) return ;\\n         mp[root->val]++;\\n        if(root->left==NULL && root->right==NULL) {\\n            if(isPalindromePossible()) ans++;\\n             mp[root->val]--;\\n            return ;\\n        }\\n       \\n        solve(root->left);\\n        solve(root->right);\\n         mp[root->val]--;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n          solve(root);\\n           return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    map<int,int> mp;\\n    int ans = 0;\\n    \\n    bool isPalindromePossible(){\\n        if(mp.size()==1) return true;\\n        int odd_cnt = 0;\\n        \\n        for(auto it = mp.begin(); it!=mp.end(); it++){\\n            if(it->second % 2 != 0) odd_cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1356469,
                "title": "python-bitmask-faster-than-92-19",
                "content": "\\n```\\nclass Solution:\\n\\tdef pseudoPalindromicPaths (self, root: TreeNode, bitck: int = 0) -> int:\\n\\t\\tif not root: return 0\\n\\t\\tbitck ^= (1 << root.val)\\n        if not root.left and not root.right:\\n\\t\\t\\tcnt = 0\\n            while bitck > 0:\\n\\t\\t\\t\\tbitck &= (bitck-1)\\n\\t\\t\\t\\tcnt += 1\\n            if cnt <= 1: return 1\\n            return 0\\n        return self.pseudoPalindromicPaths(root.left, bitck) + self.pseudoPalindromicPaths(root.right, bitck)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n\\tdef pseudoPalindromicPaths (self, root: TreeNode, bitck: int = 0) -> int:\\n\\t\\tif not root: return 0\\n\\t\\tbitck ^= (1 << root.val)\\n        if not root.left and not root.right:\\n\\t\\t\\tcnt = 0\\n            while bitck > 0:\\n\\t\\t\\t\\tbitck &= (bitck-1)\\n\\t\\t\\t\\tcnt += 1\\n            if cnt <= 1: return 1\\n            return 0\\n        return self.pseudoPalindromicPaths(root.left, bitck) + self.pseudoPalindromicPaths(root.right, bitck)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995430,
                "title": "c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count;\\n    bool check(vector<int>v)\\n    {\\n        int even=0;\\n        int odd=0;\\n        for(auto it:v)\\n        {\\n            if(it%2==0)\\n            {\\n                even++;\\n            }\\n            else\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd<2)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    void find(TreeNode*root,vector<int>&v)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        v[root->val]++;\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            if(check(v))\\n            {\\n                count++;\\n            }\\n        }\\n        find(root->left,v);\\n        find(root->right,v);\\n        v[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) \\n    {\\n        vector<int>v(10,0);\\n        find(root,v);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count;\\n    bool check(vector<int>v)\\n    {\\n        int even=0;\\n        int odd=0;\\n        for(auto it:v)\\n        {\\n            if(it%2==0)\\n            {\\n                even++;\\n            }\\n            else\\n            {\\n                odd++;\\n            }\\n        }\\n        if(odd<2)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    void find(TreeNode*root,vector<int>&v)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        v[root->val]++;\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            if(check(v))\\n            {\\n                count++;\\n            }\\n        }\\n        find(root->left,v);\\n        find(root->right,v);\\n        v[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) \\n    {\\n        vector<int>v(10,0);\\n        find(root,v);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993780,
                "title": "simple-java-solution-recursive-dfs",
                "content": "```\\nclass Solution {\\n    private int result=0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] map = new int[10];\\n        traverseAndCheck(root,map);\\n        return result;\\n    }\\n    private void traverseAndCheck(TreeNode root,int[] map) {\\n        if(root!=null) {\\n            map[root.val]++;\\n            if(root.left==null && root.right==null) {\\n               if(isPseudoPalindrome(map)) {\\n                   result++;\\n               }\\n            }\\n            traverseAndCheck(root.left,map);\\n            traverseAndCheck(root.right,map);\\n            map[root.val]--;\\n        }\\n    }\\n    \\n    private boolean isPseudoPalindrome(int[] map) {\\n        int odd=0;\\n        for(int i=1;i<10;i++) {\\n            if(map[i]%2!=0) {\\n                odd++;\\n            }\\n            if(odd>1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private int result=0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] map = new int[10];\\n        traverseAndCheck(root,map);\\n        return result;\\n    }\\n    private void traverseAndCheck(TreeNode root,int[] map) {\\n        if(root!=null) {\\n            map[root.val]++;\\n            if(root.left==null && root.right==null) {\\n               if(isPseudoPalindrome(map)) {\\n                   result++;\\n               }\\n            }\\n            traverseAndCheck(root.left,map);\\n            traverseAndCheck(root.right,map);\\n            map[root.val]--;\\n        }\\n    }\\n    \\n    private boolean isPseudoPalindrome(int[] map) {\\n        int odd=0;\\n        for(int i=1;i<10;i++) {\\n            if(map[i]%2!=0) {\\n                odd++;\\n            }\\n            if(odd>1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993307,
                "title": "python-backtracking-alike-no-bit",
                "content": "I tried to approach the problem with common tree problem patterns and found that backtracking-alike approach is easier without clever tricks or bit operations [not good at this], the only tricky part is to observe pseudopalindromic paths = paths with at most 1 odd elements\\n\\n```\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        # only 1-9, space O(1)\\n        arr = [0] * 10\\n        cnt = 0\\n        \\n        def helper(node):\\n            nonlocal cnt\\n            # base case\\n            if not node: return\\n            # include the current node, similar to path construction in backtracking\\n            arr[node.val] += 1\\n            # path is ended, check whether pseudoPalindromic\\n            if not node.left and not node.right:\\n                # odd item can be at most 1\\n                cnt += int(len([item for item in arr if item%2==1])<=1)\\n            helper(node.left)\\n            helper(node.right)\\n            # remove the current node, similar to backtracking\\n            arr[node.val] -= 1\\n        helper(root)\\n        return cnt\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\n    def pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        # only 1-9, space O(1)\\n        arr = [0] * 10\\n        cnt = 0\\n        \\n        def helper(node):\\n            nonlocal cnt\\n            # base case\\n            if not node: return\\n            # include the current node, similar to path construction in backtracking\\n            arr[node.val] += 1\\n            # path is ended, check whether pseudoPalindromic\\n            if not node.left and not node.right:\\n                # odd item can be at most 1\\n                cnt += int(len([item for item in arr if item%2==1])<=1)\\n            helper(node.left)\\n            helper(node.right)\\n            # remove the current node, similar to backtracking\\n            arr[node.val] -= 1\\n        helper(root)\\n        return cnt\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 992870,
                "title": "c-beginner-friendly-recursive-solution-no-bit-manipulation",
                "content": "Traverse the tree and store node values frequencies in vector.\\nWhen it\\'s a leaf node, count frequency of all elements in that path. If odd elements count is 1 or if there are no odd frequencies, increment palindromic count.\\n```\\nint pseudoPalindromicPaths (TreeNode* root) {\\n        vector<vector<int>> path;\\n        vector<int> vec(10,0);       // store frequency of elements in each path\\n        int i,j;\\n        int palindromicPathCount=0;\\n        if(root == NULL)\\n            return 0;\\n       \\n        findPalindromicPaths(root, vec, palindromicPathCount);\\n        return palindromicPathCount;\\n    }\\n    \\n  \\n     void findPalindromicPaths(TreeNode *node, vector<int>vec, int &palindromicPathCount)\\n    {\\n        if(node == NULL)\\n            return;\\n        if(node->left == NULL && node->right==NULL)\\n        {\\n            vec[node->val]++;\\n            int count=0;\\n            for(auto n : vec)\\n            {\\n                if(n%2 !=0)\\n                    count++;\\n            }\\n            if(count == 1 || count==0)\\n                palindromicPathCount++;\\n            return;\\n        }\\n        vec[node->val]++;\\n        findPalindromicPaths(node->left, vec, palindromicPathCount);\\n        findPalindromicPaths(node->right, vec, palindromicPathCount);\\n        \\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "Traverse the tree and store node values frequencies in vector.\\nWhen it\\'s a leaf node, count frequency of all elements in that path. If odd elements count is 1 or if there are no odd frequencies, increment palindromic count.\\n```\\nint pseudoPalindromicPaths (TreeNode* root) {\\n        vector<vector<int>> path;\\n        vector<int> vec(10,0);       // store frequency of elements in each path\\n        int i,j;\\n        int palindromicPathCount=0;\\n        if(root == NULL)\\n            return 0;\\n       \\n        findPalindromicPaths(root, vec, palindromicPathCount);\\n        return palindromicPathCount;\\n    }\\n    \\n  \\n     void findPalindromicPaths(TreeNode *node, vector<int>vec, int &palindromicPathCount)\\n    {\\n        if(node == NULL)\\n            return;\\n        if(node->left == NULL && node->right==NULL)\\n        {\\n            vec[node->val]++;\\n            int count=0;\\n            for(auto n : vec)\\n            {\\n                if(n%2 !=0)\\n                    count++;\\n            }\\n            if(count == 1 || count==0)\\n                palindromicPathCount++;\\n            return;\\n        }\\n        vec[node->val]++;\\n        findPalindromicPaths(node->left, vec, palindromicPathCount);\\n        findPalindromicPaths(node->right, vec, palindromicPathCount);\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 992446,
                "title": "rust-recursion-dfs-with-bit-ops",
                "content": "```rust\\npub type Tree = Option<Rc<RefCell<TreeNode>>>;\\nimpl Solution {\\n    pub fn pseudo_palindromic_paths(root: Tree) -> i32 {\\n        pali_traverse(root, 0)\\n    }\\n}\\nfn pali_traverse(root: Tree, code: u16) -> i32 {\\n    let rc = if let Some(rc) = root { rc } else { return 0; };\\n    let tn = rc.borrow();\\n    let new_code = code ^ (1 << tn.val);\\n    if tn.left.is_none() && tn.right.is_none() {\\n        return if ((new_code - 1) & new_code) == 0 { 1 } else { 0 };\\n    }\\n    pali_traverse(tn.left.clone(), new_code) + pali_traverse(tn.right.clone(), new_code)\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub type Tree = Option<Rc<RefCell<TreeNode>>>;\\nimpl Solution {\\n    pub fn pseudo_palindromic_paths(root: Tree) -> i32 {\\n        pali_traverse(root, 0)\\n    }\\n}\\nfn pali_traverse(root: Tree, code: u16) -> i32 {\\n    let rc = if let Some(rc) = root { rc } else { return 0; };\\n    let tn = rc.borrow();\\n    let new_code = code ^ (1 << tn.val);\\n    if tn.left.is_none() && tn.right.is_none() {\\n        return if ((new_code - 1) & new_code) == 0 { 1 } else { 0 };\\n    }\\n    pali_traverse(tn.left.clone(), new_code) + pali_traverse(tn.right.clone(), new_code)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 992304,
                "title": "pseudo-palindromic-paths-in-a-binary-tree-java-recursive-preorder-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int ans = 0;\\n    int[] digits;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        digits = new int[10];\\n        preorder(root);\\n        \\n        return ans;\\n    }\\n    \\n    public void preorder(TreeNode root){\\n        if(root == null)\\n            return;\\n        \\n        digits[root.val]++;\\n        \\n        if(root.left == null && root.right == null){\\n            if(isPalindrome()) ans++;\\n        }else{\\n            preorder(root.left);\\n            preorder(root.right);\\n        }\\n        \\n        digits[root.val]--;\\n    }\\n    \\n    public boolean isPalindrome(){\\n        int oddc = 0;\\n        \\n        for(int i=0; i<10; i++){\\n            if(digits[i] % 2 != 0)\\n                oddc++;\\n        }\\n        \\n        return oddc > 1 ? false : true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int ans = 0;\\n    int[] digits;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        digits = new int[10];\\n        preorder(root);\\n        \\n        return ans;\\n    }\\n    \\n    public void preorder(TreeNode root){\\n        if(root == null)\\n            return;\\n        \\n        digits[root.val]++;\\n        \\n        if(root.left == null && root.right == null){\\n            if(isPalindrome()) ans++;\\n        }else{\\n            preorder(root.left);\\n            preorder(root.right);\\n        }\\n        \\n        digits[root.val]--;\\n    }\\n    \\n    public boolean isPalindrome(){\\n        int oddc = 0;\\n        \\n        for(int i=0; i<10; i++){\\n            if(digits[i] % 2 != 0)\\n                oddc++;\\n        }\\n        \\n        return oddc > 1 ? false : true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992013,
                "title": "javascript-bit-masking-beats-100-6-lines",
                "content": "```javascript\\nvar pseudoPalindromicPaths  = function(root, mask = 0) {\\n  // Mask has 9 spaces corresponding to 1 - 9\\n  \\n  if (root === null) return 0;\\n  mask ^= 1 << root.val - 1;\\n  // e.g. val = 4 and current mask is 0b011000011\\n  // the space 4 of mask is 0 -> change it to 1 (which means the current numbers of 4 is even)\\n  // -> mask now is 0b011001011\\n  // if that space is 1 then change it to 0 (the numbers of 4 is odd)\\n  \\n  if (root.left === null && root.right === null) return (mask & -mask) === mask;\\n  // a trick to check if mask is a power of 2 (which means mask contains 0 or 1 ones)\\n  // if it does return true else false\\n  \\n  return pseudoPalindromicPaths(root.left, mask) + pseudoPalindromicPaths(root.right, mask);\\n  // note that true == 1 and false == 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```javascript\\nvar pseudoPalindromicPaths  = function(root, mask = 0) {\\n  // Mask has 9 spaces corresponding to 1 - 9\\n  \\n  if (root === null) return 0;\\n  mask ^= 1 << root.val - 1;\\n  // e.g. val = 4 and current mask is 0b011000011\\n  // the space 4 of mask is 0 -> change it to 1 (which means the current numbers of 4 is even)\\n  // -> mask now is 0b011001011\\n  // if that space is 1 then change it to 0 (the numbers of 4 is odd)\\n  \\n  if (root.left === null && root.right === null) return (mask & -mask) === mask;\\n  // a trick to check if mask is a power of 2 (which means mask contains 0 or 1 ones)\\n  // if it does return true else false\\n  \\n  return pseudoPalindromicPaths(root.left, mask) + pseudoPalindromicPaths(root.right, mask);\\n  // note that true == 1 and false == 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 991906,
                "title": "python-bit-masking-and-recursion-6-lines-with-examples",
                "content": "**Insights:**\\n\\nA pseudopalindrome must have **at most** one odd occurrence of a number.\\n\\nBecause the numbers are all in the range of [1, 9] an easy way to keep track\\nof whether we have seen an even or odd amount of a given number is to\\nuse a bit-mask.\\n\\n<details>\\n\\n<summary><b>Here is an example of bit masking:</b> (click to show)</summary>\\n\\n```html5\\nmask = 714 = \\'1011001010\\'\\n              9876543210\\n\\t\\t\\t\\t\\nBits 1, 3, 6, 7, and 9 are turned on.\\nThis means we have seen an odd number of 1, 3, 6, 7 and 9.\\nAnd an even number of 2, 4, 5 and 8.\\n```\\n\\nWhen we see another 3 we can flip the third bit <b>off</b> using any of the following methods:\\n```txt\\nThis can be done by 714 - (2**3)\\n              or by 714 ^ (2**3)\\n\\t\\t\\t  or by 714 ^ (1 << 3)\\n\\nNote: (1 << x) is the same as (2 ** x)\\n\\nmask = 706 = \\'1011000010\\'\\n```\\n\\nLikewise we can flip the third bit <b>on</b> like so:\\n\\n```txt\\n714 + (2**3)\\n714 ^ (2**3)\\n714 ^ (1<<3)\\nmask = 714 = mask = \\'1011001010\\'\\n```\\n\\n</details>\\n\\n**Approach:**\\n\\nTraverse each branch of the tree and use mask to keep track of\\nwhether each value has been seen an even or odd number of times.\\n\\nWhen a leaf node is reached, check if the path is a pseudopalindrome.\\nThe path is a pseudopalindrome if the bitmask has at most one bit turned on.\\nIf the path is a pseudopalindrome, return 1.\\n\\nIf the node is not a leaf node, then return the sum of the recursive calls\\nto the leaf node\\'s children.  This is equal to the number of \\npseudopalindromes that pass through the node.\\n\\n<br>\\n\\n```python\\ndef pseudoPalindromicPaths(self, node: TreeNode, mask = 0) -> int:\\n\\tmask = mask ^ (1 << node.val)\\n\\tif node.left and node.right:\\n\\t\\treturn self.pseudoPalindromicPaths(node.left, mask) + self.pseudoPalindromicPaths(node.right, mask)\\n\\telif node.left or node.right:\\n\\t\\treturn self.pseudoPalindromicPaths(node.left, mask) if node.left else self.pseudoPalindromicPaths(node.right, mask)\\n\\treturn int(bin(mask).count(\\'1\\') <= 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```html5\\nmask = 714 = \\'1011001010\\'\\n              9876543210\\n\\t\\t\\t\\t\\nBits 1, 3, 6, 7, and 9 are turned on.\\nThis means we have seen an odd number of 1, 3, 6, 7 and 9.\\nAnd an even number of 2, 4, 5 and 8.\\n```\n```txt\\nThis can be done by 714 - (2**3)\\n              or by 714 ^ (2**3)\\n\\t\\t\\t  or by 714 ^ (1 << 3)\\n\\nNote: (1 << x) is the same as (2 ** x)\\n\\nmask = 706 = \\'1011000010\\'\\n```\n```txt\\n714 + (2**3)\\n714 ^ (2**3)\\n714 ^ (1<<3)\\nmask = 714 = mask = \\'1011001010\\'\\n```\n```python\\ndef pseudoPalindromicPaths(self, node: TreeNode, mask = 0) -> int:\\n\\tmask = mask ^ (1 << node.val)\\n\\tif node.left and node.right:\\n\\t\\treturn self.pseudoPalindromicPaths(node.left, mask) + self.pseudoPalindromicPaths(node.right, mask)\\n\\telif node.left or node.right:\\n\\t\\treturn self.pseudoPalindromicPaths(node.left, mask) if node.left else self.pseudoPalindromicPaths(node.right, mask)\\n\\treturn int(bin(mask).count(\\'1\\') <= 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 861849,
                "title": "python-set-xor-dfs-beats-90",
                "content": "The logic in this solution is that, for a series of numbers to be palindrome, there should be atmost 1 element which occurs odd number of times.\\n\\n**Examples:**\\n[1, 1, 1],\\n[1, 2, 3, 3, 2, 1],\\n[1, 2, 3, 2, 1],\\n[1, 2, 3, 3, 3, 2, 1] are all palindromic series.\\n\\nThus all series of numbers which have atmost 1 element which occurs odd number of times, will have a permutation which will be palindrome.\\n\\nThe second thing here is when we do XOR operation on sets, the intersection elements are removed, and the union of the remaining elements are returned.\\n\\n**Example:\\n{ 1, 2, 3, 4 } ^ { 4 } = { 1, 2, 3 }**\\n**{ 1, 2, 3 } ^ { 5 } = { 1, 2, 3, 5 }**\\n\\nThis makes sure that only elements which have occured odd number of times upto that point remain in the set.\\nThus in the end we check if the number of odd occuring elements is <= 1 or not. If yes then the series will have a palindromic permutation otherwise not.\\n\\n```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: TreeNode):\\n        self.count = 0\\n        def traverse(root, path):\\n            if root.left:\\n                traverse(root.left, path^{root.val})\\n            if root.right:\\n                traverse(root.right, path^{root.val})\\n            \\n            if not root.left and not root.right:\\n                if len(path^{root.val}) < 2:\\n                    self.count += 1\\n                \\n        traverse(root, set())\\n        return self.count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: TreeNode):\\n        self.count = 0\\n        def traverse(root, path):\\n            if root.left:\\n                traverse(root.left, path^{root.val})\\n            if root.right:\\n                traverse(root.right, path^{root.val})\\n            \\n            if not root.left and not root.right:\\n                if len(path^{root.val}) < 2:\\n                    self.count += 1\\n                \\n        traverse(root, set())\\n        return self.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742624,
                "title": "easy-recursive-c-solution-using-bitset-o-n-time",
                "content": "The basic idea behind this solution is that if a root to leaf path contains atmost only 1 odd occurence of any node value (any digit between 1 - 9) it is always possible to make it a pseudo-palindromic path.\\n```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void path(TreeNode* root, bitset<9> bSet) {\\n        if(root) {\\n            bSet.flip(root->val - 1);\\n            if(!root->left && !root->right) {\\n                if (bSet.count() <= 1)\\n                    count++;\\n                return;\\n            }\\n            path(root->left, bSet);\\n            path(root->right, bSet);\\n        }\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        bitset<9> bSet;\\n        path(root, bSet);\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int count = 0;\\n    void path(TreeNode* root, bitset<9> bSet) {\\n        if(root) {\\n            bSet.flip(root->val - 1);\\n            if(!root->left && !root->right) {\\n                if (bSet.count() <= 1)\\n                    count++;\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 663784,
                "title": "using-basic-bit-manipulation-and-beats-99-4",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res=0;\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        nodeToRootPath(root,0);\\n        return res;\\n    }\\n    void nodeToRootPath(TreeNode *node, int num)\\n    {\\n        if(!node)\\n            return;\\n        \\n        int mask=1;\\n        mask=mask<<(node->val);\\n        num=(num^mask);              //toggaling on the num bit of node->val\\n        \\n        if(node->left==nullptr && node->right==nullptr) {\\n            int count=0;\\n            while(num>0)                  //counting number of on bit\\n            {\\n                count+=(num&1);\\n                num=(num>>1);\\n            }\\n            if(count==1 || count==0)    //to be a palindromic path each value should be in even count with maximum of one val with odd count\\n                res+=1;\\n        }\\n        \\n        nodeToRootPath(node->left,num);\\n        nodeToRootPath(node->right,num);\\n        return;\\n    }\\n};\\nauto SpeedUp = []() {\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return nullptr;\\n}();\\n```\\n\\nXOR gate used\\n\\nas when even time bits on \\nXOR gives 0\\nwhereas \\nfor odd times gives 1\\n\\nA       B        A^B\\n0       0           0\\n1       0           1\\n0       1           1\\n1       1           0",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res=0;\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        nodeToRootPath(root,0);\\n        return res;\\n    }\\n    void nodeToRootPath(TreeNode *node, int num)\\n    {\\n        if(!node)\\n            return;\\n        \\n        int mask=1;\\n        mask=mask<<(node->val);\\n        num=(num^mask);              //toggaling on the num bit of node->val\\n        \\n        if(node->left==nullptr && node->right==nullptr) {\\n            int count=0;\\n            while(num>0)                  //counting number of on bit\\n            {\\n                count+=(num&1);\\n                num=(num>>1);\\n            }\\n            if(count==1 || count==0)    //to be a palindromic path each value should be in even count with maximum of one val with odd count\\n                res+=1;\\n        }\\n        \\n        nodeToRootPath(node->left,num);\\n        nodeToRootPath(node->right,num);\\n        return;\\n    }\\n};\\nauto SpeedUp = []() {\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    std::cout.tie(nullptr);\\n    return nullptr;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 654030,
                "title": "python-dfs-using-set",
                "content": "```\\ndef pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n\\tdef dfs(node, path):\\n\\t\\tif not node: return 0\\n\\t\\tcur = set(path)\\n\\t\\tif node.val in cur: cur.remove(node.val)\\n\\t\\telse: cur.add(node.val)\\n\\t\\tres = dfs(node.left, cur) + dfs(node.right, cur)\\n\\t\\tif not node.left and not node.right:\\n\\t\\t\\tif len(cur)<2: res+=1\\n\\t\\treturn res\\n\\treturn dfs(root, set())\\n```",
                "solutionTags": [],
                "code": "```\\ndef pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n\\tdef dfs(node, path):\\n\\t\\tif not node: return 0\\n\\t\\tcur = set(path)\\n\\t\\tif node.val in cur: cur.remove(node.val)\\n\\t\\telse: cur.add(node.val)\\n\\t\\tres = dfs(node.left, cur) + dfs(node.right, cur)\\n\\t\\tif not node.left and not node.right:\\n\\t\\t\\tif len(cur)<2: res+=1\\n\\t\\treturn res\\n\\treturn dfs(root, set())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 648853,
                "title": "simple-python-code-using-dfs",
                "content": "For each root to node path which is computed using DFS , check palindrome\\n\\nif the length of string(path from root to node) is \\n**case 1 : ODD**\\nOne charactrer in string can have odd number of occurences , remaining all should have even ocurences\\nex : 12312 - only 3 has odd number of occurences\\n**case2 : EVEN**\\nAll characters in string should have even number of occurences:\\nex: 1212 , 1111 , 2233 are palindromes\\n1112 , here 1 has odd number of occurences so not a palindrome\\n\\n\\n```\\ndef pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        \\n        def chkpalindrome(s):\\n            n = len(s)\\n            d = {}\\n            for c in s:\\n                d[c] = d.get(c,0) + 1\\n            flag = n%2 != 0\\n            for c in d:\\n                if d[c]%2!=0:\\n                    if not flag:\\n                        return False\\n                    flag = 0\\n            return True\\n        \\n        self.ans = 0\\n        \\n        def traverse(node,s):\\n            if not node.left and not node.right:\\n                self.ans += chkpalindrome(s+str(node.val))\\n            if node.left:\\n                traverse(node.left,s+str(node.val))\\n            if node.right:\\n                traverse(node.right,s+str(node.val))\\n        \\n        traverse(root,\"\")\\n        return self.ans\\n",
                "solutionTags": [],
                "code": "For each root to node path which is computed using DFS , check palindrome\\n\\nif the length of string(path from root to node) is \\n**case 1 : ODD**\\nOne charactrer in string can have odd number of occurences , remaining all should have even ocurences\\nex : 12312 - only 3 has odd number of occurences\\n**case2 : EVEN**\\nAll characters in string should have even number of occurences:\\nex: 1212 , 1111 , 2233 are palindromes\\n1112 , here 1 has odd number of occurences so not a palindrome\\n\\n\\n```\\ndef pseudoPalindromicPaths (self, root: TreeNode) -> int:\\n        \\n        def chkpalindrome(s):\\n            n = len(s)\\n            d = {}\\n            for c in s:\\n                d[c] = d.get(c,0) + 1\\n            flag = n%2 != 0\\n            for c in d:\\n                if d[c]%2!=0:\\n                    if not flag:\\n                        return False\\n                    flag = 0\\n            return True\\n        \\n        self.ans = 0\\n        \\n        def traverse(node,s):\\n            if not node.left and not node.right:\\n                self.ans += chkpalindrome(s+str(node.val))\\n            if node.left:\\n                traverse(node.left,s+str(node.val))\\n            if node.right:\\n                traverse(node.right,s+str(node.val))\\n        \\n        traverse(root,\"\")\\n        return self.ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 648741,
                "title": "backtracking-python-code-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def pseudoPalindromicPaths (self, root):\\n        res = 0\\n        allpath = []\\n        self.dfs(root, \\'\\', allpath)\\n        print(allpath)\\n        \\n        for p in allpath:\\n            if self.check(p): res += 1\\n        return res\\n    def dfs(self, root, path, allpath):\\n        if not root:\\n            return\\n        if not root.left and not root.right:\\n            path+=str(root.val)\\n            allpath.append(path)\\n            return\\n        \\n        self.dfs(root.left, path+str(root.val), allpath)\\n        self.dfs(root.right, path+str(root.val), allpath)\\n\\n    \\n    def check(self, s):\\n        return sum(v % 2 for v in collections.Counter(s).values()) < 2",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pseudoPalindromicPaths (self, root):\\n        res = 0\\n        allpath = []\\n        self.dfs(root, \\'\\', allpath)\\n        print(allpath)\\n        \\n        for p in allpath:\\n            if self.check(p): res += 1\\n        return res\\n    def dfs(self, root, path, allpath):\\n        if not root:\\n            return\\n        if not root.left and not root.right:\\n            path+=str(root.val)\\n            allpath.append(path)\\n            return\\n        \\n        self.dfs(root.left, path+str(root.val), allpath)\\n        self.dfs(root.right, path+str(root.val), allpath)\\n\\n    \\n    def check(self, s):\\n        return sum(v % 2 for v in collections.Counter(s).values()) < 2",
                "codeTag": "Java"
            },
            {
                "id": 648698,
                "title": "java-combination-of-binarytreepaths-and-ispalindrome",
                "content": "This problem can be broken down into 2 parts.\\n1. Getting all the root to leaf paths\\n2. Checking if that path is a palindrome\\n\\nPlease do take a look \\n\\n```\\npublic int pseudoPalindromicPaths (TreeNode root) {\\n        if (root == null) return 0;\\n        if (root.left == null && root.right == null) return 1;\\n        List<List<Integer>> res = new ArrayList<>();\\n        rootToLeafPaths(root, res, \"\");\\n        int max = 0;\\n        for (List<Integer> path : res) {\\n            if (checkPalindrome(path)) max ++;\\n        }\\n        return max;\\n    }\\n    \\n    private void rootToLeafPaths(TreeNode root, List<List<Integer>> res, String curr) {\\n        if (root.left == null && root.right == null) {\\n            String[] vals = curr.split(\",\");\\n            List<Integer> temp = new ArrayList<>();\\n            for (String val : vals) temp.add(Integer.parseInt(val));\\n            temp.add(root.val);\\n            res.add(new ArrayList<>(temp));\\n        }\\n        if (root.left != null) rootToLeafPaths(root.left, res, curr + root.val + \",\");\\n        if (root.right != null) rootToLeafPaths(root.right, res, curr + root.val + \",\");\\n    }\\n    private boolean checkPalindrome(List<Integer> input) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : input) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        int oddCount = 0, evenCount = 0;\\n        for (int count : map.values()) {\\n            if (count % 2 == 0) evenCount ++;\\n            else oddCount ++;\\n        }\\n        if (oddCount > 1) return false;\\n        else return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic int pseudoPalindromicPaths (TreeNode root) {\\n        if (root == null) return 0;\\n        if (root.left == null && root.right == null) return 1;\\n        List<List<Integer>> res = new ArrayList<>();\\n        rootToLeafPaths(root, res, \"\");\\n        int max = 0;\\n        for (List<Integer> path : res) {\\n            if (checkPalindrome(path)) max ++;\\n        }\\n        return max;\\n    }\\n    \\n    private void rootToLeafPaths(TreeNode root, List<List<Integer>> res, String curr) {\\n        if (root.left == null && root.right == null) {\\n            String[] vals = curr.split(\",\");\\n            List<Integer> temp = new ArrayList<>();\\n            for (String val : vals) temp.add(Integer.parseInt(val));\\n            temp.add(root.val);\\n            res.add(new ArrayList<>(temp));\\n        }\\n        if (root.left != null) rootToLeafPaths(root.left, res, curr + root.val + \",\");\\n        if (root.right != null) rootToLeafPaths(root.right, res, curr + root.val + \",\");\\n    }\\n    private boolean checkPalindrome(List<Integer> input) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : input) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        int oddCount = 0, evenCount = 0;\\n        for (int count : map.values()) {\\n            if (count % 2 == 0) evenCount ++;\\n            else oddCount ++;\\n        }\\n        if (oddCount > 1) return false;\\n        else return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 648553,
                "title": "java-dfs-with-o-1-time-to-check-palindrome",
                "content": "```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] hash = new int[10];\\n        int[] ans = new int[1];\\n        ++hash[root.val];\\n        dfs(root, hash, ans, 1);\\n        return ans[0];\\n    }\\n    \\n    private void dfs(TreeNode root, int[] hash, int[] ans, int count) {\\n\\t\\t//count means the number of odd digits\\n        if (root.left == null && root.right == null) {\\n            if (count <= 1) ans[0]++;\\n        }\\n\\t\\t// classic backtracking\\n        if (root.left != null) {\\n            hash[root.left.val]++; // choose\\n            dfs(root.left, hash, ans, hash[root.left.val] % 2 == 0 ? count - 1 : count + 1);\\n            hash[root.left.val]--;  // unchoose\\n        }\\n        if (root.right != null) {\\n            hash[root.right.val]++;\\n            dfs(root.right, hash, ans, hash[root.right.val] % 2 == 0 ? count - 1 : count + 1);\\n            hash[root.right.val]--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] hash = new int[10];\\n        int[] ans = new int[1];\\n        ++hash[root.val];\\n        dfs(root, hash, ans, 1);\\n        return ans[0];\\n    }\\n    \\n    private void dfs(TreeNode root, int[] hash, int[] ans, int count) {\\n\\t\\t//count means the number of odd digits\\n        if (root.left == null && root.right == null) {\\n            if (count <= 1) ans[0]++;\\n        }\\n\\t\\t// classic backtracking\\n        if (root.left != null) {\\n            hash[root.left.val]++; // choose\\n            dfs(root.left, hash, ans, hash[root.left.val] % 2 == 0 ? count - 1 : count + 1);\\n            hash[root.left.val]--;  // unchoose\\n        }\\n        if (root.right != null) {\\n            hash[root.right.val]++;\\n            dfs(root.right, hash, ans, hash[root.right.val] % 2 == 0 ? count - 1 : count + 1);\\n            hash[root.right.val]--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648459,
                "title": "simple-pre-order-traversal-with-explanation-and-comments-in-java-with-digit-count",
                "content": "**Time Complexity : O(n)\\n\\n**Space Complexity : Recursion stack (Worst case if tree is skewed ) O(n) + digitFrequency (constant space)\\n\\n```\\npublic class Solution {\\n\\t \\n\\t static int count[]; \\n     // count of the number of such paths\\n\\t static int res = 0;\\n\\t \\n\\t //Logic of checking whether palindorme possible or not\\n\\t private boolean isPossible() {\\n\\t\\t \\n\\t\\t // Check in the given path if more then 1 digit having ODD frequency then answer is not possible\\n\\t\\t int oddCount = 0;\\n\\t\\t \\n\\t\\t for(int i=0; i<10; i++) {\\n\\t\\t\\t \\n\\t\\t\\t if(count[i]%2 != 0) {\\n\\t\\t\\t\\t oddCount++;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t \\n\\t\\t if(oddCount > 1) {\\n\\t\\t\\t return false;\\n\\t\\t }\\n\\t\\t \\n\\t\\t return true;\\n\\t }\\n\\t \\n\\t \\n\\t private void countAns(TreeNode root) {\\n\\t\\t \\n\\t\\t if(root == null) {\\n\\t\\t\\t return;\\n\\t\\t }\\n\\t\\t \\n\\t\\t //When root check whether it forms the solution or not\\n\\t\\t if(root.left == null && root.right == null) {\\n\\t\\t\\t \\n\\t\\t\\t count[root.val]++;\\n\\t\\t\\t \\n\\t\\t\\t //if valid solution then increment the answer\\n\\t\\t\\t if(isPossible()) {\\n\\t\\t\\t\\t res++;\\n\\t\\t\\t }\\n\\t\\t\\t count[root.val]--;\\n\\t\\t\\t return;\\n\\t\\t }\\n\\t\\t \\n\\t\\t //incrementing the digit at particular node\\n\\t\\t count[root.val]++;\\n\\t\\t countAns(root.left);\\n\\t\\t countAns(root.right);\\n\\t\\t //decrementing once visit is finished\\n\\t\\t count[root.val]--;\\n\\t }\\n\\t \\n\\t public int pseudoPalindromicPaths (TreeNode root) {\\n\\t\\t \\n\\t\\t res = 0;\\n\\t\\t\\n\\t\\t if(root == null) {\\n\\t\\t\\t return res;\\n\\t\\t }\\n\\t     \\n\\t\\t count = new int[10];\\n\\t\\t countAns(root);\\n\\t\\t return res;\\n\\t }\\n\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\t \\n\\t static int count[]; \\n     // count of the number of such paths\\n\\t static int res = 0;\\n\\t \\n\\t //Logic of checking whether palindorme possible or not\\n\\t private boolean isPossible() {\\n\\t\\t \\n\\t\\t // Check in the given path if more then 1 digit having ODD frequency then answer is not possible\\n\\t\\t int oddCount = 0;\\n\\t\\t \\n\\t\\t for(int i=0; i<10; i++) {\\n\\t\\t\\t \\n\\t\\t\\t if(count[i]%2 != 0) {\\n\\t\\t\\t\\t oddCount++;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t \\n\\t\\t if(oddCount > 1) {\\n\\t\\t\\t return false;\\n\\t\\t }\\n\\t\\t \\n\\t\\t return true;\\n\\t }\\n\\t \\n\\t \\n\\t private void countAns(TreeNode root) {\\n\\t\\t \\n\\t\\t if(root == null) {\\n\\t\\t\\t return;\\n\\t\\t }\\n\\t\\t \\n\\t\\t //When root check whether it forms the solution or not\\n\\t\\t if(root.left == null && root.right == null) {\\n\\t\\t\\t \\n\\t\\t\\t count[root.val]++;\\n\\t\\t\\t \\n\\t\\t\\t //if valid solution then increment the answer\\n\\t\\t\\t if(isPossible()) {\\n\\t\\t\\t\\t res++;\\n\\t\\t\\t }\\n\\t\\t\\t count[root.val]--;\\n\\t\\t\\t return;\\n\\t\\t }\\n\\t\\t \\n\\t\\t //incrementing the digit at particular node\\n\\t\\t count[root.val]++;\\n\\t\\t countAns(root.left);\\n\\t\\t countAns(root.right);\\n\\t\\t //decrementing once visit is finished\\n\\t\\t count[root.val]--;\\n\\t }\\n\\t \\n\\t public int pseudoPalindromicPaths (TreeNode root) {\\n\\t\\t \\n\\t\\t res = 0;\\n\\t\\t\\n\\t\\t if(root == null) {\\n\\t\\t\\t return res;\\n\\t\\t }\\n\\t     \\n\\t\\t count = new int[10];\\n\\t\\t countAns(root);\\n\\t\\t return res;\\n\\t }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878828,
                "title": "rarest-solution-you-ve-never-seen-self-explanatory-comments-time-beats-99",
                "content": "\\uD83D\\uDE0A \\uD835\\uDE4E\\uD835\\uDE5A\\uD835\\uDE61\\uD835\\uDE5B \\uD835\\uDE3E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE56\\uD835\\uDE69\\uD835\\uDE5A\\uD835\\uDE59 \\uD835\\uDE47\\uD835\\uDE64\\uD835\\uDE5C\\uD835\\uDE5E\\uD835\\uDE58 ~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHey There! It\\'s Easy Just Take A Look At The Code And Comments Within It! You\\'ll Get It.\\nStill Got Doubts! Feel Free To Comment, I Will Definitely Reply!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur Easy DFS !\\n\\nHey Everyone! The More Concise & Efficient Solution For This Problem Is By Using The \"Bit Manipulation\". So, Kindly Refer To It From The Internet.\\n\\n# Complexity\\n- Time complexity: O(N)\\nWhere N let be the total number of nodes of the tree.\\n\\n- Space complexity: O(H)\\nWhere H let be the height of the tree corresponds to the maximum depth used in implicit stack space while recursion.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count; vector<int> digits;\\n \\n    // Initialize the class members\\n    Solution() : digits(vector<int>(10, 0)), count(0) {};\\n    \\n    // Method helper\\n    bool checkForPalindromic(void) {\\n        // Require to store the number of digits occuring odd times\\n        int oddTimes = 0;\\n\\n        for(int i=0; i<10; i++) {\\n            // If current digit is occuring odd times\\n            if(digits[i] % 2)\\n                oddTimes++;\\n\\n            // If its is greater than 1 than the palindromic path does not exist\\n            if(oddTimes > 1)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    // Method to find the number of pseudo-palindromic paths going from the root node to leaf nodes - O(N) & O(H)\\n    int pseudoPalindromicPaths(TreeNode* root) {\\n        // Edge case: When the tree is empty\\n        if(!root)\\n            return 0;\\n\\n        // Increment the frequency of the node value as we are reaching the path\\n        digits[root->val]++;\\n\\n         // If current is the leaf node and the pseudo-palindromic path exist\\n        if(!root->left && !root->right && checkForPalindromic())\\n            count++;\\n\\n        // Recursively find for the pseudo-palindromic paths in both the subtrees\\n        pseudoPalindromicPaths(root->left);\\n        pseudoPalindromicPaths(root->right);\\n\\n        // Decrement the frequency of the node value as we are leaving the path\\n        digits[root->val]--;\\n\\n        return count;\\n    }\\n};\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count; vector<int> digits;\\n \\n    // Initialize the class members\\n    Solution() : digits(vector<int>(10, 0)), count(0) {};\\n    \\n    // Method helper\\n    bool checkForPalindromic(void) {\\n        // Require to store the number of digits occuring odd times\\n        int oddTimes = 0;\\n\\n        for(int i=0; i<10; i++) {\\n            // If current digit is occuring odd times\\n            if(digits[i] % 2)\\n                oddTimes++;\\n\\n            // If its is greater than 1 than the palindromic path does not exist\\n            if(oddTimes > 1)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    // Method to find the number of pseudo-palindromic paths going from the root node to leaf nodes - O(N) & O(H)\\n    int pseudoPalindromicPaths(TreeNode* root) {\\n        // Edge case: When the tree is empty\\n        if(!root)\\n            return 0;\\n\\n        // Increment the frequency of the node value as we are reaching the path\\n        digits[root->val]++;\\n\\n         // If current is the leaf node and the pseudo-palindromic path exist\\n        if(!root->left && !root->right && checkForPalindromic())\\n            count++;\\n\\n        // Recursively find for the pseudo-palindromic paths in both the subtrees\\n        pseudoPalindromicPaths(root->left);\\n        pseudoPalindromicPaths(root->right);\\n\\n        // Decrement the frequency of the node value as we are leaving the path\\n        digits[root->val]--;\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858486,
                "title": "c-easy-dfs-traversal-checking-the-condition-at-leaf-node",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe main logic of this problem is that for a pseudo-palindromic path\\nthe path must contain **atmost one odd occurence of an element**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will be doing normal dfs and at the same time we\\'ll store the frequency of the elements in a map. At the leaf node we\\'ll just check the condition for pseudo-palindromic path and increment our answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n) --> n is the no of nodes in tree\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(k) --> k is the no of distinct elements in path from root node  to deepest leaf node. \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int ans=0;\\n    unordered_map<int,int> mp;\\n    void fun(TreeNode* root){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            int flag=0;\\n            int cnt=0;\\n            mp[root->val]++;\\n            for(auto it:mp){\\n                if(it.second%2==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt<=1){\\n                ans++;\\n            }\\n            mp[root->val]--;\\n            return;\\n            // return 0;\\n        }\\n        mp[root->val]++;\\n        fun(root->left);\\n        fun(root->right);\\n        mp[root->val]--;\\n    }\\n\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        fun(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int ans=0;\\n    unordered_map<int,int> mp;\\n    void fun(TreeNode* root){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            int flag=0;\\n            int cnt=0;\\n            mp[root->val]++;\\n            for(auto it:mp){\\n                if(it.second%2==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt<=1){\\n                ans++;\\n            }\\n            mp[root->val]--;\\n            return;\\n            // return 0;\\n        }\\n        mp[root->val]++;\\n        fun(root->left);\\n        fun(root->right);\\n        mp[root->val]--;\\n    }\\n\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        fun(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196579,
                "title": "java-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static Map<Integer,Integer> map;\\n    static int count=0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        map=new HashMap<>();\\n        count=0;\\n        dfs(root);\\n        return count;\\n    }\\n    public void dfs(TreeNode root)\\n    {\\n        if(root==null)return;\\n        map.put(root.val,map.getOrDefault(root.val,0)+1);\\n        if(root.left==null&&root.right==null)\\n        {\\n        int c=0;\\n        for(int i:map.keySet())\\n            if(map.get(i)%2 !=0 ) c++;\\n        if(c<=1)count++;\\n        map.put(root.val,map.get(root.val)-1);\\n        return ;\\n        }\\n        dfs(root.left);\\n        dfs(root.right);\\n        map.put(root.val,map.get(root.val)-1);\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static Map<Integer,Integer> map;\\n    static int count=0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        map=new HashMap<>();\\n        count=0;\\n        dfs(root);\\n        return count;\\n    }\\n    public void dfs(TreeNode root)\\n    {\\n        if(root==null)return;\\n        map.put(root.val,map.getOrDefault(root.val,0)+1);\\n        if(root.left==null&&root.right==null)\\n        {\\n        int c=0;\\n        for(int i:map.keySet())\\n            if(map.get(i)%2 !=0 ) c++;\\n        if(c<=1)count++;\\n        map.put(root.val,map.get(root.val)-1);\\n        return ;\\n        }\\n        dfs(root.left);\\n        dfs(root.right);\\n        map.put(root.val,map.get(root.val)-1);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675236,
                "title": "c-check-only-at-most-one-occurrence-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    \\n    void dfs(TreeNode* root , vector<int> &ans , int &count){\\n        \\n        if(!root) return ;\\n        \\n        ans[root->val]++;\\n        \\n        dfs(root->left , ans , count);\\n        dfs(root->right , ans , count);\\n        \\n        if(!root->left && !root->right){\\n            int element_cnt  = 0;\\n            \\n            for(int i=0 ;i<10 ;i++){\\n                if(ans[i]%2!=0) element_cnt++;\\n            }\\n            \\n            if(element_cnt == 1 || element_cnt == 0) count++; \\n            \\n        }\\n        \\n        ans[root->val]--;\\n        \\n        \\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> ans(10 , 0);\\n        int count = 0;\\n        \\n        dfs(root , ans , count);\\n        \\n        return count;\\n    }\\n};\\n\\n\\n# upvote",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(TreeNode* root , vector<int> &ans , int &count){\\n        \\n        if(!root) return ;\\n        \\n        ans[root->val]++;\\n        \\n        dfs(root->left , ans , count);\\n        dfs(root->right , ans , count);\\n        \\n        if(!root->left && !root->right){\\n            int element_cnt  = 0;\\n            \\n            for(int i=0 ;i<10 ;i++){\\n                if(ans[i]%2!=0) element_cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2658841,
                "title": "very-easy-to-understand",
                "content": "```\\nIntuition:\\nSince we need to return the number of pseudo-palindromic paths going from the root node to leaf nodes, so we know that seeing tree problems, first thing that should hit our brain is? what is it? Yessss its Recursion.\\n\\nApproach:\\n\\nSo first, recursively iterate all paths from root to leaves, and count the occurrence of each digits in an integer (count=0, initiallly).\\nWill be using count as a bit mask.\\nWhenever we meet an element, we just toggle the corresponding bit using ^(XOR) operation.\\nAt the leaf node, we check if the count has only one bit that is 1, we use lowbit to count this.\\nBasically this thing :- (count & (count - 1)) == 0)\\n```\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans;  //this will keep the count of the pusedo palindromic path\\nint pseudoPalindromicPaths (TreeNode* root) \\n{\\n\\tans=0;\\n    int count=0;\\n\\tfun(root,count);\\n\\treturn ans;        \\n}\\nvoid fun(TreeNode* root,int count)\\n{\\n\\tif(root==NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\tif(root!=NULL and root->left==NULL and root->right==NULL)\\n\\t{\\n\\t\\tint temp=count;\\n\\t\\ttemp=temp^(1<<root->val);\\n\\t\\t\\n\\t\\tif(temp==0)   //even length pasudeo palindromic paht as the value of temp is 0 indicated the bit set in temp is 0\\n\\t\\t{\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\telse if(temp>0)   //could be odd length psudeo palindromic path as the value of temp is more than zero we cannot anythig about no of set bit\\n\\t\\t{\\n\\t\\t\\ttemp = temp - (temp & (-temp));\\n\\t\\t\\tif(temp==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfun(root->left,count^(1<<root->val));\\n\\tfun(root->right,count^(1<<root->val));\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nIntuition:\\nSince we need to return the number of pseudo-palindromic paths going from the root node to leaf nodes, so we know that seeing tree problems, first thing that should hit our brain is? what is it? Yessss its Recursion.\\n\\nApproach:\\n\\nSo first, recursively iterate all paths from root to leaves, and count the occurrence of each digits in an integer (count=0, initiallly).\\nWill be using count as a bit mask.\\nWhenever we meet an element, we just toggle the corresponding bit using ^(XOR) operation.\\nAt the leaf node, we check if the count has only one bit that is 1, we use lowbit to count this.\\nBasically this thing :- (count & (count - 1)) == 0)\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans;  //this will keep the count of the pusedo palindromic path\\nint pseudoPalindromicPaths (TreeNode* root) \\n{\\n\\tans=0;\\n    int count=0;\\n\\tfun(root,count);\\n\\treturn ans;        \\n}\\nvoid fun(TreeNode* root,int count)\\n{\\n\\tif(root==NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\tif(root!=NULL and root->left==NULL and root->right==NULL)\\n\\t{\\n\\t\\tint temp=count;\\n\\t\\ttemp=temp^(1<<root->val);\\n\\t\\t\\n\\t\\tif(temp==0)   //even length pasudeo palindromic paht as the value of temp is 0 indicated the bit set in temp is 0\\n\\t\\t{\\n\\t\\t\\tans++;\\n\\t\\t}\\n\\t\\telse if(temp>0)   //could be odd length psudeo palindromic path as the value of temp is more than zero we cannot anythig about no of set bit\\n\\t\\t{\\n\\t\\t\\ttemp = temp - (temp & (-temp));\\n\\t\\t\\tif(temp==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfun(root->left,count^(1<<root->val));\\n\\tfun(root->right,count^(1<<root->val));\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589961,
                "title": "preorder-traversal-with-bit-manipulation-c-solution",
                "content": "```\\nclass Solution {\\n    int count = 0;\\npublic:\\n    void dfs(TreeNode *node, int path){\\n        if(node){\\n            path ^= (1 << (node->val - 1));\\n            if(!node->left && !node->right) count += !(path & (path - 1)) ? 1 : 0;\\n            dfs(node->left, path);\\n            dfs(node->right, path);\\n        }\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root, 0);\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    int count = 0;\\npublic:\\n    void dfs(TreeNode *node, int path){\\n        if(node){\\n            path ^= (1 << (node->val - 1));\\n            if(!node->left && !node->right) count += !(path & (path - 1)) ? 1 : 0;\\n            dfs(node->left, path);\\n            dfs(node->right, path);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2583842,
                "title": "c-very-simple-solution",
                "content": "```\\nclass Solution {\\n  public:\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n      vector<int> c(10);\\n      int ans = 0;\\n      helper(root, c, ans);\\n      return ans;\\n    }\\n\\n    void helper(TreeNode* root, vector<int>& c, int& ans) {\\n      if (!root)\\n        return;\\n      c[root->val]++;\\n      if (!root->left && !root->right) {\\n        int odd = 0;\\n        for (int i = 1; i < c.size(); i++)\\n          odd += c[i] % 2;\\n        if (odd <= 1)\\n          ans++;\\n      }\\n      helper(root->left, c, ans);\\n      helper(root->right, c, ans);\\n      c[root->val]--;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public:\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n      vector<int> c(10);\\n      int ans = 0;\\n      helper(root, c, ans);\\n      return ans;\\n    }\\n\\n    void helper(TreeNode* root, vector<int>& c, int& ans) {\\n      if (!root)\\n        return;\\n      c[root->val]++;\\n      if (!root->left && !root->right) {\\n        int odd = 0;\\n        for (int i = 1; i < c.size(); i++)\\n          odd += c[i] % 2;\\n        if (odd <= 1)\\n          ans++;\\n      }\\n      helper(root->left, c, ans);\\n      helper(root->right, c, ans);\\n      c[root->val]--;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579389,
                "title": "c-easy-to-understand-recursion-backtracking",
                "content": "**Code**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int counter = 0;\\n    bool checkPalindrome(vector<int> &v){\\n        int odd = 0;\\n        for(int i = 0; i < 10; ++i){\\n            if(v[i] & 1){\\n                ++odd;\\n            }\\n        }\\n        \\n        return (odd < 2);\\n    }\\n    void solve(TreeNode* root, vector<int> &v){\\n        if(root == nullptr){\\n            return;\\n        }\\n        \\n        // cout << root->val << endl;\\n        ++v[root->val];\\n        if(root->left || root->right){\\n            solve(root->left, v);\\n            solve(root->right, v);\\n        } else{\\n            if(checkPalindrome(v)){\\n                ++counter;\\n            }    \\n        }\\n        --v[root->val];\\n        \\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        if(root == nullptr){\\n            return 0;\\n        }\\n        \\n        vector<int> v(10, 0);\\n        solve(root, v);    \\n        \\n        // for(auto x: v){\\n        //     cout << x << \" \";\\n        // }\\n        return counter;\\n    }\\n};\\n```\\n**Output**\\n```\\nRuntime: 676 ms, faster than 38.70% of C++ online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\nMemory Usage: 179.5 MB, less than 87.54% of C++ online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int counter = 0;\\n    bool checkPalindrome(vector<int> &v){\\n        int odd = 0;\\n        for(int i = 0; i < 10; ++i){\\n            if(v[i] & 1){\\n                ++odd;\\n            }\\n        }\\n        \\n        return (odd < 2);\\n    }\\n    void solve(TreeNode* root, vector<int> &v){\\n        if(root == nullptr){\\n            return;\\n        }\\n        \\n        // cout << root->val << endl;\\n        ++v[root->val];\\n        if(root->left || root->right){\\n            solve(root->left, v);\\n            solve(root->right, v);\\n        } else{\\n            if(checkPalindrome(v)){\\n                ++counter;\\n            }    \\n        }\\n        --v[root->val];\\n        \\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        if(root == nullptr){\\n            return 0;\\n        }\\n        \\n        vector<int> v(10, 0);\\n        solve(root, v);    \\n        \\n        // for(auto x: v){\\n        //     cout << x << \" \";\\n        // }\\n        return counter;\\n    }\\n};\\n```\n```\\nRuntime: 676 ms, faster than 38.70% of C++ online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\nMemory Usage: 179.5 MB, less than 87.54% of C++ online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2577567,
                "title": "simple-c",
                "content": "\\tvoid solve(TreeNode* root, int &count, int arr[],int countOne){\\n\\t\\tif(!root) return;\\n\\n\\t\\tint tmp = arr[root->val];\\n\\t\\tif(arr[root->val] == 1){\\n\\t\\t\\tarr[root->val] = 0;\\n\\t\\t\\tcountOne--;\\n\\t\\t}else if(arr[root->val] == 0){\\n\\t\\t\\tarr[root->val] = 1;\\n\\t\\t\\tcountOne++;      \\n\\t\\t}\\n\\t\\tint secondTmp = arr[root->val];\\n\\t\\tif(!root->left && !root->right){\\n\\t\\t\\tarr[root->val] = tmp;\\n\\t\\t\\tif(countOne <=1){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} \\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsolve(root->left, count, arr, countOne);\\n\\t\\t// reset\\n\\t\\tarr[root->val]=secondTmp;\\n\\t\\tsolve(root->right, count, arr, countOne);\\n\\t\\tarr[root->val] = tmp;\\n\\t} \\n\\tint pseudoPalindromicPaths (TreeNode* root) {\\n\\t\\tint arr[10]{0};\\n\\t\\tint count = 0;\\n\\t\\tsolve(root, count, arr, 0);\\n\\t\\treturn count;\\n\\t}\\n\\t![image](https://assets.leetcode.com/users/images/7e3f7a5c-7228-457a-acee-a9bacfb52897_1663212393.731741.png)\\n",
                "solutionTags": [],
                "code": "\\tvoid solve(TreeNode* root, int &count, int arr[],int countOne){\\n\\t\\tif(!root) return;\\n\\n\\t\\tint tmp = arr[root->val];\\n\\t\\tif(arr[root->val] == 1){\\n\\t\\t\\tarr[root->val] = 0;\\n\\t\\t\\tcountOne--;\\n\\t\\t}else if(arr[root->val] == 0){\\n\\t\\t\\tarr[root->val] = 1;\\n\\t\\t\\tcountOne++;      \\n\\t\\t}\\n\\t\\tint secondTmp = arr[root->val];\\n\\t\\tif(!root->left && !root->right){\\n\\t\\t\\tarr[root->val] = tmp;\\n\\t\\t\\tif(countOne <=1){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} \\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tsolve(root->left, count, arr, countOne);\\n\\t\\t// reset\\n\\t\\tarr[root->val]=secondTmp;\\n\\t\\tsolve(root->right, count, arr, countOne);\\n\\t\\tarr[root->val] = tmp;\\n\\t} \\n\\tint pseudoPalindromicPaths (TreeNode* root) {\\n\\t\\tint arr[10]{0};\\n\\t\\tint count = 0;\\n\\t\\tsolve(root, count, arr, 0);\\n\\t\\treturn count;\\n\\t}\\n\\t![image](https://assets.leetcode.com/users/images/7e3f7a5c-7228-457a-acee-a9bacfb52897_1663212393.731741.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2577198,
                "title": "python-stack-and-dfs-solutions-96-98",
                "content": "## dfs is recursion so this algorithm needs to run function on each step and use memory to its parameters:\\n```py\\nclass Solution:\\n  def pseudoPalindromicPaths (self, root: Optional[TreeNode], path: int = 0) -> int:\\n    if not root: return 0\\n    path ^= 1 << root.val\\n    if not (root.left or root.right): return 1 if 0 == path & (path - 1) else 0\\n    return self.pseudoPalindromicPaths(root.left, path) + self.pseudoPalindromicPaths(root.right, path)\\n```\\n\\n## Stack is more quickly:\\n#### Runtime: 851 ms, faster than 96.35% of Python3 online submissions.\\n#### Memory Usage: 50.3 MB, less than 98.48% of Python3 online submissions.\\n```py\\nclass Solution:\\n  def pseudoPalindromicPaths(self, root: TreeNode, count = 0) -> int:\\n    stack = [(root, 0)]\\n    while stack:\\n      node, path = stack.pop()\\n      path ^= 1 << node.val\\n      if node.left == node.right and path & (path - 1) == 0: # left == right only if both is None\\n\\t   # path & (path - 1) explanation:\\n       # if only one node hasn\\'t couple i.e. 3: \"1 << 3\", 0b1000 & 0b0111 == 0\\n\\t   # if every node has couple their path sum == 0, so 0b0000 & any == 0\\n        count += 1 \\n      else:\\n        if node.left: stack.append((node.left, path))\\n        if node.right: stack.append((node.right, path))\\n\\n    return count\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass Solution:\\n  def pseudoPalindromicPaths (self, root: Optional[TreeNode], path: int = 0) -> int:\\n    if not root: return 0\\n    path ^= 1 << root.val\\n    if not (root.left or root.right): return 1 if 0 == path & (path - 1) else 0\\n    return self.pseudoPalindromicPaths(root.left, path) + self.pseudoPalindromicPaths(root.right, path)\\n```\n```py\\nclass Solution:\\n  def pseudoPalindromicPaths(self, root: TreeNode, count = 0) -> int:\\n    stack = [(root, 0)]\\n    while stack:\\n      node, path = stack.pop()\\n      path ^= 1 << node.val\\n      if node.left == node.right and path & (path - 1) == 0: # left == right only if both is None\\n\\t   # path & (path - 1) explanation:\\n       # if only one node hasn\\'t couple i.e. 3: \"1 << 3\", 0b1000 & 0b0111 == 0\\n\\t   # if every node has couple their path sum == 0, so 0b0000 & any == 0\\n        count += 1 \\n      else:\\n        if node.left: stack.append((node.left, path))\\n        if node.right: stack.append((node.right, path))\\n\\n    return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576977,
                "title": "help-required-in-identifying-the-error",
                "content": "This code seems fine to me but is producing the is producing an TLE if subbmitted . Also if problematic test case is ran a input its accepted for that very  case. \\n\\n#### Please help me find a possible answer to this behavior its bothering me alot. \\n```\\nclass Solution {\\npublic:\\n    void allLeafs(TreeNode* root,map<int,int>mp,int c,int &ret){\\n        if(!root) return ;\\n        mp[root->val]++;\\n        if(mp[root->val]%2==1)\\n        {\\n            c++;\\n        }\\n        else\\n        {\\n            c--;\\n        }\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            if(c<=1)\\n            {\\n                ret+=1;\\n            }\\n            return;\\n        }\\n        \\n            allLeafs(root->left,mp,c,ret);\\n        \\n            allLeafs(root->right,mp,c,ret);\\n        mp[root->val]--;\\n        \\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        int ret=0;\\n        map<int,int>mp;\\n        allLeafs(root,mp,0,ret);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void allLeafs(TreeNode* root,map<int,int>mp,int c,int &ret){\\n        if(!root) return ;\\n        mp[root->val]++;\\n        if(mp[root->val]%2==1)\\n        {\\n            c++;\\n        }\\n        else\\n        {\\n            c--;\\n        }\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            if(c<=1)\\n            {\\n                ret+=1;\\n            }\\n            return;\\n        }\\n        \\n            allLeafs(root->left,mp,c,ret);\\n        \\n            allLeafs(root->right,mp,c,ret);\\n        mp[root->val]--;\\n        \\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        int ret=0;\\n        map<int,int>mp;\\n        allLeafs(root,mp,0,ret);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576818,
                "title": "java-solution-using-set",
                "content": "Pseudo Palindrome number can be checked by checking if there exist frequency of each number to be even or 1 odd frequency number which can be placed in the middle.\\n\\n```\\nclass Solution \\n{\\n    int ans=0;\\n    public int pseudoPalindromicPaths (TreeNode root) \\n    {\\n        Set<Integer> list = new HashSet<>();\\n        solve(root,list);\\n        return ans;\\n    }\\n    void solve(TreeNode root , Set<Integer> set)\\n    {\\n        if(root == null)\\n            return;\\n        \\n        if(set.contains(root.val))\\n            set.remove(root.val);       //for even frequency\\n        else\\n            set.add(root.val);\\n        \\n        if(root.left == null && root.right == null)\\n        {\\n            if(set.size() == 1 || set.isEmpty())\\n                ans++;\\n        }\\n        \\n        solve(root.left,set);\\n        solve(root.right,set);\\n        \\n        if(set.contains(root.val))  //in case of backtracking adding that element again.\\n            set.remove(root.val);\\n        else\\n            set.add(root.val);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    int ans=0;\\n    public int pseudoPalindromicPaths (TreeNode root) \\n    {\\n        Set<Integer> list = new HashSet<>();\\n        solve(root,list);\\n        return ans;\\n    }\\n    void solve(TreeNode root , Set<Integer> set)\\n    {\\n        if(root == null)\\n            return;\\n        \\n        if(set.contains(root.val))\\n            set.remove(root.val);       //for even frequency\\n        else\\n            set.add(root.val);\\n        \\n        if(root.left == null && root.right == null)\\n        {\\n            if(set.size() == 1 || set.isEmpty())\\n                ans++;\\n        }\\n        \\n        solve(root.left,set);\\n        solve(root.right,set);\\n        \\n        if(set.contains(root.val))  //in case of backtracking adding that element again.\\n            set.remove(root.val);\\n        else\\n            set.add(root.val);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576779,
                "title": "1457-pseudo-palindromic-paths-in-a-binary-tree-c-accepted-solution-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isPalindrome(map<int,int>& mp){\\n        int odd=0;\\n        for(auto &it:mp){\\n            if(it.second%2!=0){\\n                odd++;\\n            }\\n        }\\n        \\n        if(odd==0 || odd==1)return true;\\n        return false;\\n    }\\n    \\n    void func(TreeNode* root,int& cnt,map<int,int>& mp){\\n        if(!root)return;\\n        \\n        mp[root->val]++;\\n        if(root->left){\\n            func(root->left,cnt,mp);\\n        }\\n        if(root->right){\\n            func(root->right,cnt,mp);\\n        }\\n        \\n        if(!root->left && !root->right){\\n            if(isPalindrome(mp)){\\n                cnt++;\\n            }\\n        }\\n        \\n        mp[root->val]--;\\n        \\n        return;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        map<int,int> mp;\\n        int cnt=0;\\n        func(root,cnt,mp);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isPalindrome(map<int,int>& mp){\\n        int odd=0;\\n        for(auto &it:mp){\\n            if(it.second%2!=0){\\n                odd++;\\n            }\\n        }\\n        \\n        if(odd==0 || odd==1)return true;\\n        return false;\\n    }\\n    \\n    void func(TreeNode* root,int& cnt,map<int,int>& mp){\\n        if(!root)return;\\n        \\n        mp[root->val]++;\\n        if(root->left){\\n            func(root->left,cnt,mp);\\n        }\\n        if(root->right){\\n            func(root->right,cnt,mp);\\n        }\\n        \\n        if(!root->left && !root->right){\\n            if(isPalindrome(mp)){\\n                cnt++;\\n            }\\n        }\\n        \\n        mp[root->val]--;\\n        \\n        return;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        map<int,int> mp;\\n        int cnt=0;\\n        func(root,cnt,mp);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576638,
                "title": "easy-c-recursive-solution-frequency-count",
                "content": "```\\nclass Solution {\\n    int count;\\npublic:\\n    void helper(TreeNode* root,vector<int> &freq){\\n        \\n        // a number can be palindromic if only 1 no. has odd occurances.\\n        // it means there exist a permutation which is palindromic\\n        \\n        // eg: 12521 .. 1->2, 2->2, 5->1 ..\\n        // but 124521 .. 1->2, 2->2, 4->1, 5->1 ... not a palindrome\\n        \\n        if(root==NULL)\\n            return;\\n        \\n        freq[root->val]++; // increment the freq of curr root\\n        \\n        helper(root->left,freq);\\n        helper(root->right,freq);\\n        \\n        if(root->left==NULL && root->right==NULL){\\n            \\n            int odd_count=0; // count for odd freqs\\n            \\n            for(int it=1;it<=9;it++)\\n            {\\n                if(freq[it]%2)\\n                    odd_count++;\\n            }\\n            \\n            if(odd_count<=1) //if odd freq are 0 or 1. then increase the total count\\n                count++;\\n        }\\n        \\n        freq[root->val]--; // backtracking step for reducing the freq of current root node\\n        \\n    }\\n    int pseudoPalindromicPaths (TreeNode* root){\\n        \\n        if(root==NULL)\\n            return 0;\\n        \\n        vector<int> freq(10,0); // since root node values are only from [1,9]\\n                        \\n        helper(root,freq);\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    int count;\\npublic:\\n    void helper(TreeNode* root,vector<int> &freq){\\n        \\n        // a number can be palindromic if only 1 no. has odd occurances.\\n        // it means there exist a permutation which is palindromic\\n        \\n        // eg: 12521 .. 1->2, 2->2, 5->1 ..\\n        // but 124521 .. 1->2, 2->2, 4->1, 5->1 ... not a palindrome\\n        \\n        if(root==NULL)\\n            return;\\n        \\n        freq[root->val]++; // increment the freq of curr root\\n        \\n        helper(root->left,freq);\\n        helper(root->right,freq);\\n        \\n        if(root->left==NULL && root->right==NULL){\\n            \\n            int odd_count=0; // count for odd freqs\\n            \\n            for(int it=1;it<=9;it++)\\n            {\\n                if(freq[it]%2)\\n                    odd_count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2576614,
                "title": "golang-dfs-backtracking-simple-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc pseudoPalindromicPaths (root *TreeNode) int {\\n    return dfs(root, make(map[int]bool, 0))\\n}\\n\\nfunc dfs(root *TreeNode, mem map[int]bool) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    mem[root.Val] = !mem[root.Val]\\n    if root.Left == nil && root.Right == nil {\\n        count := 0\\n        for _, v := range mem {\\n            if v {\\n                count += 1\\n            }\\n        }\\n        \\n        mem[root.Val] = !mem[root.Val]\\n        \\n        if count <= 1 {\\n            return 1\\n        }\\n        \\n        return 0\\n    }\\n    \\n    total := dfs(root.Left, mem) + dfs(root.Right, mem)\\n    mem[root.Val] = !mem[root.Val]\\n    \\n    return total\\n}",
                "solutionTags": [
                    "Go",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc pseudoPalindromicPaths (root *TreeNode) int {\\n    return dfs(root, make(map[int]bool, 0))\\n}\\n\\nfunc dfs(root *TreeNode, mem map[int]bool) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    mem[root.Val] = !mem[root.Val]\\n    if root.Left == nil && root.Right == nil {\\n        count := 0\\n        for _, v := range mem {\\n            if v {\\n                count += 1\\n            }\\n        }\\n        \\n        mem[root.Val] = !mem[root.Val]\\n        \\n        if count <= 1 {\\n            return 1\\n        }\\n        \\n        return 0\\n    }\\n    \\n    total := dfs(root.Left, mem) + dfs(root.Right, mem)\\n    mem[root.Val] = !mem[root.Val]\\n    \\n    return total\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2576521,
                "title": "hashing-based-simple-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool ispalindrome(unordered_map<int,int>&m)\\n    {\\n        int flag=1;\\n        for(auto it:m)\\n        {\\n            if(it.second%2==1 and flag==0)\\n                return false;\\n            if(it.second%2==1)\\n            {\\n                flag=0;\\n            }   \\n        }\\n        return true;\\n    }\\n    void rundfs(TreeNode*root,unordered_map<int,int>&m,int &count)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(root->left==NULL and root->right==NULL)\\n        {\\n            m[root->val]++;\\n            if(ispalindrome(m))\\n            {\\n                m[root->val]--;\\n                count++;\\n                return;\\n            }\\n            else{\\n                m[root->val]--;\\n                return;\\n            }\\n        }\\n        m[root->val]++;\\n        if(root->left)\\n        {\\n            rundfs(root->left,m,count);\\n        }\\n        if(root->right)\\n        {\\n            rundfs(root->right,m,count);\\n        }\\n        m[root->val]--;\\n        return;\\n    \\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        unordered_map<int,int>m;\\n        int count=0;\\n        rundfs(root,m,count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool ispalindrome(unordered_map<int,int>&m)\\n    {\\n        int flag=1;\\n        for(auto it:m)\\n        {\\n            if(it.second%2==1 and flag==0)\\n                return false;\\n            if(it.second%2==1)\\n            {\\n                flag=0;\\n            }   \\n        }\\n        return true;\\n    }\\n    void rundfs(TreeNode*root,unordered_map<int,int>&m,int &count)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(root->left==NULL and root->right==NULL)\\n        {\\n            m[root->val]++;\\n            if(ispalindrome(m))\\n            {\\n                m[root->val]--;\\n                count++;\\n                return;\\n            }\\n            else{\\n                m[root->val]--;\\n                return;\\n            }\\n        }\\n        m[root->val]++;\\n        if(root->left)\\n        {\\n            rundfs(root->left,m,count);\\n        }\\n        if(root->right)\\n        {\\n            rundfs(root->right,m,count);\\n        }\\n        m[root->val]--;\\n        return;\\n    \\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        unordered_map<int,int>m;\\n        int count=0;\\n        rundfs(root,m,count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576449,
                "title": "ruby-backtracking-for-palindrome-only-one-type-could-be-odd-or-no-odd-at-all",
                "content": "## Leetcode: 1457. Pseudo-Palindromic Paths in a Binary Tree.\\n\\n**Ruby: Backtracking, for palindrome only one type could be odd or no odd at all.**\\n\\nKey to this task is a careful reading last line of the description. In general in palindrome could be only one type of sybols could be represened in an odd amount. Or there no odd at all.\\n\\nThe solution is DFS Backtracking, filling Counter datastructure with values, and check there is only one or no at all odd amounts in the Counter in the Leafs.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1457. Pseudo-Palindromic Paths in a Binary Tree.\\n# https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 1534 ms, faster than 100.00% of Ruby online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\n# Memory Usage: 229.7 MB, less than 100.00% of Ruby online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\n#\\n# Definition for a binary tree node.\\n# class TreeNode\\n#     attr_accessor :val, :left, :right\\n#     def initialize(val = 0, left = nil, right = nil)\\n#         @val = val\\n#         @left = left\\n#         @right = right\\n#     end\\n# end\\n# @param {TreeNode} root\\n# @return {Integer}\\ndef pseudo_palindromic_paths (root)\\n  @answer = 0\\n  @counter = Array.new(10,0)\\n  backtracking(root)\\n  return @answer\\nend\\n\\ndef backtracking(node)\\n  @counter[node.val] += 1\\n  if node.left.nil? && node.right.nil?\\n    @answer += 1 if palindromic?\\n  else\\n    backtracking(node.left) if node.left\\n    backtracking(node.right) if node.right\\n  end\\n  @counter[node.val] -= 1\\nend\\n\\ndef palindromic?\\n  even, odd = 0, 0\\n  @counter.each do |val|\\n    next if 0 == val\\n    if val.even?\\n      even += 1\\n    else\\n      odd += 1\\n    end\\n  end\\n  return odd <= 1\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```Ruby\\n# Leetcode: 1457. Pseudo-Palindromic Paths in a Binary Tree.\\n# https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 1534 ms, faster than 100.00% of Ruby online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\n# Memory Usage: 229.7 MB, less than 100.00% of Ruby online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\n#\\n# Definition for a binary tree node.\\n# class TreeNode\\n#     attr_accessor :val, :left, :right\\n#     def initialize(val = 0, left = nil, right = nil)\\n#         @val = val\\n#         @left = left\\n#         @right = right\\n#     end\\n# end\\n# @param {TreeNode} root\\n# @return {Integer}\\ndef pseudo_palindromic_paths (root)\\n  @answer = 0\\n  @counter = Array.new(10,0)\\n  backtracking(root)\\n  return @answer\\nend\\n\\ndef backtracking(node)\\n  @counter[node.val] += 1\\n  if node.left.nil? && node.right.nil?\\n    @answer += 1 if palindromic?\\n  else\\n    backtracking(node.left) if node.left\\n    backtracking(node.right) if node.right\\n  end\\n  @counter[node.val] -= 1\\nend\\n\\ndef palindromic?\\n  even, odd = 0, 0\\n  @counter.each do |val|\\n    next if 0 == val\\n    if val.even?\\n      even += 1\\n    else\\n      odd += 1\\n    end\\n  end\\n  return odd <= 1\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576402,
                "title": "c-easy-solution-unordered-map",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int cnt=0;\\n    bool check(unordered_map<int,int> &m) // for checking palindrome\\n    {\\n        long long cnt1=0;\\n        for(auto it:m)\\n            cnt1+=it.second; // for calculating no of occurences\\n        if(cnt1%2==0) // if even length then all elements occurences must be even for satisying palindrome condition\\n        {\\n            for(auto it:m)\\n            {\\n                if(it.second%2==1)\\n                    return false;\\n            }\\n            return true;\\n        }\\n        else // for odd one occurence odd rest all even occurences for satisying palindrome condition\\n        {\\n            int c1=0;\\n            for(auto it:m)\\n            {\\n               if(it.second%2==1)\\n                   c1++;\\n            }\\n            if(c1==1)\\n            return true;\\n           return false; \\n        }\\n        return false;\\n    }\\n    void f(TreeNode* root,unordered_map<int,int> &s)\\n    {\\n        if(root==NULL)\\n            return;\\n        if(root->left==NULL and root->right==NULL)\\n        {\\n           s[root->val]++;\\n            if(check(s))\\n                cnt++;\\n            s[root->val]--;\\n            return;\\n        }\\n        s[root->val]++;\\n        f(root->left,s);\\n        f(root->right,s);\\n        s[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        unordered_map<int,int> s; // for checking frequency of elements\\n        int cnt1=0;\\n        f(root,s);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int cnt=0;\\n    bool check(unordered_map<int,int> &m) // for checking palindrome\\n    {\\n        long long cnt1=0;\\n        for(auto it:m)\\n            cnt1+=it.second; // for calculating no of occurences\\n        if(cnt1%2==0) // if even length then all elements occurences must be even for satisying palindrome condition\\n        {\\n            for(auto it:m)\\n            {\\n                if(it.second%2==1)\\n                    return false;\\n            }\\n            return true;\\n        }\\n        else // for odd one occurence odd rest all even occurences for satisying palindrome condition\\n        {\\n            int c1=0;\\n            for(auto it:m)\\n            {\\n               if(it.second%2==1)\\n                   c1++;\\n            }\\n            if(c1==1)\\n            return true;\\n           return false; \\n        }\\n        return false;\\n    }\\n    void f(TreeNode* root,unordered_map<int,int> &s)\\n    {\\n        if(root==NULL)\\n            return;\\n        if(root->left==NULL and root->right==NULL)\\n        {\\n           s[root->val]++;\\n            if(check(s))\\n                cnt++;\\n            s[root->val]--;\\n            return;\\n        }\\n        s[root->val]++;\\n        f(root->left,s);\\n        f(root->right,s);\\n        s[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        unordered_map<int,int> s; // for checking frequency of elements\\n        int cnt1=0;\\n        f(root,s);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576370,
                "title": "recursion-easy-to-understand-with-explanation",
                "content": "**Algo:-**\\n1. First we try to reach th leaf node  using recursion.\\n2. We use variable count to track the length of path and use vector to track the frequency of each node.\\n4. When we reach the leaf node we will find if the nodes in the path can be Palindrome :-\\n \\t * First  we check total number of node in path is even or odd if count is even the frequency of each node should                be even either one node frequency should be odd (size of path=n => even=n-1 && odd=1).\\n\\t * EG - path => 2,3,4,4,5   count=5(odd)\\n\\t * Frequency=>1,1,2,   1  (we can see frequency is odd for more than one element it means no combination of node                                                  can become palindrome)\\n\\t * EG 2  path => 2,5,7,5,7,2  count 6(even)\\n\\t *   Frequency=>2,2,2    (count is even and all the frequency is also even so combination of node can create                                                              palindrome)\\n\\t\\t\\n**Upvote if it helps :)**\\n\\n```\\npublic:\\n    vector<int> path={0,0,0,0,0,0,0,0,0,0};\\n    int count=0;\\n\\n    int pseudoPalindromicPaths (TreeNode* root) { \\n        if(!root)return 0;\\n        int ans=0;\\n        \\n        path[root->val]++;\\n        count++;\\n                \\n        if(!root->left && !root->right){\\n            int frq=count&1;\\n            for(int i=1;i<10;i++){\\n                if(path[i] && path[i]&1){\\n                    frq--;\\n                    if(frq<0)break;\\n                }\\n            }\\n            path[root->val]--;\\n            count--;\\n            \\n            return frq==0?1:0;\\n        }\\n\\n        ans=pseudoPalindromicPaths(root->left)+pseudoPalindromicPaths(root->right);\\n        \\n        path[root->val]--;\\n        count--;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\npublic:\\n    vector<int> path={0,0,0,0,0,0,0,0,0,0};\\n    int count=0;\\n\\n    int pseudoPalindromicPaths (TreeNode* root) { \\n        if(!root)return 0;\\n        int ans=0;\\n        \\n        path[root->val]++;\\n        count++;\\n                \\n        if(!root->left && !root->right){\\n            int frq=count&1;\\n            for(int i=1;i<10;i++){\\n                if(path[i] && path[i]&1){\\n                    frq--;\\n                    if(frq<0)break;\\n                }\\n            }\\n            path[root->val]--;\\n            count--;\\n            \\n            return frq==0?1:0;\\n        }\\n\\n        ans=pseudoPalindromicPaths(root->left)+pseudoPalindromicPaths(root->right);\\n        \\n        path[root->val]--;\\n        count--;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2576325,
                "title": "one-different-way-of-solving-a-clear-explained-thought",
                "content": "As we are given to check if path represents any permutation of palindromic sequence, we can just keep track of how many odd frequency elements are there.\\nAs we know in a palindromic sequence there will be atmost one odd palindromic number.\\nSo at every node of the tree we traverse, we check if that number is already repeated odd number of times or even number of times. This is done with the help of two boolean arrays, odd and even\\nEg: We want to add 5 to our path, if 5 is there then boolean values of odd[5-1] and even[5-1] will be false. So to speak in converse way,\\n* \\tif odd[k-1] and even[k-1] is false implies that this number is first time getting included in the path and after adding it odd[k-1] become true, i.e., k is repeated odd number of times (1 in this case)\\n* \\tif odd[k-1] true implies that k has already repeated odd number of times, and including k here makes that previous count to odd so we make odd[k-1] false and even[k-1] true;\\n* \\tif even[k-1] true implies even times occurance of element k till previous node, if we add k then it become odd number of times, so we make even[k-1] false and odd[k-1] true.\\n\\nFor every leaf nodes(nodes with both left and right pointers pointing to null) we check number of odd times repeated elements(for a sequence to become pseudo palindromic n(odd) should be atmost 1. We really dont bother about even frequencies.\\n\\n```\\nclass Solution {\\n    int ans=0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        //two boolean arrays for storing count\\n        boolean[] even = new boolean[9];\\n        boolean[] odd = new boolean[9];\\n        //Preorder traversal\\n        func(root,even,odd);\\n        return ans;\\n    }\\n    private void func(TreeNode root,boolean[] even,boolean[] odd){\\n        //Base case\\n        if(root==null){\\n            return;\\n        }\\n        //Main case\\n        //Clone boolean arrays\\n        boolean[] neweven = new boolean[9];\\n        boolean[] newodd = new boolean[9];\\n        for(int i=0;i<9;i++){\\n            neweven[i]=even[i];\\n            newodd[i]=odd[i];\\n        }\\n        //If this variable is not in the path\\n        if(!neweven[root.val-1]&&!newodd[root.val-1]){\\n            //Add this into odd place\\n            newodd[root.val-1]=true;\\n        }else if(!neweven[root.val-1]){\\n            neweven[root.val-1]=true;\\n            newodd[root.val-1]=false;\\n        }else if(!newodd[root.val-1]){\\n            neweven[root.val-1]=false;\\n            newodd[root.val-1]=true;\\n        }\\n        \\n        if(root.left==null&&root.right==null){\\n            //Leaf node case so update the answer\\n            int count=0;\\n            for(boolean b:newodd){\\n                if(b)count++;\\n            }\\n            if(count<=1)ans++;\\n            return;\\n        }\\n        \\n        //Calling for childs\\n        func(root.left,neweven,newodd);\\n        func(root.right,neweven,newodd);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        //two boolean arrays for storing count\\n        boolean[] even = new boolean[9];\\n        boolean[] odd = new boolean[9];\\n        //Preorder traversal\\n        func(root,even,odd);\\n        return ans;\\n    }\\n    private void func(TreeNode root,boolean[] even,boolean[] odd){\\n        //Base case\\n        if(root==null){\\n            return;\\n        }\\n        //Main case\\n        //Clone boolean arrays\\n        boolean[] neweven = new boolean[9];\\n        boolean[] newodd = new boolean[9];\\n        for(int i=0;i<9;i++){\\n            neweven[i]=even[i];\\n            newodd[i]=odd[i];\\n        }\\n        //If this variable is not in the path\\n        if(!neweven[root.val-1]&&!newodd[root.val-1]){\\n            //Add this into odd place\\n            newodd[root.val-1]=true;\\n        }else if(!neweven[root.val-1]){\\n            neweven[root.val-1]=true;\\n            newodd[root.val-1]=false;\\n        }else if(!newodd[root.val-1]){\\n            neweven[root.val-1]=false;\\n            newodd[root.val-1]=true;\\n        }\\n        \\n        if(root.left==null&&root.right==null){\\n            //Leaf node case so update the answer\\n            int count=0;\\n            for(boolean b:newodd){\\n                if(b)count++;\\n            }\\n            if(count<=1)ans++;\\n            return;\\n        }\\n        \\n        //Calling for childs\\n        func(root.left,neweven,newodd);\\n        func(root.right,neweven,newodd);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576218,
                "title": "java-dfs-with-set-solution",
                "content": "```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        if (root==null)return 0;\\n       return pseudoPalindromicPaths(root, new HashSet<>())/2;\\n    }\\n    \\n    public int pseudoPalindromicPaths(TreeNode root, Set<Integer> path){\\n        int res = 0;\\n        if (root==null){ \\n            if (path.size()<=1)res= 1; else res= 0;\\n        }\\n        else {\\n            if (path.contains(root.val)) path.remove(root.val); else path.add(root.val);\\n            res = ((root.left!=null || root.right==null) ? pseudoPalindromicPaths(root.left, path) : 0) + \\n\\t\\t\\t      ((root.left==null || root.right!=null) ? pseudoPalindromicPaths(root.right, path) : 0);\\n            if (path.contains(root.val)) path.remove(root.val); else path.add(root.val);\\n        }\\n     return res;  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        if (root==null)return 0;\\n       return pseudoPalindromicPaths(root, new HashSet<>())/2;\\n    }\\n    \\n    public int pseudoPalindromicPaths(TreeNode root, Set<Integer> path){\\n        int res = 0;\\n        if (root==null){ \\n            if (path.size()<=1)res= 1; else res= 0;\\n        }\\n        else {\\n            if (path.contains(root.val)) path.remove(root.val); else path.add(root.val);\\n            res = ((root.left!=null || root.right==null) ? pseudoPalindromicPaths(root.left, path) : 0) + \\n\\t\\t\\t      ((root.left==null || root.right!=null) ? pseudoPalindromicPaths(root.right, path) : 0);\\n            if (path.contains(root.val)) path.remove(root.val); else path.add(root.val);\\n        }\\n     return res;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576170,
                "title": "c-dfs-solution-counting-at-most-one-digit-in-path-is-odd",
                "content": "```\\n\\n    void solve(TreeNode* root,unordered_map<int,int>&mp,int &ans){\\n        if(root==NULL) return;\\n        \\n        mp[root->val]++;\\n        if(!root->left && !root->right){\\n            int c = 0;\\n            for(auto i: mp){\\n                if(i.second%2==1){\\n                    c++;\\n                }\\n            }\\n            if(c<=1){\\n                ans++;\\n            }\\n        }\\n        solve(root->left,mp,ans);\\n        solve(root->right,mp,ans);\\n       \\n        mp[root->val]--;\\n       return;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        unordered_map<int,int>mp;\\n        int ans=0;\\n        solve(root,mp,ans);\\n        \\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\n    void solve(TreeNode* root,unordered_map<int,int>&mp,int &ans){\\n        if(root==NULL) return;\\n        \\n        mp[root->val]++;\\n        if(!root->left && !root->right){\\n            int c = 0;\\n            for(auto i: mp){\\n                if(i.second%2==1){\\n                    c++;\\n                }\\n            }\\n            if(c<=1){\\n                ans++;\\n            }\\n        }\\n        solve(root->left,mp,ans);\\n        solve(root->right,mp,ans);\\n       \\n        mp[root->val]--;\\n       return;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        unordered_map<int,int>mp;\\n        int ans=0;\\n        solve(root,mp,ans);\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2576142,
                "title": "easy-to-understand-dfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void helper(TreeNode *root, vector<int> v)\\n    {\\n        if(root == NULL)\\n            return;\\n        v[root -> val]++;\\n        if(root -> left == NULL and root -> right == NULL)\\n        {\\n            int odd = 0;\\n            for(auto i: v)\\n            {\\n                if(i % 2 == 1)\\n                    odd++;\\n            }\\n            if(odd <= 1)\\n                count++;\\n            return;\\n        }\\n        helper(root -> left, v);\\n        helper(root -> right, v);\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> v(10, 0);\\n        helper(root, v);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void helper(TreeNode *root, vector<int> v)\\n    {\\n        if(root == NULL)\\n            return;\\n        v[root -> val]++;\\n        if(root -> left == NULL and root -> right == NULL)\\n        {\\n            int odd = 0;\\n            for(auto i: v)\\n            {\\n                if(i % 2 == 1)\\n                    odd++;\\n            }\\n            if(odd <= 1)\\n                count++;\\n            return;\\n        }\\n        helper(root -> left, v);\\n        helper(root -> right, v);\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> v(10, 0);\\n        helper(root, v);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576075,
                "title": "dfs-freq-array",
                "content": "```\\n\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] freq = new int[10];\\n        return dfs(root, freq);\\n    }\\n    \\n    private int dfs(TreeNode root, int[] freq) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        \\n        int countPallindrome = 0; \\n        freq[root.val]++;\\n        if(isLeafNode(root) && canFormPallindrome(freq)) {\\n            countPallindrome++;\\n        }\\n        \\n        countPallindrome += dfs(root.left, freq);\\n        countPallindrome += dfs(root.right, freq);\\n        freq[root.val]--;\\n        return countPallindrome;\\n    }\\n    \\n    private boolean canFormPallindrome(int[] freq) {\\n        int countOdd = 0;\\n        for(int num : freq) {\\n            if(num%2 != 0) {\\n                countOdd++;\\n            }\\n        }\\n        \\n        return countOdd > 1 ? false : true;\\n    }\\n    \\n    private boolean isLeafNode(TreeNode root) {\\n        return root.left == null && root.right == null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] freq = new int[10];\\n        return dfs(root, freq);\\n    }\\n    \\n    private int dfs(TreeNode root, int[] freq) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        \\n        int countPallindrome = 0; \\n        freq[root.val]++;\\n        if(isLeafNode(root) && canFormPallindrome(freq)) {\\n            countPallindrome++;\\n        }\\n        \\n        countPallindrome += dfs(root.left, freq);\\n        countPallindrome += dfs(root.right, freq);\\n        freq[root.val]--;\\n        return countPallindrome;\\n    }\\n    \\n    private boolean canFormPallindrome(int[] freq) {\\n        int countOdd = 0;\\n        for(int num : freq) {\\n            if(num%2 != 0) {\\n                countOdd++;\\n            }\\n        }\\n        \\n        return countOdd > 1 ? false : true;\\n    }\\n    \\n    private boolean isLeafNode(TreeNode root) {\\n        return root.left == null && root.right == null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575814,
                "title": "c-dfs-hash-map-super-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    int count=0;\\n    bool check(){ // this is to check palindrome*\\n        bool flag=true;\\n        for(auto x:mp){\\n            if(x.second%2!=0){\\n                if(!flag) return false;\\n                flag=false;\\n            } \\n        }\\n        return true;\\n    }\\n    void dfs(TreeNode* root){\\n        if(root==NULL) return; // base case\\n        mp[root->val]++;  // increasing frequency value of the current root value\\n        dfs(root->left);\\n        dfs(root->right);\\n        if(!root->left && !root->right && check()) count++; // leaf node + condition satisfied, so increase count\\n        mp[root->val]--; // decreasing frequency value of the current root value [backtracking step]\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root);\\n        return count;\\n    }\\n};\\n```\\n**How we are checking if there is any the palindrom sequence??**\\n=> for any palindrome sequence, there can be **at most one** digit, that has an odd frequency. So, if more than one digits found that have odd frequency,  return false.\\n\\n**If it helps, do an upvote!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    int count=0;\\n    bool check(){ // this is to check palindrome*\\n        bool flag=true;\\n        for(auto x:mp){\\n            if(x.second%2!=0){\\n                if(!flag) return false;\\n                flag=false;\\n            } \\n        }\\n        return true;\\n    }\\n    void dfs(TreeNode* root){\\n        if(root==NULL) return; // base case\\n        mp[root->val]++;  // increasing frequency value of the current root value\\n        dfs(root->left);\\n        dfs(root->right);\\n        if(!root->left && !root->right && check()) count++; // leaf node + condition satisfied, so increase count\\n        mp[root->val]--; // decreasing frequency value of the current root value [backtracking step]\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575689,
                "title": "concise-c",
                "content": "```\\nclass Solution {\\n    bool isPal(unordered_map<int, int> &m) {\\n        int oddfr = 0;\\n        for(auto i : m) {\\n            if(i.second % 2) oddfr++;\\n            if(oddfr > 1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(TreeNode* root, unordered_map<int, int> &m, int &ans) {\\n        if(!root) return;\\n        m[root -> val]++;\\n        if(!root -> left && !root -> right) if(isPal(m)) ans++;\\n        \\n        dfs(root -> left, m, ans);\\n        dfs(root -> right, m, ans);\\n        m[root -> val]--;\\n        if(!m[root -> val]) m.erase(root -> val);\\n    } \\n    \\npublic:\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        unordered_map<int, int> m;\\n        int ans = 0;\\n        dfs(root, m, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool isPal(unordered_map<int, int> &m) {\\n        int oddfr = 0;\\n        for(auto i : m) {\\n            if(i.second % 2) oddfr++;\\n            if(oddfr > 1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(TreeNode* root, unordered_map<int, int> &m, int &ans) {\\n        if(!root) return;\\n        m[root -> val]++;\\n        if(!root -> left && !root -> right) if(isPal(m)) ans++;\\n        \\n        dfs(root -> left, m, ans);\\n        dfs(root -> right, m, ans);\\n        m[root -> val]--;\\n        if(!m[root -> val]) m.erase(root -> val);\\n    } \\n    \\npublic:\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        unordered_map<int, int> m;\\n        int ans = 0;\\n        dfs(root, m, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575641,
                "title": "out-of-memory-and-sub-optimised-js-code-got-100-runtime",
                "content": "For approach **1**, I had started with finding all possible paths. Once I had all the paths stored in _superset_ variable, I was looping over them to find if any of the arrays(paths) were palindrome. To check if a path was palindrome, I was counting the frequency. If the size of array was even, I was confirming that there is no odd frequency and if the size was odd, I was confirming that at max one odd frequency was present. With this approach I got the `JavaScript heap out of memory` error. \\n\\nFor approach **2**, I refered [this link.](https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/discuss/2574040/Explained-from-memory-limit-exceeded-approach-to-optimal-or-notes-image) The gist for approach is, to maintain a small array and count the frequencies on the go, we compute if the path contains a palindrome when we no longer have a left or a right node.\\n\\nPlease upvote if helpful. \\n\\n### Approach 2: Sub-Optimised JS Code:\\n``` js\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar pseudoPalindromicPaths = function(root) {\\n    let count = 0\\n    var driver = function(r, freq) {\\n        if (!r) return\\n        freq[r.val] += 1\\n        if (r.right === null && r.left === null) {\\n            mismatch = 0;\\n            for (i = 0; i < 10; i++) {\\n                mismatch += (freq[i] % 2)\\n            }\\n            if (mismatch <= 1) {\\n                count++\\n            };\\n        } else {\\n            driver(r.left, freq)\\n            driver(r.right, freq)\\n        }\\n        freq[r.val] -= 1\\n    }\\n    let temp = []\\n    for (i = 0; i < 10; i++) {\\n        temp[i] = 0\\n    }\\n    driver(root, temp)\\n    return count\\n};\\n```\\n\\n### Approach 1: Out of heap error\\n``` js\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\n var pseudoPalindromicPaths = function(root) {\\n    let count = 0\\n    let superset = []\\n    var driver = function(r, level, temp) {\\n        if (!r) return\\n        temp[level] = r.val\\n        level += 1\\n        if (r.right === null && r.left === null) {\\n            superset.push(temp.slice(0)) // Copy by value and not reference!\\n            return\\n        } else {\\n            driver(r.right, level, temp.slice(0))\\n            driver(r.left, level, temp.slice(0))\\n        }\\n    }\\n    driver(root, 0, [])\\n    // Logic to check if any of the array is palindrome\\n    for (let i of superset) {\\n        freq = {}\\n        for (let j in i) {\\n            freq[i[j]] === undefined ? freq[i[j]] = 1 : freq[i[j]] += 1\\n        }\\n        if (i.length % 2 === 1) {\\n          if((Object.values(freq).filter(fr => fr % 2 === 1).length === 1)){\\n            count+=1\\n          }\\n        } else {\\n          if((Object.values(freq).filter(fr => fr % 2 === 1).length === 0)){\\n            count+=1\\n          }\\n        }\\n    }\\n    return count\\n};\\n```\\n\\n\\n>Runtime: 348 ms, faster than 100.00% of JavaScript online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\n>Memory Usage: 89.7 MB, less than 95.56% of JavaScript online submissions for Pseudo-Palindromic Paths in a Binary Tree.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` js\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar pseudoPalindromicPaths = function(root) {\\n    let count = 0\\n    var driver = function(r, freq) {\\n        if (!r) return\\n        freq[r.val] += 1\\n        if (r.right === null && r.left === null) {\\n            mismatch = 0;\\n            for (i = 0; i < 10; i++) {\\n                mismatch += (freq[i] % 2)\\n            }\\n            if (mismatch <= 1) {\\n                count++\\n            };\\n        } else {\\n            driver(r.left, freq)\\n            driver(r.right, freq)\\n        }\\n        freq[r.val] -= 1\\n    }\\n    let temp = []\\n    for (i = 0; i < 10; i++) {\\n        temp[i] = 0\\n    }\\n    driver(root, temp)\\n    return count\\n};\\n```\n``` js\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\n var pseudoPalindromicPaths = function(root) {\\n    let count = 0\\n    let superset = []\\n    var driver = function(r, level, temp) {\\n        if (!r) return\\n        temp[level] = r.val\\n        level += 1\\n        if (r.right === null && r.left === null) {\\n            superset.push(temp.slice(0)) // Copy by value and not reference!\\n            return\\n        } else {\\n            driver(r.right, level, temp.slice(0))\\n            driver(r.left, level, temp.slice(0))\\n        }\\n    }\\n    driver(root, 0, [])\\n    // Logic to check if any of the array is palindrome\\n    for (let i of superset) {\\n        freq = {}\\n        for (let j in i) {\\n            freq[i[j]] === undefined ? freq[i[j]] = 1 : freq[i[j]] += 1\\n        }\\n        if (i.length % 2 === 1) {\\n          if((Object.values(freq).filter(fr => fr % 2 === 1).length === 1)){\\n            count+=1\\n          }\\n        } else {\\n          if((Object.values(freq).filter(fr => fr % 2 === 1).length === 0)){\\n            count+=1\\n          }\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575519,
                "title": "easy-and-fast-c-solution-dfs-bit-manipoulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int pseudoPalindromicPaths (TreeNode* root, int bitVec = 0) {\\n\\t\\t//check if the current node exist\\n        if(!root)\\n            return 0;\\n        \\n\\t\\t//if the current node is a leaf, we count the 1 bits in the bit vector, if they are greater then one we return 0 due to the fact that the path is not pseudo palindrome\\n        if(!root->left&&!root->right){\\n            return __builtin_popcount(bitVec^(1<<root->val))<=1;\\n        }\\n        \\n\\t\\t//dfs\\n        return pseudoPalindromicPaths(root->left,bitVec^(1<<root->val))+pseudoPalindromicPaths(root->right,bitVec^(1<<root->val));\\t\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pseudoPalindromicPaths (TreeNode* root, int bitVec = 0) {\\n\\t\\t//check if the current node exist\\n        if(!root)\\n            return 0;\\n        \\n\\t\\t//if the current node is a leaf, we count the 1 bits in the bit vector, if they are greater then one we return 0 due to the fact that the path is not pseudo palindrome\\n        if(!root->left&&!root->right){\\n            return __builtin_popcount(bitVec^(1<<root->val))<=1;\\n        }\\n        \\n\\t\\t//dfs\\n        return pseudoPalindromicPaths(root->left,bitVec^(1<<root->val))+pseudoPalindromicPaths(root->right,bitVec^(1<<root->val));\\t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575370,
                "title": "java-solution-easy",
                "content": "### **Please Upvote !!!**\\n```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] freq = new int[10];\\n        return dfs(root, freq);\\n    }\\n\\n    public int dfs (TreeNode node, int[] freq) {\\n        if (node == null) return 0;\\n\\n        // When we reach the leaf node, we\\'ll have an array of counts of all numbers in that subtree\\n        if (node.left == null && node.right == null) {\\n            int c = 0;\\n            freq[node.val]++;\\n\\n            // every number is should appear in pairs, or there should be only ONE ODD CASE\\n\\n            for (int i : freq) {\\n                if (i % 2 == 1) c++;\\n            }\\n\\n            freq[node.val]--;\\n\\n            // leaving all other pairs, there should only be ONE case in which a number should appear only once and that\\'d go in the middle of the palindrome\\n            // If not, then its not a palindrome hence we don\\'t count that subtree\\n            return c > 1 ? 0 : 1;\\n        }\\n\\n        else {\\n            freq[node.val]++;\\n            int ans = dfs(node.left, freq) + dfs(node.right, freq);\\n            freq[node.val]--;\\n            return ans;\\n        }\\n    }\\n}\\n\\n// TC: O(n) -> We visit every node of the tree\\n// Sc: O(h) -> where h is the height of the tree / recursive stack\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] freq = new int[10];\\n        return dfs(root, freq);\\n    }\\n\\n    public int dfs (TreeNode node, int[] freq) {\\n        if (node == null) return 0;\\n\\n        // When we reach the leaf node, we\\'ll have an array of counts of all numbers in that subtree\\n        if (node.left == null && node.right == null) {\\n            int c = 0;\\n            freq[node.val]++;\\n\\n            // every number is should appear in pairs, or there should be only ONE ODD CASE\\n\\n            for (int i : freq) {\\n                if (i % 2 == 1) c++;\\n            }\\n\\n            freq[node.val]--;\\n\\n            // leaving all other pairs, there should only be ONE case in which a number should appear only once and that\\'d go in the middle of the palindrome\\n            // If not, then its not a palindrome hence we don\\'t count that subtree\\n            return c > 1 ? 0 : 1;\\n        }\\n\\n        else {\\n            freq[node.val]++;\\n            int ans = dfs(node.left, freq) + dfs(node.right, freq);\\n            freq[node.val]--;\\n            return ans;\\n        }\\n    }\\n}\\n\\n// TC: O(n) -> We visit every node of the tree\\n// Sc: O(h) -> where h is the height of the tree / recursive stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575319,
                "title": "javascript-tc-o-n-sc-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar pseudoPalindromicPaths  = function(root) {\\n    let ans = 0;\\n    const freq = {};\\n    \\n    function dfs(node) {\\n        if (!node) {\\n            return null;\\n        }\\n        \\n        freq[node.val] = ++freq[node.val] || 1;\\n        \\n        const left = dfs(node.left);\\n        const right = dfs(node.right);\\n        \\n        if (!left && !right) {\\n            let odd = 0;\\n            const values = Object.values(freq);\\n            for (const val of values) {\\n                if (val % 2) {\\n                    odd++;\\n                }\\n            }\\n            if (odd <= 1) {\\n                ans++;\\n            }\\n        }\\n        \\n        freq[node.val] = --freq[node.val];\\n        return true;\\n    }\\n    dfs(root);\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar pseudoPalindromicPaths  = function(root) {\\n    let ans = 0;\\n    const freq = {};\\n    \\n    function dfs(node) {\\n        if (!node) {\\n            return null;\\n        }\\n        \\n        freq[node.val] = ++freq[node.val] || 1;\\n        \\n        const left = dfs(node.left);\\n        const right = dfs(node.right);\\n        \\n        if (!left && !right) {\\n            let odd = 0;\\n            const values = Object.values(freq);\\n            for (const val of values) {\\n                if (val % 2) {\\n                    odd++;\\n                }\\n            }\\n            if (odd <= 1) {\\n                ans++;\\n            }\\n        }\\n        \\n        freq[node.val] = --freq[node.val];\\n        return true;\\n    }\\n    dfs(root);\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575296,
                "title": "1457-pseudo-palindromic-paths-in-a-binary-tree-java-code",
                "content": "# **1457. Pseudo-Palindromic Paths in a Binary Tree**\\n[https://www.youtube.com/watch?v=s2yJTlacN2g](http://)\\n```\\nclass Solution {\\n    int result = 0;\\n    int[] digits;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        digits = new int[10];\\n        dfs(root);\\n        return result;\\n    }\\n    void dfs (TreeNode root){\\n        if(root == null) return;\\n        \\n        digits[root.val]++;\\n        \\n        if(root.left == null && root.right == null){\\n            if(isPalindrome()){\\n                result++;\\n            }\\n        }else{\\n            dfs(root.left);\\n            dfs(root.right);\\n        }\\n        \\n        digits[root.val]--;\\n    }\\n    boolean isPalindrome (){\\n        int odd = 0;\\n        for(int i = 1; i <= 9; i++){\\n            if(digits[i] % 2 != 0){\\n                odd++;\\n            }\\n        }\\n        if(odd > 1){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    int[] digits;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        digits = new int[10];\\n        dfs(root);\\n        return result;\\n    }\\n    void dfs (TreeNode root){\\n        if(root == null) return;\\n        \\n        digits[root.val]++;\\n        \\n        if(root.left == null && root.right == null){\\n            if(isPalindrome()){\\n                result++;\\n            }\\n        }else{\\n            dfs(root.left);\\n            dfs(root.right);\\n        }\\n        \\n        digits[root.val]--;\\n    }\\n    boolean isPalindrome (){\\n        int odd = 0;\\n        for(int i = 1; i <= 9; i++){\\n            if(digits[i] % 2 != 0){\\n                odd++;\\n            }\\n        }\\n        if(odd > 1){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575235,
                "title": "javascript-dfs",
                "content": "```\\nvar pseudoPalindromicPaths  = function(root) {\\n    const countOddOccurrences = (occurrences) => occurrences.reduce((acc, occurrence) => acc + occurrence%2, 0);\\n\\n    const dfs = (node = root, occurrences = new Array(10).fill(0)) => {\\n        if(!node) return 0;\\n\\n        let paths = 0;\\n        occurrences[node.val] += 1;\\n        if(!node.left && !node.right) {\\n            paths = countOddOccurrences(occurrences) <= 1 ? 1 : 0;\\n        } else {\\n            paths = dfs(node.left, occurrences) + dfs(node.right, occurrences);\\n        }\\n        occurrences[node.val] -= 1;\\n\\n        return paths;\\n    }\\n\\n    return dfs();\\n};\\n```\\n\\nRuntime: O(n)\\nSpace: O(h) // Height of the tree",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar pseudoPalindromicPaths  = function(root) {\\n    const countOddOccurrences = (occurrences) => occurrences.reduce((acc, occurrence) => acc + occurrence%2, 0);\\n\\n    const dfs = (node = root, occurrences = new Array(10).fill(0)) => {\\n        if(!node) return 0;\\n\\n        let paths = 0;\\n        occurrences[node.val] += 1;\\n        if(!node.left && !node.right) {\\n            paths = countOddOccurrences(occurrences) <= 1 ? 1 : 0;\\n        } else {\\n            paths = dfs(node.left, occurrences) + dfs(node.right, occurrences);\\n        }\\n        occurrences[node.val] -= 1;\\n\\n        return paths;\\n    }\\n\\n    return dfs();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575231,
                "title": "simple-and-clear-c-solution-using-dfs",
                "content": "\\t#define tn TreeNode \\n\\tclass Solution {\\n\\tpublic:\\n    int ans =0;\\n    vector<int> vis;\\n    void solve(tn *root){\\n        if(!root)return;\\n        vis[root->val]++;\\n        if(root->left==NULL and root->right==NULL){            \\n            int odd=-1;\\n            bool ok =true;\\n            for(int i=1;i<=9;i++){\\n                if(vis[i] %2   and (odd==-1)){\\n                    odd=1;                    \\n                }\\n                else if(vis[i]%2){\\n                    ok=false;\\n                    break;\\n                }\\n            }\\n            if(ok) ans++;            \\n            \\n        }        \\n        solve(root->left);\\n        solve(root->right);\\n        vis[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vis.resize(10,0);\\n        solve(root);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int ans =0;\\n    vector<int> vis;\\n    void solve(tn *root){\\n        if(!root)return;\\n        vis[root->val]++;\\n        if(root->left==NULL and root->right==NULL){            \\n            int odd=-1;\\n            bool ok =true;\\n            for(int i=1;i<=9;i++){\\n                if(vis[i] %2   and (odd==-1)){\\n                    odd=1;                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2575126,
                "title": "golang-dfs-with-saving-values-frequencies",
                "content": "Use DFS when get leaf then count if numbers from nodes before all odd except one.\\n\\n```\\nfunc dps(node *TreeNode, odds *map[int]int, oddCount int) int {\\n\\tif node == nil {\\n\\t\\treturn 0\\n\\t}\\n\\tif _, ok := (*odds)[node.Val]; ok {\\n\\t\\t(*odds)[node.Val]++\\n\\t\\tif (*odds)[node.Val]%2 == 1 {\\n\\t\\t\\toddCount = oddCount - 1\\n\\t\\t} else {\\n\\t\\t\\toddCount = oddCount + 1\\n\\t\\t}\\n\\t} else {\\n\\t\\t(*odds)[node.Val] = 1\\n\\t}\\n\\n\\tres := 0\\n\\tif node.Left == nil && node.Right == nil {\\n\\t\\tif oddCount >= len(*odds)-1 {\\n\\t\\t\\tres = 1\\n\\t\\t}\\n\\t}\\n\\tres += dps(node.Left, odds, oddCount) + dps(node.Right, odds, oddCount)\\n\\t(*odds)[node.Val]--\\n\\tif (*odds)[node.Val] == 0 {\\n\\t\\tdelete((*odds), node.Val)\\n\\t}\\n\\treturn res\\n}\\n\\nfunc pseudoPalindromicPaths(root *TreeNode) int {\\n\\todds := make(map[int]int)\\n\\treturn dps(root, &odds, 0)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc dps(node *TreeNode, odds *map[int]int, oddCount int) int {\\n\\tif node == nil {\\n\\t\\treturn 0\\n\\t}\\n\\tif _, ok := (*odds)[node.Val]; ok {\\n\\t\\t(*odds)[node.Val]++\\n\\t\\tif (*odds)[node.Val]%2 == 1 {\\n\\t\\t\\toddCount = oddCount - 1\\n\\t\\t} else {\\n\\t\\t\\toddCount = oddCount + 1\\n\\t\\t}\\n\\t} else {\\n\\t\\t(*odds)[node.Val] = 1\\n\\t}\\n\\n\\tres := 0\\n\\tif node.Left == nil && node.Right == nil {\\n\\t\\tif oddCount >= len(*odds)-1 {\\n\\t\\t\\tres = 1\\n\\t\\t}\\n\\t}\\n\\tres += dps(node.Left, odds, oddCount) + dps(node.Right, odds, oddCount)\\n\\t(*odds)[node.Val]--\\n\\tif (*odds)[node.Val] == 0 {\\n\\t\\tdelete((*odds), node.Val)\\n\\t}\\n\\treturn res\\n}\\n\\nfunc pseudoPalindromicPaths(root *TreeNode) int {\\n\\todds := make(map[int]int)\\n\\treturn dps(root, &odds, 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575008,
                "title": "c-using-unordered-map-backtracking",
                "content": "**C++ Code:**\\n\\n```\\nvoid solve(TreeNode* root,unordered_map<int,int>&m,int &ans){\\n        if(root==NULL) return;\\n        \\n         m[root->val]++;\\n        \\n        if(root->left==NULL && root->right==NULL){\\n            int count = 0;\\n            for(auto it = m.begin();it!=m.end();it++){\\n                if((it->second)%2!=0) \\n                    count++;\\n              }\\n            if(count<=1) ans++; \\n        }\\n        \\n        solve (root->left,m,ans);\\n        solve (root->right,m,ans);\\n        m[root->val]--;\\n       if(m[root->val]==0) m.erase(m[root->val]);\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        \\n     unordered_map<int,int>m;\\n     int ans = 0;\\n     solve(root,m,ans);\\n     return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Binary Tree"
                ],
                "code": "```\\nvoid solve(TreeNode* root,unordered_map<int,int>&m,int &ans){\\n        if(root==NULL) return;\\n        \\n         m[root->val]++;\\n        \\n        if(root->left==NULL && root->right==NULL){\\n            int count = 0;\\n            for(auto it = m.begin();it!=m.end();it++){\\n                if((it->second)%2!=0) \\n                    count++;\\n              }\\n            if(count<=1) ans++; \\n        }\\n        \\n        solve (root->left,m,ans);\\n        solve (root->right,m,ans);\\n        m[root->val]--;\\n       if(m[root->val]==0) m.erase(m[root->val]);\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        \\n     unordered_map<int,int>m;\\n     int ans = 0;\\n     solve(root,m,ans);\\n     return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2574997,
                "title": "java-solution-depth-first-search-recursion",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int result = 0;\\n    \\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        this.dfs(new int[9], root);\\n        \\n        return this.result;\\n    }\\n    \\n    private void dfs(int[] counter, TreeNode node) {\\n        if (node == null)\\n            return;\\n        \\n        counter[node.val - 1]++;\\n        \\n        if (node.left == null && node.right == null && this.isPalindrome(counter))\\n            this.result++;\\n        \\n        this.dfs(counter, node.left);\\n        this.dfs(counter, node.right);\\n        \\n        counter[node.val - 1]--;\\n    }\\n    \\n    private boolean isPalindrome(int[] counter) {\\n        int odd = 0;\\n        for (int c: counter) {\\n            if (c % 2 == 1)\\n                odd++;\\n            if (odd > 1)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private int result = 0;\\n    \\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        this.dfs(new int[9], root);\\n        \\n        return this.result;\\n    }\\n    \\n    private void dfs(int[] counter, TreeNode node) {\\n        if (node == null)\\n            return;\\n        \\n        counter[node.val - 1]++;\\n        \\n        if (node.left == null && node.right == null && this.isPalindrome(counter))\\n            this.result++;\\n        \\n        this.dfs(counter, node.left);\\n        this.dfs(counter, node.right);\\n        \\n        counter[node.val - 1]--;\\n    }\\n    \\n    private boolean isPalindrome(int[] counter) {\\n        int odd = 0;\\n        for (int c: counter) {\\n            if (c % 2 == 1)\\n                odd++;\\n            if (odd > 1)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574963,
                "title": "java-dfs-backtracking-with-comments",
                "content": "```\\nclass Solution {\\n    /*\\n        Time - O(N), N = number of nodes.\\n        Space - O(H), H = Height of binary tree.\\n    */\\n    int count = 0;\\n\\t\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] freq = new int[10]; // Node values in the range 1 to 9.\\n        helper(root, freq); \\n        return count;\\n    }\\n    \\n    void helper(TreeNode root, int[] freq) { // Calculate frequency of digits in each branch.\\n        if(root == null) { // Do nothing.\\n            return;\\n        }\\n        if(root.left == null && root.right == null) { // If leaf node, update frquency, check if valid palindrome can be formed, backstrack.\\n            freq[root.val] ++;\\n            if(validPerm(freq)) { // If valid palindrome can be formed, increment count.\\n                count ++;\\n            }\\n            freq[root.val] --;\\n            return;\\n        }\\n        // For interior nodes, update frquency, call for left and right child, backstrack.\\n        freq[root.val] ++; \\n        helper(root.left, freq);\\n        helper(root.right, freq);\\n        freq[root.val] --;\\n    }\\n    \\n    boolean validPerm(int[] freq) { // We can have a valid palindrome only if the frequency of atmost 1 digit is odd.\\n        int odd = 0;\\n        for(int i = 1; i <= 9; i ++) {\\n            if(freq[i] % 2 == 1) {\\n                odd ++;\\n            }\\n        }\\n        return odd <= 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n        Time - O(N), N = number of nodes.\\n        Space - O(H), H = Height of binary tree.\\n    */\\n    int count = 0;\\n\\t\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        int[] freq = new int[10]; // Node values in the range 1 to 9.\\n        helper(root, freq); \\n        return count;\\n    }\\n    \\n    void helper(TreeNode root, int[] freq) { // Calculate frequency of digits in each branch.\\n        if(root == null) { // Do nothing.\\n            return;\\n        }\\n        if(root.left == null && root.right == null) { // If leaf node, update frquency, check if valid palindrome can be formed, backstrack.\\n            freq[root.val] ++;\\n            if(validPerm(freq)) { // If valid palindrome can be formed, increment count.\\n                count ++;\\n            }\\n            freq[root.val] --;\\n            return;\\n        }\\n        // For interior nodes, update frquency, call for left and right child, backstrack.\\n        freq[root.val] ++; \\n        helper(root.left, freq);\\n        helper(root.right, freq);\\n        freq[root.val] --;\\n    }\\n    \\n    boolean validPerm(int[] freq) { // We can have a valid palindrome only if the frequency of atmost 1 digit is odd.\\n        int odd = 0;\\n        for(int i = 1; i <= 9; i ++) {\\n            if(freq[i] % 2 == 1) {\\n                odd ++;\\n            }\\n        }\\n        return odd <= 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574828,
                "title": "go-dfs-unit-test",
                "content": "1. Solution\\n```\\ntype TreeNode struct {\\n\\tVal   int\\n\\tLeft  *TreeNode\\n\\tRight *TreeNode\\n}\\n\\nfunc PseudoPalindromicPaths(root *TreeNode) int {\\n\\tresult := 0\\n\\tdfsPalindromicPaths(root, 0, &result)\\n\\treturn result\\n}\\n\\nfunc dfsPalindromicPaths(root *TreeNode, path int, result *int) {\\n\\tif root == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif root.Left == nil && root.Right == nil {\\n\\t\\tpath ^= 1 << root.Val\\n\\t\\tif (path & (path - 1)) == 0 {\\n\\t\\t\\t*result++\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\n\\tdfsPalindromicPaths(root.Left, path^1<<root.Val, result)\\n\\tdfsPalindromicPaths(root.Right, path^1<<root.Val, result)\\n}\\n```\\n2. Unit-test\\n```\\nfunc TestPseudoPalindromicPaths(t *testing.T) {\\n\\tcases := []struct {\\n\\t\\troot *TreeNode\\n\\t\\twant int\\n\\t}{\\n\\t\\t// test case 1\\n\\t\\t{\\n\\t\\t\\t&TreeNode{ // [2,3,1,3,1,null,1]\\n\\t\\t\\t\\tVal: 2,\\n\\t\\t\\t\\tLeft: &TreeNode{\\n\\t\\t\\t\\t\\tVal: 3,\\n\\t\\t\\t\\t\\tLeft: &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: 3,\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tRight: &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tRight: &TreeNode{\\n\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t\\tRight: &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t\\t2,\\n\\t\\t},\\n\\t\\t// test case 2\\n\\t\\t{\\n\\t\\t\\t&TreeNode{ // [2,1,1,1,3,null,null,null,null,null,1]\\n\\t\\t\\t\\tVal: 2,\\n\\t\\t\\t\\tLeft: &TreeNode{\\n\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t\\tLeft: &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tRight: &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: 3,\\n\\t\\t\\t\\t\\t\\tRight: &TreeNode{\\n\\t\\t\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tRight: &TreeNode{\\n\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t\\t1,\\n\\t\\t},\\n\\t\\t// test case 3\\n\\t\\t{\\n\\t\\t\\t&TreeNode{ // [9]\\n\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t},\\n\\t\\t\\t1,\\n\\t\\t},\\n\\t}\\n\\tfor _, c := range cases {\\n\\t\\tgot := PseudoPalindromicPaths(c.root)\\n\\t\\tif got != c.want {\\n\\t\\t\\tt.Errorf(\"PseudoPalindromicPaths(%q) == %d, want %d\", fmt.Sprint(c.root), got, c.want)\\n\\t\\t}\\n\\t}\\n}\\n```\\nMore Go problems [here](https://github.com/nguyenptk/leetcode)\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype TreeNode struct {\\n\\tVal   int\\n\\tLeft  *TreeNode\\n\\tRight *TreeNode\\n}\\n\\nfunc PseudoPalindromicPaths(root *TreeNode) int {\\n\\tresult := 0\\n\\tdfsPalindromicPaths(root, 0, &result)\\n\\treturn result\\n}\\n\\nfunc dfsPalindromicPaths(root *TreeNode, path int, result *int) {\\n\\tif root == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif root.Left == nil && root.Right == nil {\\n\\t\\tpath ^= 1 << root.Val\\n\\t\\tif (path & (path - 1)) == 0 {\\n\\t\\t\\t*result++\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\n\\tdfsPalindromicPaths(root.Left, path^1<<root.Val, result)\\n\\tdfsPalindromicPaths(root.Right, path^1<<root.Val, result)\\n}\\n```\n```\\nfunc TestPseudoPalindromicPaths(t *testing.T) {\\n\\tcases := []struct {\\n\\t\\troot *TreeNode\\n\\t\\twant int\\n\\t}{\\n\\t\\t// test case 1\\n\\t\\t{\\n\\t\\t\\t&TreeNode{ // [2,3,1,3,1,null,1]\\n\\t\\t\\t\\tVal: 2,\\n\\t\\t\\t\\tLeft: &TreeNode{\\n\\t\\t\\t\\t\\tVal: 3,\\n\\t\\t\\t\\t\\tLeft: &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: 3,\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tRight: &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tRight: &TreeNode{\\n\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t\\tRight: &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t\\t2,\\n\\t\\t},\\n\\t\\t// test case 2\\n\\t\\t{\\n\\t\\t\\t&TreeNode{ // [2,1,1,1,3,null,null,null,null,null,1]\\n\\t\\t\\t\\tVal: 2,\\n\\t\\t\\t\\tLeft: &TreeNode{\\n\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t\\tLeft: &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tRight: &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: 3,\\n\\t\\t\\t\\t\\t\\tRight: &TreeNode{\\n\\t\\t\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tRight: &TreeNode{\\n\\t\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t\\t1,\\n\\t\\t},\\n\\t\\t// test case 3\\n\\t\\t{\\n\\t\\t\\t&TreeNode{ // [9]\\n\\t\\t\\t\\tVal: 1,\\n\\t\\t\\t},\\n\\t\\t\\t1,\\n\\t\\t},\\n\\t}\\n\\tfor _, c := range cases {\\n\\t\\tgot := PseudoPalindromicPaths(c.root)\\n\\t\\tif got != c.want {\\n\\t\\t\\tt.Errorf(\"PseudoPalindromicPaths(%q) == %d, want %d\", fmt.Sprint(c.root), got, c.want)\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2574824,
                "title": "golang-255-ms-24-3-mb-solution",
                "content": "```\\nfunc pseudoPalindromicPaths2 (root *TreeNode, parity int16) int {\\n    parity ^= int16(1) << (root.Val-1)\\n    if root.Left == nil && root.Right == nil {\\n        switch parity {\\n        case 0, 1, 2, 4, 8, 16, 32, 64, 128, 256:\\n            return 1\\n        }\\n        return 0\\n    }\\n    \\n    result := 0\\n    for _, node := range [...]*TreeNode{root.Left, root.Right} {\\n        if node != nil {\\n            result += pseudoPalindromicPaths2(node, parity)\\n        }\\n    }\\n    \\n    return result\\n}\\n\\nfunc pseudoPalindromicPaths (root *TreeNode) int {\\n    return pseudoPalindromicPaths2(root, 0)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pseudoPalindromicPaths2 (root *TreeNode, parity int16) int {\\n    parity ^= int16(1) << (root.Val-1)\\n    if root.Left == nil && root.Right == nil {\\n        switch parity {\\n        case 0, 1, 2, 4, 8, 16, 32, 64, 128, 256:\\n            return 1\\n        }\\n        return 0\\n    }\\n    \\n    result := 0\\n    for _, node := range [...]*TreeNode{root.Left, root.Right} {\\n        if node != nil {\\n            result += pseudoPalindromicPaths2(node, parity)\\n        }\\n    }\\n    \\n    return result\\n}\\n\\nfunc pseudoPalindromicPaths (root *TreeNode) int {\\n    return pseudoPalindromicPaths2(root, 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2574604,
                "title": "easy-code-with-full-explanation",
                "content": "/**\\n \\nclass Solution {\\npublic:\\n\\n    //intuition is simple..as we know we need root to leaf path only and also we know to a number to be a palindrome it has even number frequency or only 1 odd number freq..\\n    // our work is to store or keep the track of the path and the frequency but how to do it\\n    //use map data structure and as we are entering we will insert while when existing(after left and right child are traversed) and as leaf is found we will see for the freq on the map and thus ans is incremneted if criteria fullfilled\\n     map<int,int>mp;\\n    int ans=0;\\n    void func(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n        mp[root->val]++;\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            int odd=0;\\n            for(auto it:mp)\\n            {\\n                if((it.second%2)!=0)\\n                    odd++;\\n            }\\n            if(odd<=1)\\n                ans++;\\n        }\\n        func(root->left);\\n        func(root->right);\\n        mp[root->val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n      if(root==NULL)\\n            return 0;\\n        func(root);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    //intuition is simple..as we know we need root to leaf path only and also we know to a number to be a palindrome it has even number frequency or only 1 odd number freq..\\n    // our work is to store or keep the track of the path and the frequency but how to do it\\n    //use map data structure and as we are entering we will insert while when existing(after left and right child are traversed) and as leaf is found we will see for the freq on the map and thus ans is incremneted if criteria fullfilled\\n     map<int,int>mp;\\n    int ans=0;\\n    void func(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n        mp[root->val]++;\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            int odd=0;\\n            for(auto it:mp)\\n            {\\n                if((it.second%2)!=0)\\n                    odd++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2574574,
                "title": "c-dfs-map",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int ans=0;\\n    \\n    bool palindrome(int n){\\n        if(n%2){\\n            bool flag = false;\\n            for(auto i : mp){\\n                if(i.second%2 and flag) return false;\\n                else if(i.second%2 and !flag) flag = true;\\n            }\\n        }else{\\n            cout << n <<endl;\\n            for(auto i : mp){\\n                if(i.second%2) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(TreeNode* root, int h){\\n        if(root->left==NULL and root->right==NULL) {\\n            mp[root->val]++;\\n            if(palindrome(h)) ans++;\\n            if(mp[root->val]==1) mp.erase(mp.find(root->val));\\n            else mp[root->val]--;\\n            return;\\n        }\\n        \\n        mp[root->val]++;\\n        if(root->left) dfs(root->left,h+1);\\n        if(root->right) dfs(root->right,h+1);\\n        if(mp[root->val]==1) mp.erase(mp.find(root->val));\\n        else mp[root->val]--;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int ans=0;\\n    \\n    bool palindrome(int n){\\n        if(n%2){\\n            bool flag = false;\\n            for(auto i : mp){\\n                if(i.second%2 and flag) return false;\\n                else if(i.second%2 and !flag) flag = true;\\n            }\\n        }else{\\n            cout << n <<endl;\\n            for(auto i : mp){\\n                if(i.second%2) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(TreeNode* root, int h){\\n        if(root->left==NULL and root->right==NULL) {\\n            mp[root->val]++;\\n            if(palindrome(h)) ans++;\\n            if(mp[root->val]==1) mp.erase(mp.find(root->val));\\n            else mp[root->val]--;\\n            return;\\n        }\\n        \\n        mp[root->val]++;\\n        if(root->left) dfs(root->left,h+1);\\n        if(root->right) dfs(root->right,h+1);\\n        if(mp[root->val]==1) mp.erase(mp.find(root->val));\\n        else mp[root->val]--;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        dfs(root,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2574504,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-beats-100-dfs",
                "content": "```C#\\npublic class Solution {\\n    public int PseudoPalindromicPaths (TreeNode root) {\\n        if (root is null) return 0;\\n        \\n        var x = new Dictionary<int, int>();\\n        return Solve(root, x);\\n    }\\n    \\n    private int Solve(TreeNode root, Dictionary<int, int> x) {\\n        if (root is null) return 0;\\n        \\n        x.TryGetValue(root.val, out var repetitions);\\n        x[root.val] = repetitions + 1;\\n        \\n        int count;\\n        if (root.left is null && root.right is null) {\\n            if (IsPseudoPalindrome(x)) count = 1;\\n            else count = 0;\\n        }\\n        else {\\n            count = Solve(root.left, x) + Solve(root.right, x);\\n        }\\n        \\n        x[root.val] = repetitions;\\n        \\n        return count;\\n    }\\n    \\n    private bool IsPseudoPalindrome(Dictionary<int, int> x) {\\n        bool hadOdd = false;\\n        foreach (var kvp in x) {\\n            if (kvp.Value % 2 != 0) {\\n                if (hadOdd) return false;\\n                hadOdd = true;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int PseudoPalindromicPaths (TreeNode root) {\\n        if (root is null) return 0;\\n        \\n        var x = new Dictionary<int, int>();\\n        return Solve(root, x);\\n    }\\n    \\n    private int Solve(TreeNode root, Dictionary<int, int> x) {\\n        if (root is null) return 0;\\n        \\n        x.TryGetValue(root.val, out var repetitions);\\n        x[root.val] = repetitions + 1;\\n        \\n        int count;\\n        if (root.left is null && root.right is null) {\\n            if (IsPseudoPalindrome(x)) count = 1;\\n            else count = 0;\\n        }\\n        else {\\n            count = Solve(root.left, x) + Solve(root.right, x);\\n        }\\n        \\n        x[root.val] = repetitions;\\n        \\n        return count;\\n    }\\n    \\n    private bool IsPseudoPalindrome(Dictionary<int, int> x) {\\n        bool hadOdd = false;\\n        foreach (var kvp in x) {\\n            if (kvp.Value % 2 != 0) {\\n                if (hadOdd) return false;\\n                hadOdd = true;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574492,
                "title": "java-solution-optimized-without-using-bit-manipulation-o-n-space-o-n-time",
                "content": "class Solution {\\n    int [] map;\\n    int count =0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n         \\n        map = new int[10];\\n        checkPalindrome(root);\\n        return count;\\n    }\\n    \\n    private void checkPalindrome(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        map[root.val]++;         // Add element freq to the map\\n        if(root.left == null && root.right == null){\\n            if(checkValidity()){\\n                count++;\\n            }\\n        }\\n        checkPalindrome(root.left);\\n        checkPalindrome(root.right);\\n        map[root.val]--; // BackTrack and remove it from the map;\\n    }\\n    \\n    private boolean checkValidity(){    // Because the loop will always run from 0-9, This is said to be of o(1) T.C\\n        \\n        boolean odd = true;\\n        for(int i=0;i<map.length;i++){\\n            if(map[i]==0)continue;\\n            if(map[i]%2 == 1 && odd == false){\\n                return false;\\n            }\\n            else if(map[i]%2 == 1){\\n                odd = false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    int [] map;\\n    int count =0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n         \\n        map = new int[10];\\n        checkPalindrome(root);\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2574415,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> mp;\\n    int ans = 0;\\n    \\n    void helper(TreeNode* root) {\\n        if(!root) {\\n            return;\\n        }\\n        mp[root -> val]++;\\n        if(!root -> left and !root -> right) {\\n            int odd = 0;\\n            for(auto it : mp) {\\n                if(it.second % 2 != 0) {\\n                    odd++;\\n                }\\n                if(odd >= 2) {\\n                    break;\\n                }\\n            }\\n            if(odd <= 1) {\\n                ans++;\\n            }\\n        }\\n        helper(root -> left);\\n        helper(root -> right);\\n        mp[root -> val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> mp;\\n    int ans = 0;\\n    \\n    void helper(TreeNode* root) {\\n        if(!root) {\\n            return;\\n        }\\n        mp[root -> val]++;\\n        if(!root -> left and !root -> right) {\\n            int odd = 0;\\n            for(auto it : mp) {\\n                if(it.second % 2 != 0) {\\n                    odd++;\\n                }\\n                if(odd >= 2) {\\n                    break;\\n                }\\n            }\\n            if(odd <= 1) {\\n                ans++;\\n            }\\n        }\\n        helper(root -> left);\\n        helper(root -> right);\\n        mp[root -> val]--;\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574409,
                "title": "easy-to-understand-python-solution-at-most-one-odd-occurrence-using-count-array",
                "content": "In the given problem we have to find the count of all possible ways in which the permutation of the traversal from root to a leaf node will form a palindrome. A palindrome can be formed if the number of odd occurences of digits is at most one. For example : 1,1,1,1 (0 odd occurence) forms (1,1,1,1);  1,1,1,1,2 (1 odd occurence) will form a palindrome (1,1,2,1,1). But 1,1,1,1,2,3 (2 odd occurences) cannot.\\n\\nEach node in the tree can have values ranging from 1-9. If we can store the count of each value starting from the root to a leaf node, we can check the number of odd occurences at each leaf node. If odd_occurences==0 or 1, we increase result counter by 1.\\n\\nCode : (Count list stores number of occurences of each digit and res stores the total number of pseudo-palindromes)\\n\\n```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        self.count, self.res=[0]*9, 0\\n        def Count(root):\\n            \\n            #Return if root is null\\n            if not root:\\n                return\\n            \\n            #On reaching each node, increase its value\\'s count in the count array\\n            self.count[root.val-1]+=1\\n            \\n            \\'\\'\\'On reaching a leaf node, we must have at most one odd count in count array.\\n               If satisfied, increase result count by 1\\'\\'\\'\\n            if root.left==None and root.right==None:\\n                odd_count=0\\n                for num in self.count:\\n                    if num%2!=0:\\n                        odd_count+=1\\n                if odd_count==0 or odd_count==1:\\n                    self.res+=1\\n            \\n            #Traverse left and right subtrees\\n            Count(root.left)\\n            Count(root.right)\\n            \\n            #Before going back to parent node, reduce current value\\'s count \\n            self.count[root.val-1]-=1\\n            \\n        Count(root)\\n        return self.res\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        self.count, self.res=[0]*9, 0\\n        def Count(root):\\n            \\n            #Return if root is null\\n            if not root:\\n                return\\n            \\n            #On reaching each node, increase its value\\'s count in the count array\\n            self.count[root.val-1]+=1\\n            \\n            \\'\\'\\'On reaching a leaf node, we must have at most one odd count in count array.\\n               If satisfied, increase result count by 1\\'\\'\\'\\n            if root.left==None and root.right==None:\\n                odd_count=0\\n                for num in self.count:\\n                    if num%2!=0:\\n                        odd_count+=1\\n                if odd_count==0 or odd_count==1:\\n                    self.res+=1\\n            \\n            #Traverse left and right subtrees\\n            Count(root.left)\\n            Count(root.right)\\n            \\n            #Before going back to parent node, reduce current value\\'s count \\n            self.count[root.val-1]-=1\\n            \\n        Count(root)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574401,
                "title": "c-dfs-cleanest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> paths;\\n    int ans=0;\\n    bool isleaf(TreeNode* n){\\n        return n->left==NULL and n->right==NULL;\\n    }\\n    void check(map<int,int>& mp,vector<int>& v){\\n        if(v.size()%2==0){\\n                int f=0,cto=0,cte=0;\\n                for(auto ele:mp){\\n                    if(ele.second%2!=0){\\n                     //odd occurence\\n                      f=1;\\n                      break;\\n                    }\\n                    else{\\n                        cte++;\\n                    }\\n                }\\n                if(!f){\\n                    ans++;\\n                }\\n            }\\n            else if(v.size()%2!=0){\\n                //all even occurence and only 1 odd occurence\\n                int f=0;\\n                int cto=0,cte=0;\\n                for(auto ele:mp){\\n                    if(ele.second%2!=0){\\n                        cto++;\\n                        if(cto>1){f=1;break;}\\n                    }\\n                }\\n                if(!f){\\n                    ans++;\\n                }\\n            }\\n    }\\n    void helper(TreeNode* root,vector<int>& v,map<int,int>& mp,int& cte,int& cto){\\n        if(root==NULL){\\n            return;\\n        }\\n        v.push_back(root->val);\\n        mp[root->val]++;\\n        if(isleaf(root)){\\n           check(mp,v);\\n        }\\n        helper(root->left,v,mp,cte,cto);\\n        helper(root->right,v,mp,cte,cto);\\n        mp[v.back()]--;\\n       \\n        v.pop_back();\\n        \\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        //we can store all paths from root node to leaves\\n        vector<int> v;\\n        map<int,int> mp;\\n        int cte=0,cto=0;\\n        helper(root,v,mp,cte,cto);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> paths;\\n    int ans=0;\\n    bool isleaf(TreeNode* n){\\n        return n->left==NULL and n->right==NULL;\\n    }\\n    void check(map<int,int>& mp,vector<int>& v){\\n        if(v.size()%2==0){\\n                int f=0,cto=0,cte=0;\\n                for(auto ele:mp){\\n                    if(ele.second%2!=0){\\n                     //odd occurence\\n                      f=1;\\n                      break;\\n                    }\\n                    else{\\n                        cte++;\\n                    }\\n                }\\n                if(!f){\\n                    ans++;\\n                }\\n            }\\n            else if(v.size()%2!=0){\\n                //all even occurence and only 1 odd occurence\\n                int f=0;\\n                int cto=0,cte=0;\\n                for(auto ele:mp){\\n                    if(ele.second%2!=0){\\n                        cto++;\\n                        if(cto>1){f=1;break;}\\n                    }\\n                }\\n                if(!f){\\n                    ans++;\\n                }\\n            }\\n    }\\n    void helper(TreeNode* root,vector<int>& v,map<int,int>& mp,int& cte,int& cto){\\n        if(root==NULL){\\n            return;\\n        }\\n        v.push_back(root->val);\\n        mp[root->val]++;\\n        if(isleaf(root)){\\n           check(mp,v);\\n        }\\n        helper(root->left,v,mp,cte,cto);\\n        helper(root->right,v,mp,cte,cto);\\n        mp[v.back()]--;\\n       \\n        v.pop_back();\\n        \\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        //we can store all paths from root node to leaves\\n        vector<int> v;\\n        map<int,int> mp;\\n        int cte=0,cto=0;\\n        helper(root,v,mp,cte,cto);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574382,
                "title": "golang-standard-dfs-solution",
                "content": "```\\nfunc pseudoPalindromicPaths (root *TreeNode) int {\\n    odd := [10]bool{}\\n    res := 0\\n    \\n    var dfs func(node *TreeNode)\\n    dfs = func(node *TreeNode) {\\n        if node == nil {\\n            return\\n        }\\n        odd[node.Val] = !odd[node.Val]\\n        if node.Left == nil && node.Right == nil {\\n            cnt := 0\\n            for _, o := range odd {\\n                if o {\\n                    cnt++\\n                }\\n            }\\n            if cnt <= 1 {\\n                res++\\n            }\\n        } else {\\n            dfs(node.Left)\\n            dfs(node.Right)\\n        }\\n        odd[node.Val] = !odd[node.Val]\\n    }\\n    \\n    dfs(root)\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc pseudoPalindromicPaths (root *TreeNode) int {\\n    odd := [10]bool{}\\n    res := 0\\n    \\n    var dfs func(node *TreeNode)\\n    dfs = func(node *TreeNode) {\\n        if node == nil {\\n            return\\n        }\\n        odd[node.Val] = !odd[node.Val]\\n        if node.Left == nil && node.Right == nil {\\n            cnt := 0\\n            for _, o := range odd {\\n                if o {\\n                    cnt++\\n                }\\n            }\\n            if cnt <= 1 {\\n                res++\\n            }\\n        } else {\\n            dfs(node.Left)\\n            dfs(node.Right)\\n        }\\n        odd[node.Val] = !odd[node.Val]\\n    }\\n    \\n    dfs(root)\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2574376,
                "title": "rust-itertaive-and-recursive-solutions",
                "content": "\\n### Recursive preorder DFS\\n\\n```rust\\npub fn pseudo_palindromic_paths(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n    let mut freq = [0; 10];\\n    match root.as_ref() {\\n        None => 0,\\n        Some(root) => dfs(root, &mut freq, 0),\\n    }\\n}\\n\\nfn dfs(root: &Rc<RefCell<TreeNode>>, freq: &mut [u32; 10], mut odd: u32) -> i32 {\\n    let root_ref = root.borrow();\\n    freq[root_ref.val as usize] += 1;\\n\\n    let mut odd_count = odd;\\n    // If the current count has become \"odd\", then increase the odd_counter\\n    odd_count += (freq[root_ref.val as usize] % 2 != 0) as u32;\\n    // If the current value has become \"event\", then decrease the odd counter\\n    odd_count -= (freq[root_ref.val as usize] % 2 == 0) as u32;\\n\\n    let mut count = 0;\\n    if let Some(node) = root_ref.left.as_ref() {\\n        count += dfs(node, freq, odd_count);\\n    }\\n    if let Some(node) = root_ref.right.as_ref() {\\n        count += dfs(node, freq, odd_count);\\n    }\\n    if root_ref.left.is_none() && root_ref.right.is_none() {\\n        count = (odd_count <= 1) as i32;\\n    }\\n\\n    freq[root_ref.val as usize] -= 1;\\n    count\\n}\\n```\\n\\n### Iterative preorder DFS\\n\\n```rust\\npub fn pseudo_palindromic_paths(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n    let mut stack = vec![];\\n    if let Some(node) = root {\\n        stack.push((node, 0usize));\\n    }\\n\\n    let mut count = 0;\\n    while let Some((node, freq)) = stack.pop() {\\n        let mut node_ref = node.borrow_mut();\\n        // We can track the number of odd frequencies by using bitmasks.\\n        // I.e. a number I is odd, if thr Ith bit is one. Thus, we can easily\\n        // toggle between odd/even by just XORing this bit\\n        let freq = freq ^ (1 << node_ref.val);\\n\\n        // If it\\'s a leaf node, then update the answer\\n        if node_ref.left.is_none() && node_ref.right.is_none() {\\n            // A path is pseudo palindromic, if it has at most 1 \\n            // odd frequency, i.e. this bitmask represents a power of two\\n            count += ((freq & (freq - 1)) == 0) as i32;\\n            continue;\\n        }\\n\\n        // If it\\'s not a leaf node, then push its children to the stack\\n        if let Some(right) = node_ref.right.take() {\\n            stack.push((right, freq));\\n        }\\n        if let Some(left) = node_ref.left.take() {\\n            stack.push((left, freq));\\n        }\\n    }\\n\\n    count\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```rust\\npub fn pseudo_palindromic_paths(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n    let mut freq = [0; 10];\\n    match root.as_ref() {\\n        None => 0,\\n        Some(root) => dfs(root, &mut freq, 0),\\n    }\\n}\\n\\nfn dfs(root: &Rc<RefCell<TreeNode>>, freq: &mut [u32; 10], mut odd: u32) -> i32 {\\n    let root_ref = root.borrow();\\n    freq[root_ref.val as usize] += 1;\\n\\n    let mut odd_count = odd;\\n    // If the current count has become \"odd\", then increase the odd_counter\\n    odd_count += (freq[root_ref.val as usize] % 2 != 0) as u32;\\n    // If the current value has become \"event\", then decrease the odd counter\\n    odd_count -= (freq[root_ref.val as usize] % 2 == 0) as u32;\\n\\n    let mut count = 0;\\n    if let Some(node) = root_ref.left.as_ref() {\\n        count += dfs(node, freq, odd_count);\\n    }\\n    if let Some(node) = root_ref.right.as_ref() {\\n        count += dfs(node, freq, odd_count);\\n    }\\n    if root_ref.left.is_none() && root_ref.right.is_none() {\\n        count = (odd_count <= 1) as i32;\\n    }\\n\\n    freq[root_ref.val as usize] -= 1;\\n    count\\n}\\n```\n```rust\\npub fn pseudo_palindromic_paths(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n    let mut stack = vec![];\\n    if let Some(node) = root {\\n        stack.push((node, 0usize));\\n    }\\n\\n    let mut count = 0;\\n    while let Some((node, freq)) = stack.pop() {\\n        let mut node_ref = node.borrow_mut();\\n        // We can track the number of odd frequencies by using bitmasks.\\n        // I.e. a number I is odd, if thr Ith bit is one. Thus, we can easily\\n        // toggle between odd/even by just XORing this bit\\n        let freq = freq ^ (1 << node_ref.val);\\n\\n        // If it\\'s a leaf node, then update the answer\\n        if node_ref.left.is_none() && node_ref.right.is_none() {\\n            // A path is pseudo palindromic, if it has at most 1 \\n            // odd frequency, i.e. this bitmask represents a power of two\\n            count += ((freq & (freq - 1)) == 0) as i32;\\n            continue;\\n        }\\n\\n        // If it\\'s not a leaf node, then push its children to the stack\\n        if let Some(right) = node_ref.right.take() {\\n            stack.push((right, freq));\\n        }\\n        if let Some(left) = node_ref.left.take() {\\n            stack.push((left, freq));\\n        }\\n    }\\n\\n    count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2574340,
                "title": "explanation-of-logic-with-clear-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define node TreeNode\\nclass Solution {\\npublic:\\n    int ans;\\n    bool check(map<int,int> &mm){\\n        bool flag=true;\\n        for(auto &v: mm){\\n            if(v.second%2==0) continue;\\n            else if(flag) flag=false;\\n            else return false;\\n        }\\n        return true;\\n    }\\n    \\n    void rec(node *curr,map<int,int> &mm){\\n        if(!curr) return;\\n        \\n        if(curr and !curr->left and !curr->right){\\n            mm[curr->val]++;\\n            \\n            if(check(mm)) ans++;\\n            \\n            mm[curr->val]--;\\n            if(mm[curr->val]==0) mm.erase(curr->val);\\n            \\n            return;\\n        }\\n        \\n        mm[curr->val]++;\\n        rec(curr->left,mm);\\n        rec(curr->right,mm);\\n        mm[curr->val]--;\\n        if(mm[curr->val]==0) mm.erase(curr->val);\\n        \\n        return;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        ans=0;\\n        map<int,int> mm;\\n        rec(root,mm);\\n        \\n        return ans;\\n    }\\n};\\n/*\\n\\nas we move we keep on storing the elements in the map. \\n\\nfor a palindrome : all elements\\' freq must be even or all even with one element\\'s freq as odd. then only a palindrome can be formed. \\n\\nso we keep on moving and storing the elements in the map on the way. we keep a separate case for leaf nodes(left and right = null) because we dont keep it then it would be counted 2 times. since it would go to left and then right and each time hitting the base case it would count it 2 times. so we need to avoid it. \\n\\na usual BC of curr==null is mandatory. for the nodes having one of the children as null.\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define node TreeNode\\nclass Solution {\\npublic:\\n    int ans;\\n    bool check(map<int,int> &mm){\\n        bool flag=true;\\n        for(auto &v: mm){\\n            if(v.second%2==0) continue;\\n            else if(flag) flag=false;\\n            else return false;\\n        }\\n        return true;\\n    }\\n    \\n    void rec(node *curr,map<int,int> &mm){\\n        if(!curr) return;\\n        \\n        if(curr and !curr->left and !curr->right){\\n            mm[curr->val]++;\\n            \\n            if(check(mm)) ans++;\\n            \\n            mm[curr->val]--;\\n            if(mm[curr->val]==0) mm.erase(curr->val);\\n            \\n            return;\\n        }\\n        \\n        mm[curr->val]++;\\n        rec(curr->left,mm);\\n        rec(curr->right,mm);\\n        mm[curr->val]--;\\n        if(mm[curr->val]==0) mm.erase(curr->val);\\n        \\n        return;\\n    }\\n    \\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        ans=0;\\n        map<int,int> mm;\\n        rec(root,mm);\\n        \\n        return ans;\\n    }\\n};\\n/*\\n\\nas we move we keep on storing the elements in the map. \\n\\nfor a palindrome : all elements\\' freq must be even or all even with one element\\'s freq as odd. then only a palindrome can be formed. \\n\\nso we keep on moving and storing the elements in the map on the way. we keep a separate case for leaf nodes(left and right = null) because we dont keep it then it would be counted 2 times. since it would go to left and then right and each time hitting the base case it would count it 2 times. so we need to avoid it. \\n\\na usual BC of curr==null is mandatory. for the nodes having one of the children as null.\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574337,
                "title": "python-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        ans=[0]\\n        def solve(root,path):\\n            if not root:\\n                return\\n            if root.val in path:\\n                path[root.val]+=1\\n            else:\\n                path[root.val]=1\\n            \\n            if not root.left and not root.right:\\n                o=0\\n                for i in path:\\n                    if path[i]%2!=0:\\n                        o+=1\\n                if o in [0,1]:\\n                    ans[0]+=1\\n                    \\n            else:\\n                \\n                solve(root.left,path.copy())\\n                solve(root.right,path.copy())\\n        solve(root,{})\\n        return ans[0]\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        ans=[0]\\n        def solve(root,path):\\n            if not root:\\n                return\\n            if root.val in path:\\n                path[root.val]+=1\\n            else:\\n                path[root.val]=1\\n            \\n            if not root.left and not root.right:\\n                o=0\\n                for i in path:\\n                    if path[i]%2!=0:\\n                        o+=1\\n                if o in [0,1]:\\n                    ans[0]+=1\\n                    \\n            else:\\n                \\n                solve(root.left,path.copy())\\n                solve(root.right,path.copy())\\n        solve(root,{})\\n        return ans[0]\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574266,
                "title": "elixir-pattern-matching-solution",
                "content": "```\\ndefmodule Solution do\\n  def pseudo_palindromic_paths(root) do\\n    palindrome_check(root, %{})\\n  end\\n\\n  defp palindrome_check(%TreeNode{val: v, left: nil, right: nil}, map),\\n    do: palindrome_check(Map.update(map, v, 1, &(&1 + 1)))\\n\\n  defp palindrome_check(%TreeNode{val: v, left: l, right: nil}, map),\\n    do: palindrome_check(l, Map.update(map, v, 1, &(&1 + 1)))\\n\\n  defp palindrome_check(%TreeNode{val: v, left: nil, right: r}, map),\\n    do: palindrome_check(r, Map.update(map, v, 1, &(&1 + 1)))\\n\\n  defp palindrome_check(%TreeNode{val: v, left: l, right: r}, map) do\\n    palindrome_check(l, Map.update(map, v, 1, &(&1 + 1))) +\\n      palindrome_check(r, Map.update(map, v, 1, &(&1 + 1)))\\n  end\\n\\n  defp palindrome_check(map) do\\n    map\\n    |> Enum.reduce_while(_odd_count = 0, fn\\n      {_, count}, 0 when rem(count, 2) == 1 -> {:cont, 1}\\n      {_, count}, _ when rem(count, 2) == 1 -> {:halt, false}\\n      _, odd_count -> {:cont, odd_count}\\n    end)\\n    |> (&if(&1 == false, do: 0, else: 1)).()\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  def pseudo_palindromic_paths(root) do\\n    palindrome_check(root, %{})\\n  end\\n\\n  defp palindrome_check(%TreeNode{val: v, left: nil, right: nil}, map),\\n    do: palindrome_check(Map.update(map, v, 1, &(&1 + 1)))\\n\\n  defp palindrome_check(%TreeNode{val: v, left: l, right: nil}, map),\\n    do: palindrome_check(l, Map.update(map, v, 1, &(&1 + 1)))\\n\\n  defp palindrome_check(%TreeNode{val: v, left: nil, right: r}, map),\\n    do: palindrome_check(r, Map.update(map, v, 1, &(&1 + 1)))\\n\\n  defp palindrome_check(%TreeNode{val: v, left: l, right: r}, map) do\\n    palindrome_check(l, Map.update(map, v, 1, &(&1 + 1))) +\\n      palindrome_check(r, Map.update(map, v, 1, &(&1 + 1)))\\n  end\\n\\n  defp palindrome_check(map) do\\n    map\\n    |> Enum.reduce_while(_odd_count = 0, fn\\n      {_, count}, 0 when rem(count, 2) == 1 -> {:cont, 1}\\n      {_, count}, _ when rem(count, 2) == 1 -> {:halt, false}\\n      _, odd_count -> {:cont, odd_count}\\n    end)\\n    |> (&if(&1 == false, do: 0, else: 1)).()\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2574250,
                "title": "swift-solution-with-set",
                "content": "If a path is pseudo-palindromic it has at most one odd number of repetitive node values.\\n\\n*For example, [5,6,6,7,6,6,5] has two `5`s, four `6`s and one `7` - 2 even numbers (2 and 4) and 1 odd. Only one odd number - hence this path is pseudo-palindromic.*\\n\\nTo keep number of repetitive values we use stack. \\nOn each traverse step we add node to the stack or remove it if the stack already contains this value. When we remove node - that means we have an even number of that value.\\nAnd at the end we check stack size. If the path under consideration contains only even numbers of values, stack size must be equal to zero. Otherwise, stack size will be equal to the number of repetitive odd values along the path. Since, only one odd number is allowed, we check stack size to be equal to one in OR branch.\\n\\n```\\nclass Solution {\\n\\n    private var paths = 0\\n    \\n    func pseudoPalindromicPaths (_ root: TreeNode?) -> Int {\\n        guard let root = root else {\\n            return -1\\n        }\\n        \\n        var set = Set<Int>()\\n        traverse(root, set)\\n        return paths\\n    }\\n    \\n    private func traverse(_ node: TreeNode, _ set: Set<Int>) {\\n        var set = set\\n        if set.contains(node.val) {\\n            set.remove(node.val)\\n        } else {\\n            set.insert(node.val)\\n        }\\n        \\n        if node.left == nil && node.right == nil {\\n            if set.count == 0 || set.count == 1 {\\n                paths += 1\\n            }\\n            return\\n        }\\n        \\n        if let left = node.left {\\n            traverse(left, set)\\n        }\\n        \\n        if let right = node.right {\\n            traverse(right, set)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Tree",
                    "Interactive",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n\\n    private var paths = 0\\n    \\n    func pseudoPalindromicPaths (_ root: TreeNode?) -> Int {\\n        guard let root = root else {\\n            return -1\\n        }\\n        \\n        var set = Set<Int>()\\n        traverse(root, set)\\n        return paths\\n    }\\n    \\n    private func traverse(_ node: TreeNode, _ set: Set<Int>) {\\n        var set = set\\n        if set.contains(node.val) {\\n            set.remove(node.val)\\n        } else {\\n            set.insert(node.val)\\n        }\\n        \\n        if node.left == nil && node.right == nil {\\n            if set.count == 0 || set.count == 1 {\\n                paths += 1\\n            }\\n            return\\n        }\\n        \\n        if let left = node.left {\\n            traverse(left, set)\\n        }\\n        \\n        if let right = node.right {\\n            traverse(right, set)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574246,
                "title": "c-using-xor",
                "content": "```\\nclass Solution {\\npublic:\\n        int ans=0; \\n        void helper(TreeNode* root,int count)\\n        {\\n           if(!root)return ;\\n            count^=1<<root->val;  //dry run this many times on 1 to 9 you will get idea; for frequency \\n\\t\\t\\t\\n            if(!root->left and !root->right)\\n                ans+=(count&count-1)==0;  //for checking of odd occurences atmost 1 time\\n            \\n\\t\\t\\thelper(root->left,count); //for left subtree\\n            helper(root->right,count); //for right subtree\\n        }\\n    \\n        int pseudoPalindromicPaths (TreeNode* root) \\n    {\\n        ios_base::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n            helper(root,0);\\n         return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n        int ans=0; \\n        void helper(TreeNode* root,int count)\\n        {\\n           if(!root)return ;\\n            count^=1<<root->val;  //dry run this many times on 1 to 9 you will get idea; for frequency \\n\\t\\t\\t\\n            if(!root->left and !root->right)\\n                ans+=(count&count-1)==0;  //for checking of odd occurences atmost 1 time\\n            \\n\\t\\t\\thelper(root->left,count); //for left subtree\\n            helper(root->right,count); //for right subtree\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2574217,
                "title": "simple-straightforward-recursive-commented-c-faster-than-94",
                "content": "Pay attention to 2 details in the question -\\n1. Node values are digits from 1 to 9 (we can maintain their count or simply if the count is even or odd)\\n2. Check if any permutation is a palindrome.\\n\\nA permutation can be a palindrome if we have a matching pair of all nodes eg. 123321 (count of all nodes even) or only one of the nodes is odd eg 12321.\\nThis is all we are going to check in our code.\\n```\\nclass Solution {\\n    int pseudoPalindromicPaths (TreeNode* root, int odd, vector<bool>& isEven) {\\n\\t\\t// base condition\\n        if(!root) return 0;\\n        \\n\\t\\t// adjusting odd values count after considering current node\\n\\t\\t\\n\\t\\t// if the count of current node has been even in the path uptill now, make it odd and add its count to odd variable\\n        if(isEven[root->val]){\\n            isEven[root->val] = false;\\n            ++odd;\\n        }\\n        else{\\n\\t\\t\\t// if the count of current node has been odd in the path uptill now, make it even and decrease its count to odd variable\\n            isEven[root->val] = true;\\n            --odd;\\n        }\\n        \\n\\t\\t// if current node is a leaf node\\n        if(!root->left && !root->right){\\n\\t\\t\\t// discard the current node before returning a answer (since passing by reference)\\n\\t\\t\\tisEven[root->val] = !isEven[root->val];\\n\\t\\t\\t\\n\\t\\t\\t// if there have been no more than 1 nodes with odd count, return 1, otherwise return 0\\n            if(odd<=1) return 1;\\n            else return 0;\\n        }\\n        \\n\\t\\t// for a non-leaf node, return count of pseudo palindromic paths in left sub-tree and right sub-tree\\n        int ans = pseudoPalindromicPaths(root->left, odd, isEven) + pseudoPalindromicPaths(root->right, odd, isEven);\\n        \\n\\t\\t// discard the current node before returning a answer (since passing by reference)\\n        isEven[root->val] = !isEven[root->val];\\n        \\n        return ans;\\n    }\\npublic:\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n\\t\\t// for checking if current node count is even or odd\\n\\t\\t// initilizing by true since initially count is 0 (even)\\n        vector<bool> isEven(10, true);\\n        return pseudoPalindromicPaths(root, 0, isEven);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int pseudoPalindromicPaths (TreeNode* root, int odd, vector<bool>& isEven) {\\n\\t\\t// base condition\\n        if(!root) return 0;\\n        \\n\\t\\t// adjusting odd values count after considering current node\\n\\t\\t\\n\\t\\t// if the count of current node has been even in the path uptill now, make it odd and add its count to odd variable\\n        if(isEven[root->val]){\\n            isEven[root->val] = false;\\n            ++odd;\\n        }\\n        else{\\n\\t\\t\\t// if the count of current node has been odd in the path uptill now, make it even and decrease its count to odd variable\\n            isEven[root->val] = true;\\n            --odd;\\n        }\\n        \\n\\t\\t// if current node is a leaf node\\n        if(!root->left && !root->right){\\n\\t\\t\\t// discard the current node before returning a answer (since passing by reference)\\n\\t\\t\\tisEven[root->val] = !isEven[root->val];\\n\\t\\t\\t\\n\\t\\t\\t// if there have been no more than 1 nodes with odd count, return 1, otherwise return 0\\n            if(odd<=1) return 1;\\n            else return 0;\\n        }\\n        \\n\\t\\t// for a non-leaf node, return count of pseudo palindromic paths in left sub-tree and right sub-tree\\n        int ans = pseudoPalindromicPaths(root->left, odd, isEven) + pseudoPalindromicPaths(root->right, odd, isEven);\\n        \\n\\t\\t// discard the current node before returning a answer (since passing by reference)\\n        isEven[root->val] = !isEven[root->val];\\n        \\n        return ans;\\n    }\\npublic:\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n\\t\\t// for checking if current node count is even or odd\\n\\t\\t// initilizing by true since initially count is 0 (even)\\n        vector<bool> isEven(10, true);\\n        return pseudoPalindromicPaths(root, 0, isEven);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574216,
                "title": "pseudo-palindromic-paths-in-a-binary-tree-java-solution",
                "content": "Java :\\n```\\nclass Solution {\\n    int ans = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        ans = 0;\\n        dfs(root, 0);\\n        return ans;\\n    }\\n    private void dfs(TreeNode root, int count) {\\n        if (root == null) return;\\n        count ^= 1 << (root.val - 1);\\n        dfs(root.left, count);\\n        dfs(root.right, count);\\n        if (root.left == null && root.right ==  null && (count & (count - 1)) == 0) ans++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        ans = 0;\\n        dfs(root, 0);\\n        return ans;\\n    }\\n    private void dfs(TreeNode root, int count) {\\n        if (root == null) return;\\n        count ^= 1 << (root.val - 1);\\n        dfs(root.left, count);\\n        dfs(root.right, count);\\n        if (root.left == null && root.right ==  null && (count & (count - 1)) == 0) ans++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574187,
                "title": "golang-python-o-n-time-o-h-space",
                "content": "**N** - number of nodes in a tree\\n**H** - height of a tree\\n\\n**Golang**\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc pseudoPalindromicPaths (root *TreeNode) int {\\n    return dfs(root, 0)\\n}\\n\\nfunc dfs(node *TreeNode, path int) int{\\n    if node == nil{\\n        return 0\\n    }\\n    counter := 0\\n    path = path ^ (1 << node.Val)\\n    \\n    counter+=dfs(node.Left, path)\\n    counter+=dfs(node.Right, path)\\n    if node.Left == nil && node.Right == nil{\\n        if path & (path - 1) == 0{\\n            counter ++\\n        }\\n    }\\n    return counter\\n}\\n```\\n**Python**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        return dfs(root, 0)\\n\\ndef dfs(node,path):\\n    if not node:\\n        return 0\\n    counter = 0\\n    path = path ^ (1 << node.val)\\n    \\n    counter+=dfs(node.left, path)\\n    counter+=dfs(node.right, path)\\n    if not node.left and not node.right:\\n        if path & (path - 1) == 0:\\n            counter += 1\\n    return counter\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc pseudoPalindromicPaths (root *TreeNode) int {\\n    return dfs(root, 0)\\n}\\n\\nfunc dfs(node *TreeNode, path int) int{\\n    if node == nil{\\n        return 0\\n    }\\n    counter := 0\\n    path = path ^ (1 << node.Val)\\n    \\n    counter+=dfs(node.Left, path)\\n    counter+=dfs(node.Right, path)\\n    if node.Left == nil && node.Right == nil{\\n        if path & (path - 1) == 0{\\n            counter ++\\n        }\\n    }\\n    return counter\\n}\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\\n        return dfs(root, 0)\\n\\ndef dfs(node,path):\\n    if not node:\\n        return 0\\n    counter = 0\\n    path = path ^ (1 << node.val)\\n    \\n    counter+=dfs(node.left, path)\\n    counter+=dfs(node.right, path)\\n    if not node.left and not node.right:\\n        if path & (path - 1) == 0:\\n            counter += 1\\n    return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574157,
                "title": "pseudo-palindromic-paths-in-a-binary-tree-cpp-solution-usinf-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count=0;\\n    void dfs(TreeNode* root,vector<int> hm,int c){\\n        if(root==NULL) return;\\n        hm[root->val]++;\\n        \\n        if(!root->left && !root->right){\\n            int n = hm.size(),f;\\n            if(c%2==0) f=1;\\n            else f=2;\\n            for(auto it:hm){\\n                if((it)%2!=0) f--;\\n            }\\n            if(f==1) count++;\\n        }\\n        dfs(root->left,hm,c+1);\\n        dfs(root->right,hm,c+1);\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> hm(10,0);\\n        dfs(root,hm,1);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count=0;\\n    void dfs(TreeNode* root,vector<int> hm,int c){\\n        if(root==NULL) return;\\n        hm[root->val]++;\\n        \\n        if(!root->left && !root->right){\\n            int n = hm.size(),f;\\n            if(c%2==0) f=1;\\n            else f=2;\\n            for(auto it:hm){\\n                if((it)%2!=0) f--;\\n            }\\n            if(f==1) count++;\\n        }\\n        dfs(root->left,hm,c+1);\\n        dfs(root->right,hm,c+1);\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        vector<int> hm(10,0);\\n        dfs(root,hm,1);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574144,
                "title": "c-bitmask-dfs",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root,int mask,int& ans){\\n        if(!root) return;\\n        mask^=(1<<(root->val-1));\\n        if(!root->left&&!root->right&&__builtin_popcount(mask)<=1) ans++;\\n        dfs(root->left,mask,ans);\\n        dfs(root->right,mask,ans);\\n    }\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        int ans=0;\\n        dfs(root,0,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    void dfs(TreeNode* root,int mask,int& ans){\\n        if(!root) return;\\n        mask^=(1<<(root->val-1));\\n        if(!root->left&&!root->right&&__builtin_popcount(mask)<=1) ans++;\\n        dfs(root->left,mask,ans);\\n        dfs(root->right,mask,ans);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2573957,
                "title": "easy-bit-masking-solution-in-java-too-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int res=0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        dfs(root,0);\\n        return res;\\n    }\\n    void dfs(TreeNode node, int bitmask){\\n        if(node==null)return;\\n        bitmask=bitmask^(1<<node.val);\\n        if(node.left==null && node.right==null && (bitmask&(bitmask-1))==0)\\n            res++;\\n        else{\\n            dfs(node.left,bitmask);\\n            dfs(node.right,bitmask);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int res=0;\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        dfs(root,0);\\n        return res;\\n    }\\n    void dfs(TreeNode node, int bitmask){\\n        if(node==null)return;\\n        bitmask=bitmask^(1<<node.val);\\n        if(node.left==null && node.right==null && (bitmask&(bitmask-1))==0)\\n            res++;\\n        else{\\n            dfs(node.left,bitmask);\\n            dfs(node.right,bitmask);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573925,
                "title": "easiest-way-explained-solution-java",
                "content": "class Solution {\\n\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        \\n        int[] freq = new int[10];                   //to store frequency of each element\\n        return solveItForMe(root,freq);         \\n        \\n    }\\n    \\n    private int solveItForMe(TreeNode root,int[] freq){\\n        \\n        if(root==null)\\n            return 0;\\n        \\n        freq[root.val]++;                           //increase count by 1 of node\\'s value\\n        \\n        if(root.left==null && root.right==null){    //if node\\'s left and right both are null, that is leaf node, Now check pseudo-palindrome is there or not\\n            int isPalin = 0;                        //initialize it by zero\\n            for(int i=1;i<=9;i++)                   //Given node\\'s values are only from 1 to 9\\n                isPalin += freq[i]%2;               //add the modulo 2 of that elements frequency, to count number of odd frequency elements\\n                \\n            freq[root.val]--;                       //BACKTRACK, reduce that(leaf node) element\\'s frequency by one\\n            if(isPalin==1 || isPalin==0)            //if isPalin>1 it means more than 1 odd frequency elements are present else return 1\\n               return 1;\\n            else\\n               return 0;  \\n        }\\n        \\n        int count = solveItForMe(root.left,freq) + solveItForMe(root.right,freq);  //count the no. of pseudo-palindromic paths going from the root node to leaf nodes.   \\n        freq[root.val]--;                            //BACKTRACK\\n        \\n        return count;\\n      \\n    }\\n}\\n\\n**Feel Free to ask any doubt...!**\\n\\n***Note: Kindly Upvote this article, if you found it helpful. Thanks For Reading!!***",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n    public int pseudoPalindromicPaths (TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        \\n        int[] freq = new int[10];                   //to store frequency of each element\\n        return solveItForMe(root,freq);         \\n        \\n    }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569939,
                "content": [
                    {
                        "username": "Dan783",
                        "content": "Did anyone manage to write code that passes all the test cases and not causes TLE for 52 test case?\\n\\nI have tried all the solutions from the discussion section, and none of them can pass all the test cases. Is it possible to do it with Javascript? Python and C++ work nice thought."
                    },
                    {
                        "username": "sharpsailor",
                        "content": "Did u manage to solve it"
                    },
                    {
                        "username": "jribbink",
                        "content": "Use bitwise operations"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "This is giving TLE. 52/55 test cases are getting passed. please help\\nclass Solution {\\npublic:\\nstring a=\"\";\\nint c=0;\\nvector<int>v;\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        if (!root)\\n            return 0;\\n       checkingpal(root);\\n       return c;\\n    }\\n    void checkingpal(TreeNode*root)\\n    {   if (!root)\\n            return;\\n         v.push_back(root->val);\\n         if (!root->left && !root->right)\\n         {\\n             if (ispalidrome())\\n                c++;\\n         }\\n         checkingpal(root->left);\\n         checkingpal(root->right);\\n         v.pop_back();\\n    }\\n    bool ispalidrome()\\n    {\\n        int odd=0;\\n        unordered_map<int,int>umap;\\n        for (int i=0;i<v.size();i++)\\n        {\\n            umap[v[i]]++;\\n        }\\n        for (auto k:umap)\\n        {\\n            if (k.second%2!=0)\\n                odd++;\\n        }\\n        if (odd<=1)\\n            return true;\\n        return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1928842,
                "content": [
                    {
                        "username": "Dan783",
                        "content": "Did anyone manage to write code that passes all the test cases and not causes TLE for 52 test case?\\n\\nI have tried all the solutions from the discussion section, and none of them can pass all the test cases. Is it possible to do it with Javascript? Python and C++ work nice thought."
                    },
                    {
                        "username": "sharpsailor",
                        "content": "Did u manage to solve it"
                    },
                    {
                        "username": "jribbink",
                        "content": "Use bitwise operations"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "This is giving TLE. 52/55 test cases are getting passed. please help\\nclass Solution {\\npublic:\\nstring a=\"\";\\nint c=0;\\nvector<int>v;\\n    int pseudoPalindromicPaths (TreeNode* root) {\\n        if (!root)\\n            return 0;\\n       checkingpal(root);\\n       return c;\\n    }\\n    void checkingpal(TreeNode*root)\\n    {   if (!root)\\n            return;\\n         v.push_back(root->val);\\n         if (!root->left && !root->right)\\n         {\\n             if (ispalidrome())\\n                c++;\\n         }\\n         checkingpal(root->left);\\n         checkingpal(root->right);\\n         v.pop_back();\\n    }\\n    bool ispalidrome()\\n    {\\n        int odd=0;\\n        unordered_map<int,int>umap;\\n        for (int i=0;i<v.size();i++)\\n        {\\n            umap[v[i]]++;\\n        }\\n        for (auto k:umap)\\n        {\\n            if (k.second%2!=0)\\n                odd++;\\n        }\\n        if (odd<=1)\\n            return true;\\n        return false;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]