[
    {
        "title": "Scramble String",
        "question_content": "We can scramble a string s to get a string t using the following algorithm:\n\n\tIf the length of the string is 1, stop.\n\tIf the length of the string is > 1, do the following:\n\t\n\t\tSplit the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\n\t\tRandomly&nbsp;decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\n\t\tApply step 1 recursively on each of the two substrings x and y.\n\t\n\t\n\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.\n&nbsp;\nExample 1:\n\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n\nExample 2:\n\nInput: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false\n\nExample 3:\n\nInput: s1 = \"a\", s2 = \"a\"\nOutput: true\n\n&nbsp;\nConstraints:\n\n\ts1.length == s2.length\n\t1 <= s1.length <= 30\n\ts1 and s2 consist of lowercase English letters.",
        "solutions": [
            {
                "id": 29392,
                "title": "share-my-4ms-c-recursive-solution",
                "content": "Assume the strings are all lower case letters\\n\\n    class Solution {\\n    public:\\n        bool isScramble(string s1, string s2) {\\n            if(s1==s2)\\n                return true;\\n                \\n            int len = s1.length();\\n            int count[26] = {0};\\n            for(int i=0; i<len; i++)\\n            {\\n                count[s1[i]-'a']++;\\n                count[s2[i]-'a']--;\\n            }\\n            \\n            for(int i=0; i<26; i++)\\n            {\\n                if(count[i]!=0)\\n                    return false;\\n            }\\n            \\n            for(int i=1; i<=len-1; i++)\\n            {\\n                if( isScramble(s1.substr(0,i), s2.substr(0,i)) && isScramble(s1.substr(i), s2.substr(i)))\\n                    return true;\\n                if( isScramble(s1.substr(0,i), s2.substr(len-i)) && isScramble(s1.substr(i), s2.substr(0,len-i)))\\n                    return true;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isScramble(string s1, string s2) {\\n            if(s1==s2)\\n                return true;\\n                \\n            int len = s1.length();\\n            int count[26] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 29396,
                "title": "simple-iterative-dp-java-solution-with-explanation",
                "content": "Explanation in code itself. The iterative version of the idea is considerably slower than the recursive simply because here we consider all possible states, while the recursive will only compute required states as it founds them. Time complexity of both is, in any case, the same.\\n    \\n    public class Solution {\\n    \\tpublic boolean isScramble(String s1, String s2) {\\n    \\t\\tif (s1.length() != s2.length()) return false;\\n    \\t\\tint len = s1.length();\\n    \\t\\t/**\\n    \\t\\t * Let F(i, j, k) = whether the substring S1[i..i + k - 1] is a scramble of S2[j..j + k - 1] or not\\n    \\t\\t * Since each of these substrings is a potential node in the tree, we need to check for all possible cuts.\\n    \\t\\t * Let q be the length of a cut (hence, q < k), then we are in the following situation:\\n    \\t\\t * \\n    \\t\\t * S1 [   x1    |         x2         ]\\n    \\t\\t *    i         i + q                i + k - 1\\n    \\t\\t * \\n    \\t\\t * here we have two possibilities:\\n    \\t\\t *      \\n    \\t\\t * S2 [   y1    |         y2         ]\\n    \\t\\t *    j         j + q                j + k - 1\\n    \\t\\t *    \\n    \\t\\t * or \\n    \\t\\t * \\n    \\t\\t * S2 [       y1        |     y2     ]\\n    \\t\\t *    j                 j + k - q    j + k - 1\\n    \\t\\t * \\n    \\t\\t * which in terms of F means:\\n    \\t\\t * \\n    \\t\\t * F(i, j, k) = for some 1 <= q < k we have:\\n    \\t\\t *  (F(i, j, q) AND F(i + q, j + q, k - q)) OR (F(i, j + k - q, q) AND F(i + q, j, k - q))\\n    \\t\\t *  \\n    \\t\\t * Base case is k = 1, where we simply need to check for S1[i] and S2[j] to be equal \\n    \\t\\t * */\\n    \\t\\tboolean [][][] F = new boolean[len][len][len + 1];\\n    \\t\\tfor (int k = 1; k <= len; ++k)\\n    \\t\\t\\tfor (int i = 0; i + k <= len; ++i)\\n    \\t\\t\\t\\tfor (int j = 0; j + k <= len; ++j)\\n    \\t\\t\\t\\t\\tif (k == 1)\\n    \\t\\t\\t\\t\\t\\tF[i][j][k] = s1.charAt(i) == s2.charAt(j);\\n    \\t\\t\\t\\t\\telse for (int q = 1; q < k && !F[i][j][k]; ++q) {\\n    \\t\\t\\t\\t\\t\\tF[i][j][k] = (F[i][j][q] && F[i + q][j + q][k - q]) || (F[i][j + k - q][q] && F[i + q][j][k - q]);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\treturn F[0][0][len];\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    \\tpublic boolean isScramble(String s1, String s2) {\\n    \\t\\tif (s1.length() != s2.length()) return false;\\n    \\t\\tint len = s1.length();\\n    \\t\\t/**\\n    \\t\\t * Let F(i, j, k) = whether the substring S1[i..i + k - 1] is a scramble of S2[j..j + k - 1] or not\\n    \\t\\t * Since each of these substrings is a potential node in the tree, we need to check for all possible cuts.\\n    \\t\\t * Let q be the length of a cut (hence, q < k), then we are in the following situation:\\n    \\t\\t * \\n    \\t\\t * S1 [   x1    |         x2         ]\\n    \\t\\t *    i         i + q                i + k - 1\\n    \\t\\t * \\n    \\t\\t * here we have two possibilities:\\n    \\t\\t *      \\n    \\t\\t * S2 [   y1    |         y2         ]\\n    \\t\\t *    j         j + q                j + k - 1\\n    \\t\\t *    \\n    \\t\\t * or \\n    \\t\\t * \\n    \\t\\t * S2 [       y1        |     y2     ]\\n    \\t\\t *    j                 j + k - q    j + k - 1\\n    \\t\\t * \\n    \\t\\t * which in terms of F means:\\n    \\t\\t * \\n    \\t\\t * F(i, j, k) = for some 1 <= q < k we have:\\n    \\t\\t *  (F(i, j, q) AND F(i + q, j + q, k - q)) OR (F(i, j + k - q, q) AND F(i + q, j, k - q))\\n    \\t\\t *  \\n    \\t\\t * Base case is k = 1, where we simply need to check for S1[i] and S2[j] to be equal \\n    \\t\\t * */\\n    \\t\\tboolean [][][] F = new boolean[len][len][len + 1];\\n    \\t\\tfor (int k = 1; k <= len; ++k)\\n    \\t\\t\\tfor (int i = 0; i + k <= len; ++i)\\n    \\t\\t\\t\\tfor (int j = 0; j + k <= len; ++j)\\n    \\t\\t\\t\\t\\tif (k == 1)\\n    \\t\\t\\t\\t\\t\\tF[i][j][k] = s1.charAt(i) == s2.charAt(j);\\n    \\t\\t\\t\\t\\telse for (int q = 1; q < k && !F[i][j][k]; ++q) {\\n    \\t\\t\\t\\t\\t\\tF[i][j][k] = (F[i][j][q] && F[i + q][j + q][k - q]) || (F[i][j + k - q][q] && F[i + q][j][k - q]);\\n    \\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 29387,
                "title": "accepted-java-solution",
                "content": "    public class Solution {\\n        public boolean isScramble(String s1, String s2) {\\n            if (s1.equals(s2)) return true; \\n            \\n            int[] letters = new int[26];\\n            for (int i=0; i<s1.length(); i++) {\\n                letters[s1.charAt(i)-'a']++;\\n                letters[s2.charAt(i)-'a']--;\\n            }\\n            for (int i=0; i<26; i++) if (letters[i]!=0) return false;\\n        \\n            for (int i=1; i<s1.length(); i++) {\\n                if (isScramble(s1.substring(0,i), s2.substring(0,i)) \\n                 && isScramble(s1.substring(i), s2.substring(i))) return true;\\n                if (isScramble(s1.substring(0,i), s2.substring(s2.length()-i)) \\n                 && isScramble(s1.substring(i), s2.substring(0,s2.length()-i))) return true;\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isScramble(String s1, String s2) {\\n            if (s1.equals(s2)) return true; \\n            \\n            int[] letters = new int[26];\\n            for (int i=0; i<s1.length(); i++) {\\n                letters[s1.charAt(i)-'a']++;\\n                letters[s2.charAt(i)-'a']--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 29394,
                "title": "my-c-solutions-recursion-with-cache-dp-recursion-with-cache-and-pruning-with-explanation-4ms",
                "content": "The basic idea is to divide s1(s2) into two substrings with length k and len-k and check if the two substrings s1[0..k-1] and s1[k, len-1] are the scrambles of s2[0..k-1] and s2[k,len-1] or s2[len-k, len-1] and s2[0..len-k-1] via recursion. The straigtforward recursion will be very slow due to many repeated recursive function calls. To speed up the recursion, we can use an unordered_map isScramblePair to save intermediate results. The key used here is s1+s2, but other keys are also possible (e.g. using indices)\\n\\n        class Solution {\\n            bool DP_helper(unordered_map<string, bool> &isScramblePair, string s1, string s2)\\n            {\\n                int i,len = s1.size();\\n                bool res = false;\\n                if(0==len) return true;\\n                else if(1==len) return s1 == s2;\\n                else\\n                {\\n                    if(isScramblePair.count(s1+s2)) return isScramblePair[s1+s2]; // checked before, return intermediate result directly\\n                    if(s1==s2) res=true;\\n                    else{\\n                        for(i=1; i<len && !res; ++i)\\n                        {\\n    //check s1[0..i-1] with s2[0..i-1] and s1[i..len-1] and s2[i..len-1]\\n                            res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(0,i)) && DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(i,len-i)));\\n     //if no match, then check s1[0..i-1] with s2[len-k.. len-1] and s1[i..len-1] and s2[0..len-i]\\n                           res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(len-i,i)) && DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(0,len-i)));\\n                        }\\n                    }\\n                    return isScramblePair[s1+s2]= res; //save the intermediate results\\n                    \\n                }\\n            }\\n        public:\\n            bool isScramble(string s1, string s2) {\\n               unordered_map<string, bool> isScramblePair;\\n               return DP_helper(isScramblePair, s1, s2);\\n            }\\n        };\\n\\nThe recursive version has exponential complexity. To further improve the performance, we can use bottom-up DP, which is O(N^4) complexity. Here we build a table isS[len][i][j], which indicates whether s1[i..i+len-1] is a scramble of s2[j..j+len-1].\\n\\n    class Solution {\\n    public:\\n        bool isScramble(string s1, string s2) {\\n            int sSize = s1.size(), len, i, j, k;\\n            if(0==sSize) return true;\\n            if(1==sSize) return s1==s2;\\n            bool isS[sSize+1][sSize][sSize];\\n    \\n            for(i=0; i<sSize; ++i)\\n                for(j=0; j<sSize; ++j)\\n                    isS[1][i][j] = s1[i] == s2[j];\\n                    \\n            for(len=2; len <=sSize; ++len)\\n                for(i=0; i<=sSize-len; ++i)\\n                    for(j=0; j<=sSize-len; ++j)\\n                    {\\n                        isS[len][i][j] = false;\\n                            for(k=1; k<len && !isS[len][i][j]; ++k)\\n                            {\\n                                isS[len][i][j] = isS[len][i][j] || (isS[k][i][j] && isS[len-k][i+k][j+k]);\\n                                isS[len][i][j] = isS[len][i][j] || (isS[k][i+len-k][j] && isS[len-k][i][j+k]);\\n                            }\\n                    }\\n            return isS[sSize][0][0];            \\n    \\n        }\\n    }; \\n\\nFurhtermore, in many cases, we found we can terminate our recursion early by pruning: i.e. by first checking if s1 and s2 have the same character set before we do recursion: if not, just terminate without recursion.  This observation leads us to the following Recursion+cache+pruning version. Here the key of the cache changes to idx1*sSize +idx2 + len*sSize*sSize;\\n\\n    class Solution {\\n    private:\\n        bool DP_helper(string &s1, string &s2, int idx1, int idx2, int len, char isS[])\\n        {\\n            int sSize = s1.size(),i, j, k, hist[26] , zero_count =0;\\n            if(isS[(len*sSize+idx1)*sSize+idx2]) return isS[(len*sSize+idx1)*sSize+idx2]==1;\\n            bool res = false;\\n            \\n            fill_n(hist, 26, 0);\\n            for(k=0; k<len;++k)\\n            { // check if s1[idx1:idx1+len-1] and s2[idx2:idx2+len-1] have same characters\\n                zero_count +=  (0==hist[s1[idx1+k]-'a']) - (0== ++hist[s1[idx1+k]-'a']);\\n                zero_count +=  (0==hist[s2[idx2+k]-'a']) - (0== --hist[s2[idx2+k]-'a']);\\n            }\\n            if(zero_count) {isS[(len*sSize+idx1)*sSize+idx2] = 2; return false;} //if not, return directly\\n            if(len==1)     {isS[(len*sSize+idx1)*sSize+idx2] = 1; return true;}\\n            for(k=1;k<len && !res;++k) //otherwise, recursion with cache\\n            {\\n                res = res || (DP_helper(s1, s2, idx1, idx2, k, isS) && DP_helper(s1, s2, idx1+k, idx2+k, len-k, isS) );\\n                res = res || (DP_helper(s1, s2, idx1+len-k, idx2, k, isS) && DP_helper(s1, s2, idx1, idx2+k, len-k, isS) );\\n            }\\n            isS[(len*sSize+idx1)*sSize+idx2] = res?1:2;\\n            return res;\\n        }\\n    public:\\n        bool isScramble(string s1, string s2) {\\n            const int sSize = s1.size();\\n            if(0==sSize) return true;\\n            char isS[(sSize+1)*sSize*sSize];\\n            fill_n(isS, (sSize+1)*sSize*sSize, 0);\\n            return DP_helper(s1, s2, 0, 0, sSize, isS);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n            bool DP_helper(unordered_map<string, bool> &isScramblePair, string s1, string s2)\\n            {\\n                int i,len = s1.size();\\n                bool res = false;\\n                if(0==len) return true;\\n                else if(1==len) return s1 == s2;\\n                else\\n                {\\n                    if(isScramblePair.count(s1+s2)) return isScramblePair[s1+s2]; // checked before, return intermediate result directly\\n                    if(s1==s2) res=true;\\n                    else{\\n                        for(i=1; i<len && !res; ++i)\\n                        {\\n    //check s1[0..i-1] with s2[0..i-1] and s1[i..len-1] and s2[i..len-1]\\n                            res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(0,i)) && DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(i,len-i)));\\n     //if no match, then check s1[0..i-1] with s2[len-k.. len-1] and s1[i..len-1] and s2[0..len-i]\\n                           res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(len-i,i)) && DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(0,len-i)));\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3357439,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to check whether s2 is scrambled string of s1 or not. The scrambled string of a given string is defined as any string that can be obtained by swapping some characters of the original string. So we can solve this problem recursively by dividing the string into left and right substrings and check for two cases i.e., whether we need to swap the substrings before checking for the next recursive call or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will first check the base cases i.e., if the two strings are equal or not or if they are of different sizes. Then, we will create a key for the current problem by concatenating the two strings and storing it in a dictionary to avoid repeated computations. We will iterate over all possible splits of the current string and check whether we need to swap the left and right substrings or not. We will then make recursive calls on these two substrings and return true if any of the calls return true.\\n\\n# Complexity\\n- Time complexity: $$O(n^4)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsince for each character in s1, we are trying out all possible splits of the string which takes $$O(n^2)$$ time and we are calling the recursion twice for each split which takes another $$O(n^2)$$ time. And for each such problem, we are storing it in a dictionary which takes $$O(1)$$ time. So overall time complexity is $$O(n^4)$$.\\n\\n- Space complexity: $$O(n^3)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nsince we are using a dictionary to store previously solved problems and the depth of the recursion tree can go up to n. Therefore, the space complexity of this solution is $$O(n^3)$$.\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    // for storing already solved problems\\n    Map<String, Boolean> mp = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n\\n        // if both strings are not equal in size\\n        if (s2.length() != n)\\n            return false;\\n\\n        // if both strings are equal\\n        if (s1.equals(s2))\\n            return true;\\n\\n        // if code is reached to this condition then following this are sure:\\n        // 1. size of both string is equal\\n        // 2. string are not equal\\n        // so size is equal (where size==1) and they are not equal then obviously false\\n        // example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if (n == 1)\\n            return false;\\n\\n        String key = s1 + \" \" + s2;\\n\\n        // check if this problem has already been solved\\n        if (mp.containsKey(key))\\n            return mp.get(key);\\n\\n        // for every iteration it can two condition\\n        // 1.we should proceed without swapping\\n        // 2.we should swap before looking next\\n        for (int i = 1; i < n; i++) {\\n            // ex of without swap: gr|eat and rg|eat\\n            boolean withoutswap = (\\n                    // left part of first and second string\\n                    isScramble(s1.substring(0, i), s2.substring(0, i))\\n\\n                            &&\\n\\n                            // right part of first and second string;\\n                            isScramble(s1.substring(i), s2.substring(i))\\n            );\\n\\n            // if without swap give us right answer then we do not need\\n            // to call the recursion withswap\\n            if (withoutswap) {\\n                mp.put(key, true);\\n                return true;\\n            }\\n\\n            // ex of withswap: gr|eat rge|at\\n            // here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            boolean withswap = (\\n                    // left part of first and right part of second\\n                    isScramble(s1.substring(0, i), s2.substring(n - i))\\n\\n                            &&\\n\\n                            // right part of first and left part of second\\n                            isScramble(s1.substring(i), s2.substring(0, n - i))\\n            );\\n\\n            // if withswap give us right answer then we return true\\n            // otherwise the for loop do it work\\n            if (withswap) {\\n                mp.put(key, true);\\n                return true;\\n            }\\n            // we are not returning false in else case\\n            // because we want to check further cases with the for loop\\n        }\\n        mp.put(key, false);\\n        return false;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n//for storing already solved problems\\n    unordered_map<string,bool> mp;\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        //base cases\\n        \\n        int n = s1.size();\\n        \\n        //if both string are not equal in size\\n        if(s2.size()!=n)\\n            return false;\\n        \\n        //if both string are equal\\n        if(s1==s2)\\n         return true;   \\n        \\n            \\n        \\n        //if code is reached to this condition then following this are sure:\\n        //1. size of both string is equal\\n        //2.  string are not equal\\n        //so size is equal (where size==1) and they are not equal then obviously false\\n        //example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if(n==1)\\n            return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n\\t\\t//check if this problem has already been solved\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        //for every iteration it can two condition \\n        //1.we should proceed without swapping\\n        //2.we should swap before looking next\\n        for(int i=1;i<n;i++)\\n        {\\n\\n            //ex of without swap: gr|eat and rg|eat\\n            bool withoutswap = (\\n                //left part of first and second string\\n                isScramble(s1.substr(0,i),s2.substr(0,i)) \\n                \\n                &&\\n                \\n                //right part of first and second string;\\n                isScramble(s1.substr(i),s2.substr(i))\\n                );\\n            \\n            \\n            \\n            //if without swap give us right answer then we do not need \\n            //to call the recursion withswap\\n            if(withoutswap)\\n                return true;\\n            \\n            //ex of withswap: gr|eat  rge|at\\n\\t\\t\\t//here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            bool withswap = (\\n                //left part of first and right part of second \\n                isScramble(s1.substr(0,i),s2.substr(n-i)) \\n                \\n                &&\\n                \\n                //right part of first and left part of second\\n                isScramble(s1.substr(i),s2.substr(0,n-i)) \\n                );\\n            \\n            \\n            \\n            //if withswap give us right answer then we return true\\n            //otherwise the for loop do it work\\n            if(withswap)\\n                return true;\\n            //we are not returning false in else case \\n            //because we want to check further cases with the for loop\\n        }\\n        \\n        \\n        return mp[key] = false;\\n        \\n    }\\n};\\n```\\n``` Python []\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        # Base cases\\n\\n        n = len(s1)\\n\\n        # If both strings are not equal in size\\n        if len(s2) != n:\\n            return False\\n\\n        # If both strings are equal\\n        if s1 == s2:\\n            return True\\n\\n        # If code is reached to this condition then following this are sure:\\n        # 1. size of both string is equal\\n        # 2. string are not equal\\n        # so size is equal (where size==1) and they are not equal then obviously false\\n        # example \\'a\\' and \\'b\\' size is equal, string are not equal\\n        if n == 1:\\n            return False\\n\\n        key = s1 + \" \" + s2\\n\\n        # Check if this problem has already been solved\\n        if key in self.mp:\\n            return self.mp[key]\\n\\n        # For every iteration it can two condition\\n        # 1. We should proceed without swapping\\n        # 2. We should swap before looking next\\n        for i in range(1, n):\\n            # ex of without swap: gr|eat and rg|eat\\n            without_swap = (\\n                # Left part of first and second string\\n                self.isScramble(s1[:i], s2[:i])\\n                and\\n                # Right part of first and second string;\\n                self.isScramble(s1[i:], s2[i:])\\n            )\\n\\n            # If without swap gives us the right answer then we do not need\\n            # to call the recursion with swap\\n            if without_swap:\\n                return True\\n\\n            # ex of with swap: gr|eat rge|at\\n            # here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            with_swap = (\\n                # Left part of first and right part of second\\n                self.isScramble(s1[:i], s2[n-i:])\\n                and\\n                # Right part of first and left part of second\\n                self.isScramble(s1[i:], s2[:n-i])\\n            )\\n\\n            # If with swap gives us the right answer then we return True\\n            # otherwise, the for loop does its work\\n            if with_swap:\\n                return True\\n\\n        self.mp[key] = False\\n        return False\\n\\n    # for storing already solved problems\\n    mp = {}\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    // for storing already solved problems\\n    Map<String, Boolean> mp = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n\\n        // if both strings are not equal in size\\n        if (s2.length() != n)\\n            return false;\\n\\n        // if both strings are equal\\n        if (s1.equals(s2))\\n            return true;\\n\\n        // if code is reached to this condition then following this are sure:\\n        // 1. size of both string is equal\\n        // 2. string are not equal\\n        // so size is equal (where size==1) and they are not equal then obviously false\\n        // example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if (n == 1)\\n            return false;\\n\\n        String key = s1 + \" \" + s2;\\n\\n        // check if this problem has already been solved\\n        if (mp.containsKey(key))\\n            return mp.get(key);\\n\\n        // for every iteration it can two condition\\n        // 1.we should proceed without swapping\\n        // 2.we should swap before looking next\\n        for (int i = 1; i < n; i++) {\\n            // ex of without swap: gr|eat and rg|eat\\n            boolean withoutswap = (\\n                    // left part of first and second string\\n                    isScramble(s1.substring(0, i), s2.substring(0, i))\\n\\n                            &&\\n\\n                            // right part of first and second string;\\n                            isScramble(s1.substring(i), s2.substring(i))\\n            );\\n\\n            // if without swap give us right answer then we do not need\\n            // to call the recursion withswap\\n            if (withoutswap) {\\n                mp.put(key, true);\\n                return true;\\n            }\\n\\n            // ex of withswap: gr|eat rge|at\\n            // here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            boolean withswap = (\\n                    // left part of first and right part of second\\n                    isScramble(s1.substring(0, i), s2.substring(n - i))\\n\\n                            &&\\n\\n                            // right part of first and left part of second\\n                            isScramble(s1.substring(i), s2.substring(0, n - i))\\n            );\\n\\n            // if withswap give us right answer then we return true\\n            // otherwise the for loop do it work\\n            if (withswap) {\\n                mp.put(key, true);\\n                return true;\\n            }\\n            // we are not returning false in else case\\n            // because we want to check further cases with the for loop\\n        }\\n        mp.put(key, false);\\n        return false;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n//for storing already solved problems\\n    unordered_map<string,bool> mp;\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        //base cases\\n        \\n        int n = s1.size();\\n        \\n        //if both string are not equal in size\\n        if(s2.size()!=n)\\n            return false;\\n        \\n        //if both string are equal\\n        if(s1==s2)\\n         return true;   \\n        \\n            \\n        \\n        //if code is reached to this condition then following this are sure:\\n        //1. size of both string is equal\\n        //2.  string are not equal\\n        //so size is equal (where size==1) and they are not equal then obviously false\\n        //example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if(n==1)\\n            return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n\\t\\t//check if this problem has already been solved\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        //for every iteration it can two condition \\n        //1.we should proceed without swapping\\n        //2.we should swap before looking next\\n        for(int i=1;i<n;i++)\\n        {\\n\\n            //ex of without swap: gr|eat and rg|eat\\n            bool withoutswap = (\\n                //left part of first and second string\\n                isScramble(s1.substr(0,i),s2.substr(0,i)) \\n                \\n                &&\\n                \\n                //right part of first and second string;\\n                isScramble(s1.substr(i),s2.substr(i))\\n                );\\n            \\n            \\n            \\n            //if without swap give us right answer then we do not need \\n            //to call the recursion withswap\\n            if(withoutswap)\\n                return true;\\n            \\n            //ex of withswap: gr|eat  rge|at\\n\\t\\t\\t//here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            bool withswap = (\\n                //left part of first and right part of second \\n                isScramble(s1.substr(0,i),s2.substr(n-i)) \\n                \\n                &&\\n                \\n                //right part of first and left part of second\\n                isScramble(s1.substr(i),s2.substr(0,n-i)) \\n                );\\n            \\n            \\n            \\n            //if withswap give us right answer then we return true\\n            //otherwise the for loop do it work\\n            if(withswap)\\n                return true;\\n            //we are not returning false in else case \\n            //because we want to check further cases with the for loop\\n        }\\n        \\n        \\n        return mp[key] = false;\\n        \\n    }\\n};\\n```\n``` Python []\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        # Base cases\\n\\n        n = len(s1)\\n\\n        # If both strings are not equal in size\\n        if len(s2) != n:\\n            return False\\n\\n        # If both strings are equal\\n        if s1 == s2:\\n            return True\\n\\n        # If code is reached to this condition then following this are sure:\\n        # 1. size of both string is equal\\n        # 2. string are not equal\\n        # so size is equal (where size==1) and they are not equal then obviously false\\n        # example \\'a\\' and \\'b\\' size is equal, string are not equal\\n        if n == 1:\\n            return False\\n\\n        key = s1 + \" \" + s2\\n\\n        # Check if this problem has already been solved\\n        if key in self.mp:\\n            return self.mp[key]\\n\\n        # For every iteration it can two condition\\n        # 1. We should proceed without swapping\\n        # 2. We should swap before looking next\\n        for i in range(1, n):\\n            # ex of without swap: gr|eat and rg|eat\\n            without_swap = (\\n                # Left part of first and second string\\n                self.isScramble(s1[:i], s2[:i])\\n                and\\n                # Right part of first and second string;\\n                self.isScramble(s1[i:], s2[i:])\\n            )\\n\\n            # If without swap gives us the right answer then we do not need\\n            # to call the recursion with swap\\n            if without_swap:\\n                return True\\n\\n            # ex of with swap: gr|eat rge|at\\n            # here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            with_swap = (\\n                # Left part of first and right part of second\\n                self.isScramble(s1[:i], s2[n-i:])\\n                and\\n                # Right part of first and left part of second\\n                self.isScramble(s1[i:], s2[:n-i])\\n            )\\n\\n            # If with swap gives us the right answer then we return True\\n            # otherwise, the for loop does its work\\n            if with_swap:\\n                return True\\n\\n        self.mp[key] = False\\n        return False\\n\\n    # for storing already solved problems\\n    mp = {}\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29459,
                "title": "python-recursive-solution",
                "content": "    class Solution:\\n    # @return a boolean\\n    def isScramble(self, s1, s2):\\n        n, m = len(s1), len(s2)\\n        if n != m or sorted(s1) != sorted(s2):\\n            return False\\n        if n < 4 or s1 == s2:\\n            return True\\n        f = self.isScramble\\n        for i in range(1, n):\\n            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\\\\n               f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\\n                return True\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @return a boolean\\n    def isScramble(self, s1, s2):\\n        n, m = len(s1), len(s2)\\n        if n != m or sorted(s1) != sorted(s2):\\n            return False\\n        if n < 4 or s1 == s2:\\n            return True\\n        f = self.isScramble\\n        for i in range(1, n):\\n            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\\\\n               f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\\n                return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 3357574,
                "title": "day-364-100-java-c-python-explained-intution-dry-run-proof",
                "content": "\\n\\n# Happy Sri Ram Navami to all !! \\uD83D\\uDEA9\\uD83D\\uDEA9\\uD83D\\uDEA9\\n![image.png](https://assets.leetcode.com/users/images/a2267944-10b8-41f2-b624-81a67ccea163_1680148646.205976.png)\\n# NOTE:- if you found anyone\\'s post helpful please upvote that post because some persons are downvoting unneccesarily, and you are the one guys that save our post from getting unvisible, upvote for remains visible for others so and other people can also get benefitted.\\n\\n##### \\u2022\\tThere are several ways to solve the Scramble String problem\\n##### \\u2022\\tRecursion with memoization: This is the approach used in the solution we discussed earlier. The idea is to recursively check all possible splits of the two strings, and memoize the results to avoid recomputing the same substrings multiple times.\\n##### \\u2022\\tDynamic programming: This approach involves building a 3D table to store the results of all possible substrings of the two strings. The table is filled in a bottom-up manner, starting with the smallest substrings and building up to the largest substrings. The table can then be used to check if the two strings are scrambled versions of each other.\\n##### \\u2022\\tTop-down dynamic programming: This approach is similar to recursion with memoization, but uses a 3D table to store the results of all possible substrings of the two strings. The table is filled in a top-down manner, starting with the largest substrings and building down to the smallest substrings. The table can then be used to check if the two strings are scrambled versions of each other.\\n##### \\u2022\\tBFS: This approach involves using a queue to generate all possible scrambled versions of one of the strings, and checking if any of them match the other string. The idea is to generate all possible substrings of the first string, and then generate all possible permutations of each substring. The resulting strings can then be checked to see if they match the second string.\\n##### \\u2022\\tAll of these approaches have the same time and space complexity of O(n^4), but they differ in their implementation details and performance characteristics.\\n\\n# Intuition &  Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tThe problem is to determine if two strings s1 and s2 are scrambled versions of each other. The algorithm works by recursively splitting the strings into two non-empty substrings and swapping them randomly. The algorithm stops when the length of the string is 1.\\n##### \\u2022\\tThe approach used to solve the problem use a recursive function that checks if the two strings are scrambled versions of each other. The function checks if the two strings are equal, and if not, it checks if the two strings have the same characters and if the substrings of the two strings are scrambled versions of each other.\\n##### \\u2022\\tThe algorithm uses an unordered map to store the results of previously computed substrings to avoid recomputing them. It also uses three vectors to keep track of the frequency of characters in the two strings and the current substring being checked.\\n##### \\u2022\\tThe intuition behind the algorithm is that if two strings are scrambled versions of each other, then they can be split into two non-empty substrings that are also scrambled versions of each other. The algorithm checks all possible splits of the two strings and recursively checks if the substrings are scrambled versions of each other.\\n##### \\u2022\\tThe algorithm starts by checking if the two strings are equal. If they are, it returns true. If not, it initializes three vectors to keep track of the frequency of characters in the two strings and the current substring being checked. It then checks if the current substring of s1 and s2 have the same characters. If they do, it recursively checks if the substrings of s1 and s2 are scrambled versions of each other. If they are, it returns true.\\n##### \\u2022\\tIf the current substrings of s1 and s2 do not have the same characters, the algorithm checks all possible splits of the two strings. For each split, it checks if the substrings of s1 and s2 are scrambled versions of each other. If they are, it returns true.\\n##### \\u2022\\tThe algorithm uses an unordered map to store the results of previously computed substrings to avoid recomputing them. If the current substring of s1 and s2 has already been computed, the algorithm returns the stored result.\\n##### \\u2022\\tOverall, the algorithm uses a recursive approach to check if two strings are scrambled versions of each other. It uses an unordered map and three vectors to store previously computed substrings and keep track of the frequency of characters in the two strings and the current substring being checked.\\n\\n\\n# here\\'s the complete recursion tree for the isScramble method with  s1 = \"great\" and  s2 = \"rgeat\"\\n\\n```\\nisScramble(\"great\", \"rgeat\")\\n           /           |           |           |           \\\\\\nisScramble(\"g\", \"r\")  isScramble(\"g\", \"at\")  isScramble(\"gr\", \"ra\")  isScramble(\"gr\", \"eat\")  isScramble(\"gre\", \"rge\")\\n           |           /           |           |           |           \\\\           |           /           |\\nisScramble(\"\", \"\")  isScramble(\"g\", \"a\")  isScramble(\"g\", \"r\")  isScramble(\"g\", \"e\")  isScramble(\"g\", \"r\")  isScramble(\"g\", \"r\")  isScramble(\"gr\", \"e\")  isScramble(\"gr\", \"g\")  isScramble(\"gr\", \"er\")  isScramble(\"gr\", \"gea\")  isScramble(\"gre\", \"rg\")  isScramble(\"gre\", \"er\")\\n      /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\\\nfalse  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  true\\n```\\n\\n\\n# Code\\n```java []\\nclass Solution {\\n    // to store previously computed substrings\\n    Map<String, Boolean> map = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        // check if the two strings are equal\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        // initialize frequency arrays for s1, s2, and current substring\\n        int[] a = new int[26], b = new int[26], c = new int[26];\\n        // check if the current substring has already been computed\\n        if (map.containsKey(s1 + s2)) {\\n            return map.get(s1 + s2);\\n        }\\n        // check all possible splits of the two strings\\n        for (int i = 1; i <= n - 1; i++) {\\n            int j = n - i;\\n            // update frequency arrays for s1, s2, and current substring\\n            a[s1.charAt(i - 1) - \\'a\\']++;\\n            b[s2.charAt(i - 1) - \\'a\\']++;\\n            c[s2.charAt(j) - \\'a\\']++;\\n            // check if the current substring has the same characters\\n            if (Arrays.equals(a, b) && isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i))) {\\n                // if the substrings are scrambled versions of each other, return true\\n                map.put(s1 + s2, true);\\n                return true;\\n            }\\n            // check if the current substring and its complement have the same characters\\n            if (Arrays.equals(a, c) && isScramble(s1.substring(0, i), s2.substring(j)) && isScramble(s1.substring(i), s2.substring(0, j))) {\\n                // if the substrings are scrambled versions of each other, return true\\n                map.put(s1 + s2, true);\\n                return true;\\n            }\\n        }\\n        // if none of the splits result in scrambled versions, return false\\n        map.put(s1 + s2, false);\\n        return false;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution\\n{\\n\\t// unordered map to store previously computed substrings\\n\\tunordered_map<string,bool> mp;\\n\\npublic:\\n\\tbool isScramble(string s1, string s2)\\n\\t{\\n\\t\\tint n = s1.size();\\n\\t\\t// check if the two strings are equal\\n\\t\\tif (s1 == s2)\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t// initialize frequency vectors for s1, s2, and current substring\\n\\t\\tvector a(26, 0), b(26, 0), c(26, 0);\\n\\t\\t// check if the current substring has already been computed\\n\\t\\tif (mp.count(s1 + s2))\\n\\t\\t{\\n\\t\\t\\treturn mp[s1 + s2];\\n\\t\\t}\\n\\t\\t// check all possible splits of the two strings\\n\\t\\tfor (int i = 1; i <= n - 1; i++)\\n\\t\\t{\\n\\t\\t\\tint j = n - i;\\n\\t\\t\\t// update frequency vectors for s1, s2, and current substring\\n\\t\\t\\ta[s1[i - 1] - \\'a\\']++;\\n\\t\\t\\tb[s2[i - 1] - \\'a\\']++;\\n\\t\\t\\tc[s2[j] - \\'a\\']++;\\n\\t\\t\\t// check if the current substring has the same characters\\n\\t\\t\\tif (a == b && isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\\n\\t\\t\\t{\\n\\t\\t\\t\\t// if the substrings are scrambled versions of each other, return true\\n\\t\\t\\t\\tmp[s1 + s2] = true;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\t// check if the current substring and its complement have the same characters\\n\\t\\t\\tif (a == c && isScramble(s1.substr(0, i), s2.substr(j)) && isScramble(s1.substr(i), s2.substr(0, j)))\\n\\t\\t\\t{\\n\\t\\t\\t\\t// if the substrings are scrambled versions of each other, return true\\n\\t\\t\\t\\tmp[s1 + s2] = true;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// if none of the splits result in scrambled versions, return false\\n\\t\\tmp[s1 + s2] = false;\\n\\t\\treturn false;\\n\\t}\\n};\\n```\\n```python []\\nclass Solution:\\n    # dictionary to store previously computed substrings\\n    map = {}\\n\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        # check if the two strings are equal\\n        if s1 == s2:\\n            return True\\n        # initialize frequency lists for s1, s2, and current substring\\n        a, b, c = [0] * 26, [0] * 26, [0] * 26\\n        # check if the current substring has already been computed\\n        if (s1 + s2) in self.map:\\n            return self.map[s1 + s2]\\n        # check all possible splits of the two strings\\n        for i in range(1, n):\\n            j = n - i\\n            # update frequency lists for s1, s2, and current substring\\n            a[ord(s1[i - 1]) - ord(\\'a\\')] += 1\\n            b[ord(s2[i - 1]) - ord(\\'a\\')] += 1\\n            c[ord(s2[j]) - ord(\\'a\\')] += 1\\n            # check if the current substring has the same characters\\n            if a == b and self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                # if the substrings are scrambled versions of each other, return True\\n                self.map[s1 + s2] = True\\n                return True\\n            # check if the current substring and its complement have the same characters\\n            if a == c and self.isScramble(s1[:i], s2[j:]) and self.isScramble(s1[i:], s2[:j]):\\n                # if the substrings are scrambled versions of each other, return True\\n                self.map[s1 + s2] = True\\n                return True\\n        # if none of the splits result in scrambled versions, return False\\n        self.map[s1 + s2] = False\\n        return False\\n```\\n\\n\\n\\n# Complexity\\n\\n##### \\u2022\\tThe time complexity of the algorithm is O(n^4), n is the length of the strings. This is because the algorithm checks all possible splits of the two strings, which takes O(n^2) time, and for each split, it recursively checks if the substrings are scrambled versions of each other, which takes O(n^2) time in the worst case. Therefore, the overall time complexity is O(n^2 * n^2) = O(n^4).\\n##### \\u2022\\tThe space complexity of the algorithm is also O(n^4), due to the use of the unordered map to store previously computed substrings. In the worst case, the map can store all possible substrings of the two strings, which takes O(n^4) space. Additionally, the algorithm uses three arrays to keep track of the frequency of characters in the two strings and the current substring being checked, which also takes O(n^3) space in the worst case. Therefore, the overall space complexity is O(n^4).\\n##### \\u2022\\tHowever, the use of the unordered map to store previously computed substrings allows the algorithm to avoid recomputing the same substrings multiple times, which can significantly improve the performance of the algorithm for large inputs.\\n\\n\\n\\n\\n# DP  Intuition\\n##### \\u2022\\tThe problem involves checking if two strings are scrambled versions of each other.\\n##### \\u2022\\tWe have a recursive definition of scrambling a string s, which involves dividing s into x and y, and scrambling x and y independently.\\n##### \\u2022\\tTo check if a given string t is a scrambled string of s, we choose an index and cut s into x and y, and see if we can cut t into scrambled versions of x and y.\\n##### \\u2022\\tWe can solve the problem using dynamic programming by defining a 3D table with variables for length, i, and j to represent the subproblems.\\n##### \\u2022\\tEach state focuses on two substrings: a substring of s1 starting at index i with length equal to length, and a substring of s2 starting at index j with length equal to length.\\n##### \\u2022\\tWe use a base case for substrings of length 1 and fill the table for substrings of length 2 to n.\\n##### \\u2022\\tAt each state, we perform a split on s1 and consider all possible splits, and write down the transitions for each case.\\n##### \\u2022\\tThe answer to the problem is dp[n][0][0], where n is the length of the input strings.\\n#\\tAlgorithm:\\n##### \\u2022\\tIterate i from 0 to n-1.\\n##### \\u2022\\tIterate j from 0 to n-1.\\n##### \\u2022\\tSet dp[1][i][j] to the boolean value of s1[i] == s2[j] (the base case of the DP).\\n##### \\u2022\\tIterate length from 2 to n.\\n##### \\u2022\\tIterate i from 0 to n + 1 - length.\\n##### \\u2022\\tIterate j from 0 to n + 1 - length.\\n##### \\u2022\\tIterate newLength from 1 to length - 1.\\n##### \\u2022\\tIf dp[newLength][i][j] && dp[length-newLength][i+newLength][j+newLength]) || (dp[newLength][i][j+l-newLength] && dp[l-newLength][i+newLength][j] is true, set dp[length][i][j] to true.\\n##### \\u2022\\tReturn dp[n][0][0].\\n\\n\\n\\n```PYTHON []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        # Initialize a 3D table to store the results of all possible substrings of the two strings\\n        dp = [[[False for _ in range(n)] for _ in range(n)] for _ in range(n+1)]\\n\\n        # Initialize the table for substrings of length 1\\n        for i in range(n):\\n            for j in range(n):\\n                dp[1][i][j] = s1[i] == s2[j]\\n\\n        # Fill the table for substrings of length 2 to n\\n        for length in range(2, n+1):\\n            for i in range(n+1-length):\\n                for j in range(n+1-length):\\n                    # Iterate over all possible lengths of the first substring\\n                    for newLength in range(1, length):\\n                        # Check if the two possible splits of the substrings are scrambled versions of each other\\n                        dp1 = dp[newLength][i]\\n                        dp2 = dp[length-newLength][i+newLength]\\n                        dp[length][i][j] |= dp1[j] and dp2[j+newLength]\\n                        dp[length][i][j] |= dp1[j+length-newLength] and dp2[j]\\n\\n        # Return whether the entire strings s1 and s2 are scrambled versions of each other\\n        return dp[n][0][0]\\n```\\n```JAVA []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        // Initialize a 3D table to store the results of all possible substrings of the two strings\\n        boolean[][][] dp = new boolean[n+1][n][n];\\n\\n        // Initialize the table for substrings of length 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[1][i][j] = s1.charAt(i) == s2.charAt(j);\\n            }\\n        }\\n\\n        // Fill the table for substrings of length 2 to n\\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    // Iterate over all possible lengths of the first substring\\n                    for (int newLength = 1; newLength < length; newLength++) {\\n                        // Check if the two possible splits of the substrings are scrambled versions of each other\\n                        boolean[] dp1 = dp[newLength][i];\\n                        boolean[] dp2 = dp[length-newLength][i+newLength];\\n                        dp[length][i][j] |= dp1[j] && dp2[j+newLength];\\n                        dp[length][i][j] |= dp1[j+length-newLength] && dp2[j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return whether the entire strings s1 and s2 are scrambled versions of each other\\n        return dp[n][0][0];\\n    }\\n}\\n```\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.length();\\n        // Initialize a 3D table to store the results of all possible substrings of the two strings\\n        vector<vector<vector<bool>>> dp(n+1, vector<vector<bool>>(n, vector<bool>(n)));\\n\\n        // Initialize the table for substrings of length 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[1][i][j] = s1[i] == s2[j];\\n            }\\n        }\\n\\n        // Fill the table for substrings of length 2 to n\\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    // Iterate over all possible lengths of the first substring\\n                    for (int newLength = 1; newLength < length; newLength++) {\\n                        // Check if the two possible splits of the substrings are scrambled versions of each other\\n                        vector<bool>& dp1 = dp[newLength][i];\\n                        vector<bool>& dp2 = dp[length-newLength][i+newLength];\\n                        dp[length][i][j] |= dp1[j] && dp2[j+newLength];\\n                        dp[length][i][j] |= dp1[j+length-newLength] && dp2[j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return whether the entire strings s1 and s2 are scrambled versions of each other\\n        return dp[n][0][0];\\n    }\\n};\\n```\\n\\n# TC & SC\\n\\n##### \\u2022\\tThe time complexity of this algorithm is O(n^4), and the space complexity is also O(n^4), due to the use of the 3D table. \\n##### \\u2022\\tHowever, this approach can be faster than the recursive approach with memoization for some inputs, since it avoids the overhead of function calls and memoization lookups.\\n\\n\\n# 3RD WAY RECURSIVE \\n\\n\\n```C++ []\\nclass Solution {\\n    bool isScrambleHelper(unordered_map<string, bool> &memo, string s1, string s2) {\\n        int i, len = s1.size();\\n        bool result = false;\\n\\n        // Base cases\\n        if (len == 0) {\\n            return true;\\n        } else if (len == 1) {\\n            return s1 == s2;\\n        } else {\\n            // Check if we have already computed the result for this pair of strings\\n            if (memo.count(s1 + s2)) {\\n                return memo[s1 + s2];\\n            }\\n\\n            // Check if the two strings are equal\\n            if (s1 == s2) {\\n                result = true;\\n            } else {\\n                // Check all possible split positions\\n                for (i = 1; i < len && !result; ++i) {\\n                    // Check if s1[0..i-1] and s2[0..i-1] are valid scrambles of each other\\n                    // and if s1[i..len-1] and s2[i..len-1] are valid scrambles of each other\\n                    result = result || (isScrambleHelper(memo, s1.substr(0, i), s2.substr(0, i)) && isScrambleHelper(memo, s1.substr(i, len - i), s2.substr(i, len - i)));\\n\\n                    // Check if s1[0..i-1] and s2[len-i..len-1] are valid scrambles of each other\\n                    // and if s1[i..len-1] and s2[0..len-i-1] are valid scrambles of each other\\n                    result = result || (isScrambleHelper(memo, s1.substr(0, i), s2.substr(len - i, i)) && isScrambleHelper(memo, s1.substr(i, len - i), s2.substr(0, len - i)));\\n                }\\n            }\\n\\n            // Save the intermediate result in the memoization table\\n            return memo[s1 + s2] = result;\\n        }\\n    }\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string, bool> memo;\\n        return isScrambleHelper(memo, s1, s2);\\n    }\\n};\\n```\\n```PYTHON []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        if n != len(s2):\\n            return False\\n        if n == 0:\\n            return True\\n        elif n == 1:\\n            return s1 == s2\\n        else:\\n            memo = {}\\n            return self.isScrambleHelper(memo, s1, s2)\\n\\n    def isScrambleHelper(self, memo: dict, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        result = False\\n\\n        if n == 0:\\n            return True\\n        elif n == 1:\\n            return s1 == s2\\n        else:\\n            if (s1, s2) in memo:\\n                return memo[(s1, s2)]\\n\\n            if s1 == s2:\\n                result = True\\n            else:\\n                for i in range(1, n):\\n                    result = (self.isScrambleHelper(memo, s1[:i], s2[:i]) and self.isScrambleHelper(memo, s1[i:], s2[i:])) or \\\\\\n                             (self.isScrambleHelper(memo, s1[:i], s2[n - i:]) and self.isScrambleHelper(memo, s1[i:], s2[:n - i]))\\n                    if result:\\n                        break\\n\\n            memo[(s1, s2)] = result\\n            return result\\n```\\n```JAVA []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        int len = s1.length();\\n        if (len != s2.length()) {\\n            return false;\\n        }\\n        if (len == 0) {\\n            return true;\\n        } else if (len == 1) {\\n            return s1.equals(s2);\\n        } else {\\n            Map<String, Boolean> memo = new HashMap<>();\\n            return isScrambleHelper(memo, s1, s2);\\n        }\\n    }\\n\\n    private boolean isScrambleHelper(Map<String, Boolean> memo, String s1, String s2) {\\n        int len = s1.length();\\n        boolean result = false;\\n\\n        if (len == 0) {\\n            return true;\\n        } else if (len == 1) {\\n            return s1.equals(s2);\\n        } else {\\n            if (memo.containsKey(s1 + s2)) {\\n                return memo.get(s1 + s2);\\n            }\\n\\n            if (s1.equals(s2)) {\\n                result = true;\\n            } else {\\n                for (int i = 1; i < len && !result; i++) {\\n                    result = (isScrambleHelper(memo, s1.substring(0, i), s2.substring(0, i)) && isScrambleHelper(memo, s1.substring(i), s2.substring(i))) ||\\n                             (isScrambleHelper(memo, s1.substring(0, i), s2.substring(len - i)) && isScrambleHelper(memo, s1.substring(i), s2.substring(0, len - i)));\\n                }\\n            }\\n\\n            memo.put(s1 + s2, result);\\n            return result;\\n        }\\n    }\\n}\\n```\\n\\n# TC & SC\\n\\n##### \\u2022\\tThe time complexity of the given solution is O(n^4), where n is the length of the input strings. This is because we are checking all possible split positions for each substring, which takes O(n^2) time, and we are doing this for all possible substrings, which takes another O(n^2) time. The recursive calls also add to the time complexity.\\n##### \\u2022\\tThe space complexity of the given solution is O(n^3), which is the size of the memoization table. This is because we are storing the results of all possible substring pairs in the memoization table.\\n\\n# 4th way  cache is implemented\\n```c++ []\\nclass Solution {\\nprivate:\\n   bool DP_helper(string &s1, string &s2, int idx1, int idx2, int len, char isS[]) {\\n        int sSize = s1.size(), i, j, k, hist[26], zero_count = 0;\\n\\n        // Check if we have already computed the result for this substring pair\\n        if (isS[(len * sSize + idx1) * sSize + idx2]) {\\n            return isS[(len * sSize + idx1) * sSize + idx2] == 1;\\n        }\\n\\n        bool res = false;\\n\\n        // Count the frequency of each character in the two substrings\\n        fill_n(hist, 26, 0);\\n        for (k = 0; k < len; ++k) {\\n            zero_count += (0 == hist[s1[idx1 + k] - \\'a\\']) - (0 == ++hist[s1[idx1 + k] - \\'a\\']);\\n            zero_count += (0 == hist[s2[idx2 + k] - \\'a\\']) - (0 == --hist[s2[idx2 + k] - \\'a\\']);\\n        }\\n\\n        // If the two substrings have different characters, return false\\n        if (zero_count) {\\n            isS[(len * sSize + idx1) * sSize + idx2] = 2;\\n            return false;\\n        }\\n\\n        // If the length of the substrings is 1, return true\\n        if (len == 1) {\\n            isS[(len * sSize + idx1) * sSize + idx2] = 1;\\n            return true;\\n        }\\n\\n        // Recursively check all possible split positions\\n        for (k = 1; k < len && !res; ++k) {\\n            res = res || (DP_helper(s1, s2, idx1, idx2, k, isS) && DP_helper(s1, s2, idx1 + k, idx2 + k, len - k, isS));\\n            res = res || (DP_helper(s1, s2, idx1 + len - k, idx2, k, isS) && DP_helper(s1, s2, idx1, idx2 + k, len - k, isS));\\n        }\\n\\n        // Save the intermediate result in the cache\\n        isS[(len * sSize + idx1) * sSize + idx2] = res ? 1 : 2;\\n        return res;\\n    }\\n\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        const int sSize = s1.size();\\n\\n        // Base case: empty strings are always valid scrambles of each other\\n        if (0 == sSize) {\\n            return true;\\n        }\\n\\n        // Initialize the cache\\n        char isS[(sSize + 1) * sSize * sSize];\\n        fill_n(isS, (sSize + 1) * sSize * sSize, 0);\\n\\n        // Recursively check if s1 and s2 are valid scrambles of each other\\n        return DP_helper(s1, s2, 0, 0, sSize, isS);\\n    }\\n};\\n```\\n# explaination \\n\\n##### \\u2022\\tIt does this by recursively checking all possible split positions of the two strings, and caching the intermediate results to avoid redundant computations. \\n##### \\u2022\\tThe cache is implemented as a one-dimensional array isS , where isS[idx1 * sSize + idx2 + len * sSize * sSize] stores the result of checking whether the substring of s1 starting at index idx1 and the substring of s2 starting at index idx2 , both of length len , are valid scrambles of each other. The value of isS[idx1 * sSize + idx2 + len * sSize * sSize] can be either 0 (not computed yet), 1 (valid scramble), or 2 (invalid scramble). \\n##### \\u2022\\tThe recursion is implemented in the DP_helper function, which takes as input the two strings s1 and s2 , the starting indices idx1 and idx2 , the length len , and the cache isS . \\n##### \\u2022\\tThe function first checks if the result for this substring pair has already been computed and cached, and returns the cached result if it exists. \\n##### \\u2022\\tOtherwise, it counts the frequency of each character in the two substrings, and returns false if the two substrings have different characters. If the length of the substrings is 1, the function returns true.\\n##### \\u2022\\tIf the two substrings have the same character set, the function recursively checks all possible split positions and returns true if any of them are valid scrambles of each other. \\n##### \\u2022\\tFinally, the function saves the intermediate result in the cache and returns the result. \\n##### \\u2022\\tTo optimize the recursion, the function uses early pruning by checking if the two substrings have the same character set before recursively checking all possible split positions. \\n##### \\u2022\\tIf the two substrings have different character sets, the function immediately returns false without doing any further computation. \\n##### \\u2022\\tThis helps to reduce the number of recursive calls and improve the overall performance of the algorithm.\\n\\n\\n# DRY RUN 1\\n\\n##### \\u2022\\tLet\\'s dry run the algorithm with the input \"great\" andrgeat\".\\n##### \\u2022\\tFirst, the algorithm checks if the two strings are equal. Since they are not, it initializes the frequency vectors for s1, s2, and the current substring, and checks if the current substring has already been computed in the unordered map. Since it has not, the algorithm proceeds to check all possible splits of the two strings.\\n##### \\u2022\\tFor the first split, i = 1 and j = 4. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"g\" and \"r\" are different, the algorithm moves on to the next split.\\n##### \\u2022\\tFor the second split, i = 2 and j = 3. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"gr\" and \"rg\" have the same characters, the algorithm recursively checks if the substrings of s1 and s2 are scrambled versions of each other. It does this by calling the isScramble function with the substrings \"g\" and \"r\" for both s1 and s2. Since \"g\" and \"r\" are not scrambled versions of each other, the algorithm backtracks and checks the other possible split.\\n##### \\u2022\\tFor the third split, i = 3 and j = 2. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"gre\" and \"rge\" have the same characters, the algorithm recursively checks if the substrings of s1 and s2 are scrambled versions of each other. It does this by calling the isScramble function with the substrings \"g\" and \"r\" for s1 and s2, and the substrings \"re\" and \"eat\" for s1 and s2. Since \"g\" and \"r\" are not scrambled versions of each other, the algorithm backtracks and checks the other possible split.\\n##### \\u2022\\tFor the fourth split, i = 4 and j = 1. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"reat\" and \"rgea\" have the same characters, the algorithm recursively checks if the substrings of s1 and s2 are scrambled versions of each other. It does this by calling the  isScramble function with the substrings \"r\" and \"r\" for s1 and s2, and the substrings \"eat\" and \"gea\" for s1 and s2. Since \"r\" and \"r\" are scrambled versions of each other, the algorithm proceeds to check if \"eat\" and \"gea\" are scrambled versions of each other. It does this by calling the  isScramble function with the substrings \"e\" and \"e\" for s1 and s2, and the substrings \"at\" and \"ga\" for s1 and s2. Since \"e\" and \"e\" are scrambled versions of each other, the algorithm proceeds to check if \"at\" and \"ga\" are scrambled versions of each other. It does this by calling the  isScramble function with the substrings \"a\" and \"a\" for s1 and s2, and the substrings \"t\" and \"g\" for s1 and s2. Since \"a\" and \"a\" are scrambled versions of each other, and \"t\" and \"g\" are scrambled versions of each other, the algorithm returns true.\\n##### \\u2022\\tTherefore, the output of the algorithm for the input \"great\" and \"rgeat\" is true, indicating that the two strings are scrambled versions of each other.\\n\\n# DRY RUN 2\\n##### \\u2022\\tLet\\'s dry run the algorithm with the input \"abcde\" and \"caebd\".\\n##### \\u2022\\tFirst, the algorithm checks if the two strings are equal. Since they are not, it initializes the frequency vectors for s1, s2, and the current substring, and checks if the current substring has already been computed in the unordered map. Since it has not, the algorithm proceeds to check all possible splits of the two strings.\\n##### \\u2022\\tFor the first split, i = 1 and j = 4. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"a\" and \"c\" are different, the algorithm moves on to the next split.\\n##### \\u2022\\tFor the second split, i = 2 and j = 3. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"ab\" and \"ca\" have different characters, the algorithm moves on to the next split.\\n##### \\u2022\\tFor the third split, i = 3 and j = 2. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"abc\" and \"cae\" have different characters, the algorithm moves on to the next split.\\n##### \\u2022\\tFor the fourth split, i = 4 and j = 1. The algorithm updates the frequency vectors for s1, s2, and the current substring, and checks if the current substring has the same characters. Since \"abcd\" and \"caeb\" have different characters, the algorithm moves on to the next split.\\n##### \\u2022\\tSince none of the splits result in scrambled versions of each other, the algorithm returns false.\\n##### \\u2022\\tTherefore, the output of the algorithm for the input \"abcde\" and \"caebd\" is false, indicating that the two strings are not scrambled versions of each other.\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n\\n![meme2.png](https://assets.leetcode.com/users/images/d588f492-3f95-45f6-8e4a-10d6069002a5_1680054021.7117147.png)\\n\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nisScramble(\"great\", \"rgeat\")\\n           /           |           |           |           \\\\\\nisScramble(\"g\", \"r\")  isScramble(\"g\", \"at\")  isScramble(\"gr\", \"ra\")  isScramble(\"gr\", \"eat\")  isScramble(\"gre\", \"rge\")\\n           |           /           |           |           |           \\\\           |           /           |\\nisScramble(\"\", \"\")  isScramble(\"g\", \"a\")  isScramble(\"g\", \"r\")  isScramble(\"g\", \"e\")  isScramble(\"g\", \"r\")  isScramble(\"g\", \"r\")  isScramble(\"gr\", \"e\")  isScramble(\"gr\", \"g\")  isScramble(\"gr\", \"er\")  isScramble(\"gr\", \"gea\")  isScramble(\"gre\", \"rg\")  isScramble(\"gre\", \"er\")\\n      /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\           /      \\\\\\nfalse  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  false  true\\n```\n```java []\\nclass Solution {\\n    // to store previously computed substrings\\n    Map<String, Boolean> map = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        // check if the two strings are equal\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        // initialize frequency arrays for s1, s2, and current substring\\n        int[] a = new int[26], b = new int[26], c = new int[26];\\n        // check if the current substring has already been computed\\n        if (map.containsKey(s1 + s2)) {\\n            return map.get(s1 + s2);\\n        }\\n        // check all possible splits of the two strings\\n        for (int i = 1; i <= n - 1; i++) {\\n            int j = n - i;\\n            // update frequency arrays for s1, s2, and current substring\\n            a[s1.charAt(i - 1) - \\'a\\']++;\\n            b[s2.charAt(i - 1) - \\'a\\']++;\\n            c[s2.charAt(j) - \\'a\\']++;\\n            // check if the current substring has the same characters\\n            if (Arrays.equals(a, b) && isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i))) {\\n                // if the substrings are scrambled versions of each other, return true\\n                map.put(s1 + s2, true);\\n                return true;\\n            }\\n            // check if the current substring and its complement have the same characters\\n            if (Arrays.equals(a, c) && isScramble(s1.substring(0, i), s2.substring(j)) && isScramble(s1.substring(i), s2.substring(0, j))) {\\n                // if the substrings are scrambled versions of each other, return true\\n                map.put(s1 + s2, true);\\n                return true;\\n            }\\n        }\\n        // if none of the splits result in scrambled versions, return false\\n        map.put(s1 + s2, false);\\n        return false;\\n    }\\n}\\n```\n```c++ []\\nclass Solution\\n{\\n\\t// unordered map to store previously computed substrings\\n\\tunordered_map<string,bool> mp;\\n\\npublic:\\n\\tbool isScramble(string s1, string s2)\\n\\t{\\n\\t\\tint n = s1.size();\\n\\t\\t// check if the two strings are equal\\n\\t\\tif (s1 == s2)\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t// initialize frequency vectors for s1, s2, and current substring\\n\\t\\tvector a(26, 0), b(26, 0), c(26, 0);\\n\\t\\t// check if the current substring has already been computed\\n\\t\\tif (mp.count(s1 + s2))\\n\\t\\t{\\n\\t\\t\\treturn mp[s1 + s2];\\n\\t\\t}\\n\\t\\t// check all possible splits of the two strings\\n\\t\\tfor (int i = 1; i <= n - 1; i++)\\n\\t\\t{\\n\\t\\t\\tint j = n - i;\\n\\t\\t\\t// update frequency vectors for s1, s2, and current substring\\n\\t\\t\\ta[s1[i - 1] - \\'a\\']++;\\n\\t\\t\\tb[s2[i - 1] - \\'a\\']++;\\n\\t\\t\\tc[s2[j] - \\'a\\']++;\\n\\t\\t\\t// check if the current substring has the same characters\\n\\t\\t\\tif (a == b && isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\\n\\t\\t\\t{\\n\\t\\t\\t\\t// if the substrings are scrambled versions of each other, return true\\n\\t\\t\\t\\tmp[s1 + s2] = true;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\t// check if the current substring and its complement have the same characters\\n\\t\\t\\tif (a == c && isScramble(s1.substr(0, i), s2.substr(j)) && isScramble(s1.substr(i), s2.substr(0, j)))\\n\\t\\t\\t{\\n\\t\\t\\t\\t// if the substrings are scrambled versions of each other, return true\\n\\t\\t\\t\\tmp[s1 + s2] = true;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// if none of the splits result in scrambled versions, return false\\n\\t\\tmp[s1 + s2] = false;\\n\\t\\treturn false;\\n\\t}\\n};\\n```\n```python []\\nclass Solution:\\n    # dictionary to store previously computed substrings\\n    map = {}\\n\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        # check if the two strings are equal\\n        if s1 == s2:\\n            return True\\n        # initialize frequency lists for s1, s2, and current substring\\n        a, b, c = [0] * 26, [0] * 26, [0] * 26\\n        # check if the current substring has already been computed\\n        if (s1 + s2) in self.map:\\n            return self.map[s1 + s2]\\n        # check all possible splits of the two strings\\n        for i in range(1, n):\\n            j = n - i\\n            # update frequency lists for s1, s2, and current substring\\n            a[ord(s1[i - 1]) - ord(\\'a\\')] += 1\\n            b[ord(s2[i - 1]) - ord(\\'a\\')] += 1\\n            c[ord(s2[j]) - ord(\\'a\\')] += 1\\n            # check if the current substring has the same characters\\n            if a == b and self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                # if the substrings are scrambled versions of each other, return True\\n                self.map[s1 + s2] = True\\n                return True\\n            # check if the current substring and its complement have the same characters\\n            if a == c and self.isScramble(s1[:i], s2[j:]) and self.isScramble(s1[i:], s2[:j]):\\n                # if the substrings are scrambled versions of each other, return True\\n                self.map[s1 + s2] = True\\n                return True\\n        # if none of the splits result in scrambled versions, return False\\n        self.map[s1 + s2] = False\\n        return False\\n```\n```PYTHON []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        # Initialize a 3D table to store the results of all possible substrings of the two strings\\n        dp = [[[False for _ in range(n)] for _ in range(n)] for _ in range(n+1)]\\n\\n        # Initialize the table for substrings of length 1\\n        for i in range(n):\\n            for j in range(n):\\n                dp[1][i][j] = s1[i] == s2[j]\\n\\n        # Fill the table for substrings of length 2 to n\\n        for length in range(2, n+1):\\n            for i in range(n+1-length):\\n                for j in range(n+1-length):\\n                    # Iterate over all possible lengths of the first substring\\n                    for newLength in range(1, length):\\n                        # Check if the two possible splits of the substrings are scrambled versions of each other\\n                        dp1 = dp[newLength][i]\\n                        dp2 = dp[length-newLength][i+newLength]\\n                        dp[length][i][j] |= dp1[j] and dp2[j+newLength]\\n                        dp[length][i][j] |= dp1[j+length-newLength] and dp2[j]\\n\\n        # Return whether the entire strings s1 and s2 are scrambled versions of each other\\n        return dp[n][0][0]\\n```\n```JAVA []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        // Initialize a 3D table to store the results of all possible substrings of the two strings\\n        boolean[][][] dp = new boolean[n+1][n][n];\\n\\n        // Initialize the table for substrings of length 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[1][i][j] = s1.charAt(i) == s2.charAt(j);\\n            }\\n        }\\n\\n        // Fill the table for substrings of length 2 to n\\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    // Iterate over all possible lengths of the first substring\\n                    for (int newLength = 1; newLength < length; newLength++) {\\n                        // Check if the two possible splits of the substrings are scrambled versions of each other\\n                        boolean[] dp1 = dp[newLength][i];\\n                        boolean[] dp2 = dp[length-newLength][i+newLength];\\n                        dp[length][i][j] |= dp1[j] && dp2[j+newLength];\\n                        dp[length][i][j] |= dp1[j+length-newLength] && dp2[j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return whether the entire strings s1 and s2 are scrambled versions of each other\\n        return dp[n][0][0];\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.length();\\n        // Initialize a 3D table to store the results of all possible substrings of the two strings\\n        vector<vector<vector<bool>>> dp(n+1, vector<vector<bool>>(n, vector<bool>(n)));\\n\\n        // Initialize the table for substrings of length 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[1][i][j] = s1[i] == s2[j];\\n            }\\n        }\\n\\n        // Fill the table for substrings of length 2 to n\\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    // Iterate over all possible lengths of the first substring\\n                    for (int newLength = 1; newLength < length; newLength++) {\\n                        // Check if the two possible splits of the substrings are scrambled versions of each other\\n                        vector<bool>& dp1 = dp[newLength][i];\\n                        vector<bool>& dp2 = dp[length-newLength][i+newLength];\\n                        dp[length][i][j] |= dp1[j] && dp2[j+newLength];\\n                        dp[length][i][j] |= dp1[j+length-newLength] && dp2[j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return whether the entire strings s1 and s2 are scrambled versions of each other\\n        return dp[n][0][0];\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\n    bool isScrambleHelper(unordered_map<string, bool> &memo, string s1, string s2) {\\n        int i, len = s1.size();\\n        bool result = false;\\n\\n        // Base cases\\n        if (len == 0) {\\n            return true;\\n        } else if (len == 1) {\\n            return s1 == s2;\\n        } else {\\n            // Check if we have already computed the result for this pair of strings\\n            if (memo.count(s1 + s2)) {\\n                return memo[s1 + s2];\\n            }\\n\\n            // Check if the two strings are equal\\n            if (s1 == s2) {\\n                result = true;\\n            } else {\\n                // Check all possible split positions\\n                for (i = 1; i < len && !result; ++i) {\\n                    // Check if s1[0..i-1] and s2[0..i-1] are valid scrambles of each other\\n                    // and if s1[i..len-1] and s2[i..len-1] are valid scrambles of each other\\n                    result = result || (isScrambleHelper(memo, s1.substr(0, i), s2.substr(0, i)) && isScrambleHelper(memo, s1.substr(i, len - i), s2.substr(i, len - i)));\\n\\n                    // Check if s1[0..i-1] and s2[len-i..len-1] are valid scrambles of each other\\n                    // and if s1[i..len-1] and s2[0..len-i-1] are valid scrambles of each other\\n                    result = result || (isScrambleHelper(memo, s1.substr(0, i), s2.substr(len - i, i)) && isScrambleHelper(memo, s1.substr(i, len - i), s2.substr(0, len - i)));\\n                }\\n            }\\n\\n            // Save the intermediate result in the memoization table\\n            return memo[s1 + s2] = result;\\n        }\\n    }\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string, bool> memo;\\n        return isScrambleHelper(memo, s1, s2);\\n    }\\n};\\n```\n```PYTHON []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        if n != len(s2):\\n            return False\\n        if n == 0:\\n            return True\\n        elif n == 1:\\n            return s1 == s2\\n        else:\\n            memo = {}\\n            return self.isScrambleHelper(memo, s1, s2)\\n\\n    def isScrambleHelper(self, memo: dict, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        result = False\\n\\n        if n == 0:\\n            return True\\n        elif n == 1:\\n            return s1 == s2\\n        else:\\n            if (s1, s2) in memo:\\n                return memo[(s1, s2)]\\n\\n            if s1 == s2:\\n                result = True\\n            else:\\n                for i in range(1, n):\\n                    result = (self.isScrambleHelper(memo, s1[:i], s2[:i]) and self.isScrambleHelper(memo, s1[i:], s2[i:])) or \\\\\\n                             (self.isScrambleHelper(memo, s1[:i], s2[n - i:]) and self.isScrambleHelper(memo, s1[i:], s2[:n - i]))\\n                    if result:\\n                        break\\n\\n            memo[(s1, s2)] = result\\n            return result\\n```\n```JAVA []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        int len = s1.length();\\n        if (len != s2.length()) {\\n            return false;\\n        }\\n        if (len == 0) {\\n            return true;\\n        } else if (len == 1) {\\n            return s1.equals(s2);\\n        } else {\\n            Map<String, Boolean> memo = new HashMap<>();\\n            return isScrambleHelper(memo, s1, s2);\\n        }\\n    }\\n\\n    private boolean isScrambleHelper(Map<String, Boolean> memo, String s1, String s2) {\\n        int len = s1.length();\\n        boolean result = false;\\n\\n        if (len == 0) {\\n            return true;\\n        } else if (len == 1) {\\n            return s1.equals(s2);\\n        } else {\\n            if (memo.containsKey(s1 + s2)) {\\n                return memo.get(s1 + s2);\\n            }\\n\\n            if (s1.equals(s2)) {\\n                result = true;\\n            } else {\\n                for (int i = 1; i < len && !result; i++) {\\n                    result = (isScrambleHelper(memo, s1.substring(0, i), s2.substring(0, i)) && isScrambleHelper(memo, s1.substring(i), s2.substring(i))) ||\\n                             (isScrambleHelper(memo, s1.substring(0, i), s2.substring(len - i)) && isScrambleHelper(memo, s1.substring(i), s2.substring(0, len - i)));\\n                }\\n            }\\n\\n            memo.put(s1 + s2, result);\\n            return result;\\n        }\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\nprivate:\\n   bool DP_helper(string &s1, string &s2, int idx1, int idx2, int len, char isS[]) {\\n        int sSize = s1.size(), i, j, k, hist[26], zero_count = 0;\\n\\n        // Check if we have already computed the result for this substring pair\\n        if (isS[(len * sSize + idx1) * sSize + idx2]) {\\n            return isS[(len * sSize + idx1) * sSize + idx2] == 1;\\n        }\\n\\n        bool res = false;\\n\\n        // Count the frequency of each character in the two substrings\\n        fill_n(hist, 26, 0);\\n        for (k = 0; k < len; ++k) {\\n            zero_count += (0 == hist[s1[idx1 + k] - \\'a\\']) - (0 == ++hist[s1[idx1 + k] - \\'a\\']);\\n            zero_count += (0 == hist[s2[idx2 + k] - \\'a\\']) - (0 == --hist[s2[idx2 + k] - \\'a\\']);\\n        }\\n\\n        // If the two substrings have different characters, return false\\n        if (zero_count) {\\n            isS[(len * sSize + idx1) * sSize + idx2] = 2;\\n            return false;\\n        }\\n\\n        // If the length of the substrings is 1, return true\\n        if (len == 1) {\\n            isS[(len * sSize + idx1) * sSize + idx2] = 1;\\n            return true;\\n        }\\n\\n        // Recursively check all possible split positions\\n        for (k = 1; k < len && !res; ++k) {\\n            res = res || (DP_helper(s1, s2, idx1, idx2, k, isS) && DP_helper(s1, s2, idx1 + k, idx2 + k, len - k, isS));\\n            res = res || (DP_helper(s1, s2, idx1 + len - k, idx2, k, isS) && DP_helper(s1, s2, idx1, idx2 + k, len - k, isS));\\n        }\\n\\n        // Save the intermediate result in the cache\\n        isS[(len * sSize + idx1) * sSize + idx2] = res ? 1 : 2;\\n        return res;\\n    }\\n\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        const int sSize = s1.size();\\n\\n        // Base case: empty strings are always valid scrambles of each other\\n        if (0 == sSize) {\\n            return true;\\n        }\\n\\n        // Initialize the cache\\n        char isS[(sSize + 1) * sSize * sSize];\\n        fill_n(isS, (sSize + 1) * sSize * sSize, 0);\\n\\n        // Recursively check if s1 and s2 are valid scrambles of each other\\n        return DP_helper(s1, s2, 0, 0, sSize, isS);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227919,
                "title": "well-commented-code-dp-memoization-mcm",
                "content": "```\\nclass Solution {\\npublic:\\n//for storing already solved problems\\n    unordered_map<string,bool> mp;\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        //base cases\\n        \\n        int n = s1.size();\\n        \\n        //if both string are not equal in size\\n        if(s2.size()!=n)\\n            return false;\\n        \\n        //if both string are equal\\n        if(s1==s2)\\n         return true;   \\n        \\n            \\n        \\n        //if code is reached to this condition then following this are sure:\\n        //1. size of both string is equal\\n        //2.  string are not equal\\n        //so size is equal (where size==1) and they are not equal then obviously false\\n        //example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if(n==1)\\n            return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n\\t\\t//check if this problem has already been solved\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        //for every iteration it can two condition \\n        //1.we should proceed without swapping\\n        //2.we should swap before looking next\\n        for(int i=1;i<n;i++)\\n        {\\n\\n            //ex of without swap: gr|eat and rg|eat\\n            bool withoutswap = (\\n                //left part of first and second string\\n                isScramble(s1.substr(0,i),s2.substr(0,i)) \\n                \\n                &&\\n                \\n                //right part of first and second string;\\n                isScramble(s1.substr(i),s2.substr(i))\\n                );\\n            \\n            \\n            \\n            //if without swap give us right answer then we do not need \\n            //to call the recursion withswap\\n            if(withoutswap)\\n                return true;\\n            \\n            //ex of withswap: gr|eat  rge|at\\n\\t\\t\\t//here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            bool withswap = (\\n                //left part of first and right part of second \\n                isScramble(s1.substr(0,i),s2.substr(n-i)) \\n                \\n                &&\\n                \\n                //right part of first and left part of second\\n                isScramble(s1.substr(i),s2.substr(0,n-i)) \\n                );\\n            \\n            \\n            \\n            //if withswap give us right answer then we return true\\n            //otherwise the for loop do it work\\n            if(withswap)\\n                return true;\\n            //we are not returning false in else case \\n            //because we want to check further cases with the for loop\\n        }\\n        \\n        \\n        return mp[key] = false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//for storing already solved problems\\n    unordered_map<string,bool> mp;\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        //base cases\\n        \\n        int n = s1.size();\\n        \\n        //if both string are not equal in size\\n        if(s2.size()!=n)\\n            return false;\\n        \\n        //if both string are equal\\n        if(s1==s2)\\n         return true;   \\n        \\n            \\n        \\n        //if code is reached to this condition then following this are sure:\\n        //1. size of both string is equal\\n        //2.  string are not equal\\n        //so size is equal (where size==1) and they are not equal then obviously false\\n        //example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if(n==1)\\n            return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n\\t\\t//check if this problem has already been solved\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        //for every iteration it can two condition \\n        //1.we should proceed without swapping\\n        //2.we should swap before looking next\\n        for(int i=1;i<n;i++)\\n        {\\n\\n            //ex of without swap: gr|eat and rg|eat\\n            bool withoutswap = (\\n                //left part of first and second string\\n                isScramble(s1.substr(0,i),s2.substr(0,i)) \\n                \\n                &&\\n                \\n                //right part of first and second string;\\n                isScramble(s1.substr(i),s2.substr(i))\\n                );\\n            \\n            \\n            \\n            //if without swap give us right answer then we do not need \\n            //to call the recursion withswap\\n            if(withoutswap)\\n                return true;\\n            \\n            //ex of withswap: gr|eat  rge|at\\n\\t\\t\\t//here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            bool withswap = (\\n                //left part of first and right part of second \\n                isScramble(s1.substr(0,i),s2.substr(n-i)) \\n                \\n                &&\\n                \\n                //right part of first and left part of second\\n                isScramble(s1.substr(i),s2.substr(0,n-i)) \\n                );\\n            \\n            \\n            \\n            //if withswap give us right answer then we return true\\n            //otherwise the for loop do it work\\n            if(withswap)\\n                return true;\\n            //we are not returning false in else case \\n            //because we want to check further cases with the for loop\\n        }\\n        \\n        \\n        return mp[key] = false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357546,
                "title": "python3-35ms-beats-99-38-recursion-with-memoization",
                "content": "The solution uses recursion with memoization to check all possible partitions of the two strings and determine if they are scrambled versions of each other. The memoization is achieved using a dictionary m that stores the result of previous computations for the same inputs.\\n\\nThe func function takes in two strings s1 and s2, and returns a boolean value indicating whether they are scrambled versions of each other. The function first checks the length of the strings - if they are both of length 1, it simply compares the characters. If the sorted characters in the two strings are not equal, it returns False.\\n\\nOtherwise, the function loops through all possible partitions of s1 and checks if they are valid scrambles of corresponding partitions in s2. The partitions are formed by looping through the length of s1 from index 1 to the end. If a valid partition is found, the function recursively checks the remaining partitions to see if they are also valid scrambles.\\n\\nIf at least one valid partition is found, the function returns True and stores the result in the m dictionary. If no valid partitions are found, the function returns False and stores the result in the m dictionary.\\n\\nFinally, the isScramble function calls the func function with the two input strings and returns the resulting boolean value.\\n# Please Upvote \\uD83D\\uDE07\\n![image.png](https://assets.leetcode.com/users/images/a85197c0-ca4e-4b4b-9d0e-6c3e999491f0_1680140610.86559.png)\\n\\n\\n# Python3\\n```\\nclass Solution:\\n    def isScramble(self,s1, s2):\\n        m ={}\\n        def func(s1, s2):\\n            if (s1, s2) in m:\\n                return m[(s1, s2)]\\n            if not sorted(s1) == sorted(s2):\\n                return False\\n            if len(s1) == 1:\\n                return True\\n            \\n\\n            for i in range(1, len(s1)):\\n                if func(s1[:i], s2[-i:]) and func(s1[i:], s2[:-i]) or func(s1[:i], s2[:i]) and func(s1[i:], s2[i:]):\\n                    m[(s1, s2)] = True\\n                    return True\\n            m[(s1, s2)] = False\\n            return False\\n        return func(s1, s2)\\n\\n\\n\\n\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png)",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self,s1, s2):\\n        m ={}\\n        def func(s1, s2):\\n            if (s1, s2) in m:\\n                return m[(s1, s2)]\\n            if not sorted(s1) == sorted(s2):\\n                return False\\n            if len(s1) == 1:\\n                return True\\n            \\n\\n            for i in range(1, len(s1)):\\n                if func(s1[:i], s2[-i:]) and func(s1[i:], s2[:-i]) or func(s1[:i], s2[:i]) and func(s1[i:], s2[i:]):\\n                    m[(s1, s2)] = True\\n                    return True\\n            m[(s1, s2)] = False\\n            return False\\n        return func(s1, s2)\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29452,
                "title": "python-dp-solutions-with-and-without-memorization",
                "content": "    # DP \\n    def isScramble1(self, s1, s2):\\n        if len(s1) != len(s2):\\n            return False\\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2): # prunning\\n            return False\\n        for i in xrange(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\\\\n            (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                return True\\n        return False\\n        \\n    # DP with memorization\\n    def __init__(self):\\n        self.dic = {}\\n        \\n    def isScramble(self, s1, s2):\\n        if (s1, s2) in self.dic:\\n            return self.dic[(s1, s2)]\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2): # prunning\\n            self.dic[(s1, s2)] = False\\n            return False\\n        if s1 == s2:\\n            self.dic[(s1, s2)] = True\\n            return True\\n        for i in xrange(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\\\\n            (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                return True\\n        self.dic[(s1, s2)] = False\\n        return False",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    # DP \\n    def isScramble1(self, s1, s2):\\n        if len(s1) != len(s2):\\n            return False\\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2): # prunning\\n            return False\\n        for i in xrange(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\\\\n            (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                return True\\n        return False\\n        \\n    # DP with memorization\\n    def __init__(self):\\n        self.dic = {}\\n        \\n    def isScramble(self, s1, s2):\\n        if (s1, s2) in self.dic:\\n            return self.dic[(s1, s2)]\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2): # prunning\\n            self.dic[(s1, s2)] = False\\n            return False\\n        if s1 == s2:\\n            self.dic[(s1, s2)] = True\\n            return True\\n        for i in xrange(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\\\\n            (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                return True\\n        self.dic[(s1, s2)] = False\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 3357814,
                "title": "image-explanation-recursion-dp-complexity-analysis-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Scramble String` by `Aryan Mittal`\\n![Google5.png](https://assets.leetcode.com/users/images/686e8c0a-9b17-46c6-bb66-fccb88c23d3b_1680160513.964775.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/722ed5f3-cb83-4348-adad-8d7741606b53_1680150801.3812325.png)\\n![image.png](https://assets.leetcode.com/users/images/47fab9c2-8e24-4528-93fb-776cd024beb6_1680150821.2099686.png)\\n![image.png](https://assets.leetcode.com/users/images/b56f8c7a-211a-47c0-8cda-3e1b1a964a51_1680150836.9387395.png)\\n![image.png](https://assets.leetcode.com/users/images/6936e020-774e-47ea-83e7-ce6d910dcc1f_1680150849.6459093.png)\\n![image.png](https://assets.leetcode.com/users/images/c4b90c3f-ab12-4bf9-8274-078e4d5269da_1680150862.8997695.png)\\n![image.png](https://assets.leetcode.com/users/images/c5ca5695-e8ed-41be-9765-4617b1216217_1680150878.5818756.png)\\n\\n[`Don\\'t fall for this Small Optimization, It is Leetcode\\'s Test Case Bug`] \\n![image.png](https://assets.leetcode.com/users/images/b9c26979-3449-4ec1-8ece-53bc1df27bb1_1680150888.9371839.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        int n = s1.size();\\n        if(s1==s2) return true;   \\n        if(n==1) return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n        if(mp.find(key)!=mp.end()) return mp[key];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            if(isScramble(s1.substr(0,i),s2.substr(0,i)) && \\n                            isScramble(s1.substr(i),s2.substr(i)))\\n                return mp[key] = true;\\n            \\n            if(isScramble(s1.substr(0,i),s2.substr(n-i)) &&\\n                        isScramble(s1.substr(i),s2.substr(0,n-i)))\\n                return mp[key] = true;\\n        }\\n        \\n        return mp[key] = false;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    Map<String, Boolean> mp = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        if (s1.equals(s2)) return true;\\n        if (n == 1) return false;\\n\\n        String key = s1 + \" \" + s2;\\n\\n        if (mp.containsKey(key)) return mp.get(key);\\n\\n        for (int i = 1; i < n; i++) {\\n            if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i))){\\n                mp.put(key, true);\\n                return true;\\n            }\\n\\n            if (isScramble(s1.substring(0, i), s2.substring(n - i)) && isScramble(s1.substring(i), s2.substring(0, n - i))){\\n                mp.put(key, true);\\n                return true;\\n            }\\n        }\\n\\n        mp.put(key, false);\\n        return false;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.mp = {}\\n\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        if s1 == s2:\\n            return True\\n        if n == 1:\\n            return False\\n\\n        key = s1 + \" \" + s2\\n\\n        if key in self.mp:\\n            return self.mp[key]\\n\\n        for i in range(1, n):\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                self.mp[key] = True\\n                return True\\n\\n            if self.isScramble(s1[:i], s2[n - i:]) and self.isScramble(s1[i:], s2[:n - i]):\\n                self.mp[key] = True\\n                return True\\n\\n        self.mp[key] = False\\n        return False\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        int n = s1.size();\\n        if(s1==s2) return true;   \\n        if(n==1) return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n        if(mp.find(key)!=mp.end()) return mp[key];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            if(isScramble(s1.substr(0,i),s2.substr(0,i)) && \\n                            isScramble(s1.substr(i),s2.substr(i)))\\n                return mp[key] = true;\\n            \\n            if(isScramble(s1.substr(0,i),s2.substr(n-i)) &&\\n                        isScramble(s1.substr(i),s2.substr(0,n-i)))\\n                return mp[key] = true;\\n        }\\n        \\n        return mp[key] = false;\\n    }\\n};\\n```\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    Map<String, Boolean> mp = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        if (s1.equals(s2)) return true;\\n        if (n == 1) return false;\\n\\n        String key = s1 + \" \" + s2;\\n\\n        if (mp.containsKey(key)) return mp.get(key);\\n\\n        for (int i = 1; i < n; i++) {\\n            if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i))){\\n                mp.put(key, true);\\n                return true;\\n            }\\n\\n            if (isScramble(s1.substring(0, i), s2.substring(n - i)) && isScramble(s1.substring(i), s2.substring(0, n - i))){\\n                mp.put(key, true);\\n                return true;\\n            }\\n        }\\n\\n        mp.put(key, false);\\n        return false;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.mp = {}\\n\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        if s1 == s2:\\n            return True\\n        if n == 1:\\n            return False\\n\\n        key = s1 + \" \" + s2\\n\\n        if key in self.mp:\\n            return self.mp[key]\\n\\n        for i in range(1, n):\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                self.mp[key] = True\\n                return True\\n\\n            if self.isScramble(s1[:i], s2[n - i:]) and self.isScramble(s1[i:], s2[:n - i]):\\n                self.mp[key] = True\\n                return True\\n\\n        self.mp[key] = False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285215,
                "title": "java-2ms-recursive-solution-with-explanation",
                "content": "We can judge whether ```s1``` and ```s2``` can scramble into each other through mathematical induction:\\n* The base case that ```s1``` can scramble into ```s2```  if ```s1```== ```s2```. If the frequencies of each characters appearing in ```s1``` and ```s2``` differ, then ```s1``` can not scramble into ```s2```.\\n* If there exist ```0 <= i <= s1.length()``` where\\n\\t* s1[0,i] can scramble into s2[0,i] and s1[i,length] can scramble into s2[i, length]; or \\n\\t* s1[0,i] can scramble into s2[length - i, length] and s1[i,length] can scramble into s2[0, length - i]\\n\\t\\n\\tthen, s1 can scramble into s2.\\n\\n```\\npublic boolean isScramble(String s1, String s2) {\\n    if( s1.equals(s2) )\\n        return true;\\n    int s1Array[] = new int[26];\\n    int s2Array[] = new int[26];\\n    for(int i = 0; i < s1.length(); i++) {\\n        s1Array[s1.charAt(i) - \\'a\\']++;\\n        s2Array[s2.charAt(i) - \\'a\\']++;\\n    }\\n    for(int i = 0; i < 26; i++)\\n        if( s1Array[i] != s2Array[i] )\\n            return false;\\n    for(int i = 1; i < s1.length(); i++) {\\n        if( isScramble(s1.substring(0, i), s2.substring(0, i))\\n            && isScramble(s1.substring(i), s2.substring(i)) )\\n            return true;\\n        if( isScramble(s1.substring(0, i), s2.substring(s1.length() - i))\\n            && isScramble(s1.substring(i), s2.substring(0, s1.length() - i)))\\n            return true;\\n    }\\n    return false;\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```s1```\n```s2```\n```s1```\n```s2```\n```s1```\n```s2```\n```s1```\n```s2```\n```s1```\n```s2```\n```0 <= i <= s1.length()```\n```\\npublic boolean isScramble(String s1, String s2) {\\n    if( s1.equals(s2) )\\n        return true;\\n    int s1Array[] = new int[26];\\n    int s2Array[] = new int[26];\\n    for(int i = 0; i < s1.length(); i++) {\\n        s1Array[s1.charAt(i) - \\'a\\']++;\\n        s2Array[s2.charAt(i) - \\'a\\']++;\\n    }\\n    for(int i = 0; i < 26; i++)\\n        if( s1Array[i] != s2Array[i] )\\n            return false;\\n    for(int i = 1; i < s1.length(); i++) {\\n        if( isScramble(s1.substring(0, i), s2.substring(0, i))\\n            && isScramble(s1.substring(i), s2.substring(i)) )\\n            return true;\\n        if( isScramble(s1.substring(0, i), s2.substring(s1.length() - i))\\n            && isScramble(s1.substring(i), s2.substring(0, s1.length() - i)))\\n            return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29469,
                "title": "c-solutions-w-explanation-both-recursive-and-top-down-dynamic-programming",
                "content": "    // This was a very interesting problem! Here is my solution, using top down dynamic programming. \\n    //\\n    // Lets discuss the recurrence. The question posed is, when is string s1 considered to be a scrambling of string s2? \\n    // Let us pose this as a modified question in the form of the following boolean function:\\n    // bool isScrambling(int s1s, int s1e, int s2s, int s2e);\\n    // i.e., given two strings s1 and s2, are their SUBSTRINGS s1[s1s, s1e] and s2[s2s, s2e] scramblings of each other?\\n    // The original question can be answered by isScrambling(0, s1.length()-1, 0, s2.length() -1);\\n    //\\n    //    First the trivial cases which result in false result:\\n    //     1. The two strings are not of same length, then it cannot be a scrambling.\\n    //     2. if s1e < s1s, or s2e < s2s, then they are not scramblings of each other.\\n    //\\n    //    Now the case for identity scrambling (i.e. no scrambling at all)\\n    //    If s1[s1s, s1e] == s2[s2s, s2e] then they are trivial scramblings of each other\\n    //\\n    //    Another trivial case, if the two strings are of length 1, just check that character\\n    //    \\n    //    Now we come to the meat of the problem. Consider all breaks of the string s1:\\n    //    s1[s1s, s1s+k] and s1[s1s+k+1, s1e] for all k <-[0..(s1e-s1s)]\\n    //       for each of these substrings, the original strings are scramblings if\\n    //       1. Either isScrambling(s1s, s1s+k, s2s, s2s+k)   && isScrambling(s1s+k+1, s1e, s2s+k+1, s2e)\\n    //       2. Or isScrambling(s1s, s1s+k, (s2e-k), s2e)     && isScrambling(s1s+k+1, s1e, s2s, s2e-k-1)\\n    //     The first case is one where we do NOT flip the current node in the tree.\\n    //     The second case is one where we flip the current node in the tree.\\n    //\\n    //    If none of the above cases return true, then the strings are NOT scramblings of each other.\\n    //\\n    // Here is a non-memoized (hence non-DP) recursive version:\\n    class Solution {\\n        string s1;\\n        string s2;\\n    public:\\n        // is s1[s1s, s1e] a scrambling of s2[s2s, s2e]?\\n        bool isScrambling (int s1s, int s1e, int s2s, int s2e) {\\n            if ((s1e-s1s) != (s2e-s2s)) return false;\\n            if (s1e < s1s || s2e < s2s) return false;\\n            if (s1.substr(s1s, (s1e - s1s + 1)) == s2.substr(s2s, (s2e - s2s + 1))) return true; //identity scrambling\\n            if (s1e == s1s) return s1[s1s] == s2[s2s];     \\n            for (int k=0; k<(s1e-s1s); k++) { \\n                if (isScrambling(s1s, s1s+k, s2s, s2s+k)   && isScrambling(s1s+k+1, s1e, s2s+k+1, s2e)) return true;\\n                if (isScrambling(s1s, s1s+k, (s2e-k), s2e) && isScrambling(s1s+k+1, s1e, s2s, s2e-k-1)) return true;\\n            }\\n            return false;\\n        }\\n        bool isScramble(string is1, string is2) {\\n            if (is1.length() == 0 || is2.length() == 0) return false;\\n            s1 = is1;\\n            s2 = is2;\\n            return isScrambling(0, s1.length()-1, 0, s2.length()-1);\\n        }\\n    };\\n    // The above solution is functionally correct, but will result in Time-Limit-Exceeded, \\n    // because we are solving the same sub-problems again and again and again\\n    //\\n    // To make this dynamic programming, we just have to memoize the results. \\n    // i.e. first check if results are in the cache, if so return them\\n    // else compute the results, store in cache, and return the result.\\n    // Here is a Top-Down dynamic programming version, which now passes in the online judge:\\n    //\\n    class Solution {\\n        string s1;\\n        string s2;\\n        std::hash<std::string> str_hash;\\n        unordered_map<size_t, bool> cache;\\n        \\n        // is s1[s1s, s1e] a scrambling of s2[s2s, s2e]?\\n        bool isScrambling (int s1s, int s1e, int s2s, int s2e) {\\n            string hashStr = s1.substr(s1s, s1e-s1s+1) + \"#\" + s2.substr(s2s, s2e-s2s+1);\\n            auto it = cache.find(str_hash(hashStr));\\n            if (it != cache.end()) { \\n                return it->second;\\n            }\\n            bool ret = false;\\n            if ((s1e-s1s) != (s2e-s2s)) {ret = false;}\\n            else if (s1e < s1s || s2e < s2s) {ret = false;}\\n            else if (s1.substr(s1s, (s1e - s1s + 1)) == s2.substr(s2s, (s2e - s2s + 1)))  { ret = true;} //identity scrambling\\n            else if (s1e == s1s) {ret = s1[s1s] == s2[s2s];}      \\n            else {\\n                for (int k=0; k<(s1e-s1s); k++) { \\n                    if (isScrambling(s1s, s1s+k, s2s, s2s+k)   && isScrambling(s1s+k+1, s1e, s2s+k+1, s2e)) {ret = true; break;}\\n                    if (isScrambling(s1s, s1s+k, (s2e-k), s2e) && isScrambling(s1s+k+1, s1e, s2s, s2e-k-1)) {ret = true; break;}\\n                }\\n            }\\n            cache[str_hash(hashStr)] = ret;\\n            return ret;\\n        }\\n    public:\\n        bool isScramble(string is1, string is2) {\\n            if (is1.length() == 0 || is2.length() == 0) return false;\\n            s1 = is1;\\n            s2 = is2;\\n            return isScrambling(0, s1.length()-1, 0, s2.length()-1);\\n        }\\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n        string s1;\\n        string s2;\\n    public:\\n        // is s1[s1s, s1e] a scrambling of s2[s2s, s2e]?\\n        bool isScrambling (int s1s, int s1e, int s2s, int s2e) {\\n            if ((s1e-s1s) != (s2e-s2s)) return false;\\n            if (s1e < s1s || s2e < s2s) return false;\\n            if (s1.substr(s1s, (s1e - s1s + 1)) == s2.substr(s2s, (s2e - s2s + 1))) return true; //identity scrambling\\n            if (s1e == s1s) return s1[s1s] == s2[s2s];     \\n            for (int k=0; k<(s1e-s1s); k++) { \\n                if (isScrambling(s1s, s1s+k, s2s, s2s+k)   && isScrambling(s1s+k+1, s1e, s2s+k+1, s2e)) return true;\\n                if (isScrambling(s1s, s1s+k, (s2e-k), s2e) && isScrambling(s1s+k+1, s1e, s2s, s2e-k-1)) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3357490,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers this week. I planned to give for next 10,000 Subscribers as well. So **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n# OR \\n**Click the Link in my Leetcode Profile to Subscribe**\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n# Approach:\\n\\nWe can use dynamic programming to solve this problem. We can define a 3D boolean array dp[i][j][length] to represent whether s1[i:i+length] and s2[j:j+length] are scrambled versions of each other. The array dp will have dimensions n x n x (n+1), where n is the length of the strings. The base case is when length=1, and in this case, dp[i][j][1] is true if and only if s1[i] is equal to s2[j]. For each value of length, we can iterate through all possible starting indices i and j, and all possible split points k such that 1 <= k < length. We can then check if the substrings of s1 and s2 starting at indices i and j, respectively, and both of length k, are scrambled versions of each other, and if the substrings of s1 and s2 starting at indices i+k and j+k, respectively, and both of length length-k, are scrambled versions of each other. If either of these conditions are met, then dp[i][j][length] is true.\\n\\n# Intuition:\\n\\n- The intuition behind this approach is that if two strings s1 and s2 are scrambled versions of each other, then there must exist a split point k such that either the substrings of s1 and s2 starting at indices 0 and 0, respectively, and both of length k, are scrambled versions of each other, and the substrings of s1 and s2 starting at indices k and k, respectively, and both of length length-k, are scrambled versions of each other, or the substrings of s1 and s2 starting at indices 0 and length-k, respectively, and both of length k, are scrambled versions of each other, and the substrings of s1 and s2 starting at indices k and 0, respectively, and both of length length-k, are scrambled versions of each other. This is because a scrambled version of a string can be obtained by swapping any two non-adjacent substrings of the string.\\n\\n- By using dynamic programming to store the results of the subproblems, we can avoid recomputing the same subproblems multiple times, leading to a more efficient solution. The time complexity of this approach is O(n^4), and the space complexity is O(n^3)\\n\\n\\n```Python []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2):\\n            return False\\n        \\n        n = len(s1)\\n        dp = [[[False] * (n+1) for _ in range(n)] for _ in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                dp[i][j][1] = (s1[i] == s2[j])\\n        \\n        for length in range(2, n+1):\\n            for i in range(n-length+1):\\n                for j in range(n-length+1):\\n                    for k in range(1, length):\\n                        if (dp[i][j][k] and dp[i+k][j+k][length-k]) or (dp[i][j+length-k][k] and dp[i+k][j][length-k]):\\n                            dp[i][j][length] = True\\n                            break\\n        \\n        return dp[0][0][n]\\n\\n    \\n        # An Upvote will be encouraging\\n\\n```\\n```Java []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (!Arrays.equals(s1.chars().sorted().toArray(), s2.chars().sorted().toArray())) {\\n            return false;\\n        }\\n        \\n        int n = s1.length();\\n        boolean[][][] dp = new boolean[n][n][n+1];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j][1] = (s1.charAt(i) == s2.charAt(j));\\n            }\\n        }\\n        \\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    for (int k = 1; k < length; k++) {\\n                        if ((dp[i][j][k] && dp[i+k][j+k][length-k]) || (dp[i][j+length-k][k] && dp[i+k][j][length-k])) {\\n                            dp[i][j][length] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][n];\\n    }\\n}\\n\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if (s1 == s2) {\\n            return true;\\n        }\\n        if (!is_permutation(s1.begin(), s1.end(), s2.begin())) {\\n            return false;\\n        }\\n        \\n        int n = s1.length();\\n        vector<vector<vector<bool>>> dp(n, vector<vector<bool>>(n, vector<bool>(n+1, false)));\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j][1] = (s1[i] == s2[j]);\\n            }\\n        }\\n        \\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    for (int k = 1; k < length; k++) {\\n                        if ((dp[i][j][k] && dp[i+k][j+k][length-k]) || (dp[i][j+length-k][k] && dp[i+k][j][length-k])) {\\n                            dp[i][j][length] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][n];\\n    }\\n};\\n\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```Python []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2):\\n            return False\\n        \\n        n = len(s1)\\n        dp = [[[False] * (n+1) for _ in range(n)] for _ in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                dp[i][j][1] = (s1[i] == s2[j])\\n        \\n        for length in range(2, n+1):\\n            for i in range(n-length+1):\\n                for j in range(n-length+1):\\n                    for k in range(1, length):\\n                        if (dp[i][j][k] and dp[i+k][j+k][length-k]) or (dp[i][j+length-k][k] and dp[i+k][j][length-k]):\\n                            dp[i][j][length] = True\\n                            break\\n        \\n        return dp[0][0][n]\\n\\n    \\n        # An Upvote will be encouraging\\n\\n```\n```Java []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (!Arrays.equals(s1.chars().sorted().toArray(), s2.chars().sorted().toArray())) {\\n            return false;\\n        }\\n        \\n        int n = s1.length();\\n        boolean[][][] dp = new boolean[n][n][n+1];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j][1] = (s1.charAt(i) == s2.charAt(j));\\n            }\\n        }\\n        \\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    for (int k = 1; k < length; k++) {\\n                        if ((dp[i][j][k] && dp[i+k][j+k][length-k]) || (dp[i][j+length-k][k] && dp[i+k][j][length-k])) {\\n                            dp[i][j][length] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][n];\\n    }\\n}\\n\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if (s1 == s2) {\\n            return true;\\n        }\\n        if (!is_permutation(s1.begin(), s1.end(), s2.begin())) {\\n            return false;\\n        }\\n        \\n        int n = s1.length();\\n        vector<vector<vector<bool>>> dp(n, vector<vector<bool>>(n, vector<bool>(n+1, false)));\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j][1] = (s1[i] == s2[j]);\\n            }\\n        }\\n        \\n        for (int length = 2; length <= n; length++) {\\n            for (int i = 0; i <= n-length; i++) {\\n                for (int j = 0; j <= n-length; j++) {\\n                    for (int k = 1; k < length; k++) {\\n                        if ((dp[i][j][k] && dp[i+k][j+k][length-k]) || (dp[i][j+length-k][k] && dp[i+k][j][length-k])) {\\n                            dp[i][j][length] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][n];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517108,
                "title": "cpp-and-java-concise-recursive-memoized-sol-n-with-explanation",
                "content": "Given two strings, we need to determine whether the strings are scrambled or not. The condition for being scrambled is to make a complete binary tree and swap their non-leaf nodes. For example, after swapping, the string becomes rgeat.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/46f5dba3-193b-468d-9bd0-5f14fcc19730_1634010235.2960505.png\" width=400>\\n</p>\\n\\n- The red ones are leaf nodes, and the blue ones are non-leaf nodes. It depends on which non-leaf nodes we want to swap, and no of swaps can be equal to or greater than zero.\\n- What happens when both strings are the same, then also both strings are scrambled.\\n- We can break it at any kth position, but the tree should be complete i.e. no empty nodes.\\n\\n- *This is MCM type question, as we need to check for every kth position.*\\n\\n#####  *Approach*\\n\\n- We will break the strings into two parts i.e from (0, ith) to (ith, n - ith) and check whether they are equal or not\\n- This arise two cases, whether the substring is swapped or not. So we have to check \\n ```\\n           left part of string1 == left part of string2 along with right part of string1 == right part of string2\\n                                                              or\\n\\t\\t      left part of string1 == right part of string2 along with right part of string1 == left part of string2\\n```\\n\\n- If any one condition becomes true then the string are scrambled. Checking it recursively as child can also be swapped. Take third example in image below for reference.\\n- If length of two strings are not equal then they are not scrambled. \\n\\n<p align=\"center\">\\n   <img src=\"https://assets.leetcode.com/users/images/1c67fd8a-2afc-456b-90e2-7192d305771c_1634008449.219847.png\" width=300>\\n  </p>\\n\\n#### *Recursive Cpp* (TLE)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool helper(string a, string b)\\n    {\\n        if(a.compare(b) == 0) return true;\\n        \\n        if(a.length() <= 1) return false;  //1character can\\'t be compared\\n        \\n        int n = a.length();\\n        bool check = false;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n           bool swap = helper(a.substr(0,i), b.substr(n - i,i)) and helper(a.substr(i), b.substr(0, n - i));\\n           bool unswap = helper(a.substr(0,i), b.substr(0,i)) and helper(a.substr(i,n - i), b.substr(i,n - i));\\n            \\n           if(swap || unswap){\\n               check = true;\\n               break;\\n           }\\n        }\\n        \\n        return check;\\n    }\\n    \\n    bool isScramble(string a, string b) \\n    {\\n        if(a == b) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.empty() and b.empty()) return true;\\n        \\n        return helper(a, b);\\n    }\\n};\\n```\\n\\n*The same Java version.*\\n\\n```\\nclass Solution {\\n    public boolean helper(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;  \\n        \\n        if(a.length() <= 1) return false;   // as we can\\'t compare 1 character\\n        \\n        int n = a.length();\\n        boolean check = false;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\\n            \\n            if(swap || unswap){\\n                check = true;\\n                break;\\n            }\\n        }\\n        \\n        return check;\\n    }\\n    \\n    public boolean isScramble(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() != b.length()) return false;   \\n        \\n        if(a.isEmpty() == true) return true;\\n        \\n        return helper(a, b);\\n    }\\n}\\n```\\n\\n#### *Memoized version*\\n\\nStoring the values in a map where the key is string a + \\' \\' + string b.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> mp;\\n    \\n    bool helper(string a, string b)\\n    {\\n        if(a.compare(b) == 0) return true;\\n        \\n        if(a.length() <= 1) return false;  //1character can\\'t be compared\\n        \\n        int n = a.length();\\n        bool check = false;\\n        \\n        string key = a;\\n        \\n        key += \\' \\' + b;\\n        \\n        if(mp.find(key) != mp.end()) \\n            return mp[key];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n           bool swap = helper(a.substr(0,i), b.substr(n - i,i)) and helper(a.substr(i), b.substr(0, n - i));\\n           bool unswap = helper(a.substr(0,i), b.substr(0,i)) and helper(a.substr(i,n - i), b.substr(i,n - i));\\n            \\n           if(swap || unswap){\\n               check = true;\\n               break;\\n           }\\n        }\\n        \\n        return mp[key] =  check;\\n    }\\n    \\n    bool isScramble(string a, string b) \\n    {\\n        if(a == b) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.empty() and b.empty()) return true;\\n        \\n        return helper(a, b);\\n    }\\n};\\n```\\n\\n*The same Java version.*\\n\\n```\\nclass Solution {\\n    Map<String, Boolean> mp = new HashMap<>();\\n    \\n    public boolean helper(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() <= 1) return false;\\n        \\n        int n = a.length();\\n        boolean check = false;\\n        \\n        String key = a;\\n        \\n        key += \\' \\' + b;\\n        \\n        if(mp.containsKey(key))\\n             return mp.get(key);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\\n            \\n            if(swap || unswap){\\n                check = true;\\n                break;\\n            }\\n        }\\n        \\n        mp.put(key, check);\\n        \\n        return check;\\n    }\\n    \\n    public boolean isScramble(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.isEmpty() == true) return true;\\n        \\n        return helper(a, b);\\n    }\\n}\\n```\\n\\nFeel free to ask your queries.\\uD83D\\uDE42\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n           left part of string1 == left part of string2 along with right part of string1 == right part of string2\\n                                                              or\\n\\t\\t      left part of string1 == right part of string2 along with right part of string1 == left part of string2\\n```\n```\\nclass Solution {\\npublic:\\n    bool helper(string a, string b)\\n    {\\n        if(a.compare(b) == 0) return true;\\n        \\n        if(a.length() <= 1) return false;  //1character can\\'t be compared\\n        \\n        int n = a.length();\\n        bool check = false;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n           bool swap = helper(a.substr(0,i), b.substr(n - i,i)) and helper(a.substr(i), b.substr(0, n - i));\\n           bool unswap = helper(a.substr(0,i), b.substr(0,i)) and helper(a.substr(i,n - i), b.substr(i,n - i));\\n            \\n           if(swap || unswap){\\n               check = true;\\n               break;\\n           }\\n        }\\n        \\n        return check;\\n    }\\n    \\n    bool isScramble(string a, string b) \\n    {\\n        if(a == b) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.empty() and b.empty()) return true;\\n        \\n        return helper(a, b);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean helper(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;  \\n        \\n        if(a.length() <= 1) return false;   // as we can\\'t compare 1 character\\n        \\n        int n = a.length();\\n        boolean check = false;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\\n            \\n            if(swap || unswap){\\n                check = true;\\n                break;\\n            }\\n        }\\n        \\n        return check;\\n    }\\n    \\n    public boolean isScramble(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() != b.length()) return false;   \\n        \\n        if(a.isEmpty() == true) return true;\\n        \\n        return helper(a, b);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> mp;\\n    \\n    bool helper(string a, string b)\\n    {\\n        if(a.compare(b) == 0) return true;\\n        \\n        if(a.length() <= 1) return false;  //1character can\\'t be compared\\n        \\n        int n = a.length();\\n        bool check = false;\\n        \\n        string key = a;\\n        \\n        key += \\' \\' + b;\\n        \\n        if(mp.find(key) != mp.end()) \\n            return mp[key];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n           bool swap = helper(a.substr(0,i), b.substr(n - i,i)) and helper(a.substr(i), b.substr(0, n - i));\\n           bool unswap = helper(a.substr(0,i), b.substr(0,i)) and helper(a.substr(i,n - i), b.substr(i,n - i));\\n            \\n           if(swap || unswap){\\n               check = true;\\n               break;\\n           }\\n        }\\n        \\n        return mp[key] =  check;\\n    }\\n    \\n    bool isScramble(string a, string b) \\n    {\\n        if(a == b) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.empty() and b.empty()) return true;\\n        \\n        return helper(a, b);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    Map<String, Boolean> mp = new HashMap<>();\\n    \\n    public boolean helper(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() <= 1) return false;\\n        \\n        int n = a.length();\\n        boolean check = false;\\n        \\n        String key = a;\\n        \\n        key += \\' \\' + b;\\n        \\n        if(mp.containsKey(key))\\n             return mp.get(key);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\\n            \\n            if(swap || unswap){\\n                check = true;\\n                break;\\n            }\\n        }\\n        \\n        mp.put(key, check);\\n        \\n        return check;\\n    }\\n    \\n    public boolean isScramble(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.isEmpty() == true) return true;\\n        \\n        return helper(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357954,
                "title": "clean-c-code-with-great-explanation",
                "content": "This is a very interesting problem!\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs soon as I read the problem, I understood that it is a DP problem cause there were overlaping subproblems. So I started thinking about what will be the DP states, what things can we solve recursively, what will be the base case and transistions be like. I have used top-down dynamic programming to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nProblem asks us to find whether string `s1` is scramble of `s2` or not. We can also look this problem as for given two string `s1` and `s2`, and their substrings `s1[l1...r1]` and `s2[l2...r2]` are scrambles of each other or not. So the original question can be answered for the substrings from `0` to `n - 1`.\\n\\nWe have a `helper` function that returns us exactly what we need to find above, and it takes `l1`, `r1`, `l2` and `r2` as parameters.\\nNote: we will always call the `helper` function such that the length of both the substring from `s1` and `s2` are of same size.\\n\\nBase Case: if both the substrings are same, we simply return `true`.\\nNow, if it is not the base case, i.e. the substrings are not same, we need to further divide this substring into two more substrings `x` and `y` (as named in the question). As we can randomly partition the substring, we will have to check for all the partitions. After each partition, we have two options: \\n\\n**Option 1:** DON\\'T FLIP\\nWe keep the current substring of `s1` as it is, i.e. `x + y`. Here we check scrambles of `x` with the prefix of substring of `s2` of the same size as `x`, and check `y` with the remaining suffix of substring of `s2`, which will be also of same size as that of `y`.\\n\\n**Option 2:** FLIP\\nWe swap the `x` and `y` after partition, i.e. `y + x`. Here we check the scrambles of `x` with the suffix of substring of `s2` of the same size as `x`, and check `y` with the remaining prefix of substring of `s2`, which will be also of same size as that of `y`.\\n\\nIf none of the above options return true, we simply return false.\\n\\nIn the code below, I have used boolean arrays to store whether we have visited any state, and its answer. Hence it is a memoized DP. Also I have used the lambda functions just cause I am addicted to it :)\\n\\n<!-- # Complexityd -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n = (int) s1.size();\\n        bool vis[n][n][n][n];\\n        bool dp[n][n][n][n];\\n        memset(vis, false, sizeof(vis));\\n        memset(dp, false, sizeof(dp));\\n\\n        // we are always calling the function such that, the substring we are checking on both the\\n        // substrings are of same length, i.e. (r1 - l1 + 1 == r2 - l2 + 1)\\n\\n        // helper takes in two substrings of both string\\n        // and returns whether they are scamble of each other\\n        function<bool(int, int, int, int)> helper = [&] (int l1, int r1, int l2, int r2) {\\n            if (vis[l1][r1][l2][r2]) return dp[l1][r1][l2][r2];\\n            vis[l1][r1][l2][r2] = true;\\n\\n            bool isSame = true;\\n            for (int i = l1, j = l2; i <= r1 && j <= r2; i++, j++)\\n                if (s1[i] != s2[j]) isSame = false;\\n            \\n            // is already same, simply return true\\n            if (isSame) {\\n                dp[l1][r1][l2][r2] = true;\\n                return true;\\n            }\\n\\n            bool res = false;\\n            for (int i = l1; i < r1; i++) {\\n                // opt1: prefix1 matches to prefix2 and suffix1 matches to suffix2\\n                res |= (helper(l1, i, l2, l2 + (i - l1)) && helper(i + 1, r1, l2 + (i - l1) + 1, r2));\\n\\n                // opt2: prefix1 matches to suffix2 and prefix2 matches to suffix1\\n                res |= (helper(l1, i, r2 - (i - l1), r2) && helper(i + 1, r1, l2, r2 - (i - l1) - 1));\\n            }\\n\\n            dp[l1][r1][l2][r2] = res;\\n            return res;\\n        };\\n\\n        return helper(0, n - 1, 0, n - 1);\\n    }\\n};\\n```\\n\\nFeedbacks are appreciated :)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n = (int) s1.size();\\n        bool vis[n][n][n][n];\\n        bool dp[n][n][n][n];\\n        memset(vis, false, sizeof(vis));\\n        memset(dp, false, sizeof(dp));\\n\\n        // we are always calling the function such that, the substring we are checking on both the\\n        // substrings are of same length, i.e. (r1 - l1 + 1 == r2 - l2 + 1)\\n\\n        // helper takes in two substrings of both string\\n        // and returns whether they are scamble of each other\\n        function<bool(int, int, int, int)> helper = [&] (int l1, int r1, int l2, int r2) {\\n            if (vis[l1][r1][l2][r2]) return dp[l1][r1][l2][r2];\\n            vis[l1][r1][l2][r2] = true;\\n\\n            bool isSame = true;\\n            for (int i = l1, j = l2; i <= r1 && j <= r2; i++, j++)\\n                if (s1[i] != s2[j]) isSame = false;\\n            \\n            // is already same, simply return true\\n            if (isSame) {\\n                dp[l1][r1][l2][r2] = true;\\n                return true;\\n            }\\n\\n            bool res = false;\\n            for (int i = l1; i < r1; i++) {\\n                // opt1: prefix1 matches to prefix2 and suffix1 matches to suffix2\\n                res |= (helper(l1, i, l2, l2 + (i - l1)) && helper(i + 1, r1, l2 + (i - l1) + 1, r2));\\n\\n                // opt2: prefix1 matches to suffix2 and prefix2 matches to suffix1\\n                res |= (helper(l1, i, r2 - (i - l1), r2) && helper(i + 1, r1, l2, r2 - (i - l1) - 1));\\n            }\\n\\n            dp[l1][r1][l2][r2] = res;\\n            return res;\\n        };\\n\\n        return helper(0, n - 1, 0, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29445,
                "title": "any-better-solution",
                "content": "My AC code is as below. I think it's not very efficient. Is there any better solution?\\n\\n    class Solution {\\n    private:\\n    \\tbool anagram(string &s1, string &s2){\\n    \\t\\tif(s1.size() != s2.size()) return false;\\n    \\t\\tunordered_map<char, int> m;\\n    \\t\\tint n = s1.size();\\n    \\t\\tfor(int i = 0; i < n; ++i){\\n    \\t\\t\\tif(m.find(s1[i]) != m.end()){\\n    \\t\\t\\t\\t++m[s1[i]];\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\tm[s1[i]] = 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tfor(int i = 0; i < n; ++i){\\n    \\t\\t\\tif(m.find(s2[i]) != m.end()){\\n    \\t\\t\\t\\t--m[s2[i]];\\n    \\t\\t\\t\\tif(m[s2[i]] < 0){\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else{\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn true;\\n    \\t}\\n    public:\\n        bool isScramble(string s1, string s2) {\\n        \\tif(s1.size() != s2.size()) return false;\\n        \\tif(s1 == s2) return true;\\n        \\tint n = s1.size();\\n        \\tfor(int i = 1; i < n; ++i){\\n        \\t\\tstring s11 = s1.substr(0, i);\\n        \\t\\tstring s12 = s1.substr(i, n - i);\\n        \\t\\tstring s21 = s2.substr(0, i);\\n        \\t\\tstring s22 = s2.substr(i, n - i);\\n        \\t\\tstring s23 = s2.substr(n - i, i);\\n        \\t\\tstring s24 = s2.substr(0, n - i);\\n        \\t\\tif(anagram(s11, s21) && anagram(s12, s22) &&\\n        \\t\\t\\tisScramble(s11, s21) && isScramble(s12, s22)\\n        \\t\\t\\t||\\n        \\t\\t\\tanagram(s11, s23) && anagram(s12, s24) &&\\n        \\t\\t\\tisScramble(s11, s23) && isScramble(s12, s24)){\\n        \\t\\t\\treturn true;\\n        \\t\\t}\\n        \\t}\\n            return false;\\n        }\\n    };\\n\\nThe main idea is:\\n\\n1. separate `s1` into two parts, namely `--s11--`, `--------s12--------`\\n2. separate `s2` into two parts, namely `--s21--`, `--------s22--------`, and test the corresponding part (`s11` and `s21` && `s12` and `s22`) with `isScramble`.\\n3. separate `s2` into two parts, namely `--------s23--------`, `--s24--`, and test the corresponding part (`s11` and `s24` && `s12` and `s23`) with `isScramble`.\\n4. Note that before testing each sub-part with `isScramble`, `anagram` is used first to test if the corresponding parts are anagrams. If not, skip directly.",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n    \\tbool anagram(string &s1, string &s2){\\n    \\t\\tif(s1.size() != s2.size()) return false;\\n    \\t\\tunordered_map<char, int> m;\\n    \\t\\tint n = s1.size();\\n    \\t\\tfor(int i = 0; i < n; ++i){\\n    \\t\\t\\tif(m.find(s1[i]) != m.end()){\\n    \\t\\t\\t\\t++m[s1[i]];\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2395245,
                "title": "clean-python3-recursion-memoization-faster-than-98",
                "content": "Please upvote if it helps! :)\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.scrambles = {}\\n        \\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if (s1, s2) in self.scrambles:\\n            return self.scrambles[(s1, s2)]\\n        if s1 == s2:\\n            self.scrambles[(s1, s2)] = True\\n            return True\\n        ls = len(s1)\\n        if ls == 1 or sorted(s1) != sorted(s2):\\n            self.scrambles[(s1, s2)] = False\\n            return False\\n\\n        for i in range(1, ls):\\n            \\n            s1_left, s1_right = s1[:i], s1[i:]\\n            s2_left, s2_right = s2[:i], s2[i:]\\n            match1 = self.isScramble(s1_left, s2_left) and self.isScramble(s1_right, s2_right)\\n            \\n            s2_left2, s2_right2 = s2[:ls - i], s2[ls - i:]\\n            match2 = self.isScramble(s1_left, s2_right2) and self.isScramble(s1_right, s2_left2)\\n            \\n            if match1 or match2:\\n                self.scrambles[(s1, s2)] = True\\n                return True\\n            \\n        self.scrambles[(s1, s2)] = False\\n        return False",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "class Solution:\\n    def __init__(self):\\n        self.scrambles = {}",
                "codeTag": "Java"
            },
            {
                "id": 1025628,
                "title": "python-top-down-dp-solution",
                "content": "```\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        def recur(s1, s2):\\n            if s1 == s2:\\n                return True\\n            if Counter(s1) != Counter(s2):\\n                return False\\n            if (s1, s2) in dp:\\n                return dp[(s1, s2)]\\n            dp[(s1, s2)] = False\\n            for i in range(1, len(s1)):\\n                if recur(s1[:i], s2[:i]) and recur(s1[i:], s2[i:]):\\n                    dp[(s1, s2)] = True\\n                    return True\\n                if recur(s1[:i], s2[-i:]) and recur(s1[i:], s2[:-i]):\\n                    dp[(s1, s2)] = True\\n                    return True\\n            return dp[(s1, s2)]\\n        \\n        dp = dict()\\n        return recur(s1, s2)\\n```",
                "solutionTags": [],
                "code": "```\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        def recur(s1, s2):\\n            if s1 == s2:\\n                return True\\n            if Counter(s1) != Counter(s2):\\n                return False\\n            if (s1, s2) in dp:\\n                return dp[(s1, s2)]\\n            dp[(s1, s2)] = False\\n            for i in range(1, len(s1)):\\n                if recur(s1[:i], s2[:i]) and recur(s1[i:], s2[i:]):\\n                    dp[(s1, s2)] = True\\n                    return True\\n                if recur(s1[:i], s2[-i:]) and recur(s1[i:], s2[:-i]):\\n                    dp[(s1, s2)] = True\\n                    return True\\n            return dp[(s1, s2)]\\n        \\n        dp = dict()\\n        return recur(s1, s2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 29411,
                "title": "optimized-recursive-0ms-and-dp-20ms-solution-c-beating-100-submissions",
                "content": "Simply we can just use recursive method to traverse every possible situations but as we can expect that we will run into TLE. \\n\\nThere are other factors we should make full use of to reduce the traversing range \\n- the limited characters \\n- the scrambled string is containing just exactly the same set of characters as the original string \\n\\nwhich can be used to `prune` almost all invalid traversing branches and result in the best time cost.  \\n\\n    #define SIZE 256\\n    bool isnScramble(char* s1, char* s2, int len) \\n    {\\n        \\n        if(!strncmp(s1, s2, len)) return true;\\n        int count[SIZE] = {0};\\n        for(int i = 0; i < len; i++)\\n            count[s1[i]-'a']++, count[s2[i]-'a']--;\\n        for(int i = 0; i < SIZE; i++)\\n            if(count[i]) return false;\\n        for(int i=1; i < len; i++)\\n            if(isnScramble(s1, s2, i) && isnScramble(s1+i, s2+i, len-i) ||\\n                    isnScramble(s1, s2+len-i, i) && isnScramble(s1+i, s2, len-i)) return true;\\n        return false;\\n    }\\n    \\n    //AC - 0ms - beats 100% submissions;\\n    bool isScramble(char* s1, char* s2)\\n    {\\n        int len = strlen(s1);\\n        return isnScramble(s1, s2, len);\\n    }\\n\\nA DP solution is also provided here with 20ms time cost, which is inspired by the above recursive method using three-dimension array to store the state \\n\\n> match[size][index1][index2]\\n\\nthe size is the comparing size of the two strings, index1 is the start index of string 1 and index2 is that of string 2.\\n\\n    //AC - 20ms - beats 100% submissions - DP solution;\\n    bool isScramble(char* s1, char* s2)\\n    {\\n        int len = strlen(s1);\\n        if(!len) return true;\\n        if(len==1) return *s1==*s2;\\n        bool*** match = (bool***)malloc(sizeof(bool**)*(len+1));\\n        for(int i = 0; i <= len; i++)\\n        {\\n            match[i] = (bool**)malloc(sizeof(bool*)*len);\\n            for(int j = 0; j < len; j++)\\n            {\\n                match[i][j] = (bool*)malloc(sizeof(bool)*len);\\n                memset(match[i][j], 0, sizeof(bool)*len);\\n            }\\n        }\\n        for(int i = 0; i < len; i++)\\n            for(int j = 0; j < len; j++)\\n                match[1][i][j] = (s1[i] == s2[j]);\\n        for(int size = 2; size <= len; size++)\\n            for(int i = 0; i <= len-size; i++)\\n                for(int j = 0; j <= len-size; j++)\\n                    for(int k = 1; k<size && !match[size][i][j]; k++)\\n                        match[size][i][j] = (match[k][i][j] && match[size-k][i+k][j+k]) || (match[k][i+size-k][j] && match[size-k][i][j+k]);\\n        return match[len][0][0];\\n    }\\n\\nThere are still lots of redundant search in the above methods; can someone further improve it? Thanks in advance!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "Simply we can just use recursive method to traverse every possible situations but as we can expect that we will run into TLE. \\n\\nThere are other factors we should make full use of to reduce the traversing range \\n- the limited characters \\n- the scrambled string is containing just exactly the same set of characters as the original string \\n\\nwhich can be used to `prune` almost all invalid traversing branches and result in the best time cost.  \\n\\n    #define SIZE 256\\n    bool isnScramble(char* s1, char* s2, int len) \\n    {\\n        \\n        if(!strncmp(s1, s2, len)) return true;\\n        int count[SIZE] = {0};\\n        for(int i = 0; i < len; i++)\\n            count[s1[i]-'a']++, count[s2[i]-'a']--;\\n        for(int i = 0; i < SIZE; i++)\\n            if(count[i]) return false;\\n        for(int i=1; i < len; i++)\\n            if(isnScramble(s1, s2, i) && isnScramble(s1+i, s2+i, len-i) ||\\n                    isnScramble(s1, s2+len-i, i) && isnScramble(s1+i, s2, len-i)) return true;\\n        return false;\\n    }\\n    \\n    //AC - 0ms - beats 100% submissions;\\n    bool isScramble(char* s1, char* s2)\\n    {\\n        int len = strlen(s1);\\n        return isnScramble(s1, s2, len);\\n    }\\n\\nA DP solution is also provided here with 20ms time cost, which is inspired by the above recursive method using three-dimension array to store the state \\n\\n> match[size][index1][index2]\\n\\nthe size is the comparing size of the two strings, index1 is the start index of string 1 and index2 is that of string 2.\\n\\n    //AC - 20ms - beats 100% submissions - DP solution;\\n    bool isScramble(char* s1, char* s2)\\n    {\\n        int len = strlen(s1);\\n        if(!len) return true;\\n        if(len==1) return *s1==*s2;\\n        bool*** match = (bool***)malloc(sizeof(bool**)*(len+1));\\n        for(int i = 0; i <= len; i++)\\n        {\\n            match[i] = (bool**)malloc(sizeof(bool*)*len);\\n            for(int j = 0; j < len; j++)\\n            {\\n                match[i][j] = (bool*)malloc(sizeof(bool)*len);\\n                memset(match[i][j], 0, sizeof(bool)*len);\\n            }\\n        }\\n        for(int i = 0; i < len; i++)\\n            for(int j = 0; j < len; j++)\\n                match[1][i][j] = (s1[i] == s2[j]);\\n        for(int size = 2; size <= len; size++)\\n            for(int i = 0; i <= len-size; i++)\\n                for(int j = 0; j <= len-size; j++)\\n                    for(int k = 1; k<size && !match[size][i][j]; k++)\\n                        match[size][i][j] = (match[k][i][j] && match[size-k][i+k][j+k]) || (match[k][i+size-k][j] && match[size-k][i][j+k]);\\n        return match[len][0][0];\\n    }\\n\\nThere are still lots of redundant search in the above methods; can someone further improve it? Thanks in advance!",
                "codeTag": "Unknown"
            },
            {
                "id": 29458,
                "title": "a-simple-solution-without-dp-in-c",
                "content": "    class Solution {\\n    public:\\n        bool isScramble(string s1, string s2) {\\n            int n = s1.length();\\n            return judge(s1.c_str(), s2.c_str(), 0, n-1, 0, n-1);\\n        }\\n        \\n        bool judge(const char* s1, const char* s2,int a,int b,int u, int v){\\n            if(b-a!=v-u) return false;\\n            if(b-a==0 && s1[a]==s2[u]) return true;\\n            \\n            int cnt[256]={0};\\n            for(int i=a;i<=b;++i){\\n                cnt[s1[i]]++;\\n            }\\n            for(int i=u;i<=v;++i){\\n                cnt[s2[i]]--;\\n            }\\n            for(int i=0;i<256;++i){\\n                if(cnt[i]!=0) return false;\\n            }\\n            \\n            for(int i=a;i<b;++i){\\n                if(judge(s1,s2,a,i,u,u+i-a) && judge(s1,s2,i+1,b,v-(b-i-1),v)){                    \\n                    return true;\\n                }\\n                if(judge(s1,s2,a,i,v-(i-a),v) && judge(s1,s2,i+1,b,u,u+b-(i+1))){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    };\\n\\nSurprisingly, it runs very fast even without dynamic programming.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isScramble(string s1, string s2) {\\n            int n = s1.length();\\n            return judge(s1.c_str(), s2.c_str(), 0, n-1, 0, n-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 29471,
                "title": "66-ms-python-solution-with-dict",
                "content": "    def is_scramble(s1, s2):\\n        m = {}\\n        return f(s1, s2, m)\\n\\n\\n    def f(s1, s2, m):\\n        if (s1, s2) in m:\\n            return m[(s1, s2)]\\n    \\n        if len(s1) == 1:\\n            return s1 == s2\\n        elif not sorted(s1) == sorted(s2):\\n            return False\\n    \\n        for i in range(1, len(s1)):\\n            if f(s1[:i], s2[-i:], m) and f(s1[i:], s2[:-i], m) or \\\\\\n               f(s1[:i], s2[:i], m) and f(s1[i:], s2[i:], m):\\n                m[(s1, s2)] = True\\n                return True\\n        m[(s1, s2)] = False\\n        return False",
                "solutionTags": [],
                "code": "    def is_scramble(s1, s2):\\n        m = {}\\n        return f(s1, s2, m)\\n\\n\\n    def f(s1, s2, m):\\n        if (s1, s2) in m:\\n            return m[(s1, s2)]\\n    \\n        if len(s1) == 1:\\n            return s1 == s2\\n        elif not sorted(s1) == sorted(s2):\\n            return False\\n    \\n        for i in range(1, len(s1)):\\n            if f(s1[:i], s2[-i:], m) and f(s1[i:], s2[:-i], m) or \\\\\\n               f(s1[:i], s2[:i], m) and f(s1[i:], s2[i:], m):\\n                m[(s1, s2)] = True\\n                return True\\n        m[(s1, s2)] = False\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 3358542,
                "title": "python-elegant-short-top-down-dp-memoization",
                "content": "# Complexity\\n- Time complexity: $$O(n^{2})$$\\n- Space complexity: $$O(n^{2})$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isScramble(self, first: str, second: str) -> bool:\\n        @cache\\n        def dp(a: str, b: str) -> bool:\\n            if a == b:\\n                return True\\n\\n            if Counter(a) != Counter(b):\\n                return False\\n\\n            return any(\\n                dp(a[:i], b[:i]) and dp(a[i:], b[i:]) or \\\\\\n                dp(a[:i], b[-i:]) and dp(a[i:], b[:-i])\\n                for i in range(1, len(a))\\n            )\\n\\n        return dp(first, second)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self, first: str, second: str) -> bool:\\n        @cache\\n        def dp(a: str, b: str) -> bool:\\n            if a == b:\\n                return True\\n\\n            if Counter(a) != Counter(b):\\n                return False\\n\\n            return any(\\n                dp(a[:i], b[:i]) and dp(a[i:], b[i:]) or \\\\\\n                dp(a[:i], b[-i:]) and dp(a[i:], b[:-i])\\n                for i in range(1, len(a))\\n            )\\n\\n        return dp(first, second)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921919,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func isScramble(_ s1: String, _ s2: String) -> Bool {\\n        var dp: [String: Bool] = [:]\\n        \\n\\n        func _isScramble(_ chs1: [Character], _ chs2: [Character]) -> Bool {\\n            let key = String(chs1) + \"-\" +  String(chs2)\\n            if let v = dp[key] { return v }            \\n            if chs1.count == 1 { return chs1[0] == chs2[0] }\\n            var val = false\\n\\n            for i in 1..<chs1.count {\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[0..<i])) \\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[i..<chs2.count])))\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[chs2.count - i..<chs2.count]))\\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[0..<chs2.count-i]))) \\n            }\\n            \\n            dp[key] = val\\n            return val\\n        }\\n        \\n        if s1.count != s2.count {\\n            return false\\n        } else {\\n            return _isScramble(Array(s1), Array(s2))\\n        }\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isScramble(_ s1: String, _ s2: String) -> Bool {\\n        var dp: [String: Bool] = [:]\\n        \\n\\n        func _isScramble(_ chs1: [Character], _ chs2: [Character]) -> Bool {\\n            let key = String(chs1) + \"-\" +  String(chs2)\\n            if let v = dp[key] { return v }            \\n            if chs1.count == 1 { return chs1[0] == chs2[0] }\\n            var val = false\\n\\n            for i in 1..<chs1.count {\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[0..<i])) \\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[i..<chs2.count])))\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[chs2.count - i..<chs2.count]))\\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[0..<chs2.count-i]))) \\n            }\\n            \\n            dp[key] = val\\n            return val\\n        }\\n        \\n        if s1.count != s2.count {\\n            return false\\n        } else {\\n            return _isScramble(Array(s1), Array(s2))\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136817,
                "title": "c-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> ump;\\n    bool isScrambled(string s1, string s2){\\n        if(s1.size() != s2.size()) return false;\\n        int n = s1.size();\\n        if(s1==s2 or n==0) return true;\\n        \\n        string key = s1+\" \"+s2;\\n        if(ump.find(key) != ump.end()) return ump[key];\\n        \\n        \\n        bool flag = false;\\n        for(int i=1;i<n;i++){\\n            //for swaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(n-i,i)) and isScrambled(s1.substr(i,n-i),s2.substr(0,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n\\n            //for unswaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(0,i)) and isScrambled(s1.substr(i,n-i),s2.substr(i,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n        }\\n        ump[key]=flag;\\n        return flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size()) return false;\\n        return isScrambled(s1,s2);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> ump;\\n    bool isScrambled(string s1, string s2){\\n        if(s1.size() != s2.size()) return false;\\n        int n = s1.size();\\n        if(s1==s2 or n==0) return true;\\n        \\n        string key = s1+\" \"+s2;\\n        if(ump.find(key) != ump.end()) return ump[key];\\n        \\n        \\n        bool flag = false;\\n        for(int i=1;i<n;i++){\\n            //for swaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(n-i,i)) and isScrambled(s1.substr(i,n-i),s2.substr(0,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n\\n            //for unswaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(0,i)) and isScrambled(s1.substr(i,n-i),s2.substr(i,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n        }\\n        ump[key]=flag;\\n        return flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size()) return false;\\n        return isScrambled(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357479,
                "title": "java-easy-solution-using-hashmap-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    Map<String, Boolean> mp = new HashMap<>();\\n    \\n    public boolean helper(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() <= 1) return false;\\n        \\n        int n = a.length();\\n        boolean check = false;\\n        \\n        String key = a;\\n        \\n        key += \\' \\' + b;\\n        \\n        if(mp.containsKey(key))\\n             return mp.get(key);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\\n            \\n            if(swap || unswap){\\n                check = true;\\n                break;\\n            }\\n        }\\n        \\n        mp.put(key, check);\\n        \\n        return check;\\n    }\\n    \\n    public boolean isScramble(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.isEmpty() == true) return true;\\n        \\n        return helper(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Boolean> mp = new HashMap<>();\\n    \\n    public boolean helper(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() <= 1) return false;\\n        \\n        int n = a.length();\\n        boolean check = false;\\n        \\n        String key = a;\\n        \\n        key += \\' \\' + b;\\n        \\n        if(mp.containsKey(key))\\n             return mp.get(key);\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            boolean swap = helper(a.substring(0, i), b.substring(n - i)) && helper(a.substring(i), b.substring(0, n - i));\\n            boolean unswap = helper(a.substring(0,i), b.substring(0,i)) && helper(a.substring(i), b.substring(i));\\n            \\n            if(swap || unswap){\\n                check = true;\\n                break;\\n            }\\n        }\\n        \\n        mp.put(key, check);\\n        \\n        return check;\\n    }\\n    \\n    public boolean isScramble(String a, String b)\\n    {\\n        if(a.equals(b) == true) return true;\\n        \\n        if(a.length() != b.length()) return false;\\n        \\n        if(a.isEmpty() == true) return true;\\n        \\n        return helper(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779801,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> ump;\\n    bool isScrambled(string s1, string s2){\\n        if(s1.size() != s2.size()) return false;\\n        int n = s1.size();\\n        if(s1==s2 or n==0) return true;\\n        \\n        string key = s1+\" \"+s2;\\n        if(ump.find(key) != ump.end()) return ump[key];\\n        \\n        \\n        bool flag = false;\\n        for(int i=1;i<n;i++){\\n            //for swaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(n-i,i)) and isScrambled(s1.substr(i,n-i),s2.substr(0,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n\\n            //for unswaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(0,i)) and isScrambled(s1.substr(i,n-i),s2.substr(i,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n        }\\n        ump[key]=flag;\\n        return flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size()) return false;\\n        return isScrambled(s1,s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> ump;\\n    bool isScrambled(string s1, string s2){\\n        if(s1.size() != s2.size()) return false;\\n        int n = s1.size();\\n        if(s1==s2 or n==0) return true;\\n        \\n        string key = s1+\" \"+s2;\\n        if(ump.find(key) != ump.end()) return ump[key];\\n        \\n        \\n        bool flag = false;\\n        for(int i=1;i<n;i++){\\n            //for swaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(n-i,i)) and isScrambled(s1.substr(i,n-i),s2.substr(0,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n\\n            //for unswaped string\\n            if(isScrambled(s1.substr(0,i),s2.substr(0,i)) and isScrambled(s1.substr(i,n-i),s2.substr(i,n-i))){\\n                flag|=true;\\n                break;\\n            }\\n        }\\n        ump[key]=flag;\\n        return flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size()) return false;\\n        return isScrambled(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533183,
                "title": "python-9-line-recursive-solution-explained",
                "content": "Basically we try to simulate the construction of the binary tree, and recursively split both `s1` and `s2` into same size every time and check every pair of possible splits until all splits has only one character.\\nThe `sorted` is to avoid unnecessary recursions (that grow exponentially), and it turns out to be better than `set` and `collections.Counter` in terms of runtime.\\n```python\\ndef isScramble(self, s1: str, s2: str) -> bool:\\n    def split(l1, r1, l2, r2):\\n        if r1 - l1 == 1:\\n            return s1[l1] == s2[l2]\\n        if sorted(s1[l1:r1]) != sorted(s2[l2:r2]):\\n            return False\\n        for i in range(1, r1-l1):\\n            if split(l1, l1+i, l2, l2+i) and split(l1+i, r1, l2+i, r2) or \\\\\\n               split(l1, l1+i, r2-i, r2) and split(l1+i, r1, l2, r2-i):\\n                return True\\n    return split(0, len(s1), 0, len(s2))\\n```\\nVote up if you find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\ndef isScramble(self, s1: str, s2: str) -> bool:\\n    def split(l1, r1, l2, r2):\\n        if r1 - l1 == 1:\\n            return s1[l1] == s2[l2]\\n        if sorted(s1[l1:r1]) != sorted(s2[l2:r2]):\\n            return False\\n        for i in range(1, r1-l1):\\n            if split(l1, l1+i, l2, l2+i) and split(l1+i, r1, l2+i, r2) or \\\\\\n               split(l1, l1+i, r2-i, r2) and split(l1+i, r1, l2, r2-i):\\n                return True\\n    return split(0, len(s1), 0, len(s2))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 307320,
                "title": "c-solution-4ms-and-9-7-mb",
                "content": "```\\nbool isScramble(const string s1, const string s2) {\\n    if(s1==s2)\\n            return 1;\\n\\n        int len = s1.length();\\n        int count[26] = {0};\\n        for(int i=0; i<len; i++){\\n            count[s1[i]-\\'a\\']++;\\n            count[s2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(count[i]!=0)\\n                return 0;\\n        }\\n\\n        for(int i=1; i<=len-1; i++) {\\n            if( isScramble(s1.substr(0,i), s2.substr(0,i)) && isScramble(s1.substr(i), s2.substr(i)))\\n                return 1;\\n            if( isScramble(s1.substr(0,i), s2.substr(len-i)) && isScramble(s1.substr(i), s2.substr(0,len-i)))\\n                return 1;\\n        }\\n        return 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isScramble(const string s1, const string s2) {\\n    if(s1==s2)\\n            return 1;\\n\\n        int len = s1.length();\\n        int count[26] = {0};\\n        for(int i=0; i<len; i++){\\n            count[s1[i]-\\'a\\']++;\\n            count[s2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(count[i]!=0)\\n                return 0;\\n        }\\n\\n        for(int i=1; i<=len-1; i++) {\\n            if( isScramble(s1.substr(0,i), s2.substr(0,i)) && isScramble(s1.substr(i), s2.substr(i)))\\n                return 1;\\n            if( isScramble(s1.substr(0,i), s2.substr(len-i)) && isScramble(s1.substr(i), s2.substr(0,len-i)))\\n                return 1;\\n        }\\n        return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3108635,
                "title": "c-dp-memoization-easy-to-understand-recursion",
                "content": "# Complexity\\n- Time complexity:\\no(m*n)  m and n are sizes of given two strings\\n\\n- Space complexity:\\no(n+m)\\n\\n# Code\\n```\\nclass Solution {\\n\\nprivate:\\n\\n    unordered_map<string,bool> dp;\\n\\n    bool solve(string s1, string s2) {\\n        if(s1 == s2) return true;\\n\\n        if(dp.find(s1 + s2) != dp.end()) return dp[s1 + s2];\\n\\n        int n = s1.size();\\n        bool sub_check = false;\\n\\n        for(int i=1;i<n;i++) {\\n            bool swap = (solve(s1.substr(0,i), s2.substr(n-i,i)) && solve(s1.substr(i,n-i), s2.substr(0,n-i)));\\n            bool not_swap = (solve(s1.substr(0,i), s2.substr(0,i)) && solve(s1.substr(i,n), s2.substr(i,n)));\\n\\n            if(swap || not_swap) {\\n                sub_check = true;\\n                break;\\n            }\\n        }\\n\\n        return dp[s1 + s2] = sub_check;\\n    }\\n\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size()) return false;\\n        if(s1 == \"\" && s2 == \"\") return true;\\n        return solve(s1, s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n\\n    unordered_map<string,bool> dp;\\n\\n    bool solve(string s1, string s2) {\\n        if(s1 == s2) return true;\\n\\n        if(dp.find(s1 + s2) != dp.end()) return dp[s1 + s2];\\n\\n        int n = s1.size();\\n        bool sub_check = false;\\n\\n        for(int i=1;i<n;i++) {\\n            bool swap = (solve(s1.substr(0,i), s2.substr(n-i,i)) && solve(s1.substr(i,n-i), s2.substr(0,n-i)));\\n            bool not_swap = (solve(s1.substr(0,i), s2.substr(0,i)) && solve(s1.substr(i,n), s2.substr(i,n)));\\n\\n            if(swap || not_swap) {\\n                sub_check = true;\\n                break;\\n            }\\n        }\\n\\n        return dp[s1 + s2] = sub_check;\\n    }\\n\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size()) return false;\\n        if(s1 == \"\" && s2 == \"\") return true;\\n        return solve(s1, s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155263,
                "title": "aditya-verma-matrix-chain-multiplication-memoized-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> mp;\\n    bool isScramble(string a, string b) {\\n        if(a.compare(b)==0)\\n            return true;\\n        if(a.size()<=1)\\n            return false;\\n        string key=a;\\n        key.push_back(\\' \\');\\n        key.append(b);\\n        \\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        int n=a.size();\\n        bool flag=false;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if((isScramble(a.substr(0,i),b.substr(n-i,i))  && isScramble(a.substr(i,n-i),b.substr(0,n-i)))\\n              ||\\n              (isScramble(a.substr(0,i),b.substr(0,i))  && isScramble(a.substr(i,n-i),b.substr(i,n-i)))) {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        \\n        return mp[key]=flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> mp;\\n    bool isScramble(string a, string b) {\\n        if(a.compare(b)==0)\\n            return true;\\n        if(a.size()<=1)\\n            return false;\\n        string key=a;\\n        key.push_back(\\' \\');\\n        key.append(b);\\n        \\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        int n=a.size();\\n        bool flag=false;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if((isScramble(a.substr(0,i),b.substr(n-i,i))  && isScramble(a.substr(i,n-i),b.substr(0,n-i)))\\n              ||\\n              (isScramble(a.substr(0,i),b.substr(0,i))  && isScramble(a.substr(i,n-i),b.substr(i,n-i)))) {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        \\n        return mp[key]=flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099843,
                "title": "java-recursive-solution-mcm-type-aditya-verma-approach",
                "content": "```\\nclass Solution {\\n    Map<String,Boolean> map = new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length() != s2.length()) return false;\\n        return solve(s1,s2);\\n    }\\n    private boolean solve(String a, String b){\\n        int n = a.length();\\n        if(a.equals(b)) return true;\\n        \\n        String key = a + \" \" + b;\\n        if(map.containsKey(key)){\\n            return map.get(key);\\n        }\\n        boolean flag = false;\\n        for(int i=1;i<=n-1;i++){\\n            boolean noswap = solve(a.substring(0,i), b.substring(0,i)) &&\\n                            solve(a.substring(i), b.substring(i));\\n            \\n            boolean swap = solve(a.substring(0,i), b.substring(n-i)) &&\\n                            solve(a.substring(i), b.substring(0,n-i));\\n            \\n            if(swap || noswap){\\n                flag = true;\\n                break;\\n            }\\n        }\\n        map.put(key, flag);\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Map<String,Boolean> map = new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length() != s2.length()) return false;\\n        return solve(s1,s2);\\n    }\\n    private boolean solve(String a, String b){\\n        int n = a.length();\\n        if(a.equals(b)) return true;\\n        \\n        String key = a + \" \" + b;\\n        if(map.containsKey(key)){\\n            return map.get(key);\\n        }\\n        boolean flag = false;\\n        for(int i=1;i<=n-1;i++){\\n            boolean noswap = solve(a.substring(0,i), b.substring(0,i)) &&\\n                            solve(a.substring(i), b.substring(i));\\n            \\n            boolean swap = solve(a.substring(0,i), b.substring(n-i)) &&\\n                            solve(a.substring(i), b.substring(0,n-i));\\n            \\n            if(swap || noswap){\\n                flag = true;\\n                break;\\n            }\\n        }\\n        map.put(key, flag);\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205451,
                "title": "java-another-dp-solution-with-explanation",
                "content": "1. dp[i][j][1] indiates whether s1(i) equals to s2(j) and third dimension represents length.\\n2. dp[i][j][k] indicates whether s1(i, i+k) can be changed from s2(j, j+k).\\n3. if dp[i][j][l] and dp[i+l][j+l][k-l] are true, dp[i][j][k] is true. You can understand as which s1(i, i+l) and s2(j, j+l) is scramble and s1(i+l, i+k) and s2(j+l, j+k) is scramble, so s1(i, i+k) and s2(j, j+k) is scramble.\\n4. There is same argument. if dp[i][j+k-l][l] and dp[i+l][j][k-l] are true, dp[i][j][k] is true. \\n```\\npublic class Solution {\\n\\tpublic boolean isScramble(String s1, String s2) {\\n        if (s1 == null || s2 == null) return false;\\n        int m = s1.length();\\n        int n = s2.length();\\n        if (m != n) return false;\\n\\n        boolean[][][] dp = new boolean[m][m][m+1];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < m; j++) {\\n                dp[i][j][1] = s1.charAt(i) == s2.charAt(j);\\n            }\\n        }\\n\\n        for (int k = 2; k <= m; k++) {\\n            for (int i = 0; i <= m - k; i++) {\\n                for (int j = 0; j <= m - k; j++) {\\n                    dp[i][j][k] = false;\\n                    for (int part = 1; part < k; part++) {\\n                        if ((dp[i][j][l] && dp[i+l][j+l][k-l])\\n                                || (dp[i][j+k-l][l] && dp[i+l][j][k-l])) {\\n                            dp[i][j][k] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][s1.length()];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic boolean isScramble(String s1, String s2) {\\n        if (s1 == null || s2 == null) return false;\\n        int m = s1.length();\\n        int n = s2.length();\\n        if (m != n) return false;\\n\\n        boolean[][][] dp = new boolean[m][m][m+1];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < m; j++) {\\n                dp[i][j][1] = s1.charAt(i) == s2.charAt(j);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3357645,
                "title": "day-89-dp-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n*The problem of determining whether two strings are scrambled versions of each other is a challenging one. One way to approach this problem is to use dynamic programming. The key idea is to divide the strings into two non-empty substrings at a random index, and recursively apply the same process to each of these substrings. If one or both of the substrings can be scrambled into the corresponding substrings of the other string, then the original strings can be scrambled into each other as well.*\\n\\n*To solve this problem using dynamic programming, we can define a 3D boolean array dp[l][i][j] that stores whether a substring of length l starting at index i of s1 and a substring of length l starting at index j of s2 can be scrambled into each other. We can use a bottom-up approach and fill the array dp in a way that depends on its smaller values, i.e., we start with dp[1][i][j] for all i and j, which is simply the base case where l is 1. We then compute dp[l][i][j] for l > 1 by trying all possible ways to divide the substrings into two non-empty parts and recursively checking if the two parts can be scrambled into each other. If we find such a way, we set dp[l][i][j] to true.*\\n\\n*Finally, the answer to the problem is the value of dp[n][0][0], where n is the length of the input strings. This is because we want to determine whether the entire strings s1 and s2 can be scrambled into each other, which corresponds to the case where we consider substrings of length n starting at the beginning of both strings. If dp[n][0][0] is true, then the answer is yes, otherwise it is no.*\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Get the length of both strings s1 and s2 and check if they are equal. If not, return false.\\n2. Define a 3D boolean array dp[n+1][n][n] to store the results, where n is the length of the strings.\\n3. Initialize all values of dp to false using memset.\\n4. For the base case where the length of strings is 1, loop through both strings and if the characters are equal, set dp[1][i][j] to true.\\n5. For the general case where the length of strings is greater than 1, loop through all possible lengths of substrings (from 2 to n) and all possible starting positions of substrings (from 0 to n - length).\\n6. Divide the strings into two substrings at all possible positions and check if they are scrambled strings of each other in both swapped and same order using dp[k][i][j] and dp[l-k][i+k][j+k] and dp[k][i][j+l-k] and dp[l-k][i+k][j] respectively. If any of these checks returns true, set dp[l][i][j] to true and break out of the loop.\\n7. Return dp[n][0][0], which is the final result.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.length(); // Get the length of the strings\\n        if (n != s2.length()) { // If the lengths are not equal, return false\\n            return false;\\n        }\\n        bool dp[n + 1][n][n]; // Define a 3D boolean array to store the results\\n        memset(dp, false, sizeof(dp)); // Initialize all values to false\\n        for (int i = 0; i < n; i++) { // Base case: length 1\\n            for (int j = 0; j < n; j++) {\\n                if (s1[i] == s2[j]) { // If the characters are equal, set dp[1][i][j] to true\\n                    dp[1][i][j] = true;\\n                }\\n            }\\n        }\\n        for (int l = 2; l <= n; l++) { // General case: length > 1\\n            for (int i = 0; i <= n - l; i++) {\\n                for (int j = 0; j <= n - l; j++) {\\n                    for (int k = 1; k < l; k++) { // Divide the strings into two substrings at all possible positions\\n                        if ((dp[k][i][j] && dp[l - k][i + k][j + k]) || // Check if the two substrings are scrambled strings of each other in swapped order\\n                            (dp[k][i][j + l - k] && dp[l - k][i + k][j])) { // Check if the two substrings are scrambled strings of each other in same order\\n                            dp[l][i][j] = true; // If any one of these checks returns true, set dp[l][i][j] to true\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][0][0]; // Return dp[n][0][0], which is the final result\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        if (n != s2.length()) {\\n            return false;\\n        }\\n        boolean[][][] dp = new boolean[n + 1][n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    dp[1][i][j] = true;\\n                }\\n            }\\n        }\\n        for (int l = 2; l <= n; l++) {\\n            for (int i = 0; i <= n - l; i++) {\\n                for (int j = 0; j <= n - l; j++) {\\n                    for (int k = 1; k < l; k++) {\\n                        if ((dp[k][i][j] && dp[l - k][i + k][j + k]) ||\\n                            (dp[k][i][j + l - k] && dp[l - k][i + k][j])) {\\n                            dp[l][i][j] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][0][0];\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        if n != len(s2):\\n            return False\\n        dp = [[[False for _ in range(n)] for _ in range(n)] for _ in range(n + 1)]\\n        for i in range(n):\\n            for j in range(n):\\n                if s1[i] == s2[j]:\\n                    dp[1][i][j] = True\\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                for j in range(n - l + 1):\\n                    for k in range(1, l):\\n                        if (dp[k][i][j] and dp[l - k][i + k][j + k]) or (dp[k][i][j + l - k] and dp[l - k][i + k][j]):\\n                            dp[l][i][j] = True\\n                            break\\n        return dp[n][0][0]\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** ***O(n^4)**, where n is the length of s1. This is because there are n^2 possible starting indices for the substrings, and for each pair (i,j), we iterate over k, which can take up to l-1 values. Therefore, the innermost loop runs at most (l-1) times for each pair (i,j). The total number of iterations of the innermost loop is bounded by the sum of (l-1) over all possible values of l, which is O(n^3). The initialization of dp takes O(n^3) time, so the overall time complexity of the algorithm is O(n^4).*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** ***O(n^3)**, since we use a 3D array of size n+1 x n x n to store the intermediate results.*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.length(); // Get the length of the strings\\n        if (n != s2.length()) { // If the lengths are not equal, return false\\n            return false;\\n        }\\n        bool dp[n + 1][n][n]; // Define a 3D boolean array to store the results\\n        memset(dp, false, sizeof(dp)); // Initialize all values to false\\n        for (int i = 0; i < n; i++) { // Base case: length 1\\n            for (int j = 0; j < n; j++) {\\n                if (s1[i] == s2[j]) { // If the characters are equal, set dp[1][i][j] to true\\n                    dp[1][i][j] = true;\\n                }\\n            }\\n        }\\n        for (int l = 2; l <= n; l++) { // General case: length > 1\\n            for (int i = 0; i <= n - l; i++) {\\n                for (int j = 0; j <= n - l; j++) {\\n                    for (int k = 1; k < l; k++) { // Divide the strings into two substrings at all possible positions\\n                        if ((dp[k][i][j] && dp[l - k][i + k][j + k]) || // Check if the two substrings are scrambled strings of each other in swapped order\\n                            (dp[k][i][j + l - k] && dp[l - k][i + k][j])) { // Check if the two substrings are scrambled strings of each other in same order\\n                            dp[l][i][j] = true; // If any one of these checks returns true, set dp[l][i][j] to true\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][0][0]; // Return dp[n][0][0], which is the final result\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        if (n != s2.length()) {\\n            return false;\\n        }\\n        boolean[][][] dp = new boolean[n + 1][n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s1.charAt(i) == s2.charAt(j)) {\\n                    dp[1][i][j] = true;\\n                }\\n            }\\n        }\\n        for (int l = 2; l <= n; l++) {\\n            for (int i = 0; i <= n - l; i++) {\\n                for (int j = 0; j <= n - l; j++) {\\n                    for (int k = 1; k < l; k++) {\\n                        if ((dp[k][i][j] && dp[l - k][i + k][j + k]) ||\\n                            (dp[k][i][j + l - k] && dp[l - k][i + k][j])) {\\n                            dp[l][i][j] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][0][0];\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        if n != len(s2):\\n            return False\\n        dp = [[[False for _ in range(n)] for _ in range(n)] for _ in range(n + 1)]\\n        for i in range(n):\\n            for j in range(n):\\n                if s1[i] == s2[j]:\\n                    dp[1][i][j] = True\\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                for j in range(n - l + 1):\\n                    for k in range(1, l):\\n                        if (dp[k][i][j] and dp[l - k][i + k][j + k]) or (dp[k][i][j + l - k] and dp[l - k][i + k][j]):\\n                            dp[l][i][j] = True\\n                            break\\n        return dp[n][0][0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357423,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if len(s1)!=len(s2):\\n            return False\\n        m=dict()\\n        def f(a,b):\\n            if (a,b) in m:\\n                return m[(a,b)]\\n            if a==b:\\n                m[a,b]=True\\n                return True\\n            if len(a)!=len(b):\\n                m[(a,b)]=False\\n                return False\\n            \\n            for i in range(1,len(a)):\\n                if f(a[:i],b[:i]) and f(a[i:],b[i:]):\\n                    m[(a,b)]=True\\n                    return True\\n                if f(a[:i],b[-i:]) and f(a[i:],b[:len(a)-i]):\\n                    m[(a,b)]=True\\n                    return True\\n                \\n            m[(a,b)]=False\\n            return False\\n        return f(s1,s2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if len(s1)!=len(s2):\\n            return False\\n        m=dict()\\n        def f(a,b):\\n            if (a,b) in m:\\n                return m[(a,b)]\\n            if a==b:\\n                m[a,b]=True\\n                return True\\n            if len(a)!=len(b):\\n                m[(a,b)]=False\\n                return False\\n            \\n            for i in range(1,len(a)):\\n                if f(a[:i],b[:i]) and f(a[i:],b[i:]):\\n                    m[(a,b)]=True\\n                    return True\\n                if f(a[:i],b[-i:]) and f(a[i:],b[:len(a)-i]):\\n                    m[(a,b)]=True\\n                    return True\\n                \\n            m[(a,b)]=False\\n            return False\\n        return f(s1,s2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991482,
                "title": "c-mcm-variation-detailed-of-each-line-memoization-top-down-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> mp;          //Create Map Globally\\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size())          //Checking length of both string\\n            return false;\\n        if(s1.size()==0 && s2.size()==0)    //If both strings are empty\\n            return true;\\n        if(s1.compare(s2)==0)               //If both strings are same\\n            return true;\\n        if(s1.size()<=1)                    //Check size of String s1 is less tha 1 OR not\\n            return false;\\n        \\n        string key=s1;                      //Generating Key for Map which should be unique\\n        key.push_back(\\' \\');\\n        key.append(s2);\\n        if(mp.find(key) != mp.end())        //Storing value in map if found \\n            return mp[key];\\n        /*Till now if we didn\\'t find our value then we will calculate particularly */\\n        int n=s1.size();\\n        bool flag=false;\\n        for(int i=1;i<n;i++) {\\n            if((isScramble(s1.substr(0,i),s2.substr(n-i,i))==true\\n              && isScramble(s1.substr(i,n-i),s2.substr(0,n-i))==true)\\n                                      || \\n               (isScramble(s1.substr(0,i),s2.substr(0,i))==true\\n                && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))==true)) {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return mp[key]=flag;\\n    }\\n};\\n```\\n*NOTE : Guys this question is super Complex to understand at first time. So, if found difficult ,refer below links of Aditya Verma Sir :*\\n**First watch Recursive approach to understand concept (Must Watch) **: https://www.youtube.com/watch?v=SqA0o-DGmEw&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=40\\n **Then watch below video of Memoization DP Approach **: https://www.youtube.com/watch?v=VyHEglhbm-A&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=41",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool> mp;          //Create Map Globally\\n    bool isScramble(string s1, string s2) {\\n        if(s1.size() != s2.size())          //Checking length of both string\\n            return false;\\n        if(s1.size()==0 && s2.size()==0)    //If both strings are empty\\n            return true;\\n        if(s1.compare(s2)==0)               //If both strings are same\\n            return true;\\n        if(s1.size()<=1)                    //Check size of String s1 is less tha 1 OR not\\n            return false;\\n        \\n        string key=s1;                      //Generating Key for Map which should be unique\\n        key.push_back(\\' \\');\\n        key.append(s2);\\n        if(mp.find(key) != mp.end())        //Storing value in map if found \\n            return mp[key];\\n        /*Till now if we didn\\'t find our value then we will calculate particularly */\\n        int n=s1.size();\\n        bool flag=false;\\n        for(int i=1;i<n;i++) {\\n            if((isScramble(s1.substr(0,i),s2.substr(n-i,i))==true\\n              && isScramble(s1.substr(i,n-i),s2.substr(0,n-i))==true)\\n                                      || \\n               (isScramble(s1.substr(0,i),s2.substr(0,i))==true\\n                && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))==true)) {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return mp[key]=flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357803,
                "title": "dynamic-programming-c-recursion-with-explanation",
                "content": "Hi LeetCode Heros, Hope you are doing great.\\nTo solve this problem we just have to try all possible opration on first string and see If we can get the second string.\\nTo do that we maintain two indcies one for the first string **l1** \\nand the second for the second string **l2** \\nand another variable for the current string size **len** \\nlets start from this example input string \\n![image](https://assets.leetcode.com/users/images/05d7ac32-b194-4fb0-93e3-3558db4ea0a1_1680149563.9615712.png)\\nlets declare that  \\n**a[l1: len]** -> substring of first string that start at index **l1** and has size = len\\n**b[l2: len]** -> substring of first string that start at index **l2** and has size = len\\n**solve(l1, l2, len)** = is **string a[l1:len] == b[l2:len]**\\nif **a[l1: len] == b[l2: len]** we are done just return true \\notherwise we can try all possoble split to split the first string \\ntry cut = 1 \\nwe have string \\n**a = x + y** \\n**x = \"4\"**\\n**y = \"132\"**\\nwe have \\n![image](https://assets.leetcode.com/users/images/13147b93-ba46-4fc1-8d20-539faa98a030_1680149739.7371008.png)\\nand solve the two parts recursivley \\n**solve(l1, l2, len) = solve(l1, l2, cut) && solve(l1+cut, l2+cut, (len-cut))**\\nor we make \\n**a = y + x** \\n**x = \"4\"**\\n**y = \"132\"**\\n![image](https://assets.leetcode.com/users/images/0d11bd7c-a4a7-4a9e-912a-9183f6f30eaa_1680150156.2705226.png)\\nkeep in mind that string **b** still without change we just play with string **a**\\nand solve two parts recursivley \\n**solve(l1, l2, len) = solve(l1, l2+(len-cut), cut) && solve(l1+cut, l2, len - cut)**\\nand these 3 variable are enough to determine the two substrings so we can memo on them\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[30][30][31];\\n    int solve(string& a, string& b, int l1, int l2, int len){\\n        int& ret = dp[l1][l2][len];\\n        if (~ret) return ret;\\n        ret = 0;\\n        bool sameString = 1;\\n        for (int i = 0; i < len && sameString; i++){\\n            sameString &= (a[i+l1] == b[i+l2]);\\n        }\\n        ret = sameString;\\n\\t\\t// if the two substrings are equal or only remain substring of size = 1 \\n        if (len == 1 || sameString) return sameString;\\n        for (int cut = 1; !ret && cut < len; cut++){\\n            ret = (solve(a, b, l1, l2, cut) && \\n\\t\\t\\t\\t\\tsolve(a, b, l1 + cut, l2 + cut, len - cut));\\n\\t\\t\\t// if ret == 1, we won\\'t going to try this ... reason for ret || \\n            ret = (ret || (solve(a, b, l1+cut, l2, len - cut) && \\n\\t\\t\\t\\t\\t\\t\\tsolve(a, b, l1, l2 + len - cut, cut)));\\n        }\\n        return ret;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp, -1 ,sizeof dp);\\n        return solve(s1, s2, 0, 0, s1.size());\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[30][30][31];\\n    int solve(string& a, string& b, int l1, int l2, int len){\\n        int& ret = dp[l1][l2][len];\\n        if (~ret) return ret;\\n        ret = 0;\\n        bool sameString = 1;\\n        for (int i = 0; i < len && sameString; i++){\\n            sameString &= (a[i+l1] == b[i+l2]);\\n        }\\n        ret = sameString;\\n\\t\\t// if the two substrings are equal or only remain substring of size = 1 \\n        if (len == 1 || sameString) return sameString;\\n        for (int cut = 1; !ret && cut < len; cut++){\\n            ret = (solve(a, b, l1, l2, cut) && \\n\\t\\t\\t\\t\\tsolve(a, b, l1 + cut, l2 + cut, len - cut));\\n\\t\\t\\t// if ret == 1, we won\\'t going to try this ... reason for ret || \\n            ret = (ret || (solve(a, b, l1+cut, l2, len - cut) && \\n\\t\\t\\t\\t\\t\\t\\tsolve(a, b, l1, l2 + len - cut, cut)));\\n        }\\n        return ret;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp, -1 ,sizeof dp);\\n        return solve(s1, s2, 0, 0, s1.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357592,
                "title": "c-dp-faster-easy-to-understand",
                "content": "* ***DP***\\n\\n* ***Time Complexity :- O(N ^ 4)***\\n\\n* ***Space Complexity :- O(N ^ 2)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare an unordered map\\n    \\n    unordered_map<string, bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        // base case\\n        \\n        if(s1 == s2)\\n            return true;\\n        \\n        // create an unique key\\n        \\n        string key = s1 + \"*\" + s2;\\n        \\n        // if already calculated\\n        \\n        if(mp.count(key))\\n            return mp[key];\\n        \\n        for(int i = 0; i < s1.size() - 1; i++)\\n        {\\n            if(isScramble(s1.substr(0, i + 1), s2.substr(0, i + 1)) && isScramble(s1.substr(i + 1), s2.substr(i + 1)))\\n            {\\n                return mp[key] = true;\\n            }\\n            \\n            if(isScramble(s1.substr(0, i + 1), s2.substr(s2.size() - i - 1)) && isScramble(s1.substr(i + 1), s2.substr(0, s2.size() - i - 1)))\\n            {\\n                return mp[key] = true;\\n            } \\n        }\\n        \\n        // store the res and return it\\n        \\n        return mp[key] = false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare an unordered map\\n    \\n    unordered_map<string, bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        // base case\\n        \\n        if(s1 == s2)\\n            return true;\\n        \\n        // create an unique key\\n        \\n        string key = s1 + \"*\" + s2;\\n        \\n        // if already calculated\\n        \\n        if(mp.count(key))\\n            return mp[key];\\n        \\n        for(int i = 0; i < s1.size() - 1; i++)\\n        {\\n            if(isScramble(s1.substr(0, i + 1), s2.substr(0, i + 1)) && isScramble(s1.substr(i + 1), s2.substr(i + 1)))\\n            {\\n                return mp[key] = true;\\n            }\\n            \\n            if(isScramble(s1.substr(0, i + 1), s2.substr(s2.size() - i - 1)) && isScramble(s1.substr(i + 1), s2.substr(0, s2.size() - i - 1)))\\n            {\\n                return mp[key] = true;\\n            } \\n        }\\n        \\n        // store the res and return it\\n        \\n        return mp[key] = false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923664,
                "title": "92-faster-recursive-solution-unordered-map-optimization",
                "content": "just a recursive Solution with some optimizaions.\\n1.  Length of Both String should be same to match.\\n2. Use of unordered_map to  store recursive Calls (concat both String  and assign boolean value  )\\n3. True if Both Strings are Same.\\n\\n```\\n   unordered_map<string,bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())return false;\\n        if(s1.length()==1)return s1[0]==s2[0];\\n        if(s1==s2)return true;\\n        string concat = s1+\"/\"+s2;\\n        if(mp.find(concat)!=mp.end())return mp[concat];\\n        mp[concat] =false;\\n        vector<int> c(256,0);\\n        int  n = s1.length();\\n        for(int i=0;i<n;i++){\\n            c[s1[i]]++;\\n            c[s2[i]]--;\\n        }\\n        for(auto ch:s1){\\n            if(c[ch]!=0)return false;\\n        }\\n        for(int i=1;i<n;i++){\\n            \\n            if(isScramble(s1.substr(0,i),s2.substr(0,i))&& \\n               isScramble(s1.substr(i),s2.substr(i)))return   mp[concat]= true;\\n            if(isScramble(s1.substr(0,i),s2.substr(n-i))&& \\n               isScramble(s1.substr(i),s2.substr(0,n-i)))return mp[concat]= true;\\n        }\\n        \\n        return false;\\n    }\\n```\\n15 ms Solution\\n93% faster .\\nC++",
                "solutionTags": [
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n   unordered_map<string,bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())return false;\\n        if(s1.length()==1)return s1[0]==s2[0];\\n        if(s1==s2)return true;\\n        string concat = s1+\"/\"+s2;\\n        if(mp.find(concat)!=mp.end())return mp[concat];\\n        mp[concat] =false;\\n        vector<int> c(256,0);\\n        int  n = s1.length();\\n        for(int i=0;i<n;i++){\\n            c[s1[i]]++;\\n            c[s2[i]]--;\\n        }\\n        for(auto ch:s1){\\n            if(c[ch]!=0)return false;\\n        }\\n        for(int i=1;i<n;i++){\\n            \\n            if(isScramble(s1.substr(0,i),s2.substr(0,i))&& \\n               isScramble(s1.substr(i),s2.substr(i)))return   mp[concat]= true;\\n            if(isScramble(s1.substr(0,i),s2.substr(n-i))&& \\n               isScramble(s1.substr(i),s2.substr(0,n-i)))return mp[concat]= true;\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1223854,
                "title": "python-o-n-4-bottom-up-dp-solution",
                "content": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        dp = [[[False for i in range(n + 1)] for i in range(n)] for i in range(n)]\\n        \\n        for l in range(1,n + 1):\\n            for i in range(n - l + 1):\\n                for j in range(n - l + 1):\\n                    if l == 1:\\n                        dp[i][j][l] = s1[i] == s2[j]\\n                    else:\\n                        for k in range(1,l):\\n                            dp[i][j][l] = dp[i][j][l] or ((dp[i][j][k] and dp[i + k][j + k][l - k]) or (dp[i][j + l - k][k] and dp[i + k][j][l - k]))\\n                            if dp[i][j][l]:\\n                                break\\n        return dp[0][0][n]\\n```\\n**PS: Please upvote if you liked the solution.**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        n = len(s1)\\n        dp = [[[False for i in range(n + 1)] for i in range(n)] for i in range(n)]\\n        \\n        for l in range(1,n + 1):\\n            for i in range(n - l + 1):\\n                for j in range(n - l + 1):\\n                    if l == 1:\\n                        dp[i][j][l] = s1[i] == s2[j]\\n                    else:\\n                        for k in range(1,l):\\n                            dp[i][j][l] = dp[i][j][l] or ((dp[i][j][k] and dp[i + k][j + k][l - k]) or (dp[i][j + l - k][k] and dp[i + k][j][l - k]))\\n                            if dp[i][j][l]:\\n                                break\\n        return dp[0][0][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525488,
                "title": "c-dp-top-down-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/scramble-string/submissions/\\n    TC: O(N^2)\\n*/\\nclass Solution {\\npublic:\\n    // checks if s2 is scrambled form of s1\\n    /*\\n        The idea is to find a position in string s1, from where scrambling must have\\n        started to create s2. So if k is the position, then s1[0-k] and s1[k+1, N-1]\\n        were the last scramble op. We do this recursively for the smaller substrings.\\n        \\n    */\\n    bool isScrambled(int s1_start, int s1_end, int s2_start, int s2_end,\\n                    string& s1, string& s2, unordered_map<string, bool>& dp) {\\n        // create the current position combination\\n        string curr_cmb = to_string(s1_start) + \\',\\' + to_string(s1_end) + \\n                            \\',\\' + to_string(s2_start) + \\',\\' + to_string(s2_end);\\n        // check if the values is in cache \\n        auto it = dp.find(curr_cmb);\\n        if(it != dp.end())\\n            return dp[curr_cmb];\\n        \\n        // base cases\\n        if(s1_end < s1_start || s2_end < s2_start)\\n            return false;\\n        // if the size of two strings is diff, then scrambling not poss\\n        if(s1_end - s1_start != s2_end - s2_start)\\n            return false;\\n        // if the two substrings match, then they are scrambled\\n        if(s1.substr(s1_start, s1_end - s1_start + 1) == s2.substr(s2_start, s2_end - s2_start + 1))\\n            return true;\\n        \\n        // check if the two substrings contains the same set of chars\\n        vector<int> char_freq(256, 0);\\n        for(int i = 0; i <= s1_end - s1_start; i++)\\n            char_freq[s1[s1_start + i]-\\'a\\']++, char_freq[s2[s2_start + i]-\\'a\\']--;\\n        for(int i = 0; i < 256; i++)\\n            if(char_freq[i]) \\n\\t\\t\\t\\treturn false;\\n        \\n        // find a position which is the potential scramble point\\n        for(int k = 0; k < (s1_end - s1_start); k++) {\\n            // check for s1[start: k], s2[start:k] and s1[k+1 : end], s2[k+1 : end]\\n            if(isScrambled(s1_start, s1_start + k, s2_start, s2_start + k, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start + k + 1, s2_end, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n            // Now incase of s2, maybe scramble opertation was performed at k, so \\n            // now check if the other half of s2\\n            // check for s1[start: k], s2[end - k : end] and s1[k+1 : end], s2[s : end - k - 1]\\n            if(isScrambled(s1_start, s1_start + k, s2_end - k, s2_end, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start, s2_end - k - 1, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n        }\\n        return dp[curr_cmb] = false;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        // DP cache: saves the result of (s1_start, s1_end, s2_start, s2_end) cmb\\n        unordered_map<string, bool> dp;\\n        return isScrambled(0, s1.size()-1, 0, s2.size()-1, s1, s2, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/scramble-string/submissions/\\n    TC: O(N^2)\\n*/\\nclass Solution {\\npublic:\\n    // checks if s2 is scrambled form of s1\\n    /*\\n        The idea is to find a position in string s1, from where scrambling must have\\n        started to create s2. So if k is the position, then s1[0-k] and s1[k+1, N-1]\\n        were the last scramble op. We do this recursively for the smaller substrings.\\n        \\n    */\\n    bool isScrambled(int s1_start, int s1_end, int s2_start, int s2_end,\\n                    string& s1, string& s2, unordered_map<string, bool>& dp) {\\n        // create the current position combination\\n        string curr_cmb = to_string(s1_start) + \\',\\' + to_string(s1_end) + \\n                            \\',\\' + to_string(s2_start) + \\',\\' + to_string(s2_end);\\n        // check if the values is in cache \\n        auto it = dp.find(curr_cmb);\\n        if(it != dp.end())\\n            return dp[curr_cmb];\\n        \\n        // base cases\\n        if(s1_end < s1_start || s2_end < s2_start)\\n            return false;\\n        // if the size of two strings is diff, then scrambling not poss\\n        if(s1_end - s1_start != s2_end - s2_start)\\n            return false;\\n        // if the two substrings match, then they are scrambled\\n        if(s1.substr(s1_start, s1_end - s1_start + 1) == s2.substr(s2_start, s2_end - s2_start + 1))\\n            return true;\\n        \\n        // check if the two substrings contains the same set of chars\\n        vector<int> char_freq(256, 0);\\n        for(int i = 0; i <= s1_end - s1_start; i++)\\n            char_freq[s1[s1_start + i]-\\'a\\']++, char_freq[s2[s2_start + i]-\\'a\\']--;\\n        for(int i = 0; i < 256; i++)\\n            if(char_freq[i]) \\n\\t\\t\\t\\treturn false;\\n        \\n        // find a position which is the potential scramble point\\n        for(int k = 0; k < (s1_end - s1_start); k++) {\\n            // check for s1[start: k], s2[start:k] and s1[k+1 : end], s2[k+1 : end]\\n            if(isScrambled(s1_start, s1_start + k, s2_start, s2_start + k, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start + k + 1, s2_end, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n            // Now incase of s2, maybe scramble opertation was performed at k, so \\n            // now check if the other half of s2\\n            // check for s1[start: k], s2[end - k : end] and s1[k+1 : end], s2[s : end - k - 1]\\n            if(isScrambled(s1_start, s1_start + k, s2_end - k, s2_end, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start, s2_end - k - 1, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n        }\\n        return dp[curr_cmb] = false;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        // DP cache: saves the result of (s1_start, s1_end, s2_start, s2_end) cmb\\n        unordered_map<string, bool> dp;\\n        return isScrambled(0, s1.size()-1, 0, s2.size()-1, s1, s2, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29425,
                "title": "simple-to-understand-python-recursive-solution",
                "content": "    from collections import Counter\\n    class Solution(object):\\n        def isScramble(self, s1, s2):\\n            if s1 == s2: return True\\n            if Counter(s1) != Counter(s2): return False # early backtracking\\n            for i in xrange(1,len(s1)):\\n                if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])): return True\\n                if (self.isScramble(s1[:i], s2[-(i):]) and self.isScramble(s1[i:], s2[:-(i)])): return True\\n            return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "    from collections import Counter\\n    class Solution(object):\\n        def isScramble(self, s1, s2):\\n            if s1 == s2: return True\\n            if Counter(s1) != Counter(s2): return False # early backtracking\\n            for i in xrange(1,len(s1)):\\n                if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])): return True\\n                if (self.isScramble(s1[:i], s2[-(i):]) and self.isScramble(s1[i:], s2[:-(i)])): return True\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 3358593,
                "title": "python-3-dfs-dp-top-down-memoization-steps-by-steps-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS Solution (TLE)\\n\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        def dfs(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n\\n            for i in range(1, len(s1)):\\n                if (dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:])) or \\\\\\n                    (dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dfs(s1,s2)\\n```\\n\\n2. Optimized DFS (TLE - 3 tests)\\n\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        def dfs(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n            if sorted(s1) != sorted(s2): return False\\n\\n            for i in range(1, len(s1)):\\n                if (dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:])) or \\\\\\n                    (dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dfs(s1,s2)\\n```\\n\\n3. DP Top-down memoization\\n\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def dp(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n\\n            for i in range(1, len(s1)):\\n                if (dp(s1[:i], s2[:i]) and dp(s1[i:], s2[i:])) or \\\\\\n                    (dp(s1[:i], s2[-i:]) and dp(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dp(s1,s2)\\n```\\n\\n4. Optimized DP\\n\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def dp(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n            if sorted(s1) != sorted(s2): return False\\n\\n            for i in range(1, len(s1)):\\n                if (dp(s1[:i], s2[:i]) and dp(s1[i:], s2[i:])) or \\\\\\n                    (dp(s1[:i], s2[-i:]) and dp(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dp(s1,s2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        def dfs(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n\\n            for i in range(1, len(s1)):\\n                if (dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:])) or \\\\\\n                    (dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dfs(s1,s2)\\n```\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        def dfs(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n            if sorted(s1) != sorted(s2): return False\\n\\n            for i in range(1, len(s1)):\\n                if (dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:])) or \\\\\\n                    (dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dfs(s1,s2)\\n```\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def dp(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n\\n            for i in range(1, len(s1)):\\n                if (dp(s1[:i], s2[:i]) and dp(s1[i:], s2[i:])) or \\\\\\n                    (dp(s1[:i], s2[-i:]) and dp(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dp(s1,s2)\\n```\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def dp(s1: str, s2: str) -> bool:\\n            if s1 == s2: return True\\n            if sorted(s1) != sorted(s2): return False\\n\\n            for i in range(1, len(s1)):\\n                if (dp(s1[:i], s2[:i]) and dp(s1[i:], s2[i:])) or \\\\\\n                    (dp(s1[:i], s2[-i:]) and dp(s1[i:], s2[:-i])): return True\\n            return False\\n\\n        return dp(s1,s2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358560,
                "title": "dynamic-programming-solution-to-check-if-strings-are-scrambled-with-easy-and-full-explanation",
                "content": "# Intuition\\nThe problem can be solved using a dynamic programming approach where we check if the substrings of s1 and s2 are scrambled strings or not. We start by checking the base cases, which is when the length of the substring is 1. We then recursively check all possible split points and if the substrings are swapped or not.\\n\\n# Approach\\nThe solution uses a dynamic programming approach to solve the problem. Let dp[i][j][len] be true if the substring s1[i:i+len] is a scrambled string of the substring s2[j:j+len], and false otherwise.\\n\\nThe base case is when len = 1, in which case we just need to check if the characters in the substrings are equal. If they are, then we set dp[i][j][1] to true, otherwise to false.\\n\\nFor the recursive case, we try all possible split points of the substrings s1[i:i+len] and s2[j:j+len]. If the substrings are split at position k, we have two possibilities: either the substrings are not swapped, or they are swapped. If they are not swapped, then we need to check if the left halves and right halves are scrambled strings, i.e., dp[i][j][k] && dp[i+k][j+k][len-k]. If they are swapped, then we need to check if the left half of s1 and the right half of s2 are scrambled strings, and if the right half of s1 and the left half of s2 are scrambled strings, i.e., dp[i][j+len-k][k] && dp[i+k][j][len-k].\\n\\nThe overall solution is the value of dp[0][0][n], where n is the length of the input strings.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is O(n^4), where n is the length of the input strings. This is because we have three nested loops, and the length of the substrings can be up to n.\\n\\n- Space complexity:\\nThe space complexity of the solution is O(n^3), where n is the length of the input strings. This is because we need to store the results of all possible substring combinations in the 3D array dp.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if (s1 == s2) {\\n            return true;\\n        }\\n        int n = s1.length();\\n        if (n != s2.length()) {\\n            return false;\\n        }\\n        vector<int> count(26, 0);\\n        for (int i = 0; i < n; i++) {\\n            count[s1[i] - \\'a\\']++;\\n            count[s2[i] - \\'a\\']--;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                return false;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(n + 1, -1)));\\n        return isScrambleHelper(s1, s2, 0, 0, n, dp);\\n    }\\n    \\n    bool isScrambleHelper(string& s1, string& s2, int i, int j, int len, vector<vector<vector<int>>>& dp) {\\n        if (dp[i][j][len] != -1) {\\n            return dp[i][j][len];\\n        }\\n        if (s1.substr(i, len) == s2.substr(j, len)) {\\n            return dp[i][j][len] = true;\\n        }\\n        vector<int> count(26, 0);\\n        for (int k = 0; k < len; k++) {\\n            count[s1[i + k] - \\'a\\']++;\\n            count[s2[j + k] - \\'a\\']--;\\n        }\\n        for (int k = 0; k < 26; k++) {\\n            if (count[k] != 0) {\\n                return dp[i][j][len] = false;\\n            }\\n        }\\n        for (int k = 1; k < len; k++) {\\n            if ((isScrambleHelper(s1, s2, i, j, k, dp) && isScrambleHelper(s1, s2, i + k, j + k, len - k, dp)) ||\\n               (isScrambleHelper(s1, s2, i, j + len - k, k, dp) && isScrambleHelper(s1, s2, i + k, j, len - k, dp))) {\\n                return dp[i][j][len] = true;\\n            }\\n        }\\n        return dp[i][j][len] = false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if (s1 == s2) {\\n            return true;\\n        }\\n        int n = s1.length();\\n        if (n != s2.length()) {\\n            return false;\\n        }\\n        vector<int> count(26, 0);\\n        for (int i = 0; i < n; i++) {\\n            count[s1[i] - \\'a\\']++;\\n            count[s2[i] - \\'a\\']--;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                return false;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(n + 1, -1)));\\n        return isScrambleHelper(s1, s2, 0, 0, n, dp);\\n    }\\n    \\n    bool isScrambleHelper(string& s1, string& s2, int i, int j, int len, vector<vector<vector<int>>>& dp) {\\n        if (dp[i][j][len] != -1) {\\n            return dp[i][j][len];\\n        }\\n        if (s1.substr(i, len) == s2.substr(j, len)) {\\n            return dp[i][j][len] = true;\\n        }\\n        vector<int> count(26, 0);\\n        for (int k = 0; k < len; k++) {\\n            count[s1[i + k] - \\'a\\']++;\\n            count[s2[j + k] - \\'a\\']--;\\n        }\\n        for (int k = 0; k < 26; k++) {\\n            if (count[k] != 0) {\\n                return dp[i][j][len] = false;\\n            }\\n        }\\n        for (int k = 1; k < len; k++) {\\n            if ((isScrambleHelper(s1, s2, i, j, k, dp) && isScrambleHelper(s1, s2, i + k, j + k, len - k, dp)) ||\\n               (isScrambleHelper(s1, s2, i, j + len - k, k, dp) && isScrambleHelper(s1, s2, i + k, j, len - k, dp))) {\\n                return dp[i][j][len] = true;\\n            }\\n        }\\n        return dp[i][j][len] = false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357734,
                "title": "easiest-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n^4)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n\\n        Map<String, Boolean> memo = new HashMap<>();\\n        return isScrambleHelper(s1, s2, memo);\\n    }\\n\\n    private boolean isScrambleHelper(String s1, String s2, Map<String, Boolean> memo) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (memo.containsKey(s1 + \"#\" + s2)) {\\n            return memo.get(s1 + \"#\" + s2);\\n        }\\n\\n        int n = s1.length();\\n        for (int i = 1; i < n; i++) {\\n            if (isScrambleHelper(s1.substring(0, i), s2.substring(0, i), memo) &&\\n                isScrambleHelper(s1.substring(i), s2.substring(i), memo)) {\\n                memo.put(s1 + \"#\" + s2, true);\\n                return true;\\n            }\\n            if (isScrambleHelper(s1.substring(0, i), s2.substring(n-i), memo) &&\\n                isScrambleHelper(s1.substring(i), s2.substring(0, n-i), memo)) {\\n                memo.put(s1 + \"#\" + s2, true);\\n                return true;\\n            }\\n        }\\n\\n        memo.put(s1 + \"#\" + s2, false);\\n        return false;\\n    }\\n}\\n```\\n# Upvoting is much appreciated",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n\\n        Map<String, Boolean> memo = new HashMap<>();\\n        return isScrambleHelper(s1, s2, memo);\\n    }\\n\\n    private boolean isScrambleHelper(String s1, String s2, Map<String, Boolean> memo) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (memo.containsKey(s1 + \"#\" + s2)) {\\n            return memo.get(s1 + \"#\" + s2);\\n        }\\n\\n        int n = s1.length();\\n        for (int i = 1; i < n; i++) {\\n            if (isScrambleHelper(s1.substring(0, i), s2.substring(0, i), memo) &&\\n                isScrambleHelper(s1.substring(i), s2.substring(i), memo)) {\\n                memo.put(s1 + \"#\" + s2, true);\\n                return true;\\n            }\\n            if (isScrambleHelper(s1.substring(0, i), s2.substring(n-i), memo) &&\\n                isScrambleHelper(s1.substring(i), s2.substring(0, n-i), memo)) {\\n                memo.put(s1 + \"#\" + s2, true);\\n                return true;\\n            }\\n        }\\n\\n        memo.put(s1 + \"#\" + s2, false);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426144,
                "title": "c-bottom-up",
                "content": "just get gud to understand\\n\\n```cpp\\nclass Solution {\\n   public:\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.size();\\n        bool dp[n][n][n + 1];\\n        memset(dp, 0, sizeof dp);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s1[i] == s2[j]) {\\n                    dp[i][j][0] = true;\\n                }\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                for (int j = 0; j <= n - len; j++) {\\n                    for (int len1 = 1; len1 <= len - 1; len1++) {\\n                        int len2 = len - len1;\\n                        dp[i][j][len - 1] |= dp[i][j][len1 - 1] && dp[i + len1][j + len1][len2 - 1];\\n                        dp[i][j][len - 1] |= dp[i][j + len2][len1 - 1] && dp[i + len1][j][len2 - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][n - 1];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n   public:\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.size();\\n        bool dp[n][n][n + 1];\\n        memset(dp, 0, sizeof dp);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s1[i] == s2[j]) {\\n                    dp[i][j][0] = true;\\n                }\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                for (int j = 0; j <= n - len; j++) {\\n                    for (int len1 = 1; len1 <= len - 1; len1++) {\\n                        int len2 = len - len1;\\n                        dp[i][j][len - 1] |= dp[i][j][len1 - 1] && dp[i + len1][j + len1][len2 - 1];\\n                        dp[i][j][len - 1] |= dp[i][j + len2][len1 - 1] && dp[i + len1][j][len2 - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][n - 1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990829,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\npublic class Solution {\\n\\tpublic boolean isScramble(String s1, String s2) {\\n\\t\\tif (s1.length() != s2.length()) return false;\\n\\t\\tint len = s1.length();\\n\\t\\t/**\\n\\t\\t * Let F(i, j, k) = whether the substring S1[i..i + k - 1] is a scramble of S2[j..j + k - 1] or not\\n\\t\\t * Since each of these substrings is a potential node in the tree, we need to check for all possible cuts.\\n\\t\\t * Let q be the length of a cut (hence, q < k), then we are in the following situation:\\n\\t\\t * \\n\\t\\t * S1 [   x1    |         x2         ]\\n\\t\\t *    i         i + q                i + k - 1\\n\\t\\t * \\n\\t\\t * here we have two possibilities:\\n\\t\\t *      \\n\\t\\t * S2 [   y1    |         y2         ]\\n\\t\\t *    j         j + q                j + k - 1\\n\\t\\t *    \\n\\t\\t * or \\n\\t\\t * \\n\\t\\t * S2 [       y1        |     y2     ]\\n\\t\\t *    j                 j + k - q    j + k - 1\\n\\t\\t * \\n\\t\\t * which in terms of F means:\\n\\t\\t * \\n\\t\\t * F(i, j, k) = for some 1 <= q < k we have:\\n\\t\\t *  (F(i, j, q) AND F(i + q, j + q, k - q)) OR (F(i, j + k - q, q) AND F(i + q, j, k - q))\\n\\t\\t *  \\n\\t\\t * Base case is k = 1, where we simply need to check for S1[i] and S2[j] to be equal \\n\\t\\t * */\\n\\t\\tboolean [][][] F = new boolean[len][len][len + 1];\\n\\t\\tfor (int k = 1; k <= len; ++k)\\n\\t\\t\\tfor (int i = 0; i + k <= len; ++i)\\n\\t\\t\\t\\tfor (int j = 0; j + k <= len; ++j)\\n\\t\\t\\t\\t\\tif (k == 1)\\n\\t\\t\\t\\t\\t\\tF[i][j][k] = s1.charAt(i) == s2.charAt(j);\\n\\t\\t\\t\\t\\telse for (int q = 1; q < k && !F[i][j][k]; ++q) {\\n\\t\\t\\t\\t\\t\\tF[i][j][k] = (F[i][j][q] && F[i + q][j + q][k - q]) || (F[i][j + k - q][q] && F[i + q][j][k - q]);\\n\\t\\t\\t\\t\\t}\\n\\t\\treturn F[0][0][len];\\n\\t}\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    // checks if s2 is scrambled form of s1\\n    /*\\n        The idea is to find a position in string s1, from where scrambling must have\\n        started to create s2. So if k is the position, then s1[0-k] and s1[k+1, N-1]\\n        were the last scramble op. We do this recursively for the smaller substrings.\\n        \\n    */\\n    bool isScrambled(int s1_start, int s1_end, int s2_start, int s2_end,\\n                    string& s1, string& s2, unordered_map<string, bool>& dp) {\\n        // create the current position combination\\n        string curr_cmb = to_string(s1_start) + \\',\\' + to_string(s1_end) + \\n                            \\',\\' + to_string(s2_start) + \\',\\' + to_string(s2_end);\\n        // check if the values is in cache \\n        auto it = dp.find(curr_cmb);\\n        if(it != dp.end())\\n            return dp[curr_cmb];\\n        \\n        // base cases\\n        if(s1_end < s1_start || s2_end < s2_start)\\n            return false;\\n        // if the size of two strings is diff, then scrambling not poss\\n        if(s1_end - s1_start != s2_end - s2_start)\\n            return false;\\n        // if the two substrings match, then they are scrambled\\n        if(s1.substr(s1_start, s1_end - s1_start + 1) == s2.substr(s2_start, s2_end - s2_start + 1))\\n            return true;\\n        \\n        // check if the two substrings contains the same set of chars\\n        vector<int> char_freq(256, 0);\\n        for(int i = 0; i <= s1_end - s1_start; i++)\\n            char_freq[s1[s1_start + i]-\\'a\\']++, char_freq[s2[s2_start + i]-\\'a\\']--;\\n        for(int i = 0; i < 256; i++)\\n            if(char_freq[i]) \\n\\t\\t\\t\\treturn false;\\n        \\n        // find a position which is the potential scramble point\\n        for(int k = 0; k < (s1_end - s1_start); k++) {\\n            // check for s1[start: k], s2[start:k] and s1[k+1 : end], s2[k+1 : end]\\n            if(isScrambled(s1_start, s1_start + k, s2_start, s2_start + k, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start + k + 1, s2_end, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n            // Now incase of s2, maybe scramble opertation was performed at k, so \\n            // now check if the other half of s2\\n            // check for s1[start: k], s2[end - k : end] and s1[k+1 : end], s2[s : end - k - 1]\\n            if(isScrambled(s1_start, s1_start + k, s2_end - k, s2_end, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start, s2_end - k - 1, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n        }\\n        return dp[curr_cmb] = false;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        // DP cache: saves the result of (s1_start, s1_end, s2_start, s2_end) cmb\\n        unordered_map<string, bool> dp;\\n        return isScrambled(0, s1.size()-1, 0, s2.size()-1, s1, s2, dp);\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if s1 == s2:\\n            return True\\n        if len(s1) != len(s2):\\n            return False\\n            \\n        # Check both strings have same count of letters\\n        count1 = collections.defaultdict(int)\\n        count2 = collections.defaultdict(int)\\n        for c1, c2 in zip(s1, s2):\\n            count1[c1] += 1\\n            count2[c2] += 1\\n        if count1 != count2: return False\\n        \\n        # Iterate through letters and check if it results in a partition of \\n        # string 1 where the collection of letters are the same\\n        # on the left (non-swapped) or right (swapped) sides of string 2\\n        # Then we recursively check these partitioned strings to see if they are scrambled\\n        lcount1 = collections.defaultdict(int) # s1 count from left\\n        lcount2 = collections.defaultdict(int) # s2 count from left\\n        rcount2 = collections.defaultdict(int) # s2 count from right\\n        for i in xrange(len(s1) - 1):\\n            lcount1[s1[i]] += 1          \\n            lcount2[s2[i]] += 1\\n            rcount2[s2[len(s1) - 1 - i]] += 1\\n            if lcount1 == lcount2:  # Left sides of both strings have same letters\\n                if self.isScramble(s1[:i + 1], s2[:i + 1]) and \\\\\\n                   self.isScramble(s1[i + 1:], s2[i + 1:]):\\n                    return True\\n            elif lcount1 == rcount2: # Left side of s1 has same letters as right side of s2\\n                if self.isScramble(s1[:i + 1], s2[-(i + 1):]) and \\\\\\n                   self.isScramble(s1[i + 1:], s2[:-(i + 1)]):\\n                    return True\\n        return False\\n```\\n\\n***JavaScript***\\n```\\nconst _isScramble = function (s1, s2, trackMap) {    \\n    if (s1.length !== s2.length) return false;\\n    if (s1 === s2) return true;\\n    if (s1.length === 0 || s2.length === 0) return true;\\n    const trackKey = s1 + s2;\\n    if (trackKey in trackMap) return !!trackMap[trackKey];\\n\\n    let result = false;\\n    let xorFW = 0;\\n    let xorBW = 0;\\n\\n    for (var i = 0, j = s1.length - 1, iPlus = 1; i < s1.length - 1; i++, j--, iPlus++) {\\n        xorFW ^= s1.charCodeAt(i) ^ s2.charCodeAt(i);\\n        xorBW ^= s1.charCodeAt(i) ^ s2.charCodeAt(j);\\n\\n        if (xorFW === 0 &&\\n            _isScramble(s1.substring(0, iPlus), s2.substring(0, iPlus), trackMap) &&\\n            _isScramble(s1.substring(iPlus), s2.substring(iPlus), trackMap)) {\\n            result = true;\\n            break;\\n        }\\n\\n        if (xorBW === 0 &&\\n            _isScramble(s1.substring(0, iPlus), s2.substring(s1.length - iPlus), trackMap) &&\\n            _isScramble(s1.substring(iPlus), s2.substring(0, s1.length - iPlus), trackMap)) {\\n            result = true;\\n            break;\\n        }\\n    }\\n\\n    trackMap[trackKey] = result;\\n    trackMap[s2 + s1] = result;\\n    return result;\\n};\\n\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {boolean}\\n */\\nconst isScramble = function (s1, s2) {\\n    return _isScramble(s1, s2, {});\\n};\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n    val memo = mutableMapOf<String, Boolean>()\\n    \\n    fun isNotAnagram(s1: String, s2: String): Boolean {\\n        val f1 = MutableList(26) {0}\\n        val f2 = MutableList(26) {0}\\n        for (c in s1) {\\n            f1[(c-\\'a\\').toInt()]++\\n        }\\n        for (c in s2) {\\n            f2[(c-\\'a\\').toInt()]++\\n        }\\n        return f1.toString() != f2.toString()\\n    }\\n    \\n    fun isScramble(s1: String, s2: String): Boolean {\\n        if (s1 == s2) return true\\n        if (isNotAnagram(s1, s2)) return false\\n        memo[\"$s1*$s2\"]?.let {\\n            return it\\n        }\\n        val n = s1.length\\n        for (i in 1 .. n-1) {\\n            \\n            if ((isScramble(s1.substring(0,i), s2.substring(0,i)) && isScramble(s1.substring(i,n), s2.substring(i,n))) || (isScramble(s1.substring(0,i), s2.substring(n-i,n)) && isScramble(s1.substring(i,n), s2.substring(0,n-i)))) {\\n                memo[\"$s1*$s2\"] = true\\n                return true\\n            }\\n        }\\n        memo[\"$s1*$s2\"] = false\\n        return false\\n    }\\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func isScramble(_ s1: String, _ s2: String) -> Bool {\\n        var dp: [String: Bool] = [:]\\n        \\n\\n        func _isScramble(_ chs1: [Character], _ chs2: [Character]) -> Bool {\\n            let key = String(chs1) + \"-\" +  String(chs2)\\n            if let v = dp[key] { return v }            \\n            if chs1.count == 1 { return chs1[0] == chs2[0] }\\n            var val = false\\n\\n            for i in 1..<chs1.count {\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[0..<i])) \\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[i..<chs2.count])))\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[chs2.count - i..<chs2.count]))\\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[0..<chs2.count-i]))) \\n            }\\n            \\n            dp[key] = val\\n            return val\\n        }\\n        \\n        if s1.count != s2.count {\\n            return false\\n        } else {\\n            return _isScramble(Array(s1), Array(s2))\\n        }\\n    }\\n    \\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***\\n***\"Open your eyes.\"***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\npublic class Solution {\\n\\tpublic boolean isScramble(String s1, String s2) {\\n\\t\\tif (s1.length() != s2.length()) return false;\\n\\t\\tint len = s1.length();\\n\\t\\t/**\\n\\t\\t * Let F(i, j, k) = whether the substring S1[i..i + k - 1] is a scramble of S2[j..j + k - 1] or not\\n\\t\\t * Since each of these substrings is a potential node in the tree, we need to check for all possible cuts.\\n\\t\\t * Let q be the length of a cut (hence, q < k), then we are in the following situation:\\n\\t\\t * \\n\\t\\t * S1 [   x1    |         x2         ]\\n\\t\\t *    i         i + q                i + k - 1\\n\\t\\t * \\n\\t\\t * here we have two possibilities:\\n\\t\\t *      \\n\\t\\t * S2 [   y1    |         y2         ]\\n\\t\\t *    j         j + q                j + k - 1\\n\\t\\t *    \\n\\t\\t * or \\n\\t\\t * \\n\\t\\t * S2 [       y1        |     y2     ]\\n\\t\\t *    j                 j + k - q    j + k - 1\\n\\t\\t * \\n\\t\\t * which in terms of F means:\\n\\t\\t * \\n\\t\\t * F(i, j, k) = for some 1 <= q < k we have:\\n\\t\\t *  (F(i, j, q) AND F(i + q, j + q, k - q)) OR (F(i, j + k - q, q) AND F(i + q, j, k - q))\\n\\t\\t *  \\n\\t\\t * Base case is k = 1, where we simply need to check for S1[i] and S2[j] to be equal \\n\\t\\t * */\\n\\t\\tboolean [][][] F = new boolean[len][len][len + 1];\\n\\t\\tfor (int k = 1; k <= len; ++k)\\n\\t\\t\\tfor (int i = 0; i + k <= len; ++i)\\n\\t\\t\\t\\tfor (int j = 0; j + k <= len; ++j)\\n\\t\\t\\t\\t\\tif (k == 1)\\n\\t\\t\\t\\t\\t\\tF[i][j][k] = s1.charAt(i) == s2.charAt(j);\\n\\t\\t\\t\\t\\telse for (int q = 1; q < k && !F[i][j][k]; ++q) {\\n\\t\\t\\t\\t\\t\\tF[i][j][k] = (F[i][j][q] && F[i + q][j + q][k - q]) || (F[i][j + k - q][q] && F[i + q][j][k - q]);\\n\\t\\t\\t\\t\\t}\\n\\t\\treturn F[0][0][len];\\n\\t}\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    // checks if s2 is scrambled form of s1\\n    /*\\n        The idea is to find a position in string s1, from where scrambling must have\\n        started to create s2. So if k is the position, then s1[0-k] and s1[k+1, N-1]\\n        were the last scramble op. We do this recursively for the smaller substrings.\\n        \\n    */\\n    bool isScrambled(int s1_start, int s1_end, int s2_start, int s2_end,\\n                    string& s1, string& s2, unordered_map<string, bool>& dp) {\\n        // create the current position combination\\n        string curr_cmb = to_string(s1_start) + \\',\\' + to_string(s1_end) + \\n                            \\',\\' + to_string(s2_start) + \\',\\' + to_string(s2_end);\\n        // check if the values is in cache \\n        auto it = dp.find(curr_cmb);\\n        if(it != dp.end())\\n            return dp[curr_cmb];\\n        \\n        // base cases\\n        if(s1_end < s1_start || s2_end < s2_start)\\n            return false;\\n        // if the size of two strings is diff, then scrambling not poss\\n        if(s1_end - s1_start != s2_end - s2_start)\\n            return false;\\n        // if the two substrings match, then they are scrambled\\n        if(s1.substr(s1_start, s1_end - s1_start + 1) == s2.substr(s2_start, s2_end - s2_start + 1))\\n            return true;\\n        \\n        // check if the two substrings contains the same set of chars\\n        vector<int> char_freq(256, 0);\\n        for(int i = 0; i <= s1_end - s1_start; i++)\\n            char_freq[s1[s1_start + i]-\\'a\\']++, char_freq[s2[s2_start + i]-\\'a\\']--;\\n        for(int i = 0; i < 256; i++)\\n            if(char_freq[i]) \\n\\t\\t\\t\\treturn false;\\n        \\n        // find a position which is the potential scramble point\\n        for(int k = 0; k < (s1_end - s1_start); k++) {\\n            // check for s1[start: k], s2[start:k] and s1[k+1 : end], s2[k+1 : end]\\n            if(isScrambled(s1_start, s1_start + k, s2_start, s2_start + k, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start + k + 1, s2_end, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n            // Now incase of s2, maybe scramble opertation was performed at k, so \\n            // now check if the other half of s2\\n            // check for s1[start: k], s2[end - k : end] and s1[k+1 : end], s2[s : end - k - 1]\\n            if(isScrambled(s1_start, s1_start + k, s2_end - k, s2_end, s1, s2, dp)  &&\\n              isScrambled(s1_start + k + 1, s1_end, s2_start, s2_end - k - 1, s1, s2, dp))\\n                return dp[curr_cmb] = true;\\n        }\\n        return dp[curr_cmb] = false;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        // DP cache: saves the result of (s1_start, s1_end, s2_start, s2_end) cmb\\n        unordered_map<string, bool> dp;\\n        return isScrambled(0, s1.size()-1, 0, s2.size()-1, s1, s2, dp);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if s1 == s2:\\n            return True\\n        if len(s1) != len(s2):\\n            return False\\n            \\n        # Check both strings have same count of letters\\n        count1 = collections.defaultdict(int)\\n        count2 = collections.defaultdict(int)\\n        for c1, c2 in zip(s1, s2):\\n            count1[c1] += 1\\n            count2[c2] += 1\\n        if count1 != count2: return False\\n        \\n        # Iterate through letters and check if it results in a partition of \\n        # string 1 where the collection of letters are the same\\n        # on the left (non-swapped) or right (swapped) sides of string 2\\n        # Then we recursively check these partitioned strings to see if they are scrambled\\n        lcount1 = collections.defaultdict(int) # s1 count from left\\n        lcount2 = collections.defaultdict(int) # s2 count from left\\n        rcount2 = collections.defaultdict(int) # s2 count from right\\n        for i in xrange(len(s1) - 1):\\n            lcount1[s1[i]] += 1          \\n            lcount2[s2[i]] += 1\\n            rcount2[s2[len(s1) - 1 - i]] += 1\\n            if lcount1 == lcount2:  # Left sides of both strings have same letters\\n                if self.isScramble(s1[:i + 1], s2[:i + 1]) and \\\\\\n                   self.isScramble(s1[i + 1:], s2[i + 1:]):\\n                    return True\\n            elif lcount1 == rcount2: # Left side of s1 has same letters as right side of s2\\n                if self.isScramble(s1[:i + 1], s2[-(i + 1):]) and \\\\\\n                   self.isScramble(s1[i + 1:], s2[:-(i + 1)]):\\n                    return True\\n        return False\\n```\n```\\nconst _isScramble = function (s1, s2, trackMap) {    \\n    if (s1.length !== s2.length) return false;\\n    if (s1 === s2) return true;\\n    if (s1.length === 0 || s2.length === 0) return true;\\n    const trackKey = s1 + s2;\\n    if (trackKey in trackMap) return !!trackMap[trackKey];\\n\\n    let result = false;\\n    let xorFW = 0;\\n    let xorBW = 0;\\n\\n    for (var i = 0, j = s1.length - 1, iPlus = 1; i < s1.length - 1; i++, j--, iPlus++) {\\n        xorFW ^= s1.charCodeAt(i) ^ s2.charCodeAt(i);\\n        xorBW ^= s1.charCodeAt(i) ^ s2.charCodeAt(j);\\n\\n        if (xorFW === 0 &&\\n            _isScramble(s1.substring(0, iPlus), s2.substring(0, iPlus), trackMap) &&\\n            _isScramble(s1.substring(iPlus), s2.substring(iPlus), trackMap)) {\\n            result = true;\\n            break;\\n        }\\n\\n        if (xorBW === 0 &&\\n            _isScramble(s1.substring(0, iPlus), s2.substring(s1.length - iPlus), trackMap) &&\\n            _isScramble(s1.substring(iPlus), s2.substring(0, s1.length - iPlus), trackMap)) {\\n            result = true;\\n            break;\\n        }\\n    }\\n\\n    trackMap[trackKey] = result;\\n    trackMap[s2 + s1] = result;\\n    return result;\\n};\\n\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {boolean}\\n */\\nconst isScramble = function (s1, s2) {\\n    return _isScramble(s1, s2, {});\\n};\\n```\n```\\nclass Solution {\\n    val memo = mutableMapOf<String, Boolean>()\\n    \\n    fun isNotAnagram(s1: String, s2: String): Boolean {\\n        val f1 = MutableList(26) {0}\\n        val f2 = MutableList(26) {0}\\n        for (c in s1) {\\n            f1[(c-\\'a\\').toInt()]++\\n        }\\n        for (c in s2) {\\n            f2[(c-\\'a\\').toInt()]++\\n        }\\n        return f1.toString() != f2.toString()\\n    }\\n    \\n    fun isScramble(s1: String, s2: String): Boolean {\\n        if (s1 == s2) return true\\n        if (isNotAnagram(s1, s2)) return false\\n        memo[\"$s1*$s2\"]?.let {\\n            return it\\n        }\\n        val n = s1.length\\n        for (i in 1 .. n-1) {\\n            \\n            if ((isScramble(s1.substring(0,i), s2.substring(0,i)) && isScramble(s1.substring(i,n), s2.substring(i,n))) || (isScramble(s1.substring(0,i), s2.substring(n-i,n)) && isScramble(s1.substring(i,n), s2.substring(0,n-i)))) {\\n                memo[\"$s1*$s2\"] = true\\n                return true\\n            }\\n        }\\n        memo[\"$s1*$s2\"] = false\\n        return false\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func isScramble(_ s1: String, _ s2: String) -> Bool {\\n        var dp: [String: Bool] = [:]\\n        \\n\\n        func _isScramble(_ chs1: [Character], _ chs2: [Character]) -> Bool {\\n            let key = String(chs1) + \"-\" +  String(chs2)\\n            if let v = dp[key] { return v }            \\n            if chs1.count == 1 { return chs1[0] == chs2[0] }\\n            var val = false\\n\\n            for i in 1..<chs1.count {\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[0..<i])) \\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[i..<chs2.count])))\\n                val = val || (_isScramble(Array(chs1[0..<i]), Array(chs2[chs2.count - i..<chs2.count]))\\n                                && _isScramble(Array(chs1[i..<chs1.count]), Array(chs2[0..<chs2.count-i]))) \\n            }\\n            \\n            dp[key] = val\\n            return val\\n        }\\n        \\n        if s1.count != s2.count {\\n            return false\\n        } else {\\n            return _isScramble(Array(s1), Array(s2))\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137834,
                "title": "mcm-aditya-verma-matrix-chain-multiplication-memoized-dp-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    bool solve(string s1,string s2)\\n    {\\n        int n=s1.length();\\n        if(s1.compare(s2)==0)\\n            return true;\\n        string key=s1+\" \"+s2;\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        bool flag=false;\\n        for(int i=1;i<n;i++)\\n        {\\n        bool unswap=solve(s1.substr(0,i),s2.substr(0,i)) && solve(s1.substr(i,n-i),s2.substr(i,n-i));\\n    bool swapped=solve(s1.substr(0,i),s2.substr(n-i,i)) && solve(s1.substr(i),s2.substr(0,n-i));\\n            if(unswap || swapped)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        mp[key]=flag;\\n        return flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        if(s1.length()>s2.length())\\n            return false;\\n        return solve(s1,s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    bool solve(string s1,string s2)\\n    {\\n        int n=s1.length();\\n        if(s1.compare(s2)==0)\\n            return true;\\n        string key=s1+\" \"+s2;\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        bool flag=false;\\n        for(int i=1;i<n;i++)\\n        {\\n        bool unswap=solve(s1.substr(0,i),s2.substr(0,i)) && solve(s1.substr(i,n-i),s2.substr(i,n-i));\\n    bool swapped=solve(s1.substr(0,i),s2.substr(n-i,i)) && solve(s1.substr(i),s2.substr(0,n-i));\\n            if(unswap || swapped)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        mp[key]=flag;\\n        return flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        if(s1.length()>s2.length())\\n            return false;\\n        return solve(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342546,
                "title": "my-4ms-concise-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2)\\n    {\\n        if (s1.size()!=s2.size()) return false;\\n        if (s1==s2) return true;\\n        string tmp1=s1, tmp2=s2;\\n        sort(tmp1.begin(), tmp1.end());\\n        sort(tmp2.begin(), tmp2.end());\\n        if (tmp1!=tmp2) return false;\\n\\n        for (int i=1; i<s1.size(); i++)\\n        {\\n            // left<->left, right<->right\\n            // or left<->right, right<->left\\n            if ( (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i),s2.substr(i))) \\\\\\n            || (isScramble(s1.substr(0, i), s2.substr(s2.size()-i)) && isScramble(s1.substr(i),s2.substr(0, s2.size()-i))) )\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2)\\n    {\\n        if (s1.size()!=s2.size()) return false;\\n        if (s1==s2) return true;\\n        string tmp1=s1, tmp2=s2;\\n        sort(tmp1.begin(), tmp1.end());\\n        sort(tmp2.begin(), tmp2.end());\\n        if (tmp1!=tmp2) return false;\\n\\n        for (int i=1; i<s1.size(); i++)\\n        {\\n            // left<->left, right<->right\\n            // or left<->right, right<->left\\n            if ( (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i),s2.substr(i))) \\\\\\n            || (isScramble(s1.substr(0, i), s2.substr(s2.size()-i)) && isScramble(s1.substr(i),s2.substr(0, s2.size()-i))) )\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29447,
                "title": "60-ms-recursive-python-solution-faster-than-100-of-python-solutions-with-comments",
                "content": "    class Solution(object):\\n        def isScramble(self, s1, s2):\\n            \"\"\"\\n            :type s1: str\\n            :type s2: str\\n            :rtype: bool\\n            \"\"\"\\n            if s1 == s2:\\n                return True\\n            if len(s1) != len(s2):\\n                return False\\n                \\n            # Check both strings have same count of letters\\n            count1 = collections.defaultdict(int)\\n            count2 = collections.defaultdict(int)\\n            for c1, c2 in zip(s1, s2):\\n                count1[c1] += 1\\n                count2[c2] += 1\\n            if count1 != count2: return False\\n            \\n            # Iterate through letters and check if it results in a partition of \\n            # string 1 where the collection of letters are the same\\n            # on the left (non-swapped) or right (swapped) sides of string 2\\n            # Then we recursively check these partitioned strings to see if they are scrambled\\n            lcount1 = collections.defaultdict(int) # s1 count from left\\n            lcount2 = collections.defaultdict(int) # s2 count from left\\n            rcount2 = collections.defaultdict(int) # s2 count from right\\n            for i in xrange(len(s1) - 1):\\n                lcount1[s1[i]] += 1          \\n                lcount2[s2[i]] += 1\\n                rcount2[s2[len(s1) - 1 - i]] += 1\\n                if lcount1 == lcount2:  # Left sides of both strings have same letters\\n                    if self.isScramble(s1[:i + 1], s2[:i + 1]) and \\\\\\n                       self.isScramble(s1[i + 1:], s2[i + 1:]):\\n                        return True\\n                elif lcount1 == rcount2: # Left side of s1 has same letters as right side of s2\\n                    if self.isScramble(s1[:i + 1], s2[-(i + 1):]) and \\\\\\n                       self.isScramble(s1[i + 1:], s2[:-(i + 1)]):\\n                        return True\\n            return False",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "    class Solution(object):\\n        def isScramble(self, s1, s2):\\n            \"\"\"\\n            :type s1: str\\n            :type s2: str\\n            :rtype: bool\\n            \"\"\"\\n            if s1 == s2:\\n                return True\\n            if len(s1) != len(s2):\\n                return False\\n                \\n            # Check both strings have same count of letters\\n            count1 = collections.defaultdict(int)\\n            count2 = collections.defaultdict(int)\\n            for c1, c2 in zip(s1, s2):\\n                count1[c1] += 1\\n                count2[c2] += 1\\n            if count1 != count2: return False\\n            \\n            # Iterate through letters and check if it results in a partition of \\n            # string 1 where the collection of letters are the same\\n            # on the left (non-swapped) or right (swapped) sides of string 2\\n            # Then we recursively check these partitioned strings to see if they are scrambled\\n            lcount1 = collections.defaultdict(int) # s1 count from left\\n            lcount2 = collections.defaultdict(int) # s2 count from left\\n            rcount2 = collections.defaultdict(int) # s2 count from right\\n            for i in xrange(len(s1) - 1):\\n                lcount1[s1[i]] += 1          \\n                lcount2[s2[i]] += 1\\n                rcount2[s2[len(s1) - 1 - i]] += 1\\n                if lcount1 == lcount2:  # Left sides of both strings have same letters\\n                    if self.isScramble(s1[:i + 1], s2[:i + 1]) and \\\\\\n                       self.isScramble(s1[i + 1:], s2[i + 1:]):\\n                        return True\\n                elif lcount1 == rcount2: # Left side of s1 has same letters as right side of s2\\n                    if self.isScramble(s1[:i + 1], s2[-(i + 1):]) and \\\\\\n                       self.isScramble(s1[i + 1:], s2[:-(i + 1)]):\\n                        return True\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 3826197,
                "title": "c-top-down-solution-with-memoization-3ms-beats-99",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince there is no official Top-down solution, this is meant to serve as a simple approach with recursion. \\n\\nThe dfs function come with three parameters. Idx1 and Idx2 represent the indices that the substring is starting from string s1 and s2 with len. If length is 1, we check if the characters match.\\n\\nWe do a simple trim before the search to check if the two substring has the same freqency of unique characters. Then we split the string into substrings with length 1 to len-1, s1 = x1 + y1, s2 = x2 + y2 for each state, we consider two cases:\\n\\n1. (x1,x2) and (y1, y2)\\n2. (x1, y2) and (x2, y1)\\n\\nIf either of them is scramble, we return true.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^4)\\n\\n- Space complexity:\\nO(n^3)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        const int sz = s1.size();\\n        int8_t memo[sz][sz][sz+1];\\n        memset(memo,-1,sizeof(memo));\\n\\n        function<bool(int,int,int)>dfs= [&](int idx1, int idx2, int len)->bool{\\n            if(memo[idx1][idx2][len]!=-1)return (memo[idx1][idx2][len]==1);\\n            \\n            if(len==1&&s1[idx1]==s2[idx2])return true;\\n            \\n            int count[26];\\n            memset(count,0,sizeof(count));\\n\\n            for(int i = 0;i<len;i++){\\n                count[s1[idx1+i]-\\'a\\']++;\\n                count[s2[idx2+i]-\\'a\\']--;\\n            }\\n            for(int i = 0;i<26;i++){\\n                if(count[i]!=0){\\n                    memo[idx1][idx2][len] = 0;\\n                    return false;\\n                }\\n            }\\n\\n            for(int i = 1;i<len;i++){\\n                if ((dfs(idx1, idx2, i) && dfs(idx1 + i, idx2 + i, len - i)) ||\\n                    (dfs(idx1, idx2 + len - i, i) && dfs(idx1 + i, idx2, len - i))) {\\n                    \\n                    memo[idx1][idx2][len] = 1;\\n                    return true;\\n                }\\n            }\\n\\n            memo[idx1][idx2][len] = 0;\\n            return false;\\n        };\\n\\n        return dfs(0,0,sz);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        const int sz = s1.size();\\n        int8_t memo[sz][sz][sz+1];\\n        memset(memo,-1,sizeof(memo));\\n\\n        function<bool(int,int,int)>dfs= [&](int idx1, int idx2, int len)->bool{\\n            if(memo[idx1][idx2][len]!=-1)return (memo[idx1][idx2][len]==1);\\n            \\n            if(len==1&&s1[idx1]==s2[idx2])return true;\\n            \\n            int count[26];\\n            memset(count,0,sizeof(count));\\n\\n            for(int i = 0;i<len;i++){\\n                count[s1[idx1+i]-\\'a\\']++;\\n                count[s2[idx2+i]-\\'a\\']--;\\n            }\\n            for(int i = 0;i<26;i++){\\n                if(count[i]!=0){\\n                    memo[idx1][idx2][len] = 0;\\n                    return false;\\n                }\\n            }\\n\\n            for(int i = 1;i<len;i++){\\n                if ((dfs(idx1, idx2, i) && dfs(idx1 + i, idx2 + i, len - i)) ||\\n                    (dfs(idx1, idx2 + len - i, i) && dfs(idx1 + i, idx2, len - i))) {\\n                    \\n                    memo[idx1][idx2][len] = 1;\\n                    return true;\\n                }\\n            }\\n\\n            memo[idx1][idx2][len] = 0;\\n            return false;\\n        };\\n\\n        return dfs(0,0,sz);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358755,
                "title": "brute-force-optimsed-both-explained-well",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbrute force\\nin this brute force i am trying to generate all possible scramble string of s1 and checking whether s2 is a part of it\\nthis will give tle\\n\\nin the second solution first we will recursively finding whether \\ns1 and s2 are sramble strings of each other\\nthe base given in the question is that 2 equal characters are scramble strings of each other\\nwe can extend this logic to that 2 equal strings are scramble strings of each \\nnow understand each state of the recursive function that i am using\\ndp[i][j][k] or say rec(s1,s2,k,i,j)\\nit means whether s1[i..k] and s2[j..k] are scramble strings of each other\\n\\nnow comes the recurrence part \\nlet us partition 2 string after kth character whre k range[1,len)\\n\\nfor the current 2 strings to be scramble strings of each other \\ns1[i..k] and s2[j..k] should be scramble string of each other and\\ns1[i+k..len] and s2[j+k.len] should be scramble string ofg each other \\nthis is case one in which after partition we are not swapping to check for scramble string\\n\\n\\n\\ncase2 is that when we swap for after partition  to check for scramble string\\nin that case the first part of s1 wil be scramble string wth lastpart of s2\\nand vice versa\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nint brute force \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n1.\\n```\\n\\nclass Solution {\\npublic:\\n\\n\\n\\n\\n\\n\\n    vector<string> help(string& s1,int i,int j,    map<string,vector<string>>&dp){\\n\\n        //understand each state of  this recursive function\\n        vector<string>th;\\n\\n        string curr=to_string(i)+\"#\"+to_string(j);\\n        if(i>j){\\n            return th;\\n            \\n        }\\n        if(i==j){\\n            th.push_back(s1.substr(i,1));\\n            return dp[curr]=th;\\n        }\\n        if(dp.find(curr)!=dp.end()){\\n            return dp[curr];\\n        }\\n\\n        //now recurrence in the current recursive call\\n\\n        for(int a=i;a<j;a++){\\n            //we are trying to partition after a-1th character in the current recursive call\\n            auto t1=help(s1,i,a,dp);\\n            auto t2=help(s1,a+1,j,dp);\\n            //include that cases in which t1 and t2 are swapped \\n            for(auto e:t1){\\n                for(auto f:t2){\\n                    th.push_back(e+f);\\n                    th.push_back(f+e);\\n                }\\n            }\\n            \\n        }\\n        return dp[curr]=th;\\n        //returning the answer for the use to the upper recursive call\\n    }\\n    bool isScramble(string s1, string s2) {\\n        //first we will be starting with a brute force approach\\n\\n\\n        map<string,int>mp;\\n        //this map will contain all possible scramble strings that we can generate from s1\\n        //finaally wed will search s2 is a part of it or not\\n        map<string,vector<string>>dp;\\n        auto t=help(s1,0 ,s1.size()-1,dp);\\n        for(auto e:t){\\n            mp[e]++;\\n\\n        }\\n        return mp.find(s2)!=mp.end();\\n        \\n \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int dp[32][32][32];\\n    int  help(string& s1,string&s2,int len,int s1s,int s2s){\\n\\n        //understand each of the recursive state of this function\\n        //what is the base case \\n        //we just need to check \\n        if(s1.substr(s1s,len)==s2.substr(s2s,len)){\\n            return 1;\\n        }\\n\\n        if(dp[s1s][s2s][len]!=-1){\\n            return dp[s1s][s2s][len];\\n\\n        }\\n\\n\\n\\n        //trying all partitions in the current recursive call\\n        int curr=0;\\n\\n        for(int k=1;k<len;k++){\\n            //in each iteration we will breaking after the kth char \\n            int c1=help(s1,s2,k,s1s,s2s);\\n            int c2=help(s1,s2,len-k,s1s+k,s2s+k);\\n            int c3=help(s1,s2,k,s1s,s2s+len-k);\\n            int c4=help(s1,s2,len-k,s1s+k,s2s);\\n\\n            if((c1 && c2)||(c3 && c4)){\\n                curr=1;\\n                break;\\n            }\\n        }\\n        return dp[s1s][s2s][len]=curr;\\n\\n    }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp,-1,sizeof(dp));\\n\\n\\n        //here we need to follow dynamic programming instead of generating all possible scramble strings of s1\\n        //we just need to check not generate\\n\\n        int t=help(s1,s2,s1.size(),0,0);\\n        return t==1?true:false;\\n\\n\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n\\n\\n\\n\\n\\n    vector<string> help(string& s1,int i,int j,    map<string,vector<string>>&dp){\\n\\n        //understand each state of  this recursive function\\n        vector<string>th;\\n\\n        string curr=to_string(i)+\"#\"+to_string(j);\\n        if(i>j){\\n            return th;\\n            \\n        }\\n        if(i==j){\\n            th.push_back(s1.substr(i,1));\\n            return dp[curr]=th;\\n        }\\n        if(dp.find(curr)!=dp.end()){\\n            return dp[curr];\\n        }\\n\\n        //now recurrence in the current recursive call\\n\\n        for(int a=i;a<j;a++){\\n            //we are trying to partition after a-1th character in the current recursive call\\n            auto t1=help(s1,i,a,dp);\\n            auto t2=help(s1,a+1,j,dp);\\n            //include that cases in which t1 and t2 are swapped \\n            for(auto e:t1){\\n                for(auto f:t2){\\n                    th.push_back(e+f);\\n                    th.push_back(f+e);\\n                }\\n            }\\n            \\n        }\\n        return dp[curr]=th;\\n        //returning the answer for the use to the upper recursive call\\n    }\\n    bool isScramble(string s1, string s2) {\\n        //first we will be starting with a brute force approach\\n\\n\\n        map<string,int>mp;\\n        //this map will contain all possible scramble strings that we can generate from s1\\n        //finaally wed will search s2 is a part of it or not\\n        map<string,vector<string>>dp;\\n        auto t=help(s1,0 ,s1.size()-1,dp);\\n        for(auto e:t){\\n            mp[e]++;\\n\\n        }\\n        return mp.find(s2)!=mp.end();\\n        \\n \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int dp[32][32][32];\\n    int  help(string& s1,string&s2,int len,int s1s,int s2s){\\n\\n        //understand each of the recursive state of this function\\n        //what is the base case \\n        //we just need to check \\n        if(s1.substr(s1s,len)==s2.substr(s2s,len)){\\n            return 1;\\n        }\\n\\n        if(dp[s1s][s2s][len]!=-1){\\n            return dp[s1s][s2s][len];\\n\\n        }\\n\\n\\n\\n        //trying all partitions in the current recursive call\\n        int curr=0;\\n\\n        for(int k=1;k<len;k++){\\n            //in each iteration we will breaking after the kth char \\n            int c1=help(s1,s2,k,s1s,s2s);\\n            int c2=help(s1,s2,len-k,s1s+k,s2s+k);\\n            int c3=help(s1,s2,k,s1s,s2s+len-k);\\n            int c4=help(s1,s2,len-k,s1s+k,s2s);\\n\\n            if((c1 && c2)||(c3 && c4)){\\n                curr=1;\\n                break;\\n            }\\n        }\\n        return dp[s1s][s2s][len]=curr;\\n\\n    }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp,-1,sizeof(dp));\\n\\n\\n        //here we need to follow dynamic programming instead of generating all possible scramble strings of s1\\n        //we just need to check not generate\\n\\n        int t=help(s1,s2,s1.size(),0,0);\\n        return t==1?true:false;\\n\\n\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358626,
                "title": "simple-recursive-solution-3d-array-solution-with-detailed-comments",
                "content": "## Simpler, recursive solution (cache + pruning)\\n```\\n// helper function that checks if the two strings have the same characters\\nconst hasSameChars = (word1, word2) => {\\n  // If the two words have different lengths, they can\\'t have the same characters\\n  if (word1.length !== word2.length) return false;\\n\\n  // Create an object to keep track of the count of each character in the two words\\n  const charCount = {};\\n\\n  // Loop through each character in the two words and update the character count\\n  for (let i = 0; i < word1.length; i++) {\\n    const char1 = word1[i];\\n    const char2 = word2[i];\\n    charCount[char1] = char1 in charCount ? charCount[char1] + 1 : 1;\\n    charCount[char2] = char2 in charCount ? charCount[char2] - 1 : -1;\\n  }\\n\\n  // If any character count is not zero, the two words don\\'t have the same characters\\n  for (const char in charCount) {\\n    if (charCount[char] !== 0) return false;\\n  }\\n\\n  return true;\\n};\\n\\nvar isScramble = function (s1, s2, memo = {}) {\\n  // Create a key for the memoization object\\n  const key = `${s1}-${s2}`;\\n\\n  // If the result for this key has already been calculated, return it\\n  if (key in memo) return memo[key];\\n\\n  // If the two strings are equal, s1 can be scrambled to get s2\\n  if (s1 === s2) return true;\\n\\n  // If the two strings don\\'t have the same characters, s1 can\\'t be scrambled to get s2\\n  if (!hasSameChars(s1, s2)) {\\n    memo[key] = false;\\n    return false;\\n  }\\n\\n  // Try all possible splits of s1 and s2 and recursively check if the resulting substrings can be scrambled\\n  const length = s1.length;\\n\\n  for (let i = 1; i < length; i++) {\\n    if (\\n      (isScramble(s1.slice(0, i), s2.slice(0, i), memo) &&\\n        isScramble(s1.slice(i), s2.slice(i), memo)) ||\\n      (isScramble(s1.slice(0, i), s2.slice(length - i), memo) &&\\n        isScramble(s1.slice(i), s2.slice(0, length - i), memo))\\n    ) {\\n      memo[key] = true;\\n      return true;\\n    }\\n  }\\n\\n  // If none of the splits worked, s1 can\\'t be scrambled to get s2\\n  memo[key] = false;\\n  return false;\\n};\\n```\\nThe time complexity of this solution is not optimal, and it\\'s possible to solve this problem more efficiently using dynamic programming. The basic idea is to use a 3D array to store the intermediate results of the recursive calls, so that we can avoid repeating the same computation multiple times.\\n\\n## Dynamic Programming Solution\\n```\\nvar isScramble = function (s1, s2) {\\n  const totalLength = s1.length;\\n\\n  // Initialize a 3D array to store the intermediate results\\n  const canScramble = new Array(totalLength + 1)\\n    .fill(null)\\n    .map(() =>\\n      new Array(totalLength)\\n        .fill(null)\\n        .map(() => new Array(totalLength).fill(false))\\n    );\\n\\n  // Initialize the base case where the two strings have length 1\\n  for (let i = 0; i < totalLength; i++) {\\n    for (let j = 0; j < totalLength; j++) {\\n      canScramble[1][i][j] = s1[i] === s2[j];\\n    }\\n  }\\n\\n  // Solve the subproblems in a bottom-up manner\\n  for (let len = 2; len <= totalLength; len++) {\\n    for (let i = 0; i <= totalLength - len; i++) {\\n      for (let j = 0; j <= totalLength - len; j++) {\\n        for (let k = 1; k < len; k++) {\\n          // Partition s1[0,len] into two parts: s1[0,k] and s1[k,len]\\n          // Check if s1[0,k] can be scrambled to get s2[0,k]\\n          const canScrambleLeft = canScramble[k][i][j];\\n          // Check if s1[k,n] can be scrambled to get s2[k,n]\\n          const canScrambleRight = canScramble[len - k][i + k][j + k];\\n          // Check if s1[0,k] can be scrambled to get s2[len-k,n]\\n          const canScrambleLeftReverse = canScramble[k][i][j + len - k];\\n          // Check if s1[k,n] can be scrambled to get s2[0,len-k]\\n          const canScrambleRightReverse = canScramble[len - k][i + k][j];\\n\\n          // Check if s1[0,k] can be scrambled to get s2[0,k] and s1[k,n] can be scrambled to get s2[k,n]\\n          // OR if s1[0,k] can be scrambled to get s2[len-k,n] and s1[k,n] can be scrambled to get s2[0,len-k]\\n          if (\\n            (canScrambleLeft && canScrambleRight) ||\\n            (canScrambleLeftReverse && canScrambleRightReverse)\\n          ) {\\n            // If either case is true, s1[0,len] can be scrambled to get s2[0,len]\\n            canScramble[len][i][j] = true;\\n            break;\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  // The answer is stored in canScramble[n][0][0]\\n  return canScramble[totalLength][0][0];\\n};\\n```\\nThis solution uses a dynamic programming approach to solve the problem of determining whether one string can be scrambled into another. The idea behind dynamic programming is to solve a problem by breaking it down into smaller subproblems and storing the results of these subproblems in memory so that we can avoid recalculating them.\\n\\nTo solve this problem, we create a 3D boolean array called canScramble to store intermediate results. canScramble[k][i][j] represents whether the substring of s1 starting at index i and of length k can be scrambled into the substring of s2 starting at index j and of length k.\\n\\nThe base case for our dynamic programming approach is when both strings have length 1. In this case, we simply compare the two characters at the same index in both strings and store the result.\\n\\nNext, we solve the subproblems in a bottom-up manner. We start by looking at substrings of length 2, then length 3, and so on, until we reach the length of the entire string. For each substring of length len, we consider all possible ways to split the substring into two parts, with lengths k and len - k. We then check if the two parts of s1 can be scrambled into the corresponding parts of s2. We do this by checking the following conditions:\\n\\n1) The first part of s1 can be scrambled into the first part of s2 and the second part of s1 can be scrambled into the second part of s2.\\n2) The first part of s1 can be scrambled into the second part of s2 and the second part of s1 can be scrambled into the first part of s2.\\n\\nIf any of these conditions is true, then we can scramble the substring of s1 into the substring of s2. We store the result in canScramble[len][i][j].\\n\\nFinally, we return the value of canScramble[n][0][0], which represents whether the entire s1 can be scrambled into s2.\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n// helper function that checks if the two strings have the same characters\\nconst hasSameChars = (word1, word2) => {\\n  // If the two words have different lengths, they can\\'t have the same characters\\n  if (word1.length !== word2.length) return false;\\n\\n  // Create an object to keep track of the count of each character in the two words\\n  const charCount = {};\\n\\n  // Loop through each character in the two words and update the character count\\n  for (let i = 0; i < word1.length; i++) {\\n    const char1 = word1[i];\\n    const char2 = word2[i];\\n    charCount[char1] = char1 in charCount ? charCount[char1] + 1 : 1;\\n    charCount[char2] = char2 in charCount ? charCount[char2] - 1 : -1;\\n  }\\n\\n  // If any character count is not zero, the two words don\\'t have the same characters\\n  for (const char in charCount) {\\n    if (charCount[char] !== 0) return false;\\n  }\\n\\n  return true;\\n};\\n\\nvar isScramble = function (s1, s2, memo = {}) {\\n  // Create a key for the memoization object\\n  const key = `${s1}-${s2}`;\\n\\n  // If the result for this key has already been calculated, return it\\n  if (key in memo) return memo[key];\\n\\n  // If the two strings are equal, s1 can be scrambled to get s2\\n  if (s1 === s2) return true;\\n\\n  // If the two strings don\\'t have the same characters, s1 can\\'t be scrambled to get s2\\n  if (!hasSameChars(s1, s2)) {\\n    memo[key] = false;\\n    return false;\\n  }\\n\\n  // Try all possible splits of s1 and s2 and recursively check if the resulting substrings can be scrambled\\n  const length = s1.length;\\n\\n  for (let i = 1; i < length; i++) {\\n    if (\\n      (isScramble(s1.slice(0, i), s2.slice(0, i), memo) &&\\n        isScramble(s1.slice(i), s2.slice(i), memo)) ||\\n      (isScramble(s1.slice(0, i), s2.slice(length - i), memo) &&\\n        isScramble(s1.slice(i), s2.slice(0, length - i), memo))\\n    ) {\\n      memo[key] = true;\\n      return true;\\n    }\\n  }\\n\\n  // If none of the splits worked, s1 can\\'t be scrambled to get s2\\n  memo[key] = false;\\n  return false;\\n};\\n```\n```\\nvar isScramble = function (s1, s2) {\\n  const totalLength = s1.length;\\n\\n  // Initialize a 3D array to store the intermediate results\\n  const canScramble = new Array(totalLength + 1)\\n    .fill(null)\\n    .map(() =>\\n      new Array(totalLength)\\n        .fill(null)\\n        .map(() => new Array(totalLength).fill(false))\\n    );\\n\\n  // Initialize the base case where the two strings have length 1\\n  for (let i = 0; i < totalLength; i++) {\\n    for (let j = 0; j < totalLength; j++) {\\n      canScramble[1][i][j] = s1[i] === s2[j];\\n    }\\n  }\\n\\n  // Solve the subproblems in a bottom-up manner\\n  for (let len = 2; len <= totalLength; len++) {\\n    for (let i = 0; i <= totalLength - len; i++) {\\n      for (let j = 0; j <= totalLength - len; j++) {\\n        for (let k = 1; k < len; k++) {\\n          // Partition s1[0,len] into two parts: s1[0,k] and s1[k,len]\\n          // Check if s1[0,k] can be scrambled to get s2[0,k]\\n          const canScrambleLeft = canScramble[k][i][j];\\n          // Check if s1[k,n] can be scrambled to get s2[k,n]\\n          const canScrambleRight = canScramble[len - k][i + k][j + k];\\n          // Check if s1[0,k] can be scrambled to get s2[len-k,n]\\n          const canScrambleLeftReverse = canScramble[k][i][j + len - k];\\n          // Check if s1[k,n] can be scrambled to get s2[0,len-k]\\n          const canScrambleRightReverse = canScramble[len - k][i + k][j];\\n\\n          // Check if s1[0,k] can be scrambled to get s2[0,k] and s1[k,n] can be scrambled to get s2[k,n]\\n          // OR if s1[0,k] can be scrambled to get s2[len-k,n] and s1[k,n] can be scrambled to get s2[0,len-k]\\n          if (\\n            (canScrambleLeft && canScrambleRight) ||\\n            (canScrambleLeftReverse && canScrambleRightReverse)\\n          ) {\\n            // If either case is true, s1[0,len] can be scrambled to get s2[0,len]\\n            canScramble[len][i][j] = true;\\n            break;\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  // The answer is stored in canScramble[n][0][0]\\n  return canScramble[totalLength][0][0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3107720,
                "title": "c-easy-solution-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool f(string s1,string s2){\\n        int n=s1.length();\\n        if(s1.size()==1) return s1==s2;\\n        if(s1==s2) return true;\\n        string k=s1+s2;\\n        if(mp.find(k)!=mp.end()) return mp[k];\\n        for(int i=1;i<n;i++){\\n            if((f(s1.substr(0,i),s2.substr(0,i)) && f(s1.substr(i),s2.substr(i))) or (f(s1.substr(0,i),s2.substr(n-i)) && f(s1.substr(i),s2.substr(0,n-i))))\\n            return mp[k]=true;\\n        }\\n        return mp[k]=false;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        return f(s1,s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool f(string s1,string s2){\\n        int n=s1.length();\\n        if(s1.size()==1) return s1==s2;\\n        if(s1==s2) return true;\\n        string k=s1+s2;\\n        if(mp.find(k)!=mp.end()) return mp[k];\\n        for(int i=1;i<n;i++){\\n            if((f(s1.substr(0,i),s2.substr(0,i)) && f(s1.substr(i),s2.substr(i))) or (f(s1.substr(0,i),s2.substr(n-i)) && f(s1.substr(i),s2.substr(0,n-i))))\\n            return mp[k]=true;\\n        }\\n        return mp[k]=false;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        return f(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325841,
                "title": "java-mcm-aditya-verma-recursion-memoization",
                "content": "```\\n\\nclass Solution {\\n    Map<String, Boolean> map = new HashMap<>();\\n\\t\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length() != s2.length()) return false;\\n        return solve(s1, s2);   \\n    }\\n    \\n    private boolean solve(String a, String b) {\\n        if(a.equals(b)) return true;\\n        if(a.length() <= 1) return false;\\n        \\n        String key = a + \"_\" + b;\\n        if(map.containsKey(key)) return map.get(key);\\n\\n        int n = a.length();\\n        \\n        boolean flag = false;\\n        for(int i=1; i<n; i++) {\\n            boolean noswap = solve(a.substring(0,i), b.substring(0,i)) &&\\n                             solve(a.substring(i), b.substring(i));\\n            \\n            boolean swap = solve(a.substring(0,i), b.substring(n-i)) &&\\n                           solve(a.substring(i), b.substring(0,n-i));\\n            if(swap || noswap){\\n                flag = true;\\n                break;\\n            }\\n        }\\n        map.put(key, flag);\\n        return flag;    \\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    Map<String, Boolean> map = new HashMap<>();\\n\\t\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length() != s2.length()) return false;\\n        return solve(s1, s2);   \\n    }\\n    \\n    private boolean solve(String a, String b) {\\n        if(a.equals(b)) return true;\\n        if(a.length() <= 1) return false;\\n        \\n        String key = a + \"_\" + b;\\n        if(map.containsKey(key)) return map.get(key);\\n\\n        int n = a.length();\\n        \\n        boolean flag = false;\\n        for(int i=1; i<n; i++) {\\n            boolean noswap = solve(a.substring(0,i), b.substring(0,i)) &&\\n                             solve(a.substring(i), b.substring(i));\\n            \\n            boolean swap = solve(a.substring(0,i), b.substring(n-i)) &&\\n                           solve(a.substring(i), b.substring(0,n-i));\\n            if(swap || noswap){\\n                flag = true;\\n                break;\\n            }\\n        }\\n        map.put(key, flag);\\n        return flag;    \\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670707,
                "title": "12-ms-c-faster-solution",
                "content": "* **Idea?**\\n1.  For current string s1 and s2,**we can divide the string at any position**.\\n2.  Traverse each position and find the left and right substrings.\\n3.  Check out all combinations we can have accroding to the problem statement.\\n4.  Also, to speed up the runtime, we can use **dynamic programming** since we are visiting same states again and again.\\n5.  Also, we would be checking the** condition to anagram to pair up any two substrings**.\\n6.  Check code for better understanding.\\n\\n```\\nclass Solution {\\npublic:\\n    map<pair<string,string>,bool> dp;\\n    bool ok(string s1,string s2){ //  to check anagram\\n        vector<int> dp(26);\\n        for(auto& c:s1)\\n            dp[c-\\'a\\']++;\\n        for(auto& c:s2)\\n            dp[c-\\'a\\']--;\\n        for(auto& c:dp){\\n            if(c!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // dynamic programming with memoization\\n    bool solve(string s1,string s2){\\n        int n = s1.length();\\n        if(n==1)\\n            return dp[{s1,s2}] = s1==s2;\\n        if(dp.count({s1,s2}))\\n            return dp[{s1,s2}];\\n        for(int i=0;i<n-1;i++){\\n            string f1 = s1.substr(0,i+1);\\n            string f2 = s1.substr(i+1);\\n            string f3 = s2.substr(0,i+1);\\n            string f4 = s2.substr(i+1);\\n            string f5 = s2.substr(n-i-1);\\n            string f6 = s2.substr(0,n-i-1);\\n            if(ok(f1,f3) and ok(f2,f4) and solve(f1,f3) and solve(f2,f4))\\n                return true;\\n            if(ok(f1,f5) and ok(f2,f6) and solve(f1,f5) and solve(f2,f6))\\n                return true;\\n        }\\n        return dp[{s1,s2}] = false;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        return solve(s1,s2);\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<string,string>,bool> dp;\\n    bool ok(string s1,string s2){ //  to check anagram\\n        vector<int> dp(26);\\n        for(auto& c:s1)\\n            dp[c-\\'a\\']++;\\n        for(auto& c:s2)\\n            dp[c-\\'a\\']--;\\n        for(auto& c:dp){\\n            if(c!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    // dynamic programming with memoization\\n    bool solve(string s1,string s2){\\n        int n = s1.length();\\n        if(n==1)\\n            return dp[{s1,s2}] = s1==s2;\\n        if(dp.count({s1,s2}))\\n            return dp[{s1,s2}];\\n        for(int i=0;i<n-1;i++){\\n            string f1 = s1.substr(0,i+1);\\n            string f2 = s1.substr(i+1);\\n            string f3 = s2.substr(0,i+1);\\n            string f4 = s2.substr(i+1);\\n            string f5 = s2.substr(n-i-1);\\n            string f6 = s2.substr(0,n-i-1);\\n            if(ok(f1,f3) and ok(f2,f4) and solve(f1,f3) and solve(f2,f4))\\n                return true;\\n            if(ok(f1,f5) and ok(f2,f6) and solve(f1,f5) and solve(f2,f6))\\n                return true;\\n        }\\n        return dp[{s1,s2}] = false;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        return solve(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359204,
                "title": "dp-solution-aditya-verma",
                "content": "```\\nclass Solution {\\n     static HashMap<String,Boolean> map=new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        \\n        return solve(s1,s2);\\n    }\\n    public static boolean solve(String a,String b)\\n    {\\n        if(a.equals(b))\\n        {\\n            return true;\\n        }\\n             \\n        String key=a+\"_\"+b;\\n        if(map.containsKey(key))\\n        {\\n            return map.get(key);\\n        }\\n        boolean flag=false;\\n        int n=a.length();\\n        for(int i=1;i<n;i++)\\n        {\\n             boolean noswap=(solve(a.substring(0, i),b.substring(n - i,n)) && solve(a.substring(i, n),b.substring(0, n-i)));\\n         \\n            boolean swap=(solve(a.substring(0, i),b.substring(0, i))  && solve(a.substring(i, n),b.substring(i, n)));\\n            \\n            if(noswap||swap)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        map.put(a+\"_\"+b,flag);\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n     static HashMap<String,Boolean> map=new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        \\n        return solve(s1,s2);\\n    }\\n    public static boolean solve(String a,String b)\\n    {\\n        if(a.equals(b))\\n        {\\n            return true;\\n        }\\n             \\n        String key=a+\"_\"+b;\\n        if(map.containsKey(key))\\n        {\\n            return map.get(key);\\n        }\\n        boolean flag=false;\\n        int n=a.length();\\n        for(int i=1;i<n;i++)\\n        {\\n             boolean noswap=(solve(a.substring(0, i),b.substring(n - i,n)) && solve(a.substring(i, n),b.substring(0, n-i)));\\n         \\n            boolean swap=(solve(a.substring(0, i),b.substring(0, i))  && solve(a.substring(i, n),b.substring(i, n)));\\n            \\n            if(noswap||swap)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        map.put(a+\"_\"+b,flag);\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272195,
                "title": "java-standard-solution",
                "content": "```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.equals(s2))\\n            return true;\\n        if(s1.length() != s2.length())\\n            return false;\\n        \\n        return solve(s1,s2);\\n    }\\n    Map<String,Boolean> map = new HashMap<>();\\n    boolean solve(String a,String b)\\n    {\\n        if(a.equals(b))\\n            return true;\\n        if(a.length() !=b.length())\\n            return false;\\n        String key = a+\"*\"+b;\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        \\n        int n = a.length();\\n        for(int i=1;i<n;i++)\\n        {\\n            if( (solve(a.substring(0,i),b.substring(n-i)) && solve(a.substring(i),b.substring(0,n-i))) ||\\n             (solve(a.substring(0,i),b.substring(0,i)) && solve(a.substring(i),b.substring(i))) )\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.equals(s2))\\n            return true;\\n        if(s1.length() != s2.length())\\n            return false;\\n        \\n        return solve(s1,s2);\\n    }\\n    Map<String,Boolean> map = new HashMap<>();\\n    boolean solve(String a,String b)\\n    {\\n        if(a.equals(b))\\n            return true;\\n        if(a.length() !=b.length())\\n            return false;\\n        String key = a+\"*\"+b;\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        \\n        int n = a.length();\\n        for(int i=1;i<n;i++)\\n        {\\n            if( (solve(a.substring(0,i),b.substring(n-i)) && solve(a.substring(i),b.substring(0,n-i))) ||\\n             (solve(a.substring(0,i),b.substring(0,i)) && solve(a.substring(i),b.substring(i))) )\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261625,
                "title": "c-16-ms-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string,bool> mp;\\n    \\n    bool check(string a, string b){\\n        string key = a + \" \" + b;\\n        if (mp.find(key) != mp.end()) return mp[key];\\n        if(a==b) return mp[key]=true;\\n        if(a.length()<=1 || b.length()<=1) return mp[key]=false;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0; i<a.length(); i++){\\n            sum1=sum1+int(a[i]);\\n        }\\n        for(int i=0; i<b.length(); i++){\\n            sum2=sum2+int(b[i]);\\n        }\\n        if(sum1!=sum2) return mp[key]=false;\\n        \\n        int n=a.length();\\n        for(int i=1; i< a.length(); i++){\\n            if( check(a.substr(0,i),b.substr(0,i)) && check(a.substr(i,n-i),b.substr(i,n-i)) ){\\n                 return true;\\n                 break;\\n             }\\n            if( check(a.substr(0,i),b.substr(n-i,i)) && check(a.substr(i,n-i),b.substr(0,n-i))) {\\n                 return true;\\n                 break;\\n             }\\n        }\\n        return mp[key]=false;\\n        \\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1.length()!=s2.length()) return false;        \\n        return check(s1,s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string,bool> mp;\\n    \\n    bool check(string a, string b){\\n        string key = a + \" \" + b;\\n        if (mp.find(key) != mp.end()) return mp[key];\\n        if(a==b) return mp[key]=true;\\n        if(a.length()<=1 || b.length()<=1) return mp[key]=false;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0; i<a.length(); i++){\\n            sum1=sum1+int(a[i]);\\n        }\\n        for(int i=0; i<b.length(); i++){\\n            sum2=sum2+int(b[i]);\\n        }\\n        if(sum1!=sum2) return mp[key]=false;\\n        \\n        int n=a.length();\\n        for(int i=1; i< a.length(); i++){\\n            if( check(a.substr(0,i),b.substr(0,i)) && check(a.substr(i,n-i),b.substr(i,n-i)) ){\\n                 return true;\\n                 break;\\n             }\\n            if( check(a.substr(0,i),b.substr(n-i,i)) && check(a.substr(i,n-i),b.substr(0,n-i))) {\\n                 return true;\\n                 break;\\n             }\\n        }\\n        return mp[key]=false;\\n        \\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1.length()!=s2.length()) return false;        \\n        return check(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114466,
                "title": "c-dp-with-memoization",
                "content": "```\\n    /*\\n     * Recursive Approach or TopDown Approach\\n     *\\n     * There are n-1 ways to split the string into 2 parts L, R where L is the length of s1\\n     * For Eg:\\n     *   s1 = \"XY\"   s2 = \"YX\"\\n     *   \\n     * Partition s1 at 1\\n     *            XY\\n     *             |\\n     *          ---------\\n     *         |         |\\n     *         X         Y\\n     * 2 ways to merge the stirng\\n     *       . without swaping - XY\\n     *       . with swapping - YX\\n     *  It is seen from above that s1 and s2 are scrambled.\\n     *\\n     * Pseudo Code:\\n     * Partition the strings(s1, s2) into 2 parts to form x and y\\n     *        s1(0...j), s1(j+1...n)\\n     *        s2(0...j), s2(j+1...n)   where j = 1.. n-1\\n     *\\n     *  Both the stirng are scramble only if \\n     *        s1(0..j) & s2(0..j) are equal and s1(j+1...n) & s2(j+1...n) are equal\\n     *                               or (swap is allowed)\\n     *        s1(0..j) & s2(j+1...n) are equal and s1(j+1...n) & s2(0...j) are equal\\n     *\\n     * As there are many duplicate subproblems, implementing dynamic programming with\\n     * memorization\\n    */\\n    // DP table to store the result of subproblems ie.., whether the subproblems\\n    // s2 is scramble string of s1 or not.\\n    std::unordered_map<string, bool> dp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        if (s1.length() != s2.length()) {\\n            // Both are different sizes, then s2 can\\'t be scramble of s1\\n            return false;\\n        }\\n        // Check if both the strings are equal\\n        if (s1 == s2) {\\n            // Both strings are equal i.e.., s2 is a scramble stirng of s1\\n            return true;\\n        }\\n        // Initializing the key key with s1 and s2 with * as differentiator\\n        string key = s1 + \"*\" + s2;\\n        // Check if the subproblem is already evaluated\\n        if (dp.count(key) == 1) {\\n            // Subproblem is already evaluated\\n            return dp[key];\\n        }\\n\\n        int n = s1.length();\\n        int res = false;\\n        \\n        // Partition the string, As both the strings of equal length\\n        for (int i = 1; i < s1.length(); i++) {\\n            if ( isScramble(s1.substr(0,i), s2.substr(0,i)) && \\n                 isScramble(s1.substr(i, n-i), s2.substr(i, n-i))) {\\n                res = true;\\n                break;\\n            }\\n            if ( isScramble(s1.substr(0,i), s2.substr(n-i, i)) && \\n                 isScramble(s1.substr(i, n-i), s2.substr(0, n-i))) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        \\n        dp[key] = res;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * Recursive Approach or TopDown Approach\\n     *\\n     * There are n-1 ways to split the string into 2 parts L, R where L is the length of s1\\n     * For Eg:\\n     *   s1 = \"XY\"   s2 = \"YX\"\\n     *   \\n     * Partition s1 at 1\\n     *            XY\\n     *             |\\n     *          ---------\\n     *         |         |\\n     *         X         Y\\n     * 2 ways to merge the stirng\\n     *       . without swaping - XY\\n     *       . with swapping - YX\\n     *  It is seen from above that s1 and s2 are scrambled.\\n     *\\n     * Pseudo Code:\\n     * Partition the strings(s1, s2) into 2 parts to form x and y\\n     *        s1(0...j), s1(j+1...n)\\n     *        s2(0...j), s2(j+1...n)   where j = 1.. n-1\\n     *\\n     *  Both the stirng are scramble only if \\n     *        s1(0..j) & s2(0..j) are equal and s1(j+1...n) & s2(j+1...n) are equal\\n     *                               or (swap is allowed)\\n     *        s1(0..j) & s2(j+1...n) are equal and s1(j+1...n) & s2(0...j) are equal\\n     *\\n     * As there are many duplicate subproblems, implementing dynamic programming with\\n     * memorization\\n    */\\n    // DP table to store the result of subproblems ie.., whether the subproblems\\n    // s2 is scramble string of s1 or not.\\n    std::unordered_map<string, bool> dp;\\n    \\n    bool isScramble(string s1, string s2) {\\n        if (s1.length() != s2.length()) {\\n            // Both are different sizes, then s2 can\\'t be scramble of s1\\n            return false;\\n        }\\n        // Check if both the strings are equal\\n        if (s1 == s2) {\\n            // Both strings are equal i.e.., s2 is a scramble stirng of s1\\n            return true;\\n        }\\n        // Initializing the key key with s1 and s2 with * as differentiator\\n        string key = s1 + \"*\" + s2;\\n        // Check if the subproblem is already evaluated\\n        if (dp.count(key) == 1) {\\n            // Subproblem is already evaluated\\n            return dp[key];\\n        }\\n\\n        int n = s1.length();\\n        int res = false;\\n        \\n        // Partition the string, As both the strings of equal length\\n        for (int i = 1; i < s1.length(); i++) {\\n            if ( isScramble(s1.substr(0,i), s2.substr(0,i)) && \\n                 isScramble(s1.substr(i, n-i), s2.substr(i, n-i))) {\\n                res = true;\\n                break;\\n            }\\n            if ( isScramble(s1.substr(0,i), s2.substr(n-i, i)) && \\n                 isScramble(s1.substr(i, n-i), s2.substr(0, n-i))) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        \\n        dp[key] = res;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925246,
                "title": "bottom-up-dp-o-n-4-clean-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string a, string b) {\\n        int n = a.length();\\n\\t\\t// dp[i][j][k] = Whether the strings a[i, ..., i+k-1] and b[j, ..., j+k-1] \\n\\t\\t// are scrambled version of each other\\n        bool dp[n][n][n+1];\\n        memset(dp, 0, sizeof(dp));\\n        \\n\\t\\t// Base case: comparing all substrings of size 1 \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) \\n                dp[i][j][1] = a[i] == b[j];\\n        }\\n        \\n        for(int k = 2; k <= n; k++) {\\n            for(int i = 0; i <= (n-k); i++) {\\n                for(int j = 0; j <= (n-k); j++) {\\n                    \\n\\t\\t\\t\\t\\t// Split the strings A = a[i, ... , i + k-1], B = b[j, ..., j + k-1]\\n\\t\\t\\t\\t\\t// into length r and (k-r) length. (say A1, A2 and B1, B2)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// For A and B to be scrambled versions of each other, \\n\\t\\t\\t\\t\\t// either A1 = scrambled(B1) and A2 = scrambled(B2) or\\n\\t\\t\\t\\t\\t// A1 = scrambled(B2) and A2 = scrambled(B1)\\n                    for(int r = 1; r < k; r++) {\\n                        dp[i][j][k] |= (dp[i][j][r] && dp[i+r][j+r][k-r]) || \\n                                       (dp[i][j+k-r][r] && dp[i+r][j][k-r]);\\n                    }\\n                    \\n                }\\n            }    \\n        }\\n        \\n        return dp[0][0][n];\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isScramble(string a, string b) {\\n        int n = a.length();\\n\\t\\t// dp[i][j][k] = Whether the strings a[i, ..., i+k-1] and b[j, ..., j+k-1] \\n\\t\\t// are scrambled version of each other\\n        bool dp[n][n][n+1];\\n        memset(dp, 0, sizeof(dp));\\n        \\n\\t\\t// Base case: comparing all substrings of size 1 \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) \\n                dp[i][j][1] = a[i] == b[j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 832610,
                "title": "java-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\n    Map<Integer, Boolean> cache;\\n    public boolean isScramble(String a, String b) {\\n        if(a.length() != b.length()) return false;\\n        if(a.length() == 0) return false;\\n        cache = new HashMap<>();\\n        return isSR(a, b);\\n    }\\n\\n    private boolean isSR(String a, String b) {\\n        int hash = (a + \"_\" + b).hashCode();\\n        if(cache.get(hash) != null) {\\n            return cache.get(hash);\\n        }\\n        int n = a.length();\\n        if(a.equals(b)) return true;\\n        if(n <= 1) return false;\\n        \\n        boolean isSS = false;\\n        boolean swapped = false;\\n        boolean not_swapped = false;\\n        for(int i = 1; i < n; i++) {\\n            if(isSR(a.substring(0, i), b.substring(n-i, n)) &&\\n                              isSR(a.substring(i, n), b.substring(0, n-i))) {\\n                swapped = true;\\n            } else if(isSR(a.substring(0, i), b.substring(0, i)) && \\n                      isSR(a.substring(i, n), b.substring(i, n))) {\\n                not_swapped = true;\\n            }\\n            if(swapped || not_swapped) {\\n                isSS = true;\\n                break;\\n            }\\n        }\\n        cache.put(hash, isSS);\\n        return isSS;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Boolean> cache;\\n    public boolean isScramble(String a, String b) {\\n        if(a.length() != b.length()) return false;\\n        if(a.length() == 0) return false;\\n        cache = new HashMap<>();\\n        return isSR(a, b);\\n    }\\n\\n    private boolean isSR(String a, String b) {\\n        int hash = (a + \"_\" + b).hashCode();\\n        if(cache.get(hash) != null) {\\n            return cache.get(hash);\\n        }\\n        int n = a.length();\\n        if(a.equals(b)) return true;\\n        if(n <= 1) return false;\\n        \\n        boolean isSS = false;\\n        boolean swapped = false;\\n        boolean not_swapped = false;\\n        for(int i = 1; i < n; i++) {\\n            if(isSR(a.substring(0, i), b.substring(n-i, n)) &&\\n                              isSR(a.substring(i, n), b.substring(0, n-i))) {\\n                swapped = true;\\n            } else if(isSR(a.substring(0, i), b.substring(0, i)) && \\n                      isSR(a.substring(i, n), b.substring(i, n))) {\\n                not_swapped = true;\\n            }\\n            if(swapped || not_swapped) {\\n                isSS = true;\\n                break;\\n            }\\n        }\\n        cache.put(hash, isSS);\\n        return isSS;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316778,
                "title": "c-o-2-n-splitting-solution-very-small-input",
                "content": "Micro explanation is this:\\n\\nFor a given string, s. of length N, we could split the string at any point from 1...N-1\\n\\nThen we would have s1 and s2, which we could re-order to a string b which is either s1s2 or s2s1.\\n\\nLet\\'s try an example, for only 1 level of scrambling depth...:\\n\\ns = hamburger\\nb = burgerham\\n\\nWe have some possible solutions:\\n\\n1.)\\nh amburger\\nWe compare with \\nb|urgerham OR burgerha|m\\n\\n2.)\\nha mburger\\nWe compare with \\nbu|rgerham OR burgerh|am\\n\\n3.)\\nham burger\\nWe compare with \\nbur|gerham OR burger|ham\\n\\nWe see that #3 is a valid scramble since \"ham\" is a scramble of \"ham\" and \"burger\" is a scramble of \"burger\"\\n\\nSo, essentially we recursively check valid sub-scrambles, for being scrambles... \\n\\nScrambles always have the same number of each letter. So this can be a quick heuristic to exit and side-search.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        \\n        if (s1 == s2) { return true; }\\n        if (s1.size() != s2.size()) { return false; }\\n        \\n        string aComp1 = s1;\\n        string aComp2 = s2;\\n        \\n        int aLen = s1.size();\\n        \\n        sort(aComp1.begin(), aComp1.end());\\n        sort(aComp2.begin(), aComp2.end());\\n        if (aComp1 != aComp2) { return false; }\\n        \\n        for (int i=1;i<s1.size();i++) {\\n            \\n            string aComps11 = s1.substr(0, i);\\n            string aComps12 = s1.substr(i);\\n            \\n            string aComp1s21 = s2.substr(0, i);\\n            string aComp1s22 = s2.substr(i);\\n            \\n            string aComp2s21 = s2.substr(aLen - i);\\n            string aComp2s22 = s2.substr(0, aLen - i);\\n            \\n            if (isScramble(aComps11, aComp1s21) && isScramble(aComps12, aComp1s22)) {\\n                return true;\\n            }\\n            \\n            if (isScramble(aComps11, aComp2s21) && isScramble(aComps12, aComp2s22)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        \\n        if (s1 == s2) { return true; }\\n        if (s1.size() != s2.size()) { return false; }\\n        \\n        string aComp1 = s1;\\n        string aComp2 = s2;\\n        \\n        int aLen = s1.size();\\n        \\n        sort(aComp1.begin(), aComp1.end());\\n        sort(aComp2.begin(), aComp2.end());\\n        if (aComp1 != aComp2) { return false; }\\n        \\n        for (int i=1;i<s1.size();i++) {\\n            \\n            string aComps11 = s1.substr(0, i);\\n            string aComps12 = s1.substr(i);\\n            \\n            string aComp1s21 = s2.substr(0, i);\\n            string aComp1s22 = s2.substr(i);\\n            \\n            string aComp2s21 = s2.substr(aLen - i);\\n            string aComp2s22 = s2.substr(0, aLen - i);\\n            \\n            if (isScramble(aComps11, aComp1s21) && isScramble(aComps12, aComp1s22)) {\\n                return true;\\n            }\\n            \\n            if (isScramble(aComps11, aComp2s21) && isScramble(aComps12, aComp2s22)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250761,
                "title": "java-simple-code-1ms",
                "content": "````\\n\\tpublic boolean isScramble(String s1, String s2) {\\n        if (s1.length() != s2.length()) return false;\\n        if (s1.isEmpty()) return true;\\n        if (s1.equals(s2)) return true;\\n        return isScramble(s1, s2, 0, 0, s1.length());\\n    }\\n\\n    public boolean permutation(String s1, String s2, int i1, int i2, int n) {\\n        int[] cs = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            cs[s1.charAt(i1+i)-\\'a\\']++;\\n            cs[s2.charAt(i2+i)-\\'a\\']--;\\n        }\\n        for (int m : cs) if (m != 0) return false;        \\n        return true;\\n    }\\n\\n    public boolean equal(String s1, String s2, int i1, int i2, int n) {\\n        for (int i = 0; i < n; i++) {\\n            if (s1.charAt(i1+i) != s2.charAt(i2+i)) return false;\\n        }\\n        return true;\\n    }\\n\\n    public boolean isScramble(String s1, String s2, int i1, int i2, int n) {\\n        if (equal(s1,s2,i1,i2,n)) return true;\\n        if (!permutation(s1,s2,i1,i2,n)) return false;\\n        for (int len=1; len<n; len++) {\\n            if (isScramble(s1, s2, i1, i2, len) && isScramble(s1, s2, i1+len, i2+len, n-len)) return true;\\n            if (isScramble(s1, s2, i1, i2+n-len, len) && isScramble(s1, s2, i1+len, i2, n-len)) return true;\\n        }\\n        return false;\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n\\tpublic boolean isScramble(String s1, String s2) {\\n        if (s1.length() != s2.length()) return false;\\n        if (s1.isEmpty()) return true;\\n        if (s1.equals(s2)) return true;\\n        return isScramble(s1, s2, 0, 0, s1.length());\\n    }\\n\\n    public boolean permutation(String s1, String s2, int i1, int i2, int n) {\\n        int[] cs = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            cs[s1.charAt(i1+i)-\\'a\\']++;\\n            cs[s2.charAt(i2+i)-\\'a\\']--;\\n        }\\n        for (int m : cs) if (m != 0) return false;        \\n        return true;\\n    }\\n\\n    public boolean equal(String s1, String s2, int i1, int i2, int n) {\\n        for (int i = 0; i < n; i++) {\\n            if (s1.charAt(i1+i) != s2.charAt(i2+i)) return false;\\n        }\\n        return true;\\n    }\\n\\n    public boolean isScramble(String s1, String s2, int i1, int i2, int n) {\\n        if (equal(s1,s2,i1,i2,n)) return true;\\n        if (!permutation(s1,s2,i1,i2,n)) return false;\\n        for (int len=1; len<n; len++) {\\n            if (isScramble(s1, s2, i1, i2, len) && isScramble(s1, s2, i1+len, i2+len, n-len)) return true;\\n            if (isScramble(s1, s2, i1, i2+n-len, len) && isScramble(s1, s2, i1+len, i2, n-len)) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29432,
                "title": "sharing-recursive-python-solution-with-memo-beats-99",
                "content": "        def isScramble(self, s, t, memo={}):\\n\\n            # Check with sorted is fundamental, otherwise TLE\\n            if len(s) != len(t) or sorted(s) != sorted(t):\\n                return False\\n            if len(s) <= len(t) <= 1:\\n                return s == t\\n            if s == t:\\n                return True\\n            if (s, t) in memo:\\n                return memo[s, t]\\n            n = len(s)\\n            for i in range(1, n):\\n                    a = self.isScramble(s[:i], t[:i], memo) and self.isScramble(s[i:], t[i:], memo)\\n                    if not a:\\n                        b = self.isScramble(s[:i], t[-i:], memo) and self.isScramble(s[i:], t[:-i], memo)\\n                    if a or b:\\n                        memo[s, t] = True\\n                        return True\\n            memo[s, t] = False\\n            return False",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        def isScramble(self, s, t, memo={}):\\n\\n            # Check with sorted is fundamental, otherwise TLE\\n            if len(s) != len(t) or sorted(s) != sorted(t):\\n                return False\\n            if len(s) <= len(t) <= 1:\\n                return s == t\\n            if s == t:\\n                return True\\n            if (s, t) in memo:\\n                return memo[s, t]\\n            n = len(s)\\n            for i in range(1, n):\\n                    a = self.isScramble(s[:i], t[:i], memo) and self.isScramble(s[i:], t[i:], memo)\\n                    if not a:\\n                        b = self.isScramble(s[:i], t[-i:], memo) and self.isScramble(s[i:], t[:-i], memo)\\n                    if a or b:\\n                        memo[s, t] = True\\n                        return True\\n            memo[s, t] = False\\n            return False",
                "codeTag": "Python3"
            },
            {
                "id": 29434,
                "title": "2ms-java-recursive-solution-beat-100",
                "content": "    public class Solution {\\n        int[] p = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};\\n        public boolean isScramble(String s1, String s2) {\\n            int l1=s1.length(), l2=s2.length();\\n            if(l1!=l2) return false;\\n            if(l1<=1) return s1.equals(s2);\\n            if(s1.equals(s2)) return true;\\n            long a=1, b=1, c=1;\\n            for(int i=0; i<l1; i++){\\n                if(i>0 && a==b && isScramble(s1.substring(0,i),s2.substring(l2-i)) && isScramble(s1.substring(i),s2.substring(0,l2-i)))\\n                    return true;\\n                if(i>0 && a==c && isScramble(s1.substring(0,i),s2.substring(0,i)) && isScramble(s1.substring(i),s2.substring(i)))\\n                    return true;\\n                a*=p[s1.charAt(i)-'A'];\\n                b*=p[s2.charAt(l2-1-i)-'A'];\\n                c*=p[s2.charAt(i)-'A'];\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int[] p = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997}",
                "codeTag": "Java"
            },
            {
                "id": 29414,
                "title": "java-fast-dp-iteration-solution-and-recursion-solution",
                "content": "Iterative version:\\n\\n    public class Solution {\\n        public boolean isScramble(String s1, String s2) {\\n            int len = s1.length();\\n            if(len!=s2.length()) return false;\\n            if(len==0) return true;\\n            boolean[][][] isScr = new boolean[len][len][len];\\n            for(int i = 0; i < len; i++) { //length of current substring, 0 means length==1\\n                for(int j = 0; j + i < len; j++) { //start point of current substring at s1.\\n                    for(int k = 0; k + i < len; k++) { //start point of current substring at s2.\\n                        if(i==0) isScr[i][j][k] = s1.charAt(j)==s2.charAt(k);\\n                        for(int m = 0; m < i; m++) {\\n                            if(isScr[m][j][k] && isScr[i-(m+1)][j+m+1][k+m+1]) isScr[i][j][k] = true;\\n                            else if(isScr[m][j][k+i-m] && isScr[i-(m+1)][j+m+1][k]) isScr[i][j][k] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            return isScr[len-1][0][0];\\n        }\\n    }\\n\\nRecursive version: with some pruning check at the beginning, finally get rid of TLE...\\n\\n\\n    public class Solution {\\n        public boolean isScramble(String s1, String s2) {\\n            int len= s1.length();\\n            if(s2.length()!=len) return false;\\n            if(s1.equals(s2)) return true;\\n            Map<Character,Integer> checkPermutation = new HashMap<Character,Integer>();\\n            for(int i = 0; i < len; i++) {\\n                char a = s1.charAt(i), b = s2.charAt(i);\\n                if(checkPermutation.containsKey(a)) checkPermutation.put(a,checkPermutation.get(a)+1);\\n                else checkPermutation.put(a,1);\\n                if(checkPermutation.containsKey(b)) checkPermutation.put(b,checkPermutation.get(b)-1);\\n                else checkPermutation.put(b,-1);\\n            }\\n            for(char c : checkPermutation.keySet()) if(checkPermutation.get(c)!=0) return false;\\n            \\n            for(int i = 1; i < s1.length(); i++) {\\n                if(isScramble(s1.substring(0,i),s2.substring(0,i))&&isScramble(s1.substring(i,len),s2.substring(i,len))) return true;\\n                else if(isScramble(s1.substring(0,i),s2.substring(len-i,len))&&isScramble(s1.substring(i,len),s2.substring(0,len-i))) return true;\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isScramble(String s1, String s2) {\\n            int len = s1.length();\\n            if(len!=s2.length()) return false;\\n            if(len==0) return true;\\n            boolean[][][] isScr = new boolean[len][len][len];\\n            for(int i = 0; i < len; i++) { //length of current substring, 0 means length==1\\n                for(int j = 0; j + i < len; j++) { //start point of current substring at s1.\\n                    for(int k = 0; k + i < len; k++) { //start point of current substring at s2.\\n                        if(i==0) isScr[i][j][k] = s1.charAt(j)==s2.charAt(k);\\n                        for(int m = 0; m < i; m++) {\\n                            if(isScr[m][j][k] && isScr[i-(m+1)][j+m+1][k+m+1]) isScr[i][j][k] = true;\\n                            else if(isScr[m][j][k+i-m] && isScr[i-(m+1)][j+m+1][k]) isScr[i][j][k] = true;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3358908,
                "title": "c-memoization-map-aaditya-verma-type-solution",
                "content": "````\\n\\nclass Solution {\\npublic:\\n    bool solve(string s1,string s2,unordered_map<string,bool> &mp){\\n        if(s1.length()!=s2.length()){\\n            return false;\\n        }\\n        if(s1.size()==0&&s2.size()==0){\\n            return true;\\n        }\\n        if(s1.compare(s2)==0){\\n            return true;\\n        }\\n        if(s1.length()<=1){\\n            return false;\\n        }\\n        string key = s1+\" \"+s2;\\n        if(mp.find(key)!=mp.end()){\\n            return mp[key];\\n        }\\n        bool ans = false;\\n        int n = s1.length();\\n        for(int i = 1; i <= n-1; i++){\\n            if(solve(s1.substr(0,i),s2.substr(n-i),mp)==true&&solve(s1.substr(i,n-i),s2.substr(0,n-i),mp)==true){\\n                ans = true;\\n            }\\n            if(!ans&&solve(s1.substr(0,i),s2.substr(0,i),mp)==true&&solve(s1.substr(i,n-i),s2.substr(i,n-i),mp)==true){\\n                ans = true;\\n            }\\n        }\\n        return mp[key] = ans;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string,bool> mp;\\n        int n = s1.length();\\n        return solve(s1,s2,mp);\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "````\\n\\nclass Solution {\\npublic:\\n    bool solve(string s1,string s2,unordered_map<string,bool> &mp){\\n        if(s1.length()!=s2.length()){\\n            return false;\\n        }\\n        if(s1.size()==0&&s2.size()==0){\\n            return true;\\n        }\\n        if(s1.compare(s2)==0){\\n            return true;\\n        }\\n        if(s1.length()<=1){\\n            return false;\\n        }\\n        string key = s1+\" \"+s2;\\n        if(mp.find(key)!=mp.end()){\\n            return mp[key];\\n        }\\n        bool ans = false;\\n        int n = s1.length();\\n        for(int i = 1; i <= n-1; i++){\\n            if(solve(s1.substr(0,i),s2.substr(n-i),mp)==true&&solve(s1.substr(i,n-i),s2.substr(0,n-i),mp)==true){\\n                ans = true;\\n            }\\n            if(!ans&&solve(s1.substr(0,i),s2.substr(0,i),mp)==true&&solve(s1.substr(i,n-i),s2.substr(i,n-i),mp)==true){\\n                ans = true;\\n            }\\n        }\\n        return mp[key] = ans;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string,bool> mp;\\n        int n = s1.length();\\n        return solve(s1,s2,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357888,
                "title": "solution-in-cpp-with-all-the-test-cases-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//for storing already solved problems\\n    unordered_map<string,bool> mp;\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        //base cases\\n        \\n        int n = s1.size();\\n        \\n        //if both string are not equal in size\\n        if(s2.size()!=n)\\n            return false;\\n        \\n        //if both string are equal\\n        if(s1==s2)\\n         return true;   \\n        \\n            \\n        \\n        //if code is reached to this condition then following this are sure:\\n        //1. size of both string is equal\\n        //2.  string are not equal\\n        //so size is equal (where size==1) and they are not equal then obviously false\\n        //example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if(n==1)\\n            return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n\\t\\t//check if this problem has already been solved\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        //for every iteration it can two condition \\n        //1.we should proceed without swapping\\n        //2.we should swap before looking next\\n        for(int i=1;i<n;i++)\\n        {\\n\\n            //ex of without swap: gr|eat and rg|eat\\n            bool withoutswap = (\\n                //left part of first and second string\\n                isScramble(s1.substr(0,i),s2.substr(0,i)) \\n                \\n                &&\\n                \\n                //right part of first and second string;\\n                isScramble(s1.substr(i),s2.substr(i))\\n                );\\n            \\n            \\n            \\n            //if without swap give us right answer then we do not need \\n            //to call the recursion withswap\\n            if(withoutswap)\\n                return true;\\n            \\n            //ex of withswap: gr|eat  rge|at\\n\\t\\t\\t//here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            bool withswap = (\\n                //left part of first and right part of second \\n                isScramble(s1.substr(0,i),s2.substr(n-i)) \\n                \\n                &&\\n                \\n                //right part of first and left part of second\\n                isScramble(s1.substr(i),s2.substr(0,n-i)) \\n                );\\n            \\n            \\n            \\n            //if withswap give us right answer then we return true\\n            //otherwise the for loop do it work\\n            if(withswap)\\n                return true;\\n            //we are not returning false in else case \\n            //because we want to check further cases with the for loop\\n        }\\n        \\n        \\n        return mp[key] = false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//for storing already solved problems\\n    unordered_map<string,bool> mp;\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        //base cases\\n        \\n        int n = s1.size();\\n        \\n        //if both string are not equal in size\\n        if(s2.size()!=n)\\n            return false;\\n        \\n        //if both string are equal\\n        if(s1==s2)\\n         return true;   \\n        \\n            \\n        \\n        //if code is reached to this condition then following this are sure:\\n        //1. size of both string is equal\\n        //2.  string are not equal\\n        //so size is equal (where size==1) and they are not equal then obviously false\\n        //example \\'a\\' and \\'b\\' size is equal ,string are not equal\\n        if(n==1)\\n            return false;\\n        \\n        string key = s1+\" \"+s2;\\n        \\n\\t\\t//check if this problem has already been solved\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        //for every iteration it can two condition \\n        //1.we should proceed without swapping\\n        //2.we should swap before looking next\\n        for(int i=1;i<n;i++)\\n        {\\n\\n            //ex of without swap: gr|eat and rg|eat\\n            bool withoutswap = (\\n                //left part of first and second string\\n                isScramble(s1.substr(0,i),s2.substr(0,i)) \\n                \\n                &&\\n                \\n                //right part of first and second string;\\n                isScramble(s1.substr(i),s2.substr(i))\\n                );\\n            \\n            \\n            \\n            //if without swap give us right answer then we do not need \\n            //to call the recursion withswap\\n            if(withoutswap)\\n                return true;\\n            \\n            //ex of withswap: gr|eat  rge|at\\n\\t\\t\\t//here we compare \"gr\" with \"at\" and \"eat\" with \"rge\"\\n            bool withswap = (\\n                //left part of first and right part of second \\n                isScramble(s1.substr(0,i),s2.substr(n-i)) \\n                \\n                &&\\n                \\n                //right part of first and left part of second\\n                isScramble(s1.substr(i),s2.substr(0,n-i)) \\n                );\\n            \\n            \\n            \\n            //if withswap give us right answer then we return true\\n            //otherwise the for loop do it work\\n            if(withswap)\\n                return true;\\n            //we are not returning false in else case \\n            //because we want to check further cases with the for loop\\n        }\\n        \\n        \\n        return mp[key] = false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357418,
                "title": "daily-leetcoding-challenge-march-day-30",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/scramble-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/scramble-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3185712,
                "title": "scramble-string-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere\\'s one approach to solve the problem using Dynamic Programming in Python3:\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2):\\n            return False\\n        if len(s1) == 1:\\n            return s1 == s2\\n        \\n        n = len(s1)\\n        dp = [[[False] * (n + 1) for _ in range(n)] for __ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if s1[i] == s2[j]:\\n                    dp[i][j][1] = True\\n        \\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                for j in range(n - l + 1):\\n                    for k in range(1, l):\\n                        if (dp[i][j][k] and dp[i + k][j + k][l - k]) or (dp[i][j + l - k][k] and dp[i + k][j][l - k]):\\n                            dp[i][j][l] = True\\n                            break\\n        return dp[0][0][n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2):\\n            return False\\n        if len(s1) == 1:\\n            return s1 == s2\\n        \\n        n = len(s1)\\n        dp = [[[False] * (n + 1) for _ in range(n)] for __ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if s1[i] == s2[j]:\\n                    dp[i][j][1] = True\\n        \\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                for j in range(n - l + 1):\\n                    for k in range(1, l):\\n                        if (dp[i][j][k] and dp[i + k][j + k][l - k]) or (dp[i][j + l - k][k] and dp[i + k][j][l - k]):\\n                            dp[i][j][l] = True\\n                            break\\n        return dp[0][0][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966518,
                "title": "scramble-string-c-simple-solution-using-unordered-map",
                "content": "# For more solution git repo\\n[https://github.com/Funik69/Leetcode_Solution]()\\n[https://github.com/Funik69/Leetcode-Algorithm-StudyPlan-]()\\n[https://github.com/Funik69/LeetCode-75---Study-Plan]()\\n[https://github.com/Funik69/Programming-Skills-1]()\\n# C++ code\\n```\\nclass Solution {\\npublic:\\n    unordered_map <string,bool> mp;\\n\\nbool solve(string a ,string b){\\n    if(a.length()!=b.length()){\\n        return false;\\n    }\\n    if(a.compare(b)==0){\\n        return true;\\n    }\\n    if(a.length()<=1){\\n        return false;\\n    }\\n    int n= a.length();\\n    bool flag =false;\\n\\n    string key= (a+\" \"+b);\\n    if(mp.find(key)!=mp.end()){\\n        return mp[key];\\n    }\\n\\n    for(int i=1;i<=n-1;i++){\\n        //gr eat   eat gr\\n        if(solve(a.substr(0,i),b.substr(n-i,i)) && solve(a.substr(i,n-i),b.substr(0,n-i)))\\n        {flag = true;\\n        break;}\\n\\n        //gr eat   gr ate \\n        else if(solve(a.substr(0,i),b.substr(0,i)) && solve(a.substr(i,n-i),b.substr(i,n-i)))\\n        {flag= true;\\n        break;}\\n    }\\n    return mp[key]=flag;\\n}\\n    bool isScramble(string s1, string s2) {\\n        string a=s1;\\n        string b=s2;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a!=b) return false;\\n        else return solve(s1,s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map <string,bool> mp;\\n\\nbool solve(string a ,string b){\\n    if(a.length()!=b.length()){\\n        return false;\\n    }\\n    if(a.compare(b)==0){\\n        return true;\\n    }\\n    if(a.length()<=1){\\n        return false;\\n    }\\n    int n= a.length();\\n    bool flag =false;\\n\\n    string key= (a+\" \"+b);\\n    if(mp.find(key)!=mp.end()){\\n        return mp[key];\\n    }\\n\\n    for(int i=1;i<=n-1;i++){\\n        //gr eat   eat gr\\n        if(solve(a.substr(0,i),b.substr(n-i,i)) && solve(a.substr(i,n-i),b.substr(0,n-i)))\\n        {flag = true;\\n        break;}\\n\\n        //gr eat   gr ate \\n        else if(solve(a.substr(0,i),b.substr(0,i)) && solve(a.substr(i,n-i),b.substr(i,n-i)))\\n        {flag= true;\\n        break;}\\n    }\\n    return mp[key]=flag;\\n}\\n    bool isScramble(string s1, string s2) {\\n        string a=s1;\\n        string b=s2;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a!=b) return false;\\n        else return solve(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873254,
                "title": "c-dp-using-memoization-and-recursion-faster-than-90",
                "content": "class Solution {\\npublic:int dp[31][31][31][31];\\n    bool solve(int a, int b, int i, int j, string &s1,string &s2){\\n        if(i>j)\\n            return false;\\n        if(i==j)\\n            return s1[a]==s2[i];\\n        if(dp[a][b][i][j]!=-1)\\n            return dp[a][b][i][j];\\n        bool ans=false;\\n        for(int k=0;k<=(j-i-1);k++){\\n            ans=ans||(solve(a,a+k,i,i+k,s1,s2) && solve(a+k+1,b,i+k+1,j,s1,s2));\\n             }\\n                for(int k=0;k<=(j-i-1);k++){\\n            ans=ans||(solve(a,a+k,j-k,j,s1,s2) && solve(a+k+1,b,i,j-k-1,s1,s2));\\n             }\\n        return dp[a][b][i][j]=ans;\\n        }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,s1.length()-1,0,s1.length()-1,s1,s2);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:int dp[31][31][31][31];\\n    bool solve(int a, int b, int i, int j, string &s1,string &s2){\\n        if(i>j)\\n            return false;\\n        if(i==j)\\n            return s1[a]==s2[i];\\n        if(dp[a][b][i][j]!=-1)\\n            return dp[a][b][i][j];\\n        bool ans=false;\\n        for(int k=0;k<=(j-i-1);k++){\\n            ans=ans||(solve(a,a+k,i,i+k,s1,s2) && solve(a+k+1,b,i+k+1,j,s1,s2));\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1760815,
                "title": "c-dp-aditya-verma",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    unordered_map<string,bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n       \\n        \\n        if(s1.compare(s2)==0)\\n            return true;\\n        \\n        string key=s1;\\n        key.append(\" \");\\n        key.append(s2);\\n        \\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        int n=s1.length();\\n        bool flag=false;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n        bool unswap=isScramble(s1.substr(0,i),s2.substr(0,i)) && \\n        isScramble(s1.substr(i,n-i),s2.substr(i,n-i));\\n        bool swapped=isScramble(s1.substr(0,i),s2.substr(n-i,i)) && \\n        isScramble(s1.substr(i,n-i),s2.substr(0,n-i));\\n            \\n        if(unswap || swapped)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        \\n        return mp[key]=flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    unordered_map<string,bool> mp;\\n    \\n    bool isScramble(string s1, string s2) {\\n       \\n        \\n        if(s1.compare(s2)==0)\\n            return true;\\n        \\n        string key=s1;\\n        key.append(\" \");\\n        key.append(s2);\\n        \\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        \\n        int n=s1.length();\\n        bool flag=false;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n        bool unswap=isScramble(s1.substr(0,i),s2.substr(0,i)) && \\n        isScramble(s1.substr(i,n-i),s2.substr(i,n-i));\\n        bool swapped=isScramble(s1.substr(0,i),s2.substr(n-i,i)) && \\n        isScramble(s1.substr(i,n-i),s2.substr(0,n-i));\\n            \\n        if(unswap || swapped)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        \\n        return mp[key]=flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601661,
                "title": "python-dp",
                "content": "General idea is to simulate the problem and cache each subproblem.\\n\\n### F(a,b)\\nLet `F(a,b)` be true if we can scramble a to get b. \\n\\n### Base Case\\n1 if `a==b` we return true since theyre already equal\\n2. if len(a) == 1 and a != b, then we cant scramble a to b so we return false.\\n\\n### Recursive step\\nFor every (left_a, right_a) where (left_a + right_a) = a, we can either swap the two or not swap.\\n\\n#### Case 1: dont swap\\n\\nWhen we don\\'t swap, we need to break b into left_b and right_b the same way we broke a  into left_a and left_b.\\nThen, we can scramble a to get b if `f(left_a, left_b)` and `f(right_a, right_b)` are true.\\n\\nCase 2: swap\\n\\nIf we swap, its similar to not swapping, but we simulate the \\'swap\\' by breaking `b` into left_b, right_b such that len(left_a) == len(right_b) and len(right_b) == len(left_a). then we can scramble a to get b again if  `f(left_a, right_b)` and `f(right_a, left_b)` are true.\\n\\nWe cache these results so we dont repeat the same calculations.\\n\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def f(a, b):\\n            if a == b:\\n                return True\\n            assert(len(a) == len(b))\\n            \\n            if len(a) == 1:\\n                return False\\n            \\n            for length in range(1, len(a)):\\n                # no swap\\n                if f(a[:length], b[:length]) and f(a[length:], b[length:]):\\n                    return True\\n                \\n                # swap\\n                if f(a[:length], b[-length:]) and f(a[length:], b[:len(a)-length]):\\n                    return True\\n            return False\\n        \\n        return f(s1, s2)\\n                \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def f(a, b):\\n            if a == b:\\n                return True\\n            assert(len(a) == len(b))\\n            \\n            if len(a) == 1:\\n                return False\\n            \\n            for length in range(1, len(a)):\\n                # no swap\\n                if f(a[:length], b[:length]) and f(a[length:], b[length:]):\\n                    return True\\n                \\n                # swap\\n                if f(a[:length], b[-length:]) and f(a[length:], b[:len(a)-length]):\\n                    return True\\n            return False\\n        \\n        return f(s1, s2)\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599878,
                "title": "c-memoization",
                "content": "```\\nunordered_map<string, int> mp;\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2)\\n            return true;\\n        if(s1.length() <= 1)\\n            return false;\\n        string key = s1 + \" \" + s2;\\n        if(mp.count(key))\\n            return mp[key];\\n        \\n        int n = s1.length();\\n        bool res = false;\\n        for(int i = 1; i < n; i++) {\\n            bool swap = isScramble(s1.substr(0, i), s2.substr(n-i, i)) && \\n                isScramble(s1.substr(i, n-i), s2.substr(0, n-i));\\n            bool noswap = isScramble(s1.substr(0, i), s2.substr(0, i)) && \\n                isScramble(s1.substr(i, n-i), s2.substr(i, n-i));\\n            if(swap || noswap) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        mp[key] = res;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\nunordered_map<string, int> mp;\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2)\\n            return true;\\n        if(s1.length() <= 1)\\n            return false;\\n        string key = s1 + \" \" + s2;\\n        if(mp.count(key))\\n            return mp[key];\\n        \\n        int n = s1.length();\\n        bool res = false;\\n        for(int i = 1; i < n; i++) {\\n            bool swap = isScramble(s1.substr(0, i), s2.substr(n-i, i)) && \\n                isScramble(s1.substr(i, n-i), s2.substr(0, n-i));\\n            bool noswap = isScramble(s1.substr(0, i), s2.substr(0, i)) && \\n                isScramble(s1.substr(i, n-i), s2.substr(i, n-i));\\n            if(swap || noswap) {\\n                res = true;\\n                break;\\n            }\\n        }\\n        mp[key] = res;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1308418,
                "title": "c-dp-o-n-4-complexity-memory-o-n-3",
                "content": "**This problem can be solved if one is able to define a dp state properly**\\n\\n> Q1: Where to Cut:\\n\\nDo not bother about it, as in worst case s1= aaaaa..., s2=aaabaaaaa... we will have to cut at many places.\\n>Q2:  Transition Time\\n\\nSince we will try to cut at various location, will traverse from first letter in a substring, to last letter. Caution: Don\\'t make the substring length 0 both for \\'x\\' and \\'y\\'. Therefore O(n)\\n\\n>Q3:Dp states\\n\\none might think (start1, end1) (start2, end2) which I initially did. so memory would O(n^4) in this case.\\nBut we can come up with better complexity, Note we don\\'t need to define end1, end2 seperately if we have len, ie length of the substring. Since In order match both the substring their length must be equal. \\n\\nSo define a state (start1, start2, len)\\nso memory O(n^3)\\ntime O(n^3) * Transition Time => O(n^4)\\n\\n>Q4 What our dp state Signify\\n\\ndp[start1][start2][len]  means we are trying to see whether part of s1 which is s1.substr(start1, len) is a scramble string of part of s2 which is s2.substr(start2, len).\\nIf it is it will store 1, else 0; If not processed it will have default -1;\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[31][31][31];                                //-1 non processed, 1 matches, 0 not matches\\n    \\n    int fn(int start1, int start2, int len, string&s1, string& s2){\\n        int &res = dp[start1][start2][len];                       //Now res will refer to our current state\\n        \\n        //base case 0\\n        if(len==1){\\n            if(s1[start1]==s2[start2] ) return res = 1;\\n            else return res=0;\\n        }\\n\\t\\t\\n        //base case 1\\n        if(res!=-1) return res;                       //already processed, reuse it\\n\\t\\t\\n        res = 0;\\n        //without swap\\n        for(int i=1; i<len; i++){\\n            int decision = ( fn(start1, start2, i, s1, s2) & fn(start1+i, start2+i, len-i, s1, s2) );     //true only if x and y both matches\\n            res |= decision;\\n        }\\n\\t\\t\\n        //with swap\\n        for(int i=1; i<len; i++){\\n            int decision = fn(start1, start2+len-i, i, s1, s2) & fn(start1+i, start2, len-i, s1, s2);     //true only if y and x matches\\n            res |= decision;\\n        }\\n        return res;\\n\\t\\t\\n    }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp, -1, sizeof(dp) );\\n        return fn(0, 0, s1.size(), s1, s2);\\n    }\\n};\\n```\\n\\nI don\\'t post regularaly; Since I overviewed most voted soln and found it not optimised. So I am posting it.  No need to upvote. ;) Ask issues, I would try to answer.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[31][31][31];                                //-1 non processed, 1 matches, 0 not matches\\n    \\n    int fn(int start1, int start2, int len, string&s1, string& s2){\\n        int &res = dp[start1][start2][len];                       //Now res will refer to our current state\\n        \\n        //base case 0\\n        if(len==1){\\n            if(s1[start1]==s2[start2] ) return res = 1;\\n            else return res=0;\\n        }\\n\\t\\t\\n        //base case 1\\n        if(res!=-1) return res;                       //already processed, reuse it\\n\\t\\t\\n        res = 0;\\n        //without swap\\n        for(int i=1; i<len; i++){\\n            int decision = ( fn(start1, start2, i, s1, s2) & fn(start1+i, start2+i, len-i, s1, s2) );     //true only if x and y both matches\\n            res |= decision;\\n        }\\n\\t\\t\\n        //with swap\\n        for(int i=1; i<len; i++){\\n            int decision = fn(start1, start2+len-i, i, s1, s2) & fn(start1+i, start2, len-i, s1, s2);     //true only if y and x matches\\n            res |= decision;\\n        }\\n        return res;\\n\\t\\t\\n    }\\n    bool isScramble(string s1, string s2) {\\n        memset(dp, -1, sizeof(dp) );\\n        return fn(0, 0, s1.size(), s1, s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301440,
                "title": "java-recursive-progressive-methods",
                "content": "**Method 1:** Brute Force Recursive\\n```\\n/*\\nCondition 1 (original) : (s1 partition 1 is scrambled of s2 partition 1) and (s1 partition 2 is scrambled of s2 partition 2)\\nCondition 2 (flip) : (s1 partition 1 is scrambled of s2 partition 2) and (s1 partition 2 is scrambled of s2 partition 1)\\n */\\npublic boolean isScramble(String s1, String s2) {\\n\\tif (s1.equals(s2))\\n\\t\\treturn true;\\n\\tvar n = s1.length();\\n\\t\\n\\tfor (var i = 1; i < n; i++) {\\n\\t\\tvar original = isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i));\\n\\t\\tif (original)\\n\\t\\t\\treturn true;\\n\\t\\tvar flip = isScramble(s1.substring(0, i), s2.substring(n - i)) && isScramble(s1.substring(i), s2.substring(0, n - i));\\n\\t\\tif (flip)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n**Method 2:** Inject memoization in Method 1\\n```\\npublic boolean isScramble(String s1, String s2) {\\n\\treturn isScramble(s1, s2, new HashMap<>());\\n}\\n\\nprivate boolean isScramble(String s1, String s2, Map<String, Boolean> map) {\\n\\tif (s1.equals(s2))\\n\\t\\treturn true;\\n\\tvar key = s1 + \",\" + s2;\\n\\tif (map.containsKey(key))\\n\\t\\treturn map.get(key);\\n\\tvar n = s1.length();\\n\\tfor (var i = 1; i < n; i++) {\\n\\t\\t// (s1 partition 1 is scrambled of s2 partition 1) and (s1 partition 2 is scrambled of s2 partition 2)\\n\\t\\tvar original = isScramble(s1.substring(0, i), s2.substring(0, i), map) && isScramble(s1.substring(i), s2.substring(i), map);\\n\\t\\tif (original) {\\n\\t\\t\\tmap.put(key, true);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t// (s1 partition 1 is scrambled of s2 partition 2) and (s1 partition 2 is scrambled of s2 partition 1)\\n\\t\\tvar flipCase = isScramble(s1.substring(0, i), s2.substring(n - i), map) && isScramble(s1.substring(i), s2.substring(0, n - i), map);\\n\\t\\tif (flipCase) {\\n\\t\\t\\tmap.put(key, true);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\tmap.put(key, false);\\n\\treturn false;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/*\\nCondition 1 (original) : (s1 partition 1 is scrambled of s2 partition 1) and (s1 partition 2 is scrambled of s2 partition 2)\\nCondition 2 (flip) : (s1 partition 1 is scrambled of s2 partition 2) and (s1 partition 2 is scrambled of s2 partition 1)\\n */\\npublic boolean isScramble(String s1, String s2) {\\n\\tif (s1.equals(s2))\\n\\t\\treturn true;\\n\\tvar n = s1.length();\\n\\t\\n\\tfor (var i = 1; i < n; i++) {\\n\\t\\tvar original = isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i));\\n\\t\\tif (original)\\n\\t\\t\\treturn true;\\n\\t\\tvar flip = isScramble(s1.substring(0, i), s2.substring(n - i)) && isScramble(s1.substring(i), s2.substring(0, n - i));\\n\\t\\tif (flip)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n```\n```\\npublic boolean isScramble(String s1, String s2) {\\n\\treturn isScramble(s1, s2, new HashMap<>());\\n}\\n\\nprivate boolean isScramble(String s1, String s2, Map<String, Boolean> map) {\\n\\tif (s1.equals(s2))\\n\\t\\treturn true;\\n\\tvar key = s1 + \",\" + s2;\\n\\tif (map.containsKey(key))\\n\\t\\treturn map.get(key);\\n\\tvar n = s1.length();\\n\\tfor (var i = 1; i < n; i++) {\\n\\t\\t// (s1 partition 1 is scrambled of s2 partition 1) and (s1 partition 2 is scrambled of s2 partition 2)\\n\\t\\tvar original = isScramble(s1.substring(0, i), s2.substring(0, i), map) && isScramble(s1.substring(i), s2.substring(i), map);\\n\\t\\tif (original) {\\n\\t\\t\\tmap.put(key, true);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\t// (s1 partition 1 is scrambled of s2 partition 2) and (s1 partition 2 is scrambled of s2 partition 1)\\n\\t\\tvar flipCase = isScramble(s1.substring(0, i), s2.substring(n - i), map) && isScramble(s1.substring(i), s2.substring(0, n - i), map);\\n\\t\\tif (flipCase) {\\n\\t\\t\\tmap.put(key, true);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\tmap.put(key, false);\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1277442,
                "title": "javascript-easy-explained-solution",
                "content": "Approach: Intuitive, do what the question asks. \\n\\xA0 \\xA0 We will cut the string s1 from every possible point\\n\\t\\n\\xA0 \\xA0 To do this we will run a loop from start to end\\n\\xA0 \\xA0 \\xA0s1FirstPart = chars from 0 till ith char\\n\\xA0 \\xA0 \\xA0s1SecondPart = chars from i+1 till end\\n\\xA0 \\xA0 \\xA0Then we will match these parts with the same range in s2 if it matches, then the result is true and break the loop\\n\\xA0 \\xA0 \\xA0If it doesn\\'t match then we will try to match the parts of s1 with opposite/reversed parts from s2\\n\\xA0 \\xA0 \\xA0For the second match \\n\\xA0 \\xA0 \\xA0s2FirstPart = last i+1 chars\\n\\xA0 \\xA0 \\xA0s2SecondPart = rest of the chars leaving the last i+1 chars\\n\\xA0 \\xA0 \\xA0Now we will check again if this combination is matching if yes, then the result is true and break the loop\\n\\xA0 \\xA0 \\xA0\\n\\xA0 \\xA0 \\xA0If length of s1 and s2 is 1 then we can check if s1==2 then the result is true else the result is false\\n\\xA0 \\xA0 \\xA0\\n\\t We are also using to cache to avoid processing any to string twice\\n\\t In each call to recursive function \\'match\\' length of s1 and s2 will be same.\\n\\n```\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {boolean}\\n */\\nvar isScramble = function(s1, s2) {\\n    let cache={};\\n    \\n    return match(s1,s2);\\n    \\n    function match(s1,s2){\\n        let res = false;\\n        if(cache[s1+s2]!==undefined){\\n            return cache[s1+s2];\\n        }\\n        if(cache[s2+s1]!==undefined){\\n            return cache[s2+s1];\\n        }\\n        if(s1.length===1){\\n            return s1===s2;\\n        }\\n        let s1FirstPart,s1SecondPart,s2FirstPart,s2SecondPart;\\n        for(let i=0;i<s1.length-1;i++){\\n            s1FirstPart = s1.substring(0,i+1);//first i+1 chars\\n            s1SecondPart = s1.substring(i+1);//rest of the chars\\n            s2FirstPart = s2.substring(0,i+1);//first i+1 chars\\n            s2SecondPart = s2.substring(i+1);//rest of the chars\\n            if(match(s1FirstPart,s2FirstPart) && match(s1SecondPart,s2SecondPart)){\\n                res=true;\\n                break;\\n            }\\n            s2FirstPart = s2.substring(s2.length-1-i);//last i+1 chars\\n            s2SecondPart = s2.substring(0,s2.length-1-i);//rest of the chars\\n            if(match(s1FirstPart,s2FirstPart) && match(s1SecondPart,s2SecondPart)){\\n                res=true;\\n                break;\\n            }\\n        }\\n        cache[s1+s2] = res;\\n        cache[s2+s1] = res\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s1\\n * @param {string} s2\\n * @return {boolean}\\n */\\nvar isScramble = function(s1, s2) {\\n    let cache={};\\n    \\n    return match(s1,s2);\\n    \\n    function match(s1,s2){\\n        let res = false;\\n        if(cache[s1+s2]!==undefined){\\n            return cache[s1+s2];\\n        }\\n        if(cache[s2+s1]!==undefined){\\n            return cache[s2+s1];\\n        }\\n        if(s1.length===1){\\n            return s1===s2;\\n        }\\n        let s1FirstPart,s1SecondPart,s2FirstPart,s2SecondPart;\\n        for(let i=0;i<s1.length-1;i++){\\n            s1FirstPart = s1.substring(0,i+1);//first i+1 chars\\n            s1SecondPart = s1.substring(i+1);//rest of the chars\\n            s2FirstPart = s2.substring(0,i+1);//first i+1 chars\\n            s2SecondPart = s2.substring(i+1);//rest of the chars\\n            if(match(s1FirstPart,s2FirstPart) && match(s1SecondPart,s2SecondPart)){\\n                res=true;\\n                break;\\n            }\\n            s2FirstPart = s2.substring(s2.length-1-i);//last i+1 chars\\n            s2SecondPart = s2.substring(0,s2.length-1-i);//rest of the chars\\n            if(match(s1FirstPart,s2FirstPart) && match(s1SecondPart,s2SecondPart)){\\n                res=true;\\n                break;\\n            }\\n        }\\n        cache[s1+s2] = res;\\n        cache[s2+s1] = res\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1164271,
                "title": "python-complete-solution-and-some-remarks",
                "content": "**This is a basic recursive solution which focuses on the following points.**\\n\\nIn order to solve this problem, we are using Divide and Conquer approach. \\nGiven two strings of equal length (say n+1), S1[0\\u2026n] and S2[0\\u2026n]. If S2 is a scrambled form of S1, then there must exist an index i such that at least one of the following conditions is true: \\n \\n\\nS2[0\\u2026i] is a scrambled string of S1[0\\u2026i] and S2[i+1\\u2026n] is a scrambled string of S1[i+1\\u2026n].\\nS2[0\\u2026i] is a scrambled string of S1[n-i\\u2026n] and S2[i+1\\u2026n] is a scrambled string of S1[0\\u2026n-i-1].\\n\\nAs well as, we check if the strings are anagrams if not, then they can;t be scrambled form of each other.\\n\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if len(s1) != len(s2):\\n            return False\\n        n = len(s1)\\n        if not n:\\n            return True\\n        \\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2):\\n            return False\\n        for i in range(1, n):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])):\\n                return True\\n            if (self.isScramble(s1[-i:], s2[:i]) and self.isScramble(s1[:-i], s2[i:])):\\n                return True\\n        return False\\n\\t\\t#Dp using map\\n\\t``\\n\\tclass Solution:\\n    def __init__(self):\\n        self.dic = {}\\n        \\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if (s1, s2) in self.dic :\\n            return self.dic[(s1, s2)]\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2):\\n            self.dic[(s1, s2)] = False     \\n            return False\\n        n = len(s1)\\n        if s1 == s2:\\n            self.dic[(s1, s2)] = True\\n            return True\\n        \\n        for i in range(1, n):\\n            if (self.isScramble(s1[i:], s2[i:]) and self.isScramble(s1[:\\ni], s2[:i])):\\n                return True\\n            if (self.isScramble(s1[:-i], s2[i:]) and self.isScramble(s1[-i:], s2[:i])):\\n                return True\\n\\t\\t\\tself.dic[(s1, s2)] = False\\n\\t\\t\\treturn False\\n```\\n\\nIf you expected recursive solution to pass all the test cases then brother, you really need to think twice, this solution will definitely fail for long inputs, because of your recursive calls, this code is calculating the same values again and again, and that;s why this takes more time, and TLE will appear for long inputs, **but it\\'s always very good practice to write recursive solution first, for DP problems, this is the key to move ahead.**\\n\\tSo, Now our task is to optimise our recursive solution. The one and only we can improve is the recursive calls, as i said, the function is calculating same values again and agin and therefore more time. Why can\\'t we just the store the values that we\\'ve already calculated and then before calculating the value, we\\'ll check if we\\'ve done it already or not.\\n\\t\\tIf we\\'ve we\\'ll use the values, if not, we\\'ll call the function, and believe me this extra 2 or 3 lines can do wonders to your code. \\n\\t\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if len(s1) != len(s2):\\n            return False\\n        n = len(s1)\\n        if not n:\\n            return True\\n        \\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2):\\n            return False\\n        for i in range(1, n):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])):\\n                return True\\n            if (self.isScramble(s1[-i:], s2[:i]) and self.isScramble(s1[:-i], s2[i:])):\\n                return True\\n        return False\\n\\t\\t#Dp using map\\n\\t``\\n\\tclass Solution:\\n    def __init__(self):\\n        self.dic = {}\\n        \\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if (s1, s2) in self.dic :\\n            return self.dic[(s1, s2)]\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2):\\n            self.dic[(s1, s2)] = False     \\n            return False\\n        n = len(s1)\\n        if s1 == s2:\\n            self.dic[(s1, s2)] = True\\n            return True\\n        \\n        for i in range(1, n):\\n            if (self.isScramble(s1[i:], s2[i:]) and self.isScramble(s1[:\\ni], s2[:i])):\\n                return True\\n            if (self.isScramble(s1[:-i], s2[i:]) and self.isScramble(s1[-i:], s2[:i])):\\n                return True\\n\\t\\t\\tself.dic[(s1, s2)] = False\\n\\t\\t\\treturn False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920384,
                "title": "c-memoisation-bottom-up-dp-runtime-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> dp;\\n    bool isScramble(string s1, string s2){\\n        string key = s1 + \\'_\\' + s2;\\n\\n        if(s1.length() != s2.length())\\n            return false;\\n\\n        if(s1.length() == 0)\\n            return true;\\n\\n        if(s1 == s2)\\n            return true;\\n\\n        if(dp.count(key))\\n            return dp[key];\\n\\n        int a[28] = {0};\\n        for(auto &i:s1)\\n            a[i-\\'a\\']++;\\n\\n        for(auto &i:s2)\\n            a[i-\\'a\\']--;\\n\\n        for(int i = 0; i < 28; i++)\\n            if(a[i] != 0)\\n                return false;\\n\\n        int n = s1.length();\\n        bool flag = false;\\n        for(int i = 1; i < s1.length(); i++){\\n            bool left = isScramble(s1.substr(0, i), s2.substr(n-i, i)) &&\\n                        isScramble(s1.substr(i, n-i), s2.substr(0, n-i));\\n\\n            bool right = isScramble(s1.substr(0, i), s2.substr(0, i)) &&\\n                         isScramble(s1.substr(i, n-i), s2.substr(i, n-i));\\n\\n            if(left || right){\\n                flag = true;\\n                break;\\n            }\\n\\n        }\\n\\n        dp[key] = flag;\\n        return dp[key];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> dp;\\n    bool isScramble(string s1, string s2){\\n        string key = s1 + \\'_\\' + s2;\\n\\n        if(s1.length() != s2.length())\\n            return false;\\n\\n        if(s1.length() == 0)\\n            return true;\\n\\n        if(s1 == s2)\\n            return true;\\n\\n        if(dp.count(key))\\n            return dp[key];\\n\\n        int a[28] = {0};\\n        for(auto &i:s1)\\n            a[i-\\'a\\']++;\\n\\n        for(auto &i:s2)\\n            a[i-\\'a\\']--;\\n\\n        for(int i = 0; i < 28; i++)\\n            if(a[i] != 0)\\n                return false;\\n\\n        int n = s1.length();\\n        bool flag = false;\\n        for(int i = 1; i < s1.length(); i++){\\n            bool left = isScramble(s1.substr(0, i), s2.substr(n-i, i)) &&\\n                        isScramble(s1.substr(i, n-i), s2.substr(0, n-i));\\n\\n            bool right = isScramble(s1.substr(0, i), s2.substr(0, i)) &&\\n                         isScramble(s1.substr(i, n-i), s2.substr(i, n-i));\\n\\n            if(left || right){\\n                flag = true;\\n                break;\\n            }\\n\\n        }\\n\\n        dp[key] = flag;\\n        return dp[key];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776581,
                "title": "c-dp-solution",
                "content": "```\\nunordered_map<string, bool> mp;\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2){\\n        \\n        if(s1.length()!= s2.length())\\n            return false;\\n        \\n        if(s1.length() && s2.length() == 0)\\n            return true;\\n    \\n        if(s1.compare(s2) == 0)\\n            return true;\\n        \\n        if(s1.length() <= 1 || s2.length()<=1)\\n            return false;\\n        \\n        string key = s1;           // string key=s1+\" \"+s2\\n        key.push_back(\\' \\');\\n        key.append(s2);\\n        \\n        if(mp.find(key) != mp.end())\\n            return mp[key];\\n        \\n        int n = s1.length();\\n        \\n        bool flag = false;\\n    \\n        for(int k = 1; k < n; k++){\\n        \\n            bool c1 = (isScramble(s1.substr(0, k),s2.substr(n - k, k)) && isScramble(s1.substr(k, n-k), s2.substr(0, n - k)));\\n            bool c2 = (isScramble(s1.substr(0, k),s2.substr(0, k)) && isScramble(s1.substr(k, n-k), s2.substr(k,n - k)));                                                     \\n        \\n              if(c1 || c2){\\n                 flag = true;\\n                 break;\\n              }\\n        }\\n         return mp[key] = flag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nunordered_map<string, bool> mp;\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2){\\n        \\n        if(s1.length()!= s2.length())\\n            return false;\\n        \\n        if(s1.length() && s2.length() == 0)\\n            return true;\\n    \\n        if(s1.compare(s2) == 0)\\n            return true;\\n        \\n        if(s1.length() <= 1 || s2.length()<=1)\\n            return false;\\n        \\n        string key = s1;           // string key=s1+\" \"+s2\\n        key.push_back(\\' \\');\\n        key.append(s2);\\n        \\n        if(mp.find(key) != mp.end())\\n            return mp[key];\\n        \\n        int n = s1.length();\\n        \\n        bool flag = false;\\n    \\n        for(int k = 1; k < n; k++){\\n        \\n            bool c1 = (isScramble(s1.substr(0, k),s2.substr(n - k, k)) && isScramble(s1.substr(k, n-k), s2.substr(0, n - k)));\\n            bool c2 = (isScramble(s1.substr(0, k),s2.substr(0, k)) && isScramble(s1.substr(k, n-k), s2.substr(k,n - k)));                                                     \\n        \\n              if(c1 || c2){\\n                 flag = true;\\n                 break;\\n              }\\n        }\\n         return mp[key] = flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631223,
                "title": "java-recursion-explanation",
                "content": "Intiution: \\nStep 1:\\nlets take a simpler example:  \"abc\" & \"bac\".  \\nStep 2:\\nabc can be split in the following => {a,bc} {ab, c}\\non swapping the values you can also generate reverse of substrings {bc,a} and {c, ab}  \\n\\nStep 3:\\nAll possible combinations of abc from step-2 are {a,bc} {ab, c} & {bc,a} and {c, ab} \\n\\nStep 4:\\nSimilarly \"bac\" becomes {b, ac} {ba, c} {ac, b} {c, ab}\\n\\nStep 5: \\nTake the Step3 and Step4 results and recursively analyze if any of the combination results in to same string, if it does its success. else its not. \\n\\n\\n\\n\\n\\n\\n\\n````\\nclass Solution {\\n    Map<String, Boolean> memo = new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n                \\n        if(s1.equalsIgnoreCase(s2)) return true;\\n        \\n        String key = s1+\"____\"+s2;\\n        \\n        if(memo.containsKey(key))return memo.get(key);\\n        \\n        boolean answer = false;\\n        for(int i=1;i<s2.length();i++){\\n            \\n            String real_prefix = s1.substring(0, s1.length()-i); //(gr, e)\\n            String real_suffix = s1.substring(s1.length()-i);\\n            \\n            String real_prefix_no_echange = s1.substring(0, i); // (g, re)\\n            String real_suffix_no_echange = s1.substring(i);\\n                        \\n            String prefix = s2.substring(0, i);   // (g, re)\\n            String suffix = s2.substring(i);\\n\\n            boolean noExchange = isScramble(real_prefix, suffix) && isScramble(real_suffix, prefix);\\n            boolean exchange = isScramble(real_prefix_no_echange, prefix) && isScramble(real_suffix_no_echange, suffix);\\n            \\n            \\n            answer = answer || exchange || noExchange;\\n        }\\n        \\n        memo.put(key, answer);\\n        return answer;\\n    }\\n}\\n````\\n\\nO(n^4)",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    Map<String, Boolean> memo = new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n                \\n        if(s1.equalsIgnoreCase(s2)) return true;\\n        \\n        String key = s1+\"____\"+s2;\\n        \\n        if(memo.containsKey(key))return memo.get(key);\\n        \\n        boolean answer = false;\\n        for(int i=1;i<s2.length();i++){\\n            \\n            String real_prefix = s1.substring(0, s1.length()-i); //(gr, e)\\n            String real_suffix = s1.substring(s1.length()-i);\\n            \\n            String real_prefix_no_echange = s1.substring(0, i); // (g, re)\\n            String real_suffix_no_echange = s1.substring(i);\\n                        \\n            String prefix = s2.substring(0, i);   // (g, re)\\n            String suffix = s2.substring(i);\\n\\n            boolean noExchange = isScramble(real_prefix, suffix) && isScramble(real_suffix, prefix);\\n            boolean exchange = isScramble(real_prefix_no_echange, prefix) && isScramble(real_suffix_no_echange, suffix);\\n            \\n            \\n            answer = answer || exchange || noExchange;\\n        }\\n        \\n        memo.put(key, answer);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359319,
                "title": "share-my-notes-of-this-problem",
                "content": "I think this problem is much difficult than other difficult problems . I spend almost one day to find the solution to this problem from brute force to dynamic planing .\\nHere are my solutions :\\n\\n## Solution One  \\n  use recrusive brute foce method(this method will get runtime limit error)\\n```\\n public boolean isScramble(String s1, String s2) {\\n        if(s1.equals(s2)){\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        if(!scrambleEqual(s1,s2)){\\n            return false;\\n        }\\n        for(int i=1;i<s1.length();i++){\\n            String s1L = s1.substring(0,i);\\n            String s1R = s1.substring(i,s1.length());\\n            String s2L = s2.substring(0,i);\\n            String s2R = s2.substring(i,s2.length());\\n            if(isScramble(s1L,s2L) && isScramble(s1R,s2R)){\\n                return true;\\n            }\\n            s2L = s2.substring(s2.length()-i,s2.length());\\n            s2R = s2.substring(0,s2.length()-i);\\n\\n            if(isScramble(s1L,s2L) && isScramble(s1R,s2R)){\\n                return true;\\n            }\\n\\n        }\\n        return false;\\n    }\\n\\n    public boolean scrambleEqual(String s1,String s2){\\n        int[] c = new int[26];\\n        for(int i=0;i<s1.length();i++){\\n            c[s1.charAt(i) - \\'a\\']++;\\n            c[s2.charAt(i) - \\'a\\']--;\\n        }\\n        boolean ans = true;\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0){\\n                return false;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n## Solution Two  \\nuse recursive plus memory method(this solution will alose cause time limit exception . the reason of this is that there still have dumplicate calculation)\\n```\\npublic boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int len = s1.length();\\n        boolean[][][] map = new boolean[len + 1][len + 1][len + 1];\\n        return helper(s1, 0, s2, 0, len, map);\\n    }\\n\\n    public boolean helper(String s1, int i, String s2,int j, int len, boolean[][][] map) {\\n        if (len == 0) { return true; }\\n        if (len == 1 && s1.charAt(i) == s2.charAt(j)) {\\n            map[i][j][len] = true;\\n        }\\n        if (map[i][j][len]) {\\n            return true;\\n        }\\n        for (int k = 1; k < len; k++) {\\n            if (helper(s1, i, s2, j, k, map) && helper(s1, i + k, s2, j + k, len - k, map)) {\\n                return map[i][j][len] = true;\\n            }\\n            if (helper(s1, i, s2, j + len - k, k, map) && helper(s1, i + k, s2, j, len - k, map)) {\\n                return map[i][j][len] = true;\\n            }\\n        }\\n        return map[i][j][len] = false;\\n    }\\n```\\n\\n## Solution Three  \\nfix dumplicate calculation of solution two\\n```\\npublic boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int len = s1.length();\\n        int[][][] map = new int[len + 1][len + 1][len + 1];\\n        return helper(s1, 0, s2, 0, len, map);\\n    }\\n\\n    public boolean helper(String s1, int i, String s2,int j, int len, int[][][] map) {\\n        if (len == 0) { return true; }\\n        if (len == 1 && s1.charAt(i) == s2.charAt(j)) {\\n            map[i][j][len] = 1;\\n        }\\n        if (map[i][j][len]!=0) {\\n            return map[i][j][len]==1;\\n        }\\n        for (int k = 1; k < len; k++) {\\n            if (helper(s1, i, s2, j, k, map) && helper(s1, i + k, s2, j + k, len - k, map)) {\\n                map[i][j][len] = 1;\\n                return true;\\n            }\\n            if (helper(s1, i, s2, j + len - k, k, map) && helper(s1, i + k, s2, j, len - k, map)) {\\n                map[i][j][len] = 1;\\n                return true;\\n            }\\n        }\\n        map[i][j][len] = 2;\\n        return false;\\n    }\\n```\\n\\n## Solution four  \\nchange solution three to dynamic planing\\n```\\n  public boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int n = s1.length();\\n        boolean[][][] dp = new boolean[n + 1][n + 1][n + 1];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j][1] = s1.charAt(i) == s2.charAt(j);\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                for (int j = 0; j <= n - len; j++) {\\n                    for (int k = 1; k <= len; k++) {\\n                        boolean left = dp[i][j][k] && dp[i + k][j + k][len - k];\\n                        boolean right = dp[i][j + len - k][k] && dp[i + k][j][len - k];\\n                        if (left || right) {\\n                            dp[i][j][len] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][0][n];\\n    }\\n```\\n\\n## solution five(final solution)\\nan improve solution of solution four\\n```\\npublic boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int len = s1.length();\\n        boolean[][][] dp = new boolean[len][len][len+1];\\n\\t\\tfor (int k = 1; k <= len; ++k)\\n\\t\\t\\tfor (int i = 0; i + k <= len; ++i)\\n\\t\\t\\t\\tfor (int j = 0; j + k <= len; ++j)\\n\\t\\t\\t\\t\\tif (k == 1)\\n\\t\\t\\t\\t\\t\\tdp[i][j][k] = s1.charAt(i) == s2.charAt(j);\\n\\t\\t\\t\\t\\telse for (int q = 1; q < k && !dp[i][j][k]; ++q) {\\n\\t\\t\\t\\t\\t\\tdp[i][j][k] = (dp[i][j][q] && dp[i + q][j + q][k - q]) || (dp[i][j + k - q][q] && dp[i + q][j][k - q]);\\n\\t\\t\\t\\t\\t}\\n        return dp[0][0][len];\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public boolean isScramble(String s1, String s2) {\\n        if(s1.equals(s2)){\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        if(!scrambleEqual(s1,s2)){\\n            return false;\\n        }\\n        for(int i=1;i<s1.length();i++){\\n            String s1L = s1.substring(0,i);\\n            String s1R = s1.substring(i,s1.length());\\n            String s2L = s2.substring(0,i);\\n            String s2R = s2.substring(i,s2.length());\\n            if(isScramble(s1L,s2L) && isScramble(s1R,s2R)){\\n                return true;\\n            }\\n            s2L = s2.substring(s2.length()-i,s2.length());\\n            s2R = s2.substring(0,s2.length()-i);\\n\\n            if(isScramble(s1L,s2L) && isScramble(s1R,s2R)){\\n                return true;\\n            }\\n\\n        }\\n        return false;\\n    }\\n\\n    public boolean scrambleEqual(String s1,String s2){\\n        int[] c = new int[26];\\n        for(int i=0;i<s1.length();i++){\\n            c[s1.charAt(i) - \\'a\\']++;\\n            c[s2.charAt(i) - \\'a\\']--;\\n        }\\n        boolean ans = true;\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]!=0){\\n                return false;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\npublic boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int len = s1.length();\\n        boolean[][][] map = new boolean[len + 1][len + 1][len + 1];\\n        return helper(s1, 0, s2, 0, len, map);\\n    }\\n\\n    public boolean helper(String s1, int i, String s2,int j, int len, boolean[][][] map) {\\n        if (len == 0) { return true; }\\n        if (len == 1 && s1.charAt(i) == s2.charAt(j)) {\\n            map[i][j][len] = true;\\n        }\\n        if (map[i][j][len]) {\\n            return true;\\n        }\\n        for (int k = 1; k < len; k++) {\\n            if (helper(s1, i, s2, j, k, map) && helper(s1, i + k, s2, j + k, len - k, map)) {\\n                return map[i][j][len] = true;\\n            }\\n            if (helper(s1, i, s2, j + len - k, k, map) && helper(s1, i + k, s2, j, len - k, map)) {\\n                return map[i][j][len] = true;\\n            }\\n        }\\n        return map[i][j][len] = false;\\n    }\\n```\n```\\npublic boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int len = s1.length();\\n        int[][][] map = new int[len + 1][len + 1][len + 1];\\n        return helper(s1, 0, s2, 0, len, map);\\n    }\\n\\n    public boolean helper(String s1, int i, String s2,int j, int len, int[][][] map) {\\n        if (len == 0) { return true; }\\n        if (len == 1 && s1.charAt(i) == s2.charAt(j)) {\\n            map[i][j][len] = 1;\\n        }\\n        if (map[i][j][len]!=0) {\\n            return map[i][j][len]==1;\\n        }\\n        for (int k = 1; k < len; k++) {\\n            if (helper(s1, i, s2, j, k, map) && helper(s1, i + k, s2, j + k, len - k, map)) {\\n                map[i][j][len] = 1;\\n                return true;\\n            }\\n            if (helper(s1, i, s2, j + len - k, k, map) && helper(s1, i + k, s2, j, len - k, map)) {\\n                map[i][j][len] = 1;\\n                return true;\\n            }\\n        }\\n        map[i][j][len] = 2;\\n        return false;\\n    }\\n```\n```\\n  public boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int n = s1.length();\\n        boolean[][][] dp = new boolean[n + 1][n + 1][n + 1];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j][1] = s1.charAt(i) == s2.charAt(j);\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                for (int j = 0; j <= n - len; j++) {\\n                    for (int k = 1; k <= len; k++) {\\n                        boolean left = dp[i][j][k] && dp[i + k][j + k][len - k];\\n                        boolean right = dp[i][j + len - k][k] && dp[i + k][j][len - k];\\n                        if (left || right) {\\n                            dp[i][j][len] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0][0][n];\\n    }\\n```\n```\\npublic boolean isScramble(String s1, String s2) {\\n        if (s1.equals(s2)) {\\n            return true;\\n        }\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n        int len = s1.length();\\n        boolean[][][] dp = new boolean[len][len][len+1];\\n\\t\\tfor (int k = 1; k <= len; ++k)\\n\\t\\t\\tfor (int i = 0; i + k <= len; ++i)\\n\\t\\t\\t\\tfor (int j = 0; j + k <= len; ++j)\\n\\t\\t\\t\\t\\tif (k == 1)\\n\\t\\t\\t\\t\\t\\tdp[i][j][k] = s1.charAt(i) == s2.charAt(j);\\n\\t\\t\\t\\t\\telse for (int q = 1; q < k && !dp[i][j][k]; ++q) {\\n\\t\\t\\t\\t\\t\\tdp[i][j][k] = (dp[i][j][q] && dp[i + q][j + q][k - q]) || (dp[i][j + k - q][q] && dp[i + q][j][k - q]);\\n\\t\\t\\t\\t\\t}\\n        return dp[0][0][len];\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 302507,
                "title": "32ms-python-recursive-solution-faster-than-100",
                "content": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if s1 == s2:\\n            return True\\n        l, a, b, c = len(s1), [], [], []\\n        for i in range(1, l):\\n            bisect.insort(a, s1[i - 1])\\n            bisect.insort(b, s2[-i])\\n            bisect.insort(c, s2[i - 1])\\n            if a == b and self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[0:-i]):\\n                return True\\n            elif a == c and self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if s1 == s2:\\n            return True\\n        l, a, b, c = len(s1), [], [], []\\n        for i in range(1, l):\\n            bisect.insort(a, s1[i - 1])\\n            bisect.insort(b, s2[-i])\\n            bisect.insort(c, s2[i - 1])\\n            if a == b and self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[0:-i]):\\n                return True\\n            elif a == c and self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284076,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public bool IsScramble(string s1, string s2) {\\n        var n = s1.Length;\\n\\n        if (n != s2.Length) {\\n            return false;\\n        }\\n\\n        // check whether they have same letters\\n        var s1CharArray = s1.ToCharArray();\\n        var s2CharArray = s2.ToCharArray();\\n\\n        Array.Sort(s1CharArray);\\n        Array.Sort(s2CharArray);\\n\\n        for (int i = 0; i < s1CharArray.Length; i++) {\\n            if (s1CharArray[i] != s2CharArray[i]) {\\n                return false;\\n            }\\n        }\\n\\n        // DP: s1[i], s2[j], length\\n        var dp = new bool[n, n, n + 1];\\n\\n        // start with len = 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s1[i] == s2[j]) {\\n                    dp[i, j, 1] = true;\\n                }\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n - len + 1; i++) {\\n                for (int j = 0; j < n - len + 1; j++) {\\n                    for (int k = 1; k < len; k++) {\\n                        // (gr eat) or (eat gr)\\n                        if ((dp[i, j, k] && dp[i + k, j + k, len - k]) ||\\n                            (dp[i, j + len - k, k] && dp[i + k, j, len - k])\\n                        ) {\\n                            dp[i, j, len] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0, 0, n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsScramble(string s1, string s2) {\\n        var n = s1.Length;\\n\\n        if (n != s2.Length) {\\n            return false;\\n        }\\n\\n        // check whether they have same letters\\n        var s1CharArray = s1.ToCharArray();\\n        var s2CharArray = s2.ToCharArray();\\n\\n        Array.Sort(s1CharArray);\\n        Array.Sort(s2CharArray);\\n\\n        for (int i = 0; i < s1CharArray.Length; i++) {\\n            if (s1CharArray[i] != s2CharArray[i]) {\\n                return false;\\n            }\\n        }\\n\\n        // DP: s1[i], s2[j], length\\n        var dp = new bool[n, n, n + 1];\\n\\n        // start with len = 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s1[i] == s2[j]) {\\n                    dp[i, j, 1] = true;\\n                }\\n            }\\n        }\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n - len + 1; i++) {\\n                for (int j = 0; j < n - len + 1; j++) {\\n                    for (int k = 1; k < len; k++) {\\n                        // (gr eat) or (eat gr)\\n                        if ((dp[i, j, k] && dp[i + k, j + k, len - k]) ||\\n                            (dp[i, j + len - k, k] && dp[i + k, j, len - k])\\n                        ) {\\n                            dp[i, j, len] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[0, 0, n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257185,
                "title": "in-place-implementation-without-creating-new-string-100-in-both-memory-and-speed",
                "content": "Was able to avoid recreate substring during the recurssion. However the memorization seems have a big perf hit. Anyone find the same and have a good understanding on why is that?\\n\\n![image](https://assets.leetcode.com/users/liyun1988/image_1552846961.png)\\n\\n\\nI have tested with memorization. once memorization is added the entire execution time would be degraded. Does anyone experience the same? \\n\\n```\\n public boolean isScramble(String s1, String s2) {\\n        if((s1 == null || s1.length() == 0) && (s2 == null || s2.length() == 0)) {\\n            return true;\\n        }\\n        \\n        if((s1 == null || s1.length() == 0) || (s2 == null || s2.length() == 0)) {\\n            return false;\\n        }\\n        \\n        if(s1.length() != s2.length()) {\\n            return false;\\n        }\\n        \\n        // HashMap<String, Boolean> isScrambles = new HashMap<>();\\n        return isScramble_withoutMemorization(s1, 0, s1.length() - 1, s2, 0, s2.length() - 1);\\n    }\\n    \\n    private boolean isScramble_withoutMemorization(String s1, int left1, int right1, String s2, int left2, int right2) {\\n        if(left1 > right1) {\\n            // same applies to left2 and right2.\\n            return true;\\n        }\\n        \\n        if(left1 == right1) {\\n            // same for left2 and right2.\\n            return s1.charAt(left1) == s2.charAt(left2);\\n        }\\n        \\n        /*\\n        String key = getKey(s1, left1, right1, s2, left2, right2);\\n        if(isScrambles.containsKey(key)) {\\n            return isScrambles.get(key);\\n        }\\n        */\\n        \\n        if(!isPermutation(s1, left1, right1, s2, left2, right2)) {\\n            // permutation is necessary but not sufficient\\n            //isScrambles.put(key, false);\\n            return false;\\n        }\\n        \\n        for(int k = 0; k < right1 - left1; ++k) {\\n            if((isScramble_withoutMemorization(s1, left1, left1 + k, s2, left2, left2 + k) \\n                  && isScramble_withoutMemorization(s1, left1 + k + 1, right1, s2, left2 + k + 1, right2))\\n               || (isScramble_withoutMemorization(s1, left1, left1 + k, s2, right2 - k, right2)\\n                  && isScramble_withoutMemorization(s1,left1 + k + 1, right1, s2, left2, right2 - k - 1))) {\\n                //isScrambles.put(key, true);\\n                return true;\\n            }\\n        }\\n        \\n        //isScrambles.put(key, false);\\n        return false;\\n    }\\n    \\n    private boolean isPermutation(String s1, int left1, int right1, String s2, int left2, int right2) {\\n        int[] counts = new int[26];\\n        for(int i = 0; i <= right1 - left1; ++i) {\\n            ++counts[s1.charAt(left1 + i) - \\'a\\'];\\n            --counts[s2.charAt(left2 + i) -\\'a\\'];\\n        }\\n        \\n        for (int i= 0;i<26;i++) {\\n            if (counts[i] != 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private String getKey(String s1, int left1, int right1, String s2, int left2, int right2) {\\n        StringBuilder sb = new StringBuilder(right1 - left1 + 1 + right2 - left2 + 1);\\n        for(int i = left1; i <= right1; ++i) {\\n            sb.append(s1.charAt(i));\\n        }\\n        \\n        for(int i = left2; i <= right2; ++i) {\\n            sb.append(s2.charAt(i));\\n        }\\n        \\n        return new String(sb);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public boolean isScramble(String s1, String s2) {\\n        if((s1 == null || s1.length() == 0) && (s2 == null || s2.length() == 0)) {\\n            return true;\\n        }\\n        \\n        if((s1 == null || s1.length() == 0) || (s2 == null || s2.length() == 0)) {\\n            return false;\\n        }\\n        \\n        if(s1.length() != s2.length()) {\\n            return false;\\n        }\\n        \\n        // HashMap<String, Boolean> isScrambles = new HashMap<>();\\n        return isScramble_withoutMemorization(s1, 0, s1.length() - 1, s2, 0, s2.length() - 1);\\n    }\\n    \\n    private boolean isScramble_withoutMemorization(String s1, int left1, int right1, String s2, int left2, int right2) {\\n        if(left1 > right1) {\\n            // same applies to left2 and right2.\\n            return true;\\n        }\\n        \\n        if(left1 == right1) {\\n            // same for left2 and right2.\\n            return s1.charAt(left1) == s2.charAt(left2);\\n        }\\n        \\n        /*\\n        String key = getKey(s1, left1, right1, s2, left2, right2);\\n        if(isScrambles.containsKey(key)) {\\n            return isScrambles.get(key);\\n        }\\n        */\\n        \\n        if(!isPermutation(s1, left1, right1, s2, left2, right2)) {\\n            // permutation is necessary but not sufficient\\n            //isScrambles.put(key, false);\\n            return false;\\n        }\\n        \\n        for(int k = 0; k < right1 - left1; ++k) {\\n            if((isScramble_withoutMemorization(s1, left1, left1 + k, s2, left2, left2 + k) \\n                  && isScramble_withoutMemorization(s1, left1 + k + 1, right1, s2, left2 + k + 1, right2))\\n               || (isScramble_withoutMemorization(s1, left1, left1 + k, s2, right2 - k, right2)\\n                  && isScramble_withoutMemorization(s1,left1 + k + 1, right1, s2, left2, right2 - k - 1))) {\\n                //isScrambles.put(key, true);\\n                return true;\\n            }\\n        }\\n        \\n        //isScrambles.put(key, false);\\n        return false;\\n    }\\n    \\n    private boolean isPermutation(String s1, int left1, int right1, String s2, int left2, int right2) {\\n        int[] counts = new int[26];\\n        for(int i = 0; i <= right1 - left1; ++i) {\\n            ++counts[s1.charAt(left1 + i) - \\'a\\'];\\n            --counts[s2.charAt(left2 + i) -\\'a\\'];\\n        }\\n        \\n        for (int i= 0;i<26;i++) {\\n            if (counts[i] != 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private String getKey(String s1, int left1, int right1, String s2, int left2, int right2) {\\n        StringBuilder sb = new StringBuilder(right1 - left1 + 1 + right2 - left2 + 1);\\n        for(int i = left1; i <= right1; ++i) {\\n            sb.append(s1.charAt(i));\\n        }\\n        \\n        for(int i = left2; i <= right2; ++i) {\\n            sb.append(s2.charAt(i));\\n        }\\n        \\n        return new String(sb);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201049,
                "title": "doubt-in-one-of-the-test-cases",
                "content": "Input:\\n\"abb\"\\n\"bab\"\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nHow is this a valid case ?\\nShould\\'nt the tree for abb look something like this \\n\\n\\t  abb\\n\\t\\t/\\\\\\n\\t   /  \\\\\\n\\t  a   bb\\n\\t\\t\\t/\\\\\\n\\t\\t   /  \\\\\\n\\t\\t b    b\\n\\t\\t \\nIn such a case we will never have bab as a valid swapped string right ? This is the 93rd test case and I am stuck on it. Can someone please clarify ?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 168869,
                "title": "python-6-lines-short-dfs-and-a-super-slow-dp-solution",
                "content": "Base case: if s1 == s2, then return True, if the s1 is not a permutation of s2, then return False (we can check this by comparing `sorted(s1)` and `sorted(s2)`.\\n\\nOtherwise, we recursively check to see each part of string seperation are scramble or not. Specifically, for `i = 1->len(s1)` we check `isScramble(s1[:i], s2[:i])` and `isScramble(s1[i:], s2[i:])`, if so then return True (e.g, `great`, and `rgeat`). Also we need to check if `isScramble(s1[:i], s2[-i:])` and `isScramble(s1[i:], s2[:-i])` (e.g, `great`, `eatgr`), if so also return True. \\n\\n```python\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if s1 == s2:return True\\n        if sorted(s1) != sorted(s2):return False\\n        for i in range(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                return True\\n        return False\\n```\\n\\nAdding memorization would also speed up the code by a little bit.\\n\\n```python\\nclass Solution(object):\\n    \\n    mem = {}\\n    \\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if (s1, s2) in self.mem:return self.mem[(s1, s2)]\\n        if s1 == s2:return True\\n        if sorted(s1) != sorted(s2):return False\\n        res = False\\n        for i in range(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                res = True\\n                break\\n        self.mem[(s1, s2)] = res\\n        return res\\n```\\n\\nI feel writing code with DFS instead of DP is much easier .. however I do not know how to analyze the time complexity of it. Would appreciate if anyone can give some hint.  \\n\\nJust FYI, here is the standard fill-table DP solution. Super slow though.\\n\\n```python\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if len(s1) != len(s2):\\n            return False\\n        n = len(s1)\\n        dp = [[[False for _ in range(n+1)] for _ in range(n)] for _ in range(n)]\\n        for k in range(n+1):\\n            for i in range(n):\\n                for j in range(n):\\n                    if k == 0:\\n                        dp[i][j][k] = True\\n                        continue\\n                    if k == 1:\\n                        dp[i][j][k] = s1[i] == s2[j]\\n                        continue\\n                    if i + k > n or j + k > n:\\n                        continue\\n                    for p in range(1, k):\\n                        dp[i][j][k] |= dp[i][j][p] and dp[i+p][j+p][k-p]\\n                        dp[i][j][k] |= dp[i][j+p][k-p] and dp[i+k-p][j][p]\\n        return dp[0][0][n]\\n                        \\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if s1 == s2:return True\\n        if sorted(s1) != sorted(s2):return False\\n        for i in range(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                return True\\n        return False\\n```\n```python\\nclass Solution(object):\\n    \\n    mem = {}\\n    \\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if (s1, s2) in self.mem:return self.mem[(s1, s2)]\\n        if s1 == s2:return True\\n        if sorted(s1) != sorted(s2):return False\\n        res = False\\n        for i in range(1, len(s1)):\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\\n                res = True\\n                break\\n        self.mem[(s1, s2)] = res\\n        return res\\n```\n```python\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if len(s1) != len(s2):\\n            return False\\n        n = len(s1)\\n        dp = [[[False for _ in range(n+1)] for _ in range(n)] for _ in range(n)]\\n        for k in range(n+1):\\n            for i in range(n):\\n                for j in range(n):\\n                    if k == 0:\\n                        dp[i][j][k] = True\\n                        continue\\n                    if k == 1:\\n                        dp[i][j][k] = s1[i] == s2[j]\\n                        continue\\n                    if i + k > n or j + k > n:\\n                        continue\\n                    for p in range(1, k):\\n                        dp[i][j][k] |= dp[i][j][p] and dp[i+p][j+p][k-p]\\n                        dp[i][j][k] |= dp[i][j+p][k-p] and dp[i+k-p][j][p]\\n        return dp[0][0][n]\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 29421,
                "title": "1-liner-in-python-88ms-with-an-optimization-note",
                "content": "```\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        return s1==s2 or sorted(s1)==sorted(s2) and any(self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]) or self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]) for i in range(1, len(s1)))\\n```\\n\\nWhich is equivalent to:\\n\\n```\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2):\\n            return False\\n        for i in range(1, len(s1)):\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                return True\\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\\n                return True\\n        return False\\n```\\n\\nI noticed for shorter strings (which is the case here, but not in problem 242 Valid Anagram), sorted(s1) != sorted(s2) is much faster than collections.Counter(s1) != collections.Counter(s2)\\n\\nWhat do you guys think? @StefanPochmann",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        return s1==s2 or sorted(s1)==sorted(s2) and any(self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]) or self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]) for i in range(1, len(s1)))\\n```\n```\\nclass Solution(object):\\n    def isScramble(self, s1, s2):\\n        \"\"\"\\n        :type s1: str\\n        :type s2: str\\n        :rtype: bool\\n        \"\"\"\\n        if s1 == s2:\\n            return True\\n        if sorted(s1) != sorted(s2):\\n            return False\\n        for i in range(1, len(s1)):\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                return True\\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29433,
                "title": "7ms-ac-simple-java-no-dp-no-sort-no-count-no-hashtable-with-a-speed-up-trick",
                "content": "The trick is to do the shorter sub string first, hoping it fails quickly and avoid doing the longer one.\\n\\n    boolean isit(char[] s1, char[] s2, int b1, int e1, int b2, int e2) {\\n        int len = e1-b1;\\n        if (1 == len) return s1[b1] == s2[b2];\\n        for (int n = 1; n <= len/2; ++n) {\\n            if (isit(s1, s2, b1, b1+n, b2, b2+n) && isit(s1, s2, b1+n, e1, b2+n, e2)) return true;\\n            if (isit(s1, s2, b1, b1+n, e2-n, e2) && isit(s1, s2, b1+n, e1, b2, e2-n)) return true;\\n            if (n == len-n) continue;\\n            if (isit(s1, s2, e1-n, e1, b2, b2+n) && isit(s1, s2, b1, e1-n, b2+n, e2)) return true;\\n            if (isit(s1, s2, e1-n, e1, e2-n, e2) && isit(s1, s2, b1, e1-n, b2, e2-n)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean isScramble(String s1, String s2) {\\n        return isit(s1.toCharArray(), s2.toCharArray(), 0, s1.length(), 0, s2.length());\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The trick is to do the shorter sub string first, hoping it fails quickly and avoid doing the longer one.\\n\\n    boolean isit(char[] s1, char[] s2, int b1, int e1, int b2, int e2) {\\n        int len = e1-b1;\\n        if (1 == len) return s1[b1] == s2[b2];\\n        for (int n = 1; n <= len/2; ++n) {\\n            if (isit(s1, s2, b1, b1+n, b2, b2+n) && isit(s1, s2, b1+n, e1, b2+n, e2)) return true;\\n            if (isit(s1, s2, b1, b1+n, e2-n, e2) && isit(s1, s2, b1+n, e1, b2, e2-n)) return true;\\n            if (n == len-n) continue;\\n            if (isit(s1, s2, e1-n, e1, b2, b2+n) && isit(s1, s2, b1, e1-n, b2+n, e2)) return true;\\n            if (isit(s1, s2, e1-n, e1, e2-n, e2) && isit(s1, s2, b1, e1-n, b2, e2-n)) return true;\\n        }\\n        return false;\\n    }\\n    public boolean isScramble(String s1, String s2) {\\n        return isit(s1.toCharArray(), s2.toCharArray(), 0, s1.length(), 0, s2.length());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 29468,
                "title": "my-c-accepted-solution-in-6ms-little-change-in-normal-solution",
                "content": "i read some solutions, usually we will check every location [i] in s1 and s2 to see if they are splinted there.\\nIn that case, the process of [0~i] will be done when processing [i+1].\\nOn the other hand(is this sentence implies me Chinese ? 23333), s1 and s2 is scramble only in two ways:\\n\\n1. -----******** and -----********\\n\\n2. -----******** and ********-----\\n\\n so i check this and do recursion and resulting in 6ms\\n\\nhere is the code\\n\\n    bool work(string s1, string s2){\\n            // special case\\n            int len=s1.length();\\n            if(len==0 || s1==s2) return true;\\n            if(len==1 && s1!=s2) return false;\\n            if(len==2 && s1[0]==s2[1] && s1[1]==s2[0]) return true;\\n            \\n            // check for case s1 and s2 are divided as  -----******** and -----********\\n            // cnt stores the number of none zero numbers\\n            int sum[200],cnt=0,i;\\n            memset(sum,0,sizeof(sum));\\n            for(i=0;i<len;i++){\\n                sum[s1[i]]++;\\n                if(sum[s1[i]]==0) cnt--;\\n                else if(sum[s1[i]]==1) cnt++;\\n                \\n                sum[s2[i]]--;\\n                if(sum[s2[i]]==0) cnt--;\\n                else if(sum[s2[i]]==-1) cnt++;\\n                \\n                if(cnt==0) break;\\n            }\\n            \\n            i++;\\n            if(i<len && work(s1.substr(0,i),s2.substr(0,i)) && work(s1.substr(i),s2.substr(i)) ) return true;\\n            \\n            // check for case s1 and s2 are divided as  -----******** and ********_____\\n            memset(sum,0,sizeof(sum));\\n            cnt=0;\\n            for(i=0;i<len;i++){\\n                sum[s1[i]]++;\\n                if(sum[s1[i]]==0) cnt--;\\n                else if(sum[s1[i]]==1) cnt++;\\n                \\n                sum[s2[len-1-i]]--;\\n                if(sum[s2[len-1-i]]==0) cnt--;\\n                else if(sum[s2[len-1-i]]==-1) cnt++;\\n                \\n                if(cnt==0) break;\\n            }\\n            \\n            i++;\\n            if(i<len && work(s1.substr(0,i),s2.substr(len-i)) && work(s1.substr(i),s2.substr(0,len-i))) return true;\\n            \\n            return false;\\n        }\\n        bool isScramble(string s1, string s2) {\\n            int len=s1.length();\\n            int sum[200],i;\\n            memset(sum,0,sizeof(sum));\\n            for(i=0;i<len;i++){\\n                sum[s1[i]]++;\\n                sum[s2[i]]--;\\n            }\\n            for(i=0;i<200;i++)\\n            if(sum[i]!=0) return false;\\n            \\n            return work(s1,s2);\\n        }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "i read some solutions, usually we will check every location [i] in s1 and s2 to see if they are splinted there.\\nIn that case, the process of [0~i] will be done when processing [i+1].\\nOn the other hand(is this sentence implies me Chinese ? 23333), s1 and s2 is scramble only in two ways:\\n\\n1. -----******** and -----********\\n\\n2. -----******** and ********-----\\n\\n so i check this and do recursion and resulting in 6ms\\n\\nhere is the code\\n\\n    bool work(string s1, string s2){\\n            // special case\\n            int len=s1.length();\\n            if(len==0 || s1==s2) return true;\\n            if(len==1 && s1!=s2) return false;\\n            if(len==2 && s1[0]==s2[1] && s1[1]==s2[0]) return true;\\n            \\n            // check for case s1 and s2 are divided as  -----******** and -----********\\n            // cnt stores the number of none zero numbers\\n            int sum[200],cnt=0,i;\\n            memset(sum,0,sizeof(sum));\\n            for(i=0;i<len;i++){\\n                sum[s1[i]]++;\\n                if(sum[s1[i]]==0) cnt--;\\n                else if(sum[s1[i]]==1) cnt++;\\n                \\n                sum[s2[i]]--;\\n                if(sum[s2[i]]==0) cnt--;\\n                else if(sum[s2[i]]==-1) cnt++;\\n                \\n                if(cnt==0) break;\\n            }\\n            \\n            i++;\\n            if(i<len && work(s1.substr(0,i),s2.substr(0,i)) && work(s1.substr(i),s2.substr(i)) ) return true;\\n            \\n            // check for case s1 and s2 are divided as  -----******** and ********_____\\n            memset(sum,0,sizeof(sum));\\n            cnt=0;\\n            for(i=0;i<len;i++){\\n                sum[s1[i]]++;\\n                if(sum[s1[i]]==0) cnt--;\\n                else if(sum[s1[i]]==1) cnt++;\\n                \\n                sum[s2[len-1-i]]--;\\n                if(sum[s2[len-1-i]]==0) cnt--;\\n                else if(sum[s2[len-1-i]]==-1) cnt++;\\n                \\n                if(cnt==0) break;\\n            }\\n            \\n            i++;\\n            if(i<len && work(s1.substr(0,i),s2.substr(len-i)) && work(s1.substr(i),s2.substr(0,len-i))) return true;\\n            \\n            return false;\\n        }\\n        bool isScramble(string s1, string s2) {\\n            int len=s1.length();\\n            int sum[200],i;\\n            memset(sum,0,sizeof(sum));\\n            for(i=0;i<len;i++){\\n                sum[s1[i]]++;\\n                sum[s2[i]]--;\\n            }\\n            for(i=0;i<200;i++)\\n            if(sum[i]!=0) return false;\\n            \\n            return work(s1,s2);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3614569,
                "title": "aditya-verma-approach-recursive-memoization",
                "content": "\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    unordered_map<string, bool> mp;\\n    bool isScramble(string s1, string s2)\\n    {\\n        int n = s1.size();\\n        if (n != s2.size())\\n            return false;\\n        if (s1.compare(s2) == 0)\\n            return true;\\n        if (mp.find(s1 + \" \" + s2) != mp.end())\\n            return mp[s1 + \" \" + s2];\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\\n                return mp[s1 + \" \" + s2] = true;\\n            if (isScramble(s1.substr(0, i), s2.substr(n - i)) && isScramble(s1.substr(i), s2.substr(0, n - i)))\\n                return mp[s1 + \" \" + s2] = true;\\n        }\\n        return mp[s1 + \" \" + s2] = false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    unordered_map<string, bool> mp;\\n    bool isScramble(string s1, string s2)\\n    {\\n        int n = s1.size();\\n        if (n != s2.size())\\n            return false;\\n        if (s1.compare(s2) == 0)\\n            return true;\\n        if (mp.find(s1 + \" \" + s2) != mp.end())\\n            return mp[s1 + \" \" + s2];\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\\n                return mp[s1 + \" \" + s2] = true;\\n            if (isScramble(s1.substr(0, i), s2.substr(n - i)) && isScramble(s1.substr(i), s2.substr(0, n - i)))\\n                return mp[s1 + \" \" + s2] = true;\\n        }\\n        return mp[s1 + \" \" + s2] = false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3360312,
                "title": "python-shortest-2-liner-dp-functional-programming",
                "content": "# Approach\\nTL;DR, Same as [Editorial solution](https://leetcode.com/problems/scramble-string/editorial/) but written in a functional way.\\n\\n# Complexity\\n- Time complexity: $$O(n^4)$$\\n\\n- Space complexity: $$O(n^3)$$\\n\\nwhere, `n is length of s1 or s2`.\\n\\n# Code\\n2-liner (Not readable):\\n```python\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def is_scramble(i: int, j: int, n: int) -> bool: return any((is_scramble(i, j, k) and is_scramble(i + k, j + k, n - k)) or (is_scramble(i, j + n - k, k) and is_scramble(i + k, j, n - k)) for k in range(1, n)) if n > 1 else s1[i] == s2[j]\\n        return is_scramble(0, 0, len(s1))\\n\\n\\n```\\nMulti-liner (More Readable):\\n```python\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def is_scramble(i: int, j: int, n: int) -> bool:            \\n            return any(\\n                (is_scramble(i, j        , k) and is_scramble(i + k, j + k, n - k)) or\\n                (is_scramble(i, j + n - k, k) and is_scramble(i + k, j    , n - k))\\n                for k in range(1, n)\\n            ) if n > 1 else s1[i] == s2[j]\\n        \\n        return is_scramble(0, 0, len(s1))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def is_scramble(i: int, j: int, n: int) -> bool: return any((is_scramble(i, j, k) and is_scramble(i + k, j + k, n - k)) or (is_scramble(i, j + n - k, k) and is_scramble(i + k, j, n - k)) for k in range(1, n)) if n > 1 else s1[i] == s2[j]\\n        return is_scramble(0, 0, len(s1))\\n\\n\\n```\n```python\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        @cache\\n        def is_scramble(i: int, j: int, n: int) -> bool:            \\n            return any(\\n                (is_scramble(i, j        , k) and is_scramble(i + k, j + k, n - k)) or\\n                (is_scramble(i, j + n - k, k) and is_scramble(i + k, j    , n - k))\\n                for k in range(1, n)\\n            ) if n > 1 else s1[i] == s2[j]\\n        \\n        return is_scramble(0, 0, len(s1))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360256,
                "title": "memoization-dp-c",
                "content": "```\\nclass Solution {\\n    bool dfs(string s, string t, unordered_map<string, bool> &dp) {\\n        if(s == t) return true;\\n        if(dp.find(s + \" \" + t) != dp.end()) return dp[s + \" \" + t];\\n\\n        int n = s.size();\\n        for(int k=1; k<n; k++) {\\n            bool notswap = dfs(s.substr(0, k), t.substr(0, k), dp) && dfs(s.substr(k), t.substr(k), dp);\\n            bool swap = dfs(s.substr(0, k), t.substr(n - k), dp) && dfs(s.substr(k), t.substr(0, n - k), dp);\\n            if(swap || notswap) return dp[s + \" \" + t] = true;\\n        }\\n        return dp[s + \" \" + t] = false;\\n    }\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string, bool> dp;\\n        return dfs(s1, s2, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    bool dfs(string s, string t, unordered_map<string, bool> &dp) {\\n        if(s == t) return true;\\n        if(dp.find(s + \" \" + t) != dp.end()) return dp[s + \" \" + t];\\n\\n        int n = s.size();\\n        for(int k=1; k<n; k++) {\\n            bool notswap = dfs(s.substr(0, k), t.substr(0, k), dp) && dfs(s.substr(k), t.substr(k), dp);\\n            bool swap = dfs(s.substr(0, k), t.substr(n - k), dp) && dfs(s.substr(k), t.substr(0, n - k), dp);\\n            if(swap || notswap) return dp[s + \" \" + t] = true;\\n        }\\n        return dp[s + \" \" + t] = false;\\n    }\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string, bool> dp;\\n        return dfs(s1, s2, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360121,
                "title": "c-solution-using-memoization",
                "content": "\\nclass Solution {\\npublic:\\n\\n    bool isScramblee(string s1, string s2, unordered_map<string,bool>&mpp) {\\n        if(s1.compare(s2)==0){\\n            return true;\\n        }\\n        if(s1.length()<=1){\\n            return false;\\n        }\\n       \\n        string key=s1;\\n        key.push_back(\\' \\');\\n        key.append(s2);\\n        if(mpp.find(key)!=mpp.end()){\\n            return mpp[key];\\n        }\\n        int n=s1.size();\\n         bool flag=false;\\n        for(int i=1; i<=n-1; i++){\\n            bool cond1=isScramblee(s1.substr(0,i), s2.substr(n-i,i), mpp)&& isScramblee(s1.substr(i,n-1), s2.substr(0,n-i), mpp);\\n            bool cond2=isScramblee(s1.substr(0,i), s2.substr(0,i), mpp)&& isScramblee(s1.substr(i,n-i), s2.substr(i,n-i), mpp);\\n            if(cond1||cond2){\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return mpp[key]=flag;\\n    }\\n    bool isScramble(string s1, string s2){\\n        unordered_map<string, bool> mpp;\\n        int n=s1.size();\\n        return isScramblee(s1,s2,mpp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isScramblee(string s1, string s2, unordered_map<string,bool>&mpp) {\\n        if(s1.compare(s2)==0){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3359916,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> mp;\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.size();\\n        if(s1 == s2) return true;   \\n        if(n == 1) return false;\\n        string key = s1+\" \"+s2;\\n        if(mp.find(key)!=mp.end()) return mp[key];\\n        for(int i=1; i<n; i++) {\\n            if(isScramble(s1.substr(0, i), s2.substr(0, i)) and isScramble(s1.substr(i), s2.substr(i)))\\n                return mp[key] = true;\\n            if(isScramble(s1.substr(0, i), s2.substr(n - i)) and isScramble(s1.substr(i), s2.substr(0, n-i)))\\n                return mp[key] = true;\\n        }\\n        return mp[key] = false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> mp;\\n    bool isScramble(string s1, string s2) {\\n        int n = s1.size();\\n        if(s1 == s2) return true;   \\n        if(n == 1) return false;\\n        string key = s1+\" \"+s2;\\n        if(mp.find(key)!=mp.end()) return mp[key];\\n        for(int i=1; i<n; i++) {\\n            if(isScramble(s1.substr(0, i), s2.substr(0, i)) and isScramble(s1.substr(i), s2.substr(i)))\\n                return mp[key] = true;\\n            if(isScramble(s1.substr(0, i), s2.substr(n - i)) and isScramble(s1.substr(i), s2.substr(0, n-i)))\\n                return mp[key] = true;\\n        }\\n        return mp[key] = false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359519,
                "title": "beginner-friendly-easy-recursion-dp-memoization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe will break our main string into all possible outcomes ==>>\\ni.e abc ==>> a bc or ab c\\nthen we will try to swap positions of those parts and check all possible outcomes, hence we will use dp (memoizaiton) for that;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmemoization\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[30][30][30][30];\\n    bool helper(string one, string two, int i1, int j1, int i2, int j2){\\n        if(dp[i1][j1][i2][j2] != -1) return dp[i1][j1][i2][j2];\\n        bool counter = true;\\n        for(int i = i1, j = i2; i <= j1 && j <= j2; i++, j++){\\n            if(one[i] != two[j]) counter = false;\\n        }\\n        if(counter) return dp[i1][j1][i2][j2] = true;\\n        for(int i = i1; i < j1; i++){\\n            if(helper(one, two, i1, i, j2 - (i - i1), j2) && helper(one, two, i + 1, j1, i2, j2 - (i - i1) - 1)) return dp[i1][j1][i2][j2] = true;\\n            if(helper(one, two, i1, i, i2, i2 + (i - i1)) && helper(one, two, i + 1, j1, i2 + (i - i1) + 1, j2)) return dp[i1][j1][i2][j2] = true;\\n        }\\n        return dp[i1][j1][i2][j2] = false;\\n    }\\n\\n    bool isScramble(string s1, string s2) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(s1, s2, 0, s1.size() - 1, 0, s2.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[30][30][30][30];\\n    bool helper(string one, string two, int i1, int j1, int i2, int j2){\\n        if(dp[i1][j1][i2][j2] != -1) return dp[i1][j1][i2][j2];\\n        bool counter = true;\\n        for(int i = i1, j = i2; i <= j1 && j <= j2; i++, j++){\\n            if(one[i] != two[j]) counter = false;\\n        }\\n        if(counter) return dp[i1][j1][i2][j2] = true;\\n        for(int i = i1; i < j1; i++){\\n            if(helper(one, two, i1, i, j2 - (i - i1), j2) && helper(one, two, i + 1, j1, i2, j2 - (i - i1) - 1)) return dp[i1][j1][i2][j2] = true;\\n            if(helper(one, two, i1, i, i2, i2 + (i - i1)) && helper(one, two, i + 1, j1, i2 + (i - i1) + 1, j2)) return dp[i1][j1][i2][j2] = true;\\n        }\\n        return dp[i1][j1][i2][j2] = false;\\n    }\\n\\n    bool isScramble(string s1, string s2) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(s1, s2, 0, s1.size() - 1, 0, s2.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358472,
                "title": "q87-accepted-c-dp-top-down-rec-memoization-simplest",
                "content": "Top-Down Approach (Recursion + Stored Values)\\nCRUX:\\n1) Considering the given Condition to be a Scrambled String.\\n2) Non-empty nodes.\\n3) Swapping Considering.\\n4) Without Swapping\\n```\\nclass Solution {\\npublic:\\n    bool solve(string a, string b,unordered_map <string,bool> &mp){\\n        if(a==b) // Base Condition which are possible\\n            return true;  \\n        int n=a.size();\\n        if(n<=1)\\n            return false;\\n\\t\\n        string s=a;\\n        s+=b;\\n        if(mp.find(s)!=mp.end())\\n            return mp[s]; //If already present then return the previously calculated bool Value\\n        bool flag=false;\\n        for(int i=1;i<=n-1;i++){\\n            bool c1=(solve(a.substr(0,i),b.substr(n-i,i),mp) && \\n                     solve(a.substr(i,n-i),b.substr(0,n-i),mp)); // Considering Swapping\\n            bool c2=(solve(a.substr(0,i),b.substr(0,i),mp) && \\n                     solve(a.substr(i,n-i),b.substr(i,n-i),mp)); // Not considering Swapping\\n            if(c1 || c2){ // If any of the Condition 1 OR 2 is TRUE return TRUE else return FALSE\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return mp[s]=flag; // Storing the value of \"s\" = a+b  \\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1==s2)\\n            return true; //No Need to check\\n        unordered_map <string,bool> mp; // To store the various string\\'s that are generated\\n        return solve(s1,s2,mp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(string a, string b,unordered_map <string,bool> &mp){\\n        if(a==b) // Base Condition which are possible\\n            return true;  \\n        int n=a.size();\\n        if(n<=1)\\n            return false;\\n\\t\\n        string s=a;\\n        s+=b;\\n        if(mp.find(s)!=mp.end())\\n            return mp[s]; //If already present then return the previously calculated bool Value\\n        bool flag=false;\\n        for(int i=1;i<=n-1;i++){\\n            bool c1=(solve(a.substr(0,i),b.substr(n-i,i),mp) && \\n                     solve(a.substr(i,n-i),b.substr(0,n-i),mp)); // Considering Swapping\\n            bool c2=(solve(a.substr(0,i),b.substr(0,i),mp) && \\n                     solve(a.substr(i,n-i),b.substr(i,n-i),mp)); // Not considering Swapping\\n            if(c1 || c2){ // If any of the Condition 1 OR 2 is TRUE return TRUE else return FALSE\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return mp[s]=flag; // Storing the value of \"s\" = a+b  \\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if(s1==s2)\\n            return true; //No Need to check\\n        unordered_map <string,bool> mp; // To store the various string\\'s that are generated\\n        return solve(s1,s2,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358230,
                "title": "ruby-memoization",
                "content": "\\n# Code\\n```\\ndef is_scramble(s1, s2)\\n  memo = {}\\n  memo_is_scramble(s1, s2, memo)\\nend\\n\\ndef memo_is_scramble(s1, s2, memo = {})\\n  return true if s1 == s2\\n  return false if s1.length != s2.length\\n  \\n  return memo[[s1, s2]] if memo.key?([s1, s2])\\n  \\n  count = Array.new(26, 0)\\n  (0...s1.length).each do |i|\\n    count[s1[i].ord - \\'a\\'.ord] += 1\\n    count[s2[i].ord - \\'a\\'.ord] -= 1\\n  end\\n  return false if count.any? { |c| c != 0 }\\n  \\n  (1...s1.length).each do |i|\\n    if (memo_is_scramble(s1[0...i], s2[0...i], memo) && memo_is_scramble(s1[i..-1], s2[i..-1], memo)) ||\\n       (memo_is_scramble(s1[0...i], s2[-i..-1], memo) && memo_is_scramble(s1[i..-1], s2[0...s2.length-i], memo))\\n      memo[[s1, s2]] = true\\n      return true\\n    end\\n  end\\n\\n  memo[[s1, s2]] = false\\n  false\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef is_scramble(s1, s2)\\n  memo = {}\\n  memo_is_scramble(s1, s2, memo)\\nend\\n\\ndef memo_is_scramble(s1, s2, memo = {})\\n  return true if s1 == s2\\n  return false if s1.length != s2.length\\n  \\n  return memo[[s1, s2]] if memo.key?([s1, s2])\\n  \\n  count = Array.new(26, 0)\\n  (0...s1.length).each do |i|\\n    count[s1[i].ord - \\'a\\'.ord] += 1\\n    count[s2[i].ord - \\'a\\'.ord] -= 1\\n  end\\n  return false if count.any? { |c| c != 0 }\\n  \\n  (1...s1.length).each do |i|\\n    if (memo_is_scramble(s1[0...i], s2[0...i], memo) && memo_is_scramble(s1[i..-1], s2[i..-1], memo)) ||\\n       (memo_is_scramble(s1[0...i], s2[-i..-1], memo) && memo_is_scramble(s1[i..-1], s2[0...s2.length-i], memo))\\n      memo[[s1, s2]] = true\\n      return true\\n    end\\n  end\\n\\n  memo[[s1, s2]] = false\\n  false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3358020,
                "title": "explained-through-comments-recursion-memoization",
                "content": "**class Solution {\\npublic:\\n    \\n    map<pair<string,string>,bool> mp;\\n    \\n    bool dos(string s1,string s2){\\n        \\n        if(s1==s2){      //if strings are equal return true;\\n            return 1;\\n        }\\n        if(s1.size()==1){  //this line will be executed when above statement is not true\\n            return 0;       // so if length of s1 and s2 is 1 and they are not equal return false\\n        }\\n        if(mp.find({s1,s2})!=mp.end()){ //map to memoize, stored as pairs, if found no need to go further.\\n            return mp[{s1,s2}];\\n        }\\n        int n=s1.size();\\n        \\n        //Now we will compare by partioning the string at each i,1,2,3,...n-1.\\n        // and check if after flipping or without flipping both strings are equal or not.\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            //when there is no flip left part of first string will be compared by left part of second string\\n            // and right part of first string will be compared by right part of second string\\n            \\n            bool no_flip=dos(s1.substr(0,i),s2.substr(0,i))&&dos(s1.substr(i),s2.substr(i));\\n            \\n            //if it comes out to true store it in map;\\n            if(no_flip){\\n                return mp[{s1,s2}]=1;   \\n            }\\n            \\n            //when there is flip left part of first string will be compared to right part of second string;\\n            //and right part of second string will be compared with left part of second string.\\n            \\n            bool flip=dos(s1.substr(0,i),s2.substr(n-i))&&dos(s1.substr(i),s2.substr(0,n-i));\\n            if(flip){\\n               return mp[{s1,s2}]=1;\\n            }\\n            // NOTE: we are not executing else part as it may happen that after further partioning \\n            //they come out to be equal\\n            \\n           \\n        }\\n        return mp[{s1,s2}]=0;\\n    }\\n    \\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        return dos(s1,s2);\\n    }\\n};**\\n**UPVOTE IF YOU UNDERSTOOD ,NO MEMER CAT PHOTO AVAILABLE :)**",
                "solutionTags": [
                    "String",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    map<pair<string,string>,bool> mp;\\n    \\n    bool dos(string s1,string s2){\\n        \\n        if(s1==s2){      //if strings are equal return true;\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3357711,
                "title": "java-runtime-3-ms-beats-100-memory-42-5-mb-beats-84-62",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Map<String, Boolean> mem = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        var hash = s1 + s2;\\n        if (!mem.containsKey(hash)) {\\n            mem.put(hash, is(s1, s2));\\n        }\\n        return mem.get(hash);\\n    }\\n\\n    private boolean is(String s1, String s2) {\\n        if (s1.equals(s2))\\n            return true;\\n        int[] count = new int[26];\\n        int[] countF = new int[26];\\n        int[] countB = new int[26];\\n        for (int i = 0; i < s1.length() - 1; i++) {\\n            int j = s2.length() - 1 - i;\\n            count[s1.charAt(i) - \\'a\\'] += 1;\\n            countF[s2.charAt(i) - \\'a\\'] += 1;\\n            countB[s2.charAt(j) - \\'a\\'] += 1;\\n            if (Arrays.equals(count, countF)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(0, i + 1)) && isScramble(s1.substring(i + 1), s2.substring(i + 1)))\\n                    return true;\\n            }\\n            if (Arrays.equals(count, countB)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(j)) && isScramble(s1.substring(i + 1), s2.substring(0, j)))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Boolean> mem = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        var hash = s1 + s2;\\n        if (!mem.containsKey(hash)) {\\n            mem.put(hash, is(s1, s2));\\n        }\\n        return mem.get(hash);\\n    }\\n\\n    private boolean is(String s1, String s2) {\\n        if (s1.equals(s2))\\n            return true;\\n        int[] count = new int[26];\\n        int[] countF = new int[26];\\n        int[] countB = new int[26];\\n        for (int i = 0; i < s1.length() - 1; i++) {\\n            int j = s2.length() - 1 - i;\\n            count[s1.charAt(i) - \\'a\\'] += 1;\\n            countF[s2.charAt(i) - \\'a\\'] += 1;\\n            countB[s2.charAt(j) - \\'a\\'] += 1;\\n            if (Arrays.equals(count, countF)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(0, i + 1)) && isScramble(s1.substring(i + 1), s2.substring(i + 1)))\\n                    return true;\\n            }\\n            if (Arrays.equals(count, countB)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(j)) && isScramble(s1.substring(i + 1), s2.substring(0, j)))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216238,
                "title": "beats-98-java-code",
                "content": "# Java Code\\n```\\nclass Solution {\\n    Map<String, Boolean> mem = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        var hash = s1 + s2;\\n        if (!mem.containsKey(hash)) {\\n            mem.put(hash, is(s1, s2));\\n        }\\n        return mem.get(hash);\\n    }\\n\\n    private boolean is(String s1, String s2) {\\n        if (s1.equals(s2))\\n            return true;\\n        int[] count = new int[26];\\n        int[] countF = new int[26];\\n        int[] countB = new int[26];\\n        for (int i = 0; i < s1.length() - 1; i++) {\\n            int j = s2.length() - 1 - i;\\n            count[s1.charAt(i) - \\'a\\'] += 1;\\n            countF[s2.charAt(i) - \\'a\\'] += 1;\\n            countB[s2.charAt(j) - \\'a\\'] += 1;\\n            if (Arrays.equals(count, countF)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(0, i + 1)) && isScramble(s1.substring(i + 1), s2.substring(i + 1)))\\n                    return true;\\n            }\\n            if (Arrays.equals(count, countB)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(j)) && isScramble(s1.substring(i + 1), s2.substring(0, j)))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Boolean> mem = new HashMap<>();\\n\\n    public boolean isScramble(String s1, String s2) {\\n        var hash = s1 + s2;\\n        if (!mem.containsKey(hash)) {\\n            mem.put(hash, is(s1, s2));\\n        }\\n        return mem.get(hash);\\n    }\\n\\n    private boolean is(String s1, String s2) {\\n        if (s1.equals(s2))\\n            return true;\\n        int[] count = new int[26];\\n        int[] countF = new int[26];\\n        int[] countB = new int[26];\\n        for (int i = 0; i < s1.length() - 1; i++) {\\n            int j = s2.length() - 1 - i;\\n            count[s1.charAt(i) - \\'a\\'] += 1;\\n            countF[s2.charAt(i) - \\'a\\'] += 1;\\n            countB[s2.charAt(j) - \\'a\\'] += 1;\\n            if (Arrays.equals(count, countF)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(0, i + 1)) && isScramble(s1.substring(i + 1), s2.substring(i + 1)))\\n                    return true;\\n            }\\n            if (Arrays.equals(count, countB)) {\\n                if (isScramble(s1.substring(0, i + 1), s2.substring(j)) && isScramble(s1.substring(i + 1), s2.substring(0, j)))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192690,
                "title": "recursive-top-down",
                "content": "# Intuition\\n```C++ []\\n// recursive approach - gives TLE\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool scramble(string s, string t){\\n        int n= s.size();\\n\\n        if(s==t)\\n            return true;\\n        vector<int> cnt(26,0);\\n        for(int i=0; i<n; i++)\\n            cnt[s[i]-\\'a\\']++, cnt[t[i]-\\'a\\']--;\\n\\n        for(int i=0; i<26; i++)\\n            if( cnt[i] )\\n                return false;\\n\\n        // s=gr|eat  t=gr|eat   (not scrambled)\\n        // s=gr|eat  t=ate|gr   (scrambled)\\n        for(int len=1; len<n; len++){\\n           \\n            if( scramble(s.substr(0,len), t.substr(0,len)) and scramble(s.substr(len), t.substr(len)))\\n                return true;\\n            if( scramble(s.substr(0,len), t.substr(n-len)) and scramble(s.substr(len), t.substr(0,n-len)))\\n                return true;\\n        }        \\n        return false;\\n    }\\n    bool isScramble(string s, string t) {\\n\\n        return scramble(s,t);\\n    }\\n};\\n```\\n```C++ []\\n// recursive approach + dp = top-down \\n// AC cheers\\n\\nclass Solution {\\n   map<pair<string,string>, bool> dp;\\npublic:\\n   \\n    \\n    bool scramble(string s, string t){\\n        int n= s.size();\\n        pair<string , string> combo= make_pair(s,t);\\n\\n        if( dp.count(combo)  != 0)\\n            return dp[combo];\\n        if(s==t)\\n            return true;\\n        vector<int> cnt(26,0);\\n        for(int i=0; i<n; i++)\\n            cnt[s[i]-\\'a\\']++, cnt[t[i]-\\'a\\']--;\\n\\n        for(int i=0; i<26; i++)\\n            if( cnt[i] )\\n                return false;\\n\\n        // s=gr|eat  t=gr|eat   (not scrambled)\\n        // s=gr|eat  t=ate|gr   (scrambled)\\n        \\n        for(int len=1; len<n; len++){\\n           \\n            if( scramble(s.substr(0,len), t.substr(0,len)) and scramble(s.substr(len), t.substr(len))  \\n|| scramble(s.substr(0,len), t.substr(n-len)) and scramble(s.substr(len), t.substr(0,n-len))){\\n                \\n                return dp[combo]=true;\\n            }\\n                \\n        }        \\n        return dp[combo]=false;\\n    }\\n    bool isScramble(string s, string t) {\\n\\n        return scramble(s,t);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\n// recursive approach - gives TLE\\n\\n\\nclass Solution {\\npublic:\\n    \\n    bool scramble(string s, string t){\\n        int n= s.size();\\n\\n        if(s==t)\\n            return true;\\n        vector<int> cnt(26,0);\\n        for(int i=0; i<n; i++)\\n            cnt[s[i]-\\'a\\']++, cnt[t[i]-\\'a\\']--;\\n\\n        for(int i=0; i<26; i++)\\n            if( cnt[i] )\\n                return false;\\n\\n        // s=gr|eat  t=gr|eat   (not scrambled)\\n        // s=gr|eat  t=ate|gr   (scrambled)\\n        for(int len=1; len<n; len++){\\n           \\n            if( scramble(s.substr(0,len), t.substr(0,len)) and scramble(s.substr(len), t.substr(len)))\\n                return true;\\n            if( scramble(s.substr(0,len), t.substr(n-len)) and scramble(s.substr(len), t.substr(0,n-len)))\\n                return true;\\n        }        \\n        return false;\\n    }\\n    bool isScramble(string s, string t) {\\n\\n        return scramble(s,t);\\n    }\\n};\\n```\n```C++ []\\n// recursive approach + dp = top-down \\n// AC cheers\\n\\nclass Solution {\\n   map<pair<string,string>, bool> dp;\\npublic:\\n   \\n    \\n    bool scramble(string s, string t){\\n        int n= s.size();\\n        pair<string , string> combo= make_pair(s,t);\\n\\n        if( dp.count(combo)  != 0)\\n            return dp[combo];\\n        if(s==t)\\n            return true;\\n        vector<int> cnt(26,0);\\n        for(int i=0; i<n; i++)\\n            cnt[s[i]-\\'a\\']++, cnt[t[i]-\\'a\\']--;\\n\\n        for(int i=0; i<26; i++)\\n            if( cnt[i] )\\n                return false;\\n\\n        // s=gr|eat  t=gr|eat   (not scrambled)\\n        // s=gr|eat  t=ate|gr   (scrambled)\\n        \\n        for(int len=1; len<n; len++){\\n           \\n            if( scramble(s.substr(0,len), t.substr(0,len)) and scramble(s.substr(len), t.substr(len))  \\n|| scramble(s.substr(0,len), t.substr(n-len)) and scramble(s.substr(len), t.substr(0,n-len))){\\n                \\n                return dp[combo]=true;\\n            }\\n                \\n        }        \\n        return dp[combo]=false;\\n    }\\n    bool isScramble(string s, string t) {\\n\\n        return scramble(s,t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742089,
                "title": "memorized-map-dp-reference-4d-dp-c",
                "content": "**coder , ocder , ocred are scrambled strings**\\n\\ndivide string in two parts , co | der  and oc | der , **der equal so cancel out**\\n\\nc | o , o | c \\n\\nwhile returing , we can swap while combining \\n\\nso c|o becomes , oc  and coder becomes scrambled with\\n\\n**Below are the scrambled strings decomposition**\\n\\n![image.jpg](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/857517ed-ea18-4e05-93c0-8c73d1a973ef/image.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221025%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221025T095829Z&X-Amz-Expires=86400&X-Amz-Signature=ac975287b5f6289c7085d73f3aee0c3623bea59c6ccd073ae16cb535a755165d&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22image.jpg%22&x-id=GetObject)\\n\\n\\nLOGIC : divide string in two parts , \\n\\n1. take L1 from beginning of s1 and s2 , and remaining\\n2. take L1 from beginning of s1 and L1 from end of s2 ( as we can swap values while returing )\\n\\n```cpp\\nunordered_map<string,bool> dp;\\n    bool isScramble(string a, string b) {\\n        if(size(a)!=size(b)) return false;\\n        int n=size(a);\\n        string s=a+\" \"+b;\\n        if(dp.count(s)) return dp[s];\\n        if(a==b) return dp[s]=true;\\n        for(int len=1;len<n;len++){\\n            bool ans=isScramble(a.substr(0,len),b.substr(0,len)) and isScramble(a.substr(len),b.substr(len));\\n            if(ans) return dp[s]=true;\\n            ans=isScramble(a.substr(0,len),b.substr(n-len)) and isScramble(a.substr(len),b.substr(0,n-len));\\n            if(ans) return dp[s]=true;\\n        }\\n        return dp[s]=false;\\n    }\\n```\\n\\nIf take reference of strings and indices\\n\\n```cpp\\nint dp[31][31][31][31];\\n    \\n    // e-s+1=len\\n    // e=len+s-1\\n    // s=e+1-len\\n\\t\\n    bool isScramble(string &a, string &b , int s1 , int e1 , int s2 , int e2) {\\n        int len1=e1-s1+1,len2=e2-s2+1;\\n        if(len1!=len2) return false;\\n        if(dp[s1][e1][s2][e2]!=-1) return dp[s1][e1][s2][e2];\\n        if(a.substr(s1,len1)==b.substr(s2,len2)) return true;\\n        for(int len=1;len<len1;len++){\\n            bool ans=isScramble(a,b,s1,s1+len-1,s2,s2+len-1) and isScramble(a,b,s1+len,e1,s2+len,e2);\\n            if(ans) return dp[s1][e1][s2][e2]=true;\\n            ans=isScramble(a,b,s1,s1+len-1,e2+1-len,e2) and isScramble(a,b,s1+len,e1,s2,e2-len);\\n            if(ans) return dp[s1][e1][s2][e2]=true;\\n        }\\n        return dp[s1][e1][s2][e2]=false;\\n    }\\n    bool isScramble(string s1, string s2){\\n        memset(dp,-1,sizeof dp);\\n        return isScramble(s1,s2,0,size(s1)-1,0,size(s2)-1);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nunordered_map<string,bool> dp;\\n    bool isScramble(string a, string b) {\\n        if(size(a)!=size(b)) return false;\\n        int n=size(a);\\n        string s=a+\" \"+b;\\n        if(dp.count(s)) return dp[s];\\n        if(a==b) return dp[s]=true;\\n        for(int len=1;len<n;len++){\\n            bool ans=isScramble(a.substr(0,len),b.substr(0,len)) and isScramble(a.substr(len),b.substr(len));\\n            if(ans) return dp[s]=true;\\n            ans=isScramble(a.substr(0,len),b.substr(n-len)) and isScramble(a.substr(len),b.substr(0,n-len));\\n            if(ans) return dp[s]=true;\\n        }\\n        return dp[s]=false;\\n    }\\n```\n```cpp\\nint dp[31][31][31][31];\\n    \\n    // e-s+1=len\\n    // e=len+s-1\\n    // s=e+1-len\\n\\t\\n    bool isScramble(string &a, string &b , int s1 , int e1 , int s2 , int e2) {\\n        int len1=e1-s1+1,len2=e2-s2+1;\\n        if(len1!=len2) return false;\\n        if(dp[s1][e1][s2][e2]!=-1) return dp[s1][e1][s2][e2];\\n        if(a.substr(s1,len1)==b.substr(s2,len2)) return true;\\n        for(int len=1;len<len1;len++){\\n            bool ans=isScramble(a,b,s1,s1+len-1,s2,s2+len-1) and isScramble(a,b,s1+len,e1,s2+len,e2);\\n            if(ans) return dp[s1][e1][s2][e2]=true;\\n            ans=isScramble(a,b,s1,s1+len-1,e2+1-len,e2) and isScramble(a,b,s1+len,e1,s2,e2-len);\\n            if(ans) return dp[s1][e1][s2][e2]=true;\\n        }\\n        return dp[s1][e1][s2][e2]=false;\\n    }\\n    bool isScramble(string s1, string s2){\\n        memset(dp,-1,sizeof dp);\\n        return isScramble(s1,s2,0,size(s1)-1,0,size(s2)-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2495569,
                "title": "c-recursion-memoization-map",
                "content": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n    \\n    bool solve(string s1, string s2 , unordered_map<string , bool> &mp){\\n        //base case\\n        if( s1.compare(s2) == 0 ) // if strings are same\\n            return true;\\n        \\n        if( s1.size() <= 1 )  \\n            return false;  \\n        \\n        // memoization step\\n        string key = s1 + \\':\\' + s2;\\n        if( mp.find(key) != mp.end() )\\n            return mp[key];\\n        \\n        int n = s1.size();\\n        bool flag = false;\\n        \\n        for( int i=1 ; i<=n-1 ; i++ ){\\n            bool cond1 = solve( s1.substr(0,i) , s2.substr(n-i,i) , mp) == true  &&\\n                         solve( s1.substr(i,n-i) , s2.substr(0,n-i) , mp) == true;\\n             \\n            bool cond2 = solve( s1.substr(0,i) , s2.substr(0,i) , mp) == true  &&\\n                         solve( s1.substr(i,n-i) , s2.substr(i,n-i) , mp) == true;\\n                \\n                \\n            if( cond1 || cond2 ){\\n                flag = true;\\n                break;\\n            }\\n        }\\n        \\n        return mp[key] = flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if( s1.size() != s2.size() )\\n            return false;\\n        \\n        if( s1.empty() && s2.empty() )\\n            return true;\\n                \\n        // using map for memoization\\n        unordered_map<string , bool> mp;\\n        \\n        return solve(s1,s2,mp);\\n    }\\n\\t};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n    bool solve(string s1, string s2 , unordered_map<string , bool> &mp){\\n        //base case\\n        if( s1.compare(s2) == 0 ) // if strings are same\\n            return true;\\n        \\n        if( s1.size() <= 1 )  \\n            return false;  \\n        \\n        // memoization step\\n        string key = s1 + \\':\\' + s2;\\n        if( mp.find(key) != mp.end() )\\n            return mp[key];\\n        \\n        int n = s1.size();\\n        bool flag = false;\\n        \\n        for( int i=1 ; i<=n-1 ; i++ ){\\n            bool cond1 = solve( s1.substr(0,i) , s2.substr(n-i,i) , mp) == true  &&\\n                         solve( s1.substr(i,n-i) , s2.substr(0,n-i) , mp) == true;\\n             \\n            bool cond2 = solve( s1.substr(0,i) , s2.substr(0,i) , mp) == true  &&\\n                         solve( s1.substr(i,n-i) , s2.substr(i,n-i) , mp) == true;\\n                \\n                \\n            if( cond1 || cond2 ){\\n                flag = true;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2416827,
                "title": "c-solution-with-0ms-runtime",
                "content": "# C++ Solution with 0ms runtime\\n## KINDLY UPVOTE IF YOU ATTAINED 0ms RUNTIME\\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        int n = s1.size();\\n        if (n == 1) return s1[0] == s2[0];\\n        int p1 = -1, p2 = -1;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += s1[i] * s1[i] - s2[i] * s2[i];\\n            sum2 += s1[i] * s1[i] - s2[n - 1 - i] * s2[n - 1 - i];\\n            if (sum1 == 0 && i != n-1) p1 = i;\\n            if (sum2 == 0 && i != n-1) p2 = i;\\n\\t\\t\\t//SOLUTION BY Yaduttam95\\n        }\\n        int a = 0, b = 0;\\n        if (p1 != -1) a = isScramble(s1.substr(0, p1 + 1), s2.substr(0, p1 + 1)) && isScramble(s1.substr(p1 + 1, n - p1 - 1 ), s2.substr(p1 + 1, n - p1 - 1));\\n        if (p2 != -1) b = isScramble(s1.substr(0, p2 + 1), s2.substr(n - p2 - 1, p2 + 1)) && isScramble(s1.substr(p2 + 1, n - p2 - 1), s2.substr(0, n - p2 - 1));\\n        return a || b;\\n    }\\n};\\n```\\n\\nSOLUTION BY [Yaduttam95](https://github.com/Yaduttam95)\\n\\n#### IF YOU HAVE READ TILL HERE PLEASE UPVOTE THE SOLUTION",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int sum1 = 0, sum2 = 0;\\n        int n = s1.size();\\n        if (n == 1) return s1[0] == s2[0];\\n        int p1 = -1, p2 = -1;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += s1[i] * s1[i] - s2[i] * s2[i];\\n            sum2 += s1[i] * s1[i] - s2[n - 1 - i] * s2[n - 1 - i];\\n            if (sum1 == 0 && i != n-1) p1 = i;\\n            if (sum2 == 0 && i != n-1) p2 = i;\\n\\t\\t\\t//SOLUTION BY Yaduttam95\\n        }\\n        int a = 0, b = 0;\\n        if (p1 != -1) a = isScramble(s1.substr(0, p1 + 1), s2.substr(0, p1 + 1)) && isScramble(s1.substr(p1 + 1, n - p1 - 1 ), s2.substr(p1 + 1, n - p1 - 1));\\n        if (p2 != -1) b = isScramble(s1.substr(0, p2 + 1), s2.substr(n - p2 - 1, p2 + 1)) && isScramble(s1.substr(p2 + 1, n - p2 - 1), s2.substr(0, n - p2 - 1));\\n        return a || b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351236,
                "title": "python-3-solution",
                "content": "![image](https://assets.leetcode.com/users/images/4a282e89-ca03-4292-bfb6-95ebbc143249_1659108310.814036.png)\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.map = {}\\n\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if (s1, s2) in self.map:\\n            return self.map[(s1, s2)]\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2):\\n            self.map[(s1, s2)] = False\\n            return False\\n        length = len(s1)\\n        if s1 == s2:\\n            self.map[(s1, s2)] = True\\n            return True\\n        for i in range(1, length):\\n            if self.isScramble(s1[i:], s2[i:]) and self.isScramble(s1[:i], s2[:i]):\\n                return True\\n            if self.isScramble(s1[:-i], s2[i:]) and self.isScramble(s1[-i:], s2[:i]):\\n                return True\\n        self.map[(s1, s2)] = False\\n        return False![image](https://assets.leetcode.com/users/images/9d15aea0-b33e-424d-8e39-a044d6e9b6f5_1659108282.189691.png)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.map = {}\\n\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if (s1, s2) in self.map:\\n            return self.map[(s1, s2)]\\n        if len(s1) != len(s2) or sorted(s1) != sorted(s2):\\n            self.map[(s1, s2)] = False\\n            return False\\n        length = len(s1)\\n        if s1 == s2:\\n            self.map[(s1, s2)] = True\\n            return True\\n        for i in range(1, length):\\n            if self.isScramble(s1[i:], s2[i:]) and self.isScramble(s1[:i], s2[:i]):\\n                return True\\n            if self.isScramble(s1[:-i], s2[i:]) and self.isScramble(s1[-i:], s2[:i]):\\n                return True\\n        self.map[(s1, s2)] = False\\n        return False![image](https://assets.leetcode.com/users/images/9d15aea0-b33e-424d-8e39-a044d6e9b6f5_1659108282.189691.png)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284154,
                "title": "bhai-java-m-code-hai-maze-karo",
                "content": "```\\nclass Solution {\\n    public boolean solve(String s1, String s2, HashMap<String, Boolean> map){\\n        \\n        // batawo compareTo use kiya hai (bade log ) : matlab v dekho iska \"compares two strings lexicographically\"\\n        // acche se bole to sort karo aur check karo....\\n        if(s1.compareTo(s2) == 0){\\n            return true;\\n        }\\n        \\n        //idhar v padhoge\\n        int n = s1.length();\\n        \\n        // ab single length ho gya to kaahe ko iterate karna choro ka base base apna y\\n        if(n<=1){\\n            return false;\\n        }\\n        \\n        // ab ynha dono string ko concatenate karo maine to underscore liya hai tumhe jo lena hai le lo\\n        // kya hi farak padne wala hai\\n        // par isiliy liy taaki recursion m same chizze baare baar calculate na ho simple\\n        String key = s1 + \"_\" + s2;\\n        \\n        // agar y already process ho gya to sidha iska value fetch karo aur return karaa do\\n        if(map.containsKey(key)){\\n            return map.get(key);\\n        }\\n        \\n        \\n        //idhar m ek flag liya hai taaki future m isi par khell sko\\n        boolean flag = false;\\n        \\n        // idhar second element se khelna start karo aur last tak khelnaa...\\n        for(int i=1;i<n;i++){\\n            \\n            // y ratt lo easy hai.. bas aage piche, piche aage, aage aage, piche piche compare karna hia bas...\\n            if((solve(s1.substring(0,i), s2.substring(n-i, n), map) && (solve(s1.substring(i, n), s2.substring(0, n-i), map))) || \\n               ((solve(s1.substring(0,i), s2.substring(0,i), map)) && (solve(s1.substring(i, n), s2.substring(i, n), map)))){\\n                // idhar flag true kra aur break kar do agge test hi nhi karna hia\\n                   flag = true;\\n                   break;\\n               }\\n        }\\n        \\n        // suru m bola tha recusion m chize repeat hoti hai to ynha uss repetation ko khtm kar do \\n        map.put(key, flag);\\n        // y rhha final answer...\\n                return flag;\\n    }\\n    \\n    // bas bakchodi karni hai inhe. simple sala sort kar do and match kara lo ki dono match kar rhe hain ya nhi. par nhi inko karni hai bakiti to chalo suru karte hain inke tarike se.\\n    public boolean isScramble(String s1, String s2) {\\n        \\n        // ynha pe length check kar lo, ki same hai ya nhi. means string s1 and s2 dene wala ko bewkuff hoga wrong length dega...\\n        if(s1.length() != s2.length()){return false;}\\n        // phir ynhi check kar lo ki same hain ya nhi : same hain to diya hi kaahe be...\\n        if(s1.equals(s2)) return true;\\n        \\n        //ab hashmap create karo taaki har chota chota part ko match karaa kar k dekhana hia ki same hai ki nhi matalab pura time pass karna hai map ko\\n        HashMap<String, Boolean> map = new HashMap<>();\\n        // ynha se suru hoti hai khichadi par acchi waali... bole to recursion.\\n        return solve(s1, s2, map);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean solve(String s1, String s2, HashMap<String, Boolean> map){\\n        \\n        // batawo compareTo use kiya hai (bade log ) : matlab v dekho iska \"compares two strings lexicographically\"\\n        // acche se bole to sort karo aur check karo....\\n        if(s1.compareTo(s2) == 0){\\n            return true;\\n        }\\n        \\n        //idhar v padhoge\\n        int n = s1.length();\\n        \\n        // ab single length ho gya to kaahe ko iterate karna choro ka base base apna y\\n        if(n<=1){\\n            return false;\\n        }\\n        \\n        // ab ynha dono string ko concatenate karo maine to underscore liya hai tumhe jo lena hai le lo\\n        // kya hi farak padne wala hai\\n        // par isiliy liy taaki recursion m same chizze baare baar calculate na ho simple\\n        String key = s1 + \"_\" + s2;\\n        \\n        // agar y already process ho gya to sidha iska value fetch karo aur return karaa do\\n        if(map.containsKey(key)){\\n            return map.get(key);\\n        }\\n        \\n        \\n        //idhar m ek flag liya hai taaki future m isi par khell sko\\n        boolean flag = false;\\n        \\n        // idhar second element se khelna start karo aur last tak khelnaa...\\n        for(int i=1;i<n;i++){\\n            \\n            // y ratt lo easy hai.. bas aage piche, piche aage, aage aage, piche piche compare karna hia bas...\\n            if((solve(s1.substring(0,i), s2.substring(n-i, n), map) && (solve(s1.substring(i, n), s2.substring(0, n-i), map))) || \\n               ((solve(s1.substring(0,i), s2.substring(0,i), map)) && (solve(s1.substring(i, n), s2.substring(i, n), map)))){\\n                // idhar flag true kra aur break kar do agge test hi nhi karna hia\\n                   flag = true;\\n                   break;\\n               }\\n        }\\n        \\n        // suru m bola tha recusion m chize repeat hoti hai to ynha uss repetation ko khtm kar do \\n        map.put(key, flag);\\n        // y rhha final answer...\\n                return flag;\\n    }\\n    \\n    // bas bakchodi karni hai inhe. simple sala sort kar do and match kara lo ki dono match kar rhe hain ya nhi. par nhi inko karni hai bakiti to chalo suru karte hain inke tarike se.\\n    public boolean isScramble(String s1, String s2) {\\n        \\n        // ynha pe length check kar lo, ki same hai ya nhi. means string s1 and s2 dene wala ko bewkuff hoga wrong length dega...\\n        if(s1.length() != s2.length()){return false;}\\n        // phir ynhi check kar lo ki same hain ya nhi : same hain to diya hi kaahe be...\\n        if(s1.equals(s2)) return true;\\n        \\n        //ab hashmap create karo taaki har chota chota part ko match karaa kar k dekhana hia ki same hai ki nhi matalab pura time pass karna hai map ko\\n        HashMap<String, Boolean> map = new HashMap<>();\\n        // ynha se suru hoti hai khichadi par acchi waali... bole to recursion.\\n        return solve(s1, s2, map);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237199,
                "title": "bottom-up-approach-optimal-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    bool isScramble(string s1, string s2) {\\n        if (s1.length() != s2.length()) {  //recursive approach will give TLE\\n        return false;\\n    }\\n \\n    int n = s1.length();\\n \\n    // Empty strings are scramble strings\\n    if (n == 0) {\\n        return true;\\n    }\\n \\n    // Equal strings are scramble strings\\n    if (s1 == s2) {\\n        return true;\\n    }\\n    string key = (s1 + \" \" + s2);\\n    if(mp.find(key)!=mp.end())\\n    return mp[key];\\n    \\n    bool flag=false;\\n    for(int i=1;i<=n-1;i++){      \\n       if (isScramble(s1.substr(0, i), s2.substr(0, i)) //first condition\\n            && isScramble(s1.substr(i, n - i), s2.substr(i, n - i)) || (isScramble(s1.substr(0, i), //second condition\\n                       s2.substr(n - i, i))\\n            && isScramble(s1.substr(i, n - i),\\n                          s2.substr(0, n - i)))) {\\n            flag =true;\\n            return true;\\n        }\\n         \\n    }\\n    mp[key]=flag;\\n    return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> mp;\\n    bool isScramble(string s1, string s2) {\\n        if (s1.length() != s2.length()) {  //recursive approach will give TLE\\n        return false;\\n    }\\n \\n    int n = s1.length();\\n \\n    // Empty strings are scramble strings\\n    if (n == 0) {\\n        return true;\\n    }\\n \\n    // Equal strings are scramble strings\\n    if (s1 == s2) {\\n        return true;\\n    }\\n    string key = (s1 + \" \" + s2);\\n    if(mp.find(key)!=mp.end())\\n    return mp[key];\\n    \\n    bool flag=false;\\n    for(int i=1;i<=n-1;i++){      \\n       if (isScramble(s1.substr(0, i), s2.substr(0, i)) //first condition\\n            && isScramble(s1.substr(i, n - i), s2.substr(i, n - i)) || (isScramble(s1.substr(0, i), //second condition\\n                       s2.substr(n - i, i))\\n            && isScramble(s1.substr(i, n - i),\\n                          s2.substr(0, n - i)))) {\\n            flag =true;\\n            return true;\\n        }\\n         \\n    }\\n    mp[key]=flag;\\n    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217499,
                "title": "c-mcm-aditya-verma-playlist",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool>dp;\\n    bool solve(string s1, string s2)\\n    {\\n        if(s1 == s2)\\n            return true;\\n        if(s1.length() <= 1)\\n            return false;\\n        string temp = s1+\"\"+s2;\\n        if(dp.find(temp) != dp.end())\\n            return dp[temp];\\n        bool flag = false;\\n        int n = s1.length();\\n        bool cond1=false, cond2=false;\\n        for(int k=1; k<=n-1; k++)\\n        {\\n            if(solve(s1.substr(0, k), s2.substr(n-k, k)) && (solve(s1.substr(k, n-k), s2.substr(0, n-k))))\\n                cond1= true;\\n            if(solve(s1.substr(0, k), s2.substr(0, k)) && (solve(s1.substr(k, n-k), s2.substr(k, n-k))))\\n                cond2 = true;\\n            if(cond1 || cond2)\\n            {\\n                flag = true;\\n                break;\\n            }\\n        }\\n        return dp[temp] = flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2)\\n            return true;\\n        if(s1.length() != s2.length())\\n            return false;\\n        if(s1.length() <= 1)\\n            return false;\\n        return solve(s1, s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool>dp;\\n    bool solve(string s1, string s2)\\n    {\\n        if(s1 == s2)\\n            return true;\\n        if(s1.length() <= 1)\\n            return false;\\n        string temp = s1+\"\"+s2;\\n        if(dp.find(temp) != dp.end())\\n            return dp[temp];\\n        bool flag = false;\\n        int n = s1.length();\\n        bool cond1=false, cond2=false;\\n        for(int k=1; k<=n-1; k++)\\n        {\\n            if(solve(s1.substr(0, k), s2.substr(n-k, k)) && (solve(s1.substr(k, n-k), s2.substr(0, n-k))))\\n                cond1= true;\\n            if(solve(s1.substr(0, k), s2.substr(0, k)) && (solve(s1.substr(k, n-k), s2.substr(k, n-k))))\\n                cond2 = true;\\n            if(cond1 || cond2)\\n            {\\n                flag = true;\\n                break;\\n            }\\n        }\\n        return dp[temp] = flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2)\\n            return true;\\n        if(s1.length() != s2.length())\\n            return false;\\n        if(s1.length() <= 1)\\n            return false;\\n        return solve(s1, s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202091,
                "title": "c-mcm-pattern-fully-explained-2-methods-recursion-memorization-dp",
                "content": "* So we have 2 strings s1 and s2 and we need to check if they are scrambled strings are not\\n* For that we can follow the MCM pattern of dividing the string into 2 parts at every possible point\\n* So we can do 2 possible things at a point\\n            1. leave the string as it is\\n            2. swap it!\\n* Let us assume you are at index 1 and you want to leave the string as it is then it would be true if and only if (0,1) of s1 == (0,1) of s2 (AND) (1,n) of s1 == (1,n) of s2 \\n*  Now for swap case let us assume we are at index 1 and now we will check if (0,1) of s1 == (n-1,1) of s2 (AND) (1,n) of s1 == (0,n-1) of s2 \\n*  **(Here \\'s1==s2\\' doesn\\'t mean we are comparing both the string it represent whether s1 and  s2 are scrambled strings or not)**\\n\\n**CODE:**\\n\\n**RECURSION (TLE) :**\\n```\\nclass Solution {\\npublic:\\n    bool rec(string s1,string s2){\\n        int n=s1.size();\\n        if(s1==s2){   //If strings are equal  Eg:s1=ab and s2=ab;\\n            return 1;\\n        }\\n        if(n==1){   //strings are not equal even if the size is 1\\n            return 0;\\n        }\\n        int flag=0;\\n        for(int k=1;k<n;k++){\\n            if(rec(s1.substr(0,k),s2.substr(0,k))&&rec(s1.substr(k),s2.substr(k))){   //leave\\n                flag=1;\\n            }\\n            if(rec(s1.substr(0,k),s2.substr(n-k))&&rec(s1.substr(k),s2.substr(0,n-k))){ //swap\\n                flag=1;\\n            }\\n        }\\n        return flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        return rec(s1,s2);\\n    }\\n};\\n```\\n\\n**DYNAMIC PROGRAMMING (RECURSION + MEMORIZATION) (AC) :**\\n```\\nclass Solution {\\npublic:\\n    bool rec(string s1,string s2,unordered_map<string,int>&um){\\n        int n=s1.size();\\n        if(s1==s2){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 0;\\n        }\\n        int flag=0;\\n        if(um.find(s1+\" \"+s2)!=um.end()){\\n            return um[s1+\" \"+s2];\\n        }\\n        for(int k=1;k<n;k++){\\n            if(rec(s1.substr(0,k),s2.substr(0,k),um)&&rec(s1.substr(k),s2.substr(k),um)){\\n                flag=1;\\n            }\\n            if(flag==1){\\n                return true;\\n            }\\n            if(rec(s1.substr(0,k),s2.substr(n-k),um)&&rec(s1.substr(k),s2.substr(0,n-k),um)){\\n                flag=1;\\n            }\\n            if(flag==1){\\n                return true;\\n            }\\n        }\\n        return um[s1+\" \"+s2]=flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string,int>um;\\n        return rec(s1,s2,um);\\n    }\\n};\\n```\\n\\nPlease **UPVOTE!** if you find this useful and update me in the comments if you have a better optimized solution\\nCheck this [video](https://www.youtube.com/watch?v=SqA0o-DGmEw&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=40&ab_channel=AdityaVerma) for better understanding\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool rec(string s1,string s2){\\n        int n=s1.size();\\n        if(s1==s2){   //If strings are equal  Eg:s1=ab and s2=ab;\\n            return 1;\\n        }\\n        if(n==1){   //strings are not equal even if the size is 1\\n            return 0;\\n        }\\n        int flag=0;\\n        for(int k=1;k<n;k++){\\n            if(rec(s1.substr(0,k),s2.substr(0,k))&&rec(s1.substr(k),s2.substr(k))){   //leave\\n                flag=1;\\n            }\\n            if(rec(s1.substr(0,k),s2.substr(n-k))&&rec(s1.substr(k),s2.substr(0,n-k))){ //swap\\n                flag=1;\\n            }\\n        }\\n        return flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        return rec(s1,s2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool rec(string s1,string s2,unordered_map<string,int>&um){\\n        int n=s1.size();\\n        if(s1==s2){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 0;\\n        }\\n        int flag=0;\\n        if(um.find(s1+\" \"+s2)!=um.end()){\\n            return um[s1+\" \"+s2];\\n        }\\n        for(int k=1;k<n;k++){\\n            if(rec(s1.substr(0,k),s2.substr(0,k),um)&&rec(s1.substr(k),s2.substr(k),um)){\\n                flag=1;\\n            }\\n            if(flag==1){\\n                return true;\\n            }\\n            if(rec(s1.substr(0,k),s2.substr(n-k),um)&&rec(s1.substr(k),s2.substr(0,n-k),um)){\\n                flag=1;\\n            }\\n            if(flag==1){\\n                return true;\\n            }\\n        }\\n        return um[s1+\" \"+s2]=flag;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        unordered_map<string,int>um;\\n        return rec(s1,s2,um);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185858,
                "title": "c-mcm-memorization-dp-easy-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool solve(string s1,string s2){\\n        string s = s1 +\" \"+s2;\\n        if(s1==s2) return mp[s]= true;\\n        if(s1.length()<=1||s2.length()<=1) return false;\\n        if(mp.find(s)!=mp.end()) return mp[s];\\n        bool flag =false;\\n        int j = s1.length();\\n        for(int i=1;i<s1.length();i++){\\n    bool cond1 = solve(s1.substr(0,i),s2.substr(j-i))&&solve(s1.substr(i),s2.substr(0,j-i));\\n    bool cond2 = solve(s1.substr(0,i),s2.substr(0,i))&&solve(s1.substr(i),s2.substr(i));\\n          if(cond1||cond2){\\n              flag = true;\\n              break;\\n          }  \\n        }\\n        \\n     return mp[s]=flag;   \\n    }\\n    bool isScramble(string s1, string s2) {\\n        vector<int> cnt(26,0);\\n        mp = unordered_map<string,bool>(false);\\n        if(s1.length()!=s2.length()) return false;\\n        if(s1==s2)return true;\\n        for(int i=0;i<s1.size();i++){\\n            cnt[s1[i]-\\'a\\']++;\\n            cnt[s2[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]!=0)return false;\\n        }\\n        \\n       return solve(s1,s2); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool solve(string s1,string s2){\\n        string s = s1 +\" \"+s2;\\n        if(s1==s2) return mp[s]= true;\\n        if(s1.length()<=1||s2.length()<=1) return false;\\n        if(mp.find(s)!=mp.end()) return mp[s];\\n        bool flag =false;\\n        int j = s1.length();\\n        for(int i=1;i<s1.length();i++){\\n    bool cond1 = solve(s1.substr(0,i),s2.substr(j-i))&&solve(s1.substr(i),s2.substr(0,j-i));\\n    bool cond2 = solve(s1.substr(0,i),s2.substr(0,i))&&solve(s1.substr(i),s2.substr(i));\\n          if(cond1||cond2){\\n              flag = true;\\n              break;\\n          }  \\n        }\\n        \\n     return mp[s]=flag;   \\n    }\\n    bool isScramble(string s1, string s2) {\\n        vector<int> cnt(26,0);\\n        mp = unordered_map<string,bool>(false);\\n        if(s1.length()!=s2.length()) return false;\\n        if(s1==s2)return true;\\n        for(int i=0;i<s1.size();i++){\\n            cnt[s1[i]-\\'a\\']++;\\n            cnt[s2[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]!=0)return false;\\n        }\\n        \\n       return solve(s1,s2); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029583,
                "title": "bottom-up-approach-simple-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        if (n1 != n2)   return false; // lengths should be the same\\n        if (s1 == \"\" && s2 == \"\")   return true; // empty strings are scramble of each other\\n        // try to write dp state params\\n\\t\\t// an obvious dp state would be dp[start1][end1][start2][end2]\\n        // but as the length of two strings should always be equal we can determine end2 using start1, end1, and start2\\n        // thus, we use dp[start1][start2][len] as our state\\n        bool dp[n1 + 1][n1 + 1][n1 + 1]; // denoting dp[start1][start2][len]\\n        memset(dp, false, sizeof(dp));\\n        // if we have to build a solution from bottom up first try to think how to get the answers for the base cases\\n        // here as our base case we want asnwers for all substrings of s1 * all substrings of s2 of size 1\\n        // that means we already have 3 loops for len, ind_i and ind_2\\n        // now why len loop is outside because we first want to solve all the subproblems of len 1 before moving to a higher len\\n        for(int l = 1; l <= n1; l++){ \\n            for (int i = 0; i + l - 2 < n1; i++) {\\n                for (int j = 0; j + l - 2 < n1; j++) {\\n                    dp[i][j][l] = (s1.substr(i, l) == s2.substr(j, l));\\n                    // transactions are a bit clearer from the question itself\\n                    // we just have to decide the left and right parts for scrambling\\n                    // thus we have dp[i][j][l] |= (dp[i][j][k] && dp[i + k][j + k][l - k]) || (dp[i + l - k][j][k] && dp[i][j + k][l - k]);\\n                    // where k denotes the len of the left part\\n                    for (int k = 1 ; k < l ; k++) {\\n                        dp[i][j][l] |= (dp[i][j][k] && dp[i + k][j + k][l - k]) || (dp[i + l - k][j][k] && dp[i][j + k][l - k]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][n1];\\n        \\n    }\\n};\\n```\\nPlease upvote if it helped !",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        int n1 = s1.size(), n2 = s2.size();\\n        if (n1 != n2)   return false; // lengths should be the same\\n        if (s1 == \"\" && s2 == \"\")   return true; // empty strings are scramble of each other\\n        // try to write dp state params\\n\\t\\t// an obvious dp state would be dp[start1][end1][start2][end2]\\n        // but as the length of two strings should always be equal we can determine end2 using start1, end1, and start2\\n        // thus, we use dp[start1][start2][len] as our state\\n        bool dp[n1 + 1][n1 + 1][n1 + 1]; // denoting dp[start1][start2][len]\\n        memset(dp, false, sizeof(dp));\\n        // if we have to build a solution from bottom up first try to think how to get the answers for the base cases\\n        // here as our base case we want asnwers for all substrings of s1 * all substrings of s2 of size 1\\n        // that means we already have 3 loops for len, ind_i and ind_2\\n        // now why len loop is outside because we first want to solve all the subproblems of len 1 before moving to a higher len\\n        for(int l = 1; l <= n1; l++){ \\n            for (int i = 0; i + l - 2 < n1; i++) {\\n                for (int j = 0; j + l - 2 < n1; j++) {\\n                    dp[i][j][l] = (s1.substr(i, l) == s2.substr(j, l));\\n                    // transactions are a bit clearer from the question itself\\n                    // we just have to decide the left and right parts for scrambling\\n                    // thus we have dp[i][j][l] |= (dp[i][j][k] && dp[i + k][j + k][l - k]) || (dp[i + l - k][j][k] && dp[i][j + k][l - k]);\\n                    // where k denotes the len of the left part\\n                    for (int k = 1 ; k < l ; k++) {\\n                        dp[i][j][l] |= (dp[i][j][k] && dp[i + k][j + k][l - k]) || (dp[i + l - k][j][k] && dp[i][j + k][l - k]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][n1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984464,
                "title": "c-best-solution-using-dp-unique-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<string, int>, bool> mp;\\n    bool solve(string str, string &s2, int start, int end){\\n        if (start == end){\\n            return s2[start] == str[0];\\n        }\\n        if (mp.find({str, start+end}) != mp.end())  return mp[{str, start+end}];\\n        \\n        bool ans = 0;\\n        for (int i = 0;i < end-start;i++){\\n            bool left = solve(str.substr(0, i+1), s2, start, start+i) && solve(str.substr(i+1), s2, start+i+1, end);\\n            bool right = solve(str.substr(i+1), s2, start, end-i-1) && solve(str.substr(0, i+1), s2, end-i, end);\\n            ans = left or right;\\n            if (ans){\\n                mp[{str, start+end}] = ans;\\n                return ans;\\n            }\\n        }\\n        mp[{str, start+end}] = ans;\\n        return ans;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        return solve(s1, s2, 0, s1.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<string, int>, bool> mp;\\n    bool solve(string str, string &s2, int start, int end){\\n        if (start == end){\\n            return s2[start] == str[0];\\n        }\\n        if (mp.find({str, start+end}) != mp.end())  return mp[{str, start+end}];\\n        \\n        bool ans = 0;\\n        for (int i = 0;i < end-start;i++){\\n            bool left = solve(str.substr(0, i+1), s2, start, start+i) && solve(str.substr(i+1), s2, start+i+1, end);\\n            bool right = solve(str.substr(i+1), s2, start, end-i-1) && solve(str.substr(0, i+1), s2, end-i, end);\\n            ans = left or right;\\n            if (ans){\\n                mp[{str, start+end}] = ans;\\n                return ans;\\n            }\\n        }\\n        mp[{str, start+end}] = ans;\\n        return ans;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        return solve(s1, s2, 0, s1.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785831,
                "title": "scramble-string-solution-java",
                "content": "class Solution {\\n  public boolean isScramble(String s1, String s2) {\\n    if (s1.equals(s2))\\n      return true;\\n    if (s1.length() != s2.length())\\n      return false;\\n    final String hashedKey = s1 + \"+\" + s2;\\n    if (memo.containsKey(hashedKey))\\n      return memo.get(hashedKey);\\n\\n    int[] count = new int[128];\\n\\n    for (int i = 0; i < s1.length(); ++i) {\\n      ++count[s1.charAt(i)];\\n      --count[s2.charAt(i)];\\n    }\\n\\n    for (final int c : count)\\n      if (c != 0) {\\n        memo.put(hashedKey, false);\\n        return false;\\n      }\\n\\n    for (int i = 1; i < s1.length(); ++i) {\\n      if (isScramble(s1.substring(0, i), s2.substring(0, i)) &&\\n          isScramble(s1.substring(i), s2.substring(i))) {\\n        memo.put(hashedKey, true);\\n        return true;\\n      }\\n      if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) &&\\n          isScramble(s1.substring(i), s2.substring(0, s2.length() - i))) {\\n        memo.put(hashedKey, true);\\n        return true;\\n      }\\n    }\\n\\n    memo.put(hashedKey, false);\\n    return false;\\n  }\\n\\n  private Map<String, Boolean> memo = new HashMap<>();\\n}\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n  public boolean isScramble(String s1, String s2) {\\n    if (s1.equals(s2))\\n      return true;\\n    if (s1.length() != s2.length())\\n      return false;\\n    final String hashedKey = s1 + \"+\" + s2;\\n    if (memo.containsKey(hashedKey))\\n      return memo.get(hashedKey);\\n\\n    int[] count = new int[128];\\n\\n    for (int i = 0; i < s1.length(); ++i) {\\n      ++count[s1.charAt(i)];\\n      --count[s2.charAt(i)];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1763795,
                "title": "aditya-bhaiya-op-scramble-string",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool>mp;\\n    \\n    bool solve( string a, string b){\\n        \\n        if (a.compare(b) == 0)\\n            return true;\\n        \\n        if (a.size() <=1 )\\n            return false ;\\n        \\n        int n = a.size();\\n        \\n        string key = a+ \" \" + b;\\n        \\n        if (mp.find(key) != mp.end())\\n            return mp[key];\\n        \\n         bool flag = false;\\n        \\n        for (int i=1; i< n; i++){\\n            \\n    \\n            \\n        if ((solve(a.substr(0,i), b.substr(n-i, i))== true  && solve(a.substr(i,n-i), b.substr(0, n-i))== true)|| (solve(a.substr(0,i), b.substr(0, i))== true  && solve(a.substr(i,n-i), b.substr(i, n-i)) == true))\\n        {\\n            flag = true;\\n            break;\\n        }\\n        \\n        \\n        \\n    }\\n    return mp[key] = flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        if (s1.size() != s2.size())\\n            return false ;\\n        \\n        return solve(s1, s2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool>mp;\\n    \\n    bool solve( string a, string b){\\n        \\n        if (a.compare(b) == 0)\\n            return true;\\n        \\n        if (a.size() <=1 )\\n            return false ;\\n        \\n        int n = a.size();\\n        \\n        string key = a+ \" \" + b;\\n        \\n        if (mp.find(key) != mp.end())\\n            return mp[key];\\n        \\n         bool flag = false;\\n        \\n        for (int i=1; i< n; i++){\\n            \\n    \\n            \\n        if ((solve(a.substr(0,i), b.substr(n-i, i))== true  && solve(a.substr(i,n-i), b.substr(0, n-i))== true)|| (solve(a.substr(0,i), b.substr(0, i))== true  && solve(a.substr(i,n-i), b.substr(i, n-i)) == true))\\n        {\\n            flag = true;\\n            break;\\n        }\\n        \\n        \\n        \\n    }\\n    return mp[key] = flag;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        \\n        if (s1.size() != s2.size())\\n            return false ;\\n        \\n        return solve(s1, s2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741245,
                "title": "java-aditya-verma-solution",
                "content": "```\\nclass Solution {\\n    static HashMap<String,Boolean> map=new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        \\n        if(s1.equals(s2))\\n        {\\n            return true;\\n        }\\n             \\n        String key=s1+\"_\"+s2;\\n        if(map.containsKey(key))\\n        {\\n            return map.get(key);\\n        }\\n        boolean flag=false;\\n        int n=s1.length();\\n        for(int i=1;i<n;i++)\\n        {\\n             boolean swap=(isScramble(s1.substring(0, i),s2.substring(n - i,n)) && isScramble(s1.substring(i, n),s2.substring(0, n-i)));\\n         \\n            boolean noswap=(isScramble(s1.substring(0, i),s2.substring(0, i))  && isScramble(s1.substring(i, n),s2.substring(i, n)));\\n            \\n            if(noswap||swap)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        map.put(key,flag);\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    static HashMap<String,Boolean> map=new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        \\n        if(s1.equals(s2))\\n        {\\n            return true;\\n        }\\n             \\n        String key=s1+\"_\"+s2;\\n        if(map.containsKey(key))\\n        {\\n            return map.get(key);\\n        }\\n        boolean flag=false;\\n        int n=s1.length();\\n        for(int i=1;i<n;i++)\\n        {\\n             boolean swap=(isScramble(s1.substring(0, i),s2.substring(n - i,n)) && isScramble(s1.substring(i, n),s2.substring(0, n-i)));\\n         \\n            boolean noswap=(isScramble(s1.substring(0, i),s2.substring(0, i))  && isScramble(s1.substring(i, n),s2.substring(i, n)));\\n            \\n            if(noswap||swap)\\n            {\\n                flag=true;\\n                break;\\n            }\\n        }\\n        map.put(key,flag);\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713183,
                "title": "c-memoized-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool isScramble(string a, string b) {\\n        \\n        string key=a+b;\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        if(a.compare(b)==0)\\n            return mp[key]=true;\\n        if(a.length()<=1)\\n            return mp[key]=false;\\n        int i,n;\\n        n=a.length();\\n        for(i=1;i<n;i++)\\n        {\\n            if(isScramble(a.substr(0,i),b.substr(0,i)) && isScramble(a.substr(i,n-i),b.substr(i,n-i)))\\n            return mp[key]=true;\\n            if(isScramble(a.substr(0,i),b.substr(n-i,i)) && isScramble(a.substr(i,n-i),b.substr(0,n-i)))\\n            return mp[key]=true;\\n        }\\n        return mp[key]=false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool isScramble(string a, string b) {\\n        \\n        string key=a+b;\\n        if(mp.find(key)!=mp.end())\\n            return mp[key];\\n        if(a.compare(b)==0)\\n            return mp[key]=true;\\n        if(a.length()<=1)\\n            return mp[key]=false;\\n        int i,n;\\n        n=a.length();\\n        for(i=1;i<n;i++)\\n        {\\n            if(isScramble(a.substr(0,i),b.substr(0,i)) && isScramble(a.substr(i,n-i),b.substr(i,n-i)))\\n            return mp[key]=true;\\n            if(isScramble(a.substr(0,i),b.substr(n-i,i)) && isScramble(a.substr(i,n-i),b.substr(0,n-i)))\\n            return mp[key]=true;\\n        }\\n        return mp[key]=false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570555,
                "title": "python-c-dfs-memo-and-elegant-negative-index",
                "content": "Approach 1: DFS + memo\\n```\\nclass Solution:\\n    @lru_cache(None)\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if s1 == s2: return True\\n        if Counter(s1) != Counter(s2): return False\\n        N = len(s1)\\n        for i in range(1, N):\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]): return True\\n            if self.isScramble(s1[:i], s2[N - i:]) and self.isScramble(s1[i:], s2[:N-i]): return True\\n        return False                  \\n```\\n\\nApproach 2: Elegant using negative index in Python\\nTrick:\\na=[1,2,3,4,5]\\na[:-2] = [1,2,3]\\na[-2:] = [4,5]\\n```\\nclass Solution: # Appraoch 2, BEST\\n    @cache\\n    def isScramble(self, s1: str, s2: str) -> bool:        \\n        #if sorted(s1)!=sorted(s2): return False #OK, but too expensive\\n        if s1 == s2: return True\\n        if Counter(s1)!=Counter(s2): return False        \\n        n = len(s1)\\n        for i in range(1,n):#OK, sub-problmens must be smaller than original problems.\\n        #for i in range(n-1): #ERR: maximum recursion depth exceeded in comparison\\n        #for i in range(n): # ERR: maximum recursion depth exceeded in comparison\\n            #case1: first i items vs. first i items, where i is [1, n-1]\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                return True\\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\\n                return True\\n        return False\\n\\n```\\n\\nAppraoch 2: C++ version\\n```\\nclass Solution {// C++ version\\npublic: // string can be replace with string_view\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2) return true;\\n        if(Counter(s1) != Counter(s2)) return false;\\n        if(_memo.count(s1) && _memo[s1].count(s2)) return _memo[s1][s2];\\n        for(int i = 1, N = s1.size(); i < N; i++){\\n            if(isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)) ) return _memo[s1][s2]=true;\\n            if(isScramble(s1.substr(0, i), s2.substr(N-i)) && isScramble(s1.substr(i), s2.substr(0, N-i)) ) return _memo[s1][s2]=true;\\n        }\\n        return _memo[s1][s2] = false;\\n    }\\n    \\nprivate:\\n    unordered_map<string, unordered_map<string, bool> > _memo;\\n    vector<int> Counter(string& s){\\n        vector<int> ans(26,0);\\n        for(auto c: s) ++ans[c-\\'a\\'];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    @lru_cache(None)\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if s1 == s2: return True\\n        if Counter(s1) != Counter(s2): return False\\n        N = len(s1)\\n        for i in range(1, N):\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]): return True\\n            if self.isScramble(s1[:i], s2[N - i:]) and self.isScramble(s1[i:], s2[:N-i]): return True\\n        return False                  \\n```\n```\\nclass Solution: # Appraoch 2, BEST\\n    @cache\\n    def isScramble(self, s1: str, s2: str) -> bool:        \\n        #if sorted(s1)!=sorted(s2): return False #OK, but too expensive\\n        if s1 == s2: return True\\n        if Counter(s1)!=Counter(s2): return False        \\n        n = len(s1)\\n        for i in range(1,n):#OK, sub-problmens must be smaller than original problems.\\n        #for i in range(n-1): #ERR: maximum recursion depth exceeded in comparison\\n        #for i in range(n): # ERR: maximum recursion depth exceeded in comparison\\n            #case1: first i items vs. first i items, where i is [1, n-1]\\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\\n                return True\\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\\n                return True\\n        return False\\n\\n```\n```\\nclass Solution {// C++ version\\npublic: // string can be replace with string_view\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2) return true;\\n        if(Counter(s1) != Counter(s2)) return false;\\n        if(_memo.count(s1) && _memo[s1].count(s2)) return _memo[s1][s2];\\n        for(int i = 1, N = s1.size(); i < N; i++){\\n            if(isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)) ) return _memo[s1][s2]=true;\\n            if(isScramble(s1.substr(0, i), s2.substr(N-i)) && isScramble(s1.substr(i), s2.substr(0, N-i)) ) return _memo[s1][s2]=true;\\n        }\\n        return _memo[s1][s2] = false;\\n    }\\n    \\nprivate:\\n    unordered_map<string, unordered_map<string, bool> > _memo;\\n    vector<int> Counter(string& s){\\n        vector<int> ans(26,0);\\n        for(auto c: s) ++ans[c-\\'a\\'];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568607,
                "title": "java-code-recursion-memo-mcm-type",
                "content": "class Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length()!=s2.length()){\\n            return false ; \\n        }\\n        \\n        return s(s1,s2);\\n        \\n        \\n    }\\n static HashMap<String,Boolean> map = new HashMap<>();\\n\\n    public boolean s(String s1, String s2){\\n        if(s1.equals(s2)){\\n            return true ;\\n        }\\n        if(s1.length()<=1) return false ;\\n        \\n       String key=s1+\" \"+s2;\\n\\n        if(map.containsKey(key)) {\\n            return map.get(key);\\n        }\\n        \\n       boolean isflag = false ;\\n        for(int k=1;k<s1.length();k++){\\n       boolean a = s(s1.substring(0,k),s2.substring(0,k)) && s(s1.substring(k),s2.substring(k));\\n       boolean b = s(s1.substring(0,k),s2.substring(s1.length()-k)) && s(s1.substring(k),s2.substring(0,s1.length()-k));  \\n          if(a||b){\\n             isflag = true ;\\n          }                                                                   \\n        }\\n         map.put(key, isflag);\\n\\n        return isflag ;\\n    }\\n}\\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "class Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length()!=s2.length()){\\n            return false ; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1530280,
                "title": "c-memoization-using-map-o-n-3-time-mcm",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool>m;\\n    bool isScramble(string a, string b){\\n        if(a==b)\\n            return true;\\n        if(a.size()!=b.size())\\n            return false;\\n        if(a.size()==1)\\n            return false; \\n        string key=a+\" \"+b;\\n        if(m.find(key)!=m.end())\\n            return m[key];\\n        bool flag=false;\\n        for(int i=1;i<a.size();i++){\\n            bool cond1=(isScramble(a.substr(0,i), b.substr(a.size()-i, i)) &&  isScramble(a.substr(i,a.size()-i), b.substr(0, a.size()-i)));\\n            bool cond2=(isScramble(a.substr(0,i), b.substr(0,i)) && isScramble(a.substr(i,a.size()-i), b.substr(i,a.size()-i)));\\n\\t\\t\\t\\n            if(cond1 || cond2){\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return m[key]=flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool>m;\\n    bool isScramble(string a, string b){\\n        if(a==b)\\n            return true;\\n        if(a.size()!=b.size())\\n            return false;\\n        if(a.size()==1)\\n            return false; \\n        string key=a+\" \"+b;\\n        if(m.find(key)!=m.end())\\n            return m[key];\\n        bool flag=false;\\n        for(int i=1;i<a.size();i++){\\n            bool cond1=(isScramble(a.substr(0,i), b.substr(a.size()-i, i)) &&  isScramble(a.substr(i,a.size()-i), b.substr(0, a.size()-i)));\\n            bool cond2=(isScramble(a.substr(0,i), b.substr(0,i)) && isScramble(a.substr(i,a.size()-i), b.substr(i,a.size()-i)));\\n\\t\\t\\t\\n            if(cond1 || cond2){\\n                flag=true;\\n                break;\\n            }\\n        }\\n        return m[key]=flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453949,
                "title": "python-solution",
                "content": "class Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        memo={}\\n        \\n        def dfs(s1,s2):\\n            if (s1+s2) in memo:return memo[s1+s2]\\n            if len(s1)==1:\\n                return s1==s2\\n            \\n            if s1==s2:\\n                return True\\n            \\n            n=len(s1)\\n        \\n            for i in range(1,n):\\n                if (dfs(s1[:i],s2[:i]) and dfs(s1[i:],s2[i:])) or (dfs(s1[:i],s2[n-i:]) and dfs(s1[i:],s2[:n-i])):\\n                    memo[s1+s2]=True\\n                    return memo[s1+s2]\\n        \\n            memo[s1+s2]=False\\n            return False\\n    \\n        return dfs(s1,s2)\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        memo={}",
                "codeTag": "Java"
            },
            {
                "id": 1399920,
                "title": "java-easy-memoization-solution",
                "content": "class Solution {\\n\\n    private HashMap<String, Boolean> map;\\n    public boolean isScramble(String s1, String s2) {\\n        this.map = new HashMap<>();\\n        boolean ans = helper(s1, s2);\\n        return ans;\\n    }\\n    private boolean helper(String str1, String str2){\\n        int n = str1.length();\\n        if(str1.equals(str2)){\\n            map.put(str1 + \"&\" + str2, true);\\n            return true;\\n        }\\n        if(n == 1){\\n            map.put(str1 + \"&\" + str2, false);\\n            return false;\\n        }\\n        if(map.containsKey(str1 + \"&\" + str2)){\\n            return map.get(str1 + \"&\" + str2);\\n        }\\n        Boolean ans = false;\\n        for(int i = 1; i < n; i++){\\n            boolean ans1 = helper(str1.substring(0, i), str2.substring(0, i)) \\n                && helper(str1.substring(i), str2.substring(i));\\n            boolean ans2 = helper(str1.substring(0, i), str2.substring(n-i)) \\n                && helper(str1.substring(i), str2.substring(0, n-i));\\n            \\n            if(ans1 || ans2){\\n                ans = true;\\n                break;\\n            }\\n        }\\n        map.put(str1 + \"&\" + str2, ans);\\n        return ans;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\n    private HashMap<String, Boolean> map;\\n    public boolean isScramble(String s1, String s2) {\\n        this.map = new HashMap<>();\\n        boolean ans = helper(s1, s2);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1392093,
                "title": "c-recursive-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    map<string,bool> mp;\\n    bool isScramble(string s1, string s2) {\\n    if(s1==s2) return true;\\n    int cnt[26] ={};\\n    \\n    string s = s1+\\'-\\'+s2;\\n    if(mp.find(s)!=mp.end()) return mp[s];\\n    if(s1.length()!=s2.length()) return false;\\n    for(int i =0; i<s1.length(); i++){\\n        cnt[s1[i]-\\'a\\']++;\\n        cnt[s2[i]-\\'a\\']--;\\n    }\\n        \\n    for(int i=0; i<26; i++)\\n        {\\n            if(cnt[i]!=0)\\n                return false;\\n        }\\n    int len = s1.length();\\n    bool flag = false;\\n    for(int i =1; i<=len-1; i++){\\n        if(isScramble(s1.substr(0,i),s2.substr(0,i))&& isScramble(s1.substr(i),s2.substr(i))) flag =  true; \\n        if(isScramble(s1.substr(0,i),s2.substr(len-i))&& isScramble(s1.substr(i),s2.substr(0,len-i))) flag = true; \\n    }\\n    mp[s] = flag;\\n    return flag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    map<string,bool> mp;\\n    bool isScramble(string s1, string s2) {\\n    if(s1==s2) return true;\\n    int cnt[26] ={};\\n    \\n    string s = s1+\\'-\\'+s2;\\n    if(mp.find(s)!=mp.end()) return mp[s];\\n    if(s1.length()!=s2.length()) return false;\\n    for(int i =0; i<s1.length(); i++){\\n        cnt[s1[i]-\\'a\\']++;\\n        cnt[s2[i]-\\'a\\']--;\\n    }\\n        \\n    for(int i=0; i<26; i++)\\n        {\\n            if(cnt[i]!=0)\\n                return false;\\n        }\\n    int len = s1.length();\\n    bool flag = false;\\n    for(int i =1; i<=len-1; i++){\\n        if(isScramble(s1.substr(0,i),s2.substr(0,i))&& isScramble(s1.substr(i),s2.substr(i))) flag =  true; \\n        if(isScramble(s1.substr(0,i),s2.substr(len-i))&& isScramble(s1.substr(i),s2.substr(0,len-i))) flag = true; \\n    }\\n    mp[s] = flag;\\n    return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306162,
                "title": "0ms-c-solution",
                "content": "```\\nstatic char *s_lookup, *s_s1, *s_s2;\\nstatic int s_len;\\n\\nint CheckSramble(char *current, char *target, int len)\\n{\\n    char *flag=s_lookup+((current-s_s1)*s_len+target-s_s2)*s_len+len;\\n    if(*flag!=-1) return *flag;\\n    if(!memcmp(current, target, len)) return *flag=1;\\n    int char_table_s1_head[26]={};\\n    int char_table_s2_head[26]={};\\n    int char_table_s2_tail[26]={};\\n    for(int i=1;i<len;i++)\\n    {\\n        char_table_s1_head[current[i-1]-\\'a\\']++;\\n        char_table_s2_head[target[i-1]-\\'a\\']++;  \\n        if(!memcmp(char_table_s1_head, char_table_s2_head, sizeof(char_table_s1_head)))\\n            if(CheckSramble(current, target, i) && CheckSramble(current+i, target+i, len-i))\\n                return *flag=1;\\n        char_table_s2_tail[target[len-i]-\\'a\\']++;\\n        if(!memcmp(char_table_s1_head, char_table_s2_tail, sizeof(char_table_s1_head)))\\n            if(CheckSramble(current+i, target, len-i) && CheckSramble(current, target+len-i, i))\\n                return *flag=1;\\n    }\\n    return *flag=0;\\n}\\n\\nbool isScramble(char * s1, char * s2){\\n    int len=strlen(s1);\\n    int char_table_s1[26]={};\\n    int char_table_s2[26]={};\\n    for(int i=0;i<len;i++)\\n    {\\n        char_table_s1[s1[i]-\\'a\\']++;\\n        char_table_s2[s2[i]-\\'a\\']++;\\n    }\\n    if(memcmp(char_table_s1, char_table_s2, sizeof(char_table_s1))) return false;\\n    s_len=len+1;\\n    s_lookup=(char*)malloc(s_len*s_len*s_len);\\n    memset(s_lookup, -1, s_len*s_len*s_len);\\n    s_s1=s1, s_s2=s2;\\n    bool ret=CheckSramble(s1, s2, len);\\n    free(s_lookup);\\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstatic char *s_lookup, *s_s1, *s_s2;\\nstatic int s_len;\\n\\nint CheckSramble(char *current, char *target, int len)\\n{\\n    char *flag=s_lookup+((current-s_s1)*s_len+target-s_s2)*s_len+len;\\n    if(*flag!=-1) return *flag;\\n    if(!memcmp(current, target, len)) return *flag=1;\\n    int char_table_s1_head[26]={};\\n    int char_table_s2_head[26]={};\\n    int char_table_s2_tail[26]={};\\n    for(int i=1;i<len;i++)\\n    {\\n        char_table_s1_head[current[i-1]-\\'a\\']++;\\n        char_table_s2_head[target[i-1]-\\'a\\']++;  \\n        if(!memcmp(char_table_s1_head, char_table_s2_head, sizeof(char_table_s1_head)))\\n            if(CheckSramble(current, target, i) && CheckSramble(current+i, target+i, len-i))\\n                return *flag=1;\\n        char_table_s2_tail[target[len-i]-\\'a\\']++;\\n        if(!memcmp(char_table_s1_head, char_table_s2_tail, sizeof(char_table_s1_head)))\\n            if(CheckSramble(current+i, target, len-i) && CheckSramble(current, target+len-i, i))\\n                return *flag=1;\\n    }\\n    return *flag=0;\\n}\\n\\nbool isScramble(char * s1, char * s2){\\n    int len=strlen(s1);\\n    int char_table_s1[26]={};\\n    int char_table_s2[26]={};\\n    for(int i=0;i<len;i++)\\n    {\\n        char_table_s1[s1[i]-\\'a\\']++;\\n        char_table_s2[s2[i]-\\'a\\']++;\\n    }\\n    if(memcmp(char_table_s1, char_table_s2, sizeof(char_table_s1))) return false;\\n    s_len=len+1;\\n    s_lookup=(char*)malloc(s_len*s_len*s_len);\\n    memset(s_lookup, -1, s_len*s_len*s_len);\\n    s_s1=s1, s_s2=s2;\\n    bool ret=CheckSramble(s1, s2, len);\\n    free(s_lookup);\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280605,
                "title": "scramble-string-easy-c",
                "content": "Question :Given two strings S1 and S2 of equal length, the task is to determine if S2 is a scrambled       form of S1.\\n**Scrambled string:** \\n* Given string str, we can represent it as a binary tree by partitioning it to two non-empty substrings recursively.\\n* Note: Srambled string is not same as an Anagram\\nEg Below is one possible representation of str = \\u201Ccoder\\u201D:\\n```\\n    coder\\n   /    \\\\\\n  co    der\\n / \\\\    /  \\\\\\nc   o  d   er\\n           / \\\\\\n          e   r\\n```\\nTo scramble the string, we may choose any non-leaf node and swap its two children. \\nSuppose, we choose the node \\u201Cco\\u201D and swap its two children, it produces a scrambled string \\u201Cocder\\u201D.\\n```\\n  ocder\\n   /    \\\\\\n  oc    der\\n / \\\\    /  \\\\\\no   c  d   er\\n           / \\\\\\n          e   r\\n```\\n**Thus, \\u201Cocder\\u201D is a scrambled string of \\u201Ccoder\\u201D.**\\n* Note : No of swwaps we can do is >=0\\n* Now we can see there are 2 cases possible : \\n* **Case 1 : No swapping** \\nEg \"coder\" & \"coder\" are 2 strambled strings\\n* **Case 2: Swappig**\\nSee the above tree for this case\\n\\n\\n### Recurisve approach\\n* Since there are many possible combinations in which the strings can be scrambled the only way is to use recursion to calculate the answer.\\n* The main idea is to divide the string \\'S\\' into two substrings with length \\u2018i\\u2019 and \\u2018LEN - i\\u2019, where \\u2018LEN\\u2019 is the length of the original string \\'S\\', and check recursively if the two substrings X = S[0\\u2026.i - 1] and Y = S[i\\u2026 LEN - 1] form some scramble to generate \\'R\\'.\\n* So we traverse i (length of the substr) from 1 to LEN-1\\n* Eg i=1 for \"coder\" splits it into \"c\" & \"oder\" and then we can check recursively & swap/not swap to check for scramble condition\\n* i=0 would have spit the string \"coder\" into \"\" & \"coder\" which is not allowed as said in the question ...**we can only swap non leaf nod**es  \\n* Let ISSCRAMBLE(\\'S\\', \\'R\\') be the recursive function that returns true if \\'R\\' is a scramble of \\'S\\' else it returns false.\\n* Now we will generate all the possible substrings of \\'S\\' and check whether they form a scramble or not.\\n* If \\'S\\' is equal to \\'R\\', then return true. It is the base case. Or if the current \\'S\\' has length = 1, then also we need to return true or false depending upon its equality with its counterpart in \\'R\\'.\\n* Let\\u2019s say that we cut the string \\'S\\' at index i. Now there are two options.\\nS[0, i] scrambles into R[0, i] and S[i, N] can scramble into R[i,N].    // No Swapping\\nS[0, i] can scramble into R[i + 1, N] and S[i, N] can scramble into R[0, N - i    // Swapping\\n### Recusrive Code\\n```\\n bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n {\\n// no swap\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) \\nreturn true;\\n\\n// swap\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))\\nreturn true;\\n        }\\n        return false;\\n    }\\n```\\n### Optimized Recursion\\n\\n* An optimization step to consider here is to check beforehand if the two strings are anagrams of each other. If not, it indicates that the strings contain different characters and can\\u2019t be a scrambled form of each other\\n### Code\\n```\\n bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n        \\n\\t\\t// checking for not anagrams \\n          int count[26] = {0};\\n        for(int i=0; i<n; i++){\\n            count[s1[i]-\\'a\\']++;\\n            count[s2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(count[i]!=0)\\n                return false;\\n        }\\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n        {\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) return true;\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))return true;\\n        }\\n        return false;\\n    }\\n```\\n### Memoization (172 ms)\\n* We \\'ll take a map with the concatenation of both strings as key and if both keys were already processed before in the previous recusion calls then no need to call the recusive function for that part , we can simply return from the map itself\\n```\\nunordered_map<string,bool> mp;\\n    bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n       \\n        if(mp.find(s1+s2)!=mp.end())\\n            return mp[s1+s2];\\n        \\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n        {\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) return mp[s1+s2] = true;\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))return mp[s1+s2] = true;\\n        }\\n        return mp[s1+s2]=false;\\n    }\\n```\\n### Memoization with optimization\\n* We can check for the anagram condition too & this will reduce the time complexity significantly\\n* Just add this code \\n```\\n  string temp1 = s1;\\n    string temp2 = s2;\\n    sort(temp1.begin(), temp1.end());\\n    sort(temp2.begin(), temp2.end());\\n     \\n    if(temp1.compare(temp2) != 0) return false;\\n```\\n### OR\\n```\\n int count[26] = {0};\\n        for(int i=0; i<n; i++){\\n            count[s1[i]-\\'a\\']++;\\n            count[s2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(count[i]!=0)\\n                return false;\\n        }\\n```\\n### Therefore Final Memoized Code with Optimization( 8 ms)\\n```\\nunordered_map<string,bool> mp;\\n    bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n        \\n    string temp1 = s1;\\n    string temp2 = s2;\\n    sort(temp1.begin(), temp1.end());\\n    sort(temp2.begin(), temp2.end());\\n     \\n    if(temp1.compare(temp2) != 0) return false;\\n       \\n        if(mp.find(s1+s2)!=mp.end())\\n            return mp[s1+s2];\\n        \\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n        {\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) return mp[s1+s2] = true;\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))return mp[s1+s2] = true;\\n        }\\n        return mp[s1+s2]=false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    coder\\n   /    \\\\\\n  co    der\\n / \\\\    /  \\\\\\nc   o  d   er\\n           / \\\\\\n          e   r\\n```\n```\\n  ocder\\n   /    \\\\\\n  oc    der\\n / \\\\    /  \\\\\\no   c  d   er\\n           / \\\\\\n          e   r\\n```\n```\\n bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n {\\n// no swap\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) \\nreturn true;\\n\\n// swap\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))\\nreturn true;\\n        }\\n        return false;\\n    }\\n```\n```\\n bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n        \\n\\t\\t// checking for not anagrams \\n          int count[26] = {0};\\n        for(int i=0; i<n; i++){\\n            count[s1[i]-\\'a\\']++;\\n            count[s2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(count[i]!=0)\\n                return false;\\n        }\\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n        {\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) return true;\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))return true;\\n        }\\n        return false;\\n    }\\n```\n```\\nunordered_map<string,bool> mp;\\n    bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n       \\n        if(mp.find(s1+s2)!=mp.end())\\n            return mp[s1+s2];\\n        \\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n        {\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) return mp[s1+s2] = true;\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))return mp[s1+s2] = true;\\n        }\\n        return mp[s1+s2]=false;\\n    }\\n```\n```\\n  string temp1 = s1;\\n    string temp2 = s2;\\n    sort(temp1.begin(), temp1.end());\\n    sort(temp2.begin(), temp2.end());\\n     \\n    if(temp1.compare(temp2) != 0) return false;\\n```\n```\\n int count[26] = {0};\\n        for(int i=0; i<n; i++){\\n            count[s1[i]-\\'a\\']++;\\n            count[s2[i]-\\'a\\']--;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(count[i]!=0)\\n                return false;\\n        }\\n```\n```\\nunordered_map<string,bool> mp;\\n    bool isScramble(string s1, string s2) {\\n        \\n        if(s1.length()!=s2.length())\\n            return false;\\n        int n=s1.length();\\n        if(n==0)return true;\\n        if(s1==s2)return true;\\n        \\n    string temp1 = s1;\\n    string temp2 = s2;\\n    sort(temp1.begin(), temp1.end());\\n    sort(temp2.begin(), temp2.end());\\n     \\n    if(temp1.compare(temp2) != 0) return false;\\n       \\n        if(mp.find(s1+s2)!=mp.end())\\n            return mp[s1+s2];\\n        \\n        \\n        for(int i=1;i<=n-1;i++)   // i deotes the length of the substr\\n        {\\nif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,n-i),s2.substr(i,n-i))) return mp[s1+s2] = true;\\nif(isScramble(s1.substr(0,i),s2.substr(n-i,i)) && isScramble(s1.substr(i,n-1),s2.substr(0,n-i)))return mp[s1+s2] = true;\\n        }\\n        return mp[s1+s2]=false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1161093,
                "title": "real-dynamic-programming-solution",
                "content": "This question is really difficult for DP solution, I\\'m not good as English writing. We need is a 3-D DP matrix `dp[i][j][k]`, ` i, j` is index from s1 and s2 respectively, and k represents length. We will start from k == 1 (length == 1). Thus `dp[i][j][1] = True` if `s1[i] == s2[j]`.\\nThen come to situations that k > 1, use `w: range(1, k)` to \\'cut\\' strings s1 and s2 which start from index i, j and length equals to k into two parts:\\n`s1[i: i+k] -> s1[i: i+w], s1[i+w: i+k]`\\n`s2[j: j+k] -> s2[j: j+w], s2[j+w: j+k]`\\nor\\n`s1[i: i+k] -> s1[i: i+w], s1[i+w: i+k]`\\n`s2[j: j+k] -> s2[j: j+k-w], s2[j+k-w: j+k]`\\n\\n`dp[i][j][k] = True` if `(dp[i][j][w] and dp[i+w][j+w][k-w]) or (dp[i][j+k-w][w] and dp[i+w][j][k-w])` is True.\\n```\\nfrom itertools import product\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        lt = len(s1) # len(s1) == len(s2)\\n        # 3-D DP matrix\\n        dp = [[[False]*(lt + 1) for _ in range(lt)] for _ in range(lt)]\\n\\t\\t# Initialize DP matrix\\n        for i, j in product(range(lt), range(lt)):\\n            dp[i][j][1] = s1[i] == s2[j]\\n\\t\\t\\n        for k in range(2, lt + 1):\\n            for i in range(lt - k + 1):\\n                for j in range(lt - k + 1):\\n                    for w in range(1, k):\\n                        # \\u540E\\u534A\\u6BB5dp[i][j+k-w][w] and dp[i+w][j][k-w]\\u6BD4\\u8F83\\u62BD\\u8C61\\uFF0C\\u5EFA\\u8BAE\\u5728\\u7EB8\\u4E0A\\u753B\\u51FA\\u6765\\n                        if (dp[i][j][w] and dp[i+w][j+w][k-w]) or (dp[i][j+k-w][w] and dp[i+w][j][k-w]):\\n                            dp[i][j][k] = True\\n                            break\\n        return dp[0][0][lt]\\n```\\n\\nIt\\'s much easier to figure a recursion solution:\\n```\\nclass Solution:\\n    @functools.lru_cache(None)\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if sorted(s1) != sorted(s2): return False\\n        l = len(s1)\\n        if l < 4 or s1 == s2: return True\\n        f = self.isScramble\\n        for i in range(1, l):\\n            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\\\\n                f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\\n                return True\\n        return False\\n```\\nor we can use hash map to replace `@functools.lru_cache(None)`\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.dic = {}\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        k = (s1, s2)\\n        if k in self.dic: return self.dic[k]\\n        if sorted(s1) != sorted(s2):\\n            self.dic[k] = False\\n            return False\\n        l = len(s1)\\n        if l < 4 or s1 == s2:\\n            self.dic[k] = True\\n            return True\\n        f = self.isScramble\\n        for i in range(1, l):\\n            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\\\\n                f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\\n                self.dic[k] = True\\n                return True\\n        self.dic[k] = False\\n        return False\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nfrom itertools import product\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        lt = len(s1) # len(s1) == len(s2)\\n        # 3-D DP matrix\\n        dp = [[[False]*(lt + 1) for _ in range(lt)] for _ in range(lt)]\\n\\t\\t# Initialize DP matrix\\n        for i, j in product(range(lt), range(lt)):\\n            dp[i][j][1] = s1[i] == s2[j]\\n\\t\\t\\n        for k in range(2, lt + 1):\\n            for i in range(lt - k + 1):\\n                for j in range(lt - k + 1):\\n                    for w in range(1, k):\\n                        # \\u540E\\u534A\\u6BB5dp[i][j+k-w][w] and dp[i+w][j][k-w]\\u6BD4\\u8F83\\u62BD\\u8C61\\uFF0C\\u5EFA\\u8BAE\\u5728\\u7EB8\\u4E0A\\u753B\\u51FA\\u6765\\n                        if (dp[i][j][w] and dp[i+w][j+w][k-w]) or (dp[i][j+k-w][w] and dp[i+w][j][k-w]):\\n                            dp[i][j][k] = True\\n                            break\\n        return dp[0][0][lt]\\n```\n```\\nclass Solution:\\n    @functools.lru_cache(None)\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if sorted(s1) != sorted(s2): return False\\n        l = len(s1)\\n        if l < 4 or s1 == s2: return True\\n        f = self.isScramble\\n        for i in range(1, l):\\n            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\\\\n                f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\\n                return True\\n        return False\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.dic = {}\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        k = (s1, s2)\\n        if k in self.dic: return self.dic[k]\\n        if sorted(s1) != sorted(s2):\\n            self.dic[k] = False\\n            return False\\n        l = len(s1)\\n        if l < 4 or s1 == s2:\\n            self.dic[k] = True\\n            return True\\n        f = self.isScramble\\n        for i in range(1, l):\\n            if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\\\\n                f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\\n                self.dic[k] = True\\n                return True\\n        self.dic[k] = False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030883,
                "title": "java-2ms-recursive-memoization-frequency-check",
                "content": "```\\n    Map<String, Boolean> memo = new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.equals(s2))\\n            return true;\\n        if(!equalByFreq(s1, s2))\\n            return false;\\n        \\n        String key = s1+s2;\\n        if(memo.containsKey(key))\\n            return memo.get(key);\\n        \\n        int len1 = s1.length(), len2 = s2.length();\\n        boolean match = false;\\n        for(int i = 1; i < s1.length(); i++){\\n            String p1 = s1.substring(0,i);\\n            String p2 = s1.substring(i);\\n            \\n            match = isScramble(p1, s2.substring(0, i)) && isScramble(p2, s2.substring(i));\\n            if(match)\\n                break;\\n            match = isScramble(p1, s2.substring(len2-i)) && isScramble(p2, s2.substring(0, len2-i));\\n            if(match)\\n                break;\\n        }\\n        \\n        memo.put(key, match);\\n        return match;\\n    }\\n    \\n    public boolean equalByFreq(String s1, String s2){\\n        int xor = 0;\\n        for(int i= 0; i < s1.length(); i++){\\n            xor ^= (s1.charAt(i)-\\'a\\')^(s2.charAt(i)-\\'a\\');\\n        }\\n        return xor == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Map<String, Boolean> memo = new HashMap<>();\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.equals(s2))\\n            return true;\\n        if(!equalByFreq(s1, s2))\\n            return false;\\n        \\n        String key = s1+s2;\\n        if(memo.containsKey(key))\\n            return memo.get(key);\\n        \\n        int len1 = s1.length(), len2 = s2.length();\\n        boolean match = false;\\n        for(int i = 1; i < s1.length(); i++){\\n            String p1 = s1.substring(0,i);\\n            String p2 = s1.substring(i);\\n            \\n            match = isScramble(p1, s2.substring(0, i)) && isScramble(p2, s2.substring(i));\\n            if(match)\\n                break;\\n            match = isScramble(p1, s2.substring(len2-i)) && isScramble(p2, s2.substring(0, len2-i));\\n            if(match)\\n                break;\\n        }\\n        \\n        memo.put(key, match);\\n        return match;\\n    }\\n    \\n    public boolean equalByFreq(String s1, String s2){\\n        int xor = 0;\\n        for(int i= 0; i < s1.length(); i++){\\n            xor ^= (s1.charAt(i)-\\'a\\')^(s2.charAt(i)-\\'a\\');\\n        }\\n        return xor == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1011971,
                "title": "accepted-python-solution-with-template-method",
                "content": "Despite the misleading word \"randomly\" in the description, this problem is a typical problem that can be solved by **memory+dfs**, in other words, **dynamic programming**.\\n\\nwe use ```memo``` to store the sub-problem already known, and function ```dfs(s1, s2)``` to solve the problem recursively.\\n\\nFor a recursive function, we need to figure out several simple cases that can return the answer directly, and some difficult cases.\\n1. We sort the ```s1``` and ```s2```, if ```s1!=s2```, return ```false``` because in this case, ```s1```miss some letters in ```s2```.\\n2. If ```s1 == s2```, ok they are same so return ```true```.\\n3. Else, we try every possible position to swap or not, to see if we can find a ```true``` case. Note once we find a ```true``` case, we do not need to test anymore, we can return ```true``` immediately.\\n\\nHere is my code:\\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        memo = {}\\n        def dfs(s1, s2):\\n            if (s1, s2) not in memo:\\n                if sorted(s1) != sorted(s2):\\n                    flag = False\\n                elif s1 == s2:\\n                    flag = True\\n                else:\\n                    for i in range(1, len(s1)):\\n                        flag = (dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:])) \\\\\\n                                or (dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i]))\\n                        if flag:\\n                            break\\n                memo[s1,s2] = flag\\n            return memo[s1,s2]\\n              \\n        return dfs(s1, s2)\\n```\\nAlso, you can solve the [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/) and [Edit Distance](https://leetcode.com/problems/edit-distance/) with the same template method.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```memo```\n```dfs(s1, s2)```\n```s1```\n```s2```\n```s1!=s2```\n```false```\n```s1```\n```s2```\n```s1 == s2```\n```true```\n```true```\n```true```\n```true```\n```\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        memo = {}\\n        def dfs(s1, s2):\\n            if (s1, s2) not in memo:\\n                if sorted(s1) != sorted(s2):\\n                    flag = False\\n                elif s1 == s2:\\n                    flag = True\\n                else:\\n                    for i in range(1, len(s1)):\\n                        flag = (dfs(s1[:i], s2[:i]) and dfs(s1[i:], s2[i:])) \\\\\\n                                or (dfs(s1[:i], s2[-i:]) and dfs(s1[i:], s2[:-i]))\\n                        if flag:\\n                            break\\n                memo[s1,s2] = flag\\n            return memo[s1,s2]\\n              \\n        return dfs(s1, s2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894283,
                "title": "beats-100-time-short-and-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool shouldMatch(string s1,string s2)\\n    {\\n        int arr1[26]={0};\\n        int arr2[26]={0};\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            arr1[s1[i]-\\'a\\']++;\\n            arr2[s2[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr1[i]-arr2[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool isScramble(string s1, string s2) {\\n        if(s1==s2)\\n            return true;\\n        if(!shouldMatch(s1,s2))\\n            return false;\\n        bool b=false;\\n        for(int i=1;i<s1.length();i++)\\n        {\\n            b=b||(isScramble(s1.substr(0,i),s2.substr(0,i))&&(isScramble(s1.substr(i),s2.substr(i)))||(isScramble(s1.substr(0,i),s2.substr(s1.length()-i))&&(isScramble(s1.substr(i),s2.substr(0,s1.length()-i)))));\\n        }\\n        return b;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool shouldMatch(string s1,string s2)\\n    {\\n        int arr1[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 813790,
                "title": "javascript-recursive-with-dp",
                "content": "```\\nvar isScramble = function(s1, s2) {\\n    return helper(s1, s2, {})\\n};\\n\\nvar helper = function(s1, s2, dp) {\\n    if (dp[s1 + s2] != undefined || dp[s2 + s1] != undefined) {\\n        return dp[s1 + s2]\\n    } else if (s1 == s2) {\\n        return true\\n    } else if (s1.length != s2.length) {\\n        return false\\n    } else if (s1.length <= 1) {\\n        return s1 == s2\\n    }\\n    for (let i = 1; i < s1.length; i++) {\\n        if ((helper(s1.slice(0, i), s2.slice(0, i), dp) && helper(s1.slice(i), s2.slice(i), dp)) ||\\n            (helper(s1.slice(0, i), s2.slice(s1.length - i), dp) && helper(s1.slice(i), s2.slice(0, s1.length - i), dp))) {\\n            dp[s1 + s2] = true\\n            return true\\n        }\\n    }\\n    dp[s1 + s2] = false\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isScramble = function(s1, s2) {\\n    return helper(s1, s2, {})\\n};\\n\\nvar helper = function(s1, s2, dp) {\\n    if (dp[s1 + s2] != undefined || dp[s2 + s1] != undefined) {\\n        return dp[s1 + s2]\\n    } else if (s1 == s2) {\\n        return true\\n    } else if (s1.length != s2.length) {\\n        return false\\n    } else if (s1.length <= 1) {\\n        return s1 == s2\\n    }\\n    for (let i = 1; i < s1.length; i++) {\\n        if ((helper(s1.slice(0, i), s2.slice(0, i), dp) && helper(s1.slice(i), s2.slice(i), dp)) ||\\n            (helper(s1.slice(0, i), s2.slice(s1.length - i), dp) && helper(s1.slice(i), s2.slice(0, s1.length - i), dp))) {\\n            dp[s1 + s2] = true\\n            return true\\n        }\\n    }\\n    dp[s1 + s2] = false\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 772077,
                "title": "c-dp-solution",
                "content": "The method \"isomorphic\" tests whether two strings consist of the same set of chars.\\nThen we use three-dimensional dp. The first two dimensions represent the i th and j th position of string s1 and s2, respectively, and the third dimension represents the length of substring starting from i th and j th position. The bool stored in dp represents whether these two substrings is scramble.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isomorphic(string s1, string s2){\\n        int cnt1[26];\\n        int cnt2[26];\\n        memset(cnt1, 0, sizeof(cnt1));\\n        memset(cnt2, 0, sizeof(cnt2));\\n        for (int i=0; i<s1.length(); i++) cnt1[s1[i]-\\'a\\']++;\\n        for (int i=0; i<s2.length(); i++) cnt2[s2[i]-\\'a\\']++;\\n        for (int i=0; i<26; i++){\\n            if (cnt1[i] != cnt2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if (!isomorphic(s1, s2)) return false;\\n        int len = s1.length();\\n        bool dp[len+1][len+1][len+1];  \\n        for (int i=0; i<len; i++){\\n            for (int j=0; j<len; j++){\\n                for (int k=1; k<=len; k++){\\n                    dp[i][j][k] = false;\\n                }\\n            }\\n        }\\n        for (int k=1; k<=len; k++){\\n            for (int i=0; i<len; i++){\\n                for (int j=0; j<len; j++){\\n                    if (k+max(i, j)>len) break;\\n                    if (isomorphic(s1.substr(i, k), s2.substr(j, k))){\\n                        if (k<=3){\\n                            dp[i][j][k] = true;\\n                            continue;\\n                        }\\n                        bool res = false;\\n                        for (int t=1; t<k; t++){\\n                            bool good1 = dp[i][j][t] && dp[i+t][j+t][k-t];\\n                            bool good2 = dp[i][j+k-t][t] && dp[i+t][j][k-t];\\n                            res = res||good1||good2;\\n                            if (res) break;\\n                        }\\n                        dp[i][j][k] = res;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][len];\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isomorphic(string s1, string s2){\\n        int cnt1[26];\\n        int cnt2[26];\\n        memset(cnt1, 0, sizeof(cnt1));\\n        memset(cnt2, 0, sizeof(cnt2));\\n        for (int i=0; i<s1.length(); i++) cnt1[s1[i]-\\'a\\']++;\\n        for (int i=0; i<s2.length(); i++) cnt2[s2[i]-\\'a\\']++;\\n        for (int i=0; i<26; i++){\\n            if (cnt1[i] != cnt2[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isScramble(string s1, string s2) {\\n        if (!isomorphic(s1, s2)) return false;\\n        int len = s1.length();\\n        bool dp[len+1][len+1][len+1];  \\n        for (int i=0; i<len; i++){\\n            for (int j=0; j<len; j++){\\n                for (int k=1; k<=len; k++){\\n                    dp[i][j][k] = false;\\n                }\\n            }\\n        }\\n        for (int k=1; k<=len; k++){\\n            for (int i=0; i<len; i++){\\n                for (int j=0; j<len; j++){\\n                    if (k+max(i, j)>len) break;\\n                    if (isomorphic(s1.substr(i, k), s2.substr(j, k))){\\n                        if (k<=3){\\n                            dp[i][j][k] = true;\\n                            continue;\\n                        }\\n                        bool res = false;\\n                        for (int t=1; t<k; t++){\\n                            bool good1 = dp[i][j][t] && dp[i+t][j+t][k-t];\\n                            bool good2 = dp[i][j+k-t][t] && dp[i+t][j][k-t];\\n                            res = res||good1||good2;\\n                            if (res) break;\\n                        }\\n                        dp[i][j][k] = res;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0][len];\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725614,
                "title": "87-scramble-string-2-solutions-c-little-tricky-question-only",
                "content": "1: solution with recursion + memoization:\\n\\n```\\nclass Solution {\\npublic:\\n   unordered_map<string,bool>DP;\\n\\nbool solve(string s1,string s2){\\n   \\n    if(s1.compare(s2)==0)return 1;                  \\n    if(s1.size()<=1)return 0; \\n\\t\\n    string key=s1+\" \"+s2;\\n    if(DP.find(key)!=DP.end())\\n        return DP[key];\\n\\t\\n    bool ans=0;\\n    int n=s1.size();\\n    \\n    for(int i=1;i<n;i++)\\n    {\\n        bool temp1=solve(s1.substr(0,i),s2.substr(n-i,i)) && solve(s1.substr(i,n-i),s2.substr(0,n-i));\\n        \\n        bool temp2=solve(s1.substr(0,i),s2.substr(0,i)) && solve(s1.substr(i,n-i),s2.substr(i,n-i));\\n        \\n        ans=temp1||temp2;\\n        \\n        if(ans==1)\\n            break;\\n        \\n    }\\n    \\n    return DP[key]=ans;\\n}\\n\\nbool isScramble(string s1, string s2) \\n{\\n    if(s1.length()!=s2.length())\\n        return 0;\\n    if(s1.length()==0)\\n        return 1;\\n    \\n    return solve(s1,s2);    \\n}\\n};\\n```\\n2: Only recursive :\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool isScramble(string s1, string s2) {\\n        if(s1.length() != s2.length()){\\n            return false;\\n        }\\n        \\n        if(s1 == s2){\\n            return true;\\n        }\\n\\n        string temp1 = s1, temp2 = s2;\\n        sort(temp1.begin(),temp1.end());\\n        sort(temp2.begin(),temp2.end());\\n        if(temp1 != temp2){\\n            return false;\\n        }\\n        \\n        int L = s1.length();\\n        for(int i = 1; i < L; i++){\\n            if((isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,L-i),s2.substr(i,L-i))) ||\\n                (isScramble(s1.substr(0,i),s2.substr(L-i,i)) && isScramble(s1.substr(i,L-i),s2.substr(0,L-i)))){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   unordered_map<string,bool>DP;\\n\\nbool solve(string s1,string s2){\\n   \\n    if(s1.compare(s2)==0)return 1;                  \\n    if(s1.size()<=1)return 0; \\n\\t\\n    string key=s1+\" \"+s2;\\n    if(DP.find(key)!=DP.end())\\n        return DP[key];\\n\\t\\n    bool ans=0;\\n    int n=s1.size();\\n    \\n    for(int i=1;i<n;i++)\\n    {\\n        bool temp1=solve(s1.substr(0,i),s2.substr(n-i,i)) && solve(s1.substr(i,n-i),s2.substr(0,n-i));\\n        \\n        bool temp2=solve(s1.substr(0,i),s2.substr(0,i)) && solve(s1.substr(i,n-i),s2.substr(i,n-i));\\n        \\n        ans=temp1||temp2;\\n        \\n        if(ans==1)\\n            break;\\n        \\n    }\\n    \\n    return DP[key]=ans;\\n}\\n\\nbool isScramble(string s1, string s2) \\n{\\n    if(s1.length()!=s2.length())\\n        return 0;\\n    if(s1.length()==0)\\n        return 1;\\n    \\n    return solve(s1,s2);    \\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,bool>mp;\\n    bool isScramble(string s1, string s2) {\\n        if(s1.length() != s2.length()){\\n            return false;\\n        }\\n        \\n        if(s1 == s2){\\n            return true;\\n        }\\n\\n        string temp1 = s1, temp2 = s2;\\n        sort(temp1.begin(),temp1.end());\\n        sort(temp2.begin(),temp2.end());\\n        if(temp1 != temp2){\\n            return false;\\n        }\\n        \\n        int L = s1.length();\\n        for(int i = 1; i < L; i++){\\n            if((isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i,L-i),s2.substr(i,L-i))) ||\\n                (isScramble(s1.substr(0,i),s2.substr(L-i,i)) && isScramble(s1.substr(i,L-i),s2.substr(0,L-i)))){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 700242,
                "title": "98-faster-c-solution-recursion-with-memoization",
                "content": "class Solution {\\npublic:\\n    \\n    unordered_map<string,bool>DP;\\n    \\n    bool solve(string s1,string s2){\\n       \\n        if(s1.compare(s2)==0)return 1;                  \\n        if(s1.size()<=1)return 0; \\n\\t\\t\\n        string key=s1+\" \"+s2;\\n        if(DP.find(key)!=DP.end())\\n            return DP[key];\\n\\t\\t\\n        bool ans=0;\\n        int n=s1.size();\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            bool temp1=solve(s1.substr(0,i),s2.substr(n-i,i)) && solve(s1.substr(i,n-i),s2.substr(0,n-i));\\n            \\n            bool temp2=solve(s1.substr(0,i),s2.substr(0,i)) && solve(s1.substr(i,n-i),s2.substr(i,n-i));\\n            \\n            ans=temp1||temp2;\\n            \\n            if(ans==1)\\n                break;\\n            \\n        }\\n        \\n        return DP[key]=ans;\\n    }\\n\\t\\n    bool isScramble(string s1, string s2) \\n    {\\n        if(s1.length()!=s2.length())\\n            return 0;\\n        if(s1.length()==0)\\n            return 1;\\n        \\n        return solve(s1,s2);    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    unordered_map<string,bool>DP;\\n    \\n    bool solve(string s1,string s2){\\n       \\n        if(s1.compare(s2)==0)return 1;                  \\n        if(s1.size()<=1)return 0; \\n\\t\\t\\n        string key=s1+\" \"+s2;\\n        if(DP.find(key)!=DP.end())\\n            return DP[key];\\n\\t\\t\\n        bool ans=0;\\n        int n=s1.size();\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            bool temp1=solve(s1.substr(0,i),s2.substr(n-i,i)) && solve(s1.substr(i,n-i),s2.substr(0,n-i));\\n            \\n            bool temp2=solve(s1.substr(0,i),s2.substr(0,i)) && solve(s1.substr(i,n-i),s2.substr(i,n-i));\\n            \\n            ans=temp1||temp2;\\n            \\n            if(ans==1)\\n                break;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 676186,
                "title": "javascript-solution",
                "content": "```\\nvar isScramble = function (s1, s2) {\\n  if (s1 === s2) return true;\\n  if (!isAnagram(s1, s2)) return false;\\n\\n  // boundaries are because the substrings being non-empty is a requirement\\n  for (let i = 1; i < s1.length; ++i) {\\n    if (\\n      isScramble(s1.substr(0, i), s2.substr(0, i)) &&\\n      isScramble(s1.substr(i), s2.substr(i))\\n    )\\n      return true;\\n\\n    if (\\n      isScramble(s1.substr(0, i), s2.substr(s1.length - i)) &&\\n      isScramble(s1.substr(i), s2.substr(0, s1.length - i))\\n    )\\n      return true;\\n  }\\n  return false;\\n};\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n  const map = {};\\n\\n  for (let i = 0; i < s.length; ++i) {\\n    map[s[i]] ? map[s[i]]++ : (map[s[i]] = 1);\\n  }\\n\\n  for (let i = 0; i < t.length; ++i) {\\n    if (map[t[i]]) map[t[i]]--;\\n    else return false;\\n  }\\n\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isScramble = function (s1, s2) {\\n  if (s1 === s2) return true;\\n  if (!isAnagram(s1, s2)) return false;\\n\\n  // boundaries are because the substrings being non-empty is a requirement\\n  for (let i = 1; i < s1.length; ++i) {\\n    if (\\n      isScramble(s1.substr(0, i), s2.substr(0, i)) &&\\n      isScramble(s1.substr(i), s2.substr(i))\\n    )\\n      return true;\\n\\n    if (\\n      isScramble(s1.substr(0, i), s2.substr(s1.length - i)) &&\\n      isScramble(s1.substr(i), s2.substr(0, s1.length - i))\\n    )\\n      return true;\\n  }\\n  return false;\\n};\\n\\nfunction isAnagram(s, t) {\\n  if (s.length !== t.length) return false;\\n  const map = {};\\n\\n  for (let i = 0; i < s.length; ++i) {\\n    map[s[i]] ? map[s[i]]++ : (map[s[i]] = 1);\\n  }\\n\\n  for (let i = 0; i < t.length; ++i) {\\n    if (map[t[i]]) map[t[i]]--;\\n    else return false;\\n  }\\n\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540524,
                "title": "c-8ms-recursion",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isScramble(string s1, string s2) {\\n\\t\\t\\tif(s1==s2) return true;\\n\\t\\t\\tvector<int> cnt(26,0);\\n\\t\\t\\tint len1=s1.size(); \\n\\t\\t\\tfor(int i=0;i<len1;i++){\\n\\t\\t\\t\\tcnt[s1[i]-\\'a\\']++;\\n\\t\\t\\t\\tcnt[s2[i]-\\'a\\']--;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<cnt.size();i++){\\n\\t\\t\\t\\tif(cnt[i]!=0) return false;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=1;i<len1;i++){\\n\\n\\t\\t\\t\\tif(isScramble(s1.substr(0,i),s2.substr(0,i)) && isScramble(s1.substr(i),s2.substr(i))){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(isScramble(s1.substr(0,i),s2.substr(len1-i)) && isScramble(s1.substr(i),s2.substr(0,len1-i))){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\treturn false; \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isScramble(string s1, string s2) {\\n\\t\\t\\tif(s1==s2) return true;\\n\\t\\t\\tvector<int> cnt(26,0);\\n\\t\\t\\tint len1=s1.size(); \\n\\t\\t\\tfor(int i=0;i<len1;i++){\\n\\t\\t\\t\\tcnt[s1[i]-\\'a\\']++;\\n\\t\\t\\t\\tcnt[s2[i]-\\'a\\']--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 464410,
                "title": "java-recursive-solution",
                "content": "```\\n// The idea is that for s2 to be scramble of s1 we consider the tree\\n// representation of the strings and they will be scramble only if\\n// every subtree in their representations is either same or mirror\\n// Catch is that for node equality, the strings can be equal or anagrams.\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n     int n = s1.length(), m = s2.length();\\n     if(n != m) return false;\\n     if(n == 0) return true;\\n     if(s1.equals(s2)) return true;\\n      \\n     int[] freq = new int[26];\\n     for(int i = 0; i < n; i++){\\n      freq[s1.charAt(i) - 97]++;\\n      freq[s2.charAt(i) - 97]--;   \\n     }\\n     // if freq[i] != 0  => different characters, hence node equality condition is violated.\\n     for(int i = 0; i < n; i++)\\n      if(freq[s1.charAt(i) - 97] != 0) return false;\\n     \\n\\t // The following loop has conditions similar to what we use for mirror trees.\\n     for(int i = 1; i < n; i++){\\n       if(isScramble(s1.substring(0,i),s2.substring(0,i))\\n       && isScramble(s1.substring(i),s2.substring(i)))\\n        return true;\\n       if(isScramble(s1.substring(0,i),s2.substring(n - i))\\n         && isScramble(s1.substring(i),s2.substring(0,n - i)))\\n        return true;   \\n     }\\n     return false;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// The idea is that for s2 to be scramble of s1 we consider the tree\\n// representation of the strings and they will be scramble only if\\n// every subtree in their representations is either same or mirror\\n// Catch is that for node equality, the strings can be equal or anagrams.\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n     int n = s1.length(), m = s2.length();\\n     if(n != m) return false;\\n     if(n == 0) return true;\\n     if(s1.equals(s2)) return true;\\n      \\n     int[] freq = new int[26];\\n     for(int i = 0; i < n; i++){\\n      freq[s1.charAt(i) - 97]++;\\n      freq[s2.charAt(i) - 97]--;   \\n     }\\n     // if freq[i] != 0  => different characters, hence node equality condition is violated.\\n     for(int i = 0; i < n; i++)\\n      if(freq[s1.charAt(i) - 97] != 0) return false;\\n     \\n\\t // The following loop has conditions similar to what we use for mirror trees.\\n     for(int i = 1; i < n; i++){\\n       if(isScramble(s1.substring(0,i),s2.substring(0,i))\\n       && isScramble(s1.substring(i),s2.substring(i)))\\n        return true;\\n       if(isScramble(s1.substring(0,i),s2.substring(n - i))\\n         && isScramble(s1.substring(i),s2.substring(0,n - i)))\\n        return true;   \\n     }\\n     return false;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428968,
                "title": "java-beat-100-o-n-space-o-n-2-time",
                "content": "Some other posts are using the same idea, without any analysis of the time complexity. Beating 100% is not a solid poof that this is a good algorithm. If you know how to analyze the time complexity of this algorithm, could you leave some explanation? Your help is appreciated!\\n\\nYou can also refer to the following links using the same idea:\\nhttps://leetcode.com/problems/scramble-string/discuss/401844/My-C++-Code:-0-ms-Average-Case:-O(nlogn)-Worst-Case:-O(n2)\\nhttps://leetcode.com/problems/scramble-string/discuss/365579/java-100\\n\\n```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1 == null || s2 == null || s1.length() != s2.length()) {return false;}  \\n        int length = s1.length();\\n        if(length == 0) {return true;}\\n        return isScramble(s1, 0, length - 1, s2, 0, length - 1);\\n    }\\n    \\n    private boolean isScramble(String s1, int startIdx1, int endIdx1, String s2, int startIdx2, int endIdx2) {\\n        if(startIdx1 == endIdx1) {return s1.charAt(startIdx1) == s2.charAt(startIdx2);}\\n        \\n        int i = startIdx1, j = startIdx2, count = 0;\\n        int[] counts = new int[128];\\n\\t\\t// find substrings that contain the same characters\\n\\t\\t// you can refer to problem 76. Minimum Window Substring to find out the trick here\\n        do {\\n            if(counts[s1.charAt(i++)]++ >= 0) {count++;}\\n            if(counts[s2.charAt(j++)]-- > 0) {count--;}\\n        } while(i < endIdx1 && count != 0);\\n        if(count == 0 && isScramble(s1, startIdx1, i - 1, s2, startIdx2, j - 1) &&\\n           isScramble(s1, i, endIdx1, s2, j, endIdx2)) {return true;}\\n        \\n        int i2 = startIdx1, j2 = endIdx2, count2 = 0;\\n        Arrays.fill(counts, 0);\\n        do {\\n            if(counts[s1.charAt(i2++)]++ >= 0) {count2++;}\\n            if(counts[s2.charAt(j2--)]-- > 0) {count2--;}\\n        } while(i2 < endIdx1 && count2 != 0);\\n        if(count2 == 0  && isScramble(s1, startIdx1, i2 - 1, s2, j2 + 1, endIdx2) &&\\n           isScramble(s1, i2, endIdx1, s2, startIdx2, j2)) {return true;}\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1 == null || s2 == null || s1.length() != s2.length()) {return false;}  \\n        int length = s1.length();\\n        if(length == 0) {return true;}\\n        return isScramble(s1, 0, length - 1, s2, 0, length - 1);\\n    }\\n    \\n    private boolean isScramble(String s1, int startIdx1, int endIdx1, String s2, int startIdx2, int endIdx2) {\\n        if(startIdx1 == endIdx1) {return s1.charAt(startIdx1) == s2.charAt(startIdx2);}\\n        \\n        int i = startIdx1, j = startIdx2, count = 0;\\n        int[] counts = new int[128];\\n\\t\\t// find substrings that contain the same characters\\n\\t\\t// you can refer to problem 76. Minimum Window Substring to find out the trick here\\n        do {\\n            if(counts[s1.charAt(i++)]++ >= 0) {count++;}\\n            if(counts[s2.charAt(j++)]-- > 0) {count--;}\\n        } while(i < endIdx1 && count != 0);\\n        if(count == 0 && isScramble(s1, startIdx1, i - 1, s2, startIdx2, j - 1) &&\\n           isScramble(s1, i, endIdx1, s2, j, endIdx2)) {return true;}\\n        \\n        int i2 = startIdx1, j2 = endIdx2, count2 = 0;\\n        Arrays.fill(counts, 0);\\n        do {\\n            if(counts[s1.charAt(i2++)]++ >= 0) {count2++;}\\n            if(counts[s2.charAt(j2--)]-- > 0) {count2--;}\\n        } while(i2 < endIdx1 && count2 != 0);\\n        if(count2 == 0  && isScramble(s1, startIdx1, i2 - 1, s2, j2 + 1, endIdx2) &&\\n           isScramble(s1, i2, endIdx1, s2, startIdx2, j2)) {return true;}\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394094,
                "title": "c-recursive-solution",
                "content": "```csharp\\npublic class Solution {\\n    public bool IsScramble(string s1, string s2) {\\n        // To avoid meaningless recursion, if charactors are not match, quit search\\n        var count = new int[26];\\n        foreach (var x in s1)\\n        {\\n            ++count[x - \\'a\\'];\\n        }\\n\\n        foreach (var x in s2)\\n        {\\n            --count[x - \\'a\\'];\\n        }\\n\\n        if (!count.All(x => x == 0))\\n        {\\n            return false;\\n        }\\n        /* End */\\n\\n        if (s1.Length <= 1) return true;\\n\\n        // Enum split points\\n        for (var i = 1; i < s1.Length; ++i)\\n        {\\n            // \\'gr rg\\' or \\'gr at\\'\\n            if (IsScramble(s1.Substring(0, i), s2.Substring(0, i))\\n                && IsScramble(s1.Substring(i), s2.Substring(i))\\n                || IsScramble(s1.Substring(0, i), s2.Substring(s2.Length - i))\\n                && IsScramble(s1.Substring(i), s2.Substring(0, s2.Length - i)))\\n            {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution {\\n    public bool IsScramble(string s1, string s2) {\\n        // To avoid meaningless recursion, if charactors are not match, quit search\\n        var count = new int[26];\\n        foreach (var x in s1)\\n        {\\n            ++count[x - \\'a\\'];\\n        }\\n\\n        foreach (var x in s2)\\n        {\\n            --count[x - \\'a\\'];\\n        }\\n\\n        if (!count.All(x => x == 0))\\n        {\\n            return false;\\n        }\\n        /* End */\\n\\n        if (s1.Length <= 1) return true;\\n\\n        // Enum split points\\n        for (var i = 1; i < s1.Length; ++i)\\n        {\\n            // \\'gr rg\\' or \\'gr at\\'\\n            if (IsScramble(s1.Substring(0, i), s2.Substring(0, i))\\n                && IsScramble(s1.Substring(i), s2.Substring(i))\\n                || IsScramble(s1.Substring(0, i), s2.Substring(s2.Length - i))\\n                && IsScramble(s1.Substring(i), s2.Substring(0, s2.Length - i)))\\n            {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339176,
                "title": "very-short-code-easy-to-understand-java-2ms",
                "content": "\\n```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        int[] check = new int[26];\\n        for(int i = 0; i < s1.length(); i++){\\n            char tmp = s1.charAt(i);\\n            check[tmp-\\'a\\']++;\\n        }\\n        for(int i = 0; i < s2.length(); i++){\\n            char tmp = s2.charAt(i);\\n            check[tmp-\\'a\\']--;\\n        }\\n        for(int val : check){\\n            if(val != 0) return false;\\n        }\\n        \\n        for(int i = 1; i < s1.length(); i++){  // < not <=\\n          \\n            if((isScramble(s1.substring(0, i), s2.substring(0, i)) && \\n                isScramble(s1.substring(i), s2.substring(i)))||\\n               (isScramble(s1.substring(0, i), s2.substring(s2.length()-i)) && \\n                isScramble(s1.substring(i), s2.substring(0,s2.length()-i))))\\n                return true;\\n        }\\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        int[] check = new int[26];\\n        for(int i = 0; i < s1.length(); i++){\\n            char tmp = s1.charAt(i);\\n            check[tmp-\\'a\\']++;\\n        }\\n        for(int i = 0; i < s2.length(); i++){\\n            char tmp = s2.charAt(i);\\n            check[tmp-\\'a\\']--;\\n        }\\n        for(int val : check){\\n            if(val != 0) return false;\\n        }\\n        \\n        for(int i = 1; i < s1.length(); i++){  // < not <=\\n          \\n            if((isScramble(s1.substring(0, i), s2.substring(0, i)) && \\n                isScramble(s1.substring(i), s2.substring(i)))||\\n               (isScramble(s1.substring(0, i), s2.substring(s2.length()-i)) && \\n                isScramble(s1.substring(i), s2.substring(0,s2.length()-i))))\\n                return true;\\n        }\\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327124,
                "title": "c-4ms-beat-96-with-explanation",
                "content": "**idea**\\n1. use a vector : ```s1_v``` to record s1\\'s char count from index ```0``` to ```i```.\\n2. use two vectors : \\n2.a ```s2_front``` to record s2\\'s char count from index ```0``` to ```i```.\\n2.b ```s2_back``` to record s2\\'s char count from index ```length()-i``` to ```end```\\n\\n```\\nif(s1_v == s2_front || s1_v == s2_back) : means scramble might exist when you cut at index-i\\n\\nso let\\'s divide into smaller problems :\\nif(s1_v == s2_front)\\n    isScramble(s1.front.substring,s2.front.substring) & isScramble(s1.back.substring,s2.back.substring)\\nelse if(s1_v == s2_back)\\n    isScramble(s1.front.substring,s2.back.substring) & isScramble(s1.back.substring,s2.front.substring)\\n```\\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2) return true; //ending condition\\n        int head = 0, size = s1.length();\\n        vector<int> s1_v(128,0),s2_front(128,0),s2_back(128,0);\\n        int any = 0;\\n        while(head < size-1){\\n            s1_v[s1[head]]++;\\n            s2_front[s2[head]]++;\\n            head++;\\n            s2_back[s2[size-head]]++;\\n            if(s1_v == s2_front)\\n                any |= isScramble(s1.substr(0,head),s2.substr(0,head)) & isScramble(s1.substr(head),s2.substr(head));\\n            else if(s1_v == s2_back)\\n                any |= isScramble(s1.substr(0,head),s2.substr(size-head)) & isScramble(s1.substr(head),s2.substr(0,size-head));\\n            if(any) //if any == false, this head position cannot make it happen. we need to go ahead to check next cutting index.\\n\\t\\t\\t    return true;\\n        }\\n        return any;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```s1_v```\n```0```\n```i```\n```s2_front```\n```0```\n```i```\n```s2_back```\n```length()-i```\n```end```\n```\\nif(s1_v == s2_front || s1_v == s2_back) : means scramble might exist when you cut at index-i\\n\\nso let\\'s divide into smaller problems :\\nif(s1_v == s2_front)\\n    isScramble(s1.front.substring,s2.front.substring) & isScramble(s1.back.substring,s2.back.substring)\\nelse if(s1_v == s2_back)\\n    isScramble(s1.front.substring,s2.back.substring) & isScramble(s1.back.substring,s2.front.substring)\\n```\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        if(s1 == s2) return true; //ending condition\\n        int head = 0, size = s1.length();\\n        vector<int> s1_v(128,0),s2_front(128,0),s2_back(128,0);\\n        int any = 0;\\n        while(head < size-1){\\n            s1_v[s1[head]]++;\\n            s2_front[s2[head]]++;\\n            head++;\\n            s2_back[s2[size-head]]++;\\n            if(s1_v == s2_front)\\n                any |= isScramble(s1.substr(0,head),s2.substr(0,head)) & isScramble(s1.substr(head),s2.substr(head));\\n            else if(s1_v == s2_back)\\n                any |= isScramble(s1.substr(0,head),s2.substr(size-head)) & isScramble(s1.substr(head),s2.substr(0,size-head));\\n            if(any) //if any == false, this head position cannot make it happen. we need to go ahead to check next cutting index.\\n\\t\\t\\t    return true;\\n        }\\n        return any;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316768,
                "title": "c-using-smart-slicing",
                "content": "What is the time complexity of this guy?\\n\\n```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        \\n        if (s1 == s2) { return true; }\\n        if (s1.size() != s2.size()) { return false; }\\n        \\n        string aComp1 = s1;\\n        string aComp2 = s2;\\n        \\n        int aLen = s1.size();\\n        \\n        sort(aComp1.begin(), aComp1.end());\\n        sort(aComp2.begin(), aComp2.end());\\n        if (aComp1 != aComp2) { return false; }\\n        \\n        for (int i=1;i<s1.size();i++) {\\n            \\n            string aComps11 = s1.substr(0, i);\\n            string aComps12 = s1.substr(i);\\n            \\n            string aComp1s21 = s2.substr(0, i);\\n            string aComp1s22 = s2.substr(i);\\n            \\n            string aComp2s21 = s2.substr(aLen - i);\\n            string aComp2s22 = s2.substr(0, aLen - i);\\n            \\n            if (isScramble(aComps11, aComp1s21) && isScramble(aComps12, aComp1s22)) {\\n                return true;\\n            }\\n            \\n            if (isScramble(aComps11, aComp2s21) && isScramble(aComps12, aComp2s22)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isScramble(string s1, string s2) {\\n        \\n        if (s1 == s2) { return true; }\\n        if (s1.size() != s2.size()) { return false; }\\n        \\n        string aComp1 = s1;\\n        string aComp2 = s2;\\n        \\n        int aLen = s1.size();\\n        \\n        sort(aComp1.begin(), aComp1.end());\\n        sort(aComp2.begin(), aComp2.end());\\n        if (aComp1 != aComp2) { return false; }\\n        \\n        for (int i=1;i<s1.size();i++) {\\n            \\n            string aComps11 = s1.substr(0, i);\\n            string aComps12 = s1.substr(i);\\n            \\n            string aComp1s21 = s2.substr(0, i);\\n            string aComp1s22 = s2.substr(i);\\n            \\n            string aComp2s21 = s2.substr(aLen - i);\\n            string aComp2s22 = s2.substr(0, aLen - i);\\n            \\n            if (isScramble(aComps11, aComp1s21) && isScramble(aComps12, aComp1s22)) {\\n                return true;\\n            }\\n            \\n            if (isScramble(aComps11, aComp2s21) && isScramble(aComps12, aComp2s22)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162771,
                "title": "dp-solution-in-c-o-n-4-time-o-n-3-space",
                "content": "        const int m = s1.length(); \\n        \\n        if (m != s2.length()) {return false;}\\n        if (m == 0) {return true;}\\n        \\n        vector<vector<vector<bool>>> memo(m, vector<vector<bool>>(m, vector<bool>(m, false)));\\n        \\n        for (int i = m-1; i >= 0; i--) {\\n            \\n            // Init table\\n            for (int l = 0; l < m; l++) {\\n                if (s1[i] == s2[l]) {memo[i][i][l] = true;}\\n            }\\n            \\n            // Dynamic programming\\n            for (int j = i+1; j < m; j++) {\\n                for (int l = 0; l < m - (j-i); l++) {        \\n                    for (int k = i; k < j; k++) {\\n                        if (memo[i][k][l] && memo[k+1][j][l+k+1-i]) {memo[i][j][l] = true;}\\n                        if (memo[i][k][l+j-k] && memo[k+1][j][l]) {memo[i][j][l] = true;}\\n                    }                                        \\n                }\\n            } \\n        }\\n        \\n        for (int l = 0; l < m; l++) {\\n            if (memo[0][m-1][l] == true) {return true;}\\n        }\\n        \\n        return false;\\n\\t\\t\\t\\t\\nThe algorithm proceeds bottom up. For each substring of s2 running from index `i` to index `j`, I check whether, for an initial position in string s1 indexed by `l`, there exists an index `k` for which the substrings from `i` to `k` and from `k+1` to `j` can be obtained through scrambling. To perform this check, I consider the two possible cases, e.g. the two substrings appear in the same order in the original string or in an inverted order due to scrambling. The base case occurs for a substring of length 1, in this case it is sufficient to check whether the characters in `s1` and `s2` at indexes `i` and `l` are the same. ",
                "solutionTags": [],
                "code": "        const int m = s1.length(); \\n        \\n        if (m != s2.length()) {return false;}\\n        if (m == 0) {return true;}\\n        \\n        vector<vector<vector<bool>>> memo(m, vector<vector<bool>>(m, vector<bool>(m, false)));\\n        \\n        for (int i = m-1; i >= 0; i--) {\\n            \\n            // Init table\\n            for (int l = 0; l < m; l++) {\\n                if (s1[i] == s2[l]) {memo[i][i][l] = true;}\\n            }\\n            \\n            // Dynamic programming\\n            for (int j = i+1; j < m; j++) {\\n                for (int l = 0; l < m - (j-i); l++) {        \\n                    for (int k = i; k < j; k++) {\\n                        if (memo[i][k][l] && memo[k+1][j][l+k+1-i]) {memo[i][j][l] = true;}\\n                        if (memo[i][k][l+j-k] && memo[k+1][j][l]) {memo[i][j][l] = true;}\\n                    }                                        \\n                }\\n            } \\n        }\\n        \\n        for (int l = 0; l < m; l++) {\\n            if (memo[0][m-1][l] == true) {return true;}\\n        }\\n        \\n        return false;\\n\\t\\t\\t\\t\\nThe algorithm proceeds bottom up. For each substring of s2 running from index `i` to index `j`, I check whether, for an initial position in string s1 indexed by `l`, there exists an index `k` for which the substrings from `i` to `k` and from `k+1` to `j` can be obtained through scrambling. To perform this check, I consider the two possible cases, e.g. the two substrings appear in the same order in the original string or in an inverted order due to scrambling. The base case occurs for a substring of length 1, in this case it is sufficient to check whether the characters in `s1` and `s2` at indexes `i` and `l` are the same. ",
                "codeTag": "Unknown"
            },
            {
                "id": 29429,
                "title": "java-2ms-nlogn-recursive-solution",
                "content": "There are on average logn levels of recursive call, at each level, all together all chars are visit linearly.\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        if (n == 1) return s1.equals(s2);\\n        int[] map1 = new int[128], map2 = new int[128];\\n        for (int i = 0, cnt1 = 0, cnt2 = 0; i < n-1; i++) {\\n            if (map1[s1.charAt(i)]++ < 0) cnt1++;\\n            if (map1[s2.charAt(i)]-- > 0) cnt1++;\\n            if (cnt1 == i+1 &&\\n                isScramble(s1.substring(0, cnt1), s2.substring(0, cnt1)) && \\n                isScramble(s1.substring(cnt1), s2.substring(cnt1))) return true;\\n            if (map2[s1.charAt(i)]++ < 0) cnt2++;\\n            if (map2[s2.charAt(n-1-i)]-- > 0) cnt2++;\\n            if (cnt2 == i+1 &&\\n                isScramble(s1.substring(0, cnt2), s2.substring(n-cnt2)) &&\\n                isScramble(s1.substring(cnt2), s2.substring(0, n-cnt2))) return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "There are on average logn levels of recursive call, at each level, all together all chars are visit linearly.\\n\\n    public boolean isScramble(String s1, String s2) {\\n        int n = s1.length();\\n        if (n == 1) return s1.equals(s2);\\n        int[] map1 = new int[128], map2 = new int[128];\\n        for (int i = 0, cnt1 = 0, cnt2 = 0; i < n-1; i++) {\\n            if (map1[s1.charAt(i)]++ < 0) cnt1++;\\n            if (map1[s2.charAt(i)]-- > 0) cnt1++;\\n            if (cnt1 == i+1 &&\\n                isScramble(s1.substring(0, cnt1), s2.substring(0, cnt1)) && \\n                isScramble(s1.substring(cnt1), s2.substring(cnt1))) return true;\\n            if (map2[s1.charAt(i)]++ < 0) cnt2++;\\n            if (map2[s2.charAt(n-1-i)]-- > 0) cnt2++;\\n            if (cnt2 == i+1 &&\\n                isScramble(s1.substring(0, cnt2), s2.substring(n-cnt2)) &&\\n                isScramble(s1.substring(cnt2), s2.substring(0, n-cnt2))) return true;\\n        }\\n        return false;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 29460,
                "title": "straightforward-c-dp-solution-o-n-4-time-o-n-3-space",
                "content": "This solution is based on a previous thread: https://leetcode.com/discuss/13258/my-o-n-4-solution-any-question\\n\\nThe basic idea of this algorithm is to maintain a three-dimension array (henceforth called eq[N][N][N+1]), where (eq[first1][first2][len] == true) if and only if (s1[first1 ... first1+len-1] == s2[first2 ... first2+len-1]). In order to simplify the notation, we discard eq[-][-][0].\\n\\nTime complexity: *O* (*n*^4)\\n\\nSpace complexity: *O* (*n*^3)\\n\\n    class Solution {\\n    public:\\n    \\tbool isScramble(string s1, string s2) {\\n    \\t\\tbool ret = true;\\n    \\t\\tsize_t n = s1.length();\\n    \\t\\tif (n > 0) // if s1 is empty, return true\\n    \\t\\t{\\n    \\t\\t\\t// Dynamic Programming: \\n    \\t\\t\\t// eq[first1][first2][len] == true iff s1[first1 ... first1+len) == s2[first2 ... first2+len)\\n    \\t\\t\\tvector<vector<vector<bool> > > eq\\n    \\t\\t\\t\\t(n, vector<vector<bool>>(n, vector<bool>(n + 1, false))); // initialize: all false\\n    \\n    \\t\\t\\t// initialize: eq[first1][first2][1] = true iff s1[first1] == s2[first2]\\n    \\t\\t    for (int first1 = 0; first1 < n; ++first1)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tfor (int first2 = 0; first2 < n; ++first2)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t    eq[first1][first2][1] = (s1[first1] == s2[first2]);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\t// dp: eq[first1][first2][len] = true iff two substrings are both matched.\\n    \\t\\t\\tfor (size_t len = 2; len <= n; ++len)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tfor (size_t first1 = 0; first1 + len <= n; ++first1)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tfor (size_t first2 = 0; first2 + len <= n; ++first2)\\n    \\t\\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t\\tfor (size_t len1 = 1; len1 < len; ++len1)\\n    \\t\\t\\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t\\t\\tsize_t len2 = len - len1;\\n    \\n    \\t\\t\\t\\t\\t\\t\\t// two substrings are not swapped\\n    \\t\\t\\t\\t\\t\\t\\tif (eq[first1][first2][len1] && eq[first1 + len1][first2 + len1][len2])\\n    \\t\\t\\t\\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t\\t\\t\\teq[first1][first2][len] = true;\\n    \\t\\t\\t\\t\\t\\t\\t}\\n    \\n    \\t\\t\\t\\t\\t\\t\\t// two substrings are swapped\\n    \\t\\t\\t\\t\\t\\t\\tif (eq[first1][first2 + len2][len1] && eq[first1 + len1][first2][len2])\\n    \\t\\t\\t\\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\t\\t\\t\\teq[first1][first2][len] = true;\\n    \\t\\t\\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tret = eq[0][0][n];\\n    \\t\\t}\\n    \\t\\treturn ret;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tbool isScramble(string s1, string s2) {\\n    \\t\\tbool ret = true;\\n    \\t\\tsize_t n = s1.length();\\n    \\t\\tif (n > 0) // if s1 is empty, return true\\n    \\t\\t{\\n    \\t\\t\\t// Dynamic Programming: \\n    \\t\\t\\t// eq[first1][first2][len] == true iff s1[first1 ... first1+len) == s2[first2 ... first2+len)\\n    \\t\\t\\tvector<vector<vector<bool> > > eq\\n    \\t\\t\\t\\t(n, vector<vector<bool>>(n, vector<bool>(n + 1, false))); // initialize: all false\\n    \\n    \\t\\t\\t// initialize: eq[first1][first2][1] = true iff s1[first1] == s2[first2]\\n    \\t\\t    for (int first1 = 0; first1 < n; ++first1)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tfor (int first2 = 0; first2 < n; ++first2)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t    eq[first1][first2][1] = (s1[first1] == s2[first2]);\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 29473,
                "title": "share-my-c-recursive-solution",
                "content": "    bool isScramble( string s1, string s2 )\\n    {\\n    \\tif ( s1.length() != s2.length() )\\n    \\t\\treturn false;\\n    \\tint len = s1.length();\\n    \\tif ( s1 == s2 )\\n    \\t\\treturn true;\\n    \\tint table1[ 26 ] = { 0 }, table2[ 26 ] = { 0 };\\n    \\tfor ( int i = 0 ; i < len ; i ++ )\\n    \\t{\\n    \\t\\ttable1[ s1[ i ] - 'a' ] ++;\\n    \\t\\ttable2[ s2[ i ] - 'a' ] ++;\\n    \\t}\\n    \\tif ( memcmp( table1, table2, 26 * sizeof( int ) ) )\\n    \\t\\treturn false;\\n    \\tif ( len <= 3 )\\n    \\t\\treturn true;\\n    \\tfor ( int i = 1 ; i < len ; i ++ )\\n    \\t{\\n    \\t\\tif ( isScramble( s1.substr( 0, i ), s2.substr( 0, i ) ) &&\\n    \\t\\t\\tisScramble( s1.substr( i, len - i ), s2.substr( i, len - i ) ) )\\n    \\t\\t\\treturn true;\\n    \\t\\tif ( isScramble( s1.substr( 0, i ), s2.substr( len - i, i ) ) &&\\n    \\t\\t\\tisScramble( s1.substr( i, len - i), s2.substr( 0, len - i ) ) )\\n    \\t\\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    bool isScramble( string s1, string s2 )\\n    {\\n    \\tif ( s1.length() != s2.length() )\\n    \\t\\treturn false;\\n    \\tint len = s1.length();\\n    \\tif ( s1 == s2 )\\n    \\t\\treturn true;\\n    \\tint table1[ 26 ] = { 0 }, table2[ 26 ] = { 0 };\\n    \\tfor ( int i = 0 ; i < len ; i ++ )\\n    \\t{\\n    \\t\\ttable1[ s1[ i ] - 'a' ] ++;\\n    \\t\\ttable2[ s2[ i ] - 'a' ] ++;\\n    \\t}\\n    \\tif ( memcmp( table1, table2, 26 * sizeof( int ) ) )\\n    \\t\\treturn false;\\n    \\tif ( len <= 3 )\\n    \\t\\treturn true;\\n    \\tfor ( int i = 1 ; i < len ; i ++ )\\n    \\t{\\n    \\t\\tif ( isScramble( s1.substr( 0, i ), s2.substr( 0, i ) ) &&\\n    \\t\\t\\tisScramble( s1.substr( i, len - i ), s2.substr( i, len - i ) ) )\\n    \\t\\t\\treturn true;\\n    \\t\\tif ( isScramble( s1.substr( 0, i ), s2.substr( len - i, i ) ) &&\\n    \\t\\t\\tisScramble( s1.substr( i, len - i), s2.substr( 0, len - i ) ) )\\n    \\t\\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 29480,
                "title": "accepted-python-dp-solution-what-s-the-time-complexity-of-this-solution",
                "content": "class Solution:\\n    # @return a boolean\\n    def __init__(self):\\n        self.cache = {}\\n        \\n    def isScramble(self, s1, s2):\\n        if (s1, s2) in self.cache:\\n            return self.cache[(s1, s2)]\\n            \\n        if len(s1) == 1:\\n            self.cache[(s1,s2)] = (s1 == s2)\\n            return self.cache[(s1,s2)]\\n            \\n        length = len(s2)\\n        for i in range(1, length): #split point 1~len(s2)-1\\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) \\\\\\n                or (self.isScramble(s1[length-i:], s2[:i]) and self.isScramble(s1[:length-i], s2[i:])):\\n                self.cache[(s1,s2)] = True\\n                return True\\n        self.cache[(s1,s2)] = False\\n        return False\\n\\nI used Memoization DP. But I don't know if this solution is good enough. I think the time complexity is exponential as O(4^(length of string)), is it?\\nAny way to improve this solution?",
                "solutionTags": [],
                "code": "class Solution:\\n    # @return a boolean\\n    def __init__(self):\\n        self.cache = {}",
                "codeTag": "Java"
            },
            {
                "id": 29464,
                "title": "time-complexity-of-this-code",
                "content": "    bool isScramble(string s1, string s2) {\\n            if(s1.size() != s2.size()) return false;\\n            if(s1 == s2) return true;\\n            int n = s1.size();\\n            vector<int> count(26, 0);\\n            for(int i = 0; i < n; i++) count[s1[i]-'a']++;\\n            for(int i = 0; i < n; i++) count[s2[i]-'a']--;\\n            for(auto i : count){\\n                if(i != 0) return false;\\n            }\\n            for(int i = 1; i < n; i++){\\n                if((isScramble(s1.substr(0, i), s2.substr(n-i, i))&&isScramble(s1.substr(i, n-i), s2.substr(0, n-i)))||\\n                    (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i, n-i), s2.substr(i, n-i))))\\n                    return true;\\n            }\\n            return false;\\n        }\\n\\nfind someone write this code said the time complexity is O(n^6), can someone explain why?",
                "solutionTags": [],
                "code": "    bool isScramble(string s1, string s2) {\\n            if(s1.size() != s2.size()) return false;\\n            if(s1 == s2) return true;\\n            int n = s1.size();\\n            vector<int> count(26, 0);\\n            for(int i = 0; i < n; i++) count[s1[i]-'a']++;\\n            for(int i = 0; i < n; i++) count[s2[i]-'a']--;\\n            for(auto i : count){\\n                if(i != 0) return false;\\n            }\\n            for(int i = 1; i < n; i++){\\n                if((isScramble(s1.substr(0, i), s2.substr(n-i, i))&&isScramble(s1.substr(i, n-i), s2.substr(0, n-i)))||\\n                    (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i, n-i), s2.substr(i, n-i))))\\n                    return true;\\n            }\\n            return false;\\n        }\\n\\nfind someone write this code said the time complexity is O(n^6), can someone explain why?",
                "codeTag": "Unknown"
            },
            {
                "id": 29492,
                "title": "my-o-n-4-solution-for-your-reference",
                "content": "    class Solution:\\n    # @return a boolean\\n    def isScramble(self, s1, s2):\\n        n=len(s1)\\n        if n==0: return True\\n        table=[[[None for i in range(n+1)] for i2 in range(n)] for i1 in range(n)] #table[i1][i2][i] stores if s1[i1:i1+i] is a scramble of s2[i2:i2+i]\\n        \\n        def helper(i1,i2,i):\\n            if table[i1][i2][i]==None:\\n                if i==1: \\n                    table[i1][i2][i]=(s1[i1]==s2[i2])\\n                else:\\n                    result=False\\n                    for partition in range(1,i):\\n                        if helper(i1,i2,partition) and helper(i1+partition,i2+partition,i-partition): result=True\\n                        if helper(i1,i2+i-partition,partition) and helper(i1+partition,i2,i-partition): result=True\\n                    table[i1][i2][i]=result\\n            return table[i1][i2][i]\\n            \\n        return helper(0,0,n)",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @return a boolean\\n    def isScramble(self, s1, s2):\\n        n=len(s1)\\n        if n==0: return True\\n        table=[[[None for i in range(n+1)] for i2 in range(n)] for i1 in range(n)] #table[i1][i2][i] stores if s1[i1:i1+i] is a scramble of s2[i2:i2+i]\\n        \\n        def helper(i1,i2,i):\\n            if table[i1][i2][i]==None:\\n                if i==1: \\n                    table[i1][i2][i]=(s1[i1]==s2[i2])\\n                else:\\n                    result=False\\n                    for partition in range(1,i):\\n                        if helper(i1,i2,partition) and helper(i1+partition,i2+partition,i-partition): result=True\\n                        if helper(i1,i2+i-partition,partition) and helper(i1+partition,i2,i-partition): result=True\\n                    table[i1][i2][i]=result\\n            return table[i1][i2][i]\\n            \\n        return helper(0,0,n)",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1847719,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1564781,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847966,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847961,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847987,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1848193,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847724,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1848001,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1566475,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1569415,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847719,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1564781,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847966,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847961,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847987,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1848193,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1847724,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1848001,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1566475,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1569415,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "Enough with the hard questions I already lost my streak :("
                    },
                    {
                        "username": "diaz900",
                        "content": "The example shows the case where left child ALWAYS has equal or one-less characters than right child. But since \"abb\" is a scramble of \"bab\", as suggested by a test case, strings are not always partitioned in the way as the example implies.\\n\\nHowever, if the answer is Yes, I think scrambles just become permutations. Isn't it?\\n\\nSo I am so confused what is expected...\\n\\nThanks!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "for just two strings to be permutation, we could have just sorted both and checked if they are same or not. But thats not the case here, the scambled algorithm works in a manner that two permuted string could be or not be scrambled. Hope every1 looking this comment gets the idea"
                    },
                    {
                        "username": "psudo1",
                        "content": "if you think it is a permutation then for the test case s1 = \"abcde\", s2 = \"caebd\" the answer must be \"true\" not false . So as per this test case we can say permutation is not same as scramble ."
                    },
                    {
                        "username": "psionl0",
                        "content": "I guess it serves us right for laughing at how \"hard\" yesterday\\'s problem was."
                    },
                    {
                        "username": "AMerrill",
                        "content": "Now this problem is quite rdha..."
                    },
                    {
                        "username": "AMerrill",
                        "content": "O_o Wow! This problem is REALLY HARD. I will admit, I cheated some and looked at the handy dandy \"Editorial\" tab. I read through the intuition and then wrote out the code myself. I don\\'t think I would have ever figured this problem out, but the solution is very elegant (complicated, but very elegant): Dynamic Programming with 3D Array and quadruple-nested for loops.\\n\\nIf you solved this solo, you should be immensely proud! And if you are struggling with this one, don\\'t beat yourself up. Try to do as much as you can on your own. I feel like I learned something from this problem, and even though I looked through the intuition of the provided solution, I feel immensely proud looking at my coded solution."
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@user5313X](/user5313X) what memoization did you add? I couldn\\'t think of a good one."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@charonme](/charonme) Great job! Way to persevere!!!"
                    },
                    {
                        "username": "charonme",
                        "content": "after reading this I almost gave up and read the editorial, but fortunately I\\'ve also read the other comments saying they\\'d done it with bruteforce dfs and just slapped on memoization, so I\\'ve did the same and it passed without TLE!"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@wyleungad](/wyleungad) I got a TLE, then blindly added a memoization to my recursion and finally passed. I hadn\\'t even thought of this as dp initially tbh"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have been doing this solo as well and tho it took me over 2h, I do feel pretty proud, thanks!"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I have been doing this solo for 2 hours by now. Unfortunately my solution is in O(n^5), even with the help of dp, the time limit still road blocks me."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agreed bro.  solo it would have taken me days of torture.  reading the editorial (concept only, no code) it took hours - definitely would\\'ve failed any interview that asked this."
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously  after looking out at first 3 cases, i was like it\\'s not that hard.. but it\\'s been over an hour.. I\\'m not able to understand"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Haha, Since I had revised classic problems like Matrix Chain Multiplication and Optimal BST from Coremen(CLRS) some time ago, I slightly knew the approach when I read the problem but what took me an hour to deduce that is my **disbelief** that we could have a 3D DP problem with $$n^4$$ time complexity.\n\nWe have three dimensions here (index of first string, index of second string, length of substring considered), so we can extrapolate even this and have another problem that has a 4rth dimension (like an accompanying integer/ boolean array). Then that would be a 4D DP problem with $$n^5$$ time complexity.\n\nMy point is that you can complicate problems as much as you like, but there should be a limit!. The good old matrix chain multiplication (2D DP with sufficient complexity) is where **I draw the line**"
                    },
                    {
                        "username": "jolswlf",
                        "content": "I think this problem was designed with the idea of forcing you to use memoization but it just ended up being a terrible problem"
                    },
                    {
                        "username": "DexterHines",
                        "content": "I\\'m really amazed by the creativity that some people have to just create redundant dumb questions to be used in interviews that will evaluate absolutely nothing about a candidate and in fact the only thing that solving this question does in an interview is to tell you is that either the candidate is Albert Einstein\\'s successor for our generation and you just got lucky enough that he\\'s interviewing at your google copycat startup or he probably saw the question before and memorized it to hell.\\n\\nIf I ever receive this question in an interview I\\'ll just quit the chat without saying anything, if someone is as horrible as to give you this one in an interview then believe me, even if you solve it he will probably not pass you anyway, better to just move on to the next company."
                    },
                    {
                        "username": "touwmer",
                        "content": "[@cartesPerforees](/cartesPerforees) I agree. Don\\'t get mad. It just takes some efforts. DP is not as hard as it seems to be."
                    },
                    {
                        "username": "Maang-io",
                        "content": "I have seen that, if you are able to come up with working simple recursion solution, you can still pass the interview. and I have passed several interviews rounds just at recursive, recursive+memo.  If Interviewer is expecting a DP solution in an interview setting, I will assume he is a jerk. As an interviewer, if I am seeing someone solving using DP from start, so either that person is genius or he knows the solution, and interview can ask whether you have solved the problem earlier or not. and if he is honest, that is a brownie point."
                    },
                    {
                        "username": "zaphod424",
                        "content": "This problem is definitely hard, but it\\'s not impossible as you are trying to make out. While I agree it is completely arbitrary and pointless as an actual problem, as a means of testing one\\'s ability to break down and solve a problem it is a good one, and that\\'s what interviews are trying to test. \\nGood coding practices, tech stacks, and language features can all be learnt, but raw problem solving skill cannot, so (especially in juniors) that\\'s what companies look for, they can teach you the rest"
                    },
                    {
                        "username": "DexterHines",
                        "content": "[@user5313X](/user5313X) I don\\'t wanna improve to solve stupid questions like this it\\'s pointless, if you like the fact that companies pull this bs then you are part of the problem."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "somebody's grumpy today. \nIt's ok if you didn't get to solve it. Just keep practising and don't blame it on the problem if you wanna improve. I can garantee you it doesn't take einstein to solve this, just a bit of work"
                    },
                    {
                        "username": "jolswlf",
                        "content": "didn\\'t like this one"
                    },
                    {
                        "username": "mrlnmdsn",
                        "content": "same"
                    },
                    {
                        "username": "wyc25013",
                        "content": "I think I might miss something. \\nBut how could aabb be scrambled string of abab?\\nMy understanding is that abab can only be scrambled into \\nabba, baab, baba.\\nThanks a lot!"
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "abab\\n=(aba + b)\\n=(ab +a) +(b)\\n=(aab) +(b)\\n=aabb"
                    },
                    {
                        "username": "kuelf",
                        "content": "\"abab\" \n\"a\" + \"bab\"\n\"a\" + \"ba\" + \"b\"\n\"a\" + \"ab\" +\"b\"\n\\=\n\"aabb\"\n\n"
                    },
                    {
                        "username": "Quantris",
                        "content": "I suspect the data for this question is pretty weak, and favors a relatively simple approach without any memoization.\\n\\nI think the worst case for many programs is something like \"<lots of a\\'s>bcde<lots of a\\'s>\" vs. \"<lots of a\\'s>cebd<lots of a\\'s>\" (\"lots\" is the same number in each spot) where the answer is false but a typical recursion will repeat lots of work figuring that out.\\n\\nIt seems possible to make such a case to cause time limit for recursive approach, without making memoized approach take too long. As well, there are some clever optimizations that could be made on top of 3D memo table."
                    }
                ]
            },
            {
                "id": 1848439,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1566824,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1567516,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1848587,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1848065,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1847850,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1847742,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1670898,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1575131,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1573158,
                "content": [
                    {
                        "username": "SahilAnower",
                        "content": "Why to give this on a thursday. Fucking hell! Could have given it on the weekend."
                    },
                    {
                        "username": "pengp17",
                        "content": "For example \\'aabb\\' can be splited into \\'a\\' and \\'abb\\'."
                    },
                    {
                        "username": "SanketSingh",
                        "content": "Found a really good explanation of this question\\nhttps://youtu.be/uqRrb4t_ktk"
                    },
                    {
                        "username": "gbiems",
                        "content": "I almost feel like I shouldn\\'t post this, but it\\'s the discussion, so... I was able to get to 255/288 test cases passed using a mildly brain-dead approach where I randomly generate 1000 scrambles from s1 according to the rules, and check to see if any of them are equal to s2 (if not, return False). Another time I ran this, I got 266/288 - the number of test cases passed may vary because it\\'s random. I wonder I could find a threshold above a 1000 where I can pass all the test cases without TLE. \\n\\nI understand this non-solution isn\\'t really in the spirit of this question, but since this is just the discussion and I\\'m *clearly* not posting an actual solution, here\\'s the code:\\n\\n```\\nfrom random import randint\\n\\nclass Solution:\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n\\n        def scrambleString(s):\\n\\n            if len(s) == 1:\\n                return s\\n\\n            m = randint(1,len(s)-1)\\n\\n            s1 = scrambleString(s[:m])\\n            s2 = scrambleString(s[m:])\\n\\n            if randint(0,1) == 1:\\n                return s2 + s1\\n\\n            return s1 + s2\\n            \\n\\n        for i in range(1000):\\n            if s2 == scrambleString(s1):\\n                return True\\n\\n        return False\\n```\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Now hard problems are actually hard :-)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n\\n- We can use memoization to avoid redundant computation. Specifically, we can create a map to store the boolean results of previous function calls. Each key in the map will be a concatenation of the two input strings, separated by a special character such as \"#\". The corresponding value will be the boolean result indicating whether the second string can be scrambled into the first string.\\n- Define a recursive function that takes two strings as input and returns a boolean value indicating whether the second string can be scrambled into the first string. This function will be called repeatedly with different substrings of the input strings.\\n- Base cases:\\na. If the lengths of the two input strings are not equal, return false.\\nb. If the two input strings are the same string, return true.\\n- For each possible split point in the input strings (excluding the first and last characters), do the following:\\na. Recursively call the function with the two substrings created by the split.\\nb. If both substrings can be scrambled into each other, return true.\\n- If no valid split points are found, return false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference :-)***\\nhttps://leetcode.com/problems/scramble-string/solutions/3357734/easy-to-understand-solution/"
                    },
                    {
                        "username": "AlecLC",
                        "content": "This problem scrambled my brain"
                    },
                    {
                        "username": "girotomas",
                        "content": "I still don't get why memoization is required in this exercise. Whoever added the \"memoization required\" tests should remove them imo, because there is no reason why we would have repeating subproblems in this exercise. Let me know if I missed something."
                    },
                    {
                        "username": "vivianjoseph2002",
                        "content": "There would be repeating subproblems.\\neg:\\n\"abcdef\"= \"a\"+\"bcdef\"=\"a\" +(\"b\"+\"cdef\")\\n\"abcdef\"=\"ab\"+\"cdef\"\\nhere \"cdef\" is a repeating subproblem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why do you need a reason why? \\nIf there exist some testcases which make you non-memoized program fail, then of course they should be included. We\\'re supposed to write a general code that can handle as many cases as possible\\nAdditionally, there\\'s only 26 distinct characters in the latin alphabet. Statistically, on a regular string, you\\'re bound to get a lot of repeats, even if the input is not made to stomp you"
                    },
                    {
                        "username": "sahilpcs",
                        "content": "I was wondering why this problem is having so many dislikes?"
                    },
                    {
                        "username": "ben-rosenberg",
                        "content": "Because it is confusing and difficult lol. I\\'m not even sure where to start, but I admit it is a very interesting question."
                    },
                    {
                        "username": "netcan",
                        "content": "`abcde -> bacde -> baced -> decab -> decba -> dcabe -> dcaeb -> beacd -> bedca -> bedac -> cadeb -> cadbe -> caebd`\\uFF0CI checked it every step is correct, by runing testcase code in leetcode, so why `caebd` isn\\'t a scrambled string of `abcde`?"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Hi [@Netcan](/netcan),\n\nThe step ```baced -> decab``` seems wrong as per my understanding of the question.\nConsidering the first 3 steps of the transformations, that is only possible if you take the partition index at 2 (0 based indexing) such that you have strings ```abc``` and ```de``` and then you don't decide swap so you're still left with ```abcde```. \nNow according to question you recursively move to theses substrings so from ```abc``` you make ```bac``` and from ```de``` you make ```ed``` to get ```bacde``` and then ```baced```. \nBut now you recurse down to the partitions of these strings, so you apply function calls to substrings ```b``` and ```ac``` from ```bac``` and ```d``` and ```e``` from ```de```.  Because of which its not possible to get ```decab```."
                    },
                    {
                        "username": "kuelf",
                        "content": "re-read the question"
                    }
                ]
            },
            {
                "id": 1568907,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1567189,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1853628,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1848797,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1848418,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1847965,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1847940,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1847798,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1847757,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1573025,
                "content": [
                    {
                        "username": "Nobug4ever",
                        "content": "Can I assume that a string scramble is just a permutation of a string? if not. can any one give me a counterexample?"
                    },
                    {
                        "username": "kuelf",
                        "content": "I mean look at the examples in the question."
                    },
                    {
                        "username": "zhaohaoshu",
                        "content": "My method is first divide each of the strings to 2 parts: s11, s12, s21, s22, so that each two of corresponding parts have the same collection of characters i.e. `(sameCollection(s11, s21) && sameCollection(s12, s22)) || (sameCollection(s11, s22) && sameCollection(s12, s21))`. This checks whether the root has been swaped.\\n\\nHowever, I can't find a way to divide \"abbbcbaaccacaacc\" and \"acaaaccabcabcbcb\" to meet the requirement above, so my result is `false`. But the OJ tells me the expected result is `true`. So can anyone tell me how can \"abbbcbaaccacaacc\" be scrambled to \"acaaaccabcabcbcb\"?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I'm probably nine years too late but in case anybody is still wondering:\n\n```\ns1: \"abbbcbaaccacaacc\"\n(split \"abbbcbaaccacaacc\" into \"a\" and \"bbbcbaaccacaacc\", do not swap)\n\"[a bbbcbaaccacaacc]\"\n(split \"bbbcbaaccacaacc\" into \"b\" and \"bbcbaaccacaacc\" and swap)\n\"a [bbcbaaccacaacc b]\"\n(split \"bbcbaaccacaacc\" into \"bbcbaaccacaac\" and \"c\", do not swap)\n\"a [bbcbaaccacaac c] b\"\n(split \"bbcbaaccacaac\" into \"b\" and \"bcbaaccacaac\" and swap)\n\"a [bcbaaccacaac b] c b\"\n(split \"bcbaaccacaac\" into \"bcbaaccacaa\" and \"c\", do not swap)\n\"a [bcbaaccacaa c] b c b\"\n(split \"bcbaaccacaa\" into \"b\" and \"cbaaccacaa\" and swap)\n\"a [cbaaccacaa b] c b c b\"\n(split \"cbaaccacaa\" into \"cbaaccaca\" and \"a\", do not swap)\n\"a [cbaaccaca a] b c b c b\"\n(split \"cbaaccaca\" into \"c\" and \"baaccaca\" and swap)\n\"a [baaccaca c] a b c b c b\"\n(split \"baaccaca\" into \"ba\" and \"accaca\" and swap)\n\"a [accaca ba] c a b c b c b\"\n(split \"accaca\" into \"acc\" and \"aca\" and swap)\n(split \"ba\" into \"b\" and \"a\" and swap)\n\"a [aca acc] [a b] c a b c b c b\"\n(split \"aca\" into \"ac\" and \"a\", do not swap)\n(split \"acc\" into \"a\" and \"cc\", do not swap)\n\"a [ac a] [a cc] a b c a b c b c b\"\n(split \"ac\" into \"a\" and \"c\" and swap)\n(split \"cc\" into \"c\" and \"c\", do not swap)\n\"a [c a] a a [c c] a b c a b c b c b\"\ns2: \"acaaaccabcabcbcb\"\n```"
                    },
                    {
                        "username": "aalmos",
                        "content": "This wasn\\'t a particularly hard problem but regardless, it\\'s awful and boring and took me a long time to solve without TLE. Whomever asks this on interviews should go to hell."
                    },
                    {
                        "username": "kaitmania",
                        "content": "To understand the DP solutions, you have to understand this idea.\\n\\ns1 and s2 are scramble.\\ns1 = a\\ns2 = a\\n\\ns1 and s2 are not scramble. \\ns1 = a\\ns2 = b\\n\\ns1 and s2 are also scramble because s1 and s2 are the same.\\ns1 = ab\\ns2 = ab\\n\\ns1 and s2 are also scramble because swapping is possible.\\ns1 = ab        (a | b) \\ns2 = ba        (b | a)\\n\\ns1 and s2 are also scramble (This is another example of swapping)\\ns1 = cd        (c | d)\\ns2 = dc        (d | c)\\n\\ns1 and s2 are scramble  (scramble word+ scramble word = scramble word)\\ns1 = abcd   (ab + cd)  \\ns2 = badc   (ba + dc)  \\n\\nI hope this will help you understand the DP solutions."
                    },
                    {
                        "username": "apnasurajhai",
                        "content": "I dont know how i will exceed i\\'m daily solving one problem but that too looking at solutions after spending 10 - 15 mins on questions."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "10-15 minutes is not really trying with most medium and hard puzzles, you should spend a bit longer imo. "
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "Don\\'t worry DSA takes time. You will improve day by day"
                    },
                    {
                        "username": "Msey",
                        "content": "You think the graph week was a disaster? You were totally wrong"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**enough with hard questions, i cheated yesterday also**"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Yesterday\\'s question was an easy one"
                    },
                    {
                        "username": "vetor",
                        "content": "another day of hard question :(\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some minor tips:-\\n1. Use Map for memoization, with key as `s1+\" \"+s2`\\n\\n2. Two boolean cases will be there, swap or NoSwap in a for loop from `i=1 to i = n-1`. "
                    },
                    {
                        "username": "voquanghoa",
                        "content": "All scamble strings of `abab` are  `abba`, `baab`, `baba`\\n\\nAnd `aabb` will be `bbaa` \\n\\nCan some one explain me why the test case `abab` `aabb` is `true`\\n\\nThanks"
                    },
                    {
                        "username": "lijiaqigreat",
                        "content": "abab = a+((b+a)+b) -> a+((a+b)+b) = aabb"
                    }
                ]
            },
            {
                "id": 1569650,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1568908,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1568909,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1744805,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1974184,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1962952,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1872182,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1848795,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1848725,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1848708,
                "content": [
                    {
                        "username": "starfoe",
                        "content": "how come they are scramble strings"
                    },
                    {
                        "username": "Tujin",
                        "content": "\\n\\nInput:\\t\"abb\", \"bab\"\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\n\\nabb would have children of (a) and (bb) while bab would have children of (b) and (ab).\\n\\nso the only valid scrambled strings of \"abb\" would be \"abb\" and \"bba\".\\n\\nYou can scramble string 2 and arrive at string 1, but not vice versa.\\n\\nIf we are not constrained by only being able to scramble by swapping child nodes (ie, we can move letters back and forth between children - being able to swap from (a) and (bb) to (ab) and (b)) then that makes the problem significantly simpler. The problem description gave me the impression that the child swapping constraint was being imposed upon our definition of scramble."
                    },
                    {
                        "username": "creasy",
                        "content": "I failed in a very simple test case --  \"bdac\" is not a scramble string of \"abcd\".\\n\\nBut, can I split the \"abcd\" as \"abc\" and \"d\", then further split \"abc\" as \"ab\" and \"c\". Then, if I swap the 1st level \"abc\" and \"d\" and the 2nd level \"ab\", I can have \"dbac\". I don't know where I go wrong..."
                    },
                    {
                        "username": "mdavidn",
                        "content": "\"dbac\" != \"bdac\"\n\nIn the latter, the letter \"d\" partitions the scramble of \"abc,\" which is impossible."
                    },
                    {
                        "username": "wyleungad",
                        "content": "I\\'m stuck at this exact case too"
                    },
                    {
                        "username": "yashpande2002",
                        "content": "To solve this problem, you can use a dynamic programming approach. The idea is to use a three-dimensional dp array, where dp[i][j][k] represents whether s1[i:i+k+1] is a scrambled string of s2[j:j+k+1].\\n\\nTo fill in the dp array, you can iterate over the length of the substrings (k) and the starting index of the substrings in s1 (i) and s2 (j). For each substrings, you can check all possible combinations of substrings and see if any of them are scrambled versions of each other. If any combination is a scrambled version, you can set dp[i][j][k] to true and break out of the loop.\\nhere\\'s the solution for the problem\\nbool isScramble(string s1, string s2) {\\n     if (s1 == s2) {\\n        return true;\\n    }\\n    if (s1.size() != s2.size()) {\\n        return false;\\n    }\\n    int n = s1.size();\\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n, vector<bool>(n)));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[1][i][j] = (s1[i] == s2[j]);\\n        }\\n    }\\n    for (int len = 2; len <= n; len++) {\\n        for (int i = 0; i < n - len + 1; i++) {\\n            for (int j = 0; j < n - len + 1; j++) {\\n                for (int k = 1; k < len; k++) {\\n                    if ((dp[k][i][j] && dp[len - k][i + k][j + k]) || (dp[k][i][j + len - k] && dp[len - k][i + k][j])) {\\n                        dp[len][i][j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n][0][0];\\n}\\n\\n\\n\\n"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "I was asked this question today for OA by media.net. I was given 30 mins for this question."
                    },
                    {
                        "username": "saani765",
                        "content": "wow ,what a ahdr ,ahrd problem "
                    },
                    {
                        "username": "maksymkhomiak",
                        "content": "I actually like this one. Although, it requires a lot of analysis and time spent, I've felt as I do some really complicated CS problem during investigation, which doesn't happen really often when you practice problems"
                    },
                    {
                        "username": "vietnha1999",
                        "content": "Yesterday, my solution is TLE because I used key of hashmap is\n```java\nnew String[]{s1, s2}\n```\ninstead of\n```\ns1+s2\n```\n:((("
                    },
                    {
                        "username": "user8675309",
                        "content": "## Daily Challenge for March 2023\\n\\n### March 12th [[link]](https://leetcode.com/problems/merge-k-sorted-lists/)\\n> **\"This problem should not be marked as hard.\"**\\n> --adambene\\n\\n### March 26th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"In my opinion this should have been Medium leveled\"**\\n> --sairamyadhav3\\n\\n### March 29th [[link]](https://leetcode.com/problems/longest-cycle-in-a-graph/)\\n> **\"This definitely should not be Hard\"**\\n> --alexbonasera\\n\\n### March 30th (this problem)\\n> **\"Fine, you asked for it.\"**\\n> --LeetCode"
                    },
                    {
                        "username": "vaathi",
                        "content": "In [my solution](https://leetcode.com/problems/scramble-string/solutions/3360511/basic-dp-solution/) \\nI have passed indices avoiding substring creation in assumption that it will run fast, but it is not that fast. Can anyone explain ?"
                    }
                ]
            },
            {
                "id": 1848676,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848650,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848643,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848542,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848410,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848391,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848360,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848337,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848282,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848236,
                "content": [
                    {
                        "username": "saubhik",
                        "content": "Time travel ticket alert, folks!!!"
                    },
                    {
                        "username": "sonuyash375",
                        "content": "where i m wrong??\\nclass Solution {\\n    public boolean isScramble(String s1, String s2) {\\n        return helper(s1,s1);\\n    }\\n    static Boolean helper(String s1,String s2){\\n        \\n        if(s1.length() != s2.length()) return false;\\n        if(s1.equals(s2)) return true;\\n        Boolean flag = false;\\n\\n        for(int i=1; i<s1.length(); i++){\\n            Boolean notSwap = helper(s1.substring(0,i),s2.substring(0,i)) &&\\n                          helper(s1.substring(i,s1.length()),s2.substring(i,s2.length()));\\n\\n                          if(notSwap == true){\\n                    flag = true;\\n                    break;\\n                }\\n\\n            Boolean swap = helper(s1.substring(i,s1.length()),s2.substring(0,i)) &&\\n                       helper(s1.substring(0,i),s2.substring(i,s2.length()));\\n\\n                if(swap == true){\\n                    flag = true;\\n                    break;\\n                }\\n        }\\n        return flag;\\n    }\\n}"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Leetcode please no more hard questions. I have to cheat to keep my daily streak !!!!   "
                    },
                    {
                        "username": "GD18",
                        "content": "this was one of the toughest questions ive encountered so far, i had to understand and look for help for quite some time for this one"
                    },
                    {
                        "username": "ikorpse",
                        "content": "I figured out the solution except of that I could have DP of n^3 rather than n^4, feel stupid about it"
                    },
                    {
                        "username": "Akshayhm29",
                        "content": "why it is giving TLE:\\n\\n\\nclass Solution{\\n    public:\\n    unordered_map<string,bool>m;\\n    bool isScramble(string S1, string S2){\\n        //code here\\n        if(S1==S2)return true;\\n        if(m.find(S1+S2)!=m.end())return m[S1+S2];\\n        int n=S1.length();\\n        string temp=\"\";\\n        for(int i=0;i<n-1;i++){\\n            temp+=S1[i];\\n            bool a=isScramble(temp,S2.substr(0,i+1));\\n            bool b=isScramble(temp,S2.substr(n-i-1,i+1));\\n            bool c=isScramble(S1.substr(i+1,n-i-1),S2.substr(i+1,n-i-1));\\n            bool d=isScramble(S1.substr(i+1,n-i-1),S2.substr(0,n-i-1));\\n            if((a and c) or (b and d))return true;\\n        }\\n        return m[S1+S2]=false;\\n        \\n    }    \\n};"
                    },
                    {
                        "username": "halfengineer",
                        "content": "test cases from 271 to 280 are working in custom input but giving tle error in actual submission anybody has any idea.Thanks.."
                    },
                    {
                        "username": "AKA_RAN",
                        "content": "You might have initialised some global variable with some value.\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Is it working 100% of the time in custom or more like working 8 times out of 10? I noticed that the runtimes vary quite a lot from one submission to another. If your solution is just at the limit between too slow and acceptable, it\\'s possible that it works sometimes, and fails on a \"bad run\". Statistically, I guess it is more likely to pass the custom textcases one by one, than if it has to pass all of the tests successively when you submit it"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Why is the max string length so low (<= 30)? I just implemented a brute force algorithm and it was accepted, lol"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "it is that low cause even the best solution is O(n4), which quickly becomes huge. A string of moderate size (like n=100) would already likely give TLE for most implementations of the optimal algo\nAre you sure that your solution is brute force tho? Generating all of the possible scrambles and checking if there's a match? I believe that is exponential complexity, and shouldn't pass the time limit at all"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "I have almost completed the monthly challenge and you give me hard in a row... why???\\n"
                    }
                ]
            },
            {
                "id": 1848215,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1848182,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1848051,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1848046,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1847998,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1847997,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1847829,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1847813,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1847785,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1847745,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83E\\uDD21\\u200E\\uFE0F\\u200D\\uD83D\\uDD25 +1"
                    },
                    {
                        "username": "MatteyRitch",
                        "content": "My first contest was the one yesterday which I enjoyed thoroughly but did not get credit for... regardless that one was so much easier to understand than this. \\n\\nFor the below piece of the explanation, why do they not split the \"at\" into \"a/t\"?\\n `\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.`\\n\\nAlso as an aside, does anyone know what time (in EST or UTC) the contest switches over? I did the one yesterday but after submitting my streak didn\\'t change.\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Do you see the calendar at the right panel on the Problem page? You can see how many hours are left at the top right next to the \"Day\" label."
                    },
                    {
                        "username": "sugarteddy",
                        "content": "i don\\'t like this one :("
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Ughhhh! \nI've rarely been clueless about a problem for so long. I usually have a bunch of ideas, that may or may not end up working, but this one left me dry for a while, with no clue how to go about it other than exponential-time brute force. Simply generating relevant testcases to test my intuition was quite the headache\nIt took me about 40 minutes, just to get a workable idea (tho incomplete at that stage). Took me 2h to get it all to work. \nExhausting, but somehow still satisfying when it finally passes. All in all, damn hard, but interesting problem!"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "All my testcases are running well but when submitting they are failing, any idea why?"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone help me?\\nALERT!\\nAPPROACH HERE ---->\\n\\nbool sumi(string a, string b, int ind, string &s2, int &len){\\n\\n    if(ind<0) return true;\\n    string x=a+b;\\n    string y=b+a;\\n    if(x==s2 or y==s2) return true;\\n    bool toda_noswap=sumi(x.substr(0,ind-1),x.substr(ind,len),ind-1,s2,len);\\n    bool toda_swap=sumi(y.substr(0,ind-1),y.substr(ind,len),ind-1,s2,len);\\n    bool notoda_noswap=sumi(x,x,ind-2,s2,len);\\n    bool notoda_swap=sumi(y,y,ind-2,s2,len);\\n    return ( toda_noswap or toda_swap or notoda_noswap or notoda_swap );\\n}\\n\\n\\n    bool isScramble(string s1, string s2) {\\n        int l1=s1.length();\\n        int l2=s2.length();\\n        if(l1!=l2) return false;\\n        if(s1==s2) return true;\\n        return sumi(s1.substr(0,l1-1),\"\",l1-1,s2,l1);\\n    }\\n"
                    },
                    {
                        "username": "amanchandna",
                        "content": "if `s1 1st half` and `s2 1st half` of same length and `s1 2nd half` and `s2 2nd half` of same length are equal -> strings is scramble `OR`\\nif `s1 1st half` and `s2 2nd half` of s1 1st half length and `s1 2nd half` and `s2 1st half` of s1 2nd half lenfgth are eqaul -> string is scramble\\n\\n`Can reduce some recursive calls`\\nif freq of characters are not equals of s1 and s2"
                    },
                    {
                        "username": "aitachii",
                        "content": "Here are some of the possible scrambles for Example 1: s1 = \"great\"\nthe two substrings inside the ( ) means they are randomly getting swapped\n\ngreat [possible splits: g/reat, gr/eat, gre/at, grea/t]\n- (g reat)\n- - g (r eat)\n- - - g r (e at)\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g r (at e)\n- - - - g r (a t) e\n- - - - g r (t a) e\n\n- - - g r (ea t)\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g r (t ea)\n- - - - g r t (e a)\n- - - - g r t (a e)\n\n- - - g r (eat)\n- - g (eat r)\n- - - ...\n\n- - g (re at)\n- - - g (r e) at\n- - - - g r e (a t)\n- - - - g r e (t a)\n- - - g (e r) at\n- - - - g e r (a t)\n- - - - g e r (t a)\n- - g (at re)\n- - - g (a t) re\n- - - - g a t (r e)\n- - - - g a t (e r)\n- - - g (t a) re\n- - - - g t a (r e)\n- - - - g t a (e r)\n\n- - g (rea t)\n- - - g (r ea) t\n- - - - g r (e a) t\n- - - - g r (a e) t\n- - - g (ea r) t\n- - - - g (e a) r t\n- - - - g (a e) r t\n\n- - - g (re a) t\n- - - - g (r e) a t\n- - - - g (e r) a t\n- - - g (a re) t\n- - - - g a (r e) t\n- - - - g a (e r) t\n\n- - - g (rea) t\n- - g (t rea)\n- - - g t (r ea)\n- - - - ...\n- - - g t (ea r)\n- - - - ...\n\n- - - g t (re a)\n- - - - ...\n- - - g t (a re)\n- - - - ...\n- - g (reat)\n\n- (reat g)\n- - (r eat) g\n- - - r (e at) g\n- - - - r e (a t) g\n- - - - r e (t a) g\n- - - r (at e) g\n- - - - r (a t) e g\n- - - - r (t a) e g\n- - - r (ea t) g\n- - - - r (e a) t g\n- - - - r (a e) t g\n- - - r (t ea) g\n- - - - r t (e a) g\n- - - - r t (a e) g\n- - - r (eat) g\n- - (eat r) g\n- - - (e at) r g\n- - - - e (a t) r g\n- - - - e (t a) r g\n- - - (at e) r g\n- - - - (a t) e r g\n- - - - (t a) e r g\n- - - (ea t) r g\n- - - - (e a) t r g\n- - - - (a e) t r g\n- - - (t ea) r g\n- - - - t (e a) r g\n- - - - t (a e) r g\n- - - (eat) r g\n- - (re at) g\n- - - ...\n- - (at re) g\n- - - ...\n- - (rea t) g\n- - - ...\n- - (t rea) g\n- - - ...\n- - (reat) g\n\n- (gr eat)\n- - ...\n- (eat gr)\n- - ...\n\n- (gre at)\n- - ...\n- (at gre)\n- - ...\n\n- (grea t)\n- - ...\n- (t grea)\n- - ...\n\n- (great)\nEND"
                    },
                    {
                        "username": "batsy01",
                        "content": "I am getting heap-buffer overflow error while performing it with tablulation.\\nsomeone please explain\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6040000001c0 at pc 0x000000345112 bp 0x7fff817d9570 sp 0x7fff817d9568\\n\\n ``class Solution {\\npublic:\\n    int ***dp;\\n    string s1,s2;\\n\\n    bool isScramble(string s1, string s2) {\\n        int n=s1.length();\\n        dp=new int **[n];\\n        for(int i=0;i<n;i++){\\n            dp[i]=new int*[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j]=new int[n+1];\\n                for(int k=0;k<=n;k++){\\n                    dp[i][j][k]=-1;\\n                }\\n            }\\n        }\\n\\n        this->s1=s1;\\n        this->s2=s2;\\n\\n\\n        for(int len=1;len<=n;len++){\\n            for(int i1=len-1;i1>=0;i1--){\\n                for(int i2=len-1;i2>=0;i2--){\\n\\n                    if(len==1){\\n                        dp[i1][i2][len]=(s1[i1]==s2[i2]);\\n                    }\\n                    else\\n                    {\\n                        for(int l=1;l<len;l++){\\n                            bool notSwapped=(dp[i1][i2][l] && dp[i1+l][i2+l][len-l]);\\n                            bool swapped=(dp[i1][i2+len-l][l] && dp[i1+l][i2][len-l]);\\n                            if(swapped || notSwapped){\\n                                dp[i1][i2][len]=true;\\n                                break;\\n                            }\\n                        }\\n                        dp[i1][i2][len]=false;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n\\n        return dp[0][0][n];\\n        \\n    }\\n};``\\n"
                    },
                    {
                        "username": "luanct",
                        "content": "I expect to start every day of work with full energy by doing Daily LC but you guys give me hard problems everyday \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            }
        ]
    },
    {
        "title": "Repeated DNA Sequences",
        "question_content": "<p>The <strong>DNA sequence</strong> is composed of a series of nucleotides abbreviated as <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;T&#39;</code>.</p>\n\n<ul>\n\t<li>For example, <code>&quot;ACGAATTCCG&quot;</code> is a <strong>DNA sequence</strong>.</li>\n</ul>\n\n<p>When studying <strong>DNA</strong>, it is useful to identify repeated sequences within the DNA.</p>\n\n<p>Given a string <code>s</code> that represents a <strong>DNA sequence</strong>, return all the <strong><code>10</code>-letter-long</strong> sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\n<strong>Output:</strong> [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"AAAAAAAAAAAAA\"\n<strong>Output:</strong> [\"AAAAAAAAAA\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, or <code>&#39;T&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 53855,
                "title": "7-lines-simple-java-o-n",
                "content": "    public List<String> findRepeatedDnaSequences(String s) {\\n        Set seen = new HashSet(), repeated = new HashSet();\\n        for (int i = 0; i + 9 < s.length(); i++) {\\n            String ten = s.substring(i, i + 10);\\n            if (!seen.add(ten))\\n                repeated.add(ten);\\n        }\\n        return new ArrayList(repeated);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<String> findRepeatedDnaSequences(String s) {\\n        Set seen = new HashSet(), repeated = new HashSet();\\n        for (int i = 0; i + 9 < s.length(); i++) {\\n            String ten = s.substring(i, i + 10);\\n            if (!seen.add(ten))\\n                repeated.add(ten);\\n        }\\n        return new ArrayList(repeated);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 53867,
                "title": "clean-java-solution-hashmap-bits-manipulation",
                "content": "    public List<String> findRepeatedDnaSequences(String s) {\\n        Set<Integer> words = new HashSet<>();\\n        Set<Integer> doubleWords = new HashSet<>();\\n        List<String> rv = new ArrayList<>();\\n        char[] map = new char[26];\\n        //map['A' - 'A'] = 0;\\n        map['C' - 'A'] = 1;\\n        map['G' - 'A'] = 2;\\n        map['T' - 'A'] = 3;\\n\\n        for(int i = 0; i < s.length() - 9; i++) {\\n            int v = 0;\\n            for(int j = i; j < i + 10; j++) {\\n                v <<= 2;\\n                v |= map[s.charAt(j) - 'A'];\\n            }\\n            if(!words.add(v) && doubleWords.add(v)) {\\n                rv.add(s.substring(i, i + 10));\\n            }\\n        }\\n        return rv;\\n    }",
                "solutionTags": [],
                "code": "    public List<String> findRepeatedDnaSequences(String s) {\\n        Set<Integer> words = new HashSet<>();\\n        Set<Integer> doubleWords = new HashSet<>();\\n        List<String> rv = new ArrayList<>();\\n        char[] map = new char[26];\\n        //map['A' - 'A'] = 0;\\n        map['C' - 'A'] = 1;\\n        map['G' - 'A'] = 2;\\n        map['T' - 'A'] = 3;\\n\\n        for(int i = 0; i < s.length() - 9; i++) {\\n            int v = 0;\\n            for(int j = i; j < i + 10; j++) {\\n                v <<= 2;\\n                v |= map[s.charAt(j) - 'A'];\\n            }\\n            if(!words.add(v) && doubleWords.add(v)) {\\n                rv.add(s.substring(i, i + 10));\\n            }\\n        }\\n        return rv;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 53877,
                "title": "i-did-it-in-10-lines-of-c",
                "content": "The main idea is to store the substring as int in map to bypass the memory limits.\\n\\nThere are only four possible character A, C, G, and T, but I want to use 3 bits per letter instead of 2.\\n\\nWhy? It's easier to code.\\n\\nA is 0x41, C is 0x43, G is 0x47, T is 0x54. Still don't see it? Let me write it in octal.\\n\\nA is 0101, C is 0103, G is 0107, T is 0124. The last digit in octal are different for all four letters. That's all we need!\\n\\nWe can simply use `s[i] & 7` to get the last digit which are just the last 3 bits, it's much easier than lookup table or switch or a bunch of if and else, right?\\n\\nWe don't really need to generate the substring from the int. While counting the number of occurrences, we can push the substring into result as soon as the count becomes 2, so there won't be any duplicates in the result.\\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<int, int> m;\\n        vector<string> r;\\n        int t = 0, i = 0, ss = s.size();\\n        while (i < 9)\\n            t = t << 3 | s[i++] & 7;\\n        while (i < ss)\\n            if (m[t = t << 3 & 0x3FFFFFFF | s[i++] & 7]++ == 1)\\n                r.push_back(s.substr(i - 10, 10));\\n        return r;\\n    }\\n\\nBTW, the OJ doesn't seems to have test cases which the given string length is smaller than 9, so I didn't check it to make the code simpler.\\n\\nAny suggestions?\\n\\nUpdate:\\n\\nI realised that I can use `s[i] >> 1 & 3` to get 2 bits, but then I won't be able to remove the first loop as 1337c0d3r suggested.",
                "solutionTags": [],
                "code": "The main idea is to store the substring as int in map to bypass the memory limits.\\n\\nThere are only four possible character A, C, G, and T, but I want to use 3 bits per letter instead of 2.\\n\\nWhy? It's easier to code.\\n\\nA is 0x41, C is 0x43, G is 0x47, T is 0x54. Still don't see it? Let me write it in octal.\\n\\nA is 0101, C is 0103, G is 0107, T is 0124. The last digit in octal are different for all four letters. That's all we need!\\n\\nWe can simply use `s[i] & 7` to get the last digit which are just the last 3 bits, it's much easier than lookup table or switch or a bunch of if and else, right?\\n\\nWe don't really need to generate the substring from the int. While counting the number of occurrences, we can push the substring into result as soon as the count becomes 2, so there won't be any duplicates in the result.\\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<int, int> m;\\n        vector<string> r;\\n        int t = 0, i = 0, ss = s.size();\\n        while (i < 9)\\n            t = t << 3 | s[i++] & 7;\\n        while (i < ss)\\n            if (m[t = t << 3 & 0x3FFFFFFF | s[i++] & 7]++ == 1)\\n                r.push_back(s.substr(i - 10, 10));\\n        return r;\\n    }\\n\\nBTW, the OJ doesn't seems to have test cases which the given string length is smaller than 9, so I didn't check it to make the code simpler.\\n\\nAny suggestions?\\n\\nUpdate:\\n\\nI realised that I can use `s[i] >> 1 & 3` to get 2 bits, but then I won't be able to remove the first loop as 1337c0d3r suggested.",
                "codeTag": "Unknown"
            },
            {
                "id": 53952,
                "title": "20-ms-solution-c-with-explanation",
                "content": "One obvious way to do this is to use a hash table mapping strings to counts.  (e.g. H[\"AAAAAAAAAA\"] represents the number of times we have seen AAAAAAAAAA.  This will work in O(n) time, but its useful to discuss why this is not a good solution:\\n\\n - Runtime constant (from hashing): When using a hash table, there is a runtime hit for hashing the string.  In this case, converting the string to a table index.  That will presumably mean looking at each character of the string. Since each character is part of 10 different substrings (other than the end  characters), that means 10n character reads.  Still linear, but we can do better on the constant.\\n - Memory (values): There isn\\'t any reason to store a count. Each possible string has only 3 states we need to track: \"never been seen\", \"been seen once\", and \"been seen more than once\".  This requires only two bits to track -- not the 4-8 bytes needed for aninteger.\\n - Memory (keys): A hash table needs to store each key (to resolve collisions).  At 10 bytes per key, thats 10*n bytes -- a potential problem if n is every large, and completely unnecessary.\\n\\nHere is how we address the three problems:\\n\\n**Hashing**: We compute the hash ourselves, but take advantage of the overlapping.  We treat each letter as a two-bit number.  (Arbitrarily, A=0, C=1, G=2, T=3.) We treat ten consecutive letters as a 20-bit integer.  We can calculate the first one with:\\n\\n        int val = 0;\\n        for (int i=0; i < 10; i++)\\n            val = (val << 2) | char2val(s[i]);\\n\\nNow, to compute the next string:\\n\\n       val = ((val << 2) & mask) | char2val(s[10]);\\n\\nWhere:\\n\\n 1. mask: 20 consecutive bits ((1 << 21) -1).  \\n 2. ((val << 2) & mask: shift everything over two bits, and get rid of the most significant bits.\\n 3. ((val << 2) & mask) | char2val(s[10]): Replace the right-most two bits with the character code.\\n\\nMuch faster than looking at every character 10 times.\\n\\n\\n**Hash table**: We instead use two bit-sets.  There are 2^{21}-1 possible strings.  We need a bit in each set for each possible string. The first set (S1) tells us if the string has been seen once or not.  The second set (S2) tell us whether the string has been seen more than once.\\n\\n \\nCode:\\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        if (s.size() <= 10)\\n            return vector<string>();\\n            \\n        vector<string> R;\\n        bitset<1<<20> S1;\\n        bitset<1<<20> S2;\\n        \\n        int val = 0;\\n        for (int i=0; i < 10; i++)   // Calc. the has value for the first string.\\n            val = (val << 2) | char2val(s[i]);\\n        S1.set(val);\\n        \\n        int mask = (1 << 20) - 1;\\n        for (int i=10; i < s.size(); i++) {\\n            // Calc the hash value for the string ending at position i.\\n            val = ((val << 2) & mask) | char2val(s[i]);  \\n            if (S2[val])\\n                continue;\\n            if (S1[val]) {\\n                R.push_back(s.substr(i-10+1, 10));\\n                S2.set(val);\\n            }\\n            else\\n                S1.set(val);\\n        }\\n        return R;\\n    }\\n    \\n    int char2val(char c) {\\n        switch (c) {\\n            case \\'A\\': return 0;\\n            case \\'C\\': return 1;\\n            case \\'G\\': return 2;\\n            case \\'T\\': return 3;\\n        }\\n     }",
                "solutionTags": [
                    "Hash Table",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "One obvious way to do this is to use a hash table mapping strings to counts.  (e.g. H[\"AAAAAAAAAA\"] represents the number of times we have seen AAAAAAAAAA.  This will work in O(n) time, but its useful to discuss why this is not a good solution:\\n\\n - Runtime constant (from hashing): When using a hash table, there is a runtime hit for hashing the string.  In this case, converting the string to a table index.  That will presumably mean looking at each character of the string. Since each character is part of 10 different substrings (other than the end  characters), that means 10n character reads.  Still linear, but we can do better on the constant.\\n - Memory (values): There isn\\'t any reason to store a count. Each possible string has only 3 states we need to track: \"never been seen\", \"been seen once\", and \"been seen more than once\".  This requires only two bits to track -- not the 4-8 bytes needed for aninteger.\\n - Memory (keys): A hash table needs to store each key (to resolve collisions).  At 10 bytes per key, thats 10*n bytes -- a potential problem if n is every large, and completely unnecessary.\\n\\nHere is how we address the three problems:\\n\\n**Hashing**: We compute the hash ourselves, but take advantage of the overlapping.  We treat each letter as a two-bit number.  (Arbitrarily, A=0, C=1, G=2, T=3.) We treat ten consecutive letters as a 20-bit integer.  We can calculate the first one with:\\n\\n        int val = 0;\\n        for (int i=0; i < 10; i++)\\n            val = (val << 2) | char2val(s[i]);\\n\\nNow, to compute the next string:\\n\\n       val = ((val << 2) & mask) | char2val(s[10]);\\n\\nWhere:\\n\\n 1. mask: 20 consecutive bits ((1 << 21) -1).  \\n 2. ((val << 2) & mask: shift everything over two bits, and get rid of the most significant bits.\\n 3. ((val << 2) & mask) | char2val(s[10]): Replace the right-most two bits with the character code.\\n\\nMuch faster than looking at every character 10 times.\\n\\n\\n**Hash table**: We instead use two bit-sets.  There are 2^{21}-1 possible strings.  We need a bit in each set for each possible string. The first set (S1) tells us if the string has been seen once or not.  The second set (S2) tell us whether the string has been seen more than once.\\n\\n \\nCode:\\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        if (s.size() <= 10)\\n            return vector<string>();\\n            \\n        vector<string> R;\\n        bitset<1<<20> S1;\\n        bitset<1<<20> S2;\\n        \\n        int val = 0;\\n        for (int i=0; i < 10; i++)   // Calc. the has value for the first string.\\n            val = (val << 2) | char2val(s[i]);\\n        S1.set(val);\\n        \\n        int mask = (1 << 20) - 1;\\n        for (int i=10; i < s.size(); i++) {\\n            // Calc the hash value for the string ending at position i.\\n            val = ((val << 2) & mask) | char2val(s[i]);  \\n            if (S2[val])\\n                continue;\\n            if (S1[val]) {\\n                R.push_back(s.substr(i-10+1, 10));\\n                S2.set(val);\\n            }\\n            else\\n                S1.set(val);\\n        }\\n        return R;\\n    }\\n    \\n    int char2val(char c) {\\n        switch (c) {\\n            case \\'A\\': return 0;\\n            case \\'C\\': return 1;\\n            case \\'G\\': return 2;\\n            case \\'T\\': return 3;\\n        }\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 898924,
                "title": "c-simple-and-short-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> counter;\\n        vector<string> res;\\n        \\n        if (s.size() < 10) return res;\\n        \\n        for (int i=0; i<s.size()-9; i++)\\n            counter[s.substr(i, 10)]++;\\n        \\n        for (auto a:counter)\\n            if (a.second > 1)\\n                res.push_back(a.first);\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> counter;\\n        vector<string> res;\\n        \\n        if (s.size() < 10) return res;\\n        \\n        for (int i=0; i<s.size()-9; i++)\\n            counter[s.substr(i, 10)]++;\\n        \\n        for (auto a:counter)\\n            if (a.second > 1)\\n                res.push_back(a.first);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53902,
                "title": "short-java-rolling-hash-solution",
                "content": "Hi guys!\\n\\nThe idea is to use [rolling hash][1] technique or in case of string search also known as [Rabin-Karp algorithm][2]. As our alphabet A consists of only 4 letters we can be not afraid of collisions. The hash for a current window slice could be found in a constant time by subtracting the former first character times size of the A in the power of 9 and updating remaining hash by the standard rule: hash = hash*A.size() + curr_char.\\n\\nCheck out the Java code below.\\n\\nHope it helps!\\n\\n----------\\n\\n    public class Solution {\\n        private static final Map<Character, Integer> A = new HashMap<>();\\n        static { A.put('A',0); A.put('C',1); A.put('G',2); A.put('T',3); }\\n        private final int A_SIZE_POW_9 = (int) Math.pow(A.size(), 9);\\n    \\n        public List<String> findRepeatedDnaSequences(String s) {\\n            Set<String> res = new HashSet<>();\\n            Set<Integer> hashes = new HashSet<>();\\n            for (int i = 0, rhash = 0; i < s.length(); i++) {\\n                if (i > 9) rhash -= A_SIZE_POW_9 * A.get(s.charAt(i-10));\\n                rhash = A.size() * rhash + A.get(s.charAt(i));\\n                if (i > 8 && !hashes.add(rhash)) res.add(s.substring(i-9,i+1));\\n            }\\n            return new ArrayList<>(res);\\n        }\\n    }\\n\\n  [1]: http://en.wikipedia.org/wiki/Rolling_hash\\n  [2]: http://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        private static final Map<Character, Integer> A = new HashMap<>();\\n        static { A.put('A',0); A.put('C',1); A.put('G',2); A.put('T',3); }",
                "codeTag": "Java"
            },
            {
                "id": 53892,
                "title": "4-lines-python-solution",
                "content": "I use a defauldict to initialize as 0 the dictionary of integers, then I check the dictionary for substrings seen more than once.\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a list of strings\\n        def findRepeatedDnaSequences(self, s):\\n            sequences = collections.defaultdict(int) #set '0' as the default value for non-existing keys\\n            for i in range(len(s)):\\n                sequences[s[i:i+10]] += 1#add 1 to the count\\n            return [key for key, value in sequences.iteritems() if value > 1] #extract the relevant keys",
                "solutionTags": [
                    "Python"
                ],
                "code": "I use a defauldict to initialize as 0 the dictionary of integers, then I check the dictionary for substrings seen more than once.\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a list of strings\\n        def findRepeatedDnaSequences(self, s):\\n            sequences = collections.defaultdict(int) #set '0' as the default value for non-existing keys\\n            for i in range(len(s)):\\n                sequences[s[i:i+10]] += 1#add 1 to the count\\n            return [key for key, value in sequences.iteritems() if value > 1] #extract the relevant keys",
                "codeTag": "Java"
            },
            {
                "id": 53971,
                "title": "easy-understand-and-straightforward-java-solution",
                "content": "    public class Solution {\\n        public List<String> findRepeatedDnaSequences(String s) {\\n            List<String> res = new ArrayList<String>();\\n            Set<String> resset = new HashSet<String>();\\n            if(s == null || s.length() <= 10){\\n                return res;\\n            }\\n            Set<String> set = new HashSet<String>();\\n            int len = s.length();\\n            for(int i = 0; i <= len - 10; i++){\\n                String sub = s.substring(i, i + 10);\\n                if(!set.add(sub)){\\n                    resset.add(sub);\\n                }\\n            }\\n            res.addAll(resset);\\n            return res;\\n        }\\n    }\\n\\n\\nmy idea is to get all the possible 10 letter long sequences and put them into set, it the operation failed, it means there are duplicates. so put the sequence into another set(\"AAAAAAAAAAAA\" could have three \"AAAAAAAAAA\" sequences, so this set will remove the duplicates) then add all the set to the final list.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> findRepeatedDnaSequences(String s) {\\n            List<String> res = new ArrayList<String>();\\n            Set<String> resset = new HashSet<String>();\\n            if(s == null || s.length() <= 10){\\n                return res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 53964,
                "title": "10-lines-c-code-8-ms-passed",
                "content": "    vector<string> findRepeatedDnaSequences(string s) {\\n        char  hashMap[1048576] = {0};\\n        vector<string> ans;\\n        int len = s.size(),hashNum = 0;\\n        if (len < 11) return ans;\\n        for (int i = 0;i < 9;++i)\\n            hashNum = hashNum << 2 | (s[i] - 'A' + 1) % 5;\\n        for (int i = 9;i < len;++i)\\n            if (hashMap[hashNum = (hashNum << 2 | (s[i] - 'A' + 1) % 5) & 0xfffff]++ == 1)\\n                ans.push_back(s.substr(i-9,10));\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> findRepeatedDnaSequences(string s) {\\n        char  hashMap[1048576] = {0};\\n        vector<string> ans;\\n        int len = s.size(),hashNum = 0;\\n        if (len < 11) return ans;\\n        for (int i = 0;i < 9;++i)\\n            hashNum = hashNum << 2 | (s[i] - 'A' + 1) % 5;\\n        for (int i = 9;i < len;++i)\\n            if (hashMap[hashNum = (hashNum << 2 | (s[i] - 'A' + 1) % 5) & 0xfffff]++ == 1)\\n                ans.push_back(s.substr(i-9,10));\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 898297,
                "title": "python-2-solutions-hashtable-rolling-hash-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Hashtable**\\n```python3\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        n = len(s)\\n        cnt = defaultdict(int)\\n        ans = []\\n\\n        for i in range(n - 9):\\n            dna = s[i:i+10]\\n            cnt[dna] += 1\\n            if cnt[dna] == 2:\\n                ans.append(dna)\\n\\n        return ans\\n```\\n\\n**Complexity**\\n- Time & Space: `O(10*N)`\\n\\n----\\n**\\u2714\\uFE0F Solution 2: Hashtable + Rolling Hash**\\n```python3\\nclass Solution(object):\\n    def getVal(self, c):\\n        if c == \\'A\\': return 0\\n        if c == \\'C\\': return 1\\n        if c == \\'G\\': return 2\\n        return 3\\n\\n    def findRepeatedDnaSequences(self, s):\\n        n = len(s)\\n        cnt = defaultdict(int)\\n        ans = []\\n        \\n        dnaHash = 0\\n        POWN1 = 4 ** 9\\n        for i in range(n):\\n            dnaHash = dnaHash * 4 + self.getVal(s[i])\\n            if i >= 9:\\n                cnt[dnaHash] += 1\\n                if cnt[dnaHash] == 2:\\n                    ans.append(s[i-9:i+1])\\n\\n                dnaHash -= POWN1 * self.getVal(s[i-9])\\n\\n        return ans\\n```\\n**Complexity**\\n- Time & Space: `O(10*N)` (in worst case)",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Rolling Hash"
                ],
                "code": "```python3\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        n = len(s)\\n        cnt = defaultdict(int)\\n        ans = []\\n\\n        for i in range(n - 9):\\n            dna = s[i:i+10]\\n            cnt[dna] += 1\\n            if cnt[dna] == 2:\\n                ans.append(dna)\\n\\n        return ans\\n```\n```python3\\nclass Solution(object):\\n    def getVal(self, c):\\n        if c == \\'A\\': return 0\\n        if c == \\'C\\': return 1\\n        if c == \\'G\\': return 2\\n        return 3\\n\\n    def findRepeatedDnaSequences(self, s):\\n        n = len(s)\\n        cnt = defaultdict(int)\\n        ans = []\\n        \\n        dnaHash = 0\\n        POWN1 = 4 ** 9\\n        for i in range(n):\\n            dnaHash = dnaHash * 4 + self.getVal(s[i])\\n            if i >= 9:\\n                cnt[dnaHash] += 1\\n                if cnt[dnaHash] == 2:\\n                    ans.append(s[i-9:i+1])\\n\\n                dnaHash -= POWN1 * self.getVal(s[i-9])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53856,
                "title": "beating-100-submission-in-c-well-explained-and-commented",
                "content": "Since there are only 4 different letters we need to distinguish, so enumeration or something similar can perfectly handle this case;\\n\\nGiven the ASCII Code for them are   **A - 65, C - 67, G - 71, T - 84** \\n\\n(X - 'A' + 1)%5 will be A -> 1, C -> 3, G -> 2, T -> 0 and can be represented by only two-bits!\\n10 letters can be represented by 20-bits which is smaller than 32 bits of an integer; so we can just use a integer to represent the 10-letter-length substring.\\n\\n> the basic idea has been presented, do not be too lazy to read code -> reading effectively is quite essential.\\n\\nWe can now handle it using bit manipulation and hash table by just traversing one single round. \\n\\n> hashTable[hashNum = (hashNum << 2 | (s[i] - 'A' + 1) % 5) & 0xfffff]\\n\\nBang! End of Story!\\n\\n- space cost O(2^20)\\n- time cost O(n)\\n\\n\\n----------\\n\\n\\n    char** findRepeatedDnaSequences(char*s, int* returnSize)\\n    {\\n        int size = strlen(s);\\n        if(size < 11) return NULL; //at least 11 letters;\\n        int hashTable[1<<21] = {0}; //allocate a hash map array for 20-bit key;\\n        int hashNum = 0;\\n        int index = 0;\\n        char** sArray = (char**)malloc(sizeof(char*) * size);\\n        for(int i = 0; i < 9; i++) //the head of the first key;\\n            hashNum = hashNum << 2 | (*(s+i) - 'A' + 1) % 5;\\n        for(int i = 9; i < size; i++) //one step forward, one different string will be covered by the key simply;\\n        {\\n            if(hashTable[hashNum = (hashNum << 2 | (*(s+i) - 'A' + 1) % 5) & 0xfffff]++ == 1) //each repeated substring will only be collected once;\\n            {\\n                sArray[index] = (char*)malloc(11 * sizeof(char));\\n                strncpy(sArray[index], s+i-9, 10);\\n                sArray[index++][10] = '\\\\0';\\n            }\\n        }\\n        *returnSize = index;\\n        return sArray;\\n    }",
                "solutionTags": [],
                "code": "Since there are only 4 different letters we need to distinguish, so enumeration or something similar can perfectly handle this case;\\n\\nGiven the ASCII Code for them are   **A - 65, C - 67, G - 71, T - 84** \\n\\n(X - 'A' + 1)%5 will be A -> 1, C -> 3, G -> 2, T -> 0 and can be represented by only two-bits!\\n10 letters can be represented by 20-bits which is smaller than 32 bits of an integer; so we can just use a integer to represent the 10-letter-length substring.\\n\\n> the basic idea has been presented, do not be too lazy to read code -> reading effectively is quite essential.\\n\\nWe can now handle it using bit manipulation and hash table by just traversing one single round. \\n\\n> hashTable[hashNum = (hashNum << 2 | (s[i] - 'A' + 1) % 5) & 0xfffff]\\n\\nBang! End of Story!\\n\\n- space cost O(2^20)\\n- time cost O(n)\\n\\n\\n----------\\n\\n\\n    char** findRepeatedDnaSequences(char*s, int* returnSize)\\n    {\\n        int size = strlen(s);\\n        if(size < 11) return NULL; //at least 11 letters;\\n        int hashTable[1<<21] = {0}; //allocate a hash map array for 20-bit key;\\n        int hashNum = 0;\\n        int index = 0;\\n        char** sArray = (char**)malloc(sizeof(char*) * size);\\n        for(int i = 0; i < 9; i++) //the head of the first key;\\n            hashNum = hashNum << 2 | (*(s+i) - 'A' + 1) % 5;\\n        for(int i = 9; i < size; i++) //one step forward, one different string will be covered by the key simply;\\n        {\\n            if(hashTable[hashNum = (hashNum << 2 | (*(s+i) - 'A' + 1) % 5) & 0xfffff]++ == 1) //each repeated substring will only be collected once;\\n            {\\n                sArray[index] = (char*)malloc(11 * sizeof(char));\\n                strncpy(sArray[index], s+i-9, 10);\\n                sArray[index++][10] = '\\\\0';\\n            }\\n        }\\n        *returnSize = index;\\n        return sArray;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 898299,
                "title": "python-2-lines-solution-explained",
                "content": "Let us just put all sequences of length `10` into list, then apply counter: count how many times each element is present and finally return elements with frequency more than `1`.\\n\\n**Complexity**: Time and space complexity is `O(10n)`: ther will be `O(n)` substrings of length `10`.\\n\\n```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s):\\n        Count = Counter(s[i-10:i] for i in range(10, len(s) + 1))\\n        return [key for key in Count if Count[key] > 1]   \\n```\\n\\n**Remark** When I saw this problem, my first idea was to use rolling hash, which potentially can give us `O(n)` instead of `O(10n)` complexity. However we need not only evaluate how many repeated substrings of length `10` we have, but also return them all. This potentially can spend `O(n)` time: imagine example:\\n`TT`, where `T` is string of length `n/2`. Then if all substring in `T` are different, we have `O(n/2)` different substings, we need to return, which gives us `O(5n)` space complexity of output.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s):\\n        Count = Counter(s[i-10:i] for i in range(10, len(s) + 1))\\n        return [key for key in Count if Count[key] > 1]   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 53958,
                "title": "clean-python-code",
                "content": "    class Solution(object):\\n        def findRepeatedDnaSequences(self, s):\\n            r, record = set(), set()\\n            for i in xrange(len(s) - 9):\\n                substring = s[i:i + 10]\\n                [record, r][substring in record].add(substring)\\n            return list(r)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def findRepeatedDnaSequences(self, s):\\n            r, record = set(), set()\\n            for i in xrange(len(s) - 9):\\n                substring = s[i:i + 10]\\n                [record, r][substring in record].add(substring)\\n            return list(r)",
                "codeTag": "Java"
            },
            {
                "id": 53990,
                "title": "11ms-solution-with-unified-hash-fxn",
                "content": "Appricate for advice.\\n\\n    vector<string> findRepeatedDnaSequences(string s)\\n    {\\n        vector<string> ret;\\n        if ( s.length() < 11 )\\n        {\\n        \\treturn ret;\\n        }\\n        \\n        char table[1048576] = \"\";\\n        unsigned int hash = 0U;\\n        \\n        for ( size_t i = 0; i < 10; ++i )\\n        {\\n        \\t/** 'A' - 'A' + 1 = 1  = 1 (mod 5)\\n        \\t *  'C' - 'A' + 1 = 3  = 3 (mod 5)\\n        \\t *  'G' - 'A' + 1 = 7  = 2 (mod 5)\\n        \\t *  'T' - 'A' + 1 = 20 = 0 (mod 5)\\n        \\t */\\n        \\thash = ( hash << 2 ) | ( ( s[i] - 'A' + 1 ) % 5 );\\n        }\\n        \\t\\n        table[hash] = 1;\\n        \\n        for ( size_t i = 10; i < s.length(); ++i )\\n        {\\n        \\thash = ( ( hash << 2 )\\n                 ^ ( ( s[ i - 10 ] - 'A' + 1 ) % 5 ) << 20 )\\n                 | ( ( s[i] - 'A' + 1 ) % 5 );\\n        \\t         \\n        \\tif ( table[hash] == 0 )\\n        \\t{\\n        \\t\\ttable[hash] = 1;\\n        \\t}\\n        \\telse if ( table[hash] == 1 )\\n        \\t{\\n        \\t\\ttable[hash] = 2;\\n        \\t\\tret.push_back( string( s, i - 9, 10 ) );\\n        \\t}\\n        }\\n        \\n        return ret;\\n    }",
                "solutionTags": [
                    "Hash Function"
                ],
                "code": "Appricate for advice.\\n\\n    vector<string> findRepeatedDnaSequences(string s)\\n    {\\n        vector<string> ret;\\n        if ( s.length() < 11 )\\n        {\\n        \\treturn ret;\\n        }\\n        \\n        char table[1048576] = \"\";\\n        unsigned int hash = 0U;\\n        \\n        for ( size_t i = 0; i < 10; ++i )\\n        {\\n        \\t/** 'A' - 'A' + 1 = 1  = 1 (mod 5)\\n        \\t *  'C' - 'A' + 1 = 3  = 3 (mod 5)\\n        \\t *  'G' - 'A' + 1 = 7  = 2 (mod 5)\\n        \\t *  'T' - 'A' + 1 = 20 = 0 (mod 5)\\n        \\t */\\n        \\thash = ( hash << 2 ) | ( ( s[i] - 'A' + 1 ) % 5 );\\n        }\\n        \\t\\n        table[hash] = 1;\\n        \\n        for ( size_t i = 10; i < s.length(); ++i )\\n        {\\n        \\thash = ( ( hash << 2 )\\n                 ^ ( ( s[ i - 10 ] - 'A' + 1 ) % 5 ) << 20 )\\n                 | ( ( s[i] - 'A' + 1 ) % 5 );\\n        \\t         \\n        \\tif ( table[hash] == 0 )\\n        \\t{\\n        \\t\\ttable[hash] = 1;\\n        \\t}\\n        \\telse if ( table[hash] == 1 )\\n        \\t{\\n        \\t\\ttable[hash] = 2;\\n        \\t\\tret.push_back( string( s, i - 9, 10 ) );\\n        \\t}\\n        }\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54076,
                "title": "just-7-lines-of-code",
                "content": "I am too lazy to design my own hash function; Hence I just used the one provided by C++.\\n\\n\\n\\n \\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n            \\n            unordered_map<size_t,int> MP;\\n            hash<string> hash_fn;\\n            vector<string> ret;\\n            \\n            for(int i = 0; i < int(s.size()) - 9; ++i)\\n                if(MP[hash_fn(s.substr(i,10))]++ == 1 )\\n                   ret.push_back(s.substr(i,10));\\n                   \\n          return ret;\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "I am too lazy to design my own hash function; Hence I just used the one provided by C++.\\n\\n\\n\\n \\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n            \\n            unordered_map<size_t,int> MP;\\n            hash<string> hash_fn;\\n            vector<string> ret;\\n            \\n            for(int i = 0; i < int(s.size()) - 9; ++i)\\n                if(MP[hash_fn(s.substr(i,10))]++ == 1 )\\n                   ret.push_back(s.substr(i,10));\\n                   \\n          return ret;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 206968,
                "title": "javascript",
                "content": "```\\nvar findRepeatedDnaSequences = function(s) {\\n    let store = new Set(), result = new Set()\\n    for(let i = 0; i < s.length - 9; i++) {\\n        const str = s.substring(i, i + 10)\\n        if(store.has(str)) {\\n            result.add(str)\\n        } else {\\n            store.add(str)\\n        }\\n    }\\n    return Array.from(result)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findRepeatedDnaSequences = function(s) {\\n    let store = new Set(), result = new Set()\\n    for(let i = 0; i < s.length - 9; i++) {\\n        const str = s.substring(i, i + 10)\\n        if(store.has(str)) {\\n            result.add(str)\\n        } else {\\n            store.add(str)\\n        }\\n    }\\n    return Array.from(result)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1593972,
                "title": "simple-c-soution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        int n = s.length();\\n        vector <string> ans;\\n        if(n < 10){\\n            return ans;\\n        }\\n        unordered_map <string,int> ump;\\n        for(int i=0;i<s.size()-9;i++){\\n        string t = s.substr(i,10);\\n        ump[t]++;\\n        }\\n        \\n        for(auto it : ump){\\n            if(it.second > 1){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window",
                    "Rolling Hash",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        int n = s.length();\\n        vector <string> ans;\\n        if(n < 10){\\n            return ans;\\n        }\\n        unordered_map <string,int> ump;\\n        for(int i=0;i<s.size()-9;i++){\\n        string t = s.substr(i,10);\\n        ump[t]++;\\n        }\\n        \\n        for(auto it : ump){\\n            if(it.second > 1){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898370,
                "title": "python-o-n-by-set-and-iteration-w-comment",
                "content": "Python O(n) by set and iteration\\n\\n---\\n\\n**Implementation** by set and iteration\\n\\n```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        \\n        # set for sequence\\n        sequence = set()\\n        \\n        # set for sequence with repetition\\n        repeated = set()\\n        \\n        for i in range( len(s)-9 ):\\n            \\n            # make current sequence for i to i+10\\n            cur_seq = s[i:i+10]\\n            \\n            if cur_seq in sequence:\\n                # check for repetition\\n                repeated.add( cur_seq )\\n            \\n            # add to sequence set\\n            sequence.add( cur_seq )\\n        \\n        return [ *repeated ]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        \\n        # set for sequence\\n        sequence = set()\\n        \\n        # set for sequence with repetition\\n        repeated = set()\\n        \\n        for i in range( len(s)-9 ):\\n            \\n            # make current sequence for i to i+10\\n            cur_seq = s[i:i+10]\\n            \\n            if cur_seq in sequence:\\n                # check for repetition\\n                repeated.add( cur_seq )\\n            \\n            # add to sequence set\\n            sequence.add( cur_seq )\\n        \\n        return [ *repeated ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53992,
                "title": "easy-to-understand-java-solution-with-well-commented-code",
                "content": "This solution is inspired. I worked to understand it myself and commented the code.\\n\\n    public List<String> findRepeatedDnaSequences(String s) {\\n            Set<Integer> firstTime = new HashSet<Integer>();\\n            Set<Integer> secondTime = new HashSet<Integer>();\\n            List<String> list = new ArrayList<String>();\\n            \\n            char[] map = new char[26];\\n            int len = s.length();\\n            \\n            // Hashing function. We have only 4 letters which we can represent by 2 bits.\\n            map['A' - 'A'] = 0; // A = 00\\n            map['C' - 'A'] = 1; // B = 01\\n            map['G' - 'A'] = 2; // C = 10\\n            map['T' - 'A'] = 3; // D = 11\\n            \\n            for(int i=0; i<= len - 10; i++)\\n            {\\n                int sequence = 0;\\n                for(int j=i; j< i+10; j++)\\n                {\\n                    // Shift existing sequence by two to make space for the new character coming\\n                    sequence = sequence << 2;\\n                    \\n                    // Copy the character from the map and paste those two bits in the newly created space. Read bit wise OR.\\n                    sequence = sequence | map[s.charAt(j) - 'A'];\\n                }\\n                \\n                // For this number to be added in the list, this should be the second time this number is appearing\\n                // For this if condition to be true, firstTime.add() should be false.\\n                // firstTime.add() will be false when there is already the same number present.\\n                // How it will behave?\\n                // First time - firstTime.add(sequence) will return T\\n                // !firstTime.add(sequence) will become F\\n                // secondTime.add(sequence) will NOT be executed\\n                \\n                // Second time addition: \\n                // First time - firstTime.add(sequence) will return F\\n                // !firstTime.add(sequence) will become T\\n                // secondTime.add(sequence) will be executed\\n                if(!firstTime.add(sequence) && secondTime.add(sequence))\\n                {\\n                    list.add(s.substring(i, i+10));\\n                }\\n            }\\n            \\n            return list;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This solution is inspired. I worked to understand it myself and commented the code.\\n\\n    public List<String> findRepeatedDnaSequences(String s) {\\n            Set<Integer> firstTime = new HashSet<Integer>();\\n            Set<Integer> secondTime = new HashSet<Integer>();\\n            List<String> list = new ArrayList<String>();\\n            \\n            char[] map = new char[26];\\n            int len = s.length();\\n            \\n            // Hashing function. We have only 4 letters which we can represent by 2 bits.\\n            map['A' - 'A'] = 0; // A = 00\\n            map['C' - 'A'] = 1; // B = 01\\n            map['G' - 'A'] = 2; // C = 10\\n            map['T' - 'A'] = 3; // D = 11\\n            \\n            for(int i=0; i<= len - 10; i++)\\n            {\\n                int sequence = 0;\\n                for(int j=i; j< i+10; j++)\\n                {\\n                    // Shift existing sequence by two to make space for the new character coming\\n                    sequence = sequence << 2;\\n                    \\n                    // Copy the character from the map and paste those two bits in the newly created space. Read bit wise OR.\\n                    sequence = sequence | map[s.charAt(j) - 'A'];\\n                }\\n                \\n                // For this number to be added in the list, this should be the second time this number is appearing\\n                // For this if condition to be true, firstTime.add() should be false.\\n                // firstTime.add() will be false when there is already the same number present.\\n                // How it will behave?\\n                // First time - firstTime.add(sequence) will return T\\n                // !firstTime.add(sequence) will become F\\n                // secondTime.add(sequence) will NOT be executed\\n                \\n                // Second time addition: \\n                // First time - firstTime.add(sequence) will return F\\n                // !firstTime.add(sequence) will become T\\n                // secondTime.add(sequence) will be executed\\n                if(!firstTime.add(sequence) && secondTime.add(sequence))\\n                {\\n                    list.add(s.substring(i, i+10));\\n                }\\n            }\\n            \\n            return list;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 53948,
                "title": "java-28ms-solution-beats-100-of-java-submissions",
                "content": "The idea is inspired by @crazyirontoiletpaper's solution.\\n\\n    public class Solution {\\n        public List<String> findRepeatedDnaSequences(String DNA) {\\n            ArrayList<String> res = new ArrayList<String>();\\n            if(DNA.length()<10)    return res;\\n            HashSet<Integer> once = new HashSet<Integer>();\\n            HashSet<Integer> twice = new HashSet<Integer>();\\n            int[] map = new int[26];\\n            map['A'-'A'] = 0;\\n            map['C'-'A'] = 1;\\n            map['G'-'A'] = 2;\\n            map['T'-'A'] = 3;\\n            int enc = 0;\\n            for(int i=0; i<9; ++i){\\n                enc <<=2;\\n                enc |= map[DNA.charAt(i)-'A'];\\n            }\\n            for(int j=9; j<DNA.length(); ++j){\\n                enc <<=2;\\n                enc &= 0xfffff;\\n                enc |= map[DNA.charAt(j)-'A'];\\n                if(!once.add(enc) && twice.add(enc))\\n                    res.add(DNA.substring(j-9,j+1));\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<String> findRepeatedDnaSequences(String DNA) {\\n            ArrayList<String> res = new ArrayList<String>();\\n            if(DNA.length()<10)    return res;\\n            HashSet<Integer> once = new HashSet<Integer>();\\n            HashSet<Integer> twice = new HashSet<Integer>();\\n            int[] map = new int[26];\\n            map['A'-'A'] = 0;\\n            map['C'-'A'] = 1;\\n            map['G'-'A'] = 2;\\n            map['T'-'A'] = 3;\\n            int enc = 0;\\n            for(int i=0; i<9; ++i){\\n                enc <<=2;\\n                enc |= map[DNA.charAt(i)-'A'];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 899795,
                "title": "javascript-clean-o-n-solution",
                "content": "```javascript\\nvar findRepeatedDnaSequences = function(s) {\\n    let curr = s.slice(0, 10);\\n    const seen = new Set([curr]);\\n    const res = new Set();\\n    \\n    for(let i = 10; i < s.length; i++) {\\n        curr = curr.slice(1) + s[i];\\n        if(seen.has(curr)) res.add(curr);\\n        seen.add(curr);\\n    }\\n    return [...res];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar findRepeatedDnaSequences = function(s) {\\n    let curr = s.slice(0, 10);\\n    const seen = new Set([curr]);\\n    const res = new Set();\\n    \\n    for(let i = 10; i < s.length; i++) {\\n        curr = curr.slice(1) + s[i];\\n        if(seen.has(curr)) res.add(curr);\\n        seen.add(curr);\\n    }\\n    return [...res];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 898362,
                "title": "c-key-space-optimization-beat-90",
                "content": "### Each nucleic letter can be represented within a range of 2 bits (0~3)\\n\\nA | C | G | T\\n--|---|---|----\\n0 | 1 | 2 | 3\\n\\n### Example\\n\\n#### AAAAACCCCC\\n\\nletter | bits\\n---|-------\\nA  | 00\\nA  | 00\\nA  | 00\\nA  | 00\\nA  | 00\\nC  | 01\\nC  | 01\\nC  | 01\\nC  | 01\\nC  | 01\\n\\nWe can concatinate these and use it as the 20 bits key of the hashmap as follows\\n\\n```\\n00000000000101010101 // AAAAACCCCC // 341 (10)\\n```\\n\\nUsing this method, a given DNA sequences can be sliced into 10 lengths, and a key for 10 captured DNA sequences can be extracted and verified if they are duplicated.\\n\\nThis way you can efficiently use the memory being loaded for hashing.\\n\\n```\\nclass Solution {\\npublic:\\n    char t[20] = {0, -1, 1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3}; // A = 0, C = 1, G = 2, T = 3, others = -1\\n    int getKey(string& s, int idx) {\\n        int key = 0;\\n        for (int i=0; i<10; ++i) key = (key << 2) | (t[s[idx+i] - \\'A\\']); // represents the 10 length nucleic sequences into 20 bits\\n        return key;\\n    }\\n    \\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<int, int> m;\\n        vector<string> A;\\n        for (int i=0; i+10 <= s.size(); ++i) {\\n            int key = getKey(s, i);\\n            if (m.find(key) != m.end()) {\\n                if (m[key] == 1) A.push_back(s.substr(i, 10));\\n                ++m[key];\\n            } else m[key] = 1;\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n00000000000101010101 // AAAAACCCCC // 341 (10)\\n```\n```\\nclass Solution {\\npublic:\\n    char t[20] = {0, -1, 1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3}; // A = 0, C = 1, G = 2, T = 3, others = -1\\n    int getKey(string& s, int idx) {\\n        int key = 0;\\n        for (int i=0; i<10; ++i) key = (key << 2) | (t[s[idx+i] - \\'A\\']); // represents the 10 length nucleic sequences into 20 bits\\n        return key;\\n    }\\n    \\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<int, int> m;\\n        vector<string> A;\\n        for (int i=0; i+10 <= s.size(); ++i) {\\n            int key = getKey(s, i);\\n            if (m.find(key) != m.end()) {\\n                if (m[key] == 1) A.push_back(s.substr(i, 10));\\n                ++m[key];\\n            } else m[key] = 1;\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898306,
                "title": "repeated-dna-sequences-c-java-o-n-bit-manipulation-don-t-use-string-hashmap",
                "content": "We can use 2 bits to represent a nucleotide, 20 bits to represent a 10-letter-long sequences.  So an integer is more than enough to represent it. **Don\\'t use string HashMap/HashSet.  It wastes too many memory.**   If an interviewer asks you this question, you will fail if you use a string hashmap/hashset.\\n\\n**java**\\n```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n\\t    // you can also use array or function for this map\\n        Map<Character, Integer> n2d = new HashMap<>();\\n        n2d.put(\\'A\\', 0);\\n        n2d.put(\\'C\\', 1);\\n        n2d.put(\\'G\\', 2);\\n        n2d.put(\\'T\\', 3);\\n        Set<Integer> candidates = new HashSet<>();\\n\\t\\t// this set should be much smaller than the candidates set.  So using string should be ok. \\n\\t\\t// You can also use integer if you want to. \\n        Set<String> duplicates = new HashSet<>();\\n        int cur = 0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            // only keep at most 9 letters before the current letter\\n\\t\\t\\t// or maybe cur &= (1<<19) -1\\n            cur %= 1<<18;                \\n            cur = cur * 4 + n2d.get(s.charAt(i));\\n            if (i < 9) continue;\\n            if (candidates.contains(cur))\\n            {\\n                duplicates.add(s.substring(i-9, i+1));\\n            }\\n            else\\n            {\\n                candidates.add(cur);\\n            }\\n        }\\n        return new ArrayList<String>(duplicates);\\n    }\\n}\\n```\\n\\n**c++**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n\\t    // you can also use array or function for this map\\n        unordered_map<char, int> n2d{{\\'A\\', 0}, {\\'C\\', 1}, {\\'G\\', 2}, {\\'T\\', 3}};\\n        unordered_set<int> candidates;\\n\\t\\t// this set should be much smaller than the candidates set.  So using string should be ok. \\n\\t\\t// You can also use integer if you want to. \\n        unordered_set<string> duplicates;\\n        int cur = 0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            // only keep at most 9 letters before the current letter\\n\\t\\t\\t// or maybe cur &= (1<<19) -1\\n            cur %= 1<<18;                \\n            cur = cur * 4 + n2d[s[i]];\\n            if (i < 9) continue;\\n            if (candidates.count(cur) > 0)\\n            {\\n                duplicates.insert(s.substr(i-9, 10));\\n            }\\n            else\\n            {\\n                candidates.insert(cur);\\n            }\\n        }\\n        return vector<string>(duplicates.begin(), duplicates.end());\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n\\t    // you can also use array or function for this map\\n        Map<Character, Integer> n2d = new HashMap<>();\\n        n2d.put(\\'A\\', 0);\\n        n2d.put(\\'C\\', 1);\\n        n2d.put(\\'G\\', 2);\\n        n2d.put(\\'T\\', 3);\\n        Set<Integer> candidates = new HashSet<>();\\n\\t\\t// this set should be much smaller than the candidates set.  So using string should be ok. \\n\\t\\t// You can also use integer if you want to. \\n        Set<String> duplicates = new HashSet<>();\\n        int cur = 0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            // only keep at most 9 letters before the current letter\\n\\t\\t\\t// or maybe cur &= (1<<19) -1\\n            cur %= 1<<18;                \\n            cur = cur * 4 + n2d.get(s.charAt(i));\\n            if (i < 9) continue;\\n            if (candidates.contains(cur))\\n            {\\n                duplicates.add(s.substring(i-9, i+1));\\n            }\\n            else\\n            {\\n                candidates.add(cur);\\n            }\\n        }\\n        return new ArrayList<String>(duplicates);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n\\t    // you can also use array or function for this map\\n        unordered_map<char, int> n2d{{\\'A\\', 0}, {\\'C\\', 1}, {\\'G\\', 2}, {\\'T\\', 3}};\\n        unordered_set<int> candidates;\\n\\t\\t// this set should be much smaller than the candidates set.  So using string should be ok. \\n\\t\\t// You can also use integer if you want to. \\n        unordered_set<string> duplicates;\\n        int cur = 0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            // only keep at most 9 letters before the current letter\\n\\t\\t\\t// or maybe cur &= (1<<19) -1\\n            cur %= 1<<18;                \\n            cur = cur * 4 + n2d[s[i]];\\n            if (i < 9) continue;\\n            if (candidates.count(cur) > 0)\\n            {\\n                duplicates.insert(s.substr(i-9, 10));\\n            }\\n            else\\n            {\\n                candidates.insert(cur);\\n            }\\n        }\\n        return vector<string>(duplicates.begin(), duplicates.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54108,
                "title": "my-4-lines-python-code",
                "content": "The question is straightforward. We only need generate possible substring and count it. When the count larger than 2, we take the substring as result.\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a list of strings\\n        def findRepeatedDnaSequences(self, s):\\n            dictionary = dict()\\n            for i in [s[x : x + 10] for x in range(len(s) - 9)]:\\n                dictionary[i] = dictionary.get(i, 0) + 1\\n            return [k for k, v in dictionary.iteritems() if v > 1]\\n\\nIf we can use Counter, it only needs 1 line code:\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a list of strings\\n        def findRepeatedDnaSequences(self, s):\\n            return [k for k,v in Counter([s[x:x+10] for x in range(len(s)-9)]).iteritems() if v > 1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "The question is straightforward. We only need generate possible substring and count it. When the count larger than 2, we take the substring as result.\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a list of strings\\n        def findRepeatedDnaSequences(self, s):\\n            dictionary = dict()\\n            for i in [s[x : x + 10] for x in range(len(s) - 9)]:\\n                dictionary[i] = dictionary.get(i, 0) + 1\\n            return [k for k, v in dictionary.iteritems() if v > 1]\\n\\nIf we can use Counter, it only needs 1 line code:\\n\\n    class Solution:\\n        # @param s, a string\\n        # @return a list of strings\\n        def findRepeatedDnaSequences(self, s):\\n            return [k for k,v in Counter([s[x:x+10] for x in range(len(s)-9)]).iteritems() if v > 1]",
                "codeTag": "Java"
            },
            {
                "id": 53980,
                "title": "accepted-java-easy-to-understand-solution",
                "content": "    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> list = new ArrayList<String>();\\n        if (s == null || s.length() < 10) return list;\\n        HashMap<Integer, Boolean> map = new HashMap<Integer, Boolean>();\\n        \\n        for (int i = 0; i + 10 <= s.length(); i++ ) {\\n            int hash = stringToHash(s.substring(i, i + 10));\\n            if (map.containsKey(hash)) {\\n                if (!map.get(hash)) {\\n                    list.add(s.substring(i, i + 10));\\n                    map.put(hash, true);\\n                }\\n            } else {\\n                map.put(hash, false);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    private int stringToHash (String s) {\\n        String numberBuilder = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == 'A') numberBuilder += \"0\";\\n            if (s.charAt(i) == 'C') numberBuilder += \"1\";\\n            if (s.charAt(i) == 'G') numberBuilder += \"2\";\\n            if (s.charAt(i) == 'T') numberBuilder += \"3\";\\n        }\\n        return Integer.parseInt(numberBuilder, 4);\\n    }\\n\\nThanking for the suggestions by TWiStErRob at el. the stringToHash function can be implemented to be more efficient.\\nHere TWiStErRob's code for it\\n\\n    private int stringToHash(String s) {\\n        int numberBuilder = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            numberBuilder *= 4;\\n                 if (s.charAt(i) == 'A') numberBuilder += 0;\\n            else if (s.charAt(i) == 'C') numberBuilder += 1;\\n            else if (s.charAt(i) == 'G') numberBuilder += 2;\\n            else if (s.charAt(i) == 'T') numberBuilder += 3;\\n        }\\n        return numberBuilder;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> list = new ArrayList<String>();\\n        if (s == null || s.length() < 10) return list;\\n        HashMap<Integer, Boolean> map = new HashMap<Integer, Boolean>();\\n        \\n        for (int i = 0; i + 10 <= s.length(); i++ ) {\\n            int hash = stringToHash(s.substring(i, i + 10));\\n            if (map.containsKey(hash)) {\\n                if (!map.get(hash)) {\\n                    list.add(s.substring(i, i + 10));\\n                    map.put(hash, true);\\n                }\\n            } else {\\n                map.put(hash, false);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    private int stringToHash (String s) {\\n        String numberBuilder = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == 'A') numberBuilder += \"0\";\\n            if (s.charAt(i) == 'C') numberBuilder += \"1\";\\n            if (s.charAt(i) == 'G') numberBuilder += \"2\";\\n            if (s.charAt(i) == 'T') numberBuilder += \"3\";\\n        }\\n        return Integer.parseInt(numberBuilder, 4);\\n    }\\n\\nThanking for the suggestions by TWiStErRob at el. the stringToHash function can be implemented to be more efficient.\\nHere TWiStErRob's code for it\\n\\n    private int stringToHash(String s) {\\n        int numberBuilder = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            numberBuilder *= 4;\\n                 if (s.charAt(i) == 'A') numberBuilder += 0;\\n            else if (s.charAt(i) == 'C') numberBuilder += 1;\\n            else if (s.charAt(i) == 'G') numberBuilder += 2;\\n            else if (s.charAt(i) == 'T') numberBuilder += 3;\\n        }\\n        return numberBuilder;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1228538,
                "title": "hashset-rolling-hash-two-js-solutions",
                "content": "```\\n// First Solution\\n// Brute Force\\nvar findRepeatedDnaSequences = function(s) {\\n    if (s.length < 10) {\\n        return [];\\n    }\\n    let set = new Set(), res = new Set();\\n    let start = 0;\\n    for (let end = 9; end < s.length; end++) {\\n        let substr = s.substring(start, end+1);\\n        if (set.has(substr)) {\\n            res.add(substr);\\n        } else {\\n            set.add(substr);\\n        }\\n        start++;\\n    }\\n    return Array.from(res);\\n    // T.C: O(K * (N-K+1)), N-K+1 substrings are possible where K = 10\\n    // S.C: O(K * (N-K+1))\\n}\\n```\\n\\n```\\n// Second Solution\\n// Rolling Hash\\nvar findRepeatedDnaSequences = function(s) {\\n    if (s.length < 10) {\\n        return [];\\n    }\\n    let hashSet = new Set(), hash = 0, windowSize = 10, base = 4;\\n    let decoded = {\\'A\\': 1, \\'C\\': 2, \\'G\\': 3, \\'T\\': 4};\\n    // process the first window separately\\n    for (let i = 0; i < 10; i++) {\\n        hash += Math.pow(base, windowSize-i-1) * decoded[s[i]];\\n    }\\n    hashSet.add(hash);\\n    let res = new Set();\\n    for (let i = 10; i < s.length; i++) {\\n        // subtract the left-most bit\\n        hash -= Math.pow(base, windowSize-1) * decoded[s[i-windowSize]];\\n        hash *= base;\\n        hash += decoded[s[i]];\\n        if (hashSet.has(hash)) {\\n            res.add(s.substring(i+1-windowSize, i+1));\\n        } else {\\n            hashSet.add(hash);\\n        }\\n    }\\n    return Array.from(res);\\n    // T.C: O(K*(N-K+1)) where K = 10 in the worst case \\n    // but average time complexity will be O(N-K+1) which is much better\\n    // S.C: O(K*(N-K+1))\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// First Solution\\n// Brute Force\\nvar findRepeatedDnaSequences = function(s) {\\n    if (s.length < 10) {\\n        return [];\\n    }\\n    let set = new Set(), res = new Set();\\n    let start = 0;\\n    for (let end = 9; end < s.length; end++) {\\n        let substr = s.substring(start, end+1);\\n        if (set.has(substr)) {\\n            res.add(substr);\\n        } else {\\n            set.add(substr);\\n        }\\n        start++;\\n    }\\n    return Array.from(res);\\n    // T.C: O(K * (N-K+1)), N-K+1 substrings are possible where K = 10\\n    // S.C: O(K * (N-K+1))\\n}\\n```\n```\\n// Second Solution\\n// Rolling Hash\\nvar findRepeatedDnaSequences = function(s) {\\n    if (s.length < 10) {\\n        return [];\\n    }\\n    let hashSet = new Set(), hash = 0, windowSize = 10, base = 4;\\n    let decoded = {\\'A\\': 1, \\'C\\': 2, \\'G\\': 3, \\'T\\': 4};\\n    // process the first window separately\\n    for (let i = 0; i < 10; i++) {\\n        hash += Math.pow(base, windowSize-i-1) * decoded[s[i]];\\n    }\\n    hashSet.add(hash);\\n    let res = new Set();\\n    for (let i = 10; i < s.length; i++) {\\n        // subtract the left-most bit\\n        hash -= Math.pow(base, windowSize-1) * decoded[s[i-windowSize]];\\n        hash *= base;\\n        hash += decoded[s[i]];\\n        if (hashSet.has(hash)) {\\n            res.add(s.substring(i+1-windowSize, i+1));\\n        } else {\\n            hashSet.add(hash);\\n        }\\n    }\\n    return Array.from(res);\\n    // T.C: O(K*(N-K+1)) where K = 10 in the worst case \\n    // but average time complexity will be O(N-K+1) which is much better\\n    // S.C: O(K*(N-K+1))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 975779,
                "title": "java-hashmap-with-sliding-window",
                "content": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> list=new ArrayList<String>();\\n        if(s.length()<=10)\\n        {\\n            return list;\\n        }\\n        HashMap<String, Integer> map=new HashMap<String, Integer>();\\n        String str=\"\";\\n        for(int i=0;i<10;i++)\\n        {\\n            str+=s.charAt(i);\\n        }\\n        map.put(str, map.getOrDefault(str, 0)+1);\\n        for(int i=1;i<=s.length()-10;i++)\\n        {\\n            StringBuilder sb=new StringBuilder(str);\\n            sb.deleteCharAt(0);\\n            sb.append(s.charAt(i+9));\\n            str=sb.toString();\\n            map.put(str, map.getOrDefault(str, 0)+1);\\n        }\\n        for(String p:map.keySet())\\n        {\\n            if(map.get(p)>1)\\n            {\\n                list.add(p);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> list=new ArrayList<String>();\\n        if(s.length()<=10)\\n        {\\n            return list;\\n        }\\n        HashMap<String, Integer> map=new HashMap<String, Integer>();\\n        String str=\"\";\\n        for(int i=0;i<10;i++)\\n        {\\n            str+=s.charAt(i);\\n        }\\n        map.put(str, map.getOrDefault(str, 0)+1);\\n        for(int i=1;i<=s.length()-10;i++)\\n        {\\n            StringBuilder sb=new StringBuilder(str);\\n            sb.deleteCharAt(0);\\n            sb.append(s.charAt(i+9));\\n            str=sb.toString();\\n            map.put(str, map.getOrDefault(str, 0)+1);\\n        }\\n        for(String p:map.keySet())\\n        {\\n            if(map.get(p)>1)\\n            {\\n                list.add(p);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898456,
                "title": "c-bitwise-compression-vs-naive-solution-explained-and-compared-98-time-15-space",
                "content": "So, since I forgot I solved this already months ago, I approached it with a clear mind and I knew what I did NOT want to do - namely just go for a cheap shot with a frequency map and be done with it.\\n\\nI decided then to refresh a bit the idea of compression of information, since it works pretty well with a sliding window problem as this one.\\n\\nI wanted to convert each single subsequence of the input string of length `10` you can have into a number. And I realised it is not that difficult, since each character can only have `4` different values, which can be considered as values in the `00 - 11` binary range.\\n\\nThe approach I wanted to work with was supposed to behave like this:\\n\\n```cpp\\n// AAAAAAAAAA = 00000000000000000000\\n// AAAAAAAAAC = 00000000000000000001\\n// AAAAAAAAAG = 00000000000000000010\\n// ...\\n// CTTTTTTTTT = 01111111111111111111\\n// GTTTTTTTTT = 10111111111111111111\\n// TTTTTTTTTT = 11111111111111111111\\n```\\n\\nThen I realised it was not the most convenient, unless I slid through the string backwards (still a valuable approach, though) and I decided to challenge myself and reverse what is the most significant character matching the most significant couple of bits, so we will work like this instead - with the least significant character being now the leftmost:\\n\\n```cpp\\n// AAAAAAAAAA = 00000000000000000000\\n// AAAAAAAAAC = 01000000000000000000\\n// AAAAAAAAAG = 10000000000000000000\\n// ...\\n// CTTTTTTTTT = 11111111111111111110\\n// GTTTTTTTTT = 11111111111111111110\\n// TTTTTTTTTT = 11111111111111111111\\n```\\n\\nTo help us proceed, I created 2 helper functions:\\n* `nucToInt` that rather trivially converts a character to a `0 - 3` value;\\n* `intToDNA` that reverses the process on a single provided value, returning a DNA string of 10 characters.\\n\\nIn the body of our main function, we will start creating our usual bunch of needed support variables:\\n* `len` will store the length of the input string - and while at it, we will return on the double if it is `< 10`;\\n* `seen` and `written` are 2 sets of `uint32_t` I decided to use in order to replace a hashmap to keep track of frequencies - and despite being 2 of them, I ended up still using much less memory in the end than the naive `unordered_map` approach at the bottom;\\n* `intDNA` is a `uint32_t` we will use to keep track of our running value - and in case you wondered why I did not use a normal `int`: just because it is not guaranteed to be of `32` bits and I wanted to avoid wasting memory;\\n* `res` will store the final result.\\n\\nWe will start first of all computing the value of `intDNA` for the very first sequence, so we will run through the first `10` characters of `s` and:\\n* shift the current value of `intDNA` right by 2 bits (equivalent to one nucleotide, since we convert them to values in the `0 - 3` range);\\n* add `nucToInt(s[i]) << 18` to the current value of `intDNA`.\\n\\nIf the last step is not clear, think of `intDNA` basically having `10` slots for us, one for each character and each one of `2` bits; since we decided to write so that the most significant bits (ie: the ones matching the newest character on the left) go to the rightmost positions, when we update it for the last character, which would be equivalent to writing on index `9` in a string, we will do so writing it after shifting it left of `9 * 2` positions.\\n\\nCheck again my translations of nucleotides sequences to binary above, if it is still not clear :)\\n\\nOnce we get the very first value of `intDNA`, we can push it inside `seen`.\\n\\nAnd then we go on basically doing the same conversion for all the characters from index `10` up to the end of `s`: we shift right (which basically cuts out the leftmost character previously considered) and we add the value of the current one shifted by `18` positions (which basically patches up the newest character in our sliding window).\\n\\nAfter we get an updated value of `intDNA`, we check if it has not already being `written`, with a `.find` call on the eponymous set:\\n* if it was not there already, then we check if it was not already `seen`, in the same way:\\n\\t* if it was `seen` (but, remember, not `written`), we add it to both `res` (after reconverting it to a string with `intToDNA`) and to `written`;\\n\\t* if it was not even `seen`, we add it to that set;\\n* otherwise we just move on with the next loop, doing nothing.\\n\\nOnce we are done looping, we can just return `res` and be done with it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int nucToInt (char c) {\\n        return c == \\'G\\' ? 2 : c == \\'T\\' ? 3 : c != \\'A\\';\\n    }\\n    string intToDNA(int intDNA) {\\n        string res = \"\";\\n        int currNuc;\\n        while (res.size() < 10) {\\n            currNuc = intDNA % 4;\\n            res += currNuc == 3 ? \\'T\\' : currNuc == 2 ? \\'G\\' : currNuc ? \\'C\\' : \\'A\\';\\n            intDNA >>= 2;\\n        }\\n        return res;\\n    }\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        int len = s.size();\\n        if (len < 10) return {};\\n        // support variables\\n        unordered_set<uint32_t> seen, written;\\n        uint32_t intDNA = 0;\\n        vector<string> res;\\n        // computing the compressed value of the first 10 nucleotides sequence\\n        for (int i = 0; i < 10; i++) {\\n            intDNA >>= 2;\\n            intDNA += nucToInt(s[i]) << 18;\\n        }\\n        seen.insert(intDNA);\\n        for (int i = 10; i < len; i++) {\\n            // computing the value of the next sequence\\n            intDNA >>= 2;\\n            intDNA += nucToInt(s[i]) << 18;\\n            // checking if it was not already added\\n            if (written.find(intDNA) == end(written)) {\\n                // checking if it was not already seen\\n                if (seen.find(intDNA) == end(seen)) seen.insert(intDNA);\\n                // otherwise we add it to res and record that is now there\\n                else {\\n                    res.push_back(intToDNA(intDNA));\\n                    written.insert(intDNA);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nMy initial naive solution I wrote months ago - performed better before,, but I guess the tests were updated now; plus it burns a lot more memory:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string ss) {\\n        vector<std::string> res;\\n        unordered_map<string, int> tmp;\\n        string s = ss.substr(0,10);\\n        int limit = ss.size();\\n        for (int i = 10; i < limit; i++) {\\n            tmp[s]++;\\n            s = s.substr(1) + ss[i];\\n        }\\n        tmp[s]++;\\n        for (auto item: tmp) {\\n            if (item.second > 1) res.push_back(item.first);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nFinally, the unholy child of the 2, which is still slower than the set-based solution (recomposing strings takes less time than hashing, I guess?), but by far the one using less memory now:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int nucToInt (char c) {\\n        return c == \\'G\\' ? 2 : c == \\'T\\' ? 3 : c != \\'A\\';\\n    }\\n    string intToDNA(int intDNA) {\\n        string res = \"\";\\n        int currNuc;\\n        while (res.size() < 10) {\\n            currNuc = intDNA % 4;\\n            res += currNuc == 3 ? \\'T\\' : currNuc == 2 ? \\'G\\' : currNuc ? \\'C\\' : \\'A\\';\\n            intDNA >>= 2;\\n        }\\n        return res;\\n    }\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        int len = s.size();\\n        if (len < 10) return {};\\n        // support variables\\n        unordered_map<uint32_t, int> freq;\\n        uint32_t intDNA = 0;\\n        vector<string> res;\\n        // computing the compressed value of the first 10 nucleotides sequence\\n        for (int i = 0; i < 10; i++) {\\n            intDNA >>= 2;\\n            intDNA += nucToInt(s[i]) << 18;\\n        }\\n        freq[intDNA]++;\\n        for (int i = 10; i < len; i++) {\\n            // computing the value of the next sequence\\n            intDNA >>= 2;\\n            intDNA += nucToInt(s[i]) << 18;\\n            freq[intDNA]++;\\n            // checking if it was not already added\\n            if (freq[intDNA] == 2) {\\n                res.push_back(intToDNA(intDNA));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut as an engineer should always ask yourself \"can I do better?\" - and it turns out we can, using an array instead of a hashmap.\\n\\nI admit it surprised me, but that is way faster than all the other alternatives, despite running one million times just to initialise our map; memory usage is also at its lowest, despite always using 1M+ cells of 32bits just to store frequencies:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int nucToInt (char c) {\\n        return c == \\'G\\' ? 2 : c == \\'T\\' ? 3 : c != \\'A\\';\\n    }\\n    string intToDNA(int intDNA) {\\n        string res = \"\";\\n        int currNuc;\\n        while (res.size() < 10) {\\n            currNuc = intDNA % 4;\\n            res += currNuc == 3 ? \\'T\\' : currNuc == 2 ? \\'G\\' : currNuc ? \\'C\\' : \\'A\\';\\n            intDNA >>= 2;\\n        }\\n        return res;\\n    }\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        int len = s.size();\\n        if (len < 10) return {};\\n        // support variables\\n        uint32_t intDNA = 0, freq[1048575];\\n        for (int i = 0; i < 1048575; i++) freq[i] = 0;\\n        vector<string> res;\\n        // computing the compressed value of the first 10 nucleotides sequence\\n        for (int i = 0; i < 10; i++) {\\n            intDNA >>= 2;\\n            intDNA += nucToInt(s[i]) << 18;\\n        }\\n        freq[intDNA]++;\\n        for (int i = 10; i < len; i++) {\\n            // computing the value of the next sequence\\n            intDNA >>= 2;\\n            intDNA += nucToInt(s[i]) << 18;\\n            freq[intDNA]++;\\n            // checking if it was not already added\\n            if (freq[intDNA] == 2) {\\n                res.push_back(intToDNA(intDNA));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\n// AAAAAAAAAA = 00000000000000000000\\n// AAAAAAAAAC = 00000000000000000001\\n// AAAAAAAAAG = 00000000000000000010\\n// ...\\n// CTTTTTTTTT = 01111111111111111111\\n// GTTTTTTTTT = 10111111111111111111\\n// TTTTTTTTTT = 11111111111111111111\\n```\n```cpp\\n// AAAAAAAAAA = 00000000000000000000\\n// AAAAAAAAAC = 01000000000000000000\\n// AAAAAAAAAG = 10000000000000000000\\n// ...\\n// CTTTTTTTTT = 11111111111111111110\\n// GTTTTTTTTT = 11111111111111111110\\n// TTTTTTTTTT = 11111111111111111111\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int nucToInt (char c) {\\n        return c == \\'G\\' ? 2 : c == \\'T\\' ? 3 : c != \\'A\\';\\n    }\\n    string intToDNA(int intDNA) {\\n        string res = \"\";\\n        int currNuc;\\n        while (res.size() < 10) {\\n            currNuc = intDNA % 4;\\n            res += currNuc == 3 ? \\'T\\' : currNuc == 2 ? \\'G\\' : currNuc ? \\'C\\' : \\'A\\';\\n            intDNA >>= 2;\\n        }\\n        return res;\\n    }\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        int len = s.size();\\n        if (len < 10) return {};\\n        // support variables\\n        unordered_set<uint32_t> seen, written;\\n        uint32_t intDNA = 0;\\n        vector<string> res;\\n        // computing the compressed value of the first 10 nucleotides sequence\\n        for (int i = 0; i < 10; i++) {\\n            intDNA >>= 2;\\n            intDNA += nucToInt(s[i]) << 18;\\n        }\\n        seen.insert(intDNA);\\n        for (int i = 10; i < len; i++) {\\n            // computing the value of the next sequence\\n            intDNA >>= 2;\\n            intDNA += nucToInt(s[i]) << 18;\\n            // checking if it was not already added\\n            if (written.find(intDNA) == end(written)) {\\n                // checking if it was not already seen\\n                if (seen.find(intDNA) == end(seen)) seen.insert(intDNA);\\n                // otherwise we add it to res and record that is now there\\n                else {\\n                    res.push_back(intToDNA(intDNA));\\n                    written.insert(intDNA);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string ss) {\\n        vector<std::string> res;\\n        unordered_map<string, int> tmp;\\n        string s = ss.substr(0,10);\\n        int limit = ss.size();\\n        for (int i = 10; i < limit; i++) {\\n            tmp[s]++;\\n            s = s.substr(1) + ss[i];\\n        }\\n        tmp[s]++;\\n        for (auto item: tmp) {\\n            if (item.second > 1) res.push_back(item.first);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int nucToInt (char c) {\\n        return c == \\'G\\' ? 2 : c == \\'T\\' ? 3 : c != \\'A\\';\\n    }\\n    string intToDNA(int intDNA) {\\n        string res = \"\";\\n        int currNuc;\\n        while (res.size() < 10) {\\n            currNuc = intDNA % 4;\\n            res += currNuc == 3 ? \\'T\\' : currNuc == 2 ? \\'G\\' : currNuc ? \\'C\\' : \\'A\\';\\n            intDNA >>= 2;\\n        }\\n        return res;\\n    }\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        int len = s.size();\\n        if (len < 10) return {};\\n        // support variables\\n        unordered_map<uint32_t, int> freq;\\n        uint32_t intDNA = 0;\\n        vector<string> res;\\n        // computing the compressed value of the first 10 nucleotides sequence\\n        for (int i = 0; i < 10; i++) {\\n            intDNA >>= 2;\\n            intDNA += nucToInt(s[i]) << 18;\\n        }\\n        freq[intDNA]++;\\n        for (int i = 10; i < len; i++) {\\n            // computing the value of the next sequence\\n            intDNA >>= 2;\\n            intDNA += nucToInt(s[i]) << 18;\\n            freq[intDNA]++;\\n            // checking if it was not already added\\n            if (freq[intDNA] == 2) {\\n                res.push_back(intToDNA(intDNA));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int nucToInt (char c) {\\n        return c == \\'G\\' ? 2 : c == \\'T\\' ? 3 : c != \\'A\\';\\n    }\\n    string intToDNA(int intDNA) {\\n        string res = \"\";\\n        int currNuc;\\n        while (res.size() < 10) {\\n            currNuc = intDNA % 4;\\n            res += currNuc == 3 ? \\'T\\' : currNuc == 2 ? \\'G\\' : currNuc ? \\'C\\' : \\'A\\';\\n            intDNA >>= 2;\\n        }\\n        return res;\\n    }\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        int len = s.size();\\n        if (len < 10) return {};\\n        // support variables\\n        uint32_t intDNA = 0, freq[1048575];\\n        for (int i = 0; i < 1048575; i++) freq[i] = 0;\\n        vector<string> res;\\n        // computing the compressed value of the first 10 nucleotides sequence\\n        for (int i = 0; i < 10; i++) {\\n            intDNA >>= 2;\\n            intDNA += nucToInt(s[i]) << 18;\\n        }\\n        freq[intDNA]++;\\n        for (int i = 10; i < len; i++) {\\n            // computing the value of the next sequence\\n            intDNA >>= 2;\\n            intDNA += nucToInt(s[i]) << 18;\\n            freq[intDNA]++;\\n            // checking if it was not already added\\n            if (freq[intDNA] == 2) {\\n                res.push_back(intToDNA(intDNA));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529731,
                "title": "very-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        //T(n) = O(n)\\n        //S(n) = O(n)\\n        vector<string> res;\\n        unordered_map<string,int> mymap;\\n        for(int i = 0; i+9 < s.length(); i++){\\n            string temp = s.substr(i,10);\\n            mymap[temp]++;\\n        }\\n        for(auto val : mymap){\\n            if(val.second > 1){\\n                res.push_back(val.first);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        //T(n) = O(n)\\n        //S(n) = O(n)\\n        vector<string> res;\\n        unordered_map<string,int> mymap;\\n        for(int i = 0; i+9 < s.length(); i++){\\n            string temp = s.substr(i,10);\\n            mymap[temp]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54000,
                "title": "ac-python-solutions-bit-manipulation-and-hash-map",
                "content": "The naive way to do is just use the 10 letters as a key and count its occurrence.\\n\\n    def findRepeatedDnaSequences(self, s):\\n        d = {}\\n        ans = []\\n        for i in xrange(len(s) - 9):\\n            key = s[i:i + 10]\\n            if key in d:\\n                d[key] += 1\\n                if d[key] == 2:\\n                    ans.append(key)\\n            else:\\n                d[key] = 1\\n        return ans\\n\\n\\n    # 30 / 30 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 96 ms\\n    # 100%\\n\\nAlthough the naive way is fast it cost a lot of extra spaces. The alternative way to do this is making a integer key for the 10 letter string. Although the time increased a little bit but the space reduced to sizeof(int)/(sizeof(\"AAAAAAAAAA\")\\n\\n    toInt = {'A': 0, 'T': 1, 'G': 2, 'C': 3}\\n\\n    def findRepeatedDnaSequences(self, s):\\n        if len(s) < 11:\\n            return []\\n        keys = {}\\n        ans = []\\n        key = 0\\n        mask = (1 << 20) - 1\\n        for i in xrange(9):\\n            key = (key << 2) + self.toInt[s[i]]\\n        for i in xrange(9, len(s)):\\n            key = ((key << 2) + self.toInt[s[i]]) & mask\\n            if key in keys:\\n                keys[key] += 1\\n                if keys[key] == 2:\\n                    ans.append(s[i - 9:i + 1])\\n            else:\\n                keys[key] = 1\\n        return ans\\n\\n    # 30 / 30 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 112 ms\\n    # 92.22%",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "The naive way to do is just use the 10 letters as a key and count its occurrence.\\n\\n    def findRepeatedDnaSequences(self, s):\\n        d = {}\\n        ans = []\\n        for i in xrange(len(s) - 9):\\n            key = s[i:i + 10]\\n            if key in d:\\n                d[key] += 1\\n                if d[key] == 2:\\n                    ans.append(key)\\n            else:\\n                d[key] = 1\\n        return ans\\n\\n\\n    # 30 / 30 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 96 ms\\n    # 100%\\n\\nAlthough the naive way is fast it cost a lot of extra spaces. The alternative way to do this is making a integer key for the 10 letter string. Although the time increased a little bit but the space reduced to sizeof(int)/(sizeof(\"AAAAAAAAAA\")\\n\\n    toInt = {'A': 0, 'T': 1, 'G': 2, 'C': 3}\\n\\n    def findRepeatedDnaSequences(self, s):\\n        if len(s) < 11:\\n            return []\\n        keys = {}\\n        ans = []\\n        key = 0\\n        mask = (1 << 20) - 1\\n        for i in xrange(9):\\n            key = (key << 2) + self.toInt[s[i]]\\n        for i in xrange(9, len(s)):\\n            key = ((key << 2) + self.toInt[s[i]]) & mask\\n            if key in keys:\\n                keys[key] += 1\\n                if keys[key] == 2:\\n                    ans.append(s[i - 9:i + 1])\\n            else:\\n                keys[key] = 1\\n        return ans\\n\\n    # 30 / 30 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 112 ms\\n    # 92.22%",
                "codeTag": "Python3"
            },
            {
                "id": 54018,
                "title": "use-unordered-set-to-solve-this-question-c",
                "content": "Here I show the thinking process to solve this question.\\nAnd another two method can not be accepted by the OJ .\\n\\n    //\\u4e8b\\u5b9e\\u8bc1\\u660e\\uff0c\\u8fd8\\u662f\\u53ef\\u4ee5\\u7528\\u54c8\\u5e0c\\u8868\\uff0c\\u76f4\\u63a5\\u5efa\\u7acb\\u4e00\\u4e2astring\\u7684\\u54c8\\u5e0c\\u8868\\u592a\\u5927\\u4e86\\uff01\\n    //\\u56e0\\u4e3astring\\u7684\\u6bcf\\u4e00\\u4f4d\\u90fd\\u53ea\\u6709\\u56db\\u79cd\\u53ef\\u80fd\\uff0c\\u6211\\u7528\\u4e00\\u4e2aint\\u4f4d\\u6765\\u4ee3\\u66ff\\u4e00\\u4e2a10\\u4f4d\\u7684string\\uff0cACGT\\u5206\\u522b\\u4ee3\\u8868\\u4e24\\u4f4d00 01 10 11\\uff0c\\u5373\\n    //\\u7528\\u4e00\\u4e2a20\\u4f4d\\u7684int\\u503c\\u8868\\u793a10\\u4f4d\\u7684string\\n    //\\u518d\\u7528hash\\u6765\\u5efa\\u7acbint\\u7684\\u8868\\u8fdb\\u884c\\u67e5\\u627e\\uff5e\\u5373\\u53ef\\n        vector<string> findRepeatedDnaSequences(string s) {\\n            vector<string> res;\\n    \\t\\tint i,foo_i;\\n    \\t\\tstring foo,bar;\\n    \\t\\tunordered_set<int> A;\\n    \\t\\tint size=s.length();\\n    \\t\\tif(size<=10)\\n    \\t\\t\\treturn res;\\n    \\t\\tfor(i=0;i+10<=size;i++){\\n    \\t\\t\\tfoo=s.substr(i,10);\\n    \\t\\t\\tfoo_i=str2num(foo);\\n    \\t\\t\\tif(A.find(foo_i)==A.end()){\\n    \\t\\t\\t\\tA.insert(foo_i);\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tif(find(res.begin(),res.end(),foo)==res.end())\\n    \\t\\t\\t\\tres.push_back(foo);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res; \\n        }\\n        int str2num(string A){\\n        \\tint i,res=0;\\n        \\tfor(i=0;i<10;i++){\\n        \\t\\tif(A[i]=='A')\\n        \\t\\t\\tres+=0;\\n        \\t\\telse if(A[i]=='C')\\n        \\t\\t\\tres+=1;\\n        \\t\\telse if(A[i]=='T')\\n        \\t\\t\\tres+=2;\\n        \\t\\telse if(A[i]=='G')\\n        \\t\\t\\tres+=3;\\n        \\t\\tres=res<<2;\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n    //Time Limit method\\n    /*\\n    \\tvector<string> findRepeatedDnaSequences(string s) {\\n    \\t\\tvector<string> res;\\n    \\t\\tint i,loc;\\n    \\t\\tstring foo,bar;\\n    \\t\\tint size=s.length();\\n    \\t\\tif(size<=10)\\n    \\t\\t\\treturn res;\\n    \\t\\tfor(i=0;i+10<=size;i++){\\n    \\t\\t\\tfoo=s.substr(i,10);\\n                        if(find(res.begin(),res.end(),foo)!=res.end())\\n\\t\\t\\t\\tcontinue;\\n    \\t\\t\\tloc=s.find(foo,i+1);\\n    \\t\\t\\tif(loc>0){\\n    \\t\\t\\t\\tres.push_back(foo);\\n    \\t\\t\\t\\tfor(;s[i+10]==s[loc+10]&&i+10<=size&&loc+10<=size;i++,loc++){\\n                           if(find(res.begin(),res.end(),foo)!=res.end())\\n    \\t\\t\\t\\t\\t       res.push_back(s.substr(i+1,10));\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t} \\n    \\t\\treturn res;\\n    \\t}\\n    \\t*/\\n        //\\u5efa\\u7acb\\u4e00\\u4e2a\\u54c8\\u5e0c\\u8868\\uff0c\\u7ed3\\u6784\\u51fa\\u73b0 Memory Limit Exceeded\\u7684\\u9519\\u8bef\\n        /*\\n        vector<string> findRepeatedDnaSequences(string s) {\\n            vector<string> res;\\n    \\t\\tint i;\\n    \\t\\tstring foo,bar;\\n    \\t\\tunordered_set<string> A;\\n    \\t\\tint size=s.length();\\n    \\t\\tif(size<=10)\\n    \\t\\t\\treturn res;\\n    \\t\\tfor(i=0;i+10<=size;i++){\\n    \\t\\t\\tfoo=s.substr(i,10);\\n    \\t\\t\\t\\n    \\t\\t\\tif(A.find(foo)==A.end()){\\n    \\t\\t\\t\\tA.insert(foo);\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tres.push_back(foo);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tsort(res.begin(),res.end());\\n    \\t\\tres.erase(unique(res.begin(),res.end()),res.end());\\n    \\t\\treturn res; \\n        }\\n        */",
                "solutionTags": [],
                "code": "Here I show the thinking process to solve this question.\\nAnd another two method can not be accepted by the OJ .\\n\\n    //\\u4e8b\\u5b9e\\u8bc1\\u660e\\uff0c\\u8fd8\\u662f\\u53ef\\u4ee5\\u7528\\u54c8\\u5e0c\\u8868\\uff0c\\u76f4\\u63a5\\u5efa\\u7acb\\u4e00\\u4e2astring\\u7684\\u54c8\\u5e0c\\u8868\\u592a\\u5927\\u4e86\\uff01\\n    //\\u56e0\\u4e3astring\\u7684\\u6bcf\\u4e00\\u4f4d\\u90fd\\u53ea\\u6709\\u56db\\u79cd\\u53ef\\u80fd\\uff0c\\u6211\\u7528\\u4e00\\u4e2aint\\u4f4d\\u6765\\u4ee3\\u66ff\\u4e00\\u4e2a10\\u4f4d\\u7684string\\uff0cACGT\\u5206\\u522b\\u4ee3\\u8868\\u4e24\\u4f4d00 01 10 11\\uff0c\\u5373\\n    //\\u7528\\u4e00\\u4e2a20\\u4f4d\\u7684int\\u503c\\u8868\\u793a10\\u4f4d\\u7684string\\n    //\\u518d\\u7528hash\\u6765\\u5efa\\u7acbint\\u7684\\u8868\\u8fdb\\u884c\\u67e5\\u627e\\uff5e\\u5373\\u53ef\\n        vector<string> findRepeatedDnaSequences(string s) {\\n            vector<string> res;\\n    \\t\\tint i,foo_i;\\n    \\t\\tstring foo,bar;\\n    \\t\\tunordered_set<int> A;\\n    \\t\\tint size=s.length();\\n    \\t\\tif(size<=10)\\n    \\t\\t\\treturn res;\\n    \\t\\tfor(i=0;i+10<=size;i++){\\n    \\t\\t\\tfoo=s.substr(i,10);\\n    \\t\\t\\tfoo_i=str2num(foo);\\n    \\t\\t\\tif(A.find(foo_i)==A.end()){\\n    \\t\\t\\t\\tA.insert(foo_i);\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tif(find(res.begin(),res.end(),foo)==res.end())\\n    \\t\\t\\t\\tres.push_back(foo);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn res; \\n        }\\n        int str2num(string A){\\n        \\tint i,res=0;\\n        \\tfor(i=0;i<10;i++){\\n        \\t\\tif(A[i]=='A')\\n        \\t\\t\\tres+=0;\\n        \\t\\telse if(A[i]=='C')\\n        \\t\\t\\tres+=1;\\n        \\t\\telse if(A[i]=='T')\\n        \\t\\t\\tres+=2;\\n        \\t\\telse if(A[i]=='G')\\n        \\t\\t\\tres+=3;\\n        \\t\\tres=res<<2;\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n    //Time Limit method\\n    /*\\n    \\tvector<string> findRepeatedDnaSequences(string s) {\\n    \\t\\tvector<string> res;\\n    \\t\\tint i,loc;\\n    \\t\\tstring foo,bar;\\n    \\t\\tint size=s.length();\\n    \\t\\tif(size<=10)\\n    \\t\\t\\treturn res;\\n    \\t\\tfor(i=0;i+10<=size;i++){\\n    \\t\\t\\tfoo=s.substr(i,10);\\n                        if(find(res.begin(),res.end(),foo)!=res.end())\\n\\t\\t\\t\\tcontinue;\\n    \\t\\t\\tloc=s.find(foo,i+1);\\n    \\t\\t\\tif(loc>0){\\n    \\t\\t\\t\\tres.push_back(foo);\\n    \\t\\t\\t\\tfor(;s[i+10]==s[loc+10]&&i+10<=size&&loc+10<=size;i++,loc++){\\n                           if(find(res.begin(),res.end(),foo)!=res.end())\\n    \\t\\t\\t\\t\\t       res.push_back(s.substr(i+1,10));\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t} \\n    \\t\\treturn res;\\n    \\t}\\n    \\t*/\\n        //\\u5efa\\u7acb\\u4e00\\u4e2a\\u54c8\\u5e0c\\u8868\\uff0c\\u7ed3\\u6784\\u51fa\\u73b0 Memory Limit Exceeded\\u7684\\u9519\\u8bef\\n        /*\\n        vector<string> findRepeatedDnaSequences(string s) {\\n            vector<string> res;\\n    \\t\\tint i;\\n    \\t\\tstring foo,bar;\\n    \\t\\tunordered_set<string> A;\\n    \\t\\tint size=s.length();\\n    \\t\\tif(size<=10)\\n    \\t\\t\\treturn res;\\n    \\t\\tfor(i=0;i+10<=size;i++){\\n    \\t\\t\\tfoo=s.substr(i,10);\\n    \\t\\t\\t\\n    \\t\\t\\tif(A.find(foo)==A.end()){\\n    \\t\\t\\t\\tA.insert(foo);\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tres.push_back(foo);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tsort(res.begin(),res.end());\\n    \\t\\tres.erase(unique(res.begin(),res.end()),res.end());\\n    \\t\\treturn res; \\n        }\\n        */",
                "codeTag": "Unknown"
            },
            {
                "id": 53884,
                "title": "rolling-hash-ac-python-solution",
                "content": "    class Solution:\\n    # @param s, a string\\n    # @return a list of strings\\n    def findRepeatedDnaSequences(self, s):\\n        repeatSeq = set()\\n        addedSeq = set()\\n        result = []\\n        answer = []\\n        charToBin = {'A' : 0b00, 'T' : 0b01, 'G' : 0b10, 'C' : 0b11}\\n        mask = 0xfffff\\n        current = 0\\n        for i in range(len(s)):\\n            #create bit\\n            x = charToBin[s[i]]\\n            current |= x\\n            if i >= 9:\\n                if current in repeatSeq:\\n                    if current not in addedSeq:\\n                        addedSeq.add(current)\\n                        result.append(i - 9)\\n                else:\\n                    repeatSeq.add(current)\\n            #shift\\n            current <<= 2\\n            #mask\\n            current &= mask\\n        for i in result:\\n            answer.append(s[i : i + 10])\\n        return answer",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param s, a string\\n    # @return a list of strings\\n    def findRepeatedDnaSequences(self, s):\\n        repeatSeq = set()\\n        addedSeq = set()\\n        result = []\\n        answer = []\\n        charToBin = {'A' : 0b00, 'T' : 0b01, 'G' : 0b10, 'C' : 0b11}",
                "codeTag": "Java"
            },
            {
                "id": 1615990,
                "title": "simple-java-solution-o-n-time",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42\\nclass Solution {\\n\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        List<String> ans = new ArrayList<>();\\n        for(int i=0;i<=s.length()-10;i++){\\n            String tem = s.substring(i,i+10);\\n            hm.put(tem,hm.getOrDefault(tem,0)+1);\\n        }\\n        for(String str:hm.keySet())\\n            if(hm.get(str)>1)\\n                ans.add(str);\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        List<String> ans = new ArrayList<>();\\n        for(int i=0;i<=s.length()-10;i++){\\n            String tem = s.substring(i,i+10);\\n            hm.put(tem,hm.getOrDefault(tem,0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 420527,
                "title": "easy-hashmap-bit-manipulation-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int char_to_bit(char c){\\n        if(c==\\'A\\') return 0;\\n        if(c==\\'C\\') return 1;\\n        if(c==\\'G\\') return 2;\\n        if(c==\\'T\\') return 3;\\n        return 0;\\n    }\\n    \\n    vector<string> findRepeatedDnaSequences(string s) {\\n        int n= s.size(), mask=0, bitmask=(1<<20)-1;\\n        if(n==0) return {};\\n        unordered_map<int, int> ht;\\n        vector<string> result;\\n        \\n        for(int i=0; i<10; i++){\\n            mask= (mask<<2) | char_to_bit(s[i]);\\n        }\\n        ht[mask]++;\\n        \\n        for(int i=10; i<n; i++){\\n            mask= ((mask<<2) & bitmask) | char_to_bit(s[i]);\\n            if(ht.find(mask)!=ht.end() && ht[mask]==1)\\n                result.push_back(s.substr(i-9, 10));\\n            ht[mask]++;\\n        }\\n        \\n        \\n        return result;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int char_to_bit(char c){\\n        if(c==\\'A\\') return 0;\\n        if(c==\\'C\\') return 1;\\n        if(c==\\'G\\') return 2;\\n        if(c==\\'T\\') return 3;\\n        return 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 54049,
                "title": "c-9ms-bit-array-solution",
                "content": "    class Solution {\\n    \\tinline bool testAndSetBit(unsigned int *intArr, unsigned int offset) {\\n    \\t\\tunsigned int byteOff = offset >> 5;\\n    \\t\\tunsigned int bitOff = offset & ((1 << 5) - 1);\\n    \\n    \\t\\tunsigned int bit = intArr[byteOff] & (1 << bitOff);\\n    \\t\\tif (bit) {\\n    \\t\\t\\treturn true;\\n    \\t\\t} else {\\n    \\t\\t\\tintArr[byteOff] |= 1 << bitOff;\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t}\\n    public:\\n    \\tvector<string> findRepeatedDnaSequences(string s) {\\n    \\t\\tvector<string> result;\\n    \\t\\tif (s.length() < 11) {\\n    \\t\\t\\treturn result;\\n    \\t\\t}\\n    \\n    \\t\\tstatic const int intArrSize = 1 << (2 * 10 - 5);\\n    \\t\\tunsigned int dataArr[intArrSize] = {0};\\n    \\t\\tunsigned int recordArr[intArrSize] = {0};\\n    \\n    \\t\\tconst char *str = s.c_str();\\n    \\t\\tint size = s.length();\\n    \\t\\tstatic const unsigned int mask = ((1 << 20) - 1);\\n    \\n    \\t\\tunsigned int data = 0;\\n    \\t\\tfor (int i = 0; i < 10; ++i) {\\n    \\t\\t\\tunsigned int twobits = (str[i] >> 1) & 0x3;\\n    \\t\\t\\ttwobits <<= ((9 - i) << 1);\\n    \\t\\t\\tdata |= twobits;\\n    \\t\\t}\\n    \\t\\ttestAndSetBit(dataArr, data);\\n    \\n    \\t\\tchar dna[11] = { 0 };\\n    \\t\\tfor (int i = 10; i < size; ++i) {\\n    \\t\\t\\tunsigned int twobits = (str[i] >> 1) & 0x3;\\n    \\n    \\t\\t\\tdata = ((data << 2) | twobits) & mask;\\n    \\t\\t\\tbool hasSet = testAndSetBit(dataArr, data);\\n    \\t\\t\\tif (!hasSet) {\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\thasSet = testAndSetBit(recordArr, data);\\n    \\t\\t\\tif (hasSet) {\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\t\\t\\tmemcpy(dna, str + i - 9, 10);\\n    \\t\\t\\tresult.push_back(dna);\\n    \\t\\t}\\n    \\n    \\t\\treturn result;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    \\tinline bool testAndSetBit(unsigned int *intArr, unsigned int offset) {\\n    \\t\\tunsigned int byteOff = offset >> 5;\\n    \\t\\tunsigned int bitOff = offset & ((1 << 5) - 1);\\n    \\n    \\t\\tunsigned int bit = intArr[byteOff] & (1 << bitOff);\\n    \\t\\tif (bit) {\\n    \\t\\t\\treturn true;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3524164,
                "title": "rabin-carp-approach-repeated-dna-sequence",
                "content": "# Intuition\\nThe problem with the basic approach of checking all substrings was that it was much dependent on the length of the substring and for longer lengths the complexity would even become O(n^2). Hence, we can use Rabin Carp approach for constant time string slicing using rolling hash where basically we convert the substrings to an integer value by selecting a base. More hash values for the coming substrings can be found using rolling hash. Now if a value which had already occured is found again we can simply return tht particular substring. \\n\\n# Approach\\n1. Firstly, based on the characters in the string form an array of numbers(Replace A->0, T->1, G->2, C->3).\\n2. To obtain the first hash value consider the sequence to be a base 4 number. Convert it to its corresponding decimal number.\\n3. To compute the next hash value, we just need to remove the contribution of the left most number and add the contribution of the newly added rightmost number.\\n4. Collision can occur only when two numbers are same and no where else, hence, if we see a number more than once this would clearly mean that the substring corresponding to that particular part has been repeated and we can add it to our vector.\\n\\n# Complexity\\n- Time complexity:\\nO(N-L) where L is the length of the substring but since here we have L=10. Therefore it reduces to O(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> st;\\n        double pw=pow(4,10);\\n        int n=s.length();\\n        int li[n];\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'A\\'){\\n                li[i]=0;\\n            }\\n            else if(s[i]==\\'T\\'){\\n                li[i]=1;\\n            }\\n            else if(s[i]==\\'G\\'){\\n                li[i]=2;\\n            }\\n            else{\\n                li[i]=3;\\n            }\\n        }\\n        long long int hash_val=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n-9;i++){\\n            if(i==0){\\n                for(int i=0;i<10;i++){\\n                    hash_val= 4*hash_val + li[i]; //converting to decimal number  \\n                }\\n                mp[hash_val]++;\\n            }\\n            else{\\n                hash_val = hash_val * 4 - li[i - 1] * pw + li[i + 9]; // Finding new hash value \\n                mp[hash_val]++;\\n                if(mp[hash_val]==2){\\n                    st.push_back(s.substr(i,10));\\n                }\\n            }\\n        }\\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> st;\\n        double pw=pow(4,10);\\n        int n=s.length();\\n        int li[n];\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'A\\'){\\n                li[i]=0;\\n            }\\n            else if(s[i]==\\'T\\'){\\n                li[i]=1;\\n            }\\n            else if(s[i]==\\'G\\'){\\n                li[i]=2;\\n            }\\n            else{\\n                li[i]=3;\\n            }\\n        }\\n        long long int hash_val=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n-9;i++){\\n            if(i==0){\\n                for(int i=0;i<10;i++){\\n                    hash_val= 4*hash_val + li[i]; //converting to decimal number  \\n                }\\n                mp[hash_val]++;\\n            }\\n            else{\\n                hash_val = hash_val * 4 - li[i - 1] * pw + li[i + 9]; // Finding new hash value \\n                mp[hash_val]++;\\n                if(mp[hash_val]==2){\\n                    st.push_back(s.substr(i,10));\\n                }\\n            }\\n        }\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741774,
                "title": "easy-python-sliding-window-using-rolling-hash-technique",
                "content": "## The idea of **Rolling-Hash** is to update our initial hash as we move the sliding window.\\n\\nOur hash will be represented as an number in which each digit corresponds to its character in the sliding window, **though** we treat it as a base-***X*** number, where **X** is the minimal number of unique characters in the given string\\n\\n\\n### Example\\n\\nGiven ```\"AGTCC\"```, we can create a mapping:\\n  ```\\ncodes = { \\'A\\': 0, \\'C\\': 1, G\\': 2, \\'T\\': 3 }\\n```\\n\\n In **\"AGTCC\"** we have **4** *unique* characters, so we can choose *at least* **4** as our base.\\n\\n  ```\\n  power:              4              3              2              1              0\\n  sequence: \"         A              G              T              C              C                       \"\\n  letter-digit:  code * X**4    code * X**3    code * X**2    code * X**1    code * X**0\\n  base-4 treated:     0              2              3             1               1\\n  base-10 stored:     0             128             48            4               1\\n  \\n  \"AGTCC\" => 02311 (base-4 viewed)\\n\"AGTCC\" => 181 (base-10 stored)\\n  \\n```\\n\\n\\n### Steps:\\n\\n1. **Create a mapping**:  \\n2. **Generate the hash for the first sequence and store it as encountered once**\\n3. **Add to the result all string sequences that you encounted for the second time**\\n\\n### Solution:\\n\\n```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        if len(s) <= 10:             # for cases where \\'s\\' is shorter than 10\\n            return []\\n         \\n\\t\\tm, res = defaultdict(int), []\\n\\t\\t\\n        codes = {   \\n            \\'A\\': 0,                   # map to any unique digit in range [0, base); ex: 0-9 for base 10\\n            \\'C\\': 1, \\n            \\'G\\': 2,\\n            \\'T\\': 3,\\n        }\\n        \\n        base = 4                       # our hash base is 4, so possible digits for unique letters: 0-3, for 10 it would be: 0-9\\n        hsh = 0                        # stored as a base-10 number, but treated as a base-4 one\\n\\t\\t\\n        for i in range(10):              # get hash for the first sequence\\n            cur = codes[s[i]]\\n            hsh *= base\\n            hsh += cur\\n\\t\\t\\t\\n        m[hsh] = 1                       # store fisrt sequence (0-9) => encountered 1 time\\n        \\n        l = 1                            # start with the next sequence (1-10)\\n        while l + 9 < len(s):\\n            prevLeftMostCharCode, newRightMostCharCode = codes[s[l - 1]], codes[s[l + 9]]\\n            \\n            hsh -= prevLeftMostCharCode * base ** 9        # remove left-most digit:    12234 => 2234\\n            hsh *= base                                    # shift to the left:          2234 => 22340\\n            hsh += newRightMostCharCode                    # set the right-most digit    22340 => 22341\\n\\n            m[hsh] += 1\\n            \\n            if m[hsh] == 2:                          # res must only contain unique\\n                res.append(s[l:l + 10])\\n\\t\\t\\t  \\n            l += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Sliding Window",
                    "Rolling Hash"
                ],
                "code": "```\"AGTCC\"```\n```\\ncodes = { \\'A\\': 0, \\'C\\': 1, G\\': 2, \\'T\\': 3 }\\n```\n```\\n  power:              4              3              2              1              0\\n  sequence: \"         A              G              T              C              C                       \"\\n  letter-digit:  code * X**4    code * X**3    code * X**2    code * X**1    code * X**0\\n  base-4 treated:     0              2              3             1               1\\n  base-10 stored:     0             128             48            4               1\\n  \\n  \"AGTCC\" => 02311 (base-4 viewed)\\n\"AGTCC\" => 181 (base-10 stored)\\n  \\n```\n```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        if len(s) <= 10:             # for cases where \\'s\\' is shorter than 10\\n            return []\\n         \\n\\t\\tm, res = defaultdict(int), []\\n\\t\\t\\n        codes = {   \\n            \\'A\\': 0,                   # map to any unique digit in range [0, base); ex: 0-9 for base 10\\n            \\'C\\': 1, \\n            \\'G\\': 2,\\n            \\'T\\': 3,\\n        }\\n        \\n        base = 4                       # our hash base is 4, so possible digits for unique letters: 0-3, for 10 it would be: 0-9\\n        hsh = 0                        # stored as a base-10 number, but treated as a base-4 one\\n\\t\\t\\n        for i in range(10):              # get hash for the first sequence\\n            cur = codes[s[i]]\\n            hsh *= base\\n            hsh += cur\\n\\t\\t\\t\\n        m[hsh] = 1                       # store fisrt sequence (0-9) => encountered 1 time\\n        \\n        l = 1                            # start with the next sequence (1-10)\\n        while l + 9 < len(s):\\n            prevLeftMostCharCode, newRightMostCharCode = codes[s[l - 1]], codes[s[l + 9]]\\n            \\n            hsh -= prevLeftMostCharCode * base ** 9        # remove left-most digit:    12234 => 2234\\n            hsh *= base                                    # shift to the left:          2234 => 22340\\n            hsh += newRightMostCharCode                    # set the right-most digit    22340 => 22341\\n\\n            m[hsh] += 1\\n            \\n            if m[hsh] == 2:                          # res must only contain unique\\n                res.append(s[l:l + 10])\\n\\t\\t\\t  \\n            l += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899317,
                "title": "javascript-rolling-hash-solutions",
                "content": "##### Amorized Analysis\\n---\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n---\\n##### Code\\n---\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar findRepeatedDnaSequences = function(s) {\\n  const sequenceMap = {\\'A\\': 0, \\'C\\': 1, \\'G\\': 2, \\'T\\': 3}\\n  const base = 4;\\n  const hashMap = {};\\n  let rollingHash = 0;\\n  for(let i = 0, power = 9; i < 10; i++, power--) {\\n    rollingHash += base ** power * sequenceMap[s[i]];\\n  }\\n  hashMap[rollingHash] = s.slice(0, 10);\\n  let answer = new Set();\\n  for(let i = 10; i < s.length; i++) {\\n    let nextRollingHash = base * (rollingHash - base ** 9 * sequenceMap[s[i - 10]]) + sequenceMap[s[i]];\\n    if(nextRollingHash in hashMap) {\\n      answer.add(hashMap[nextRollingHash])\\n    } else {\\n      hashMap[nextRollingHash] = s.slice(i - 9, i + 1);\\n    }\\n    rollingHash = nextRollingHash;\\n  }\\n  return [...answer.values()];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Rolling Hash"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar findRepeatedDnaSequences = function(s) {\\n  const sequenceMap = {\\'A\\': 0, \\'C\\': 1, \\'G\\': 2, \\'T\\': 3}\\n  const base = 4;\\n  const hashMap = {};\\n  let rollingHash = 0;\\n  for(let i = 0, power = 9; i < 10; i++, power--) {\\n    rollingHash += base ** power * sequenceMap[s[i]];\\n  }\\n  hashMap[rollingHash] = s.slice(0, 10);\\n  let answer = new Set();\\n  for(let i = 10; i < s.length; i++) {\\n    let nextRollingHash = base * (rollingHash - base ** 9 * sequenceMap[s[i - 10]]) + sequenceMap[s[i]];\\n    if(nextRollingHash in hashMap) {\\n      answer.add(hashMap[nextRollingHash])\\n    } else {\\n      hashMap[nextRollingHash] = s.slice(i - 9, i + 1);\\n    }\\n    rollingHash = nextRollingHash;\\n  }\\n  return [...answer.values()];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53991,
                "title": "python-easy-to-understand-solution-using-dict",
                "content": "```\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        m, K, res = collections.defaultdict(int), 10, []\\n        for i in range(len(s)-K+1):\\n            subStr = s[i:i+K]\\n            m[subStr] += 1\\n            if m[subStr] == 2:\\n                res.append(subStr)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        m, K, res = collections.defaultdict(int), 10, []\\n        for i in range(len(s)-K+1):\\n            subStr = s[i:i+K]\\n            m[subStr] += 1\\n            if m[subStr] == 2:\\n                res.append(subStr)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214953,
                "title": "187-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStep-by-step explanation:\\n\\n1. Define a class named Solution that will contain the method to solve the problem.\\n\\n2. Define a method named findRepeatedDnaSequences that takes in a string s representing a DNA sequence and returns a list of all the 10-letter-long substrings that occur more than once in the sequence.\\n\\n3. Initialize an empty dictionary named freq that will store the frequency of each 10-letter-long substring in the DNA sequence.\\n\\n4. Iterate over each 10-letter-long substring in the DNA sequence by using a for loop that runs from the first index to the index of the last 10-letter-long substring in the sequence. The index of the last 10-letter-long substring is len(s) - 9, because we want to extract substrings of length 10.\\n\\n5. Within the for loop, extract the current 10-letter-long substring using string slicing by specifying the starting index as i and the ending index as i + 10.\\n\\n6. Update the frequency count of the current substring in the freq dictionary by using the get() method to retrieve the current count (or 0 if it doesn\\'t exist) and adding 1 to it.\\n\\n7. After the for loop, filter out the substrings that occur less than twice by using a list comprehension that iterates over the keys in the freq dictionary and only includes the keys (i.e., the substrings) that have a value (i.e., the frequency count) greater than 1.\\n\\n8. Return the list of filtered substrings as the final result of the method.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        # initialize a dictionary to store the frequency of each 10-letter-long substring\\n        freq = {}\\n        # iterate over each 10-letter-long substring in the DNA sequence\\n        for i in range(len(s) - 9):\\n            # extract the current 10-letter-long substring\\n            substring = s[i:i+10]\\n            # update the frequency count of the current substring in the dictionary\\n            freq[substring] = freq.get(substring, 0) + 1\\n        # filter out the substrings that occur less than twice and return the list of the remaining substrings\\n        return [substring for substring in freq if freq[substring] > 1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Bit Manipulation",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        # initialize a dictionary to store the frequency of each 10-letter-long substring\\n        freq = {}\\n        # iterate over each 10-letter-long substring in the DNA sequence\\n        for i in range(len(s) - 9):\\n            # extract the current 10-letter-long substring\\n            substring = s[i:i+10]\\n            # update the frequency count of the current substring in the dictionary\\n            freq[substring] = freq.get(substring, 0) + 1\\n        # filter out the substrings that occur less than twice and return the list of the remaining substrings\\n        return [substring for substring in freq if freq[substring] > 1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482180,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n     unordered_map<string,int>mp;\\n      vector<string>ans;\\n        for(int i=0;i<=s.size();i++)\\n        {  \\n            string subS=s.substr(i,10);\\n            if(mp[subS]!=-1)\\n              mp[subS]++;\\n            if(mp[subS]>1)\\n            {ans.push_back(subS);mp[subS]=-1;}\\n        }\\n        return ans;\\n    }\\n};\\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        if(s.size()<10)\\n            return {};\\n     unordered_map<string,int>mp;\\n      vector<string>ans;\\n        int i=s.size()-1;\\n        int j=s.size()-1;\\n        int k=10;\\n        string substr=\"\";\\n        // create a window\\n        while(i-j+1<k)\\n        {\\n            substr=s[j]+substr;\\n            j--;\\n        }\\n        \\n        while(j>=0)\\n        {\\n            //calculation\\n            substr=s[j]+substr;\\n            if(mp[substr]!=-1)\\n             mp[substr]++;\\n            \\n            //  To stroe result\\n            if(mp[substr]>1)\\n            {ans.push_back(substr);mp[substr]=-1;}\\n            \\n            // Remove calculation for i\\n            substr.resize(k-1);\\n            // Slide the window\\n            i--;\\n            j--;\\n            \\n                \\n                \\n        }\\n      return ans;\\n    }\\n};\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```\\n\\n\\n***PLEASE UPVOTE IF YOU FIND IT A LITTLE BIT HELPFUL, MEANS A LOT ;)***",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n     unordered_map<string,int>mp;\\n      vector<string>ans;\\n        for(int i=0;i<=s.size();i++)\\n        {  \\n            string subS=s.substr(i,10);\\n            if(mp[subS]!=-1)\\n              mp[subS]++;\\n            if(mp[subS]>1)\\n            {ans.push_back(subS);mp[subS]=-1;}\\n        }\\n        return ans;\\n    }\\n};\\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        if(s.size()<10)\\n            return {};\\n     unordered_map<string,int>mp;\\n      vector<string>ans;\\n        int i=s.size()-1;\\n        int j=s.size()-1;\\n        int k=10;\\n        string substr=\"\";\\n        // create a window\\n        while(i-j+1<k)\\n        {\\n            substr=s[j]+substr;\\n            j--;\\n        }\\n        \\n        while(j>=0)\\n        {\\n            //calculation\\n            substr=s[j]+substr;\\n            if(mp[substr]!=-1)\\n             mp[substr]++;\\n            \\n            //  To stroe result\\n            if(mp[substr]>1)\\n            {ans.push_back(substr);mp[substr]=-1;}\\n            \\n            // Remove calculation for i\\n            substr.resize(k-1);\\n            // Slide the window\\n            i--;\\n            j--;\\n            \\n                \\n                \\n        }\\n      return ans;\\n    }\\n};\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894791,
                "title": "javascript-easy-set-solution-o-n",
                "content": "```\\nvar findRepeatedDnaSequences = function (s) {\\n    let set = new Set();\\n    let result = new Set();\\n    for (let i = 0; i <=s.length - 10; i++) {\\n        let str = s.substring(i, i + 10) \\n        set.has(str) ? result.add(str) : set.add(str)\\n    }\\n    return [...result]\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar findRepeatedDnaSequences = function (s) {\\n    let set = new Set();\\n    let result = new Set();\\n    for (let i = 0; i <=s.length - 10; i++) {\\n        let str = s.substring(i, i + 10) \\n        set.has(str) ? result.add(str) : set.add(str)\\n    }\\n    return [...result]\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 609249,
                "title": "beats-100-time-and-100-space-with-explanation",
                "content": "I used Rabin-Karp algorithm and custom hashing. We can use custom hashing since there are only 4 characters with length is 10. \\n\\n     * 0000 - A\\n     * 0001 - C\\n     * 0010 - G\\n     * 0011 - T\\n(2 bits for each character) * (10 characters) = 20 bits = 0xFFFFF. Hash every substring with length is 10 then check it in hashset. If the hashcode is already exist in hashset then we found same substring.\\n\\nHere is the Rabin-Karp algorithm\\'s link:\\nhttps://www.***.org/rabin-karp-algorithm-for-pattern-searching/\\n\\n```\\n\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> answer = new ArrayList<>(s.length());\\n        int len = 10;\\n        if (s == null || s.length() <= len) {\\n            return answer;\\n        }        \\n        int baseBits = 2;\\n        int hashCode = 0;\\n        byte[] hashSet = new byte[0xFFFFF];\\n        for (int i = 0; i < len; i++) {\\n            hashCode = hashCode << baseBits | hash(s, i);\\n        }\\n        hashSet[hashCode] = 1;\\n        for (int i = 1; i < s.length() - len + 1; i++) {\\n            // remove previous character (most significant two bits) and add new character\\n            hashCode = (hashCode << baseBits) & 0xFFFFF | hash(s, i + len - 1);                                     \\n            if (hashSet[hashCode] == 0) {\\n                hashSet[hashCode]++;                \\n            } else if (hashSet[hashCode] == 1) {\\n                hashSet[hashCode]++;\\n                answer.add(s.substring(i, i + len));                \\n            }\\n        }\\n        return answer;\\n    }\\n\\n    private int hash(String s, int idx) {\\n        switch (s.charAt(idx)) {\\n        case \\'A\\':\\n            return 0;\\n        case \\'C\\':\\n            return 1;\\n        case \\'G\\':\\n            return 2;\\n        case \\'T\\':\\n            return 3;\\n        default:\\n            return 0;\\n        }\\n    }  \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> answer = new ArrayList<>(s.length());\\n        int len = 10;\\n        if (s == null || s.length() <= len) {\\n            return answer;\\n        }        \\n        int baseBits = 2;\\n        int hashCode = 0;\\n        byte[] hashSet = new byte[0xFFFFF];\\n        for (int i = 0; i < len; i++) {\\n            hashCode = hashCode << baseBits | hash(s, i);\\n        }\\n        hashSet[hashCode] = 1;\\n        for (int i = 1; i < s.length() - len + 1; i++) {\\n            // remove previous character (most significant two bits) and add new character\\n            hashCode = (hashCode << baseBits) & 0xFFFFF | hash(s, i + len - 1);                                     \\n            if (hashSet[hashCode] == 0) {\\n                hashSet[hashCode]++;                \\n            } else if (hashSet[hashCode] == 1) {\\n                hashSet[hashCode]++;\\n                answer.add(s.substring(i, i + len));                \\n            }\\n        }\\n        return answer;\\n    }\\n\\n    private int hash(String s, int idx) {\\n        switch (s.charAt(idx)) {\\n        case \\'A\\':\\n            return 0;\\n        case \\'C\\':\\n            return 1;\\n        case \\'G\\':\\n            return 2;\\n        case \\'T\\':\\n            return 3;\\n        default:\\n            return 0;\\n        }\\n    }  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 257764,
                "title": "swift-solution-with-comparison",
                "content": "## 1. Straight-Forward\\n**Runtime**: 324 ms\\n**Memory Usage**: 35.2 MB\\n\\n```swift\\nclass Solution {\\n    func findRepeatedDnaSequences(_ s: String) -> [String] {\\n        let s = Array(s)\\n        var map = [String: Int]()\\n        for i in 0..<s.count where i + 10 <= s.count {\\n            let str = String(s[i..<i+10])\\n            map[str, default: 0] += 1\\n        }\\n        return map.filter { $0.value > 1 }.map { $0.key }\\n    }\\n}\\n```\\n\\n## 2. Bit-Mapped\\n**Runtime**: 52 ms\\n**Memory Usage**: 22.4 MB\\n```swift\\nclass Solution {\\n    func findRepeatedDnaSequences(_ s: String) -> [String] {\\n        let s = Array(s)\\n        var result = [String]()\\n        var resultHash = Set<Int>()\\n        let mask = 1 << 20 - 1\\n        var map = Set<Int>()\\n        var hash = 0\\n        for i in 0..<s.count {\\n            guard let val = value(s[i]) else { return [] }\\n            hash = (hash << 2 | val) & mask\\n            if i >= 9 {\\n                if !map.contains(hash) {\\n                    map.insert(hash)\\n                } else if !resultHash.contains(hash) {\\n                    resultHash.insert(hash)\\n                    result.append(String(s[i-9...i]))\\n                }\\n            }\\n        }\\n        return result\\n    }\\n    \\n    func value(_ char: Character) -> Int? {\\n        switch char {\\n        case \"A\": return 0b00\\n        case \"C\": return 0b01\\n        case \"G\": return 0b10\\n        case \"T\": return 0b11\\n        default:  return nil\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func findRepeatedDnaSequences(_ s: String) -> [String] {\\n        let s = Array(s)\\n        var map = [String: Int]()\\n        for i in 0..<s.count where i + 10 <= s.count {\\n            let str = String(s[i..<i+10])\\n            map[str, default: 0] += 1\\n        }\\n        return map.filter { $0.value > 1 }.map { $0.key }\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func findRepeatedDnaSequences(_ s: String) -> [String] {\\n        let s = Array(s)\\n        var result = [String]()\\n        var resultHash = Set<Int>()\\n        let mask = 1 << 20 - 1\\n        var map = Set<Int>()\\n        var hash = 0\\n        for i in 0..<s.count {\\n            guard let val = value(s[i]) else { return [] }\\n            hash = (hash << 2 | val) & mask\\n            if i >= 9 {\\n                if !map.contains(hash) {\\n                    map.insert(hash)\\n                } else if !resultHash.contains(hash) {\\n                    resultHash.insert(hash)\\n                    result.append(String(s[i-9...i]))\\n                }\\n            }\\n        }\\n        return result\\n    }\\n    \\n    func value(_ char: Character) -> Int? {\\n        switch char {\\n        case \"A\": return 0b00\\n        case \"C\": return 0b01\\n        case \"G\": return 0b10\\n        case \"T\": return 0b11\\n        default:  return nil\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53895,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Repeated DNA Sequences** https://leetcode.com/problems/repeated-dna-sequences/?tab=Description\\n\\n**Brute Force**\\n* The brute force solution is to use a rolling window and store every substring in a set and report a match. This can be inefficient in terms of memory usage - you store approximately 10 * N strings.\\n\\n**Karp Rabin Optimization**\\n* The optimization should make use of reduced alphabet size and the fixed length of the strings. We use Karp-Rabin to accomplish this.\\n* There are 4 characters and this means we must use base 4.\\n* Compute the hash of first 10 characters - i.e. the base 4 representation of first 10 characters. How will you compute \"123\"? 1, 1 * 10 + 2 = 12, 12 * 10 + 3. \\n* While computing the hash for first number, compute 4^9\\n* Now as we roll the window, say the string was \"1234\"(base 10). Then hash for \"234\" = (123-100) * 10 + 4.\\n\\n```\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        if len(s) < 10:\\n            return []\\n        tags, N, base = {\"A\":0, \"C\":1, \"G\":2, \"T\":3}, 10, 4\\n        cache, repeats = set([]), set([])\\n        number, factor = 0, 1\\n        for i in range(N):\\n            number, factor = number*base + tags[s[i]], factor*base\\n        factor /= base # Pre-compute 4^9\\n        cache.add(number)\\n        for i in range(N, len(s)):\\n            number = (number - tags[s[i-N]]*factor)*base + tags[s[i]]\\n            if number in cache:\\n                repeats.add(s[i-(N-1):i+1])\\n            else:\\n                cache.add(number)\\n        return [x for x in repeats]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        if len(s) < 10:\\n            return []\\n        tags, N, base = {\"A\":0, \"C\":1, \"G\":2, \"T\":3}, 10, 4\\n        cache, repeats = set([]), set([])\\n        number, factor = 0, 1\\n        for i in range(N):\\n            number, factor = number*base + tags[s[i]], factor*base\\n        factor /= base # Pre-compute 4^9\\n        cache.add(number)\\n        for i in range(N, len(s)):\\n            number = (number - tags[s[i-N]]*factor)*base + tags[s[i]]\\n            if number in cache:\\n                repeats.add(s[i-(N-1):i+1])\\n            else:\\n                cache.add(number)\\n        return [x for x in repeats]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53901,
                "title": "well-organized-sliding-window-c-solution-beating-94",
                "content": "This is a typical sliding window problem. Since the window size is 10 and possible char is ACGT, we can encode the string covered by the window using 20-bit integer.\\n\\nThe key thing here is how to update the window. There are 2 possible cases for window, one is 1) window size < 10 2) window size == 10\\n\\nDuring the initial setup phase the window size is less than 10, so each time we only add to window. Then when window size reaches 10, we need to pop out and push back.\\n\\nSo we can abstract it into two actions 1) **eviction**, 2) **addition**\\n\\nIf window size < 10, we only do **addition**\\nIf window size == 10, we do **eviction** first, then **addition**.\\n\\nThis is also a very recommended style for all sliding window problems. Breaking up the logical of updating a window into eviction phase and addition phase can simplify and modulize the overall solution\\n\\n```\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        if (s.size() < 10) return {};\\n        unsigned int signature = 0;\\n        unordered_map<unsigned int, int> occurred;\\n        \\n        vector<string> result;\\n        for (int i=0; i<s.size(); i++) {\\n            if (i > 9) removeLeft(signature);\\n            addToRight(signature, s[i]);\\n            if (i >= 9) {\\n                int count = occurred[signature]++;\\n                if (count == 1) result.push_back(s.substr(i-9, 10));\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    //addition phase\\n    void addToRight(unsigned int& signature, char c) {\\n        signature <<= 2;\\n        if (c == 'A') {\\n            signature |= 0x0;\\n        } else if (c == 'C') {\\n            signature |= 0x1;\\n        } else if (c == 'G') {\\n            signature |= 0x2;\\n        } else {\\n            signature |= 0x3;\\n        }\\n    }\\n    \\n    //eviction phase\\n    void removeLeft(unsigned int& signature) {\\n        signature &= (1 << 18) - 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        if (s.size() < 10) return {};\\n        unsigned int signature = 0;\\n        unordered_map<unsigned int, int> occurred;\\n        \\n        vector<string> result;\\n        for (int i=0; i<s.size(); i++) {\\n            if (i > 9) removeLeft(signature);\\n            addToRight(signature, s[i]);\\n            if (i >= 9) {\\n                int count = occurred[signature]++;\\n                if (count == 1) result.push_back(s.substr(i-9, 10));\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    //addition phase\\n    void addToRight(unsigned int& signature, char c) {\\n        signature <<= 2;\\n        if (c == 'A') {\\n            signature |= 0x0;\\n        } else if (c == 'C') {\\n            signature |= 0x1;\\n        } else if (c == 'G') {\\n            signature |= 0x2;\\n        } else {\\n            signature |= 0x3;\\n        }\\n    }\\n    \\n    //eviction phase\\n    void removeLeft(unsigned int& signature) {\\n        signature &= (1 << 18) - 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54009,
                "title": "simple-java-solution-using-hashset-and-4-based-int",
                "content": "maintain two hashSets, one records the 10-letter substrings when scanning the input string, \\nthe other stores the strings that are already in the result.\\n\\nneed to convert string to integer to reduce memory used. \\nSince there are only four possible characters in string, I can use a 4-based integer to represent each string.\\n\\none tricky thing: do not write comments outside the class, or u will get Memory Limit Exceeded. \\n\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> ans = new ArrayList<>();\\n        int len = s.length();\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> res = new HashSet<>(); \\n        for (int i = 10; i<= len; ++i){\\n            String sub = s.substring(i-10,i);\\n            int n = convert(sub);\\n            if (!res.contains(n)){\\n                if (!set.contains(n))\\n                    set.add(n);\\n                else{\\n                    ans.add(sub);\\n                    res.add(n);   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public static int convert (String sub){\\n        int res = 0;\\n        HashMap<Character, Integer> dict = new HashMap<>();\\n        dict.put('A',0); dict.put('C',1);\\n        dict.put('G',2); dict.put('T',3);\\n        for (int i = 0; i< 10; ++i ){\\n            res+=dict.get(sub.charAt(i)); \\n            res*=4;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "maintain two hashSets, one records the 10-letter substrings when scanning the input string, \\nthe other stores the strings that are already in the result.\\n\\nneed to convert string to integer to reduce memory used. \\nSince there are only four possible characters in string, I can use a 4-based integer to represent each string.\\n\\none tricky thing: do not write comments outside the class, or u will get Memory Limit Exceeded. \\n\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> ans = new ArrayList<>();\\n        int len = s.length();\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> res = new HashSet<>(); \\n        for (int i = 10; i<= len; ++i){\\n            String sub = s.substring(i-10,i);\\n            int n = convert(sub);\\n            if (!res.contains(n)){\\n                if (!set.contains(n))\\n                    set.add(n);\\n                else{\\n                    ans.add(sub);\\n                    res.add(n);   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public static int convert (String sub){\\n        int res = 0;\\n        HashMap<Character, Integer> dict = new HashMap<>();\\n        dict.put('A',0); dict.put('C',1);\\n        dict.put('G',2); dict.put('T',3);\\n        for (int i = 0; i< 10; ++i ){\\n            res+=dict.get(sub.charAt(i)); \\n            res*=4;\\n        }\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 53979,
                "title": "my-concise-solution-with-c",
                "content": "Trying to use the c++ standard hash function.\\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<int, int> map;\\n        hash<string> hash_fn;\\n        vector<string> v;\\n        \\n        for(int i = 0 ; i + 9 < s.size(); i++)\\n        {\\n           string t = s.substr(i, 10);\\n           int h = hash_fn(t);\\n           \\n           if(map.find(h) == map.end())\\n           {\\n              map[h] = 1;\\n           }\\n           else\\n           {\\n               if (map[h] == 1)\\n               {\\n                   v.insert (v.end(), t);\\n               }\\n               \\n                map[h]++;\\n           }\\n        }\\n        \\n        return v;\\n    }",
                "solutionTags": [],
                "code": "Trying to use the c++ standard hash function.\\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<int, int> map;\\n        hash<string> hash_fn;\\n        vector<string> v;\\n        \\n        for(int i = 0 ; i + 9 < s.size(); i++)\\n        {\\n           string t = s.substr(i, 10);\\n           int h = hash_fn(t);\\n           \\n           if(map.find(h) == map.end())\\n           {\\n              map[h] = 1;\\n           }\\n           else\\n           {\\n               if (map[h] == 1)\\n               {\\n                   v.insert (v.end(), t);\\n               }\\n               \\n                map[h]++;\\n           }\\n        }\\n        \\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54103,
                "title": "my-concise-solution-in-c",
                "content": "Share my accepted solution.\\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n\\n        int size=s.size();\\n        hash<string> mapping;\\n        unordered_set<int> hasOccurred;\\n        vector<string> result;\\n        vector<string>::iterator iter;\\n        \\n        for(int i=0;i<=size-10;i++){\\n            string temp=s.substr(i,10);\\n            if(hasOccurred.find(mapping(temp))!=hasOccurred.end()){\\n                iter=find(result.begin(),result.end(),temp);\\n                if(iter==result.end())\\n                    result.push_back(temp);\\n            }\\n            else\\n                hasOccurred.insert(mapping(temp));\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "Share my accepted solution.\\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n\\n        int size=s.size();\\n        hash<string> mapping;\\n        unordered_set<int> hasOccurred;\\n        vector<string> result;\\n        vector<string>::iterator iter;\\n        \\n        for(int i=0;i<=size-10;i++){\\n            string temp=s.substr(i,10);\\n            if(hasOccurred.find(mapping(temp))!=hasOccurred.end()){\\n                iter=find(result.begin(),result.end(),temp);\\n                if(iter==result.end())\\n                    result.push_back(temp);\\n            }\\n            else\\n                hasOccurred.insert(mapping(temp));\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3078306,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        string st=\"\";\\n        vector <string> v;\\n        if(s.length()<10) return v;\\n        map <string,int> mp;\\n        for(int i=0;i<10 && i<s.length();i++){\\n                st+=s[i];\\n            }\\n            mp[st]++;\\n        for(int i=10;i<s.length();i++){\\n            st.erase(0,1);\\n            st+=s[i];\\n            mp[st]++;\\n        }\\n        for(auto &it:mp){\\n            if(it.second>1) v.push_back(it.first);\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        string st=\"\";\\n        vector <string> v;\\n        if(s.length()<10) return v;\\n        map <string,int> mp;\\n        for(int i=0;i<10 && i<s.length();i++){\\n                st+=s[i];\\n            }\\n            mp[st]++;\\n        for(int i=10;i<s.length();i++){\\n            st.erase(0,1);\\n            st+=s[i];\\n            mp[st]++;\\n        }\\n        for(auto &it:mp){\\n            if(it.second>1) v.push_back(it.first);\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664234,
                "title": "c-short-easiest-sliding-window-solution-explained",
                "content": "**If it helps, please UPVOTE : )**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) \\n    {\\n        vector<string> ans;\\n        unordered_map<string, int> m;    //store every string with length 10\\n        int n = s.size(), i=0, j=9;      //window size = 10\\n        \\n        while(j<n)\\n        {\\n            m[s.substr(i, j-i+1)]++;     //store the string from i to j in map\\n            i++;                         //slide the window one index right to maintain window size = 10\\n            j++;\\n        }\\n        for(auto i: m)\\n            if(i.second > 1)             //the string which has frequency > 1 will be in answer\\n                ans.push_back(i.first);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) \\n    {\\n        vector<string> ans;\\n        unordered_map<string, int> m;    //store every string with length 10\\n        int n = s.size(), i=0, j=9;      //window size = 10\\n        \\n        while(j<n)\\n        {\\n            m[s.substr(i, j-i+1)]++;     //store the string from i to j in map\\n            i++;                         //slide the window one index right to maintain window size = 10\\n            j++;\\n        }\\n        for(auto i: m)\\n            if(i.second > 1)             //the string which has frequency > 1 will be in answer\\n                ans.push_back(i.first);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338162,
                "title": "python-sliding-window-with-dictionary",
                "content": "\\'\\'\\'\\n\\t\\t\\n\\t\\tans, dic = [], {}\\n        for i in range(len(s)-9):\\n            if s[i:i+10] in dic and s[i:i+10] not in ans:\\n                    ans.append(s[i:i+10])\\n            dic[s[i:i+10]] = 0\\n        return ans\\n\\t\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "\\'\\'\\'\\n\\t\\t\\n\\t\\tans, dic = [], {}\\n        for i in range(len(s)-9):\\n            if s[i:i+10] in dic and s[i:i+10] not in ans:\\n                    ans.append(s[i:i+10])\\n            dic[s[i:i+10]] = 0\\n        return ans\\n\\t\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 898917,
                "title": "python-4-line-simplest-solution",
                "content": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        counter = defaultdict(int)\\n        for i in range(len(s)-9):\\n            counter[s[i:i+10]]+=1\\n        return [s for s in counter.keys() if counter[s]>1] \\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        counter = defaultdict(int)\\n        for i in range(len(s)-9):\\n            counter[s[i:i+10]]+=1\\n        return [s for s in counter.keys() if counter[s]>1] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 898213,
                "title": "repeated-dna-sequence-python3-using-set",
                "content": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        se = set()\\n        ans = []\\n        for i in range(len(s)-10+1):\\n            if s[i: i+10] in se:\\n                ans.append(s[i: i+10])\\n            else:\\n                se.add(s[i: i+10])\\n        return set(ans)\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        se = set()\\n        ans = []\\n        for i in range(len(s)-10+1):\\n            if s[i: i+10] in se:\\n                ans.append(s[i: i+10])\\n            else:\\n                se.add(s[i: i+10])\\n        return set(ans)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 494790,
                "title": "simple-c-solution-using-dictionary",
                "content": "```\\npublic IList<string> FindRepeatedDnaSequences(string s)\\n        {\\n            var dict = new Dictionary<string, int>();\\n\\n            for (int i = 0; i <= s.Length - 10; i++)\\n            {\\n                var str = s.Substring(i, 10);\\n                dict[str] = dict.ContainsKey(str) ? dict[str] + 1 : 1;\\n            }\\n\\n            return dict.Where(str => str.Value > 1)\\n                       .Select(str => str.Key)\\n                       .ToList();\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic IList<string> FindRepeatedDnaSequences(string s)\\n        {\\n            var dict = new Dictionary<string, int>();\\n\\n            for (int i = 0; i <= s.Length - 10; i++)\\n            {\\n                var str = s.Substring(i, 10);\\n                dict[str] = dict.ContainsKey(str) ? dict[str] + 1 : 1;\\n            }\\n\\n            return dict.Where(str => str.Value > 1)\\n                       .Select(str => str.Key)\\n                       .ToList();\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 184397,
                "title": "c-c-python-fast-clean-solution-o-n-time-and-space-efficient",
                "content": "## **Python Simple Solution**\\nShort and sweet. Count the frequency of all 10 character substrings and return those with more than 1.\\n```python\\ndef findRepeatedDnaSequences(self, s: str) -> List[str]:\\n  freq = {}\\n  for sub in [s[i:i + 10] for i in range(len(s) - 9)]:\\n    freq[sub] = freq.get(sub, 0) + 1\\n  return [sub for sub, count in freq.items() if count > 1]\\n```\\n## **C++ Simple Solution**\\nThe problem _could_ be easily solved using a hashmap in C++.\\n\\n```cpp\\n  vector<string> findRepeatedDnaSequences(string s) {\\n    std::vector<std::string> ret;\\n    std::unordered_map<std::string, int> sequences;\\n    for (int i = 0; i + 9 < s.size(); ++i) {\\n      if (2 == ++sequences[std::string(s.begin() + i, s.begin() + i + 10)]) {\\n        ret.emplace_back(s.begin() + i, s.begin() + i + 10);\\n      }\\n    }\\n    return ret;\\n  }\\n```\\n\\nSo what\\'s the problem? Well while _technically_ an O(n) time, O(n) space solution, there is actually a big constant factor which needs to be considered.\\n\\nEach time a hash is generated, 10 characters must be read. Each time a sequence is stored in the hashmap, 10 characters must be stored.\\n\\nConsider the case of a 100 character long input string, that has no duplicate sequences of 10. The first 10 loops around the for statement will generate 10 hashes, with each hash reading 10 characters. Thus 100 characters read. What\\'s more, since there has been no duplicate, we\\'ve stored in the hashmap 10 strings on length 10.\\n\\nWe\\'re only a 1/10th of the way though our string, yet we\\'ve already read 100 characters and stored 100 characters. By the time we\\'ve finished, we\\'ve read and stored 1000 characters (will actually be slightly less, but close enough). That\\'s an order of magnitude more than our input string.\\n\\nIsn\\'t that O(n^2) time and O(n^2) space then? Well it\\'s bad, but not that bad. The reason is simple, the length on the search string is _fixed_ to 10 characters and not the input string. Thus it is actually O(10 * n) time, O(10 * n) space, but as per the definition of big-O notation, the constants get dropped and we end up with O(n) time, O(n) space.\\n\\n## **Better**\\nThe real problem is those hash generations and storage. What we need is a system that just incorporates the newest character we encounter and forgetting the oldest, without having to re-read the middle. If we could do that, we would only need to read a single character each time around the loop. Can it be done though? Well obviously it can or I wouldn\\'t be writing this. The trick is that there is only 4 possible characters, so we only need 2 bits to store each nucleotide and there are only 10 nucleotides to store.\\n\\nThis means with only 20 bits of data, we can uniquely store all 10 nucleotides. Generating this 20 bits is just a matter of shifting the previous \\'hash\\' left by two bits and adding the new 2 bits at the start. A simple mask will take care of the overflow of \\'old\\' nucleotides. We\\'re now hasing on a 32bit number, which is something hashtables love to do.\\n\\n```cpp\\nvector<string> findRepeatedDnaSequences(string s) {\\n  std::int8_t nuc_vals[\\'T\\' - \\'A\\' + 1];\\n  nuc_vals[\\'A\\' - \\'A\\'] = 0;\\n  nuc_vals[\\'C\\' - \\'A\\'] = 1;\\n  nuc_vals[\\'G\\' - \\'A\\'] = 2;\\n  nuc_vals[\\'T\\' - \\'A\\'] = 3;\\n\\n  // Seed our fingerprint for the first 9 characters\\n  int32_t fingerprint = 0;\\n  for (int i = 0; i < 9 && i < s.size(); ++i) {\\n    fingerprint = fingerprint * 4 + nuc_vals[s[i] - \\'A\\'];\\n  }\\n\\n  std::vector<std::string> ret;\\n\\n  // For each character, shift the fingerprint 2 bits and add the new character value\\n  std::unordered_map<int32_t, int32_t> freq;\\n  for (int i = 9; i < s.size(); ++i) {\\n    // Shift left four bits (* 4), add new val and mask out extra (too far left) bits\\n    fingerprint = (fingerprint * 4 + nuc_vals[s[i] - \\'A\\']) & ((1 << 20) - 1);\\n    // If this is the second time we\\'ve seen this fingerprint, then add to the solution\\n    if (2 == ++freq[fingerprint]) {\\n      ret.emplace_back(s.begin() + i - 9, s.begin() + i + 1);\\n    }\\n  }\\n  return ret;\\n}\\n```\\n\\nThe \\'hashing\\' and comparing is much faster and more space friendly than the first solution presented, in particularly when working with large input strings.\\n\\n## What about a rolling hash?\\nThis problem is nicely solved as above, since we only need a single 32bit number to store each sequence of fixed size. In real life, things are not normally so nice and require varibale length support. This is generally done using a rolling hash which updates the hash as a new character is added. There is no benefit to doing a more complex rolling hash for this problem though. In particular because this problem allows for a guarenteed unique fingerprint to be generated, thus there is no hash colishions. The reader is of course free to do it for fun.\\n\\n## **C Solution**\\nC does not come with built in hashtable, so we have to use the uthash library that is automatically included by leetcode. Other than that, it is pretty much the same efficent solution as the c++ above.\\n```c\\nstruct SequenceHash {\\n  uint32_t fingerprint;\\n  bool duplicate;\\n  UT_hash_handle hh;\\n};\\n\\nchar ** findRepeatedDnaSequences(char * s, int* returnSize) {\\n  int8_t nuc_value[\\'T\\' - \\'A\\' + 1];\\n  nuc_value[\\'A\\' - \\'A\\'] = 0;\\n  nuc_value[\\'C\\' - \\'A\\'] = 1;\\n  nuc_value[\\'G\\' - \\'A\\'] = 2;\\n  nuc_value[\\'T\\' - \\'A\\'] = 3;\\n  \\n  char** ret = NULL;\\n  *returnSize = 0;\\n  size_t ret_cap = 0;\\n  \\n  struct SequenceHash* table = NULL;\\n  \\n  /* Seed the inital 9 characters */\\n  uint32_t fingerprint = 0;\\n  for (int i = 0; i < 9 && *s; ++i) {\\n    fingerprint = (fingerprint << 2) + nuc_value[*s++ - \\'A\\'];\\n  }\\n  \\n  while (*s) {\\n    /* Add new nucleotide and remove oldest */\\n    fingerprint = ((fingerprint << 2) + nuc_value[*s++ - \\'A\\']) & ((uint32_t)(1 << 20) - 1);\\n    struct SequenceHash* entry;\\n    HASH_FIND(hh, table, &fingerprint, sizeof(fingerprint), entry);\\n    \\n    if (!entry) { /* First time sequence seen */\\n      entry = (struct SequenceHash*) malloc(sizeof(struct SequenceHash));\\n      entry->fingerprint = fingerprint;\\n      entry->duplicate = false;\\n      HASH_ADD(hh, table, fingerprint, sizeof(entry->fingerprint), entry);\\n    } else if (!entry->duplicate) { /* Second time sequence seen */\\n      entry->duplicate = true;\\n      if (*returnSize == ret_cap) {\\n        ret_cap = (ret_cap) ? ret_cap * 2 : 1;\\n        ret = (char**) realloc(ret, ret_cap * sizeof(char*));\\n      }\\n      ret[*returnSize] = (char*) malloc((10 + 1) * sizeof(char));\\n      memcpy(ret[*returnSize], s - 10, 10);\\n      ret[(*returnSize)++][10] = \\'\\\\0\\';\\n    }\\n  }\\n  \\n  /* Destroy hash table */\\n  struct SequenceHash* entry;\\n  struct SequenceHash* tmp;\\n  HASH_ITER(hh, table, entry, tmp) {\\n    HASH_DEL(table, entry);\\n    free(entry);\\n  }\\n  \\n  return realloc(ret, *returnSize * sizeof(int*));\\n}\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\ndef findRepeatedDnaSequences(self, s: str) -> List[str]:\\n  freq = {}\\n  for sub in [s[i:i + 10] for i in range(len(s) - 9)]:\\n    freq[sub] = freq.get(sub, 0) + 1\\n  return [sub for sub, count in freq.items() if count > 1]\\n```\n```cpp\\n  vector<string> findRepeatedDnaSequences(string s) {\\n    std::vector<std::string> ret;\\n    std::unordered_map<std::string, int> sequences;\\n    for (int i = 0; i + 9 < s.size(); ++i) {\\n      if (2 == ++sequences[std::string(s.begin() + i, s.begin() + i + 10)]) {\\n        ret.emplace_back(s.begin() + i, s.begin() + i + 10);\\n      }\\n    }\\n    return ret;\\n  }\\n```\n```cpp\\nvector<string> findRepeatedDnaSequences(string s) {\\n  std::int8_t nuc_vals[\\'T\\' - \\'A\\' + 1];\\n  nuc_vals[\\'A\\' - \\'A\\'] = 0;\\n  nuc_vals[\\'C\\' - \\'A\\'] = 1;\\n  nuc_vals[\\'G\\' - \\'A\\'] = 2;\\n  nuc_vals[\\'T\\' - \\'A\\'] = 3;\\n\\n  // Seed our fingerprint for the first 9 characters\\n  int32_t fingerprint = 0;\\n  for (int i = 0; i < 9 && i < s.size(); ++i) {\\n    fingerprint = fingerprint * 4 + nuc_vals[s[i] - \\'A\\'];\\n  }\\n\\n  std::vector<std::string> ret;\\n\\n  // For each character, shift the fingerprint 2 bits and add the new character value\\n  std::unordered_map<int32_t, int32_t> freq;\\n  for (int i = 9; i < s.size(); ++i) {\\n    // Shift left four bits (* 4), add new val and mask out extra (too far left) bits\\n    fingerprint = (fingerprint * 4 + nuc_vals[s[i] - \\'A\\']) & ((1 << 20) - 1);\\n    // If this is the second time we\\'ve seen this fingerprint, then add to the solution\\n    if (2 == ++freq[fingerprint]) {\\n      ret.emplace_back(s.begin() + i - 9, s.begin() + i + 1);\\n    }\\n  }\\n  return ret;\\n}\\n```\n```c\\nstruct SequenceHash {\\n  uint32_t fingerprint;\\n  bool duplicate;\\n  UT_hash_handle hh;\\n};\\n\\nchar ** findRepeatedDnaSequences(char * s, int* returnSize) {\\n  int8_t nuc_value[\\'T\\' - \\'A\\' + 1];\\n  nuc_value[\\'A\\' - \\'A\\'] = 0;\\n  nuc_value[\\'C\\' - \\'A\\'] = 1;\\n  nuc_value[\\'G\\' - \\'A\\'] = 2;\\n  nuc_value[\\'T\\' - \\'A\\'] = 3;\\n  \\n  char** ret = NULL;\\n  *returnSize = 0;\\n  size_t ret_cap = 0;\\n  \\n  struct SequenceHash* table = NULL;\\n  \\n  /* Seed the inital 9 characters */\\n  uint32_t fingerprint = 0;\\n  for (int i = 0; i < 9 && *s; ++i) {\\n    fingerprint = (fingerprint << 2) + nuc_value[*s++ - \\'A\\'];\\n  }\\n  \\n  while (*s) {\\n    /* Add new nucleotide and remove oldest */\\n    fingerprint = ((fingerprint << 2) + nuc_value[*s++ - \\'A\\']) & ((uint32_t)(1 << 20) - 1);\\n    struct SequenceHash* entry;\\n    HASH_FIND(hh, table, &fingerprint, sizeof(fingerprint), entry);\\n    \\n    if (!entry) { /* First time sequence seen */\\n      entry = (struct SequenceHash*) malloc(sizeof(struct SequenceHash));\\n      entry->fingerprint = fingerprint;\\n      entry->duplicate = false;\\n      HASH_ADD(hh, table, fingerprint, sizeof(entry->fingerprint), entry);\\n    } else if (!entry->duplicate) { /* Second time sequence seen */\\n      entry->duplicate = true;\\n      if (*returnSize == ret_cap) {\\n        ret_cap = (ret_cap) ? ret_cap * 2 : 1;\\n        ret = (char**) realloc(ret, ret_cap * sizeof(char*));\\n      }\\n      ret[*returnSize] = (char*) malloc((10 + 1) * sizeof(char));\\n      memcpy(ret[*returnSize], s - 10, 10);\\n      ret[(*returnSize)++][10] = \\'\\\\0\\';\\n    }\\n  }\\n  \\n  /* Destroy hash table */\\n  struct SequenceHash* entry;\\n  struct SequenceHash* tmp;\\n  HASH_ITER(hh, table, entry, tmp) {\\n    HASH_DEL(table, entry);\\n    free(entry);\\n  }\\n  \\n  return realloc(ret, *returnSize * sizeof(int*));\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 142300,
                "title": "python-rolling-hash",
                "content": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        # We can use rolling hash to effeciently compute hash values of the pattern\\n        # hsh as counter for hash value => string\\n        hsh = {}\\n        def cal_hsh(string):\\n            assert(len(string) == 10)\\n            hsh_val = 0\\n            for i in range(10):\\n                hsh_val += ord(string[i]) * 7**i\\n            return hsh_val    \\n        def update_hsh(prev_val, drop_idx, add_idx):\\n            return (prev_val - ord(s[drop_idx]))//7 + ord(s[add_idx]) * 7 ** 9\\n        \\n        n = len(s)\\n        if n < 10: return []\\n        hsh_val = cal_hsh(s[:10])\\n        hsh[hsh_val] = s[:10]\\n        ret = set()\\n        # Notice this is n-9 since we want the last substring of length 10\\n        for i in range(1, n-9):\\n            hsh_val = update_hsh(hsh_val, i-1, i+9)\\n            if hsh_val in hsh:\\n                ret.add(s[i:i+10])\\n            else:\\n                hsh[hsh_val] = s[i:i+10]\\n        return list(ret)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        # We can use rolling hash to effeciently compute hash values of the pattern\\n        # hsh as counter for hash value => string\\n        hsh = {}\\n        def cal_hsh(string):\\n            assert(len(string) == 10)\\n            hsh_val = 0\\n            for i in range(10):\\n                hsh_val += ord(string[i]) * 7**i\\n            return hsh_val    \\n        def update_hsh(prev_val, drop_idx, add_idx):\\n            return (prev_val - ord(s[drop_idx]))//7 + ord(s[add_idx]) * 7 ** 9\\n        \\n        n = len(s)\\n        if n < 10: return []\\n        hsh_val = cal_hsh(s[:10])\\n        hsh[hsh_val] = s[:10]\\n        ret = set()\\n        # Notice this is n-9 since we want the last substring of length 10\\n        for i in range(1, n-9):\\n            hsh_val = update_hsh(hsh_val, i-1, i+9)\\n            if hsh_val in hsh:\\n                ret.add(s[i:i+10])\\n            else:\\n                hsh[hsh_val] = s[i:i+10]\\n        return list(ret)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 53988,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "There is only 4 possible character so I simply encode each substring in 20 bits.\\n<BR>I don't want to implement a hash map so I simply sort the encoded values and then check if any value is equal to its adjacent value.\\n<BR>After a repeated substring is found, restore it from the encoded value.\\n \\n    #define CODE(a) ('A' == (a) ? 0 : 'C' == (a) ? 1 : 'G' == (a) ? 2 : 3)\\n    #define CHAR(a) (0 == (a) ? 'A' : 1 == (a) ? 'C' : 2 == (a) ? 'G' : 'T')\\n    int comp(const void* p1, const void* p2) {\\n        int a = *((int*) p1);\\n        int b = *((int*) p2);\\n        return a == b ? 0 : a > b ? 1 : -1;\\n    }\\n    char** findRepeatedDnaSequences(char* s, int* returnSize) {\\n        int len = s && *s ? (int) strlen(s) - 9 : 0, *encode;\\n        int i, j, code = 0, mask = (1 << 20) - 1;\\n        char** result;\\n        if (1 >= len) {\\n            *returnSize = 0;\\n            return NULL;\\n        }\\n        encode = malloc(sizeof(int) * len);\\n        for (i = 0, j = 0; s[i]; ++i) {\\n            code = ((code << 2) | CODE(s[i])) & mask;\\n            9 <= i ? (encode[j++] = code) : 0;\\n        }\\n        result = malloc(sizeof(char*) * len);\\n        qsort(encode, len, sizeof(int), comp);\\n        code = 0;\\n        for (i = 1; i < len; ++i) {\\n            if (encode[i] == encode[i - 1] && \\n                (i == len - 1 || encode[i] != encode[i + 1])) {\\n                result[code] = malloc(11);\\n                for (j = 0; j < 10; ++j) {\\n                    result[code][j] = CHAR((encode[i] >> ((9 - j) << 1)) & 3);\\n                }\\n                result[code][j] = '\\\\0';\\n                code++;\\n            }\\n        }\\n        free(encode);\\n        *returnSize = code;\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "There is only 4 possible character so I simply encode each substring in 20 bits.\\n<BR>I don't want to implement a hash map so I simply sort the encoded values and then check if any value is equal to its adjacent value.\\n<BR>After a repeated substring is found, restore it from the encoded value.\\n \\n    #define CODE(a) ('A' == (a) ? 0 : 'C' == (a) ? 1 : 'G' == (a) ? 2 : 3)\\n    #define CHAR(a) (0 == (a) ? 'A' : 1 == (a) ? 'C' : 2 == (a) ? 'G' : 'T')\\n    int comp(const void* p1, const void* p2) {\\n        int a = *((int*) p1);\\n        int b = *((int*) p2);\\n        return a == b ? 0 : a > b ? 1 : -1;\\n    }\\n    char** findRepeatedDnaSequences(char* s, int* returnSize) {\\n        int len = s && *s ? (int) strlen(s) - 9 : 0, *encode;\\n        int i, j, code = 0, mask = (1 << 20) - 1;\\n        char** result;\\n        if (1 >= len) {\\n            *returnSize = 0;\\n            return NULL;\\n        }\\n        encode = malloc(sizeof(int) * len);\\n        for (i = 0, j = 0; s[i]; ++i) {\\n            code = ((code << 2) | CODE(s[i])) & mask;\\n            9 <= i ? (encode[j++] = code) : 0;\\n        }\\n        result = malloc(sizeof(char*) * len);\\n        qsort(encode, len, sizeof(int), comp);\\n        code = 0;\\n        for (i = 1; i < len; ++i) {\\n            if (encode[i] == encode[i - 1] && \\n                (i == len - 1 || encode[i] != encode[i + 1])) {\\n                result[code] = malloc(11);\\n                for (j = 0; j < 10; ++j) {\\n                    result[code][j] = CHAR((encode[i] >> ((9 - j) << 1)) & 3);\\n                }\\n                result[code][j] = '\\\\0';\\n                code++;\\n            }\\n        }\\n        free(encode);\\n        *returnSize = code;\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54046,
                "title": "clear-solution-traverse-each-character-once-java",
                "content": "This algorithm use hashmap and bit operation.\\n\\nwe use '00' -> 'A', '01' -> 'C', '10' -> 'G', '11' -> 'T' to save memory.\\n\\nHere is the code:\\n\\n    public class Solution {\\n        public List<String> findRepeatedDnaSequences(String s) {\\n            int len = s.length();\\n            if(len <= 10){\\n                return new ArrayList<String>();\\n            }\\n            \\n            List<String> result = new ArrayList<String>();\\n            //to store 10-letter-long sequence information\\n            int sequence = 0;\\n            //creat a mask to clear character move out side\\n            //where clearMask = 1111 1111 1100 1111 1111 1111 1111 1111\\n            int clearMask = ~(3 << 20);\\n            Map<Integer,Byte> recordMap = new HashMap<Integer,Byte>();\\n            \\n            //initial sequence\\n            for(int i = 0; i < 10; i++){\\n                sequence = readChar(s.charAt(i), sequence, clearMask);\\n            }\\n            \\n            //put initial pattern into hash map\\n            recordMap.put(sequence, (byte) 0);\\n            //find all pattern in the DNA string\\n            for(int i = 10; i < len; i++){\\n                sequence = readChar(s.charAt(i), sequence, clearMask);\\n                if(recordMap.containsKey(sequence)){\\n                    if(recordMap.get(sequence) == 0){\\n                        recordMap.put(sequence, (byte) 1);\\n                        result.add(s.substring(i - 9, i + 1));\\n                    }\\n                }\\n                else{\\n                    recordMap.put(sequence, (byte) 0);\\n                }\\n            }\\n            return result;\\n        }\\n        \\n        public int readChar(char c, int seq, int mask){\\n            //move record sequence left 2 position make room for this character\\n            seq <<= 2;\\n            //clear character which may out of bound\\n            seq &= mask;\\n            switch(c){\\n                    /* It is no need to do the 'or' operater\\n                       because we use \"00\" to present character 'A'\\n                    case 'A':\\n                        seq |= 0;\\n                        break;\\n                    */\\n                    case 'C':\\n                        seq |= 1;\\n                        break;\\n                    case 'G':\\n                        seq |= 2;\\n                        break;\\n                    case 'T':\\n                        seq |= 3;\\n                        break;\\n            }\\n            return seq;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> findRepeatedDnaSequences(String s) {\\n            int len = s.length();\\n            if(len <= 10){\\n                return new ArrayList<String>();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 54060,
                "title": "my-c-code-10ms-use-an-array-of-2-18-2-bit-counters-one-trick-to-avoid-switch",
                "content": "The basic idea is to use an array of 2^18 2-bit counters to count how many times each possible sequences occurs (there are 4^10 possible sequences so 2^18-char array is needed). Another trick is instead of using \"switch\" to calculate mapIdx (char array index) and bitIdx (bit position within a char), I use the bit-1 and bit-2  to distinguish \"A\" , \"C\", \"G\" and \"T\" since (bit-1, bit-2) are \"00\", \"01\", \"11\", and \"10\" respectively. To get bit-2 and bit-1, it does  ((s[i] & 0x6)>>1);   \\n\\n \\n\\n    vector<unsigned char> map(262144, 0); // use 2 bits to count how many times a specific sequence occurs. in total 4^10 different sequences\\n            vector<string> res;\\n            int i,len = s.size();\\n            unsigned int mapIdx = 0, bitIdx =0;\\n            unsigned char temp;\\n            if(len>10)\\n            {\\n                for(i=0;i<9;i++) mapIdx =(mapIdx<<2) + ((s[i] & 0x6)>>1); // initialize the char index\\n                bitIdx = (s[9] & 0x6) ; // initialize the bit shift\\n                map[mapIdx] = map[mapIdx] | (0x1<<bitIdx); // set the counter of the sequence s[0:9] to 1\\n                for(i=10;i<len;i++)\\n                { // go through all the 10-symbol sequences\\n                    mapIdx = ((mapIdx & 0xffff)<<2) +  (bitIdx >> 1) ; // update the char index\\n                    bitIdx = (s[i] & 0x6) ; // also update the bit shift\\n                    temp = (map[mapIdx] & (0x3<<bitIdx))>> bitIdx; // get the counter value\\n                    if(temp == 1)\\n                    {// if it already occurs once before\\n                        res.push_back(s.substr(i-9,10)); // save to the resulting vector\\n                        map[mapIdx] |=  (0x3<<bitIdx); // and set the counter to 2 \\n                    }\\n                    map[mapIdx] |=  (0x1<<bitIdx); // if never occured before, then set the counter to 1\\n                    \\n                }\\n                \\n           }\\n            return res;",
                "solutionTags": [],
                "code": "The basic idea is to use an array of 2^18 2-bit counters to count how many times each possible sequences occurs (there are 4^10 possible sequences so 2^18-char array is needed). Another trick is instead of using \"switch\" to calculate mapIdx (char array index) and bitIdx (bit position within a char), I use the bit-1 and bit-2  to distinguish \"A\" , \"C\", \"G\" and \"T\" since (bit-1, bit-2) are \"00\", \"01\", \"11\", and \"10\" respectively. To get bit-2 and bit-1, it does  ((s[i] & 0x6)>>1);   \\n\\n \\n\\n    vector<unsigned char> map(262144, 0); // use 2 bits to count how many times a specific sequence occurs. in total 4^10 different sequences\\n            vector<string> res;\\n            int i,len = s.size();\\n            unsigned int mapIdx = 0, bitIdx =0;\\n            unsigned char temp;\\n            if(len>10)\\n            {\\n                for(i=0;i<9;i++) mapIdx =(mapIdx<<2) + ((s[i] & 0x6)>>1); // initialize the char index\\n                bitIdx = (s[9] & 0x6) ; // initialize the bit shift\\n                map[mapIdx] = map[mapIdx] | (0x1<<bitIdx); // set the counter of the sequence s[0:9] to 1\\n                for(i=10;i<len;i++)\\n                { // go through all the 10-symbol sequences\\n                    mapIdx = ((mapIdx & 0xffff)<<2) +  (bitIdx >> 1) ; // update the char index\\n                    bitIdx = (s[i] & 0x6) ; // also update the bit shift\\n                    temp = (map[mapIdx] & (0x3<<bitIdx))>> bitIdx; // get the counter value\\n                    if(temp == 1)\\n                    {// if it already occurs once before\\n                        res.push_back(s.substr(i-9,10)); // save to the resulting vector\\n                        map[mapIdx] |=  (0x3<<bitIdx); // and set the counter to 2 \\n                    }\\n                    map[mapIdx] |=  (0x1<<bitIdx); // if never occured before, then set the counter to 1\\n                    \\n                }\\n                \\n           }\\n            return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 54078,
                "title": "java-program-in-225ms-could-be-even-faster",
                "content": "This is may java code. Since the dictionary space is only 1^20, and we only need two bits for three states (appearing 0 times, 1 times, or more than 2 times) for each word. So, we can use 1^22 bits or 256KB memory for that, which can make the program better fit into hardware caches closer to CPU. In my program, for simplicity, I just use a 1MB dictionary for that. To conclude, the optimal solution might be C/C++ with 256KB dictionary. \\n\\n    import java.util.*;\\n    \\n    public class Solution {\\n        \\n        private static byte codebook[];\\n        private static final byte textbook[] = {'A','C','G','T'};\\n        static{\\n            codebook=new byte[256];\\n            codebook['A']=0;\\n            codebook['C']=1;\\n            codebook['G']=2;\\n            codebook['T']=3;\\n        }\\n        private byte dnaBuf[] = new byte[10];\\n        private String decode(int c){\\n            for(int i=0;i<10;i++){\\n                dnaBuf[i]=textbook[(c&0xc0000)>>18];\\n                c<<=2;\\n            }\\n            return new String(dnaBuf);\\n        }\\n        \\n        public List<String> findRepeatedDnaSequences(String s) {\\n            List<String> rL = new Vector<String>();\\n            byte dnaMap[] = new byte[1<<20];\\n            int i;\\n            if(s==null || s.length()<=10)return rL;\\n            int code=0;\\n            for(i=0;i<9;i++)code=((code<<2)+codebook[s.charAt(i)])&0xfffff;\\n            for(;i<s.length();i++){\\n                code=((code<<2)+codebook[s.charAt(i)])&0xfffff;\\n                if(dnaMap[code]==0)dnaMap[code]++;\\n                else if(dnaMap[code]==1){\\n                    dnaMap[code]++;\\n                    rL.add(decode(code));\\n                }\\n            }\\n            return rL;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        private static byte codebook[];\\n        private static final byte textbook[] = {'A','C','G','T'}",
                "codeTag": "Java"
            },
            {
                "id": 3739981,
                "title": "c-unordered-map-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        int n = s.size();\\n        unordered_map<string, int> m;\\n        vector<string> res;\\n        \\n        for(int i = 0; i < n-9; i++) {\\n            m[s.substr(i, 10)]++;\\n        }\\n\\n        for(auto itr = m.begin(); itr != m.end(); itr++) {\\n            if(itr->second > 1) {\\n                res.push_back(itr->first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        int n = s.size();\\n        unordered_map<string, int> m;\\n        vector<string> res;\\n        \\n        for(int i = 0; i < n-9; i++) {\\n            m[s.substr(i, 10)]++;\\n        }\\n\\n        for(auto itr = m.begin(); itr != m.end(); itr++) {\\n            if(itr->second > 1) {\\n                res.push_back(itr->first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674786,
                "title": "meta-question-easy-linear-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSIMPLE SLIDING WINDOW APPLICATION\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> res;\\n\\n        int i = 0;\\n        int j = 0;\\n        string curr = \"\";\\n        unordered_map<string, int> mp;\\n\\n        while (j < s.length()) {\\n            if (j - i + 1 == 10) {\\n                curr = s.substr(i,10);\\n                mp[curr]++;\\n                if (mp[curr]==2) {\\n                    res.push_back(curr);\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> res;\\n\\n        int i = 0;\\n        int j = 0;\\n        string curr = \"\";\\n        unordered_map<string, int> mp;\\n\\n        while (j < s.length()) {\\n            if (j - i + 1 == 10) {\\n                curr = s.substr(i,10);\\n                mp[curr]++;\\n                if (mp[curr]==2) {\\n                    res.push_back(curr);\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549724,
                "title": "187-repeated-dna-sequences",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> map;\\n        int l = 0;\\n\\n        string str = \"\";\\n        while (l + 9 < s.size()) {\\n            map[s.substr(l, 10)]++;\\n            l++;\\n        }\\n\\n        vector<string> res;\\n        for (auto& m : map) {\\n            if (m.second > 1) res.push_back(m.first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> map;\\n        int l = 0;\\n\\n        string str = \"\";\\n        while (l + 9 < s.size()) {\\n            map[s.substr(l, 10)]++;\\n            l++;\\n        }\\n\\n        vector<string> res;\\n        for (auto& m : map) {\\n            if (m.second > 1) res.push_back(m.first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051314,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Hash\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> ans;\\n        if(s.size() < 10) return ans;\\n        map<string, int> mp;\\n        string tmp;\\n        for(int i=0; i<s.size() and i<10; i++) tmp.push_back(s[i]);\\n        mp[tmp]++;\\n        for(int i=10; i<s.size(); i++) {\\n            tmp.erase(0, 1);\\n            tmp.push_back(s[i]);\\n            mp[tmp]++;\\n        }\\n        for(auto x: mp) {\\n            if(x.second > 1) ans.push_back(x.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> ans;\\n        if(s.size() < 10) return ans;\\n        map<string, int> mp;\\n        string tmp;\\n        for(int i=0; i<s.size() and i<10; i++) tmp.push_back(s[i]);\\n        mp[tmp]++;\\n        for(int i=10; i<s.size(); i++) {\\n            tmp.erase(0, 1);\\n            tmp.push_back(s[i]);\\n            mp[tmp]++;\\n        }\\n        for(auto x: mp) {\\n            if(x.second > 1) ans.push_back(x.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049199,
                "title": "map-java-solution-new-hashmap-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n\\n        \\n        List<String>a=new ArrayList<>();\\n        if(s.length()<=10){\\n            return a;\\n        }\\n\\n        HashMap<String,Integer>map=new HashMap<>();\\n        for(int i=0;i<=s.length()-10;i++){\\n            String ans=s.substring(i,i+10);\\n            map.put(ans,map.getOrDefault(ans,0)+1);\\n        }\\n\\n        for(Map.Entry<String,Integer>e:map.entrySet()){\\n            if(e.getValue()>1){\\n                a.add(e.getKey());\\n            }\\n        }\\n        return a;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n\\n        \\n        List<String>a=new ArrayList<>();\\n        if(s.length()<=10){\\n            return a;\\n        }\\n\\n        HashMap<String,Integer>map=new HashMap<>();\\n        for(int i=0;i<=s.length()-10;i++){\\n            String ans=s.substring(i,i+10);\\n            map.put(ans,map.getOrDefault(ans,0)+1);\\n        }\\n\\n        for(Map.Entry<String,Integer>e:map.entrySet()){\\n            if(e.getValue()>1){\\n                a.add(e.getKey());\\n            }\\n        }\\n        return a;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864882,
                "title": "repeated-dna-sequences",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        map<string , int>mp;\\n        vector<string>ans;\\n        int n=s.size();\\n        if(n<10) return ans;\\n        for(int i=0; i<=abs(10-n); i++){\\n                string str=s.substr(i,10);\\n                // cout<<str<<endl;\\n                mp[str]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second>1) ans.push_back(x.first);\\n        } return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        map<string , int>mp;\\n        vector<string>ans;\\n        int n=s.size();\\n        if(n<10) return ans;\\n        for(int i=0; i<=abs(10-n); i++){\\n                string str=s.substr(i,10);\\n                // cout<<str<<endl;\\n                mp[str]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second>1) ans.push_back(x.first);\\n        } return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2613889,
                "title": "python3-fastest-and-easiest-sliding-window",
                "content": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        seen,res=set(),set()\\n        for l in range(len(s)-9) :\\n            cur=s[l:l+10]\\n            if cur in seen :\\n                res.add(cur)\\n            seen.add(cur)\\n        return list(res)\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        seen,res=set(),set()\\n        for l in range(len(s)-9) :\\n            cur=s[l:l+10]\\n            if cur in seen :\\n                res.add(cur)\\n            seen.add(cur)\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507418,
                "title": "python-rabin-karp",
                "content": "Hey everyone, I found most solution in discussion used s[i:i+10]. Auctuallt, it\\'s not good since substring will cost O(len(s)) time. It will make the whole solution takes O(n^2) complexity. The right way is Rabin-karp. Here is my code:\\n```\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        res = {}\\n        rst = []\\n        value = 0\\n        dict_map = {\"A\":0,\"G\":1,\"C\":2, \"T\":3}\\n        for i in range(len(s)):\\n            if i < 9:\\n                value = 4 * value + dict_map[s[i]]\\n            elif i == 9:\\n                value = 4 * value + dict_map[s[i]]\\n                res[value] = s[:10]\\n            else:\\n                value = (value - dict_map[s[i-10]]*(4**9)) * 4 + dict_map[s[i]]\\n                if value in res:\\n                    rst.append(res[value])\\n                else:\\n                    res[value] = s[i-9:i+1]\\n        return list(set(rst))\\n```\\n\\nLook forward someone polish my code based on the Rabin-Karp idea.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        res = {}\\n        rst = []\\n        value = 0\\n        dict_map = {\"A\":0,\"G\":1,\"C\":2, \"T\":3}\\n        for i in range(len(s)):\\n            if i < 9:\\n                value = 4 * value + dict_map[s[i]]\\n            elif i == 9:\\n                value = 4 * value + dict_map[s[i]]\\n                res[value] = s[:10]\\n            else:\\n                value = (value - dict_map[s[i-10]]*(4**9)) * 4 + dict_map[s[i]]\\n                if value in res:\\n                    rst.append(res[value])\\n                else:\\n                    res[value] = s[i-9:i+1]\\n        return list(set(rst))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791437,
                "title": "explanation-in-easy-language",
                "content": "We are traversing through array for every possible string of length 10 and adding it in map.\\nIf count of the string becomes higher we push it into answer.\\n\\n![image](https://assets.leetcode.com/users/images/20bf2ceb-de0c-438a-9e53-be5b136be373_1645529552.8038292.jpeg)\\n\\n\\n```vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string,int> map;\\n        vector<string> ans;\\n        \\n        if(s.length() < 10) return ans;\\n        \\n        for(int i = 0 ; i < s.length() - 9; i++){\\n            string temp = s.substr(i ,10);\\n            map[temp]++;\\n        }\\n        \\n        for(auto[a,_] : map){\\n            if(map[a] >= 2) ans.push_back(a);\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n\\tHope You Like it! \\uD83D\\uDE03\\n\\t\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "We are traversing through array for every possible string of length 10 and adding it in map.\\nIf count of the string becomes higher we push it into answer.\\n\\n![image](https://assets.leetcode.com/users/images/20bf2ceb-de0c-438a-9e53-be5b136be373_1645529552.8038292.jpeg)\\n\\n\\n```vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string,int> map;\\n        vector<string> ans;\\n        \\n        if(s.length() < 10) return ans;\\n        \\n        for(int i = 0 ; i < s.length() - 9; i++){\\n            string temp = s.substr(i ,10);\\n            map[temp]++;\\n        }\\n        \\n        for(auto[a,_] : map){\\n            if(map[a] >= 2) ans.push_back(a);\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n\\tHope You Like it! \\uD83D\\uDE03\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1668034,
                "title": "c-sliding-window-hash-map-intuition-approach-discussed",
                "content": "**Intuition for sliding window** : \\n* The question is of string and we need to find substrings\\n* We need to find all the 10 letter long substrings that occur more than once, so we are also given window size k = 10.\\n* We have fixed size window k = 10\\n\\n**Approach**\\n* Create a unordered_map\\n* Find all the substrings of size 10 using sliding window algorithm and store them in the hash map.\\n* Then iterate through the map and find all the keys with value more than 1 and store them in ans vector.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> mp;  \\n        int i = 0 , j = 0;\\n        string word;\\n        \\n        while(j < s.size()) { // sliding window\\n            word += s[j]; \\n            if(j-i+1 < 10) j++;\\n            else {\\n                mp[word]++;\\n                word = word.substr(1);\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        vector<string> ans;\\n        for(auto i : mp) if(i.second > 1) ans.push_back(i.first);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> mp;  \\n        int i = 0 , j = 0;\\n        string word;\\n        \\n        while(j < s.size()) { // sliding window\\n            word += s[j]; \\n            if(j-i+1 < 10) j++;\\n            else {\\n                mp[word]++;\\n                word = word.substr(1);\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        vector<string> ans;\\n        for(auto i : mp) if(i.second > 1) ans.push_back(i.first);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244860,
                "title": "kotlin-hossein-hadi-zahra-ehsan-bad-solution",
                "content": "```\\n  \\n  fun findRepeatedDnaSequences(s: String): List<String> {\\n        var result = mutableListOf<String>()\\n        var map = mutableMapOf<String, Int>()\\n        \\n        s.forEachIndexed{idx,value->\\n            \\n            if(idx+10 <= s.length){\\n                val subString = s.substring(idx, idx+10)\\n                println( \"subString : \" + subString)\\n                  if(map[subString] != null){\\n                      println( \"Hossein    \" + subString)\\n                      if(!result.contains(subString))\\n                         result.add(subString)  \\n                  }else{\\n                      map[subString] = 1\\n                 }\\n            }\\n          \\n        }\\n        \\n        return result\\n    }``\\n```",
                "solutionTags": [],
                "code": "```\\n  \\n  fun findRepeatedDnaSequences(s: String): List<String> {\\n        var result = mutableListOf<String>()\\n        var map = mutableMapOf<String, Int>()\\n        \\n        s.forEachIndexed{idx,value->\\n            \\n            if(idx+10 <= s.length){\\n                val subString = s.substring(idx, idx+10)\\n                println( \"subString : \" + subString)\\n                  if(map[subString] != null){\\n                      println( \"Hossein    \" + subString)\\n                      if(!result.contains(subString))\\n                         result.add(subString)  \\n                  }else{\\n                      map[subString] = 1\\n                 }\\n            }\\n          \\n        }\\n        \\n        return result\\n    }``\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1068353,
                "title": "c-easy-and-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> m;\\n        vector<string> res;\\n        int stop = s.size() - 10;\\n        for (int i = 0; i <= stop; i++)\\n        {\\n            string subStr = s.substr(i, 10);\\n            if (m.find(subStr) == m.end())\\n            {\\n                m[subStr] = 0;\\n            }\\n            else if (0 == m[subStr])\\n            {\\n                m[subStr] = 1;\\n                res.push_back(subStr);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nif you like it please **upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> m;\\n        vector<string> res;\\n        int stop = s.size() - 10;\\n        for (int i = 0; i <= stop; i++)\\n        {\\n            string subStr = s.substr(i, 10);\\n            if (m.find(subStr) == m.end())\\n            {\\n                m[subStr] = 0;\\n            }\\n            else if (0 == m[subStr])\\n            {\\n                m[subStr] = 1;\\n                res.push_back(subStr);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907284,
                "title": "java-solution-very-very-simple-96-faster",
                "content": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        HashSet<String> all = new HashSet<>();\\n        HashSet<String> ans = new HashSet<>();\\n        for(int i=0;i+10<=s.length();i++){\\n            String x = s.substring(i , i+10);\\n            if(!all.add(x)){\\n                ans.add(x);\\n            }\\n        }\\n        List<String> a = new ArrayList<>(ans);\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        HashSet<String> all = new HashSet<>();\\n        HashSet<String> ans = new HashSet<>();\\n        for(int i=0;i+10<=s.length();i++){\\n            String x = s.substring(i , i+10);\\n            if(!all.add(x)){\\n                ans.add(x);\\n            }\\n        }\\n        List<String> a = new ArrayList<>(ans);\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899243,
                "title": "c-simple-hashmap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   vector<string> findRepeatedDnaSequences(string s) {        \\n       unordered_map<string,int> MP;\\n       vector<string> ret;        \\n       for(int i = 0; i < int(s.size()) - 9; ++i){\\n           string str=s.substr(i,10);\\n           if(MP[str]++ == 1 ) ret.push_back(str);\\n       }\\n       return ret;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n   vector<string> findRepeatedDnaSequences(string s) {        \\n        unordered_map<size_t,int> MP;\\n        hash<string> hash_fn; //Note: hash function template to map string to size_t\\n        vector<string> ret;        \\n        for(int i = 0; i < int(s.size()) - 9; ++i)\\n            if(MP[hash_fn(s.substr(i,10))]++ == 1 )\\n               ret.push_back(s.substr(i,10));\\n               \\n      return ret;\\n    }\\n};\\n//Note: what is hash function object class ?   http://www.cplusplus.com/reference/functional/hash/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<string> findRepeatedDnaSequences(string s) {        \\n       unordered_map<string,int> MP;\\n       vector<string> ret;        \\n       for(int i = 0; i < int(s.size()) - 9; ++i){\\n           string str=s.substr(i,10);\\n           if(MP[str]++ == 1 ) ret.push_back(str);\\n       }\\n       return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   vector<string> findRepeatedDnaSequences(string s) {        \\n        unordered_map<size_t,int> MP;\\n        hash<string> hash_fn; //Note: hash function template to map string to size_t\\n        vector<string> ret;        \\n        for(int i = 0; i < int(s.size()) - 9; ++i)\\n            if(MP[hash_fn(s.substr(i,10))]++ == 1 )\\n               ret.push_back(s.substr(i,10));\\n               \\n      return ret;\\n    }\\n};\\n//Note: what is hash function object class ?   http://www.cplusplus.com/reference/functional/hash/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898238,
                "title": "java-solution-with-two-hashsets-good",
                "content": "**If u liked my solution, please vote it up)**\\n\\n```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n\\t\\tSet<String> strings = new HashSet<>();\\n\\t\\tSet<String> result = new HashSet<>();\\n\\t\\tif (s== null || s.length()<=10){\\n\\t\\t\\treturn Collections.EMPTY_LIST;\\n\\t\\t}\\n\\t\\tfor (int i = 10, j=0; i <= s.length(); i++, j++)\\n\\t\\t{\\n\\t\\t\\tString str = s.substring(j,i);\\n\\t\\t\\tif (strings.contains(str)){\\n\\t\\t\\t\\tresult.add(str);\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tstrings.add(str);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn new ArrayList<>(result);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n\\t\\tSet<String> strings = new HashSet<>();\\n\\t\\tSet<String> result = new HashSet<>();\\n\\t\\tif (s== null || s.length()<=10){\\n\\t\\t\\treturn Collections.EMPTY_LIST;\\n\\t\\t}\\n\\t\\tfor (int i = 10, j=0; i <= s.length(); i++, j++)\\n\\t\\t{\\n\\t\\t\\tString str = s.substring(j,i);\\n\\t\\t\\tif (strings.contains(str)){\\n\\t\\t\\t\\tresult.add(str);\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tstrings.add(str);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn new ArrayList<>(result);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569960,
                "title": "c-bitmask-minimalizm",
                "content": "A 10-letter DNA sequence can be represented by 20 bits. Count occurrences for each sequence, report a duplicate when the count reaches 2. \\n```cpp\\nint m[0xFFFFF] = {};\\nvector<string> findRepeatedDnaSequences(string s) {\\n    vector<string> res;\\n    for (auto i = 0, hash = 0; i < s.size(); ++i) {\\n        auto n = s[i] == \\'A\\' ? 0 : s[i] == \\'C\\' ? 1 : s[i] == \\'G\\' ? 2 : 3;\\n        hash = (0xFFFFF & (hash << 2)) + n;\\n        if (i >= 9 && ++m[hash] == 2)\\n            res.push_back(s.substr(i - 9, 10));                \\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint m[0xFFFFF] = {};\\nvector<string> findRepeatedDnaSequences(string s) {\\n    vector<string> res;\\n    for (auto i = 0, hash = 0; i < s.size(); ++i) {\\n        auto n = s[i] == \\'A\\' ? 0 : s[i] == \\'C\\' ? 1 : s[i] == \\'G\\' ? 2 : 3;\\n        hash = (0xFFFFF & (hash << 2)) + n;\\n        if (i >= 9 && ++m[hash] == 2)\\n            res.push_back(s.substr(i - 9, 10));                \\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 377337,
                "title": "easy-peasy-python-comments-solution-using-bit",
                "content": "\\tdef findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        # let\\'s map each ATCG to some integer, so that I don\\'t end of saving 10 char in my map\\n        # A = 00\\n        # T = 01\\n        # C = 10\\n        # G = 11\\n\\t\\t\\n        res = []\\n        mp = {\"A\": 0, \"T\": 1, \"C\": 2, \"G\": 3}\\n        seen = {}\\n        ln = len(s)\\n        for i in range(ln-9):\\n            sequence = 0\\n            for j in range(i, i+10):\\n                sequence <<= 2\\n                sequence |= mp[s[j]]\\n            \\n            gt = seen.get(sequence, 0)\\n            if gt == 1:\\n                res.append(s[i:i+10])\\n                seen[sequence] = 2\\n            elif gt == 0:\\n                seen[sequence] = 1\\n                \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "\\tdef findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        # let\\'s map each ATCG to some integer, so that I don\\'t end of saving 10 char in my map\\n        # A = 00\\n        # T = 01\\n        # C = 10\\n        # G = 11\\n\\t\\t\\n        res = []\\n        mp = {\"A\": 0, \"T\": 1, \"C\": 2, \"G\": 3}\\n        seen = {}\\n        ln = len(s)\\n        for i in range(ln-9):\\n            sequence = 0\\n            for j in range(i, i+10):\\n                sequence <<= 2\\n                sequence |= mp[s[j]]\\n            \\n            gt = seen.get(sequence, 0)\\n            if gt == 1:\\n                res.append(s[i:i+10])\\n                seen[sequence] = 2\\n            elif gt == 0:\\n                seen[sequence] = 1\\n                \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 369994,
                "title": "c-hashmap-with-sliding-window",
                "content": "Not the fastest, but it works.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> seqs;\\n        if(s.empty() || s.length() < 10) {\\n            return seqs; \\n        }\\n        map<string, int> seq_count;\\n        /*\\n        AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\\n        0                      ^       ^\\n                     s.length() - 9 s.length() - 1\\n        */\\n        for(int i = 0; (i < s.length() - 9); i++) {\\n            seq_count[s.substr(i, 10)]++;\\n        }\\n        for(auto const& seq : seq_count) {\\n            if(seq.second > 1) {\\n                seqs.push_back(seq.first);\\n            }\\n        }\\n        return seqs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> seqs;\\n        if(s.empty() || s.length() < 10) {\\n            return seqs; \\n        }\\n        map<string, int> seq_count;\\n        /*\\n        AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\\n        0                      ^       ^\\n                     s.length() - 9 s.length() - 1\\n        */\\n        for(int i = 0; (i < s.length() - 9); i++) {\\n            seq_count[s.substr(i, 10)]++;\\n        }\\n        for(auto const& seq : seq_count) {\\n            if(seq.second > 1) {\\n                seqs.push_back(seq.first);\\n            }\\n        }\\n        return seqs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238469,
                "title": "python-solution-beat-97",
                "content": "```\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        seq = set()\\n        res = set()\\n        for i in range(len(s)-9):\\n            if s[i:i+10] in seq:\\n                res.add(s[i:i+10])\\n            else:\\n                seq.add(s[i:i+10])\\n        return list(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        seq = set()\\n        res = set()\\n        for i in range(len(s)-9):\\n            if s[i:i+10] in seq:\\n                res.add(s[i:i+10])\\n            else:\\n                seq.add(s[i:i+10])\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 53878,
                "title": "short-8-lines-c-o-n-solution",
                "content": "```\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string>res;\\n        unordered_map<string, int>m;\\n        for(int i = 0; i + 10 <= s.size(); i++){\\n            string seq = s.substr(i, 10);\\n            if(m[seq] == 1) res.push_back(seq);\\n            m[seq]++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string>res;\\n        unordered_map<string, int>m;\\n        for(int i = 0; i + 10 <= s.size(); i++){\\n            string seq = s.substr(i, 10);\\n            if(m[seq] == 1) res.push_back(seq);\\n            m[seq]++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53945,
                "title": "can-anybody-tell-me-why-they-use-bit",
                "content": "    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> map;\\n        vector<string> res;\\n        int n = s.size();\\n        for(int i=0; i<n-9;i++){\\n            string temp = s.substr(i, 10);\\n            if(map.find(temp) != map.end() && map[temp] == 1)\\n                res.push_back(temp);\\n            map[temp]++;\\n        }\\n        return res;\\n    }\\n\\nThe solution is accepted and it runs fast.I wonder why the most votes use bit to make it complex?\\nThanks.",
                "solutionTags": [],
                "code": "    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> map;\\n        vector<string> res;\\n        int n = s.size();\\n        for(int i=0; i<n-9;i++){\\n            string temp = s.substr(i, 10);\\n            if(map.find(temp) != map.end() && map[temp] == 1)\\n                res.push_back(temp);\\n            map[temp]++;\\n        }\\n        return res;\\n    }\\n\\nThe solution is accepted and it runs fast.I wonder why the most votes use bit to make it complex?\\nThanks.",
                "codeTag": "Unknown"
            },
            {
                "id": 53963,
                "title": "easy-o-n-c-sol-without-bit-operations-in-12-lines",
                "content": "class Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        \\n        vector<string> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(s.length()<10)\\n        return ans;     \\n\\n        for(int i=0;i<s.length()-9;i++)\\n        {\\n            mp[s.substr(i,10)]++;   \\n        }\\n        \\n        for(int i=0;i<s.length()-9;i++)\\n        {\\n            //checking for frequency of substring\\n            if(mp.find(s.substr(i,10))->second>1)\\n            {\\n                ans.push_back(s.substr(i,10));\\n                mp[s.substr(i,10)]=0;\\n            }\\n        }\\n        return ans;    \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        \\n        vector<string> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(s.length()<10)\\n        return ans;     \\n\\n        for(int i=0;i<s.length()-9;i++)\\n        {\\n            mp[s.substr(i,10)]++;   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 53927,
                "title": "8ms-of-java-solution",
                "content": "In my solution,I use 2 bit to represent A(0), C(1), G(2), T(3), So a DNA sequence of 10 letters would take up 20 bits , which could be represented by an integer in range [0, 0xFFFFF]\\n\\nAccording to this , i pre-allocate an array of (0xFFFFF/64 = 16384 )  longs , and use bitset method to mark and search recurrence of DNA sequence.\\n\\nHere is my implementation\\n\\n **(If anyone has better idea or implementation,please don't hesitate to share it !)**\\n\\n    public class Solution {\\n        private static final byte[]TIDE_VALUE = new byte[26];\\n        static{\\n            TIDE_VALUE['A'-'A'] = 0;\\n            TIDE_VALUE['C'-'A'] = 1;\\n            TIDE_VALUE['G'-'A'] = 2;\\n            TIDE_VALUE['T'-'A'] = 3;\\n        }\\n         //for fast cleanup of other mark array\\n        private static final long[]dummyMrk = new long[16384]; \\n        // mark recurrence of DNA sequence in molecule\\n        private static final long[]mrk = new long[16384];    \\n        // mark if DNA sequence has been added before\\n        private static final long[]addMrk = new long[16384];  \\n\\n        public List<String> findRepeatedDnaSequences(String s) {\\n            ArrayList<String>dupSeqs = new ArrayList<String>();\\n         \\n            if(s.length()>=10){\\n                //String.charAt will be slower than char array access \\n                char[]sChars = s.toCharArray();  \\n                int i=0, dnaSeqRep=0, pos=0;\\n                System.arraycopy(dummyMrk,0,mrk,0,dummyMrk.length);  // clear up mark\\n                System.arraycopy(dummyMrk,0,addMrk,0,dummyMrk.length); // clear up mark\\n                for(;i<10;i++){\\n                    pos = i<<1;\\n                    dnaSeqRep |= TIDE_VALUE[sChars[i]-'A']<<pos;\\n                }\\n                mrk[dnaSeqRep>>6] |= 1L<<(dnaSeqRep&0x3f);\\n                for(;i<sChars.length;i++){\\n                    dnaSeqRep >>= 2;\\n                    dnaSeqRep |= TIDE_VALUE[sChars[i]-'A']<<pos;\\n                    int idx = (dnaSeqRep>>6);\\n                    long bitRep = 1L<<(dnaSeqRep&0x3f);\\n                    //if the sequence has a duplicate and haven't been added before\\n                    if((mrk[idx]&bitRep)!=0 ){\\n                        if((addMrk[idx]&bitRep)==0 ){\\n                            addMrk[idx] |= bitRep;\\n                            dupSeqs.add(s.substring(i-9,i+1)); \\n                        }\\n                    }else{\\n                        mrk[idx] |= bitRep;\\n                    }\\n                }\\n            }\\n            return dupSeqs;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        private static final byte[]TIDE_VALUE = new byte[26];\\n        static{\\n            TIDE_VALUE['A'-'A'] = 0;\\n            TIDE_VALUE['C'-'A'] = 1;\\n            TIDE_VALUE['G'-'A'] = 2;\\n            TIDE_VALUE['T'-'A'] = 3;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54028,
                "title": "an-c-based-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<string> findRepeatedDnaSequences(string s) {\\n            vector<string> res;\\n            if (s.size() <= 10) \\n                return res;\\n                \\n            int mask = 0x3ffff;// \\u7528\\u4e8e\\u53d6\\u4e00\\u4e2aint\\u6570\\u7684\\u4f4e18\\u4f4d\\n            int map[1024*1024] = {0};\\n            \\n            unsigned int cur = 0, i = 0;\\n            \\n            while (i < 9)// \\u53d618\\u4f4d\\n            {\\n                switch(s[i])\\n                {\\n                    case 'A':\\n                        cur = (cur << 2) | 0;\\n                        break;\\n                    case 'C':\\n                        cur = (cur << 2) | 1;\\n                        break;\\n                    case 'G':\\n                        cur = (cur << 2) | 2;\\n                        break;\\n                    case 'T':\\n                        cur = (cur << 2) | 3;\\n                        break;\\n                }\\n                i++;\\n            }\\n            \\n            while (i < s.size()) \\n            {\\n                switch(s[i])\\n                {\\n                    case 'A':\\n                        cur = ((cur & mask) << 2) | 0;// \\u53d6\\u539f\\u6765\\u5b57\\u7b26\\u768418\\u4f4d\\u540e\\u518d\\u63a5\\u4e0a\\u65b0\\u5b57\\u7b26\\u7684\\u4f4e2\\u4f4d\\n                        break;\\n                    case 'C':\\n                        cur = ((cur & mask) << 2) | 1;\\n                        break;\\n                    case 'G':\\n                        cur = ((cur & mask) << 2) | 2;\\n                        break;\\n                    case 'T':\\n                        cur = ((cur & mask) << 2) | 3;\\n                        break;\\n                }\\n                i++;\\n                map[cur] ++; \\n                \\n                if(map[cur] == 2)\\n                    res.push_back(s.substr(i - 10, 10));\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> findRepeatedDnaSequences(string s) {\\n            vector<string> res;\\n            if (s.size() <= 10) \\n                return res;\\n                \\n            int mask = 0x3ffff;// \\u7528\\u4e8e\\u53d6\\u4e00\\u4e2aint\\u6570\\u7684\\u4f4e18\\u4f4d\\n            int map[1024*1024] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 54029,
                "title": "10-line-c-solution-o-n-by-building-your-own-hash-code-clear-and-straightforward",
                "content": "    public IList<string> FindRepeatedDnaSequences(string s){\\n        HashSet<int> hist = new HashSet<int>();\\n        HashSet<string> resultSet = new HashSet<string>();\\n        for (int i = 0, hash = 0, mask = (1 << 18) - 1; i < s.Length; i++){   \\n            if(i > 9) hash &= mask;\\n            hash = (hash << 2) | (s[i] == 'A' ? 0 : s[i] == 'C' ? 1 : s[i] == 'G' ? 2 : 3);\\n            if(i < 9) continue;\\n            if (!hist.Contains(hash)) hist.Add(hash);\\n            else resultSet.Add(s.Substring(i - 9, 10));\\n        }\\n        return resultSet.ToList();\\n    }\\n\\nA straightforward solution easier to understand but not optimized.\\n\\n    public IList<string> FindRepeatedDnaSequences(string s){\\n        HashSet<int> hist = new HashSet<int>();\\n        HashSet<string> resultSet = new HashSet<string>();\\n        for (int i = 0; i < s.Length - 9; i++){\\n            int hash = getMyHash(s.Substring(i, 10));\\n            if (!hist.Contains(hash)) hist.Add(hash);\\n            else resultSet.Add(s.Substring(i, 10));\\n        }\\n        return resultSet.ToList();\\n    }\\n    // You don't need write a brand new hash algorithm for all chars.\\n    // Need only for 4 DNA chars.\\n    private int getMyHash(string str){ //A 0, C 1, G 2, T 3\\n        int hash = 0;\\n        foreach (var s in str)\\n            hash = (hash << 2) | (s == 'A' ? 0 : s == 'C' ? 1 : s == 'G' ? 2 : 3);\\n        return hash;\\n    }",
                "solutionTags": [],
                "code": "    public IList<string> FindRepeatedDnaSequences(string s){\\n        HashSet<int> hist = new HashSet<int>();\\n        HashSet<string> resultSet = new HashSet<string>();\\n        for (int i = 0, hash = 0, mask = (1 << 18) - 1; i < s.Length; i++){   \\n            if(i > 9) hash &= mask;\\n            hash = (hash << 2) | (s[i] == 'A' ? 0 : s[i] == 'C' ? 1 : s[i] == 'G' ? 2 : 3);\\n            if(i < 9) continue;\\n            if (!hist.Contains(hash)) hist.Add(hash);\\n            else resultSet.Add(s.Substring(i - 9, 10));\\n        }\\n        return resultSet.ToList();\\n    }\\n\\nA straightforward solution easier to understand but not optimized.\\n\\n    public IList<string> FindRepeatedDnaSequences(string s){\\n        HashSet<int> hist = new HashSet<int>();\\n        HashSet<string> resultSet = new HashSet<string>();\\n        for (int i = 0; i < s.Length - 9; i++){\\n            int hash = getMyHash(s.Substring(i, 10));\\n            if (!hist.Contains(hash)) hist.Add(hash);\\n            else resultSet.Add(s.Substring(i, 10));\\n        }\\n        return resultSet.ToList();\\n    }\\n    // You don't need write a brand new hash algorithm for all chars.\\n    // Need only for 4 DNA chars.\\n    private int getMyHash(string str){ //A 0, C 1, G 2, T 3\\n        int hash = 0;\\n        foreach (var s in str)\\n            hash = (hash << 2) | (s == 'A' ? 0 : s == 'C' ? 1 : s == 'G' ? 2 : 3);\\n        return hash;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54077,
                "title": "my-solution-using-base-4-conversion",
                "content": "My initial solution was to do this by stuffing bits into an int32 and hashing the int. The int stuffing seemed a lot more work and I wanted to see if I could do it differently. This took about 300 ms, so it's not fast by any means, but it's easy to understand. \\n\\n\\n    unordered_map<char,int> um1 {{'A', 1}, {'C', 2}, {'G', 3}, {'T', 4}};\\n    \\n    int baseFour(string s) {   //Ex: AAAAAAAAAC -> 611669\\n        int num = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            num += pow(4, i) * um1[s[i]];\\n        }\\n        return num;\\n    }\\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<int,int> ht;\\n        vector<string> v1;\\n        for (int i = 0; i + 9 < s.size(); i++) {\\n            string str = s.substr(i, 10);\\n            int num = baseFour(str);\\n            \\n            if (ht[num] == -1) //already seen, dont need to add again\\n                continue;\\n            else if (ht[num] == 1) { //repeated sequence, add to vector, then clear\\n                v1.push_back(str);\\n                ht[num] = -1;\\n            }\\n            else    //have not seen sequence or only seen once\\n                ht[num]++;\\n        }\\n        return v1;\\n    }",
                "solutionTags": [],
                "code": "My initial solution was to do this by stuffing bits into an int32 and hashing the int. The int stuffing seemed a lot more work and I wanted to see if I could do it differently. This took about 300 ms, so it's not fast by any means, but it's easy to understand. \\n\\n\\n    unordered_map<char,int> um1 {{'A', 1}, {'C', 2}, {'G', 3}, {'T', 4}};\\n    \\n    int baseFour(string s) {   //Ex: AAAAAAAAAC -> 611669\\n        int num = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            num += pow(4, i) * um1[s[i]];\\n        }\\n        return num;\\n    }\\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<int,int> ht;\\n        vector<string> v1;\\n        for (int i = 0; i + 9 < s.size(); i++) {\\n            string str = s.substr(i, 10);\\n            int num = baseFour(str);\\n            \\n            if (ht[num] == -1) //already seen, dont need to add again\\n                continue;\\n            else if (ht[num] == 1) { //repeated sequence, add to vector, then clear\\n                v1.push_back(str);\\n                ht[num] = -1;\\n            }\\n            else    //have not seen sequence or only seen once\\n                ht[num]++;\\n        }\\n        return v1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3834579,
                "title": "o-n-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a hashset and search for repeated sequences (10-size substring). Add the repeated sequences to the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- set res = hash set to store the repeated sequences and avoid duplicates\\n- set seen = hash set to track the repeated sequences\\n- traverse the string. loop size - 9 times to keep index inbound\\n    - get sequence/substring of size 10\\n    - if the sequence is in the seen hashmap, it is a repeated sequence, add it to the result\\n    - add the sequence to the hashset\\n- return res as a list \\n\\n# Complexity\\n- Time complexity: O(string traversal * substring creation) \\u2192 O(n - k * k) \\u2192 O(n - 10 * 10) \\u2192 O(n)\\n    - iterations = n - k\\n    - substring size = k = 10\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(hashset + substring) \\u2192 O(n/10 substrings of size k + k) \\u2192 O(n/10 * 10 + 10) \\u2192 O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        res = set()\\n        seen = set()\\n        for i in range(len(s) - 9):\\n            seq = s[i:i+10]\\n            if seq in seen:\\n                res.add(seq)\\n            seen.add(seq)\\n        return list(res)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        res = set()\\n        seen = set()\\n        for i in range(len(s) - 9):\\n            seq = s[i:i+10]\\n            if seq in seen:\\n                res.add(seq)\\n            seen.add(seq)\\n        return list(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798415,
                "title": "easy-python3-sliding-window-hashmap-set-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        myMap = {}\\n        mySet = set()\\n\\n        for i in range(len(s) - 9):\\n            if s[i:i+10] in myMap:\\n                mySet.add(s[i:i+10])\\n            else:\\n                myMap[s[i:i+10]] = 1\\n        \\n        return mySet\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        myMap = {}\\n        mySet = set()\\n\\n        for i in range(len(s) - 9):\\n            if s[i:i+10] in myMap:\\n                mySet.add(s[i:i+10])\\n            else:\\n                myMap[s[i:i+10]] = 1\\n        \\n        return mySet\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716949,
                "title": "187-repeated-dna-sequences-java",
                "content": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        HashSet<String> set=new HashSet(),rep=new HashSet();\\n        for(int i=0;i<s.length()-9;i++)\\n        {\\n            String sub=s.substring(i,i+10);\\n            if(set.contains(sub))\\n                rep.add(sub);\\n            set.add(sub);\\n        }\\n        return new ArrayList(rep);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        HashSet<String> set=new HashSet(),rep=new HashSet();\\n        for(int i=0;i<s.length()-9;i++)\\n        {\\n            String sub=s.substring(i,i+10);\\n            if(set.contains(sub))\\n                rep.add(sub);\\n            set.add(sub);\\n        }\\n        return new ArrayList(rep);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533926,
                "title": "approach-2-brute-force-with-unordered-set",
                "content": "# Intuition\\ndid brute force with two hash sets \\n\\n# Approach\\nMy approach was to iterate through the array and store each substring in a unordered set and then checked whether temp is in set or not if its is i added it to another unordered set T .i did this so multiple values wont get added to the vector L in the end.In the end i iterated through the set T and stored the elements in a vector\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n vector<string> findRepeatedDnaSequences(string s) {\\n      vector<string> l;\\n      string temp;\\n      unordered_set <string> m,t;\\n      if(s.length()<10) return l;\\n      for(int i=0;i<s.length()-9;i++){\\n        temp=s.substr(i,10);\\n        if(m.find(temp)!=m.end()){\\n          t.insert(temp);\\n          \\n        }\\n        else{\\n          m.insert(temp);\\n        }\\n      }\\n      for(auto& i:t){\\n        l.push_back(i);\\n      }\\n      return l;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<string> findRepeatedDnaSequences(string s) {\\n      vector<string> l;\\n      string temp;\\n      unordered_set <string> m,t;\\n      if(s.length()<10) return l;\\n      for(int i=0;i<s.length()-9;i++){\\n        temp=s.substr(i,10);\\n        if(m.find(temp)!=m.end()){\\n          t.insert(temp);\\n          \\n        }\\n        else{\\n          m.insert(temp);\\n        }\\n      }\\n      for(auto& i:t){\\n        l.push_back(i);\\n      }\\n      return l;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490342,
                "title": "c-solution-maps-sets",
                "content": "## MAPS\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        map<string,int> mp;\\n        if (s.size()<10)return {};\\n        string t;\\n        for (int i=0; i<10; i++)t+=s[i];\\n        mp[t]++;\\n        for (int i=10; i<s.size(); i++){\\n            t.erase(t.begin());\\n            t.push_back(s[i]);\\n            mp[t]++;\\n        }\\n        vector<string> ans;\\n        for (auto vl: mp){\\n            if (vl.second>1)ans.push_back(vl.first);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## SETS\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> ans;\\n        set<string> st;\\n        string t;\\n        for (int i=0; i<10; i++)t+=s[i];\\n        st.insert(t);\\n        for (int i=10; i<s.size(); i++){\\n            t.erase(t.begin());\\n            t+= s[i];\\n            if (st.find(t)!=st.end() && count(ans.begin(),ans.end(),t)==0){\\n                ans.push_back(t);\\n            }\\n            else{\\n                st.insert(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        map<string,int> mp;\\n        if (s.size()<10)return {};\\n        string t;\\n        for (int i=0; i<10; i++)t+=s[i];\\n        mp[t]++;\\n        for (int i=10; i<s.size(); i++){\\n            t.erase(t.begin());\\n            t.push_back(s[i]);\\n            mp[t]++;\\n        }\\n        vector<string> ans;\\n        for (auto vl: mp){\\n            if (vl.second>1)ans.push_back(vl.first);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> ans;\\n        set<string> st;\\n        string t;\\n        for (int i=0; i<10; i++)t+=s[i];\\n        st.insert(t);\\n        for (int i=10; i<s.size(); i++){\\n            t.erase(t.begin());\\n            t+= s[i];\\n            if (st.find(t)!=st.end() && count(ans.begin(),ans.end(),t)==0){\\n                ans.push_back(t);\\n            }\\n            else{\\n                st.insert(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483896,
                "title": "c-sets-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(10*n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        set<string>s1, s2;\\n        vector<string>ans;\\n        if(s.size()<10){return ans;}\\n        for(int i=0; i<=s.size()-10; i++){\\n            string st=\"\";\\n            for(int j=0; j<10; j++){\\n                st+=s[i+j];\\n            }\\n            if(s1.find(st)!=s1.end()){\\n                s2.insert(st);\\n            }\\n            s1.insert(st);\\n        }\\n        for(auto it: s2){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        set<string>s1, s2;\\n        vector<string>ans;\\n        if(s.size()<10){return ans;}\\n        for(int i=0; i<=s.size()-10; i++){\\n            string st=\"\";\\n            for(int j=0; j<10; j++){\\n                st+=s[i+j];\\n            }\\n            if(s1.find(st)!=s1.end()){\\n                s2.insert(st);\\n            }\\n            s1.insert(st);\\n        }\\n        for(auto it: s2){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432170,
                "title": "easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        lst=[]\\n        set1=set()\\n        for i in range(0,len(s)-9):\\n            tmp=s[i:i+10]\\n            if tmp not in set1:\\n                set1.add(tmp)\\n            else:\\n                lst.append(tmp)\\n        return list(set(lst))\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Rolling Hash",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        lst=[]\\n        set1=set()\\n        for i in range(0,len(s)-9):\\n            tmp=s[i:i+10]\\n            if tmp not in set1:\\n                set1.add(tmp)\\n            else:\\n                lst.append(tmp)\\n        return list(set(lst))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336379,
                "title": "simple-python-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        l=[]\\n        seen=set()\\n        dna=\\'\\'\\n        if len(s)>=10:\\n            for i in range(len(s)):\\n                dna=s[i:i+10]\\n                if dna in seen:\\n                    if dna not in l:\\n                        l.append(dna)\\n                seen.add(dna)\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        l=[]\\n        seen=set()\\n        dna=\\'\\'\\n        if len(s)>=10:\\n            for i in range(len(s)):\\n                dna=s[i:i+10]\\n                if dna in seen:\\n                    if dna not in l:\\n                        l.append(dna)\\n                seen.add(dna)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272494,
                "title": "simple-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        visited = {}\\n        res = []\\n        for i in range(len(s) - 9):\\n            sequence = s[i:i+10]\\n            if sequence in visited:\\n                if not visited[sequence]:\\n                    visited[sequence] = True\\n                    res.append(sequence)\\n            else:\\n                visited[sequence] = False \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        visited = {}\\n        res = []\\n        for i in range(len(s) - 9):\\n            sequence = s[i:i+10]\\n            if sequence in visited:\\n                if not visited[sequence]:\\n                    visited[sequence] = True\\n                    res.append(sequence)\\n            else:\\n                visited[sequence] = False \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172812,
                "title": "java-easy-to-understand-upvote",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        int a = 10;\\n        List<String> ans = new ArrayList<>();\\n        HashMap<String,Integer> hsmap = new HashMap<>();\\n        if(s.length()<10) return ans;\\n        for(int i=0;i<=s.length()-10;i++){\\n            int j=i+10;\\n            String str = s.substring(i,j);\\n            hsmap.put(str,hsmap.getOrDefault(str,0)+1);\\n        }\\n        for(Map.Entry<String,Integer> it : hsmap.entrySet()){\\n            if(it.getValue()>1){\\n                ans.add(it.getKey());\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        int a = 10;\\n        List<String> ans = new ArrayList<>();\\n        HashMap<String,Integer> hsmap = new HashMap<>();\\n        if(s.length()<10) return ans;\\n        for(int i=0;i<=s.length()-10;i++){\\n            int j=i+10;\\n            String str = s.substring(i,j);\\n            hsmap.put(str,hsmap.getOrDefault(str,0)+1);\\n        }\\n        for(Map.Entry<String,Integer> it : hsmap.entrySet()){\\n            if(it.getValue()>1){\\n                ans.add(it.getKey());\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093470,
                "title": "python-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        res=set()\\n        seen=set()\\n        for i in range(len(s)-9):\\n            curr=s[i:i+10]\\n            if curr in seen:\\n                res.add(curr)\\n            seen.add(curr)\\n        return list(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        res=set()\\n        seen=set()\\n        for i in range(len(s)-9):\\n            curr=s[i:i+10]\\n            if curr in seen:\\n                res.add(curr)\\n            seen.add(curr)\\n        return list(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090012,
                "title": "using-hasmap-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar findRepeatedDnaSequences = function(s) {\\n  let map = new Map();\\n  let result = [];\\n  for (let i = 0; i <= s.length - 10; i++) {\\n      let substring = s.substring(i, i + 10);\\n      if (map.has(substring)) {\\n          if(map.get(substring) === 1){\\n              result.push(substring);\\n          }\\n          map.set(substring, map.get(substring) + 1);\\n      } else {\\n          map.set(substring, 1);\\n      }\\n  }\\n  return result;\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar findRepeatedDnaSequences = function(s) {\\n  let map = new Map();\\n  let result = [];\\n  for (let i = 0; i <= s.length - 10; i++) {\\n      let substring = s.substring(i, i + 10);\\n      if (map.has(substring)) {\\n          if(map.get(substring) === 1){\\n              result.push(substring);\\n          }\\n          map.set(substring, map.get(substring) + 1);\\n      } else {\\n          map.set(substring, 1);\\n      }\\n  }\\n  return result;\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2997796,
                "title": "c-sliding-window-approach-faster-than-90",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string,int> mp;\\n        int n=s.size();\\n        for(int i=0;i<=n-10;i++){\\n            string str=s.substr(i,10);\\n            mp[str]++;\\n        }\\n        vector<string> ans;\\n        for(auto &x:mp){\\n            if(x.second>1){\\n                ans.push_back(x.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string,int> mp;\\n        int n=s.size();\\n        for(int i=0;i<=n-10;i++){\\n            string str=s.substr(i,10);\\n            mp[str]++;\\n        }\\n        vector<string> ans;\\n        for(auto &x:mp){\\n            if(x.second>1){\\n                ans.push_back(x.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921653,
                "title": "my-accepted-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n\\n        map<string ,int>mp;\\n          string x=\"\";\\n\\n         vector<string>ans;\\n        for(int i =0 ;i < s.size() ; i++)\\n        {\\n            x+=s[i];\\n\\n            if(x.size()==10)\\n            {\\n                if(mp[x]==1)\\n                     ans.push_back(x);\\n                     mp[x]++;\\n              x=x.substr(1,x.size());\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n\\n        map<string ,int>mp;\\n          string x=\"\";\\n\\n         vector<string>ans;\\n        for(int i =0 ;i < s.size() ; i++)\\n        {\\n            x+=s[i];\\n\\n            if(x.size()==10)\\n            {\\n                if(mp[x]==1)\\n                     ans.push_back(x);\\n                     mp[x]++;\\n              x=x.substr(1,x.size());\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893562,
                "title": "2-java-solution-from-brute-force-to-o-n-using-2-sets",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\none naive apporach comes to mind is to try for every possible substrings of length 10 and check if it is repeating. and add it to the answer set. Will give TLE o(n2)\\n\\nBetter Approach can be to use two set. 1 for seen elements and if this seen set found same substring again we will add it to repeating set. o(n)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n\\n//approach 1\\n```\\n    public List<String> findRepeatedDnaSequences1(String s) {\\n\\t\\tSet<String> res = new HashSet<>();\\n\\t\\tfor (int j = 0; j < s.length() - 10; j++) {\\n\\t\\t\\tString in = s.substring(j, j + 10);\\n\\t\\t\\tfor (int i = j + 1; i <= s.length() - 10; i++) {\\n\\t\\t\\t\\tif (in.equals(s.substring(i, i + 10))) {\\n\\t\\t\\t\\t\\tres.add(in);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn new ArrayList<>(res);\\n\\t}\\n```\\n//approach 2\\n```\\n    public List<String> findRepeatedDnaSequences(String s) {\\n\\t\\tSet<String> repeated = new HashSet<>();\\n\\t\\tSet<String> seen = new HashSet<>();\\n\\t\\tfor (int i = 0; i <= s.length() - 10; i++) {\\n\\t\\t\\tString seq = s.substring(i, i + 10);\\n\\t\\t\\tif (!seen.add(seq)) {\\n\\t\\t\\t\\trepeated.add(seq);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn new ArrayList<>(repeated);\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<String> findRepeatedDnaSequences1(String s) {\\n\\t\\tSet<String> res = new HashSet<>();\\n\\t\\tfor (int j = 0; j < s.length() - 10; j++) {\\n\\t\\t\\tString in = s.substring(j, j + 10);\\n\\t\\t\\tfor (int i = j + 1; i <= s.length() - 10; i++) {\\n\\t\\t\\t\\tif (in.equals(s.substring(i, i + 10))) {\\n\\t\\t\\t\\t\\tres.add(in);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn new ArrayList<>(res);\\n\\t}\\n```\n```\\n    public List<String> findRepeatedDnaSequences(String s) {\\n\\t\\tSet<String> repeated = new HashSet<>();\\n\\t\\tSet<String> seen = new HashSet<>();\\n\\t\\tfor (int i = 0; i <= s.length() - 10; i++) {\\n\\t\\t\\tString seq = s.substring(i, i + 10);\\n\\t\\t\\tif (!seen.add(seq)) {\\n\\t\\t\\t\\trepeated.add(seq);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn new ArrayList<>(repeated);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2802681,
                "title": "java-hashmap-sliding-window-easy",
                "content": "### **Please Upvote** :D\\nWe create a frequency map of all possible 10-letter substrings from the given string.\\nIf a subtring has a count more than 1 in the map, we add it to our ans arraylist.\\n```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> ans = new ArrayList<>();\\n        if (s.length() <= 10) return ans;\\n\\n        Map<String, Integer> map = new HashMap<>();\\n\\n        int i = 0, j = 10;\\n\\n        while (j <= s.length()) {\\n            String subStr = s.substring(i++, j++);\\n            map.put(subStr, map.getOrDefault(subStr, 0) + 1);\\n\\n            if (map.get(subStr) > 1 && !ans.contains(subStr)) {\\n                ans.add(subStr);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n * 10) => O(n)\\n// SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> ans = new ArrayList<>();\\n        if (s.length() <= 10) return ans;\\n\\n        Map<String, Integer> map = new HashMap<>();\\n\\n        int i = 0, j = 10;\\n\\n        while (j <= s.length()) {\\n            String subStr = s.substring(i++, j++);\\n            map.put(subStr, map.getOrDefault(subStr, 0) + 1);\\n\\n            if (map.get(subStr) > 1 && !ans.contains(subStr)) {\\n                ans.add(subStr);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n * 10) => O(n)\\n// SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799565,
                "title": "short-easy-fast-kotlin-solution",
                "content": "# Intuition\\nThe question is of type sliding window where hash hmap will be required to store strings as keys and thier occurence count as value.\\n# Approach\\ncreate an hashmap, run loop in string and add values to hashmap by finding substrings of size 10.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    fun findRepeatedDnaSequences(s: String): List<String> {\\n        \\n        if(s.length < 10) return listOf()\\n        \\n        var hashMap = mutableMapOf<String, Int>()\\n        var list: MutableList<String> = mutableListOf()\\n\\n        for(i in 0..s.length - 10)\\n        {\\n            val n = hashMap.get(s.substring(i, i+10)) ?: 0\\n            hashMap[s.substring(i, i+10)] = n + 1\\n        }\\n\\n        hashMap.forEach{ entry -> if(entry.value>1) list.add(entry.key)}\\n\\n        return list\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findRepeatedDnaSequences(s: String): List<String> {\\n        \\n        if(s.length < 10) return listOf()\\n        \\n        var hashMap = mutableMapOf<String, Int>()\\n        var list: MutableList<String> = mutableListOf()\\n\\n        for(i in 0..s.length - 10)\\n        {\\n            val n = hashMap.get(s.substring(i, i+10)) ?: 0\\n            hashMap[s.substring(i, i+10)] = n + 1\\n        }\\n\\n        hashMap.forEach{ entry -> if(entry.value>1) list.add(entry.key)}\\n\\n        return list\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749210,
                "title": "sliding-window-hashmap-set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string,int>mp;\\n        vector<string>ans;\\n        int n = s.size();\\n        if(n<=10){\\n            return ans;\\n        }\\n        for(int i=0; i<=n-10;i++){\\n            string str = s.substr(i ,10);\\n            mp[str]++;\\n        }\\n        for(auto itr=mp.begin();itr!=mp.end(); itr++){\\n            if(itr->second>1){\\n                ans.push_back(itr->first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE IF YOU LIKE THE SOLUTION**",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string,int>mp;\\n        vector<string>ans;\\n        int n = s.size();\\n        if(n<=10){\\n            return ans;\\n        }\\n        for(int i=0; i<=n-10;i++){\\n            string str = s.substr(i ,10);\\n            mp[str]++;\\n        }\\n        for(auto itr=mp.begin();itr!=mp.end(); itr++){\\n            if(itr->second>1){\\n                ans.push_back(itr->first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699987,
                "title": "c-python-concise-sliding-window",
                "content": "# Python\\n```\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        m = {}\\n        for i in range(len(s)):\\n            m[s[i : i + 10]] = 1 + m.get(s[i : i + 10], 0)\\n        return [key for key, value in m.items() if value > 1]     \\n\\n```\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> m;\\n        for(int i=0; i<s.size(); i++) m[s.substr(i, 10)]++;\\n    \\n        vector<string> ans;\\n        for(auto i : m) {\\n            if(i.second > 1) ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        m = {}\\n        for i in range(len(s)):\\n            m[s[i : i + 10]] = 1 + m.get(s[i : i + 10], 0)\\n        return [key for key, value in m.items() if value > 1]     \\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> m;\\n        for(int i=0; i<s.size(); i++) m[s.substr(i, 10)]++;\\n    \\n        vector<string> ans;\\n        for(auto i : m) {\\n            if(i.second > 1) ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659680,
                "title": "easy-solution-t-n-o-n-s-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string,int> mp;\\n        vector<string> ans;\\n        if(s.size()<=10) return ans;\\n        \\n        for(int i=0;i+10<=s.size();i++){\\n            mp[s.substr(i,10)]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second>1){\\n                ans.push_back(x.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string,int> mp;\\n        vector<string> ans;\\n        if(s.size()<=10) return ans;\\n        \\n        for(int i=0;i+10<=s.size();i++){\\n            mp[s.substr(i,10)]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second>1){\\n                ans.push_back(x.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550006,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string str) {\\n        \\n        int n = str.size();\\n        \\n        // store the frequency of the DNA sequence\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find DNA sequence of length 10\\n            \\n            int j = i;\\n            \\n            string DNA = \"\";\\n            \\n            while(j < n && DNA.size() < 10)\\n            {\\n                DNA += str[j];\\n                \\n                j++;\\n            }\\n            \\n            // push the sequence into map\\n            \\n            mp[DNA]++;\\n        }\\n        \\n        vector<string> res;\\n        \\n        for(auto x : mp)\\n        {\\n            if(x.second > 1)\\n            {\\n                res.push_back(x.first);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string str) {\\n        \\n        int n = str.size();\\n        \\n        // store the frequency of the DNA sequence\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find DNA sequence of length 10\\n            \\n            int j = i;\\n            \\n            string DNA = \"\";\\n            \\n            while(j < n && DNA.size() < 10)\\n            {\\n                DNA += str[j];\\n                \\n                j++;\\n            }\\n            \\n            // push the sequence into map\\n            \\n            mp[DNA]++;\\n        }\\n        \\n        vector<string> res;\\n        \\n        for(auto x : mp)\\n        {\\n            if(x.second > 1)\\n            {\\n                res.push_back(x.first);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382844,
                "title": "simple-c-o-n-easy-to-understand",
                "content": "\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<string> findRepeatedDnaSequences(string s) {\\n\\t\\t\\t\\tunordered_map<string,int> freq;\\n\\t\\t\\t\\tint start = 0 , end = 9;\\n\\t\\t\\t\\twhile(end < s.size()){\\n\\t\\t\\t\\t\\tbool flag = true;\\n\\t\\t\\t\\t\\tfor(int i = start ; i <= end ; i++){\\n\\t\\t\\t\\t\\t\\tif(s[i] == \\'A\\' or s[i] == \\'C\\' or s[i] == \\'G\\' or s[i] == \\'T\\') continue;\\n\\t\\t\\t\\t\\t\\telse {flag = false ; break ;}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(flag){\\n\\t\\t\\t\\t\\t\\tstring temp = s.substr(start , 10);\\n\\t\\t\\t\\t\\t\\tfreq[temp]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstart++;\\n\\t\\t\\t\\t\\tend++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvector<string> ans;\\n\\t\\t\\t\\tfor(auto it : freq){\\n\\t\\t\\t\\t\\tif(it.second >= 2) ans.push_back(it.first);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<string> findRepeatedDnaSequences(string s) {\\n\\t\\t\\t\\tunordered_map<string,int> freq;\\n\\t\\t\\t\\tint start = 0 , end = 9;\\n\\t\\t\\t\\twhile(end < s.size()){\\n\\t\\t\\t\\t\\tbool flag = true;\\n\\t\\t\\t\\t\\tfor(int i = start ; i <= end ; i++){\\n\\t\\t\\t\\t\\t\\tif(s[i] == \\'A\\' or s[i] == \\'C\\' or s[i] == \\'G\\' or s[i] == \\'T\\') continue;\\n\\t\\t\\t\\t\\t\\telse {flag = false ; break ;}",
                "codeTag": "Java"
            },
            {
                "id": 2288149,
                "title": "javascript-111ms-84-17",
                "content": "```\\n// 187. Repeated DNA Sequences\\nvar findRepeatedDnaSequences = function(s) {\\n    let map = {};\\n\\tlet res = [];\\n\\tfor (let i = 0; i <= s.length-10; i++) {\\n\\t\\tlet s10 = s.substring(i, i+10);\\n\\t\\tmap[s10] = (map[s10] || 0) + 1;\\n\\t\\tif (map[s10] === 2) res.push(s10);\\n\\t}\\n\\treturn res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// 187. Repeated DNA Sequences\\nvar findRepeatedDnaSequences = function(s) {\\n    let map = {};\\n\\tlet res = [];\\n\\tfor (let i = 0; i <= s.length-10; i++) {\\n\\t\\tlet s10 = s.substring(i, i+10);\\n\\t\\tmap[s10] = (map[s10] || 0) + 1;\\n\\t\\tif (map[s10] === 2) res.push(s10);\\n\\t}\\n\\treturn res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2190920,
                "title": "memory-efficient-solution-using-2-set-set-and-filter-technique",
                "content": "Storing the strings take up less space than integers.\\nBases on this fact, I have stored only the strings of use in the set and no integer value. Thereby making the solution memory efficient.\\nStore the substrings of legth 10 in the set. If the substring is already inserted, then put it in the final set.\\n\\nFinally return the vector form of the final set.\\n\\nPlease **Upvote ^** if you like!\\n\\n```\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        int n = s.size();\\n        unordered_set<string> set, filter;\\n        \\n        string sub = \"\";\\n        for(int i = 0; i < n; i++){\\n            sub += s[i];\\n            if(sub.size() > 10)\\n                sub.erase(0, 1);\\n            \\n            if(set.insert(sub).second == false) // this will return false when the \"sub\" is already present in the \"set\"\\n                filter.insert(sub);\\n        }\\n        \\n        return vector<string>(begin(filter), end(filter));\\n    }\\n```\\n\\n![image](https://assets.leetcode.com/users/images/44df35b2-de77-434c-811f-612a5f193f05_1656066475.6846097.png)\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        int n = s.size();\\n        unordered_set<string> set, filter;\\n        \\n        string sub = \"\";\\n        for(int i = 0; i < n; i++){\\n            sub += s[i];\\n            if(sub.size() > 10)\\n                sub.erase(0, 1);\\n            \\n            if(set.insert(sub).second == false) // this will return false when the \"sub\" is already present in the \"set\"\\n                filter.insert(sub);\\n        }\\n        \\n        return vector<string>(begin(filter), end(filter));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2185016,
                "title": "c-95-faster-92-less-mem",
                "content": "This is basically Rabin karp algorithim. We roll over a given string ```s``` where we add and subtract a character\\'s hash. We always maintain a hash of a string of length 10 as asked in the question.\\n\\nWe then compute the hash of this string while we move along the ```s``` string. This takes O(1) time as we substract the hash of very first character ```i - 1```and add the hash of the new character which we are adding ```i + 9``` with overflow checks such as ```%``` with a ***large prime number***. which then becomes the keys for our candidates set. Here if we find something again we push it to duplicates set. \\n\\nIn the code I do ```hash ... % p + p) %p;``` This is to take care of negative numbers. \\n\\nWe return a vector filled with everything from duplicates set.\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        if (s.size() < 10) return {};\\n        unordered_map<char, int> dna {{\\'A\\', 0}, {\\'C\\', 1}, {\\'G\\', 2}, {\\'T\\', 3}};\\n        unordered_set<int> candidates;\\n        unordered_set<string> duplicates;\\n        int pw = pow(4,9);\\n        int p = 10000007;\\n        int i = 0;\\n        int hash = 0;\\n        while (i < 10) {\\n            hash = (hash * 4 + dna[s[i]]) % p;\\n            ++i;\\n        }\\n        candidates.insert(hash);\\n        i = 1;\\n        while (i + 9 < s.size()) {\\n            hash = ((hash - pw * dna[s[i-1]] ) % p + p) % p;\\n            hash = ((hash * 4) + dna[s[i + 9]]) % p;\\n            if (candidates.find(hash) != candidates.end()) duplicates.insert(s.substr(i,10));\\n            else candidates.insert(hash);\\n            ++i;\\n        }\\n        return vector<string>(duplicates.begin(), duplicates.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```s```\n```s```\n```i - 1```\n```i + 9```\n```%```\n```hash ... % p + p) %p;```\n```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        if (s.size() < 10) return {};\\n        unordered_map<char, int> dna {{\\'A\\', 0}, {\\'C\\', 1}, {\\'G\\', 2}, {\\'T\\', 3}};\\n        unordered_set<int> candidates;\\n        unordered_set<string> duplicates;\\n        int pw = pow(4,9);\\n        int p = 10000007;\\n        int i = 0;\\n        int hash = 0;\\n        while (i < 10) {\\n            hash = (hash * 4 + dna[s[i]]) % p;\\n            ++i;\\n        }\\n        candidates.insert(hash);\\n        i = 1;\\n        while (i + 9 < s.size()) {\\n            hash = ((hash - pw * dna[s[i-1]] ) % p + p) % p;\\n            hash = ((hash * 4) + dna[s[i + 9]]) % p;\\n            if (candidates.find(hash) != candidates.end()) duplicates.insert(s.substr(i,10));\\n            else candidates.insert(hash);\\n            ++i;\\n        }\\n        return vector<string>(duplicates.begin(), duplicates.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015325,
                "title": "python-3-simple-hash-map-solution",
                "content": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        seen = {}\\n        res = []\\n        \\n        for i in range(len(s) - 9):\\n            sequence = s[i:i+10]\\n            if sequence in seen:\\n                if not seen[sequence]:\\n                    seen[sequence] = True\\n                    res.append(sequence)\\n            else:\\n                seen[sequence] = False\\n            \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "class Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        seen = {}",
                "codeTag": "Java"
            },
            {
                "id": 1962090,
                "title": "sliding-window-fixed-size-straightforward-java",
                "content": "```\\npublic List < String > findRepeatedDnaSequences(String s) {\\n        List < String > res = new ArrayList < > ();\\n        int n = s.length();\\n        if (s == null || n <= 10) return res;\\n        Set < String > set = new HashSet < > ();\\n        Set < String > vis = new HashSet < > ();\\n\\n        int i = 0, j = 10;\\n        while (j <= s.length()) {\\n            String str = s.substring(i, j);\\n            if (set.contains(str) && !vis.contains(str)) {\\n                res.add(str);\\n                vis.add(str);\\n            } else set.add(str);\\n            i++;\\n            j++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\npublic List < String > findRepeatedDnaSequences(String s) {\\n        List < String > res = new ArrayList < > ();\\n        int n = s.length();\\n        if (s == null || n <= 10) return res;\\n        Set < String > set = new HashSet < > ();\\n        Set < String > vis = new HashSet < > ();\\n\\n        int i = 0, j = 10;\\n        while (j <= s.length()) {\\n            String str = s.substring(i, j);\\n            if (set.contains(str) && !vis.contains(str)) {\\n                res.add(str);\\n                vis.add(str);\\n            } else set.add(str);\\n            i++;\\n            j++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1949162,
                "title": "beats-100-js-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar findRepeatedDnaSequences = function(s) {\\n    set = new Set()\\n    ans = new Set()\\n    if (s.length <= 10 || s.length > 10000) {\\n        return []\\n        }\\n    for (let i=0; i < s.length; i++){\\n        if(i+10 <= s.length) {\\n            str = s.substring(i,i+10)\\n            if (set.has(str)) {\\n                ans.add(str)\\n            }else set.add(str)\\n        }\\n    }\\n    return Array.from(ans)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar findRepeatedDnaSequences = function(s) {\\n    set = new Set()\\n    ans = new Set()\\n    if (s.length <= 10 || s.length > 10000) {\\n        return []\\n        }\\n    for (let i=0; i < s.length; i++){\\n        if(i+10 <= s.length) {\\n            str = s.substring(i,i+10)\\n            if (set.has(str)) {\\n                ans.add(str)\\n            }else set.add(str)\\n        }\\n    }\\n    return Array.from(ans)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1855147,
                "title": "c-explained-with-comments-o-n-time",
                "content": "```\\nvector<string> findRepeatedDnaSequences(string s) {\\n        \\n        // we are using hashsets as we just want to check if it has frequency > 1\\n        // as we only want to check for frequency > 1, we can just check if it\\'s already present or not\\n        // if it\\'s already there, just add it in result set\\n        \\n        unordered_set<string> visited, result;\\n        \\n        int n = s.length();\\n        \\n        for(int i = 0; i < n-9; ++i) {\\n            // taking the substring of length 10 (can say it\\'s a window of length 10)\\n            string sub = s.substr(i, 10);\\n            \\n            // if our visited set already has it, it means a duplicate that is frequency of that substring is > 1, just add it in result set\\n            if(visited.find(sub) != visited.end())\\n                result.insert(sub);\\n            // else just insert in that set\\n            else\\n                visited.insert(sub);\\n        }\\n        \\n        // making vector as we have to return it in this function\\n        vector<string> ans_arr;\\n        \\n        for(const string &s : result)\\n            ans_arr.push_back(s);\\n        \\n        return ans_arr;\\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nvector<string> findRepeatedDnaSequences(string s) {\\n        \\n        // we are using hashsets as we just want to check if it has frequency > 1\\n        // as we only want to check for frequency > 1, we can just check if it\\'s already present or not\\n        // if it\\'s already there, just add it in result set\\n        \\n        unordered_set<string> visited, result;\\n        \\n        int n = s.length();\\n        \\n        for(int i = 0; i < n-9; ++i) {\\n            // taking the substring of length 10 (can say it\\'s a window of length 10)\\n            string sub = s.substr(i, 10);\\n            \\n            // if our visited set already has it, it means a duplicate that is frequency of that substring is > 1, just add it in result set\\n            if(visited.find(sub) != visited.end())\\n                result.insert(sub);\\n            // else just insert in that set\\n            else\\n                visited.insert(sub);\\n        }\\n        \\n        // making vector as we have to return it in this function\\n        vector<string> ans_arr;\\n        \\n        for(const string &s : result)\\n            ans_arr.push_back(s);\\n        \\n        return ans_arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1832446,
                "title": "repeated-dna-sequences",
                "content": "class Solution \\n{\\n public:\\n    vector<string> findRepeatedDnaSequences(string s) \\n    {\\n         int n=s.length();\\n         set<string>v;\\n         map<string,int>mp;\\n         for(int i=0;i<=n-10;i++)\\n         {\\n             string st=s.substr(i,10);\\n             if(mp[st]>=1)\\n                v.insert(st);\\n             else\\n                 mp[st]++;\\n         }\\n         vector<string>res(v.begin(),v.end()); \\n         return res;\\n    }\\n};\\n\\n\\n\\n\\n// Simple approach pick a window of size k check is this window already present [Map[string]>1] then insert it, into set of string.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution \\n{\\n public:\\n    vector<string> findRepeatedDnaSequences(string s) \\n    {\\n         int n=s.length();\\n         set<string>v;\\n         map<string,int>mp;\\n         for(int i=0;i<=n-10;i++)\\n         {\\n             string st=s.substr(i,10);\\n             if(mp[st]>=1)\\n                v.insert(st);\\n             else\\n                 mp[st]++;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1780923,
                "title": "c-substring-with-map-85-faster",
                "content": "```\\nvector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string,int> maps;\\n        vector<string> ans;\\n        if(s.size()<10) return ans;\\n        for(int i=0;i<=s.size()-10;i++)\\n        {\\n            string sub = s.substr(i,10);\\n            maps[sub]++;\\n            if(maps[sub]==2)\\n                ans.push_back(sub);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string,int> maps;\\n        vector<string> ans;\\n        if(s.size()<10) return ans;\\n        for(int i=0;i<=s.size()-10;i++)\\n        {\\n            string sub = s.substr(i,10);\\n            maps[sub]++;\\n            if(maps[sub]==2)\\n                ans.push_back(sub);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778633,
                "title": "java-algorithm-approach-to-solve-in-seconds",
                "content": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s1) {\\n    HashMap<String , Integer> h1 = new HashMap<>();\\n        List<String> l1 = new ArrayList<>();\\n          //  String s1 = \"AAAAAAAAAAAAA\";\\n            for(int i =0;i<s1.length();i++)\\n            {      int j = i+10;\\n                if(i+10>s1.length())\\n                {\\n                    break;\\n                }\\n                String s = s1.substring(i,j);\\n                h1.put(s,h1.getOrDefault(s,0)+1);\\n            }\\n            for(String s : h1.keySet())\\n            {\\n                if(h1.get(s)>1)\\n                {\\n                   l1.add(s);\\n                }\\n            }\\n            return l1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s1) {\\n    HashMap<String , Integer> h1 = new HashMap<>();\\n        List<String> l1 = new ArrayList<>();\\n          //  String s1 = \"AAAAAAAAAAAAA\";\\n            for(int i =0;i<s1.length();i++)\\n            {      int j = i+10;\\n                if(i+10>s1.length())\\n                {\\n                    break;\\n                }\\n                String s = s1.substring(i,j);\\n                h1.put(s,h1.getOrDefault(s,0)+1);\\n            }\\n            for(String s : h1.keySet())\\n            {\\n                if(h1.get(s)>1)\\n                {\\n                   l1.add(s);\\n                }\\n            }\\n            return l1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707515,
                "title": "using-c-map-for-hashing-and-substring",
                "content": "```\\nvector<string> findRepeatedDnaSequences(string s) \\n    {\\n        vector<string>ans;\\n        int n=s.length();\\n        map<string,int>m;\\n        for(int i=0;i<=n-10;i++)\\n        {\\n            string sub=s.substr(i,10);\\n            m[sub]++;\\n        }\\n        for(auto it:m)\\n            if(it.second>1)\\n                ans.push_back(it.first);\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> findRepeatedDnaSequences(string s) \\n    {\\n        vector<string>ans;\\n        int n=s.length();\\n        map<string,int>m;\\n        for(int i=0;i<=n-10;i++)\\n        {\\n            string sub=s.substr(i,10);\\n            m[sub]++;\\n        }\\n        for(auto it:m)\\n            if(it.second>1)\\n                ans.push_back(it.first);\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1615529,
                "title": "python-99-12-faster-than-other-codes-using-hash",
                "content": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        dna= {}\\n        m=[]\\n        for i in range(len(s) -9):\\n            x=s[i:i+10]\\n            if x in dna:\\n                dna[x]=dna[x]+1\\n                m.append(x)\\n            else:\\n                dna[x]= 1 \\n        return(list(set(m)))\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        dna= {}\\n        m=[]\\n        for i in range(len(s) -9):\\n            x=s[i:i+10]\\n            if x in dna:\\n                dna[x]=dna[x]+1\\n                m.append(x)\\n            else:\\n                dna[x]= 1 \\n        return(list(set(m)))\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581978,
                "title": "py3-py-simple-solution-using-two-pointers-w-comments",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    \\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        \\n        # Init\\n        counter = defaultdict(int)\\n        left = 0\\n        \\n        # For each element in s\\n        for right, _ in enumerate(s):\\n            \\n            # if the lenght is equal to 10, add to\\n            # counter and increment left pointer\\n            if right - left + 1 == 10:\\n                counter[s[left:right+1]] += 1\\n                left += 1\\n        \\n        # List of all the keys which occurred more than 1 time\\n        return [k for k,v in counter.items() if v > 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    \\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        \\n        # Init\\n        counter = defaultdict(int)\\n        left = 0\\n        \\n        # For each element in s\\n        for right, _ in enumerate(s):\\n            \\n            # if the lenght is equal to 10, add to\\n            # counter and increment left pointer\\n            if right - left + 1 == 10:\\n                counter[s[left:right+1]] += 1\\n                left += 1\\n        \\n        # List of all the keys which occurred more than 1 time\\n        return [k for k,v in counter.items() if v > 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463576,
                "title": "java-hashmap-list",
                "content": "class Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        HashMap<String, Integer> map=new HashMap<>();\\n        List<String> list1=new LinkedList<>();\\n        \\n        for(int i=0;i<s.length()-10;i++){\\n            if(i+9<s.length()){\\n            String subStr=s.substring(i,i+10);\\n            map.put(subStr,map.getOrDefault(subStr,0)+1);                \\n            }\\n        }\\n        \\n        for(Map.Entry<String,Integer> entry:map.entrySet()){\\n            if(entry.getValue()>1){\\n                list1.add(entry.getKey());\\n        }\\n        }\\n        return list1;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        HashMap<String, Integer> map=new HashMap<>();\\n        List<String> list1=new LinkedList<>();\\n        \\n        for(int i=0;i<s.length()-10;i++){\\n            if(i+9<s.length()){\\n            String subStr=s.substring(i,i+10);\\n            map.put(subStr,map.getOrDefault(subStr,0)+1);                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1235126,
                "title": "java-hashsets",
                "content": "```\\nclass Solution {\\n    \\n    public List<String> findRepeatedDnaSequences(String s) {\\n        final Set<String> exists = new HashSet<>();\\n        final Set<String> result = new HashSet<>();\\n        int start = 0;\\n        int end = 10;\\n        \\n        while (end <= s.length()) {\\n            String seq = s.substring(start++, end++);\\n            if (!exists.add(seq)) result.add(seq);\\n        }\\n        \\n        return new ArrayList<>(result);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> findRepeatedDnaSequences(String s) {\\n        final Set<String> exists = new HashSet<>();\\n        final Set<String> result = new HashSet<>();\\n        int start = 0;\\n        int end = 10;\\n        \\n        while (end <= s.length()) {\\n            String seq = s.substring(start++, end++);\\n            if (!exists.add(seq)) result.add(seq);\\n        }\\n        \\n        return new ArrayList<>(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205598,
                "title": "java-hashmap",
                "content": "**HashMap to store substrings of DNA with 10 length**\\n*Question is what would be the complexity!!??*\\n\\n**Lets see the code first!**\\n```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        HashMap<String,Integer> hp=new HashMap<>();\\n        // hashmap to contains all substring of 10 length and frequency map\\n        for(int i=0;i+10<=s.length();i++){\\n            String temp=s.substring(i,i+10);\\n            hp.put(temp,hp.getOrDefault(temp,0)+1);\\n        }\\n        \\n        List<String> ans=new ArrayList<>();\\n        for(String ss:hp.keySet()){\\n            if(hp.get(ss)>1) ans.add(ss);\\n        }\\n        // traverse in map and string with greater freq can be stored\\n        return ans;\\n    }\\n}\\n```\\n**HashMap** operations are in average O(1)\\n**String traversal** well its O(n) where n is length of string!\\n**Substring(i)** its complexity is O(i) according to java 7\\'s new update (update 6).\\nWe are using i as 10 overall for every case, hence for best case it will be O(n).\\n\\ncorrect me if i am wrong!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        HashMap<String,Integer> hp=new HashMap<>();\\n        // hashmap to contains all substring of 10 length and frequency map\\n        for(int i=0;i+10<=s.length();i++){\\n            String temp=s.substring(i,i+10);\\n            hp.put(temp,hp.getOrDefault(temp,0)+1);\\n        }\\n        \\n        List<String> ans=new ArrayList<>();\\n        for(String ss:hp.keySet()){\\n            if(hp.get(ss)>1) ans.add(ss);\\n        }\\n        // traverse in map and string with greater freq can be stored\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082651,
                "title": "c-4ms-faster-than-100-and-top-97-for-memory",
                "content": "Using [homemade hash algorithm](https://github.com/agavrel/leetcode), I use the fact that A, C, G and T have a mask (0b00 to 0b11) embedded in their ASCII value, see below:\\n\\n```\\nclass Solution {\\npublic:\\n    void makeHash(int &hash, int letter) {\\n       // A 1 C 3 G 7 T 20 after & 0x3f, after >> 1 (middle + left), after &0b11 (middle) :\\n       // 0b00 00  1\\n       // 0b00 01  1\\n       // 0b00 11  1\\n       // 0b10 10  0\\n        int c = ((letter & 0x3f) >> 1)  & 0b11;\\n        hash &= 0b00111111111111111111; // avoid overflow\\n        hash = (hash << 2 | c); // add current letter information to value of the hash\\n    }\\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> res = {};\\n        if (s.size() <= 10)\\n            return res;\\n        int hashTable[1 << 20] = {0};\\n        int hash = 0;\\n        for (int i = 0; i < 10; i++)\\n            makeHash(hash, s[i]);\\n        hashTable[hash]++;\\n        for (int i = 10; i < s.size(); i++) {\\n            makeHash(hash, s[i]);\\n            if (hashTable[hash]++ == 1)\\n                res.push_back(s.substr(i - 9, 10));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void makeHash(int &hash, int letter) {\\n       // A 1 C 3 G 7 T 20 after & 0x3f, after >> 1 (middle + left), after &0b11 (middle) :\\n       // 0b00 00  1\\n       // 0b00 01  1\\n       // 0b00 11  1\\n       // 0b10 10  0\\n        int c = ((letter & 0x3f) >> 1)  & 0b11;\\n        hash &= 0b00111111111111111111; // avoid overflow\\n        hash = (hash << 2 | c); // add current letter information to value of the hash\\n    }\\n\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> res = {};\\n        if (s.size() <= 10)\\n            return res;\\n        int hashTable[1 << 20] = {0};\\n        int hash = 0;\\n        for (int i = 0; i < 10; i++)\\n            makeHash(hash, s[i]);\\n        hashTable[hash]++;\\n        for (int i = 10; i < s.size(); i++) {\\n            makeHash(hash, s[i]);\\n            if (hashTable[hash]++ == 1)\\n                res.push_back(s.substr(i - 9, 10));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919423,
                "title": "java-easy-maintain-count-of-all-possible-substrings",
                "content": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        if(s.length()<=10) return new ArrayList<>();\\n        \\n        int length = s.length();\\n        HashMap<String,Integer> map = new HashMap<>(); \\n        List<String> result = new ArrayList<>();\\n        \\n        for(int i=0; i+9<length; i++){\\n            String subString = s.substring(i,i+10);\\n            map.put(subString,map.getOrDefault(subString,0)+1);\\n        }\\n        \\n       for(String key : map.keySet()){\\n           if(map.get(key) > 1){\\n               result.add(key);\\n               map.put(key,0);\\n           }\\n       }\\n                   \\n        return result;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        if(s.length()<=10) return new ArrayList<>();\\n        \\n        int length = s.length();\\n        HashMap<String,Integer> map = new HashMap<>(); \\n        List<String> result = new ArrayList<>();\\n        \\n        for(int i=0; i+9<length; i++){\\n            String subString = s.substring(i,i+10);\\n            map.put(subString,map.getOrDefault(subString,0)+1);\\n        }\\n        \\n       for(String key : map.keySet()){\\n           if(map.get(key) > 1){\\n               result.add(key);\\n               map.put(key,0);\\n           }\\n       }\\n                   \\n        return result;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899889,
                "title": "java-easy-to-understand-uses-hashing",
                "content": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> result = new ArrayList<>();\\n        Map<String, Integer> freq = new HashMap();\\n        \\n        if(s.length() <= 10) return result;\\n        \\n        for(int i=0; i<=s.length()-10; i++) {\\n            String substring = s.substring(i, i+10);\\n            \\n            if(freq.containsKey(substring)) {\\n                freq.put(substring, freq.get(substring)+1);\\n                \\n                if(freq.get(substring) == 2 && !result.contains(substring)) result.add(substring);\\n            }\\n            else\\n                freq.put(substring, 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> result = new ArrayList<>();\\n        Map<String, Integer> freq = new HashMap();\\n        \\n        if(s.length() <= 10) return result;\\n        \\n        for(int i=0; i<=s.length()-10; i++) {\\n            String substring = s.substring(i, i+10);\\n            \\n            if(freq.containsKey(substring)) {\\n                freq.put(substring, freq.get(substring)+1);\\n                \\n                if(freq.get(substring) == 2 && !result.contains(substring)) result.add(substring);\\n            }\\n            else\\n                freq.put(substring, 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899709,
                "title": "c-solution",
                "content": "# Approach 1: Rabin-Karp + rolling hash (preferred)\\n## Implementation\\n```\\npublic class Solution {\\n    public IList<string> FindRepeatedDnaSequences(string s) {\\n        \\n        HashSet<string> res = new HashSet<string>();\\n        if(s == null || s.Length < 10)\\n            return res.ToList();\\n        \\n        int[] nums = new int[s.Length];\\n        for(int m = 0; m < s.Length; m++)\\n        {\\n            switch (s[m])\\n            {\\n                case \\'A\\':\\n                    nums[m] = 0;\\n                    break;\\n                case \\'C\\':\\n                    nums[m] = 1;\\n                    break;\\n                case \\'G\\':\\n                    nums[m] = 2;\\n                    break;\\n                case \\'T\\':\\n                    nums[m] = 3;\\n                    break;\\n            }\\n        }\\n        \\n        HashSet<int> seen = new HashSet<int>();      \\n        int hashCode = 0;\\n        for(int i = 0 ; i <= nums.Length - 10; i++)\\n        {\\n            if(i == 0)\\n            {\\n                for(int j = 0; j < 10; j++)\\n                    hashCode = hashCode * 4 + nums[j];\\n            }\\n            else\\n            {\\n                hashCode = hashCode * 4 - (int)Math.Pow(4, 10) * nums[i - 1] + nums[i + 9];\\n            }\\n\\n            if(seen.Contains(hashCode))\\n                res.Add(s.Substring(i, 10));\\n            else\\n                seen.Add(hashCode);\\n        }\\n        \\n        return res.ToList();\\n    }\\n}\\n```\\n## Complexity\\n* Time: O(N)\\n* Space: O(N)\\n\\n# Approach 2: HashSet + String.Substring()\\n## Implementation\\n```\\npublic class Solution {\\n    public IList<string> FindRepeatedDnaSequences(string s) {\\n        \\n        HashSet<string> res = new HashSet<string>();\\n        if(s == null || s.Length < 10)\\n            return res.ToList();\\n        \\n        HashSet<string> set = new HashSet<string>();\\n             \\n        for(int i = 0; i <= s.Length - 10; i++)\\n        {\\n            string str = s.Substring(i,10);\\n            \\n            if(set.Contains(str))\\n                res.Add(str);\\n            else\\n                set.Add(str);\\n        }\\n        \\n        return res.ToList();\\n    }\\n}\\n```\\n\\n## Complexity\\nTime: O((N-10)*10)\\nSpace: O(N-10)",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> FindRepeatedDnaSequences(string s) {\\n        \\n        HashSet<string> res = new HashSet<string>();\\n        if(s == null || s.Length < 10)\\n            return res.ToList();\\n        \\n        int[] nums = new int[s.Length];\\n        for(int m = 0; m < s.Length; m++)\\n        {\\n            switch (s[m])\\n            {\\n                case \\'A\\':\\n                    nums[m] = 0;\\n                    break;\\n                case \\'C\\':\\n                    nums[m] = 1;\\n                    break;\\n                case \\'G\\':\\n                    nums[m] = 2;\\n                    break;\\n                case \\'T\\':\\n                    nums[m] = 3;\\n                    break;\\n            }\\n        }\\n        \\n        HashSet<int> seen = new HashSet<int>();      \\n        int hashCode = 0;\\n        for(int i = 0 ; i <= nums.Length - 10; i++)\\n        {\\n            if(i == 0)\\n            {\\n                for(int j = 0; j < 10; j++)\\n                    hashCode = hashCode * 4 + nums[j];\\n            }\\n            else\\n            {\\n                hashCode = hashCode * 4 - (int)Math.Pow(4, 10) * nums[i - 1] + nums[i + 9];\\n            }\\n\\n            if(seen.Contains(hashCode))\\n                res.Add(s.Substring(i, 10));\\n            else\\n                seen.Add(hashCode);\\n        }\\n        \\n        return res.ToList();\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public IList<string> FindRepeatedDnaSequences(string s) {\\n        \\n        HashSet<string> res = new HashSet<string>();\\n        if(s == null || s.Length < 10)\\n            return res.ToList();\\n        \\n        HashSet<string> set = new HashSet<string>();\\n             \\n        for(int i = 0; i <= s.Length - 10; i++)\\n        {\\n            string str = s.Substring(i,10);\\n            \\n            if(set.Contains(str))\\n                res.Add(str);\\n            else\\n                set.Add(str);\\n        }\\n        \\n        return res.ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899225,
                "title": "java-hashmap-solution-easy-understand",
                "content": "It\\'s very straightforward, one for loop and a HashMap should do the job. \\n\\n```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> res = new ArrayList<>();\\n        if(s.length() < 10) return res;\\n        \\n        Map<String, Integer> counts = new HashMap<>();\\n        for(int i = 10; i <= s.length(); i++) {\\n            String substr = s.substring(i-10, i);\\n            if(counts.containsKey(substr) && counts.get(substr) == 1) {\\n                res.add(substr);\\n            }\\n            counts.put(substr, counts.getOrDefault(substr, 0)+1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> res = new ArrayList<>();\\n        if(s.length() < 10) return res;\\n        \\n        Map<String, Integer> counts = new HashMap<>();\\n        for(int i = 10; i <= s.length(); i++) {\\n            String substr = s.substring(i-10, i);\\n            if(counts.containsKey(substr) && counts.get(substr) == 1) {\\n                res.add(substr);\\n            }\\n            counts.put(substr, counts.getOrDefault(substr, 0)+1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898965,
                "title": "python-super-simple",
                "content": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        dna_sequences = defaultdict(int)\\n        \\n        for i in range(len(s) - 9):\\n            dna_sequences[s[i: i + 10]] += 1\\n           \\n        return [seq for seq, num in dna_sequences.items() if num > 1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        dna_sequences = defaultdict(int)\\n        \\n        for i in range(len(s) - 9):\\n            dna_sequences[s[i: i + 10]] += 1\\n           \\n        return [seq for seq, num in dna_sequences.items() if num > 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898841,
                "title": "simple-python-solution-using-slicing",
                "content": "So the solution is quite simple, the main problem is slicing is linear time not constant, since in this problem slicing is limited to 10 its ok it didnt time out. A follow up question would be if slicing is larger, so can we do slicing in constant time? (The answer is actually yes, but it will be more complicated and will be done using Bit Manipulation )\\n```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        myDict=collections.Counter()\\n        \\n        for i in range(len(s)-9):\\n            t=s[i:i+10]\\n            myDict[t]+=1    \\n        return [k for k,v in myDict.items() if v>1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        myDict=collections.Counter()\\n        \\n        for i in range(len(s)-9):\\n            t=s[i:i+10]\\n            myDict[t]+=1    \\n        return [k for k,v in myDict.items() if v>1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898836,
                "title": "c-rolling-hash",
                "content": "The \"hash\" here is not a hash in the common sense since there is no information loss due to the fact that 10 letter DNA sequence has only 20 bits of information. Therefore, we do not need to compare the strings when there is a match and can simply assume a hit was found.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s)\\n    {\\n        if (s.size() < 11)\\n            return {};\\n        \\n        std::unordered_map<int, size_t> m;\\n        std::unordered_set<int> set;\\n        \\n        int hash = 0;\\n        for (size_t i = 0; i != 10; ++i)\\n        {\\n            hash <<= 2;\\n            hash += hashVal(s[i]);\\n        }\\n        m.emplace(hash, 0);\\n        \\n        for (size_t i = 10; i != s.size(); ++i)\\n        {\\n            hash -= hashVal(s[i - 10]) << 18;\\n            hash <<= 2;\\n            hash += hashVal(s[i]);\\n            const auto [it, inserted] = m.emplace(hash, i - 9);\\n            if (!inserted)\\n                set.insert(hash);\\n        }\\n        \\n        vector<string> res;\\n        for (auto hash : set)\\n            res.push_back(s.substr(m[hash], 10));\\n        \\n        return res;\\n    }\\n\\nprivate:\\n    int hashVal(char c)\\n    {\\n        switch (c)\\n        {\\n            case \\'A\\':\\n                return 0;\\n            case \\'C\\':\\n                return 1;\\n            case \\'G\\':\\n                return 2;\\n            case \\'T\\':\\n                return 3;\\n            default:\\n                assert(false);\\n                return 3;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s)\\n    {\\n        if (s.size() < 11)\\n            return {};\\n        \\n        std::unordered_map<int, size_t> m;\\n        std::unordered_set<int> set;\\n        \\n        int hash = 0;\\n        for (size_t i = 0; i != 10; ++i)\\n        {\\n            hash <<= 2;\\n            hash += hashVal(s[i]);\\n        }\\n        m.emplace(hash, 0);\\n        \\n        for (size_t i = 10; i != s.size(); ++i)\\n        {\\n            hash -= hashVal(s[i - 10]) << 18;\\n            hash <<= 2;\\n            hash += hashVal(s[i]);\\n            const auto [it, inserted] = m.emplace(hash, i - 9);\\n            if (!inserted)\\n                set.insert(hash);\\n        }\\n        \\n        vector<string> res;\\n        for (auto hash : set)\\n            res.push_back(s.substr(m[hash], 10));\\n        \\n        return res;\\n    }\\n\\nprivate:\\n    int hashVal(char c)\\n    {\\n        switch (c)\\n        {\\n            case \\'A\\':\\n                return 0;\\n            case \\'C\\':\\n                return 1;\\n            case \\'G\\':\\n                return 2;\\n            case \\'T\\':\\n                return 3;\\n            default:\\n                assert(false);\\n                return 3;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898614,
                "title": "java-98-multiple-solution-explained-tle-to-very-fast",
                "content": "So I\\'ll start from very basic\\n\\nTime Limit Exceeded\\n1. brute force approache would be for every index i, find a 10 char long string and for each j>i, find a 10 char long string and compare, if same, it is repeated and add to result;\\n\\n```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n      if(s==null || s.length()<10)\\n        return new ArrayList<String>();\\n      int n = s.length();  \\n     \\n      List<String> result = new ArrayList<>();\\n      \\n      for(int i=0;i<n;i++){\\n        String s1 = stringStartingFromI(s,i);\\n        if(s1==null)\\n          continue;\\n        for(int j=i+1;j<n;j++){\\n          String s2 = stringStartingFromI(s,j);\\n          if(s2==null || !s1.equals(s2) || result.contains(s1))\\n            continue;\\n          result.add(s1);\\n        }\\n      }\\n      return result;\\n    }\\n  \\n    private String stringStartingFromI(String s, int i){\\n      StringBuilder str = new StringBuilder();\\n      while(str.length()!=10){\\n        if(i>=s.length())\\n          return null;\\n        str.append(s.charAt(i));\\n        i++;\\n      }\\n      \\n      return str.toString();\\n    }\\n}\\n```\\n\\n50% Fast\\n2. Another optimized would be, to create a window of string of size 10 and keep a track of all such 10 char strings in sequencesFound Map of string v/s boolean , if sequence is faced first time, put false, if sequence is faced second time, add it to result and put boolean value as true, hence visited. We only add new strings which reappear and store all strings we see.\\n\\n```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n         if(s==null || s.length()<10)\\n        return new ArrayList<String>();\\n      \\n        int n = s.length();  \\n        HashMap<String,Boolean> sequencesAdded = new HashMap<>();\\n      \\n      List<String> result = new ArrayList<>();\\n      StringBuilder sequence = new StringBuilder();\\n      \\n       for(int i=0;i<10;i++){\\n          sequence.append(s.charAt(i));\\n        }\\n      sequencesAdded.put(sequence.toString(),false);\\n      \\n      int idx = 10;\\n      while(idx<n){\\n        sequence.deleteCharAt(0);\\n        sequence.append(s.charAt(idx++));\\n        \\n        String newSequence = sequence.toString();\\n        \\n        if(sequencesAdded.containsKey(newSequence)){\\n            if(sequencesAdded.get(newSequence)) {\\n              continue;\\n            }else{\\n               result.add(newSequence);\\n               sequencesAdded.put(newSequence,true);\\n            }\\n        }else{\\n          sequencesAdded.put(newSequence,false);\\n        }\\n      }\\n      return result;\\n    }\\n}\\n```\\n\\n98% Fast\\n3.A better approach is to optimize time by operating on hashCode of the 10 char sequence and not on string..The logic is same as above but we operate on int and not string so processing is much faster.\\nso hashCode = (2 bit representation of char)..for every char..\\nwe use a bit mask of 20 1s to remove first char when we add a new char.\\n\\n```\\nclass Solution {\\n  \\n  private final static int[] map = new int[128];\\n  static{\\n    map[\\'A\\'] = 0; map[\\'C\\'] = 1; map[\\'G\\'] = 2; map[\\'T\\'] = 3;\\n   }\\n  \\n    public List<String> findRepeatedDnaSequences(String s) {\\n      List<String> result = new ArrayList<>();\\n         if(s.length()<10)\\n        return result; \\n      char[] str = s.toCharArray();\\n      \\n      //all possiblitis of 10 char A,G,C,T digits lie from A...10times to T..10 times, i.e. all lie in a range of possibities such that, each place has 4 possibilties-A,G,C,T\\n      //4*4*4*4*4*4*..10times = >10,48,576.. so these are the possibities,\\n      //we can replace our set by this.. \\n      boolean[] sequencesFound = new boolean[1048576], isSeqAdded = new boolean[1048576];\\n      \\n      // HashMap<String,Boolean> sequencesAdded = new HashMap<>();\\n      \\n      \\n      \\n      //here we will create hashcode instead of stringbuilder, since it is faster to process\\n      int hashCode = 0, i = 0;\\n      while(i<10){\\n          hashCode = (hashCode << 2) + map[str[i++]];\\n        }\\n      sequencesFound[hashCode] = true; \\n\\n      while(i<str.length){\\n        //remove first character by moving right and masking by 20 1s, and add new char at end\\n        hashCode = ((hashCode<<2) & 0xFFFFF) + map[str[i++]];\\n        \\n        if(sequencesFound[hashCode] && !isSeqAdded[hashCode]){\\n          result.add(new String(str,i-10,10));\\n          isSeqAdded[hashCode] = true;\\n        }\\n        sequencesFound[hashCode] = true;\\n      }\\n      return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n      if(s==null || s.length()<10)\\n        return new ArrayList<String>();\\n      int n = s.length();  \\n     \\n      List<String> result = new ArrayList<>();\\n      \\n      for(int i=0;i<n;i++){\\n        String s1 = stringStartingFromI(s,i);\\n        if(s1==null)\\n          continue;\\n        for(int j=i+1;j<n;j++){\\n          String s2 = stringStartingFromI(s,j);\\n          if(s2==null || !s1.equals(s2) || result.contains(s1))\\n            continue;\\n          result.add(s1);\\n        }\\n      }\\n      return result;\\n    }\\n  \\n    private String stringStartingFromI(String s, int i){\\n      StringBuilder str = new StringBuilder();\\n      while(str.length()!=10){\\n        if(i>=s.length())\\n          return null;\\n        str.append(s.charAt(i));\\n        i++;\\n      }\\n      \\n      return str.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n         if(s==null || s.length()<10)\\n        return new ArrayList<String>();\\n      \\n        int n = s.length();  \\n        HashMap<String,Boolean> sequencesAdded = new HashMap<>();\\n      \\n      List<String> result = new ArrayList<>();\\n      StringBuilder sequence = new StringBuilder();\\n      \\n       for(int i=0;i<10;i++){\\n          sequence.append(s.charAt(i));\\n        }\\n      sequencesAdded.put(sequence.toString(),false);\\n      \\n      int idx = 10;\\n      while(idx<n){\\n        sequence.deleteCharAt(0);\\n        sequence.append(s.charAt(idx++));\\n        \\n        String newSequence = sequence.toString();\\n        \\n        if(sequencesAdded.containsKey(newSequence)){\\n            if(sequencesAdded.get(newSequence)) {\\n              continue;\\n            }else{\\n               result.add(newSequence);\\n               sequencesAdded.put(newSequence,true);\\n            }\\n        }else{\\n          sequencesAdded.put(newSequence,false);\\n        }\\n      }\\n      return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n  \\n  private final static int[] map = new int[128];\\n  static{\\n    map[\\'A\\'] = 0; map[\\'C\\'] = 1; map[\\'G\\'] = 2; map[\\'T\\'] = 3;\\n   }\\n  \\n    public List<String> findRepeatedDnaSequences(String s) {\\n      List<String> result = new ArrayList<>();\\n         if(s.length()<10)\\n        return result; \\n      char[] str = s.toCharArray();\\n      \\n      //all possiblitis of 10 char A,G,C,T digits lie from A...10times to T..10 times, i.e. all lie in a range of possibities such that, each place has 4 possibilties-A,G,C,T\\n      //4*4*4*4*4*4*..10times = >10,48,576.. so these are the possibities,\\n      //we can replace our set by this.. \\n      boolean[] sequencesFound = new boolean[1048576], isSeqAdded = new boolean[1048576];\\n      \\n      // HashMap<String,Boolean> sequencesAdded = new HashMap<>();\\n      \\n      \\n      \\n      //here we will create hashcode instead of stringbuilder, since it is faster to process\\n      int hashCode = 0, i = 0;\\n      while(i<10){\\n          hashCode = (hashCode << 2) + map[str[i++]];\\n        }\\n      sequencesFound[hashCode] = true; \\n\\n      while(i<str.length){\\n        //remove first character by moving right and masking by 20 1s, and add new char at end\\n        hashCode = ((hashCode<<2) & 0xFFFFF) + map[str[i++]];\\n        \\n        if(sequencesFound[hashCode] && !isSeqAdded[hashCode]){\\n          result.add(new String(str,i-10,10));\\n          isSeqAdded[hashCode] = true;\\n        }\\n        sequencesFound[hashCode] = true;\\n      }\\n      return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898339,
                "title": "scala-1-line",
                "content": "```\\n  def findRepeatedDnaSequences(s: String): List[String] = {    \\n    s.sliding(10).toList.groupBy(identity).mapValues(_.size).filter(_._2 > 1).keys.toList\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def findRepeatedDnaSequences(s: String): List[String] = {    \\n    s.sliding(10).toList.groupBy(identity).mapValues(_.size).filter(_._2 > 1).keys.toList\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 898311,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        hash=defaultdict(int)\\n        for i in range(len(s)-9):\\n            hash[s[i:i+10]]+=1\\n        ans=[]\\n        for i in hash.keys():\\n            if hash[i]>1:\\n                ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        hash=defaultdict(int)\\n        for i in range(len(s)-9):\\n            hash[s[i:i+10]]+=1\\n        ans=[]\\n        for i in hash.keys():\\n            if hash[i]>1:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898284,
                "title": "swift-solution-using-rabin-karp-algorithm",
                "content": "```\\nclass Solution {\\n    func findRepeatedDnaSequences(_ s: String) -> [String] {\\n        guard s.count > 10 else {\\n            return []\\n        }\\n        return findRepeatedDnaSequences(s, 10)\\n    }\\n    \\n    private func findRepeatedDnaSequences(_ s: String, _ length: Int) -> [String] {\\n        let base = 5\\n        let dnaMap: [Character: Int] = [\"A\": 0, \"C\": 1, \"G\": 2, \"T\": 3]\\n        let chars: [Character] = Array(s)\\n        let power: Int = Int(pow(Double(base), Double(length-1)))\\n        \\n        var hashFrequency: [Int: Int] = [:]\\n        var hash: Int = 0\\n        for i in 0..<length {\\n            hash = hash * base + dnaMap[chars[i]]!\\n        }\\n        hashFrequency[hash] = 1\\n        \\n        var result: [String] = []\\n        for i in length..<chars.count {\\n            // remove first cahr\\n            hash -= (dnaMap[chars[i-length]]! * power)\\n            // add new char\\n            hash = hash * base + dnaMap[chars[i]]!\\n            \\n            let freq = hashFrequency[hash] ?? 0\\n            if freq == 1 {\\n                // found first duplicate\\n                result.append(String(chars[i-length+1...i]))\\n            } \\n            hashFrequency[hash] = freq + 1\\n        }\\n        return result\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    func findRepeatedDnaSequences(_ s: String) -> [String] {\\n        guard s.count > 10 else {\\n            return []\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 898215,
                "title": "repeated-dna-sequences-hashmap-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> map;\\n        int n = s.length();\\n        vector<string> res;\\n        for(int i = 0; i <= n - 10; i++) {\\n            string substr = s.substr(i, 10);\\n            if(map.count(substr)) {\\n                if(map[substr] == 1)\\n                    res.push_back(substr);\\n                map[substr] += 1;\\n            }\\n            else\\n                map.insert({substr, 1});\\n        }\\n        \\n        return res;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_map<string, int> map;\\n        int n = s.length();\\n        vector<string> res;\\n        for(int i = 0; i <= n - 10; i++) {\\n            string substr = s.substr(i, 10);\\n            if(map.count(substr)) {\\n                if(map[substr] == 1)\\n                    res.push_back(substr);\\n                map[substr] += 1;\\n            }\\n            else\\n                map.insert({substr, 1});\\n        }\\n        \\n        return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826001,
                "title": "rolling-hash-java-o-n-better-than-o-10-n",
                "content": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> res=new ArrayList<>();\\n        if(s.length()<=10)\\n            return res;\\n        HashSet<Integer> hs=new HashSet<>(),found=new HashSet<>();\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        hm.put(\\'A\\',0);\\n        hm.put(\\'C\\',1);\\n        hm.put(\\'G\\',2);\\n        hm.put(\\'T\\',3);\\n        int hash=0;\\n        for(int i=0;i<10;i++){\\n            hash=hash*4+(hm.get(s.charAt(i)));\\n        }\\n        hs.add(hash);\\n        for(int i=10;i<s.length();i++){\\n            hash=hash-(int)Math.pow(4,9)*hm.get(s.charAt(i-10));\\n            hash=hash*4+(hm.get(s.charAt(i)));\\n            if(!hs.add(hash)&&!found.contains(hash)){\\n                found.add(hash);                                           // avoid repeating\\n                res.add(s.substring(i-9,i+1));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findRepeatedDnaSequences(String s) {\\n        List<String> res=new ArrayList<>();\\n        if(s.length()<=10)\\n            return res;\\n        HashSet<Integer> hs=new HashSet<>(),found=new HashSet<>();\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        hm.put(\\'A\\',0);\\n        hm.put(\\'C\\',1);\\n        hm.put(\\'G\\',2);\\n        hm.put(\\'T\\',3);\\n        int hash=0;\\n        for(int i=0;i<10;i++){\\n            hash=hash*4+(hm.get(s.charAt(i)));\\n        }\\n        hs.add(hash);\\n        for(int i=10;i<s.length();i++){\\n            hash=hash-(int)Math.pow(4,9)*hm.get(s.charAt(i-10));\\n            hash=hash*4+(hm.get(s.charAt(i)));\\n            if(!hs.add(hash)&&!found.contains(hash)){\\n                found.add(hash);                                           // avoid repeating\\n                res.add(s.substring(i-9,i+1));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788511,
                "title": "python3-clear-simple",
                "content": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        dna_sequences = defaultdict()\\n        \\n        for i in range(len(s) - 9):\\n            if s[i: i + 10] in dna_sequences:\\n                dna_sequences[s[i: i + 10]] += 1\\n            else:\\n                dna_sequences[s[i: i + 10]] = 1\\n                \\n        \\n        return [seq for seq, num in dna_sequences.items() if num > 1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\\n        dna_sequences = defaultdict()\\n        \\n        for i in range(len(s) - 9):\\n            if s[i: i + 10] in dna_sequences:\\n                dna_sequences[s[i: i + 10]] += 1\\n            else:\\n                dna_sequences[s[i: i + 10]] = 1\\n                \\n        \\n        return [seq for seq, num in dna_sequences.items() if num > 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623794,
                "title": "python3-2-line-solution-easy-to-understand",
                "content": "Count every 10 char substring using a counter and return if the substring has a count greater than 1\\n\\n```python\\ndef findRepeatedDnaSequences(self, s: str) -> List[str]:\\n\\tcounter = collections.Counter(s[i:i+10] for i in range(len(s)-9))\\n\\treturn [s for s in counter if counter[s] > 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef findRepeatedDnaSequences(self, s: str) -> List[str]:\\n\\tcounter = collections.Counter(s[i:i+10] for i in range(len(s)-9))\\n\\treturn [s for s in counter if counter[s] > 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 300680,
                "title": "c-sliding-window-o-n-time-and-space",
                "content": "```\\npublic class Solution {\\n    private int GetPrime(char c) {\\n        switch (c) {\\n            case \\'A\\': return 2;\\n            case \\'C\\': return 3;\\n            case \\'T\\': return 5;\\n            default: return 7;\\n        }\\n    }\\n    \\n    public IList<string> FindRepeatedDnaSequences(string s) {\\n        \\n        var map = new Dictionary<long, bool>();        \\n        var res = new List<string>();\\n        \\n        long num = 0;\\n        long mult = (long)Math.Pow(10, 9);\\n        \\n        for (int i = 0; i < s.Length; i++) {\\n            num = (num * 10) + GetPrime(s[i]);\\n            \\n            if (i >= 9) {\\n                if (map.ContainsKey(num)) {\\n                    if (map[num]) {\\n                        res.Add(s.Substring(i - 9, 10));\\n                        map[num] = false;\\n                    }\\n                } else {\\n                    map[num] = true;\\n                }\\n                \\n                num -= GetPrime(s[i - 9]) * mult;\\n            }         \\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private int GetPrime(char c) {\\n        switch (c) {\\n            case \\'A\\': return 2;\\n            case \\'C\\': return 3;\\n            case \\'T\\': return 5;\\n            default: return 7;\\n        }\\n    }\\n    \\n    public IList<string> FindRepeatedDnaSequences(string s) {\\n        \\n        var map = new Dictionary<long, bool>();        \\n        var res = new List<string>();\\n        \\n        long num = 0;\\n        long mult = (long)Math.Pow(10, 9);\\n        \\n        for (int i = 0; i < s.Length; i++) {\\n            num = (num * 10) + GetPrime(s[i]);\\n            \\n            if (i >= 9) {\\n                if (map.ContainsKey(num)) {\\n                    if (map[num]) {\\n                        res.Add(s.Substring(i - 9, 10));\\n                        map[num] = false;\\n                    }\\n                } else {\\n                    map[num] = true;\\n                }\\n                \\n                num -= GetPrime(s[i - 9]) * mult;\\n            }         \\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284241,
                "title": "easy-c-solution-with-set",
                "content": "```C++\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_set<string> s1,s2;\\n\\t\\tfor(int i=0;i<(int)s.length()-9;i++)\\n\\t\\t{\\n\\t\\t\\tstring tmp=s.substr(i,10);\\n\\t\\t\\tif(s1.find(tmp)==s1.end())\\n\\t\\t\\t\\ts1.insert(tmp);\\n\\t\\t\\telse\\n\\t\\t\\t\\ts2.insert(tmp);\\n\\t\\t}\\n\\n\\t\\treturn vector<string>(s2.begin(),s2.end());\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<string> findRepeatedDnaSequences(string s) {\\n        unordered_set<string> s1,s2;\\n\\t\\tfor(int i=0;i<(int)s.length()-9;i++)\\n\\t\\t{\\n\\t\\t\\tstring tmp=s.substr(i,10);\\n\\t\\t\\tif(s1.find(tmp)==s1.end())\\n\\t\\t\\t\\ts1.insert(tmp);\\n\\t\\t\\telse\\n\\t\\t\\t\\ts2.insert(tmp);\\n\\t\\t}\\n\\n\\t\\treturn vector<string>(s2.begin(),s2.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280513,
                "title": "repeated-dna-sequences-java-array-and-bit-manipulation",
                "content": "```\\n public List<String> findRepeatedDnaSequences(String s) {\\n     List<String> resultList = new ArrayList<>();\\n\\t\\tSet<Integer> words = new HashSet<>();\\n\\t\\tSet<Integer> repeatedWords = new HashSet<>();\\n\\n\\t\\tint[] map = new int[26];\\n\\t\\tmap[\\'A\\' - \\'A\\'] = 0;\\n\\t\\tmap[\\'C\\' - \\'A\\'] = 1;\\n\\t\\tmap[\\'G\\' - \\'A\\'] = 2;\\n\\t\\tmap[\\'T\\' - \\'A\\'] = 3;\\n\\t\\t\\n\\t\\tint mask = 0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length(); i++) {\\n\\t\\t\\tmask = (mask << 2) | map[s.charAt(i) - \\'A\\'];\\n\\t\\t\\tif(i >= 9) {\\n\\t\\t\\t\\tmask = mask & ((1 << 20) - 1); // to consider only last 20 bits // ((1<<20)-1) creates a mask of 20 1s\\n\\t\\t\\t\\tif(!words.add(mask) && repeatedWords.add(mask)) {\\n\\t\\t\\t\\t\\tresultList.add(s.substring(i - 9, i + 1));  // if repeated addd to resultList\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn resultList;\\n    }",
                "solutionTags": [],
                "code": "```\\n public List<String> findRepeatedDnaSequences(String s) {\\n     List<String> resultList = new ArrayList<>();\\n\\t\\tSet<Integer> words = new HashSet<>();\\n\\t\\tSet<Integer> repeatedWords = new HashSet<>();\\n\\n\\t\\tint[] map = new int[26];\\n\\t\\tmap[\\'A\\' - \\'A\\'] = 0;\\n\\t\\tmap[\\'C\\' - \\'A\\'] = 1;\\n\\t\\tmap[\\'G\\' - \\'A\\'] = 2;\\n\\t\\tmap[\\'T\\' - \\'A\\'] = 3;\\n\\t\\t\\n\\t\\tint mask = 0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length(); i++) {\\n\\t\\t\\tmask = (mask << 2) | map[s.charAt(i) - \\'A\\'];\\n\\t\\t\\tif(i >= 9) {\\n\\t\\t\\t\\tmask = mask & ((1 << 20) - 1); // to consider only last 20 bits // ((1<<20)-1) creates a mask of 20 1s\\n\\t\\t\\t\\tif(!words.add(mask) && repeatedWords.add(mask)) {\\n\\t\\t\\t\\t\\tresultList.add(s.substring(i - 9, i + 1));  // if repeated addd to resultList\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn resultList;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 238185,
                "title": "1-line-python-solution-beat-97",
                "content": "```python\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: \\'str\\') -> \\'List[str]\\':\\n        return [k for k, v in collections.Counter([s[i : i + 10] for i in range(len(s) - 9)]).items() if v > 1]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s: \\'str\\') -> \\'List[str]\\':\\n        return [k for k, v in collections.Counter([s[i : i + 10] for i in range(len(s) - 9)]).items() if v > 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194109,
                "title": "fast-python3-solution-using-bit-shifting-72ms-beats-98-55",
                "content": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        charMap = {\\'A\\': 0b00, \\'C\\': 0b01, \\'G\\': 0b10, \\'T\\': 0b11}\\n        hashCode = 0\\n        hashes = {}\\n        result = []\\n        length = len(s)\\n        if length <= 10:\\n            return []\\n        for c in range(length-1, length-10, -1):\\n            hashCode = (hashCode << 2) & 0xfffff # 0xfffff = 20 ones in binary\\n            hashCode |= charMap[s[c]]\\n\\n        for c in range(length-10, -1, -1):\\n            hashCode = (hashCode << 2) & 0xfffff\\n            hashCode |= charMap[s[c]]\\n\\n            if hashCode in hashes:\\n                if hashes[hashCode]:\\n                    result.append(s[c:c+10])\\n                    hashes[hashCode] = False\\n            else:\\n                hashes[hashCode] = True\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findRepeatedDnaSequences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        charMap = {\\'A\\': 0b00, \\'C\\': 0b01, \\'G\\': 0b10, \\'T\\': 0b11}\\n        hashCode = 0\\n        hashes = {}\\n        result = []\\n        length = len(s)\\n        if length <= 10:\\n            return []\\n        for c in range(length-1, length-10, -1):\\n            hashCode = (hashCode << 2) & 0xfffff # 0xfffff = 20 ones in binary\\n            hashCode |= charMap[s[c]]\\n\\n        for c in range(length-10, -1, -1):\\n            hashCode = (hashCode << 2) & 0xfffff\\n            hashCode |= charMap[s[c]]\\n\\n            if hashCode in hashes:\\n                if hashes[hashCode]:\\n                    result.append(s[c:c+10])\\n                    hashes[hashCode] = False\\n            else:\\n                hashes[hashCode] = True\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185362,
                "title": "c-basic-solution-uses-lots-of-space-intuitive-quick-a",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> res;\\n        unordered_map<string, bool> visited;\\n        unordered_map<string, bool> consumed;\\n        int len = s.length();\\n        for (int i=10;i<=len;i++) {\\n            string ss = s.substr(i - 10, 10);\\n            \\n            if (visited[ss] == true && consumed[ss] == false) {\\n                res.push_back(ss);\\n                consumed[ss] = true;\\n            } else {\\n                visited[ss] = true;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};\\n```\\n\\nIt\\'s pretty cool, looking for better ways to do it.\\n\\nHmm...\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> findRepeatedDnaSequences(string s) {\\n        vector<string> res;\\n        unordered_map<string, bool> visited;\\n        unordered_map<string, bool> consumed;\\n        int len = s.length();\\n        for (int i=10;i<=len;i++) {\\n            string ss = s.substr(i - 10, 10);\\n            \\n            if (visited[ss] == true && consumed[ss] == false) {\\n                res.push_back(ss);\\n                consumed[ss] = true;\\n            } else {\\n                visited[ss] = true;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162819,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        seen = set()\\n        dup = set()\\n        if len(s) < 10:\\n            return []\\n        for i in range(len(s)-9):\\n            cand = s[i:i+10]\\n            if cand in seen:\\n                dup.add(cand)\\n            else:\\n                seen.add(cand)\\n        return list(dup)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findRepeatedDnaSequences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: List[str]\\n        \"\"\"\\n        seen = set()\\n        dup = set()\\n        if len(s) < 10:\\n            return []\\n        for i in range(len(s)-9):\\n            cand = s[i:i+10]\\n            if cand in seen:\\n                dup.add(cand)\\n            else:\\n                seen.add(cand)\\n        return list(dup)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154335,
                "title": "c-hash-solution",
                "content": "```\\nvector<string> findRepeatedDnaSequences(string s) {\\n\\tunordered_map<string, int> table;\\n\\tfor (int i = 0; i + 10 <= s.size(); ++ i) {\\n\\t\\t\\tstring sub = s.substr(i, 10);\\n\\t\\t\\t++ table[sub];\\n\\t}\\n\\n\\tvector<string> result;\\n\\tfor (auto it : table) {\\n\\t\\t\\tif (it.second > 1) {\\n\\t\\t\\t\\t\\tresult.push_back(it.first);\\n\\t\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> findRepeatedDnaSequences(string s) {\\n\\tunordered_map<string, int> table;\\n\\tfor (int i = 0; i + 10 <= s.size(); ++ i) {\\n\\t\\t\\tstring sub = s.substr(i, 10);\\n\\t\\t\\t++ table[sub];\\n\\t}\\n\\n\\tvector<string> result;\\n\\tfor (auto it : table) {\\n\\t\\t\\tif (it.second > 1) {\\n\\t\\t\\t\\t\\tresult.push_back(it.first);\\n\\t\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 145827,
                "title": "c-using-rabin-karp-algorithm-rolling-hashing-function-faster-than-bitmap",
                "content": "To improve the efficiency, using an incremental hash function instead of bit hashing\\nIncremental hashing executes one time to generate a new hashing based on previous  hashing value.  The average time complexity is O(n+m). The worst case is O(nm) \\nBit hashing executes(shift) m time to get the new hashing value. The time complexity is O(nm). \\n```\\npublic IList<string> FindRepeatedDnaSequences(string s) {\\n                 \\n            HashSet<string> rs = new HashSet<string>();    \\n            if(s.Length < 10) return rs.ToList(); \\n        \\n            HashSet<int> occur = new HashSet<int>();\\n            Dictionary<char, int> map = new Dictionary<char, int>();\\n            map.Add(\\'A\\', 0);\\n            map.Add(\\'C\\', 1);\\n            map.Add(\\'G\\', 2);\\n            map.Add(\\'T\\', 3);\\n\\n            int key = 0;\\n            for (int i = 0; i < 10; i++)\\n                key = key * 10 + map[s[i]];\\n            occur.Add(key);\\n\\n            for (int i = 1; i < s.Length-9; i++)\\n            {\\n                key = (key - map[s[i - 1]] * 1000000000) * 10 + map[s[i+9]];\\n                if (occur.Contains(key))\\n                    rs.Add(s.Substring(i, 10));\\n                else\\n                    occur.Add(key);\\n            }\\n            return rs.ToList();  \\n    }\\n",
                "solutionTags": [],
                "code": "To improve the efficiency, using an incremental hash function instead of bit hashing\\nIncremental hashing executes one time to generate a new hashing based on previous  hashing value.  The average time complexity is O(n+m). The worst case is O(nm) \\nBit hashing executes(shift) m time to get the new hashing value. The time complexity is O(nm). \\n```\\npublic IList<string> FindRepeatedDnaSequences(string s) {\\n                 \\n            HashSet<string> rs = new HashSet<string>();    \\n            if(s.Length < 10) return rs.ToList(); \\n        \\n            HashSet<int> occur = new HashSet<int>();\\n            Dictionary<char, int> map = new Dictionary<char, int>();\\n            map.Add(\\'A\\', 0);\\n            map.Add(\\'C\\', 1);\\n            map.Add(\\'G\\', 2);\\n            map.Add(\\'T\\', 3);\\n\\n            int key = 0;\\n            for (int i = 0; i < 10; i++)\\n                key = key * 10 + map[s[i]];\\n            occur.Add(key);\\n\\n            for (int i = 1; i < s.Length-9; i++)\\n            {\\n                key = (key - map[s[i - 1]] * 1000000000) * 10 + map[s[i+9]];\\n                if (occur.Contains(key))\\n                    rs.Add(s.Substring(i, 10));\\n                else\\n                    occur.Add(key);\\n            }\\n            return rs.ToList();  \\n    }\\n",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564774,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1567220,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1566761,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1566078,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1565597,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1574018,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1566941,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1566760,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1567907,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1566762,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1564774,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1567220,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1566761,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1566078,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1565597,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1574018,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1566941,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1566760,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1567907,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1566762,
                "content": [
                    {
                        "username": "lesleyz",
                        "content": "Am I understanding the problem wrongly? In the example given in the problem, \\nAren't AAAACCCCCA, AAACCCCCAA, AACCCCCAAA and ACCCCCAAAA valid repetition of sequences as well?"
                    },
                    {
                        "username": "deepgsaha",
                        "content": "[@AhmedElShereef](/AhmedElShereef) the only sequence that can occur is AAAAAAAAAA which is occurring more than once so only one output."
                    },
                    {
                        "username": "deepgsaha",
                        "content": "Yes but they are appearing only once....you can print each 10 letter sequence and can check......you can apply sliding window technique."
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "[@KalpitShah](/KalpitShah) what about e.g 2 AAAAAAAAAAAA"
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "larryleguo",
                        "content": "I think \"more than once\" mean twice or above. overlapped occurrence should not be considered.\\n\\nInput:\\n\"AAAAAAAAAAA\"\\n\\nOutput:\\n[]\\n\\nExpected:\\n[\"AAAAAAAAAA\"]"
                    },
                    {
                        "username": "nr1286",
                        "content": "can someone explain the test case AAAAAAAAAAA.\\n\\ni dont understand it"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "[@bah](/bah) then answer must contain 3 times \\'AAAAAAAAAA\\' as length of repitation is 13, means at index 2 and 3 it occurred twice. "
                    },
                    {
                        "username": "user7228dr",
                        "content": "[@Pavankhandarkar19](/Pavankhandarkar19) Dont comment if you have nothing of value to add to the discussion"
                    },
                    {
                        "username": "bah",
                        "content": "we have \\'A\\' 11 times. so we have 2 substrings of len 10:\\n\\'A\\' 10 times (from index 0 to 9)\\n\\'A\\' 10 times (from index 1 to 10)\\nso we have the same substring twice, and we return it :)"
                    },
                    {
                        "username": "henryvhl",
                        "content": "If question is \"Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\", so for the example:\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\n\\nIt should also return \"AAACCCCCAA\", \"AACCCCCAAA\" ..... as well ?"
                    },
                    {
                        "username": "mkohar",
                        "content": "yes it should and same can be verified by adding custom test case. But the example given in original question contains 6Cs in second half and 5 Cs in first."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def find_repeated_dna_sequences(s)\\n      s.chars.each_cons(10).group_by(&:join).select { |_, group| group.size > 1 }.keys\\n    end"
                    },
                    {
                        "username": "DoMonkeysFly7",
                        "content": "[@seilov](/seilov) some people feel the need to show their \\'potency\\' somehow if they cannot do it in a meaningful real way."
                    },
                    {
                        "username": "seilov",
                        "content": "this is the discussion tab, not solution."
                    },
                    {
                        "username": "pran01",
                        "content": "Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule\\n\\nThen How is the solution of \"AAAAAAAAAAA\"\\nis [\"AAAAAAAAAA\"] instead of empty list"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question has 11 As, the answer is 10 As starting from index 0 and 10 starting from index 1\\n"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because the same string occurs at position 0 and position 1"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey guys,\\n\\nso I have some problems understanding this challenge.\\nAccording to the notes:\\n\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"] are subsequences of:\\n\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\n\\nBut why only those?\\nMy first thought was, that we need to always take\\n10 character substrings so from index 0 to 9, that would be \"AAAAACCCCC\".\\nAnd that appears twice. I get that.\\n\\nBut why then \"CCCCCAAAAA\" and NOT \"AAAACCCCCA\" or \"AAACCCCCAA\".\\nTechnically those sub-sequences also appear twice.\\nOr do I have a language barrier problem to understand the term \"subsequence\"?\\n\\nA little more explanation in the problem description would have been helpful, I think.\\nMaybe it\\'s just me tho..."
                    },
                    {
                        "username": "hibit",
                        "content": "[@KalpitShah](/KalpitShah) I counted C in both substrings and it turned out that there are 5 of them, so the issue with strings like :ACCCCCAAAA, AACCCCCAAA, etc. remains open."
                    },
                    {
                        "username": "KalpitShah",
                        "content": "Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\\n\\nI think this is what you are talking about. I was confused about the same thing but when you count the C in both the sequence. First one have 5 C (CCCCC) and second one have 6 C (CCCCCC). \\nSo, the strings will be as follows for all the cases you are talking about.\\nAAAACCCCCA, AAAACCCCCC\\nAAACCCCCAA, AAACCCCCCA\\nAACCCCCAAA, AACCCCCCAA\\nACCCCCAAAA, ACCCCCCAAA\\nHence, these are not same and not included in the answer."
                    },
                    {
                        "username": "any1fish",
                        "content": "It appeared twice, but why the answer does not count this?"
                    },
                    {
                        "username": "arcaneak",
                        "content": "Sorry, a noob question. What does the 0x3fffffff do?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "it is a hexadecimal code"
                    },
                    {
                        "username": "siyang3",
                        "content": "Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nI see \"ACCCCCAAAA\" ...and so on are also 10-letter-long sequences (substrings) that occur more than once.\\n\\nCan somebody explain to me?"
                    }
                ]
            },
            {
                "id": 1845340,
                "content": [
                    {
                        "username": "vizzy205",
                        "content": "Don\\'t return sequences of length 10 if they occur only once. Just those which occur more than once."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Thanks [@Vizzy](/vizzy205) i really appreciate your hint. it allowed me to solve on my own."
                    },
                    {
                        "username": "0nakul",
                        "content": "Here are some hints to help you solve this problem:\\n\\nOne approach to solving this problem is to use a sliding window approach, where you iterate through the string and extract 10-letter substrings as you go.\\n\\nYou can use a hash map or dictionary to keep track of the substrings that you have seen so far. If you encounter a substring that you have seen before, you know that it is a repeating sequence.\\n"
                    },
                    {
                        "username": "FanLion",
                        "content": "For example,\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nWell, why \"ACCCCCAAAA\" , \"AACCCCCAAA\" , \"AAACCCCCAA\" , \"AAAACCCCCA\" need not return ?"
                    },
                    {
                        "username": "jie24",
                        "content": "As my understanding before, the unordered_map<int,int> is a map from integer to another integer. So the key integer will increase but not keep static?"
                    },
                    {
                        "username": "changhaz",
                        "content": "Since there are only four possibilities for each char, we could use 2 bit to represent one char and assign them value like: 00 for A, 01 for C 10 for G and 11 for T.\\n\\nThus each 10 char substring could be transformed into 20 bits. We use a 32-bit int to represent the 10 char sequence. After we have the first 10 chars and move forward, we add the new char and remove the left-most char. We could use some bit operation to represent this update.\\n\\nWhenever we have a int value, we insert it into a map, which counts the occurrence of each int value.\\n\\nFinally we find out all the int value that appears more than once and transform them back to 10 char string.\\n\\nMy code could be found here\\n\\n[https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/][1]\\n\\nAny better ideas?\\n\\n\\n  [1]: https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/"
                    },
                    {
                        "username": "21manavgoel",
                        "content": "for those not able to come up with an approach, u basically have to make a freq map of every 10letter sequence possible from s, then simply return those occuring more than once"
                    },
                    {
                        "username": "nazimazhaan17",
                        "content": "the dopamine rush i get after solving a medium-hard Q in 1 go >>>>> :)"
                    },
                    {
                        "username": "ankit1478",
                        "content": "1. run loop from s.length()-10;\n2.string Dna =s.substring(i,i+10);\n3.Use HashSet to track Seen \n4.And Use Another HashSet to if already seen then it is our answer so return it ..\nand Enjoy\n\nCode Link\nhttps://leetcode.com/problems/repeated-dna-sequences/solutions/3963957/java-code/"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "Man i\\'m passing 30 of 31 tests but hitting a time limit exceeded limit on the very last test, lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "Redo the solution using a TRIE (a prefix tree) :)    It\\'s a good thing to know how to implement anyway."
                    },
                    {
                        "username": "Furies",
                        "content": "One way to make this problem more challenging is to require the repeating sequence to not overlap the previous appearances - I think that is what really matters in biology too."
                    }
                ]
            },
            {
                "id": 1750682,
                "content": [
                    {
                        "username": "vizzy205",
                        "content": "Don\\'t return sequences of length 10 if they occur only once. Just those which occur more than once."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Thanks [@Vizzy](/vizzy205) i really appreciate your hint. it allowed me to solve on my own."
                    },
                    {
                        "username": "0nakul",
                        "content": "Here are some hints to help you solve this problem:\\n\\nOne approach to solving this problem is to use a sliding window approach, where you iterate through the string and extract 10-letter substrings as you go.\\n\\nYou can use a hash map or dictionary to keep track of the substrings that you have seen so far. If you encounter a substring that you have seen before, you know that it is a repeating sequence.\\n"
                    },
                    {
                        "username": "FanLion",
                        "content": "For example,\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nWell, why \"ACCCCCAAAA\" , \"AACCCCCAAA\" , \"AAACCCCCAA\" , \"AAAACCCCCA\" need not return ?"
                    },
                    {
                        "username": "jie24",
                        "content": "As my understanding before, the unordered_map<int,int> is a map from integer to another integer. So the key integer will increase but not keep static?"
                    },
                    {
                        "username": "changhaz",
                        "content": "Since there are only four possibilities for each char, we could use 2 bit to represent one char and assign them value like: 00 for A, 01 for C 10 for G and 11 for T.\\n\\nThus each 10 char substring could be transformed into 20 bits. We use a 32-bit int to represent the 10 char sequence. After we have the first 10 chars and move forward, we add the new char and remove the left-most char. We could use some bit operation to represent this update.\\n\\nWhenever we have a int value, we insert it into a map, which counts the occurrence of each int value.\\n\\nFinally we find out all the int value that appears more than once and transform them back to 10 char string.\\n\\nMy code could be found here\\n\\n[https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/][1]\\n\\nAny better ideas?\\n\\n\\n  [1]: https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/"
                    },
                    {
                        "username": "21manavgoel",
                        "content": "for those not able to come up with an approach, u basically have to make a freq map of every 10letter sequence possible from s, then simply return those occuring more than once"
                    },
                    {
                        "username": "nazimazhaan17",
                        "content": "the dopamine rush i get after solving a medium-hard Q in 1 go >>>>> :)"
                    },
                    {
                        "username": "ankit1478",
                        "content": "1. run loop from s.length()-10;\n2.string Dna =s.substring(i,i+10);\n3.Use HashSet to track Seen \n4.And Use Another HashSet to if already seen then it is our answer so return it ..\nand Enjoy\n\nCode Link\nhttps://leetcode.com/problems/repeated-dna-sequences/solutions/3963957/java-code/"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "Man i\\'m passing 30 of 31 tests but hitting a time limit exceeded limit on the very last test, lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "Redo the solution using a TRIE (a prefix tree) :)    It\\'s a good thing to know how to implement anyway."
                    },
                    {
                        "username": "Furies",
                        "content": "One way to make this problem more challenging is to require the repeating sequence to not overlap the previous appearances - I think that is what really matters in biology too."
                    }
                ]
            },
            {
                "id": 1571393,
                "content": [
                    {
                        "username": "vizzy205",
                        "content": "Don\\'t return sequences of length 10 if they occur only once. Just those which occur more than once."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Thanks [@Vizzy](/vizzy205) i really appreciate your hint. it allowed me to solve on my own."
                    },
                    {
                        "username": "0nakul",
                        "content": "Here are some hints to help you solve this problem:\\n\\nOne approach to solving this problem is to use a sliding window approach, where you iterate through the string and extract 10-letter substrings as you go.\\n\\nYou can use a hash map or dictionary to keep track of the substrings that you have seen so far. If you encounter a substring that you have seen before, you know that it is a repeating sequence.\\n"
                    },
                    {
                        "username": "FanLion",
                        "content": "For example,\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nWell, why \"ACCCCCAAAA\" , \"AACCCCCAAA\" , \"AAACCCCCAA\" , \"AAAACCCCCA\" need not return ?"
                    },
                    {
                        "username": "jie24",
                        "content": "As my understanding before, the unordered_map<int,int> is a map from integer to another integer. So the key integer will increase but not keep static?"
                    },
                    {
                        "username": "changhaz",
                        "content": "Since there are only four possibilities for each char, we could use 2 bit to represent one char and assign them value like: 00 for A, 01 for C 10 for G and 11 for T.\\n\\nThus each 10 char substring could be transformed into 20 bits. We use a 32-bit int to represent the 10 char sequence. After we have the first 10 chars and move forward, we add the new char and remove the left-most char. We could use some bit operation to represent this update.\\n\\nWhenever we have a int value, we insert it into a map, which counts the occurrence of each int value.\\n\\nFinally we find out all the int value that appears more than once and transform them back to 10 char string.\\n\\nMy code could be found here\\n\\n[https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/][1]\\n\\nAny better ideas?\\n\\n\\n  [1]: https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/"
                    },
                    {
                        "username": "21manavgoel",
                        "content": "for those not able to come up with an approach, u basically have to make a freq map of every 10letter sequence possible from s, then simply return those occuring more than once"
                    },
                    {
                        "username": "nazimazhaan17",
                        "content": "the dopamine rush i get after solving a medium-hard Q in 1 go >>>>> :)"
                    },
                    {
                        "username": "ankit1478",
                        "content": "1. run loop from s.length()-10;\n2.string Dna =s.substring(i,i+10);\n3.Use HashSet to track Seen \n4.And Use Another HashSet to if already seen then it is our answer so return it ..\nand Enjoy\n\nCode Link\nhttps://leetcode.com/problems/repeated-dna-sequences/solutions/3963957/java-code/"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "Man i\\'m passing 30 of 31 tests but hitting a time limit exceeded limit on the very last test, lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "Redo the solution using a TRIE (a prefix tree) :)    It\\'s a good thing to know how to implement anyway."
                    },
                    {
                        "username": "Furies",
                        "content": "One way to make this problem more challenging is to require the repeating sequence to not overlap the previous appearances - I think that is what really matters in biology too."
                    }
                ]
            },
            {
                "id": 1571394,
                "content": [
                    {
                        "username": "vizzy205",
                        "content": "Don\\'t return sequences of length 10 if they occur only once. Just those which occur more than once."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Thanks [@Vizzy](/vizzy205) i really appreciate your hint. it allowed me to solve on my own."
                    },
                    {
                        "username": "0nakul",
                        "content": "Here are some hints to help you solve this problem:\\n\\nOne approach to solving this problem is to use a sliding window approach, where you iterate through the string and extract 10-letter substrings as you go.\\n\\nYou can use a hash map or dictionary to keep track of the substrings that you have seen so far. If you encounter a substring that you have seen before, you know that it is a repeating sequence.\\n"
                    },
                    {
                        "username": "FanLion",
                        "content": "For example,\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nWell, why \"ACCCCCAAAA\" , \"AACCCCCAAA\" , \"AAACCCCCAA\" , \"AAAACCCCCA\" need not return ?"
                    },
                    {
                        "username": "jie24",
                        "content": "As my understanding before, the unordered_map<int,int> is a map from integer to another integer. So the key integer will increase but not keep static?"
                    },
                    {
                        "username": "changhaz",
                        "content": "Since there are only four possibilities for each char, we could use 2 bit to represent one char and assign them value like: 00 for A, 01 for C 10 for G and 11 for T.\\n\\nThus each 10 char substring could be transformed into 20 bits. We use a 32-bit int to represent the 10 char sequence. After we have the first 10 chars and move forward, we add the new char and remove the left-most char. We could use some bit operation to represent this update.\\n\\nWhenever we have a int value, we insert it into a map, which counts the occurrence of each int value.\\n\\nFinally we find out all the int value that appears more than once and transform them back to 10 char string.\\n\\nMy code could be found here\\n\\n[https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/][1]\\n\\nAny better ideas?\\n\\n\\n  [1]: https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/"
                    },
                    {
                        "username": "21manavgoel",
                        "content": "for those not able to come up with an approach, u basically have to make a freq map of every 10letter sequence possible from s, then simply return those occuring more than once"
                    },
                    {
                        "username": "nazimazhaan17",
                        "content": "the dopamine rush i get after solving a medium-hard Q in 1 go >>>>> :)"
                    },
                    {
                        "username": "ankit1478",
                        "content": "1. run loop from s.length()-10;\n2.string Dna =s.substring(i,i+10);\n3.Use HashSet to track Seen \n4.And Use Another HashSet to if already seen then it is our answer so return it ..\nand Enjoy\n\nCode Link\nhttps://leetcode.com/problems/repeated-dna-sequences/solutions/3963957/java-code/"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "Man i\\'m passing 30 of 31 tests but hitting a time limit exceeded limit on the very last test, lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "Redo the solution using a TRIE (a prefix tree) :)    It\\'s a good thing to know how to implement anyway."
                    },
                    {
                        "username": "Furies",
                        "content": "One way to make this problem more challenging is to require the repeating sequence to not overlap the previous appearances - I think that is what really matters in biology too."
                    }
                ]
            },
            {
                "id": 1571395,
                "content": [
                    {
                        "username": "vizzy205",
                        "content": "Don\\'t return sequences of length 10 if they occur only once. Just those which occur more than once."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Thanks [@Vizzy](/vizzy205) i really appreciate your hint. it allowed me to solve on my own."
                    },
                    {
                        "username": "0nakul",
                        "content": "Here are some hints to help you solve this problem:\\n\\nOne approach to solving this problem is to use a sliding window approach, where you iterate through the string and extract 10-letter substrings as you go.\\n\\nYou can use a hash map or dictionary to keep track of the substrings that you have seen so far. If you encounter a substring that you have seen before, you know that it is a repeating sequence.\\n"
                    },
                    {
                        "username": "FanLion",
                        "content": "For example,\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nWell, why \"ACCCCCAAAA\" , \"AACCCCCAAA\" , \"AAACCCCCAA\" , \"AAAACCCCCA\" need not return ?"
                    },
                    {
                        "username": "jie24",
                        "content": "As my understanding before, the unordered_map<int,int> is a map from integer to another integer. So the key integer will increase but not keep static?"
                    },
                    {
                        "username": "changhaz",
                        "content": "Since there are only four possibilities for each char, we could use 2 bit to represent one char and assign them value like: 00 for A, 01 for C 10 for G and 11 for T.\\n\\nThus each 10 char substring could be transformed into 20 bits. We use a 32-bit int to represent the 10 char sequence. After we have the first 10 chars and move forward, we add the new char and remove the left-most char. We could use some bit operation to represent this update.\\n\\nWhenever we have a int value, we insert it into a map, which counts the occurrence of each int value.\\n\\nFinally we find out all the int value that appears more than once and transform them back to 10 char string.\\n\\nMy code could be found here\\n\\n[https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/][1]\\n\\nAny better ideas?\\n\\n\\n  [1]: https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/"
                    },
                    {
                        "username": "21manavgoel",
                        "content": "for those not able to come up with an approach, u basically have to make a freq map of every 10letter sequence possible from s, then simply return those occuring more than once"
                    },
                    {
                        "username": "nazimazhaan17",
                        "content": "the dopamine rush i get after solving a medium-hard Q in 1 go >>>>> :)"
                    },
                    {
                        "username": "ankit1478",
                        "content": "1. run loop from s.length()-10;\n2.string Dna =s.substring(i,i+10);\n3.Use HashSet to track Seen \n4.And Use Another HashSet to if already seen then it is our answer so return it ..\nand Enjoy\n\nCode Link\nhttps://leetcode.com/problems/repeated-dna-sequences/solutions/3963957/java-code/"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "Man i\\'m passing 30 of 31 tests but hitting a time limit exceeded limit on the very last test, lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "Redo the solution using a TRIE (a prefix tree) :)    It\\'s a good thing to know how to implement anyway."
                    },
                    {
                        "username": "Furies",
                        "content": "One way to make this problem more challenging is to require the repeating sequence to not overlap the previous appearances - I think that is what really matters in biology too."
                    }
                ]
            },
            {
                "id": 2060837,
                "content": [
                    {
                        "username": "vizzy205",
                        "content": "Don\\'t return sequences of length 10 if they occur only once. Just those which occur more than once."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Thanks [@Vizzy](/vizzy205) i really appreciate your hint. it allowed me to solve on my own."
                    },
                    {
                        "username": "0nakul",
                        "content": "Here are some hints to help you solve this problem:\\n\\nOne approach to solving this problem is to use a sliding window approach, where you iterate through the string and extract 10-letter substrings as you go.\\n\\nYou can use a hash map or dictionary to keep track of the substrings that you have seen so far. If you encounter a substring that you have seen before, you know that it is a repeating sequence.\\n"
                    },
                    {
                        "username": "FanLion",
                        "content": "For example,\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nWell, why \"ACCCCCAAAA\" , \"AACCCCCAAA\" , \"AAACCCCCAA\" , \"AAAACCCCCA\" need not return ?"
                    },
                    {
                        "username": "jie24",
                        "content": "As my understanding before, the unordered_map<int,int> is a map from integer to another integer. So the key integer will increase but not keep static?"
                    },
                    {
                        "username": "changhaz",
                        "content": "Since there are only four possibilities for each char, we could use 2 bit to represent one char and assign them value like: 00 for A, 01 for C 10 for G and 11 for T.\\n\\nThus each 10 char substring could be transformed into 20 bits. We use a 32-bit int to represent the 10 char sequence. After we have the first 10 chars and move forward, we add the new char and remove the left-most char. We could use some bit operation to represent this update.\\n\\nWhenever we have a int value, we insert it into a map, which counts the occurrence of each int value.\\n\\nFinally we find out all the int value that appears more than once and transform them back to 10 char string.\\n\\nMy code could be found here\\n\\n[https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/][1]\\n\\nAny better ideas?\\n\\n\\n  [1]: https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/"
                    },
                    {
                        "username": "21manavgoel",
                        "content": "for those not able to come up with an approach, u basically have to make a freq map of every 10letter sequence possible from s, then simply return those occuring more than once"
                    },
                    {
                        "username": "nazimazhaan17",
                        "content": "the dopamine rush i get after solving a medium-hard Q in 1 go >>>>> :)"
                    },
                    {
                        "username": "ankit1478",
                        "content": "1. run loop from s.length()-10;\n2.string Dna =s.substring(i,i+10);\n3.Use HashSet to track Seen \n4.And Use Another HashSet to if already seen then it is our answer so return it ..\nand Enjoy\n\nCode Link\nhttps://leetcode.com/problems/repeated-dna-sequences/solutions/3963957/java-code/"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "Man i\\'m passing 30 of 31 tests but hitting a time limit exceeded limit on the very last test, lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "Redo the solution using a TRIE (a prefix tree) :)    It\\'s a good thing to know how to implement anyway."
                    },
                    {
                        "username": "Furies",
                        "content": "One way to make this problem more challenging is to require the repeating sequence to not overlap the previous appearances - I think that is what really matters in biology too."
                    }
                ]
            },
            {
                "id": 2043046,
                "content": [
                    {
                        "username": "vizzy205",
                        "content": "Don\\'t return sequences of length 10 if they occur only once. Just those which occur more than once."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Thanks [@Vizzy](/vizzy205) i really appreciate your hint. it allowed me to solve on my own."
                    },
                    {
                        "username": "0nakul",
                        "content": "Here are some hints to help you solve this problem:\\n\\nOne approach to solving this problem is to use a sliding window approach, where you iterate through the string and extract 10-letter substrings as you go.\\n\\nYou can use a hash map or dictionary to keep track of the substrings that you have seen so far. If you encounter a substring that you have seen before, you know that it is a repeating sequence.\\n"
                    },
                    {
                        "username": "FanLion",
                        "content": "For example,\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nWell, why \"ACCCCCAAAA\" , \"AACCCCCAAA\" , \"AAACCCCCAA\" , \"AAAACCCCCA\" need not return ?"
                    },
                    {
                        "username": "jie24",
                        "content": "As my understanding before, the unordered_map<int,int> is a map from integer to another integer. So the key integer will increase but not keep static?"
                    },
                    {
                        "username": "changhaz",
                        "content": "Since there are only four possibilities for each char, we could use 2 bit to represent one char and assign them value like: 00 for A, 01 for C 10 for G and 11 for T.\\n\\nThus each 10 char substring could be transformed into 20 bits. We use a 32-bit int to represent the 10 char sequence. After we have the first 10 chars and move forward, we add the new char and remove the left-most char. We could use some bit operation to represent this update.\\n\\nWhenever we have a int value, we insert it into a map, which counts the occurrence of each int value.\\n\\nFinally we find out all the int value that appears more than once and transform them back to 10 char string.\\n\\nMy code could be found here\\n\\n[https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/][1]\\n\\nAny better ideas?\\n\\n\\n  [1]: https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/"
                    },
                    {
                        "username": "21manavgoel",
                        "content": "for those not able to come up with an approach, u basically have to make a freq map of every 10letter sequence possible from s, then simply return those occuring more than once"
                    },
                    {
                        "username": "nazimazhaan17",
                        "content": "the dopamine rush i get after solving a medium-hard Q in 1 go >>>>> :)"
                    },
                    {
                        "username": "ankit1478",
                        "content": "1. run loop from s.length()-10;\n2.string Dna =s.substring(i,i+10);\n3.Use HashSet to track Seen \n4.And Use Another HashSet to if already seen then it is our answer so return it ..\nand Enjoy\n\nCode Link\nhttps://leetcode.com/problems/repeated-dna-sequences/solutions/3963957/java-code/"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "Man i\\'m passing 30 of 31 tests but hitting a time limit exceeded limit on the very last test, lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "Redo the solution using a TRIE (a prefix tree) :)    It\\'s a good thing to know how to implement anyway."
                    },
                    {
                        "username": "Furies",
                        "content": "One way to make this problem more challenging is to require the repeating sequence to not overlap the previous appearances - I think that is what really matters in biology too."
                    }
                ]
            },
            {
                "id": 2031466,
                "content": [
                    {
                        "username": "vizzy205",
                        "content": "Don\\'t return sequences of length 10 if they occur only once. Just those which occur more than once."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Thanks [@Vizzy](/vizzy205) i really appreciate your hint. it allowed me to solve on my own."
                    },
                    {
                        "username": "0nakul",
                        "content": "Here are some hints to help you solve this problem:\\n\\nOne approach to solving this problem is to use a sliding window approach, where you iterate through the string and extract 10-letter substrings as you go.\\n\\nYou can use a hash map or dictionary to keep track of the substrings that you have seen so far. If you encounter a substring that you have seen before, you know that it is a repeating sequence.\\n"
                    },
                    {
                        "username": "FanLion",
                        "content": "For example,\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nWell, why \"ACCCCCAAAA\" , \"AACCCCCAAA\" , \"AAACCCCCAA\" , \"AAAACCCCCA\" need not return ?"
                    },
                    {
                        "username": "jie24",
                        "content": "As my understanding before, the unordered_map<int,int> is a map from integer to another integer. So the key integer will increase but not keep static?"
                    },
                    {
                        "username": "changhaz",
                        "content": "Since there are only four possibilities for each char, we could use 2 bit to represent one char and assign them value like: 00 for A, 01 for C 10 for G and 11 for T.\\n\\nThus each 10 char substring could be transformed into 20 bits. We use a 32-bit int to represent the 10 char sequence. After we have the first 10 chars and move forward, we add the new char and remove the left-most char. We could use some bit operation to represent this update.\\n\\nWhenever we have a int value, we insert it into a map, which counts the occurrence of each int value.\\n\\nFinally we find out all the int value that appears more than once and transform them back to 10 char string.\\n\\nMy code could be found here\\n\\n[https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/][1]\\n\\nAny better ideas?\\n\\n\\n  [1]: https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/"
                    },
                    {
                        "username": "21manavgoel",
                        "content": "for those not able to come up with an approach, u basically have to make a freq map of every 10letter sequence possible from s, then simply return those occuring more than once"
                    },
                    {
                        "username": "nazimazhaan17",
                        "content": "the dopamine rush i get after solving a medium-hard Q in 1 go >>>>> :)"
                    },
                    {
                        "username": "ankit1478",
                        "content": "1. run loop from s.length()-10;\n2.string Dna =s.substring(i,i+10);\n3.Use HashSet to track Seen \n4.And Use Another HashSet to if already seen then it is our answer so return it ..\nand Enjoy\n\nCode Link\nhttps://leetcode.com/problems/repeated-dna-sequences/solutions/3963957/java-code/"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "Man i\\'m passing 30 of 31 tests but hitting a time limit exceeded limit on the very last test, lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "Redo the solution using a TRIE (a prefix tree) :)    It\\'s a good thing to know how to implement anyway."
                    },
                    {
                        "username": "Furies",
                        "content": "One way to make this problem more challenging is to require the repeating sequence to not overlap the previous appearances - I think that is what really matters in biology too."
                    }
                ]
            },
            {
                "id": 1961092,
                "content": [
                    {
                        "username": "vizzy205",
                        "content": "Don\\'t return sequences of length 10 if they occur only once. Just those which occur more than once."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Thanks [@Vizzy](/vizzy205) i really appreciate your hint. it allowed me to solve on my own."
                    },
                    {
                        "username": "0nakul",
                        "content": "Here are some hints to help you solve this problem:\\n\\nOne approach to solving this problem is to use a sliding window approach, where you iterate through the string and extract 10-letter substrings as you go.\\n\\nYou can use a hash map or dictionary to keep track of the substrings that you have seen so far. If you encounter a substring that you have seen before, you know that it is a repeating sequence.\\n"
                    },
                    {
                        "username": "FanLion",
                        "content": "For example,\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nWell, why \"ACCCCCAAAA\" , \"AACCCCCAAA\" , \"AAACCCCCAA\" , \"AAAACCCCCA\" need not return ?"
                    },
                    {
                        "username": "jie24",
                        "content": "As my understanding before, the unordered_map<int,int> is a map from integer to another integer. So the key integer will increase but not keep static?"
                    },
                    {
                        "username": "changhaz",
                        "content": "Since there are only four possibilities for each char, we could use 2 bit to represent one char and assign them value like: 00 for A, 01 for C 10 for G and 11 for T.\\n\\nThus each 10 char substring could be transformed into 20 bits. We use a 32-bit int to represent the 10 char sequence. After we have the first 10 chars and move forward, we add the new char and remove the left-most char. We could use some bit operation to represent this update.\\n\\nWhenever we have a int value, we insert it into a map, which counts the occurrence of each int value.\\n\\nFinally we find out all the int value that appears more than once and transform them back to 10 char string.\\n\\nMy code could be found here\\n\\n[https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/][1]\\n\\nAny better ideas?\\n\\n\\n  [1]: https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/"
                    },
                    {
                        "username": "21manavgoel",
                        "content": "for those not able to come up with an approach, u basically have to make a freq map of every 10letter sequence possible from s, then simply return those occuring more than once"
                    },
                    {
                        "username": "nazimazhaan17",
                        "content": "the dopamine rush i get after solving a medium-hard Q in 1 go >>>>> :)"
                    },
                    {
                        "username": "ankit1478",
                        "content": "1. run loop from s.length()-10;\n2.string Dna =s.substring(i,i+10);\n3.Use HashSet to track Seen \n4.And Use Another HashSet to if already seen then it is our answer so return it ..\nand Enjoy\n\nCode Link\nhttps://leetcode.com/problems/repeated-dna-sequences/solutions/3963957/java-code/"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "Man i\\'m passing 30 of 31 tests but hitting a time limit exceeded limit on the very last test, lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "Redo the solution using a TRIE (a prefix tree) :)    It\\'s a good thing to know how to implement anyway."
                    },
                    {
                        "username": "Furies",
                        "content": "One way to make this problem more challenging is to require the repeating sequence to not overlap the previous appearances - I think that is what really matters in biology too."
                    }
                ]
            },
            {
                "id": 1796060,
                "content": [
                    {
                        "username": "vizzy205",
                        "content": "Don\\'t return sequences of length 10 if they occur only once. Just those which occur more than once."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Thanks [@Vizzy](/vizzy205) i really appreciate your hint. it allowed me to solve on my own."
                    },
                    {
                        "username": "0nakul",
                        "content": "Here are some hints to help you solve this problem:\\n\\nOne approach to solving this problem is to use a sliding window approach, where you iterate through the string and extract 10-letter substrings as you go.\\n\\nYou can use a hash map or dictionary to keep track of the substrings that you have seen so far. If you encounter a substring that you have seen before, you know that it is a repeating sequence.\\n"
                    },
                    {
                        "username": "FanLion",
                        "content": "For example,\\n\\nGiven s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\\n\\nReturn:\\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\\n\\nWell, why \"ACCCCCAAAA\" , \"AACCCCCAAA\" , \"AAACCCCCAA\" , \"AAAACCCCCA\" need not return ?"
                    },
                    {
                        "username": "jie24",
                        "content": "As my understanding before, the unordered_map<int,int> is a map from integer to another integer. So the key integer will increase but not keep static?"
                    },
                    {
                        "username": "changhaz",
                        "content": "Since there are only four possibilities for each char, we could use 2 bit to represent one char and assign them value like: 00 for A, 01 for C 10 for G and 11 for T.\\n\\nThus each 10 char substring could be transformed into 20 bits. We use a 32-bit int to represent the 10 char sequence. After we have the first 10 chars and move forward, we add the new char and remove the left-most char. We could use some bit operation to represent this update.\\n\\nWhenever we have a int value, we insert it into a map, which counts the occurrence of each int value.\\n\\nFinally we find out all the int value that appears more than once and transform them back to 10 char string.\\n\\nMy code could be found here\\n\\n[https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/][1]\\n\\nAny better ideas?\\n\\n\\n  [1]: https://changhaz.wordpress.com/2015/02/05/leetcode-repeated-dna-sequences/"
                    },
                    {
                        "username": "21manavgoel",
                        "content": "for those not able to come up with an approach, u basically have to make a freq map of every 10letter sequence possible from s, then simply return those occuring more than once"
                    },
                    {
                        "username": "nazimazhaan17",
                        "content": "the dopamine rush i get after solving a medium-hard Q in 1 go >>>>> :)"
                    },
                    {
                        "username": "ankit1478",
                        "content": "1. run loop from s.length()-10;\n2.string Dna =s.substring(i,i+10);\n3.Use HashSet to track Seen \n4.And Use Another HashSet to if already seen then it is our answer so return it ..\nand Enjoy\n\nCode Link\nhttps://leetcode.com/problems/repeated-dna-sequences/solutions/3963957/java-code/"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "Man i\\'m passing 30 of 31 tests but hitting a time limit exceeded limit on the very last test, lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "Redo the solution using a TRIE (a prefix tree) :)    It\\'s a good thing to know how to implement anyway."
                    },
                    {
                        "username": "Furies",
                        "content": "One way to make this problem more challenging is to require the repeating sequence to not overlap the previous appearances - I think that is what really matters in biology too."
                    }
                ]
            }
        ]
    }
]