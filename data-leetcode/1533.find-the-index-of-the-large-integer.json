[
    {
        "title": "Find the Index of the Large Integer",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1759850,
                "content": [
                    {
                        "username": "chornox",
                        "content": "The problem is just a binary search problem using ```reader.compareSub(l, r, x, y)``` method. \\nThe important part is how to choose the correct l, r, x, y for the recursive call. Once you have this part, it should be easy to implement. "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "getting sigabort for program\\nfailing an assertion \"a <= b\" with testcase 1.\\n\\nplease fix it."
                    },
                    {
                        "username": "chornox",
                        "content": "Make sure your limits are correct by checking if you break the assertion when ```l > r || x > y```"
                    },
                    {
                        "username": "FrankLampard",
                        "content": "#### Hi all, now i will provide my solutions on these two follow up questions. Let me know if they are correct or not.\\n\\n<br/>\\n\\n### First follow up (What if there are two numbers in arr that are bigger than all other numbers?)\\n**When the original array length is even**, then we will split the array into two halves. **Please note that now the array has smallest possible length to be 4.** (4 <= arr.length <= 5 * 10^5)\\n\\n1. If the compare result is equal (0), that means the two bigger numbers are the same. Then we can just reuse similar solution we wrote for the basic question to find out the bigger number in either half.\\n\\n2. If the compare result not equal, that means the biggest number must exists in the bigger half. However both bigger numbers might be located in the bigger half as well. We should first check if we are able to find a bigger number in the smaller half. Because the original array length is even, then we can just do one comparasion O(1) to find out that for the smaller half.\\n\\t* If we cannot find a bigger number in the smaller half, that means both bigger numbers are in the bigger part. Then we only exclude our target must not exist in the smaller half. We will reapply the follow up solution for the bigger part.\\n\\t*  If we are able to find a bigger number in the smaller half, that means the biggest number is in the bigger half, and the second biggest number is in the smaller half. We can use similar solution we wrote for the basic question to find out the bigger number in the second part.\\n\\n**When the original array length is odd**, then we will split the array into three parts [0, mid - 1], [mid, mid], [mid + 1, length - 1]. I will call these three as first part, middle number, and second part in the explanation below. We will comapre first part [0, mid - 1] and second part [mid + 1, length - 1]. **Please note that now the length of the array has smallest possible number to be 3.**\\n\\n1. If the compare result is equal (0), that means the middle number is not one of the two bigger numbers. And also the bigger numbers are the same. One of them is in the first part and the other is in the second part. We can use similar solution we wrote for the basic question to find out the bigger number in the either the first or second part.\\n\\n2. If the compare result not equal, that means the one of the bigger numbers must exists in the bigger half. However there might be two possible scenarios: \\n\\t* Both two bigger numbers might be in the bigger half.\\n\\t* The middle number could be the other bigger number.\\n\\n    So we should distinguish between these two scenarios!\\n\\t\\n\\tSince we are sure that the smaller part has all its elements to be equal, we will compare the middle number with any number in the smaller part.\\n\\t* If the middle number is the same as the first element in the smaller part, then it means both two bigger numbers are in the bigger half. Since the bigger half is even length, we can use the follow up solution for arrays with even length.\\n\\t* If the middle number is bigger than the first element in the smaller part, then it means in the bigger part we can find only one bigger number. We can use similar solution we wrote for the basic question to find out the bigger number in the bigger part. Then we will compare the bigger number in the bigger part and the middle number to find out which one is bigger and it will be the biggest number in the end.\\n\\n\\n<br/>\\n\\n### Second follow up(What if there is one number that is bigger than other numbers and one number that is smaller than other numbers?)\\nIf we have arrays like this [50,50,50,50,50,50,50,50,1,99], we might need to compare all adjacent elements pairs. So the worst case will be O(arr.length). **Not sure if will be better solution on this?**\\n\\n\\n\\n<br/>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What the hell is this question?? Do things like this actually occur while coding for companies?\\n"
                    },
                    {
                        "username": "jas213",
                        "content": "ALERT- close to solution but not quite - \nanyone knows what's wrong with this code?\n\n `\nclass Solution:\n    def getIndex(self, reader: 'ArrayReader') -> int:\n\n        n = reader.length()\n        l, r = 0, n-1\n\n        while (l < r):\n            mid = (l+r)//2\n            count +=1\n            if reader.compareSub(l, mid, mid+1, r) == 1:\n                r=mid\n            else:\n                l = mid+1\n        return l\n`"
                    },
                    {
                        "username": "st-ones",
                        "content": "Don\\'t forget about curly braces for `length()` in js :)"
                    },
                    {
                        "username": "mxn42",
                        "content": "Ternary Search is better, it's $$O(log_3 N)$$ instead of $$O(log_2 N)$$\nhttps://en.wikipedia.org/wiki/Ternary_search\n\nThis problem is similar to the [Balance puzzle](https://en.wikipedia.org/wiki/Balance_puzzle).\n\nEach time divide the interval into 3 thirds. Compare 2 of them. If one is heavier, we'll search in it. If they are equal, we'll search in the rest third.\n\n[JavaScript solution](https://leetcode.com/problems/find-the-index-of-the-large-integer/solutions/3060122/javascript-neat-ternary-search-o-log3-n/)"
                    },
                    {
                        "username": "ramtulasi19",
                        "content": "question explanation is unclear!!"
                    }
                ]
            },
            {
                "id": 1728856,
                "content": [
                    {
                        "username": "chornox",
                        "content": "The problem is just a binary search problem using ```reader.compareSub(l, r, x, y)``` method. \\nThe important part is how to choose the correct l, r, x, y for the recursive call. Once you have this part, it should be easy to implement. "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "getting sigabort for program\\nfailing an assertion \"a <= b\" with testcase 1.\\n\\nplease fix it."
                    },
                    {
                        "username": "chornox",
                        "content": "Make sure your limits are correct by checking if you break the assertion when ```l > r || x > y```"
                    },
                    {
                        "username": "FrankLampard",
                        "content": "#### Hi all, now i will provide my solutions on these two follow up questions. Let me know if they are correct or not.\\n\\n<br/>\\n\\n### First follow up (What if there are two numbers in arr that are bigger than all other numbers?)\\n**When the original array length is even**, then we will split the array into two halves. **Please note that now the array has smallest possible length to be 4.** (4 <= arr.length <= 5 * 10^5)\\n\\n1. If the compare result is equal (0), that means the two bigger numbers are the same. Then we can just reuse similar solution we wrote for the basic question to find out the bigger number in either half.\\n\\n2. If the compare result not equal, that means the biggest number must exists in the bigger half. However both bigger numbers might be located in the bigger half as well. We should first check if we are able to find a bigger number in the smaller half. Because the original array length is even, then we can just do one comparasion O(1) to find out that for the smaller half.\\n\\t* If we cannot find a bigger number in the smaller half, that means both bigger numbers are in the bigger part. Then we only exclude our target must not exist in the smaller half. We will reapply the follow up solution for the bigger part.\\n\\t*  If we are able to find a bigger number in the smaller half, that means the biggest number is in the bigger half, and the second biggest number is in the smaller half. We can use similar solution we wrote for the basic question to find out the bigger number in the second part.\\n\\n**When the original array length is odd**, then we will split the array into three parts [0, mid - 1], [mid, mid], [mid + 1, length - 1]. I will call these three as first part, middle number, and second part in the explanation below. We will comapre first part [0, mid - 1] and second part [mid + 1, length - 1]. **Please note that now the length of the array has smallest possible number to be 3.**\\n\\n1. If the compare result is equal (0), that means the middle number is not one of the two bigger numbers. And also the bigger numbers are the same. One of them is in the first part and the other is in the second part. We can use similar solution we wrote for the basic question to find out the bigger number in the either the first or second part.\\n\\n2. If the compare result not equal, that means the one of the bigger numbers must exists in the bigger half. However there might be two possible scenarios: \\n\\t* Both two bigger numbers might be in the bigger half.\\n\\t* The middle number could be the other bigger number.\\n\\n    So we should distinguish between these two scenarios!\\n\\t\\n\\tSince we are sure that the smaller part has all its elements to be equal, we will compare the middle number with any number in the smaller part.\\n\\t* If the middle number is the same as the first element in the smaller part, then it means both two bigger numbers are in the bigger half. Since the bigger half is even length, we can use the follow up solution for arrays with even length.\\n\\t* If the middle number is bigger than the first element in the smaller part, then it means in the bigger part we can find only one bigger number. We can use similar solution we wrote for the basic question to find out the bigger number in the bigger part. Then we will compare the bigger number in the bigger part and the middle number to find out which one is bigger and it will be the biggest number in the end.\\n\\n\\n<br/>\\n\\n### Second follow up(What if there is one number that is bigger than other numbers and one number that is smaller than other numbers?)\\nIf we have arrays like this [50,50,50,50,50,50,50,50,1,99], we might need to compare all adjacent elements pairs. So the worst case will be O(arr.length). **Not sure if will be better solution on this?**\\n\\n\\n\\n<br/>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What the hell is this question?? Do things like this actually occur while coding for companies?\\n"
                    },
                    {
                        "username": "jas213",
                        "content": "ALERT- close to solution but not quite - \nanyone knows what's wrong with this code?\n\n `\nclass Solution:\n    def getIndex(self, reader: 'ArrayReader') -> int:\n\n        n = reader.length()\n        l, r = 0, n-1\n\n        while (l < r):\n            mid = (l+r)//2\n            count +=1\n            if reader.compareSub(l, mid, mid+1, r) == 1:\n                r=mid\n            else:\n                l = mid+1\n        return l\n`"
                    },
                    {
                        "username": "st-ones",
                        "content": "Don\\'t forget about curly braces for `length()` in js :)"
                    },
                    {
                        "username": "mxn42",
                        "content": "Ternary Search is better, it's $$O(log_3 N)$$ instead of $$O(log_2 N)$$\nhttps://en.wikipedia.org/wiki/Ternary_search\n\nThis problem is similar to the [Balance puzzle](https://en.wikipedia.org/wiki/Balance_puzzle).\n\nEach time divide the interval into 3 thirds. Compare 2 of them. If one is heavier, we'll search in it. If they are equal, we'll search in the rest third.\n\n[JavaScript solution](https://leetcode.com/problems/find-the-index-of-the-large-integer/solutions/3060122/javascript-neat-ternary-search-o-log3-n/)"
                    },
                    {
                        "username": "ramtulasi19",
                        "content": "question explanation is unclear!!"
                    }
                ]
            },
            {
                "id": 1574231,
                "content": [
                    {
                        "username": "chornox",
                        "content": "The problem is just a binary search problem using ```reader.compareSub(l, r, x, y)``` method. \\nThe important part is how to choose the correct l, r, x, y for the recursive call. Once you have this part, it should be easy to implement. "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "getting sigabort for program\\nfailing an assertion \"a <= b\" with testcase 1.\\n\\nplease fix it."
                    },
                    {
                        "username": "chornox",
                        "content": "Make sure your limits are correct by checking if you break the assertion when ```l > r || x > y```"
                    },
                    {
                        "username": "FrankLampard",
                        "content": "#### Hi all, now i will provide my solutions on these two follow up questions. Let me know if they are correct or not.\\n\\n<br/>\\n\\n### First follow up (What if there are two numbers in arr that are bigger than all other numbers?)\\n**When the original array length is even**, then we will split the array into two halves. **Please note that now the array has smallest possible length to be 4.** (4 <= arr.length <= 5 * 10^5)\\n\\n1. If the compare result is equal (0), that means the two bigger numbers are the same. Then we can just reuse similar solution we wrote for the basic question to find out the bigger number in either half.\\n\\n2. If the compare result not equal, that means the biggest number must exists in the bigger half. However both bigger numbers might be located in the bigger half as well. We should first check if we are able to find a bigger number in the smaller half. Because the original array length is even, then we can just do one comparasion O(1) to find out that for the smaller half.\\n\\t* If we cannot find a bigger number in the smaller half, that means both bigger numbers are in the bigger part. Then we only exclude our target must not exist in the smaller half. We will reapply the follow up solution for the bigger part.\\n\\t*  If we are able to find a bigger number in the smaller half, that means the biggest number is in the bigger half, and the second biggest number is in the smaller half. We can use similar solution we wrote for the basic question to find out the bigger number in the second part.\\n\\n**When the original array length is odd**, then we will split the array into three parts [0, mid - 1], [mid, mid], [mid + 1, length - 1]. I will call these three as first part, middle number, and second part in the explanation below. We will comapre first part [0, mid - 1] and second part [mid + 1, length - 1]. **Please note that now the length of the array has smallest possible number to be 3.**\\n\\n1. If the compare result is equal (0), that means the middle number is not one of the two bigger numbers. And also the bigger numbers are the same. One of them is in the first part and the other is in the second part. We can use similar solution we wrote for the basic question to find out the bigger number in the either the first or second part.\\n\\n2. If the compare result not equal, that means the one of the bigger numbers must exists in the bigger half. However there might be two possible scenarios: \\n\\t* Both two bigger numbers might be in the bigger half.\\n\\t* The middle number could be the other bigger number.\\n\\n    So we should distinguish between these two scenarios!\\n\\t\\n\\tSince we are sure that the smaller part has all its elements to be equal, we will compare the middle number with any number in the smaller part.\\n\\t* If the middle number is the same as the first element in the smaller part, then it means both two bigger numbers are in the bigger half. Since the bigger half is even length, we can use the follow up solution for arrays with even length.\\n\\t* If the middle number is bigger than the first element in the smaller part, then it means in the bigger part we can find only one bigger number. We can use similar solution we wrote for the basic question to find out the bigger number in the bigger part. Then we will compare the bigger number in the bigger part and the middle number to find out which one is bigger and it will be the biggest number in the end.\\n\\n\\n<br/>\\n\\n### Second follow up(What if there is one number that is bigger than other numbers and one number that is smaller than other numbers?)\\nIf we have arrays like this [50,50,50,50,50,50,50,50,1,99], we might need to compare all adjacent elements pairs. So the worst case will be O(arr.length). **Not sure if will be better solution on this?**\\n\\n\\n\\n<br/>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What the hell is this question?? Do things like this actually occur while coding for companies?\\n"
                    },
                    {
                        "username": "jas213",
                        "content": "ALERT- close to solution but not quite - \nanyone knows what's wrong with this code?\n\n `\nclass Solution:\n    def getIndex(self, reader: 'ArrayReader') -> int:\n\n        n = reader.length()\n        l, r = 0, n-1\n\n        while (l < r):\n            mid = (l+r)//2\n            count +=1\n            if reader.compareSub(l, mid, mid+1, r) == 1:\n                r=mid\n            else:\n                l = mid+1\n        return l\n`"
                    },
                    {
                        "username": "st-ones",
                        "content": "Don\\'t forget about curly braces for `length()` in js :)"
                    },
                    {
                        "username": "mxn42",
                        "content": "Ternary Search is better, it's $$O(log_3 N)$$ instead of $$O(log_2 N)$$\nhttps://en.wikipedia.org/wiki/Ternary_search\n\nThis problem is similar to the [Balance puzzle](https://en.wikipedia.org/wiki/Balance_puzzle).\n\nEach time divide the interval into 3 thirds. Compare 2 of them. If one is heavier, we'll search in it. If they are equal, we'll search in the rest third.\n\n[JavaScript solution](https://leetcode.com/problems/find-the-index-of-the-large-integer/solutions/3060122/javascript-neat-ternary-search-o-log3-n/)"
                    },
                    {
                        "username": "ramtulasi19",
                        "content": "question explanation is unclear!!"
                    }
                ]
            },
            {
                "id": 1762301,
                "content": [
                    {
                        "username": "chornox",
                        "content": "The problem is just a binary search problem using ```reader.compareSub(l, r, x, y)``` method. \\nThe important part is how to choose the correct l, r, x, y for the recursive call. Once you have this part, it should be easy to implement. "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "getting sigabort for program\\nfailing an assertion \"a <= b\" with testcase 1.\\n\\nplease fix it."
                    },
                    {
                        "username": "chornox",
                        "content": "Make sure your limits are correct by checking if you break the assertion when ```l > r || x > y```"
                    },
                    {
                        "username": "FrankLampard",
                        "content": "#### Hi all, now i will provide my solutions on these two follow up questions. Let me know if they are correct or not.\\n\\n<br/>\\n\\n### First follow up (What if there are two numbers in arr that are bigger than all other numbers?)\\n**When the original array length is even**, then we will split the array into two halves. **Please note that now the array has smallest possible length to be 4.** (4 <= arr.length <= 5 * 10^5)\\n\\n1. If the compare result is equal (0), that means the two bigger numbers are the same. Then we can just reuse similar solution we wrote for the basic question to find out the bigger number in either half.\\n\\n2. If the compare result not equal, that means the biggest number must exists in the bigger half. However both bigger numbers might be located in the bigger half as well. We should first check if we are able to find a bigger number in the smaller half. Because the original array length is even, then we can just do one comparasion O(1) to find out that for the smaller half.\\n\\t* If we cannot find a bigger number in the smaller half, that means both bigger numbers are in the bigger part. Then we only exclude our target must not exist in the smaller half. We will reapply the follow up solution for the bigger part.\\n\\t*  If we are able to find a bigger number in the smaller half, that means the biggest number is in the bigger half, and the second biggest number is in the smaller half. We can use similar solution we wrote for the basic question to find out the bigger number in the second part.\\n\\n**When the original array length is odd**, then we will split the array into three parts [0, mid - 1], [mid, mid], [mid + 1, length - 1]. I will call these three as first part, middle number, and second part in the explanation below. We will comapre first part [0, mid - 1] and second part [mid + 1, length - 1]. **Please note that now the length of the array has smallest possible number to be 3.**\\n\\n1. If the compare result is equal (0), that means the middle number is not one of the two bigger numbers. And also the bigger numbers are the same. One of them is in the first part and the other is in the second part. We can use similar solution we wrote for the basic question to find out the bigger number in the either the first or second part.\\n\\n2. If the compare result not equal, that means the one of the bigger numbers must exists in the bigger half. However there might be two possible scenarios: \\n\\t* Both two bigger numbers might be in the bigger half.\\n\\t* The middle number could be the other bigger number.\\n\\n    So we should distinguish between these two scenarios!\\n\\t\\n\\tSince we are sure that the smaller part has all its elements to be equal, we will compare the middle number with any number in the smaller part.\\n\\t* If the middle number is the same as the first element in the smaller part, then it means both two bigger numbers are in the bigger half. Since the bigger half is even length, we can use the follow up solution for arrays with even length.\\n\\t* If the middle number is bigger than the first element in the smaller part, then it means in the bigger part we can find only one bigger number. We can use similar solution we wrote for the basic question to find out the bigger number in the bigger part. Then we will compare the bigger number in the bigger part and the middle number to find out which one is bigger and it will be the biggest number in the end.\\n\\n\\n<br/>\\n\\n### Second follow up(What if there is one number that is bigger than other numbers and one number that is smaller than other numbers?)\\nIf we have arrays like this [50,50,50,50,50,50,50,50,1,99], we might need to compare all adjacent elements pairs. So the worst case will be O(arr.length). **Not sure if will be better solution on this?**\\n\\n\\n\\n<br/>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What the hell is this question?? Do things like this actually occur while coding for companies?\\n"
                    },
                    {
                        "username": "jas213",
                        "content": "ALERT- close to solution but not quite - \nanyone knows what's wrong with this code?\n\n `\nclass Solution:\n    def getIndex(self, reader: 'ArrayReader') -> int:\n\n        n = reader.length()\n        l, r = 0, n-1\n\n        while (l < r):\n            mid = (l+r)//2\n            count +=1\n            if reader.compareSub(l, mid, mid+1, r) == 1:\n                r=mid\n            else:\n                l = mid+1\n        return l\n`"
                    },
                    {
                        "username": "st-ones",
                        "content": "Don\\'t forget about curly braces for `length()` in js :)"
                    },
                    {
                        "username": "mxn42",
                        "content": "Ternary Search is better, it's $$O(log_3 N)$$ instead of $$O(log_2 N)$$\nhttps://en.wikipedia.org/wiki/Ternary_search\n\nThis problem is similar to the [Balance puzzle](https://en.wikipedia.org/wiki/Balance_puzzle).\n\nEach time divide the interval into 3 thirds. Compare 2 of them. If one is heavier, we'll search in it. If they are equal, we'll search in the rest third.\n\n[JavaScript solution](https://leetcode.com/problems/find-the-index-of-the-large-integer/solutions/3060122/javascript-neat-ternary-search-o-log3-n/)"
                    },
                    {
                        "username": "ramtulasi19",
                        "content": "question explanation is unclear!!"
                    }
                ]
            },
            {
                "id": 1766745,
                "content": [
                    {
                        "username": "chornox",
                        "content": "The problem is just a binary search problem using ```reader.compareSub(l, r, x, y)``` method. \\nThe important part is how to choose the correct l, r, x, y for the recursive call. Once you have this part, it should be easy to implement. "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "getting sigabort for program\\nfailing an assertion \"a <= b\" with testcase 1.\\n\\nplease fix it."
                    },
                    {
                        "username": "chornox",
                        "content": "Make sure your limits are correct by checking if you break the assertion when ```l > r || x > y```"
                    },
                    {
                        "username": "FrankLampard",
                        "content": "#### Hi all, now i will provide my solutions on these two follow up questions. Let me know if they are correct or not.\\n\\n<br/>\\n\\n### First follow up (What if there are two numbers in arr that are bigger than all other numbers?)\\n**When the original array length is even**, then we will split the array into two halves. **Please note that now the array has smallest possible length to be 4.** (4 <= arr.length <= 5 * 10^5)\\n\\n1. If the compare result is equal (0), that means the two bigger numbers are the same. Then we can just reuse similar solution we wrote for the basic question to find out the bigger number in either half.\\n\\n2. If the compare result not equal, that means the biggest number must exists in the bigger half. However both bigger numbers might be located in the bigger half as well. We should first check if we are able to find a bigger number in the smaller half. Because the original array length is even, then we can just do one comparasion O(1) to find out that for the smaller half.\\n\\t* If we cannot find a bigger number in the smaller half, that means both bigger numbers are in the bigger part. Then we only exclude our target must not exist in the smaller half. We will reapply the follow up solution for the bigger part.\\n\\t*  If we are able to find a bigger number in the smaller half, that means the biggest number is in the bigger half, and the second biggest number is in the smaller half. We can use similar solution we wrote for the basic question to find out the bigger number in the second part.\\n\\n**When the original array length is odd**, then we will split the array into three parts [0, mid - 1], [mid, mid], [mid + 1, length - 1]. I will call these three as first part, middle number, and second part in the explanation below. We will comapre first part [0, mid - 1] and second part [mid + 1, length - 1]. **Please note that now the length of the array has smallest possible number to be 3.**\\n\\n1. If the compare result is equal (0), that means the middle number is not one of the two bigger numbers. And also the bigger numbers are the same. One of them is in the first part and the other is in the second part. We can use similar solution we wrote for the basic question to find out the bigger number in the either the first or second part.\\n\\n2. If the compare result not equal, that means the one of the bigger numbers must exists in the bigger half. However there might be two possible scenarios: \\n\\t* Both two bigger numbers might be in the bigger half.\\n\\t* The middle number could be the other bigger number.\\n\\n    So we should distinguish between these two scenarios!\\n\\t\\n\\tSince we are sure that the smaller part has all its elements to be equal, we will compare the middle number with any number in the smaller part.\\n\\t* If the middle number is the same as the first element in the smaller part, then it means both two bigger numbers are in the bigger half. Since the bigger half is even length, we can use the follow up solution for arrays with even length.\\n\\t* If the middle number is bigger than the first element in the smaller part, then it means in the bigger part we can find only one bigger number. We can use similar solution we wrote for the basic question to find out the bigger number in the bigger part. Then we will compare the bigger number in the bigger part and the middle number to find out which one is bigger and it will be the biggest number in the end.\\n\\n\\n<br/>\\n\\n### Second follow up(What if there is one number that is bigger than other numbers and one number that is smaller than other numbers?)\\nIf we have arrays like this [50,50,50,50,50,50,50,50,1,99], we might need to compare all adjacent elements pairs. So the worst case will be O(arr.length). **Not sure if will be better solution on this?**\\n\\n\\n\\n<br/>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What the hell is this question?? Do things like this actually occur while coding for companies?\\n"
                    },
                    {
                        "username": "jas213",
                        "content": "ALERT- close to solution but not quite - \nanyone knows what's wrong with this code?\n\n `\nclass Solution:\n    def getIndex(self, reader: 'ArrayReader') -> int:\n\n        n = reader.length()\n        l, r = 0, n-1\n\n        while (l < r):\n            mid = (l+r)//2\n            count +=1\n            if reader.compareSub(l, mid, mid+1, r) == 1:\n                r=mid\n            else:\n                l = mid+1\n        return l\n`"
                    },
                    {
                        "username": "st-ones",
                        "content": "Don\\'t forget about curly braces for `length()` in js :)"
                    },
                    {
                        "username": "mxn42",
                        "content": "Ternary Search is better, it's $$O(log_3 N)$$ instead of $$O(log_2 N)$$\nhttps://en.wikipedia.org/wiki/Ternary_search\n\nThis problem is similar to the [Balance puzzle](https://en.wikipedia.org/wiki/Balance_puzzle).\n\nEach time divide the interval into 3 thirds. Compare 2 of them. If one is heavier, we'll search in it. If they are equal, we'll search in the rest third.\n\n[JavaScript solution](https://leetcode.com/problems/find-the-index-of-the-large-integer/solutions/3060122/javascript-neat-ternary-search-o-log3-n/)"
                    },
                    {
                        "username": "ramtulasi19",
                        "content": "question explanation is unclear!!"
                    }
                ]
            },
            {
                "id": 1761932,
                "content": [
                    {
                        "username": "chornox",
                        "content": "The problem is just a binary search problem using ```reader.compareSub(l, r, x, y)``` method. \\nThe important part is how to choose the correct l, r, x, y for the recursive call. Once you have this part, it should be easy to implement. "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "getting sigabort for program\\nfailing an assertion \"a <= b\" with testcase 1.\\n\\nplease fix it."
                    },
                    {
                        "username": "chornox",
                        "content": "Make sure your limits are correct by checking if you break the assertion when ```l > r || x > y```"
                    },
                    {
                        "username": "FrankLampard",
                        "content": "#### Hi all, now i will provide my solutions on these two follow up questions. Let me know if they are correct or not.\\n\\n<br/>\\n\\n### First follow up (What if there are two numbers in arr that are bigger than all other numbers?)\\n**When the original array length is even**, then we will split the array into two halves. **Please note that now the array has smallest possible length to be 4.** (4 <= arr.length <= 5 * 10^5)\\n\\n1. If the compare result is equal (0), that means the two bigger numbers are the same. Then we can just reuse similar solution we wrote for the basic question to find out the bigger number in either half.\\n\\n2. If the compare result not equal, that means the biggest number must exists in the bigger half. However both bigger numbers might be located in the bigger half as well. We should first check if we are able to find a bigger number in the smaller half. Because the original array length is even, then we can just do one comparasion O(1) to find out that for the smaller half.\\n\\t* If we cannot find a bigger number in the smaller half, that means both bigger numbers are in the bigger part. Then we only exclude our target must not exist in the smaller half. We will reapply the follow up solution for the bigger part.\\n\\t*  If we are able to find a bigger number in the smaller half, that means the biggest number is in the bigger half, and the second biggest number is in the smaller half. We can use similar solution we wrote for the basic question to find out the bigger number in the second part.\\n\\n**When the original array length is odd**, then we will split the array into three parts [0, mid - 1], [mid, mid], [mid + 1, length - 1]. I will call these three as first part, middle number, and second part in the explanation below. We will comapre first part [0, mid - 1] and second part [mid + 1, length - 1]. **Please note that now the length of the array has smallest possible number to be 3.**\\n\\n1. If the compare result is equal (0), that means the middle number is not one of the two bigger numbers. And also the bigger numbers are the same. One of them is in the first part and the other is in the second part. We can use similar solution we wrote for the basic question to find out the bigger number in the either the first or second part.\\n\\n2. If the compare result not equal, that means the one of the bigger numbers must exists in the bigger half. However there might be two possible scenarios: \\n\\t* Both two bigger numbers might be in the bigger half.\\n\\t* The middle number could be the other bigger number.\\n\\n    So we should distinguish between these two scenarios!\\n\\t\\n\\tSince we are sure that the smaller part has all its elements to be equal, we will compare the middle number with any number in the smaller part.\\n\\t* If the middle number is the same as the first element in the smaller part, then it means both two bigger numbers are in the bigger half. Since the bigger half is even length, we can use the follow up solution for arrays with even length.\\n\\t* If the middle number is bigger than the first element in the smaller part, then it means in the bigger part we can find only one bigger number. We can use similar solution we wrote for the basic question to find out the bigger number in the bigger part. Then we will compare the bigger number in the bigger part and the middle number to find out which one is bigger and it will be the biggest number in the end.\\n\\n\\n<br/>\\n\\n### Second follow up(What if there is one number that is bigger than other numbers and one number that is smaller than other numbers?)\\nIf we have arrays like this [50,50,50,50,50,50,50,50,1,99], we might need to compare all adjacent elements pairs. So the worst case will be O(arr.length). **Not sure if will be better solution on this?**\\n\\n\\n\\n<br/>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What the hell is this question?? Do things like this actually occur while coding for companies?\\n"
                    },
                    {
                        "username": "jas213",
                        "content": "ALERT- close to solution but not quite - \nanyone knows what's wrong with this code?\n\n `\nclass Solution:\n    def getIndex(self, reader: 'ArrayReader') -> int:\n\n        n = reader.length()\n        l, r = 0, n-1\n\n        while (l < r):\n            mid = (l+r)//2\n            count +=1\n            if reader.compareSub(l, mid, mid+1, r) == 1:\n                r=mid\n            else:\n                l = mid+1\n        return l\n`"
                    },
                    {
                        "username": "st-ones",
                        "content": "Don\\'t forget about curly braces for `length()` in js :)"
                    },
                    {
                        "username": "mxn42",
                        "content": "Ternary Search is better, it's $$O(log_3 N)$$ instead of $$O(log_2 N)$$\nhttps://en.wikipedia.org/wiki/Ternary_search\n\nThis problem is similar to the [Balance puzzle](https://en.wikipedia.org/wiki/Balance_puzzle).\n\nEach time divide the interval into 3 thirds. Compare 2 of them. If one is heavier, we'll search in it. If they are equal, we'll search in the rest third.\n\n[JavaScript solution](https://leetcode.com/problems/find-the-index-of-the-large-integer/solutions/3060122/javascript-neat-ternary-search-o-log3-n/)"
                    },
                    {
                        "username": "ramtulasi19",
                        "content": "question explanation is unclear!!"
                    }
                ]
            },
            {
                "id": 1760749,
                "content": [
                    {
                        "username": "chornox",
                        "content": "The problem is just a binary search problem using ```reader.compareSub(l, r, x, y)``` method. \\nThe important part is how to choose the correct l, r, x, y for the recursive call. Once you have this part, it should be easy to implement. "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "getting sigabort for program\\nfailing an assertion \"a <= b\" with testcase 1.\\n\\nplease fix it."
                    },
                    {
                        "username": "chornox",
                        "content": "Make sure your limits are correct by checking if you break the assertion when ```l > r || x > y```"
                    },
                    {
                        "username": "FrankLampard",
                        "content": "#### Hi all, now i will provide my solutions on these two follow up questions. Let me know if they are correct or not.\\n\\n<br/>\\n\\n### First follow up (What if there are two numbers in arr that are bigger than all other numbers?)\\n**When the original array length is even**, then we will split the array into two halves. **Please note that now the array has smallest possible length to be 4.** (4 <= arr.length <= 5 * 10^5)\\n\\n1. If the compare result is equal (0), that means the two bigger numbers are the same. Then we can just reuse similar solution we wrote for the basic question to find out the bigger number in either half.\\n\\n2. If the compare result not equal, that means the biggest number must exists in the bigger half. However both bigger numbers might be located in the bigger half as well. We should first check if we are able to find a bigger number in the smaller half. Because the original array length is even, then we can just do one comparasion O(1) to find out that for the smaller half.\\n\\t* If we cannot find a bigger number in the smaller half, that means both bigger numbers are in the bigger part. Then we only exclude our target must not exist in the smaller half. We will reapply the follow up solution for the bigger part.\\n\\t*  If we are able to find a bigger number in the smaller half, that means the biggest number is in the bigger half, and the second biggest number is in the smaller half. We can use similar solution we wrote for the basic question to find out the bigger number in the second part.\\n\\n**When the original array length is odd**, then we will split the array into three parts [0, mid - 1], [mid, mid], [mid + 1, length - 1]. I will call these three as first part, middle number, and second part in the explanation below. We will comapre first part [0, mid - 1] and second part [mid + 1, length - 1]. **Please note that now the length of the array has smallest possible number to be 3.**\\n\\n1. If the compare result is equal (0), that means the middle number is not one of the two bigger numbers. And also the bigger numbers are the same. One of them is in the first part and the other is in the second part. We can use similar solution we wrote for the basic question to find out the bigger number in the either the first or second part.\\n\\n2. If the compare result not equal, that means the one of the bigger numbers must exists in the bigger half. However there might be two possible scenarios: \\n\\t* Both two bigger numbers might be in the bigger half.\\n\\t* The middle number could be the other bigger number.\\n\\n    So we should distinguish between these two scenarios!\\n\\t\\n\\tSince we are sure that the smaller part has all its elements to be equal, we will compare the middle number with any number in the smaller part.\\n\\t* If the middle number is the same as the first element in the smaller part, then it means both two bigger numbers are in the bigger half. Since the bigger half is even length, we can use the follow up solution for arrays with even length.\\n\\t* If the middle number is bigger than the first element in the smaller part, then it means in the bigger part we can find only one bigger number. We can use similar solution we wrote for the basic question to find out the bigger number in the bigger part. Then we will compare the bigger number in the bigger part and the middle number to find out which one is bigger and it will be the biggest number in the end.\\n\\n\\n<br/>\\n\\n### Second follow up(What if there is one number that is bigger than other numbers and one number that is smaller than other numbers?)\\nIf we have arrays like this [50,50,50,50,50,50,50,50,1,99], we might need to compare all adjacent elements pairs. So the worst case will be O(arr.length). **Not sure if will be better solution on this?**\\n\\n\\n\\n<br/>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What the hell is this question?? Do things like this actually occur while coding for companies?\\n"
                    },
                    {
                        "username": "jas213",
                        "content": "ALERT- close to solution but not quite - \nanyone knows what's wrong with this code?\n\n `\nclass Solution:\n    def getIndex(self, reader: 'ArrayReader') -> int:\n\n        n = reader.length()\n        l, r = 0, n-1\n\n        while (l < r):\n            mid = (l+r)//2\n            count +=1\n            if reader.compareSub(l, mid, mid+1, r) == 1:\n                r=mid\n            else:\n                l = mid+1\n        return l\n`"
                    },
                    {
                        "username": "st-ones",
                        "content": "Don\\'t forget about curly braces for `length()` in js :)"
                    },
                    {
                        "username": "mxn42",
                        "content": "Ternary Search is better, it's $$O(log_3 N)$$ instead of $$O(log_2 N)$$\nhttps://en.wikipedia.org/wiki/Ternary_search\n\nThis problem is similar to the [Balance puzzle](https://en.wikipedia.org/wiki/Balance_puzzle).\n\nEach time divide the interval into 3 thirds. Compare 2 of them. If one is heavier, we'll search in it. If they are equal, we'll search in the rest third.\n\n[JavaScript solution](https://leetcode.com/problems/find-the-index-of-the-large-integer/solutions/3060122/javascript-neat-ternary-search-o-log3-n/)"
                    },
                    {
                        "username": "ramtulasi19",
                        "content": "question explanation is unclear!!"
                    }
                ]
            },
            {
                "id": 1758483,
                "content": [
                    {
                        "username": "chornox",
                        "content": "The problem is just a binary search problem using ```reader.compareSub(l, r, x, y)``` method. \\nThe important part is how to choose the correct l, r, x, y for the recursive call. Once you have this part, it should be easy to implement. "
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "getting sigabort for program\\nfailing an assertion \"a <= b\" with testcase 1.\\n\\nplease fix it."
                    },
                    {
                        "username": "chornox",
                        "content": "Make sure your limits are correct by checking if you break the assertion when ```l > r || x > y```"
                    },
                    {
                        "username": "FrankLampard",
                        "content": "#### Hi all, now i will provide my solutions on these two follow up questions. Let me know if they are correct or not.\\n\\n<br/>\\n\\n### First follow up (What if there are two numbers in arr that are bigger than all other numbers?)\\n**When the original array length is even**, then we will split the array into two halves. **Please note that now the array has smallest possible length to be 4.** (4 <= arr.length <= 5 * 10^5)\\n\\n1. If the compare result is equal (0), that means the two bigger numbers are the same. Then we can just reuse similar solution we wrote for the basic question to find out the bigger number in either half.\\n\\n2. If the compare result not equal, that means the biggest number must exists in the bigger half. However both bigger numbers might be located in the bigger half as well. We should first check if we are able to find a bigger number in the smaller half. Because the original array length is even, then we can just do one comparasion O(1) to find out that for the smaller half.\\n\\t* If we cannot find a bigger number in the smaller half, that means both bigger numbers are in the bigger part. Then we only exclude our target must not exist in the smaller half. We will reapply the follow up solution for the bigger part.\\n\\t*  If we are able to find a bigger number in the smaller half, that means the biggest number is in the bigger half, and the second biggest number is in the smaller half. We can use similar solution we wrote for the basic question to find out the bigger number in the second part.\\n\\n**When the original array length is odd**, then we will split the array into three parts [0, mid - 1], [mid, mid], [mid + 1, length - 1]. I will call these three as first part, middle number, and second part in the explanation below. We will comapre first part [0, mid - 1] and second part [mid + 1, length - 1]. **Please note that now the length of the array has smallest possible number to be 3.**\\n\\n1. If the compare result is equal (0), that means the middle number is not one of the two bigger numbers. And also the bigger numbers are the same. One of them is in the first part and the other is in the second part. We can use similar solution we wrote for the basic question to find out the bigger number in the either the first or second part.\\n\\n2. If the compare result not equal, that means the one of the bigger numbers must exists in the bigger half. However there might be two possible scenarios: \\n\\t* Both two bigger numbers might be in the bigger half.\\n\\t* The middle number could be the other bigger number.\\n\\n    So we should distinguish between these two scenarios!\\n\\t\\n\\tSince we are sure that the smaller part has all its elements to be equal, we will compare the middle number with any number in the smaller part.\\n\\t* If the middle number is the same as the first element in the smaller part, then it means both two bigger numbers are in the bigger half. Since the bigger half is even length, we can use the follow up solution for arrays with even length.\\n\\t* If the middle number is bigger than the first element in the smaller part, then it means in the bigger part we can find only one bigger number. We can use similar solution we wrote for the basic question to find out the bigger number in the bigger part. Then we will compare the bigger number in the bigger part and the middle number to find out which one is bigger and it will be the biggest number in the end.\\n\\n\\n<br/>\\n\\n### Second follow up(What if there is one number that is bigger than other numbers and one number that is smaller than other numbers?)\\nIf we have arrays like this [50,50,50,50,50,50,50,50,1,99], we might need to compare all adjacent elements pairs. So the worst case will be O(arr.length). **Not sure if will be better solution on this?**\\n\\n\\n\\n<br/>"
                    },
                    {
                        "username": "BristolJ",
                        "content": "What the hell is this question?? Do things like this actually occur while coding for companies?\\n"
                    },
                    {
                        "username": "jas213",
                        "content": "ALERT- close to solution but not quite - \nanyone knows what's wrong with this code?\n\n `\nclass Solution:\n    def getIndex(self, reader: 'ArrayReader') -> int:\n\n        n = reader.length()\n        l, r = 0, n-1\n\n        while (l < r):\n            mid = (l+r)//2\n            count +=1\n            if reader.compareSub(l, mid, mid+1, r) == 1:\n                r=mid\n            else:\n                l = mid+1\n        return l\n`"
                    },
                    {
                        "username": "st-ones",
                        "content": "Don\\'t forget about curly braces for `length()` in js :)"
                    },
                    {
                        "username": "mxn42",
                        "content": "Ternary Search is better, it's $$O(log_3 N)$$ instead of $$O(log_2 N)$$\nhttps://en.wikipedia.org/wiki/Ternary_search\n\nThis problem is similar to the [Balance puzzle](https://en.wikipedia.org/wiki/Balance_puzzle).\n\nEach time divide the interval into 3 thirds. Compare 2 of them. If one is heavier, we'll search in it. If they are equal, we'll search in the rest third.\n\n[JavaScript solution](https://leetcode.com/problems/find-the-index-of-the-large-integer/solutions/3060122/javascript-neat-ternary-search-o-log3-n/)"
                    },
                    {
                        "username": "ramtulasi19",
                        "content": "question explanation is unclear!!"
                    }
                ]
            }
        ]
    }
]